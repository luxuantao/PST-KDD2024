<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Function Secret Sharing: Improvements and Extensions</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Elette</forename><surname>Boyle</surname></persName>
							<email>elette.boyle@idc.ac.il</email>
						</author>
						<author>
							<persName><forename type="first">Niv</forename><surname>Gilboa</surname></persName>
							<email>gilboan@bgu.ac.il</email>
						</author>
						<author>
							<persName><forename type="first">Yuval</forename><surname>Ishai</surname></persName>
							<email>yuvali@cs.technion.ac.il</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">IDC Herzliya</orgName>
								<address>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Ben Gurion University</orgName>
								<address>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Function Secret Sharing: Improvements and Extensions</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">DC0EC67938358BC6CB9E5E14111C9F37</idno>
					<idno type="DOI">10.1145/2976749.2978429</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:32+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Function secret sharing</term>
					<term>private information retrieval</term>
					<term>secure multiparty computation</term>
					<term>homomorphic encryption</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Function Secret Sharing (FSS), introduced by Boyle et al. (Eurocrypt 2015), provides a way for additively secret-sharing a function from a given function family F. More concretely, an m-party FSS scheme splits a function f : {0, 1} n → G, for some abelian group G, into functions f1, . . . , fm, described by keys k1, . . . , km, such that f = f1 + . . . + fm and every strict subset of the keys hides f . A Distributed Point Function (DPF) is a special case where F is the family of point functions, namely functions f α,β that evaluate to β on the input α and to 0 on all other inputs.</p><p>FSS schemes are useful for applications that involve privately reading from or writing to distributed databases while minimizing the amount of communication. These include different flavors of private information retrieval (PIR), as well as a recent application of DPF for large-scale anonymous messaging.</p><p>We improve and extend previous results in several ways:</p><p>• Simplified FSS constructions. We introduce a tensoring operation for FSS which is used to obtain a conceptually simpler derivation of previous constructions and present our new constructions.</p><p>• Improved 2-party DPF. We reduce the key size of the PRG-based DPF scheme of Boyle et al. roughly by a factor of 4 and optimize its computational cost. The optimized DPF significantly improves the concrete costs of 2-server PIR and related primitives.</p><p>• FSS for new function families. We present an efficient PRG-based 2-party FSS scheme for the family of decision trees, leaking only the topology of the tree and the internal node labels. We apply this towards FSS for multi-dimensional intervals. We also present a general technique for extending FSS schemes by increasing the number of parties.</p><p>• Verifiable FSS. We present efficient protocols for verifying that keys (k * 1 , . . . , k * m ), obtained from a potentially malicious user, are consistent with some f ∈ F.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>In this work we continue the study of Function Secret Sharing (FSS), a primitive that was recently introduced by Boyle et al. <ref type="bibr" target="#b7">[7]</ref> and motivated by applications that involve private access to large distributed data.</p><p>Let F be a family of functions f : {0, 1} n → G, where G is an abelian group. An m-party FSS scheme for F provides a means for "additively secret-sharing" functions from F. Such a scheme is defined by a pair of algorithms (Gen, Eval). Given a security parameter and a description of a function f ∈ F , the algorithm Gen outputs an m-tuple of keys (k1, . . . , km), where each key ki defines the function fi(x) = Eval(i, ki, x). The correctness requirement is that the functions fi add up to f , where addition is in G; that is, for any input x ∈ {0, 1} n we have that f (x) = f1(x) + . . . + fm(x). The security requirement is that every strict subset of the keys computationally hides f . A naive FSS scheme can be obtained by additively sharing the entire truth-table of f . The main challenge is to obtain a much more efficient solution, ideally polynomial or even linear in the description size of f . The simplest nontrivial special case of FSS is a Distributed Point Function (DPF), introduced by Gilboa and Ishai <ref type="bibr" target="#b18">[18]</ref>. A DPF is an FSS for the family of point functions, namely functions f α,β : {0, 1} n → G for α ∈ {0, 1} n and β ∈ G, where the point function f α,β evaluates to β on input α and to 0 on all other inputs. Efficient constructions of 2-party DPF schemes from any pseudorandom generator (PRG), or equivalently a one-way function (OWF), were presented in <ref type="bibr" target="#b18">[18,</ref><ref type="bibr" target="#b7">7]</ref>. This was extended in <ref type="bibr" target="#b7">[7]</ref> to more general function families, including the family of interval functions f [a,b] that evaluate to 1 on all inputs x in the interval [a, b] and to 0 on all other inputs. For m ≥ 3, the best known PRGbased DPF construction is only quadratically better than the naive solution, with key size ≈ √ N , where N = 2 n <ref type="bibr" target="#b7">[7]</ref>. We consider here the case m = 2 by default.</p><p>On the high end, polynomial-time FSS schemes for arbitrary polynomial time functions are implied by indistinguishability obfuscation <ref type="bibr" target="#b7">[7]</ref> and by variants of fully homomorphic encryption <ref type="bibr" target="#b7">[7,</ref><ref type="bibr" target="#b14">14]</ref>. In the present work we mainly consider PRG-based FSS schemes, which have far better concrete efficiency and are powerful enough for the applications we describe next.</p><p>FSS schemes are motivated by two types of applications: ones that involve privately reading from a database held by m servers, and ones that involve privately writing (or incrementing) an array which is secret-shared among m servers. In both cases, FSS can be used to minimize the communication complexity. We illustrate two concrete application scenarios below and refer the reader to Appendix A for a more detailed exposition.</p><p>For a typical "reading" application, consider the problem of 2-server Private Information Retrieval (PIR) <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b8">8]</ref>. In the basic flavor of PIR, the two servers hold a database of N strings (x1, . . . , xN ), and a client wishes to retrieve xα without revealing α to either of the two servers. PIR in this setting can be implemented by having the client distribute the point function fα,1 : [N ] → Z2 between the servers. Concretely, the client generates a pair of keys (k1, k2) which define additive shares f1, f2 of fα,1, and sends each key to a different server. On input ki, server i sends back the sum N j=1 xjfi(j), where each xj is viewed as an element in Z 2 . The client can recover xα by taking the exclusive-or of the two -bit strings it receives.</p><p>Still relying only on a standard DPF, this can be directly generalized to private search by keywords (returning the payload associated with a private -bit keyword), private search on streaming data <ref type="bibr" target="#b27">[27,</ref><ref type="bibr" target="#b15">15,</ref><ref type="bibr" target="#b7">7]</ref>, and more. FSS for interval functions can be used to privately search values in a secret range. Realizing similar private search functionalities using standard PIR protocols requires the use of suitable data structures, which incur a significant additional overhead in round complexity, storage, and cost of updates <ref type="bibr" target="#b9">[9]</ref>. In general, FSS for a function family F can be used to efficiently perform searches defined by predicates from F.</p><p>For a typical "writing" application, consider the following example from <ref type="bibr" target="#b7">[7]</ref>. Suppose that we want to collect statistics on web usage of mobile devices without compromising the privacy of individual users, and while allowing fast collection of real-time traffic data for individual web sites. A DPF provides the following solution. An array of counters is additively shared between 2 servers. A client who visits URL α can now secret-share the point function f = fα,1 over a sufficiently large group G = ZM and each server i updates its shared entry of each URL αj by locally adding fi(αj) to its current share of αj. Note that the set of URLs αj used to index entries of the array does not need to include the actual URL α visited by the client, and in fact it can include only a selected watchlist of URLs which is unknown to the client. A different "writing" application for DPF was proposed in the context the Riposte system for anonymous messaging <ref type="bibr" target="#b11">[11]</ref>. In this system, messages from different clients are mixed by having each client privately write the message to a random entry in a distributed array.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Our Contribution</head><p>Motivated by applications of FSS, we continue the study of efficient constructions that can be based on any PRG. We improve and extend previous results from <ref type="bibr" target="#b7">[7]</ref> in several directions.</p><p>Simplified FSS constructions. We introduce a conceptually simple "tensoring" operation for FSS, which we use both to rederive previous constructions and obtain some of the new constructions we describe next.</p><p>Improved 2-party DPF. We reduce the key size of the PRG-based DPF scheme of Boyle et al. roughly by a factor of 4 and optimize its computational cost. In an AES-based implementation, the key size of a DPF is equivalent to roughly a single AES key per input bit. We provide further optimizations for the case of DPF with a single-bit output and for reducing the computational cost of evaluating the DPF of the entire domain (as needed, for instance, in the PIR application described above). The optimized DPF can be used to implement 2-server PIR protocols in which the communication overhead is extremely small (e.g., roughly 2.5K bits are sent to each server for retrieving from a database with 2 25 records) and the computation cost on the server side is typically dominated by the cost of computing the XOR of half the data items. More concretely, the additional computational cost of expanding the DPF key for an N -record database consists of roughly N/64 AES operations. In the case of private keyword search, retrieving the payload associated with an 80-bit keyword requires sending less than 10K bits. See Table <ref type="table" target="#tab_0">1</ref> for more details on the concrete efficiency of our DPF construction and Appendix B for more details on the PIR application and a comparison with alternative approaches from the literature.</p><p>FSS for new function families. We present an efficient PRG-based 2-party FSS scheme for the family of decision trees, leaking only the topology of the tree (i.e., the shape of the graph) and the internal node labels (i.e., which input variable labels each node). Our construction hides the labels of edges and leaves. We apply this towards PRG-based FSS for multi-dimensional intervals, e.g., capturing conjunction queries or search restricted to a geographical region. We also present a general technique for extending the expressive power of FSS schemes by increasing the number of parties. Concretely, we show how to obtain FSS schemes for the family of all products of pairs of functions from two given families that are realized by FSS. This can be applied towards more efficient solutions for multi-dimensional intervals, though with a larger number of parties.</p><p>Verifiable FSS. In both types of applications of FSS discussed above, badly formed FSS keys can enable a malicious client to gain an unfair advantage. The effect of malicious clients can be particularly devastating in the case of "writing" applications, where a single badly formed set of keys can corrupt the entire data. We present efficient protocols for verifying that keys (k * 1 , . . . , k * m ) are consistent with some f ∈ F. Our techniques make black-box use of the underlying FSS scheme, and avoid the cost of general-purpose secure computation techniques. Our verification protocols make a novel use of sublinear verification techniques (including special-purpose linear sketching schemes and linear PCPs) and combine them with MPC protocols that exploit correlated randomness from an untrusted client for better efficiency. These techniques may be applicable beyond the context of verifiable FSS.</p><p>Organization. Useful definitions appear in Section 2. Several FSS constructions, including the tensor product generalization, optimized DPF and evaluating a DPF on the entire domain are presented in Section 3. Definitions and protocols for verifiable FSS are the focus of Section 4. The appendix discusses applications of FSS and concrete performance for one specific application -two-server PIR. Due to lack of space, the proofs of claims in this work and additional material are postponed to the full version of the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PRELIMINARIES</head><p>We extend the definition of function secret sharing from <ref type="bibr" target="#b7">[7]</ref> by allowing a general specification of the allowable leakage, namely the partial information about the function that can be revealed.</p><p>A function family is defined by a pair F = (PF , EF ), where PF ⊆ {0, 1} * is an infinite collection of function descriptions f , and EF : PF ×{0, 1} * → {0, 1} * is a polynomialtime algorithm defining the function described by f . Concretely, each f ∈ PF describes a corresponding function f : D f → R f defined by f (x) = EF ( f , x). We assume by default that D f = {0, 1} n for a positive integer n and always require R f to be a finite Abelian group, denoted by G. When there is no risk of confusion, we will sometimes write f instead of f and f ∈ F instead of f ∈ PF . We assume that f includes an explicit description of both D f and R f as well as a size parameter S f .</p><p>We let Leak( f ) capture partial information about f that can be leaked. When Leak is omitted it is understood to output D f and R f . (This will be sufficient for most classes considered in this work; for more general classes, one also needs to leak the size S f .)</p><p>As in <ref type="bibr" target="#b7">[7]</ref>, we consider by default an "additive" representation of the output (i.e., an output y is split into group elements y1, . . . , ym that add up to y), rather than settle for an arbitrary compact output representation. The additive representation is critical for the applications we consider and is achieved by our constructions. Definition 2.1 (FSS: Syntax). An m-party function secret sharing (FSS) scheme is a pair of algorithms (Gen, Eval) with the following syntax:</p><p>• Gen(1 λ , f ) is a PPT key generation algorithm, which on input 1 λ (security parameter) and f ∈ {0, 1} * (description of a function f ) outputs an m-tuple of keys (k1, . . . , km). We assume that f explicitly contains an input length 1 n , group description G, and size parameter S (see above).</p><p>• Eval(i, ki, x) is a polynomial-time evaluation algorithm, which on input i ∈ [m] (party index), ki (key defining fi : {0, 1} n → G) and x ∈ {0, 1} n (input for fi) outputs a group element yi ∈ G (the value of fi(x), the i-th share of f (x)).</p><p>When m is omitted, it is understood to be 2. When m = 2, we sometimes index the parties by i ∈ {0, 1} rather than i ∈ {1, 2}.</p><p>Definition 2.2 (FSS: Security). Let F = (PF , EF ) be a function family and Leak : {0, 1} * → {0, 1} * be a function specifying the allowable leakage. Let m (number of parties) and t (secrecy threshold) be positive integers. An m-party t-secure FSS for F with leakage Leak is a pair (Gen, Eval) as in Definition 2.1, satisfying the following requirements.</p><p>• Correctness: For all f ∈ PF describing f : {0, 1} n → G, and every x ∈ {0, 1} n , if (k1, . . . , km) ← Gen(1 λ , f ) then Pr m i=1 Eval(i, ki, x) = f (x) = 1.</p><p>• Secrecy: For every set of corrupted parties S ⊂ [m] of size t, there exists a PPT algorithm Sim (simulator), such that for every sequence f1, f2, . . . of polynomialsize function descriptions from PF , the outputs of the following experiments Real and Ideal are computationally indistinguishable:</p><p>-Real(1 λ ): (k1, . . . , km) ← Gen(1 λ , fλ ); Output (ki)i∈S.</p><p>-Ideal(1 λ ): Output Sim(1 λ , Leak( fλ )).</p><p>We will also use the natural concrete security variant of (T, )-secure FSS. When Leak is omitted, it is understood to be the function Leak( f ) = (1 n , G) where 1 n and G are the input length and group description contained in f . When t is omitted it is understood to be m -1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.3 (Distributed Point Function).</head><p>A point function f α,β , for α ∈ {0, 1} n and β ∈ G, is defined to be the function f : {0, 1} n → G such that f (α) = β and f (x) = 0 for x = α. A Distributed Point Function (DPF) is an FSS for the family of all point functions, with the default leakage (i.e., Leak( f ) = (1 n , G)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">NEW FSS CONSTRUCTIONS FROM ONE-WAY FUNCTIONS</head><p>In this section, we present a collection of new FSS constructions whose security relies only on one-way functions. At the core of our new results is a new procedure for combining FSS schemes together via a "tensoring" operation, to obtain FSS for a more expressive function class. A direct iterative execution of this operation with two different recursion parameters reproduces both the DPF constructions of Gilboa and Ishai <ref type="bibr" target="#b18">[18]</ref> and the (seemingly quite different) tree-based DPF construction from <ref type="bibr" target="#b7">[7]</ref>.</p><p>Further exploring this operation, we make progress in two directions:</p><p>Improved efficiency. We demonstrate new optimizations for the case of DPFs, yielding concrete efficiency improvements over the state-of-the-art constructions (for both DPFs and FSS and for interval functions) <ref type="bibr" target="#b7">[7]</ref>, dropping the key size of an n-bit DPF from 4n(λ + 1) down to just n(λ + 2) bits. We also provide a new procedure for efficiently performing a full domain DPF evaluation (i.e., evaluating on every element of the input domain), a task which occurs frequently within PIR-style applications.</p><p>Extended expressiveness. Then, by exploiting the generalization of the procedure, we construct FSS for the class of polynomial-sized decision trees. This enables applications such as multi-dimensional interval queries.</p><p>We also demonstrate an orthogonal means of obtaining increased FSS expressibility, achieving FSS for the product of two supported function classes, in exchange for requiring a larger number of parties m.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">DPF Tensor Operation</head><p>Given the following three tools: (1) a DPF scheme FSS • = (Gen • , Eval • ) for the class of multi-bit point functions F • , (2) an FSS scheme (Gen F , Eval F ) for an arbitrary class of functions F whose keys are pseudorandom (and support an additive group structure), and (3) a pseudorandom generator, we construct an FSS scheme for the tensor of the function family F with the class of single-bit point functions: that is, functions g α,f (x, y) which evaluate to f (y) on inputs (α, y), and to 0 elsewhere. Note that if F • supports n1-bit inputs and F supports n2-bit inputs then the resulting function class F • ⊗ F takes (n1 + n2)-bit inputs. The key size of the resulting FSS (Gen ⊗ , Eval ⊗ ) will correspond to size⊗(n1+n2, λ) = size•(n1, λ)+ 2sizeF (n2, λ). Remark 3.1. In the case when F is itself a class of (multibit) point functions F • , the result of this tensor F</p><formula xml:id="formula_0">• n 1 ⊗ F • n 2</formula><p>will correspond directly to another class of (multi-bit) point functions F • n 1 +n 2 with larger domain. Repeating this process iteratively by doubling the input bit-length in each step (n1 = n2) yields a construction isomorphic to that from <ref type="bibr" target="#b18">[18]</ref>, with key size O(n log 2 3 ) bits. Alternatively, repeating this process with n2 = 1 at each step yields the construction from <ref type="bibr" target="#b7">[7]</ref>, with key size 4n(λ + 1) bits.</p><p>Intuitively, the transformation works as follows. We use the DPF to generate keys for a function which outputs a random seed concatenated with the bit 1 on the special input α, and 0 everywhere else. This means (viewing the scheme with "subtractive" reconstruction, for simplicity) that when evaluating at x = α the parties reach independent random output seeds s0, s1, and disagreeing bits t0 = 1 -t1, whereas everywhere else their outputs will agree. The s b 's can then be used to generate long(er) masks (via a PRG) to hide information from the other party. In the tensor construction, the masks are used to hide FSS keys from the second scheme: the parties are both given both keys to the second FSS, but with one masked by the PRG-output of s0 and the other masked by the PRG-output of s1. These are the "correction words." The bit t b tells the party which of the correction words to use. When t0 = t1 and s0 = s1, the parties will perform identical actions, and their final output will be the same. For the special input α, they will exactly remove the masks and evaluate using the revealed FSS keys. The pseudorandomness of the F FSS keys means the parties cannot identify which input is the special one.</p><p>Note that new keys have the form of one key from the DPF and two elements in the key space of the second FSS: that is, the resulting key size size⊗(n1</p><formula xml:id="formula_1">+ n2, λ) is indeed size•(n1, λ) + 2sizeF (n2, λ).</formula><p>We defer a formal treatment of the tensor product operation to the full version.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Optimized DPF and PIR-like Applications</head><p>For input length n, security parameter λ, and 1-bit outputs, the best known DPF constructions <ref type="bibr" target="#b7">[7]</ref> achieved key size 4n(λ + 1) bits (the key size grows accordingly for larger outputs). We now demonstrate an optimized DPF construction stemming from the tensor approach, which drops the key size down to n(λ + 2) bits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 3.2 (Optimized DPF). Assuming a pseudorandom generator</head><formula xml:id="formula_2">G : {0, 1} λ → {0, 1} 2(λ+1) , then the scheme (Gen • , Eval • ) in Figure 1 is a secure DPF for f α,β : {0, 1} n → G with key size n(λ + 2) + log 2 |G|.</formula><p>We obtain savings in two different ways. First, we modify the generic tensor transformation (accordingly, the scheme of <ref type="bibr" target="#b7">[7]</ref>) so that instead of needing two correction words for each level, we can suffice with one. The reason this is possible here is because the "second" FSS scheme in this instance is a single-bit-input DPF, which is simply a secret shared string of the truth table. For such FSS we do not need to enforce full control over the unmasked key values that the parties will compute in order to guarantee correct evaluation, but rather only over the difference between the values. This saves us one factor of 2.</p><p>Second, we are able to shrink the size of each correction word by roughly a factor of 2 (explicitly, from 2(λ + 1) bits to (λ + 2)). Recall that the goal of the correction word is to shift a (pseudo-)random string (a1, a2) so that it agrees with a second pseudo-random string (b1, b2) on one half i ∈ {0, 1}, and remains independent on the other half. Previous constructions achieved this via shifting by a correction word (c1, c2), where ci = ai ⊕bi, and c1-i was a random offset. We observe that the introduced randomness in the latter shift is unnecessary, and instead shift both halves by the same offset. Since a1-i and b1-i were (pseudo-)random and independent to begin with, conditioned on ai, bi, this property will be preserved with the shift ai ⊕ bi. This provides us with our second saved factor of 2.</p><p>The pseudocode of our DPF construction is given in Figure <ref type="figure" target="#fig_0">1</ref>. We provide a formal proof of security within the full version.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Full Domain Evaluation</head><p>Some applications of DPF require running the Eval algorithm on every element of the input domain. As an example, consider two-server Private Information Retrieval (PIR) in which two servers S0, S1 hold the same N = 2 n group elements x0, . . . , xN-1 ∈ G, for some abelian group G, and a user wishes to retrieve xα while hiding α.</p><p>PIR can be implemented using DPF as described in the introduction. A straightforward implementation of this idea requires each server to run Eval • N times independently, once for each input xj. We show two improvements to this naïve approach of evaluating the whole input domain, leveraging the structure of our particular construction.</p><p>Consider a rooted binary tree whose leaves are the elements of the input domain and the path from the root to a leaf reflects the binary representation of the element's index. In other words, the path moves from the current node to the left child if the next bit in the representation is 0 and to the right child if the next bit in the representation is 1. In our construction Eval • (b, k b , x) traverses the path from the root to a leaf x and the naïve algorithm for full domain evaluation traverses each of these paths resulting in time O(nN ). However, for every node in the tree there is a unique τ (i) value computed by any execution of Eval • that traverses the node. Since the τ values and the correction words are sufficient to compute the result of Eval • on a single point computing full domain evaluation can be carried out by computing the τ values for each node in the tree which requires O(N ) time.</p><p>A second improvement is the early termination optimization for small output groups. The correction word CW (n+1) in Gen • is the output β masked by the expansion of two seeds. If the representation of β is short then several output values can be "packed" into CW (n+1) . For any node V of depth ν in the tree there are 2 n-ν leaves in its sub-tree, or 2 n-ν input elements with a shared prefix that ends at V . If the size of CW (ν) is at least 2 n-ν times the output length then the main loop of both Gen • and Eval • can terminate at level ν instead of at level n. In this case CW (ν) will be a sequence of group elements masked by the two expanded seeds. The sequence will have the output β in the location specified by the last n -ν bits of α and the unit elements of  <ref type="figure" target="#fig_0">1</ref>. In the case of single bit outputs we use the additional early termination optimization, which is presented in Section 3.2.1. The precise analytic expression for the key size is somewhat cumbersome, but is reflected in the exact key size for each concrete input domain. We implement the PRG operation expanding s ∈ {0, 1} 127 to 256 bits by computing AES s||0 (0)||AES s||0 <ref type="bibr" target="#b1">(1)</ref>.</p><formula xml:id="formula_3">Optimized Distributed Point Function (Gen • , Eval • ) Let G : {0, 1} λ → {0, 1} 2(λ+1) a pseudorandom generator.</formula><p>Let Convert G : {0, 1} λ → G be a map converting a random λ-bit string to a pseudorandom group element of G.</p><formula xml:id="formula_4">Gen • (1 λ , α, β, G): 1: Let α = α1, . . . , αn ∈ {0, 1} n be the bit decomposition. 2: Sample random s (0) 0 ← {0, 1} λ and s (0) 1 ← {0, 1} λ 3: Sample random t (0) 0 ← {0, 1} and take t (0) 1 ← t (0) 0 ⊕ 1 4: for i = 1 to n do 5: s L 0 ||t L 0 s R 0 ||t R 0 ← G(s (i-1) 0 ) and s L 1 ||t L 1 s R 1 ||t R 1 ← G(s (i-1) 1</formula><p>). 6:</p><formula xml:id="formula_5">if αi = 0 then Keep ← L, Lose ← R 7: else Keep ← R, Lose ← L 8: end if 9: sCW ← s Lose 0 ⊕ s Lose 1 10: t L CW ← t L 0 ⊕ t L 1 ⊕ αi ⊕ 1 and t R CW ← t R 0 ⊕ t R 1 ⊕ αi 11: CW (i) ← sCW ||t L CW ||t R CW 12: s (i) b ← s Keep b ⊕ t (i-1) b</formula><p>• sCW for b = 0, 1 13:</p><formula xml:id="formula_6">t (i) b ← t Keep b ⊕ t (i-1) b • t Keep CW for b = 0, 1 14: end for 15: CW (n+1) ← (-1) t n 1 β -Convert(s (n) 0 ) + Convert(s (n) 1 ) , with addition in G 16: Let k b = s (0) b ||t (0) b ||CW (1) || • • • ||CW (n+1) 17: return (k0, k1) Eval • (b, k b , x): 1: Parse k b = s (0) ||t (0) ||CW (1) || • • • ||CW (n+1) 2: for i = 1 to n do 3:</formula><p>Parse</p><formula xml:id="formula_7">CW (i) = sCW ||t L CW ||t R CW 4: τ (i) ← G(s (i-1) ) ⊕ (t (i-1) • sCW ||t L CW ||sCW ||t R CW ) 5:</formula><p>Parse G in every other location. The two improvements described above lead to the following theorem statement. Theorem 3.3 (Full domain evaluation). Let λ be a security parameter, G be an abelian group and = log |G|. Let z = max{λ, } and let G be a PRG G : {0, 1} λ → {0, 1} 2z+1 . There exists a full domain evaluation protocol for f α,β : {0, 1} n → G with key size at most (n -log z )(λ + 2) and at most 2 n z PRG operations.</p><formula xml:id="formula_8">τ (i) = s L ||t L s R ||t R ∈ {0, 1} 2(λ+1) 6: if xi = 0 then s (i) ← s L , t (i) ← t L 7: else s (i) ← s R and t (i) ← t R 8: end if 9: end for 10: return (-1) b Convert(s (n) ) + t (n) • CW (n+1) ∈ G</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">FSS for Decision Trees</head><p>We now describe how the tensoring approach can be utilized to provide FSS for the broader class of decision trees. A decision tree is defined by a tree topology, variable labels on each node v (which can take values in some node-specific set Sv), value labels on each edge (in our case, corresponding to some element in Sv), and output labels on each leaf node.</p><p>In our construction, the key size is roughly λ•|V |, where V is the set of nodes, and evaluation on a given input requires |V | executions of a pseudorandom generator, and a comparable number of additions. The FSS is guaranteed to hide the secret edge value labels and leaf output labels (which we refer to as "Decisions"), but (in order to achieve this efficiency) reveals the base tree topology and node variable assignments (which we refer to as "Tree"). As a simple illustrative example, consider a decision tree representation of the OR function on n bits xi. The tree topology includes a length-n chain of nodes (each labeled by a unique input xi), with edges all labeled by 0, ending in a terminal output node (labeled by 0). In addition, from each internal node there is a second edge, labeled by 1, terminating in a leaf labeled by 1. In this example, the leaked information "Tree" consists of the structure of the tree and the n node labels xi; the hidden information "Decisions" consists of the choice of condition labels 0,1 on each edge, as well as the 0,1 leaf output labels. In particular, the resulting FSS key cannot be distinguished from the analogous FSS key for the AND function, which has an identical structure but with the 0 and 1 roles reversed.</p><p>Note that FSS for decision trees could be attained directly from a linear combination of separate DPFs: for each leaf node, simply include an additional corresponding DPF. However, such an approach is wasteful; in particular, our DPF constructions have the property that a DPF key contains within it explicitly DPF keys for each of its prefixes. Because of this, we can optimize the required key size and computation, to leverage the "shared backbone" of paths within the decision tree. Our construction instead directly applies the tensoring approach to "append" each node onto the backbone structure, one by one.</p><p>More specifically, our construction is recursive. The key generation procedure Gen starts from the leaves. In each step, we obtain an FSS key for a given tree structure Γ by sampling a key for a smaller tree Γ with all siblings of one leaf node in Γ removed (say, children ua of a node v). The output value we select for this newly formed leaf v in the restricted decision tree program will be the same structure s||1 ∈ {0, 1} λ+1 as in the tensor operation from the previous section. And, in an analogous fashion, we will construct a "correction word" associated with this node v, which contains the target values for its children, but masked by the PRG-output of the parties' respective shares of s (i.e., G(s b )). The key thus consists of a correction word for every node, which is an element of {0, 1} λ+1 for each internal node, and is an element of the output group G for each leaf node. Security of the scheme follows the same argument as in the tensor.</p><p>The evaluation procedure Eval begins from the root node, and calls a recursive function EvalNode. When executed on a leaf, EvalNode outputs its correction word directly. When executed on an internal node, EvalNode outputs the sum of EvalNode on each of its children.</p><p>We refer the reader to the full version for formal definitions, constructions, and proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Constant-dimension intervals.</head><p>A sample application of our FSS construction for decision trees is for constant ddimensional interval queries: that is, functions f (x1, . . . , x d ) which evaluate to a selected nonzero value precisely when ai ≤ xi ≤ bi for some secret interval ranges (ai, bi) i∈ <ref type="bibr">[d]</ref> .</p><p>(See, e.g., <ref type="bibr" target="#b28">[28]</ref> for supporting a similar functionality in the context of searching on encrypted data.) For n-bit inputs of length we achieve FSS for d-dimensional intervals with key size and computation time O(n d ). For small values of d, such as d = 2 for supporting a conjunction of intervals, this yields solutions with reasonably good concrete efficiency. The construction can be achieved as follows. First, we reduce from general d-dimensional intervals to the problem of 2 d "special" intervals, whose left-boundary ai is equal to 0. This can be done by means of a linear combination of special intervals via inclusion-exclusion (and recalling that FSS schemes combine linearly <ref type="bibr" target="#b7">[7]</ref>).</p><p>To illustrate the construction of FSS for these special ddimensional intervals, consider the case of d = 1 and 2. Observe that a 1-dimensional special interval for n-bit inputs can be expressed directly as a decision list; that is, a decision tree with one long length-n path u1, . . . , un with edges (ui, ui+1), and single terminal edges with appropriate 0/1 output labels departing from each node along the path. (Namely, a generalization of the OR function construction discussed earlier).</p><p>To extend to 2 dimensions, the 0/1 terminal edges from nodes ui are each replaced by a length-n decision list (as above), this time labeled by the corresponding bits of the second input y. Departing from the primary path corresponds to either falling outside the x-dimension interval (in which case the final leaf will be labeled 0) or within it, in which case the leaf will be labeled based on the 1-dimensional y interval. A similar approach can be taken to extend to general d dimensions, for constant d.</p><p>We remark that revealing the topology and node labels of the utilized d-dimension decision tree (as is the case in our FSS for decision trees construction) does not adversely affect security, since this structure is identical across any choice of secret interval boundaries. Rather, the only thing that differs in the construction is the choice of edge and leaf node labels, which is precisely what is hidden by our FSS construction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">A Product Operator for FSS</head><p>In this section we present a simple technique for increasing the expressive power of FSS by increasing the number of parties. We consider here function families F such that for each f ∈ F the output range R f is equipped with a ring structure. For two functions f1, f2 with the same input domain and output ring, we naturally define the product f = f1 • f2 by f (x) = f1(x)f2(x). Definition 3.5 (Product of function families). Let F1, F2 be function families. Define</p><formula xml:id="formula_9">F1•F2 = {f1 • f2 : f1 ∈ F1, f2 ∈ F2, D f 1 = D f 2 , R f 1 = R f 2 }</formula><p>The product operator can be used for expressing function classes that capture conjunctions. For instance, if the input x is partitioned into (x1, x2) and F1, F2 are the classes of interval functions applied to x1 and x2 respectively, the class F1 • F2 is the class of all two-dimensional intervals. Compared with the solution based on decision trees, we will get better efficiency (linear in the bit-length of the input instead of quadratic) at the cost of using a larger number of parties.</p><p>The following theorem captures the basic FSS product operator. (Here we use (m, t)-FSS as an abbreviation for an m-party t-secure FSS.) In the full version we describe an alternative product operator that converts (m, m -1)-FSS schemes for classes Fi, 1 ≤ i ≤ m -1, into an (m, 1)-FSS (Gen, Eval) for F = m-1 i=1 Fi, where the key size for sharing f1 • f2 • • • f d is m -1 times the total key sizes required for sharing fi. Theorem 3.6. Let (Gen1, Eval1) be an (m1, t)-FSS for F1 and (Gen2, Eval2) be an (m2, t)-FSS for F2. Then there exists an (m1m2, t)-FSS (Gen, Eval) for F = F1 • F2 in which the size of the key produced by Gen on f1 • f2 is the sum of the key sizes of Gen1 on f1 and Gen2 on f2.</p><p>As a concrete instance, using a 3-party PRG-based DPF construction from <ref type="bibr" target="#b7">[7]</ref> (which achieves a quadratic improvement over a naive solution), one can get a nontrivial PRGbased (3, 1)-FSS that supports private searches involving a conjunction of two keywords or ranges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">VERIFIABLE FSS: HANDLING MALICIOUS CLIENTS</head><p>As discussed in the Introduction, FSS schemes are motivated by two types of applications: ones that involve privately reading from a database stored at two or more servers, and ones that involve privately writing into a secret-shared array. In both types of applications, badly formed FSS keys can enable a malicious client to gain an unfair advantage.</p><p>Consider, for example, an application of DPF for maintaining a secret data histogram, say for the purpose of website traffic analytics. The histogram count of each bin x ∈ [N ] is additively secret-shared between two servers over a large group G = Zp. A valid "increment α" query for a (hidden) bin α should correspond to secret shares of the point function fα,1 that evaluates to 1 at α and 0 at all other points. However, since each server sees only one share of the function (to hide the identity of α), neither server on its own has a way of verifying that the given shares really do encode such a "proper" point function. A malicious client may just as easily encode a function that increments item α by 100, effectively casting a "heavy" vote. Even worse, it may encode a "garbage" function f * that increments every bin by some random amount-effectively erasing all the prior existing counts. We seek efficient procedures for the servers to verify the validity of the function shared by the client before it is being processed, by using a small amount of server-to-server communication.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Modeling Verifiable FSS</head><p>We consider an FSS scheme where m the keys are generated by a potentially malicious client, but are processed by semi-honest servers, to which we refer from here on as parties. That is, the parties honestly follow the prescribed protocol, but try to infer as much information as possible about an honest client's secret function f from their view. We allow the parties to communicate over secure point-topoint channels, but try to minimize the communication to the extent possible. (Some form of communication between the parties is clearly necessary for verifying the consistency of the keys.) Finally, we make the simplifying assumption that parties can generate a common source of randomness which is unpredictable to the clients, and do not count this randomness towards the communication. In practice, this common source of randomness can be realized by having one of the parties pick a random PRF key and communicating it to all other parties. The same PRF key can be used to verify many FSS instances, as long as it is independent of the FSS keys.</p><p>We are interested in verification protocols that minimize communication between parties, do not involve the client beyond the initial key distribution, and do not involve any additional parties. This should be contrasted with a verification protocol from <ref type="bibr" target="#b11">[11]</ref> that involves an additional party and requires communication linear in the domain size.</p><p>Similarly to the verification protocol from <ref type="bibr" target="#b11">[11]</ref>, we would like our protocols to only make a black-box use of the underlying FSS scheme (which in our case translates into a black-box use of a PRG). The latter requirement is meant to rule out protocols that involve a generic use of secure computation for verifying that the keys form a valid output of Gen. To the end of realizing such a black-box verification, we are willing to slightly relax the goal by settling for the validity of the keys with respect to a given set of inputs. That is, the verification protocol is given a subset D of the input domain D as an additional input. The set D represents the set of inputs on which the function f will actually be evaluated, and hence may not be known to the client. The distinction between D and D is motivated by applications such as secure keyword search or range queries, where D is typically a tiny subset of D. However, in other applications of FSS, including PIR and distributed histograms, it is typically the case that D = D.</p><p>We allow the running time of the verification protocol, but not its communication complexity, to grow with the size of D . In fact, all verification protocols we present invoke Eval on every x ∈ D . This is typically not an efficiency bottleneck, since these evaluations are anyway necessary for the application. We expect our solutions to beat the concrete efficiency of applying practical general-purpose MPC protocols to the function defined by Gen except, perhaps, when D is very large.</p><p>The verification protocol should have the following soundness property: If the verification protocol is successful, then the parties are essentially convinced that the function f * effectively shared by the client is consistent with some f ∈ F on the domain D . Of course, the verification protocol should not reveal to the parties any information about the function f * beyond its validity.</p><p>We formalize the above requirements below. For simplicity we do not explicitly treat general leakage, since we will present verification protocols for FSS with standard leakage, namely where only the input domain D f and output domain R f are leaked. However, the definitions extend in a straightforward way to the general case. Definition 4.1 (Verifiable FSS). Let F be a class of functions. An (m, t)-verifiable FSS (VFSS) for F is a triplet of algorithms (Gen, Eval, Ver) such that (Gen, Eval) are an FSS for F as in Definition 2.2, and there exists a negligible function negl for which the following additional requirements hold.</p><p>• Syntax of Ver: Ver is an m-party interactive protocol. In the beginning of the protocol, each party i has a local input ki (presumably an output of Gen). In addition, all parties share the following common inputs: a security parameter 1 λ , an input domain D for (an unknown) f ∈ F, output domain R for f , and a subset D ⊆ D of relevant evaluation points. (An empty D is interpreted as D = D.) We also assume that the parties have access to a common source of randomness picked independently of the inputs, and do not count this randomness towards the communication complexity. In the end of the protocol, each party outputs "Accept" or "Reject."</p><p>• Completeness: If (k1, . . . , km) are valid outputs of Gen(1 λ , f ) for some f ∈ F with input domain D and output domain R, then for all D ⊆ D, in the execution of Ver on local inputs (k1, . . . , km) and common inputs D, D , R, all parties output "Accept" with probability 1.</p><p>• Soundness: Consider the following security experiment defined by a PPT adversary A running on input 1 λ : </p><formula xml:id="formula_10">(x) + . . . + f * m (x) = f (x) for all x ∈ D (where f * i (x) := Eval(i, k * i , x)).</formula><p>The soundness requirement is that every PPT A can only win the above game with negligible probability in λ.</p><p>• Secrecy: Following the (honest) execution of Ver on keys (k1, . . . , km) generated by Gen(1 λ , f ) (with an arbitrary D ⊆ D f ), the joint view of any t parties should not reveal anything about f except D f and R f . This is formalized as in the secrecy requirement of Definition 2.2, except that the output of Real includes the entire view of parties in S. When t is unspecified, it is understood to be m -1.</p><p>Selective failure attacks. While allowing D to be a strict subset of D is useful, it may also give rise to security vulnerabilities. First, the above soundness requirement does not rule out a correlation between the set D of relevant evaluation points and the event of rejecting. <ref type="foot" target="#foot_0">1</ref> While selective failure attacks can often be problematic, we would like to argue that they are not a major concern in the context of natural applications of verifiable FSS. First, as discussed earlier, verifiable FSS is most strongly motivated by "writing" scenarios, where we typically have D = D and the client learns nothing from the event of rejection. Even if we use D ⊂ D, in such scenarios the client does not need to be directly informed that an error has been detected, and his vote can be silently discarded. In any case, the price of being caught cheating typically outweighs the advantage of learning one bit of information about D .</p><p>A second type of attack that may apply to the case where D ⊂ D is when an invalid function shared by a malicious client coincides with a valid function when restricted to D . For instance, in a verifiable DPF protocol, a malicious client can share a function that has a nonzero output on many points (say, simultaneously voting for many candidates) in the hope that the function will have only one nonzero output on the (unknown) subset D . Both types of attacks are irrelevant to the case D = D, and they can be mitigated by incurring a penalty for being caught cheating.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Template for Verifiable FSS Protocols</head><p>We assume that the output domain G is of the form Z p , for a prime p and positive integer , and view it as the additive group of the (large) finite field F p . Our verification protocols typically achieve soundness error of O(1/|F|) by communicating just a constant number of field elements. To verify FSS over a small group, such as G = Z2, one can view G as a subgroup of the additive group of a sufficiently large field, say F = F 2 λ , and apply a verification scheme for an FSS over F. (This does not require any changes to Gen or Eval, only to make Ver view each output of Eval as an element of F.)</p><p>The high level idea of our verifiable protocols is the following. Let N = |D |. Consider the function family F defined by restricting F to the evaluation points in D . By locally applying Eval on the inputs in D , the parties obtain an additive secret sharing of a (long) vector y ∈ F N consisting of the values (f * (x)) x∈D . The parties need to verify that y is valid, namely it is consistent with F , using only a small amount of communication and without revealing information about y. For instance, in the case of point functions the vector y should satisfy the requirement that it has at most one nonzero entry.</p><p>The verification that y is well-formed is achieved via the following combination of randomized linear sketching and special-purpose MPC. The parties use their common source of randomness to pick a linear function L : F N → F d , where d is a small constant. The function L (also referred to as a "linear sketch") is picked from a carefully chosen distribution L that has the following properties:</p><p>1. Given z = L(y), one can decide (with negligible error probability over the choice of L) whether y is valid, namely it is consistent with F;</p><p>2. This decision procedure is "MPC friendly" in the sense that there is a very efficient MPC protocol Π MPC for verifying that a secret-shared vector z ∈ F d is of the right form.</p><p>Given a distribution L and an MPC protocol Π MPC as above, the protocol Ver proceeds as follows. Party i, holding a (long) additive share y i of y, locally compresses y i into z i = L(y i ). Then the parties run Π MPC for deciding whether to accept y as being consistent with F .</p><p>To further improve the efficiency of Π MPC , we let the FSS client distribute between the parties correlated randomness that is consumed by Π MPC . This correlated randomness can be incorporated into the keys produced by Gen and does not require additional interaction with the client. However, it is critical that the soundness of the verification hold even if this correlated randomness is distributed by a malicious client. Our solutions for this type of "client-assisted MPC" problems can be useful beyond the context of verifiable FSS.</p><p>To fully instantiate the above template, we need to specify the distribution L from which L is picked, the verification predicate V applied to z, and the MPC protocol Π MPC for (client-assisted) computation of V on the shares of z. See Figure <ref type="figure" target="#fig_2">2</ref> for a formal description of a verification protocol following this template. In Section 4.3 we will instantiate the sketching distribution L and in Section 4.4 we will instantiate the MPC protocol Π MPC .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Instantiating the Sketching Scheme (L, V)</head><p>In this section we propose several efficient instantiations of the sketching scheme (L, V) that apply to useful classes F and support very efficient MPC protocols for V. All instantiations rely on the standard Schwartz-Zippel (SZ) lemma, bounding the number of zeros of a low-degree polynomial. Due to space constraints we defer proofs to the full version.</p><p>DPF f α,β with β ∈ {0, 1} and F of characteristic &gt; 2. This is the most useful case for applications that involve voting or counting, where each client can increment a single counter by 1 or "abstain" by using β = 0. Here we use Lsq that picks random field elements r1, . . . , rN and outputs the matrix L ∈ F 2×N defined by L1,j = rj and L2,j = r 2 j . That is, each column of L contains a random field element and the square of this element. (In an actual implementation, L can be generated using a short PRF key picked by one of the parties and sent to all others.) The verification predicate Vsq, which will be realized by Π MPC , checks that the sketch z = (z1, z2) satisfies the condition Vsq(z1, z2) = z 2  1 -z2 = 0.</p><p>FSS Verification Template Ver(i, k * i ) Common inputs:</p><p>-Security parameter 1 λ ; -Input length 1 n , of FSS input domain D = {0, 1} n ; -FSS output group G ⊆ F, where F is a finite field and |F| ≥ 2 λ ; // Here λ can be taken to be a statistical security parameter.</p><p>-Subset D ⊆ D of size N . An empty D is interpreted as D = D; // Running time is linear in N .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Given algorithms:</head><p>-FSS evaluation algorithm Eval;</p><p>-Matrix sampler L(F, N ), outputting a matrix L ∈ F d×N (for some constant d ≥ 1);</p><p>-Verification predicate V :</p><formula xml:id="formula_11">F d → F d ;</formula><p>-Client-assisted MPC protocol Π MPC for V.</p><p>1: Picking matrix: Let L ← L(F, N ) using common randomness; // Same L is used by all parties; L can be reused as long as it is independent of all k * i . 2: Applying Eval:</p><formula xml:id="formula_12">y i ← (Eval(i, k * i , x)) x∈D ; //y i ∈ F N 3: Local compression: Let z i ← L • y i ; //z i ∈ F d 4:</formula><p>Interactive verification: Run Π MPC on input z i using correlated randomness in k * i to evaluate V(z) and accept if and only if the output of Π MPC is the all-0 vector.  DPF f α,β with β ∈ {0, 1} and general F. We can eliminate the restriction on F by using a sketch of d = 3 field elements: L prod picks L ∈ F 3×N as a random matrix whose third row is the product of the first two. That is, L1,j = rj, L2,j = sj, and L3j = rjsj where the rj and sj are random and independent field elements. The verification predicate is V prod (z1, z2, z3) = z1z2 -z3.</p><p>Claim 4.3. Let F be any finite field. Suppose y ∈ F N is neither a unit nor the all-0 vector. Then</p><formula xml:id="formula_13">Pr [L ← L prod (F, N ); (z1, z2, z3) ← L • y : z3 = z1z2] ≤ 2/|F|.</formula><p>DPF f α,β with β ∈ {1, -1} and general F. Our next sketching procedure applies to general fields and, like the first procedure, only requires a sketch of d = 2 field elements. An additional difference is that the set of possible β values is {1, -1} instead of {0, 1}. In the case of fields of characteristic 2, this is equivalent to requiring that β = 1. Over other fields, one can either view the extra possibility as a feature, e.g., for votes that involve "liking" or "disliking" a candidate, or enforce the requirement that β = 1 as described below. Here we use L inv that picks random nonzero field elements r1, . . . , rN and define L ∈ F 2×N by L1,j = rj and L2,j = r -1 j . That is, each column of L contains a random field element and its inverse. The verification predicate is V inv (z1, z2) = z1z2 -1 = 0. While generating L using L inv is computationally more expensive than Lsq, its cost can be amortized since the same L can be used to verify many DPF keys.</p><p>Claim 4.4. Let F be any finite field. If y ∈ F N is neither a unit vector nor the negation of a unit vector, then</p><formula xml:id="formula_14">Pr [L ← L inv (F, N ); (z1, z2) ← L • y : z1z2 = 1] ≤ N/(|F|-1).</formula><p>DPF f α,β with β = 1. The above sketching schemes allow β to take two possible values. If we want to ensure that β = 1, it suffices to additionally check that the sum of all entries in y is equal to 1. Using our linear sketching framework, this can be done in both cases by adding to L an additional all-1 row and extending the verification predicate V. For instance, for d = 2, we extend V(z1, z2) into V (z1, z2, z3) = (V(z1, z2), z3 -1).</p><p>Note that the above two sketching schemes are only useful when D = D. When D is a strict subset of D, the resulting verifiable FSS would fail to be complete in the case α ∈ D , because in this case y is the all-0 vector which is rejected by the above sketching schemes.</p><p>DPF f α,β with unrestricted β ∈ F. The above sketching schemes natively support useful restrictions of β, namely either β ∈ {0, 1}, β ∈ {1, -1}, or β = 1. However, in some applications, such as "writing" applications in which a client is free to overwrite the entire contents of a single entry of an array, it is useful to support a DPF f α,β where β can be an arbitrary field element. To this end, we augment the general template in Figure <ref type="figure" target="#fig_2">2</ref> by allowing the verification predicate V to be non-deterministic. That is, V may depend an additional input w ∈ F that is secret-shared by the client as part of Gen. Given an honestly generated w, the verification succeeds, and even a maliciously generated w cannot increase the probability of accepting an invalid y.</p><p>To verify an arbitrary point function f α,β , we augment the previous verification predicates as follows:</p><p>• V sq (z1, z2, w) = z 2 1 -z2w, where an honest client uses w = β.</p><p>• V prod (z1, z2, z3, w) = z1z2 -z3w, where an honest client uses w = β.</p><p>• V inv (z1, z2, w) = z1z2 -w, where an honest client uses w = β 2 .</p><p>Completeness is easy to verify. To argue soundness, one can modify the previous case analysis to show that for any y with at least two nozero entries and for any fixed w ∈ F, the polynomial V still contains a monomial with a nonzero coefficient.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FSS for intervals.</head><p>In the full version, we present an extension of the above techniques to the class of interval functions f [a,b] that evaluate to 1 on all x ∈ [a, b] (where x is interpreted as an integer in [0, 2 n -1]) and evaluates to 0 on all other inputs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Instantiating the MPC Protocol Π MPC</head><p>The previous sketching schemes reduce the verification that a long vector y is "well formed" (i.e., belongs to some set B ⊆ F N defined by F and D ), to computing a simple, low-degree predicate V on a short vector z given an additive sharing z 1 , . . . , z m of z.</p><p>Given the simple nature of the predicates V we use, the parties could compute V on their own. For instance, if there is an honest majority of parties (t &lt; m/2) they could use a "BGW-style" protocol <ref type="bibr" target="#b4">[4]</ref>, or if there is no honest majority they could use a "GMW-style" protocol <ref type="bibr" target="#b19">[19]</ref> or an arithmetic variant of this protocol <ref type="bibr" target="#b17">[17,</ref><ref type="bibr" target="#b23">23]</ref>. However, in the latter case, and in particular in the 2-party case, such protocols make use of public-key cryptography and involve a considerable computation and communication overhead. While this overhead can be amortized to some extent over multiple instances (e.g., using OT extension techniques <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b21">21]</ref>), we can obtain better asymptotic and concrete efficiency by using the help of correlated randomness provided by the client as part of its key generation.</p><p>We present two different MPC techniques that apply to different scenarios. The first applies to the basic scenario of verifying predicates V for the simple sketching schemes described above. It relies on Beaver's circuit randomization technique <ref type="bibr" target="#b1">[1]</ref> and its soundness exploits the fact that if y is invalid, then the output of V is not only nonzero with high probability but it also has a lot of entropy that cannot be eliminated even if the client provides badly formed correlated randomness. The second technique is based on so-called linear PCPs and applies to a more specialized verification scenario in which such entropy is not present.</p><p>Using shared products. Originating from Beaver's circuit randomization technique <ref type="bibr" target="#b1">[1]</ref>, a common technique for speeding up MPC protocols is by employing correlated randomness provided by a trusted dealer (or securely implemented using input-independent preprocessing). In the case of semi-honest parties, Beaver's technique is very efficient: it requires the dealer to send 3 field elements to each party for each multiplication gate, and requires each party to communicate to all other parties just a single field element for every input or multiplication gate.</p><p>Naturally, when the dealer is malicious, the security guarantees of the protocol break down. (The goal of protecting such protocols against a malicious dealer is orthogonal to the goal of protecting them against malicious parties; see, e.g., <ref type="bibr">[5,</ref><ref type="bibr" target="#b12">12]</ref> for efficient solutions to the latter.) In <ref type="bibr" target="#b16">[16]</ref> it was observed that in natural protocols of this type, the effect of a malicious dealer corresponds precisely to an additive attack on the circuit computed by the protocol, namely an attack that can "blindly" add a field element to every internal wire in the arithmetic circuit computed by the protocol. To protect against this type of attacks, the solution proposed in <ref type="bibr" target="#b16">[16]</ref> is to protect the computation against additive attack by using a special type of fault-tolerant circuit called "AMD circuit." While this approach can be used protect against a malicious dealer with a constant overhead, this constant is quite large and the resulting protocols are fairly complex.</p><p>Our main observation is that for the purposes of securely verifying V, the additive attacks induced by badly formed correlated randomness are harmless, because the soundness of the sketching scheme holds even in the presence of such attacks. As noted above, the high level reason for this is that the attack cannot reduce the entropy of V(z) for a sketch z computed from a badly formed y.</p><p>More concretely, the predicates V defined above only require either one or two multiplications, where each multipli-cation of additively shared secrets a and b is implemented using Beaver's technique as follows: To evaluate V on the shared sketch [z], we use the above procedure for evaluating each multiplication, where additions are implemented non-interactively, and the output is reconstructed by simply exchanging shares of the output.</p><p>We now briefly analyze the security of the FSS verification protocol obtained by combining the above client-aided MPC protocol with the sketching schemes proposed above. First, since we assume the parties to be semi-honest, the secrecy property follows from the semi-honest security of the MPC protocol (i.e., the only information learned by the parites is that V(z) = 0, which is always the case for an honest client). Consider the case of correlated randomness generated by a malicious client. Since all predicates V we consider include only a single level of multiplications, the effect of such bad randomness is limited to adding some χ ∈ F to each output. Indeed, since every possible choice of [a ] and [b ] is valid, an inconsistency can always be viewed as an error in the choice of c , which is only added to the output. (If the computation involves two multiplications followed by an addition, which is needed for some of the predicates V we propose, the two errors χ1 and χ2 are added.)</p><p>The crucial point is that the additive error χ introduced by bad randomness is independent of the randomness of L. Hence, it suffices to observe that the soundness of the sketching schemes (L, V) we propose holds also if the constant χ is added to the output of V. This follows from the fact that soundness is argued via the Schwartz-Zippel Lemma applied to polynomials whose degree is greater than 1, for which adding a constant does not change the degree.</p><p>Using linear PCPs for specially structured β. The soundness of the above MPC protocol crucially depends on the fact that the client cannot predict the inputs for the protocol in case y is invalid. In the full version, we describe a different technique for the case where the inputs are fully known to the client. Concretely, the technique is used to make the client prove that the value β of a point function f α,β has a special structure. A particularly useful instance is where β is of the form (γ, γ 2 , . . . , γ d ) ∈ F d for a finite field F. A β vector of this form can be used to decode a set of messages that match the same search criterion in "reading" applications or are written to the same bin in "writing" applications <ref type="bibr" target="#b15">[15,</ref><ref type="bibr" target="#b11">11]</ref>. The idea is to make the client help the parties verify the validity of β by secret-sharing a suitable proof between the parties. The proof can be viewed as a special case of the so-called Hadamard-PCP that has been previously used in the context of sublinear-communication arguments for NP <ref type="bibr" target="#b22">[22,</ref><ref type="bibr" target="#b6">6]</ref>, exploiting the simple algebraic structure of the statement for better efficiency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Putting the Pieces Together</head><p>We conclude by summarizing the type of FSS verification enabled by combining the above sketching schemes and MPC protocols.</p><p>Theorem 4.5 (Verifiable FSS). For each function family Fi specified below, the following holds. For every m-party FSS scheme Π = (Gen, Eval) for Fi, there is an m-party verifiable FSS scheme Π = (Gen , Eval, Ver) for Fi such that keys generated by Gen include keys of Gen and a constant number of additional field elements, and in Ver parties invoke Eval once on each x ∈ D , perform O(|D |) additional field operations, and communicate a constant number of field elements with each other.</p><p>The function families Fi are:</p><p>• All point functions f α,β ;</p><p>• </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Pseudocode for optimized DPF construction for f α,β : {0, 1} n → G, where || denotes string concatenation. Subscripts 0 and 1 refer to party id. All s values are λ-bit strings and t values are a single bit.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Corollary 3 . 4 .</head><label>34</label><figDesc>For d ∈ N there exists FSS for the class of d-dimensional intervals (ai, bi) i∈[d] with key size O(λ•n d ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Template for FSS verification protocol for a given (Gen, Eval).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Claim 4 . 2 .</head><label>42</label><figDesc>Let F be a finite field of characteristic p &gt; 2. If y ∈ F N is neither a unit vector nor the all-0 vector, thenPr L ← Lsq(F, N ); (z1, z2) ← L • y : z2 = z 2 1 ≤ 2/|F|.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>•••</head><label></label><figDesc>Inputs: Additive shares [a] = ([a]1, . . . , [a]m) and [b] = ([b]1, . . . , [b]m) of secrets a, b ∈ F. • Outputs: Additive shares [c] = ([c]1, . . . , [c]m) of c = ab. Correlated randomness: Random additive shares [a ], [b ] of random and independent secrets a , b ∈ F, and random additive shares [c ] of c = a b . // This correlated randomness is included in the keys output by Gen. • Communication: Party i locally computes [∆a]i = [a]i -[a ]i and [∆b]i = [b]i -[b ]i and sends [∆a]i and [∆b]i to all other parties. Computing output: Party i computes ∆a = m j=1 [∆a]j and ∆b = m j=1 [∆b]j, and outputs [c]i = ∆a∆b + ∆b[a]i + ∆a[b]i + [c ]i.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>All point functions f α,β with β ∈ {0, 1} (alternatively, with β = 1 or β ∈ {1, -1} if D = D); • All interval functions f [a,b] and their negations -f [a,b] . • All point functions f α,β for β of the special form (γ, γ 2 , . . . , γ d ) ∈ F d ; here the keys produced by Gen include O(d) additional field elements.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Performance of the optimized DPF construction as in Figure</figDesc><table><row><cell></cell><cell></cell><cell>1-bit output</cell><cell></cell><cell></cell><cell>128-bit output</cell><cell></cell></row><row><cell>Input</cell><cell>Key length</cell><cell cols="2">Eval • -#AES Gen • -#AES</cell><cell>Key length</cell><cell cols="2">Eval • -#AES Gen • -#AES</cell></row><row><cell>Domain</cell><cell>in bits</cell><cell>operations</cell><cell>operations</cell><cell>in bits</cell><cell>operations</cell><cell>operations</cell></row><row><cell>{0, 1} n</cell><cell>≈ (n -log λ)λ</cell><cell>n -log λ</cell><cell>2(n -log λ)</cell><cell>nλ + 2(n + λ + 1)</cell><cell>n</cell><cell>2n</cell></row><row><cell>{0, 1} 16</cell><cell>1417</cell><cell>9</cell><cell>18</cell><cell>2320</cell><cell>16</cell><cell>32</cell></row><row><cell>{0, 1} 25</cell><cell>2578</cell><cell>18</cell><cell>36</cell><cell>3481</cell><cell>25</cell><cell>50</cell></row><row><cell>{0, 1} 40</cell><cell>4513</cell><cell>33</cell><cell>66</cell><cell>5416</cell><cell>40</cell><cell>80</cell></row><row><cell>{0, 1} 80</cell><cell>9673</cell><cell>73</cell><cell>146</cell><cell>10576</cell><cell>80</cell><cell>160</cell></row><row><cell>{0, 1} 160</cell><cell>19993</cell><cell>153</cell><cell>306</cell><cell>20896</cell><cell>160</cell><cell>320</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>In fact, such correlations are inherent to any solution that only makes a black-box access of Eval, which includes all of the efficient solutions we present next. Indeed, there is no way to efficiently distinguish between, say, a random point function on λ-bit inputs and a function that has a nonzero value on two random inputs.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>To simplify the exposition we restrict our attention to protocols that have 1-bit answers, since these seem to be the most attractive from a concrete efficiency point of view.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements. Research done in part while visiting the Simons Institute for the Theory of Computing, supported by the Simons Foundation and by the DIMACS / Simons Collaboration in Cryptography through NSF grant #CNS-1523467. Supported by ERC starting grant 259426. The first author additionally supported by ISF grant 1709/14 and ERC starting grant 307952. The second author additionally supported by ISF grant 1638/15, a grant by the BGU Cyber Center, the Israeli Ministry Of Science and Technology Cyber Program and by the European Union's Horizon 2020 ICT program (Mikelangelo project). The third author was additionally supported by DARPA Brandeis program under Contract N66001-15-C-4065, ISF grant 1709/14, BSF grant 2012378, a DARPA/ARL SAFEWARE award, NSF Frontier Award 1413955, NSF grants 1228984, 1136174, 1118096, and 1065276. This material is based upon work supported by the Defense Advanced Research Projects Agency through the ARL under Contract W911NF-15-C-0205. The views expressed are those of the author and do not reflect the official policy or position of the Department of Defense, the National Science Foundation, or the U.S. Government.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX A. APPLICATIONS OF FSS</head><p>In this section we describe some representative applications of FSS beyond those described in the Introduction. For simplicity we restrict attention to 2-party FSS.</p><p>Private keyword search. Suppose that each of two servers holds a database of keywords with corresponding payloads X = {(x1, p1), . . . , (xN , pN )} where xj ∈ {0, 1} n and pj ∈ {0, 1} m . We further assume that no payload pj is the all-0 string. The client would like to privately test whether some secret keyword x is in the database, and obtain the corresponding payload if it is. To this end, the client uses a DPF to split the point function fx,1 : {0, 1} n → Z2 into f1, f2, sending each key to the corresponding server. Server i sends back the sum N j=1 pjfi(xj), where each pj is viewed as an element in Z m 2 . Let a1, a2 ∈ Z m 2 be the answers received from the two servers. The client lets p = a1 + a2, and outputs "no match" if p = 0 or p otherwise.</p><p>Generalized keyword search. In the case of a generalized keyword search, where the search predicate f : {0, 1} n → {0, 1} is taken from a class F, the client can count the number of entries j satisfying f (xj) = 1 by viewing the range of f as the group G = ZN+1. Splitting f into f1 + f2, server i returns N j=1 fi(xj), and the client can recover the exact number of matches by adding the two answers in G. A bounded number of matching payloads can be retrieved by using sketching or coding techniques <ref type="bibr" target="#b27">[27,</ref><ref type="bibr" target="#b15">15]</ref>. Private updates. Consider the following application scenario for a writing analogue of PIR <ref type="bibr" target="#b26">[26]</ref> Each server i updates its shares of the N files by letting x j,i ← xj,i ⊕ fi(j), for 1 ≤ j ≤ N .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. CONCRETE EFFICIENCY OF PIR</head><p>Since the introduction of Private Information Retrieval (PIR), there have been three different models for PIR. The first, presented in the original PIR work of Chor et al. <ref type="bibr" target="#b10">[10]</ref>, assumes that the database is replicated in k ≥ 2 non-colluding servers and requires that the protocol be information theoretically secure. The second, proposed by Chor and Gilboa <ref type="bibr" target="#b8">[8]</ref>, assumes two non-colluding servers but relaxes the security requirement to hold against computationally bounded adversaries. The third model, introduced in <ref type="bibr" target="#b24">[24]</ref>, assumes that the database is held by a single server and security is again computational.</p><p>In the application of DPF to PIR, as described in the Introduction, the query size is the DPF key, which is roughly of size λ•(n-log λ) for a database of size N = 2 n records (improving over the previous best DPF-based solution from <ref type="bibr" target="#b7">[7]</ref> by roughly a factor of 4). Using Theorem 3.3, the DPF key requires approximately N/64 AES operations. In addition to this cost, each server should take the inner product of a (pseudo-)random N -bit vector with the database, effectively amounting to computing the XOR of roughly half the records in the database. The latter cost is common to all multi-server PIR protocols that have 1-bit answers. 2  Chor et al. <ref type="bibr" target="#b10">[10]</ref> present a simple 2-server informationtheoretic PIR protocol with N -bit queries and 1-bit answers.This protocol provides good concrete efficiency in applications that involve a small number of records (e.g., see <ref type="bibr" target="#b20">[20]</ref>). The optimized DPF protocol in this paper leads to better communication complexity for databases that have 400 items or more. Information-theoretic PIR protocols with k ≥ 3 servers achieve better communication complexity than two-server protocols. However, employing an additional server may be costly, and moreover, even the best published schemes for practical parameters (e.g., the 3-server protocol in <ref type="bibr" target="#b3">[3]</ref> with communication complexity 14N 1/4 ) have higher communication than our construction for large enough databases, e.g. four billion items for <ref type="bibr" target="#b3">[3]</ref>. In terms of computation, all multi-server PIR protocols require each server to expand a received key to a string of N elements and then compute the inner product of the database with the expanded key. In the two-server solution of <ref type="bibr" target="#b10">[10]</ref> the expanded string is explicitly sent to each server; other informationtheoretic PIR protocols require several field or ring operations per database bit to perform this expansion. We note that all of the alternative approaches do not natively generalize to more general types of searches, such as keyword search or range queries, without a significant overhead introduced by the use of data structures.</p><p>Single-server PIR with sublinear communication is known to imply public-key encryption <ref type="bibr" target="#b13">[13]</ref>. Indeed all known singleserver PIR protocols require (additively homomorphic) publickey encryption of the whole database to evaluate a PIR query (cf. <ref type="bibr" target="#b25">[25]</ref> and references therein). This is typically several orders of magnitude slower than the solution we present.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Efficient multiparty protocols using circuit randomization</title>
		<author>
			<persName><forename type="first">D</forename><surname>Beaver</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO &apos;91</title>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="420" to="432" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Correlated pseudorandomness and the complexity of private computations</title>
		<author>
			<persName><forename type="first">D</forename><surname>Beaver</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC 1996</title>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="479" to="488" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Share conversion and private information retrieval</title>
		<author>
			<persName><forename type="first">A</forename><surname>Beimel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Orlov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCC 2012</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="258" to="268" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Completeness theorems for non-cryptographic fault-tolerant distributed computation (extended abstract)</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ben-Or</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Semi-homomorphic encryption and multiparty computation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bendlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Orlandi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zakarias</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurocrypt</title>
		<imprint>
			<date type="published" when="2011">2011. 2011</date>
			<biblScope unit="page" from="169" to="188" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Succinct non-interactive arguments via linear interactive proofs</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bitansky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Paneth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="315" to="333" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Function secret sharing</title>
		<author>
			<persName><forename type="first">E</forename><surname>Boyle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Gilboa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2015</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="337" to="367" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Computationally private information retrieval (extended abstract)</title>
		<author>
			<persName><forename type="first">B</forename><surname>Chor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Gilboa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC 1997</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="304" to="313" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Private information retrieval by keywords</title>
		<author>
			<persName><forename type="first">B</forename><surname>Chor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Gilboa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1998">1998. 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Private information retrieval</title>
		<author>
			<persName><forename type="first">B</forename><surname>Chor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sudan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="965" to="981" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Riposte: An anonymous messaging system handling millions of users</title>
		<author>
			<persName><forename type="first">H</forename><surname>Corrigan-Gibbs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mazières</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="321" to="338" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Multiparty computation from somewhat homomorphic encryption</title>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Pastro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Smart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zakarias</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2012</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="643" to="662" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Single database private information retrieval implies oblivious transfer</title>
		<author>
			<persName><forename type="first">G</forename><surname>Di Crescenzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Malkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2000</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="122" to="138" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Spooky encryption and its applications</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">D</forename><surname>Rothblum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wichs</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016">2016. 2016</date>
			<biblScope unit="page" from="93" to="122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Private stream search at the same communication cost as a regular search: Role of LDPC codes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Finiasz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ramchandran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISIT 2012</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="2556" to="2560" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Circuits resilient to additive attacks with applications to secure computation</title>
		<author>
			<persName><forename type="first">D</forename><surname>Genkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Prabhakaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Tromer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC 2014</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="495" to="504" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Two party RSA key generation</title>
		<author>
			<persName><forename type="first">N</forename><surname>Gilboa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO &apos;99</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="116" to="129" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Distributed point functions and their applications</title>
		<author>
			<persName><forename type="first">N</forename><surname>Gilboa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="640" to="658" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">How to play any mental game or a completeness theorem for protocols with honest majority</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="218" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Scalable and private media consumption with popcorn</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Crooks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Mulhern</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Setty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Alvisi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Walfish</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Extending oblivious transfers efficiently</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nissim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Petrank</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2003</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="145" to="161" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Efficient arguments without short PCPs</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">22nd CCC</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="278" to="291" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Secure arithmetic computation with no honest majority</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Prabhakaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2009</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="294" to="314" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Replication is NOT needed: SINGLE database, computationally-private information retrieval</title>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">38th FOCS</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="364" to="373" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">XPIR : Private information retrieval for everyone</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Melchor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Barrier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Fousse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Killijian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PoPETs</title>
		<imprint>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="155" to="174" />
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Private information storage (extended abstract)</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC 1997</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="294" to="303" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Private searching on streaming data</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Skeith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2005</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="223" to="240" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Multi-dimensional range query over encrypted data</title>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bethencourt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">T</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">X</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2007 IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="350" to="364" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
