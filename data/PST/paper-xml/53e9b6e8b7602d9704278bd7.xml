<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Classical Negation in Logic Programs and Disjunctive Databases</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Michael</forename><surname>Gelfond</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Texas at E1 Paso</orgName>
								<address>
									<postCode>79968</postCode>
									<settlement>El Paso</settlement>
									<region>Texas</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Vladimir</forename><surname>Lifschitz</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">University of Texas at Austin</orgName>
								<address>
									<postCode>78712</postCode>
									<settlement>Austin</settlement>
									<region>Texas</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Classical Negation in Logic Programs and Disjunctive Databases</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note type="submission">Received 18 October 1990 Revised manuscript received 10 May 1991</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T13:53+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Disjunctive Databases</term>
					<term>Incomplete Information</term>
					<term>Logic Programming</term>
					<term>Negation as Failure</term>
					<term>Nonmonotonic Reasoning</term>
					<term>Stable Models</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>An important limitation of traditional logic programming as a knowledge representation tool, in comparison with classical logic, is that logic programming does not allow us to deal directly with incomplete information. In order to overcome this limitation, we extend the class of general logic programs by including classical negation, in addition to negation-as-failure. The semantics of such extended programs is based on the method of stable models. The concept of a disjunctive database can be extended in a similar way. We show that some facts of commonsense knowledge can be represented by logic programs and disjunctive databases more easily when classical negation is available. Computationally, classical negation can be eliminated from extended programs by a simple preprocessor. Extended programs are identical to a special case of default theories in the sense of Reiter.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>w Introduction</head><p>An important limitation of traditional logic programming as a knowledge representation tool, in comparison with classical logic, is that logic programming does not allow us to deal directly with incomplete information. A consistent classical theory partitions the set of sentences into three parts: A sentence is either provable, or refutable, or undecidable. A logic program partitions the set of ground queries into only two pars: A query is answered either yes or no. This happens because the traditional declarative semantics of logic programming automatically applies the closed world assumption to all predicates, and each ground atom that does not follow from the facts included in the program is assumed to be false. Procedurally, the query evaluation methods of logic programming give the answer no to every query that does not succeed; they provide no counterpart of undecidable sentences, which represent the incompleteness of information in classical axiomatic theories.</p><p>In order to overcome this limitation, we propose to consider "extended" logic programs, that contain classical negation ~ in addition to negation-asfailure not. General logic programs provide negative information implicitly, through closed-world reasoning; an extended program can include explicit negative information. In the language of extended programs, we can distinguish between a query which fails in the sense that it does not succeed and a query which fails in the stronger sense that its negation succeeds.* A general logic program ~4) can be defined as a set of rules of the form Ao *--A~, ...., A~, not Am+l, ..., not A,,</p><p>where n -&gt; m 2 0, and each Ai is an atom. The word "general" stresses the fact that such rules may contain negation, and, consequently, are more general than Horn clauses.</p><p>Recall that a literal is a formula of the form A or -7 A, where A is an atom. The negation sign in the negative literal ~ A represents classical negation, not negation-as-failure, so that expressions of the form not A, occurring in general logic proprams, are not literals according to this definition.</p><p>An extended logic program is a set of rules of the form Lo ~--L1 ..... Lm, not L,~+I ..... not Ln, <ref type="bibr" target="#b0">(1)</ref> where n -&gt; m _&gt; 0, and each Li is a literal. The semantics of extended programs described below is an extension of the stable model semantics for general logic programs proposed in Ref. <ref type="bibr" target="#b4">5</ref>). The stable model semantics defines when a set S of ground atoms is a "stable model" of a given program. A "well-behaved" program has exactly one stable model, and the answer that such a program is supposed to return for a ground query A is yes or no, depending on whether A belongs to the stable model or not. (The existence of several stable models indicates that the program has several possible intepretations.) For an extended program, we will define when a set S of ground literals qualifies as its answer set. If the program doesn't contain classical negation, then its answer sets are the same as its stable models. A "well-behaved" extended program has exactly one answer set, and this set is consistent. The The idea of providing for the incompleteness of information in logic-based query answering systems, and permitting answers other than simply yes or no for ground queries, is discussed in Refs. 9) and 7). Our use of two kinds of negation appears to be somewhat similar to the distinction between "strong" and "weak" negation in Ref. 27).</p><p>answer that the program is supposed to return for a ground query A is yes, no or unknown, depending on whether the answer set contains A, -7 A, or neither. The answer no corresponds to the presence of explicit negative information in the program.</p><p>Consider, for instance, the extended program II1 consisting of just one rule:</p><formula xml:id="formula_0">-7 Q ~ not P.</formula><p>Intuitively, this rule means: "Q is false, if there is no evidence that P is true." We will see that the only answer set of this program is { ~ Q}. The answers that the program should give to the queries P and Q are, respectively, unknown and false.</p><p>As another example, compare two programs that don't contain not:</p><formula xml:id="formula_1">and ~p ~--, p,---~Q ~p ~--, Q~---~p.</formula><p>Let's call them IIz and I13. Each of the programs has a single answer set, but these sets are different. The answer set of II2 is { ~P}; the answer set oflI3 is { ~P, Q}. Thus our semantics is not "contrapositive" with respect to ~--and 7; it assigns different meanings to the rules P *--~ Q and Q ~ ~P, The reason is that it interprets expressions like these as inference rules, rather than conditionals. (For positive programs, both points of view lead to the same semantics.) The language of extended programs includes classical negation, but not classical implication. This approach has important computational advantages. We will see that, under rather general conditions, evaluating a query for an extended program can be reduced to evaluating two queries for a program that doesn't contain classical negation. Our extension of general logic programs hardly brings any new computational difficulties.*</p><p>The class of extended programs is of interest in connection with the problem of relation between logic programming and nonmonotonic formalisms (see Ref_ 21) for an overview). As shown in Ref. 1), general logic programs can be viewed as default theories in the sense of Reiter. TM A similar reduction is applicable to extended programs, and they turn out to be a notational variant of a natural, easily identifiable subset of default logic. We can say that the class of extended programs is the place where logic programming meets default logic halfway.</p><p>Notice for comparison that when Poole and Goebel 2~ add classical negation to Prolog, they immediately get full first order logic and full resolution. This is because they interpret ~ as classical implication.</p><p>w</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Answer Sets</head><p>The semantics of extended programs treats a rule with variables as shorthand for the set of its ground instances. It is sufficient then to define answer sets for extended programs without variables. This will be done in two steps.</p><p>First, consider extended programs without variables that, in addition, don't contain not (rn = n in every rule (1) of the program). Extended programs without not correspond to the positive (Horn) case of traditional logic programming. Every such program will have exactly one answer set. This set will consist, informally speaking, of all ground literals that can be generated using ( i ) the rules of the program, and (ii) classical logic.</p><p>Obviously, there is only one case when a set of ground literals may logically entail a ground literal that doesn't belong to it: when it contains a pair of complementary literals A, m A. This observation suggests t.he following definition.</p><p>Let II be an extended program without variables that doesn't contain not, and let Lit be the set of ground literals in the language of II. The answer set of II is the smallest subset S of Lit such that ( i ) for any rule Lo*-L, ..... Lm from H, if L~ .... , Lm ~ S, then Lo ~ S; (ii) if S contains a pair of complementary literals, then S = Lit.</p><p>We will denote the answer set of a progam 11 that doesn't contain negation-as-failure by a(II).</p><p>If II is a positive program, i.e., a program containing neither not nor m, then condition (ii) is trivial, and a(II) is simply the minimal model of II. It is also clear that the answer sets given above for programs II2 and II3 are in agreement with this definition:</p><formula xml:id="formula_2">a(II2) = {-~P}, a(IIa) = {~P, Q).</formula><p>Now let 1I be any extended program without variables. By Lit we again denote the set of ground literals in the language of II. For any set S C Lit, let II s be the extended program obtained from II by deleting ( i ) each rule that has a formula not L in its body with L ~ S, and (ii) all formulas of the form not L in the bodies of the remaining rules. Clearly, II s doesn't contain not, so that its answer set is already defined. If this answer set coincides with S, then we say that S is an answer set of II. In other words, the answer sets of II are characterized by the equation S = a(IIS).</p><p>(</p><formula xml:id="formula_3">)<label>2</label></formula><p>For instance, in order to check that {~Q} is an answer set of the program II1 in the example above, we should construct the program 111 ~~ This program contains one rule, -~ Q .--(the result of deleting not P from the only rule of II1). The answer set of this program is { ~ Q), the set that we started with. Consequently, this is indeed an answer set of IIl. It is easy to check that no other subset of literals has the same fixpoint property.</p><p>The answer sets of I1 are, intuitively, possible sets of beliefs that a rational agent may hold on the basis of the information expressed by the rules of II. If S is the set of ground literals that the agent believes to be true, then any rule that has a subgoal not L with L ~ S will be of no use to him, and he will view any subgoal not L with L ~ S as trivial. Thus he will be able to replace the set of rules 1I by the simplified set of rules II s. If the answer set of II s coincides with S, then the choice of S as the set of beliefs is "rational".</p><p>We need to verify, of course, that the second, more general definition of answer sets, when applied to a program without not, is equivalent to the first definition. This is an immediate consequence of the fact that, for such II, II s = II, so that the fixpoint condition (2) turns into S = a(II).</p><p>On the other hand, if 11 doesn't contain 7, then II s is a positive program, and its answer set doesn't contain negative literals. Consequently, an answer set of a general logic program--a program without classical negation--is a set of atoms. The definition of an answer set coincides in this case with the definition of stable model given in Ref. <ref type="bibr" target="#b4">5</ref>). (Notice that the sign ~ stands there for negation-as-failure and thus corresponds to not in the notation of this paper.) We conclude that the answer sets of a general logic program are identical to its stable models. In this sense, the semantics of extended programs, applied to general programs, turns into the stable model semantics. But there is one essential difference: The absence of an atom A in the stable model of a general program represents the fact that A is false; the absence of A and ~A in the answer set of an extended program is taken to mean that nothing is known about A. We will return to this point in the next section, and then again in Section 6.</p><p>We think of answer sets as incomplete theories (rather than "three-valued models," used, for instance, in Refs. 4), 22) and 26). When a program has several answer sets, it is incomplete also in another sense--it has several different interpretations, and the answer to a query may depend on the interpretation.</p><p>An extended program is contradictory if it has an inconsistent answer set (that is, an answer set containing a pair of complementary literals). For instance, the program II4, consisting of the rules p~----~ p ,--, is contradictory. It is clear that a general logic program cannot be contradictory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 1</head><p>Every contradictory program has exactly one answer set--the set of all literals, Lit.</p><p>This proposition shows that our approach to negation is different from the "paraconsistent" approach of Ref, 3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>It is clear from the definition of answer sets that any answer set containing a pair of complementary literals coincides with L/t. The fact that a contradictory program cannot have any other answer set is a consequence of the following lemma:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 1</head><p>An extended logic program cannot have two answer sets of which one is a proper subset of the other.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>Let S, S' be answer sets of 1-[, and S c S'. Clearly, 1-I s' C II s. It follows that a(II s') c ~(IIS), i.e., S' c S. Consequently, S = S'.</p><p>Being noncontradictory doesn't guarantee the existence of. answer sets. This can be illustrated by any general logic program without stable models, such asPs-not P.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>w Representing Knowledge Using Classical Negation</head><p>Sometimes the use of negation-as-failure in logic programs leads to undesirable results that can be eliminated by substituting classical negation for it. We are indebted to John McCarthy for the following example. A school bus may cross railway tracks under the condition that there is no approaching train. This fact can be expressed by the rule</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Cross ,---not Train</head><p>if the absence of the atom Train in the database is interpreted as the absence of an approaching train. But this knowledge representation convention is unacceptable if information about the presence or absence of a train may be not available. If, for instance, Train is not included in the database because the driver's vision is blocked, then we certainly don't want the bus to cross tracks, The situation will be different if classical negation is used:</p><formula xml:id="formula_4">Cross ~--~ Train.</formula><p>Then Cross will not belong to the answer set unless the negative fact ~ Train is included.* The difference between not P and ~P in a logic program is essential whenever we cannot assume that the available positive information about P is According to Refs. 11) and 10), many provisions in legislation have a negative form ("A declaration.., shall not be registered unless..."). In a preliminary version of Ref. 10), such statements were treated as integrity constraints with one of the conditions identified as "retractable." The use of rules with negative heads seems more natural. complete, i.e., when the "closed world assumption ''24) is not applicable to P. The closed world assumption for a predicate P can be expressed in the language of extended programs by the rule P(x) ~--not P(x).</p><p>(3) When this rule is included in the program, not P and ~P can be used interchangeably in the bodies of other rules. Otherwise, we use not P to express that P is not known to be true, and ~P to express that P is false.</p><p>For some predicates, the assumption opposite to (3) may be appropriate:</p><formula xml:id="formula_5">P(x) ~ not -1P(x). (<label>4</label></formula><formula xml:id="formula_6">)</formula><p>For instance, the set of terminal vertices of a directed graph can be defined by the following program IIs:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Terminal(x) ~--Arc(x, y), Terminal(x) ~-not -7 Terminal(x).</head><p>For any predicate P, we are free to include either of the rules (3), (4) in the database, or to leave out both of them. Consider the following example. Jack is employed by Stanford University, and Jane is employed by SRI International:</p><formula xml:id="formula_7">Employed(Jack, Stanford) ~--,</formula><p>Employed(Jane, SRI) *--.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Any employed individual has an adequate income:</head><p>A dequate-Income(x) *--Employed(x, y).</p><p>The answer set of the program with these 3 rules is { Employed(Jack, Stanford), Employed(Jane, SRI), Adequate-Income(Jack), Adequate-Income(Jane)}.</p><p>This set contains no negative literals, and it doesn't allow us to assert, for instance, that Jack is not employed by SRI. The claim that the employment information in the database is complete is expressed by the closed world assumption for Employed:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Employed(x, y) ~--not Employed(x, y).</head><p>Appending this rule to the program will add the literals -~ Employed( Jack, SRI), -T Employed( Jane, Stanford)</p><p>to the answer set. If the available employment information is complete for Stanford, but not for SRI, a more restricted rule should be used instead:</p><p>-~Employed(x, Stanford)~--not Employed(x, Stanford).</p><p>The following example of the use of negation in the 1981 British Nationality Act is quoted in Ref. 11): "After commencement no person shall have the status of a Commonwealth citizen or the status of a British subject otherwise than under this Act." This statement, in essense, postulates the closed world assumption for some predicates. Kowalski remarks that there is no need to represent statements of this kind explicitly in a (general) logic program, because they are implicit in the semantics of the language. He seems to agree, however, that it may be desirable to permit predicates whose definitions are not assumed to be complete, and to require an "explicit declaration" whenever a completeness assumption is made. In the language of extended programs, such declarations are represented by rules of the form (3).</p><p>We do not commit ourselves to any particular use of the closed world assumption by deciding which of two opposite predicates will be represented by a predicate constant, and which one will be considered negative. In this sense, the language of extended programs is symmetric, like default logic, zS~ autoepistemic logic 1~) and formula circumscription) 7) On the contrary, the modification of our approach proposed in Ref. 10) is not symmetric.</p><p>In Section 6 we say more on the use of the closed world assumption in extended programs.</p><p>Here is one more example in which both kinds of negation are used. College X uses the following rules for awarding scholarships to its students:</p><p>(1) Every student with the GPA of at least 3.8 is eligible.</p><p>(2) Every minority student with the GPA of at least 3.6 is eligible.</p><p>(3) No student with the GPA under 3.6 is eligible. (4) The students whose eligibility is not determined by these rules are interviewed by the scholarship committee.</p><p>The rules are encoded in the following extended program:</p><formula xml:id="formula_8">Eligible (x) ,--High GPA (x), Eligible(x) ~--Minority(x), FairGPA(x), Eligible(x) *--~ FairGPA(x), Interview(x) ~--not Eligible(x), not ~ Eh'gible(x).</formula><p>The last rule says: Interview(x), if there is no evidence that Eligible(x) and there is no evidence that ~ Eligible(x).</p><p>This program is to be used in conjunction with a database specifying the values of the extensional predicates Minority, HighGPA and FairGPA. Assume, for instance, that the following two facts are available about one of the students:</p><formula xml:id="formula_9">FairGPA(Ann) *--, ~ HighGPA(Ann) ~--.</formula><p>The database contains no information about Minority(Ann). (Ann is a minority student who, as a matter of principle, declined to state this fact on her application.)</p><p>The extended program II~, consisting of these 6 rules, has one answer set:</p><p>{ FairGPA(Ann), ~ HighGPA(Ann), Interview(Ann)}.</p><p>(5)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>w Reduction to General Programs</head><p>Let II be an extended program. For any predicate P occurring in II, let P' be a new predicate of the same arity. The atom P'(...) will be called the positive form of the negative literal -7 p(...). Every positive literal is, by definition, its own positive form. The positive form of a literal L will be denoted by L +. II + stands for the general program obtained from II by replacing each rule (1) by</p><formula xml:id="formula_10">L? *--L~, L +, not + .... Lm+l ..... not L +.</formula><p>For instance, 115 ~ is the program</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Terminal'(x) ~--Arc(x, y), Terminal(x) ,---not Terminal'(x).</head><p>This is, of course, the usual definition of Terminal in the language of general logic programs.</p><p>For any set S C Lit, S + stands for the set of the positive forms of the elements of S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 2</head><p>A consistent set S C Lit is an answer set of II if and on!y if S ยง is an answer set of H +.</p><p>In this sense, the mapping 17 I~ II + reduces extended programs to general programs--even though II + gives no indication that P' represents, intuitively, the negation of P.*</p><p>The proof of Proposition 2 is based on two lemmas.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 2</head><p>For any noncontradictory program II that doesn't contain not,</p><formula xml:id="formula_11">a(n +) = a(n) +.</formula><p>This mapping is related to the methods for translating inheritance hierarchies into logic programs proposed in Refs. 6) and 7). These methods require that new predicates be introduced for the purpose of representing negative conditions. For instance, the assertion "penguins don't fly" is written as</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Flies'( x) ~ Penguin(x),</head><p>where the positive literal Flies'(x) has, intuitively, the same meaning as the negative literal Flies(x). If we are willing to use the language of extended programs as the object language for this translation process, then the procedure can produce instead:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Flies(x) ,-Penguin(x).</head><p>The additional step of replacing ~ Flies by Flies' can be viewed as an instance of the general transformation II ~ II +.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>Since H is noncontradictory, a(H) is simply the set of literals that can be generated by applying (the ground instances of) the rules of II L0 ~--L1 ..... Lm as inference rules. Similarly, a(II +) is the set of atoms that can be generated by applying the corresponding positive rules, L0 + ,--L/~ ..... Lm +.</p><p>It is clear that the atoms derivable using these positive rules are exactly the positive forms of the literals derivable using the rules of the original program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 3</head><p>For any contradictory program 1-I that doesn't contain not, a(II +) contains a pair of atoms of the form A, (-~A) +.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>Consider the set S of ground literals that can be generated by applying the rules of II as inference rules. Assume that S is consistent. Then S = a(II), so that a(II) is consistent. But this is impossible, because II is contradictory. Consequently, S is inconsistent. Let A, ~ A be two complementary literals that belong to S, i.e., can be derived using the rules of II as inference rules. By applying the corresponding positive rules, we can derive A and (~A) +. Consequently, A, (~A) + ~ a(II+).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Proposition 2</head><p>Without loss of generality we can assume that II doesn't contain variables. Let S be a consistent set of literals. By definition, S + is an answer set of l-I + when S+ = a((II+)~s+)), which can be rewritten as S + = a((W)+).</p><p>Our goal is to prove the equivalence S + = a((IIS) +) ~ S = a(IIS). ( <ref type="formula">6</ref>)</p><p>Case 1: II s is noncontradictory. Then, by Lemma 2, the left-hand side of ( <ref type="formula">6</ref>) is equivalent to S + = a(IIS) +, which is clearly equivalent to the right-hand side of (6). Case 2: II s is contradictory. Since S is consistent, the right-hand side of ( <ref type="formula">6</ref>) is false. By Lemma 3, a((IIS) +) contains a pair A, (~A) +. Since S is consistent, S + cannot contain such a pair, so that the left-hand side of ( <ref type="formula">6</ref>) is false as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary</head><p>If a set S C Lit is consistent, and S + is the only answer set of II +, then S is the only answer set of II.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>By Proposition 2, S is an answer set of l-I, so we only need to show that II has no other answer sets. Let S' C Lit be an answer set of II. Since S is consistent, II is noncontradictory (Proposition 1), so that S' is consistent, too. Then, by Proposition 2, (S') + is an answer set of II +, so that (S') + = S + and consequently S'=S.</p><p>The corollary shows how query evaluation procedures developed for general logic programs can be applied to extended programs. If l-I + is "wellbehaved" (for instance, stratified), and its answer set doesn't contain a pair of atoms of the form ,4, (~A) ยง then II is "well-behaved" also, and a literal L Lit belongs to the answer set of II if and only if the ground atom L + belongs to the answer set of 1-I +. The condition L ยง ~ II + can be verified, in principle, by a usual logic programming system. For instance, the fact that the literals included in ( <ref type="formula">5</ref>) indeed belong to the answer set of II~ can be confirmed by applying the Prolog query evaluation procedure to II~ and to the queries</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FairGPA(Ann), HighGPA'(Ann), Interview(Ann).</head><p>Queries with variables can be processed in a similar way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Remark</head><p>The consistency assumption in the statements of Proposition 2 and the corollary is essential, even if II is noncontradictory and lI + is stratified. This is demonstrated by the following example IIT:</p><formula xml:id="formula_12">P *--not ~ P, Q*-P, ~Q*-P.</formula><p>This program has no answer sets, although II~ is a stratified program. The answer set of II~ is the positive form of the inconsistent set {P, Q, ~ Q}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>w Relation to Default Logic</head><p>The stable model semantics can be equivalently described in terms of reducing logic programs to a fixpoint nonmonotonic formalism-default logic, autoepistemic logic or introspective circumscription.* The extension discussed here can be reformulated as a reduction to any of these formalisms, too. In this section we show how the language of extended programs can be embedded into Historically, two of these reductions were proposed earlier than the definition of stable models. A reduction to autoepistemic logic is given in Ref. 8), and the equivalence of the stable model approach to this semantics is established in Ref. 5) (Theorem 3). A reduction to default logic is described in Ref. 1) (see also Ref. <ref type="bibr" target="#b12">13</ref>)) and shown to be equivalent to stable models in Ref.</p><p>2). Introspective circumscription is defined in Ref. 12), and its relation to stable models is discussed in Sections 5,1 and 5.2 of that paper. default logic.*</p><p>The review of default logic below is restricted to the case of quantifierfree defaults, sufficient for our purposes.** A default is an expression of the form F ,---G: MH1 ..... MH~ <ref type="bibr" target="#b6">(7)</ref> where F, G, H1 ..... He(k _&gt; 0) are quantifier-free formulas. F is the consequent of the default, G is its prerequisite, and//1 ..... Hk are its justifications. A default theory is a set of defaults.*** The operator FD associated with a default theory D is defined as follows. For any set of sentences E, I'D(E) is the smallest set of sentences such that ( i ) for any ground instance <ref type="bibr" target="#b6">(7)</ref>  </p><p>where L stands for the literal complementary to L: A : -~A, ~A = A. Every extended program is identified in this way with some default theory. It is clear that a default theory is an extended program if and only if each of its justifications and consequents is a literal, and each of its preconditions is a conjunction of literals.</p><p>* The use of autoepistemic logic for this purpose leads to some complications. They are related to the fact that our semantics of extended programs is not contrapositive with respect to classical negation: as we have seen, the rule P ,~ -1Q is generally not equivalent to Q ~ -7 p. Consequently, even in programs without not, we can't interpret ~ as implication. To fix this problem, we can try to modify the translation from Ref. 8) and insert the autoepistemic operator L in front of each literal in the body of a rule, even if it doesn't follow not. Then the rules P ,--~ Q and Q *--~P are translated by two different autoepistemic formulas, L ~Q ~ P and L-~P ~ Q. Unfortunately, this translation reduces some "well-behaved" programs to autoepistemic theories with several extensions. For instance, the autoepistemic theory LP ~ P, corresponding to the trivial program P ,-P, has two extensions. The "unintended" extensions can be eliminated by using the ideas of Refs. or G: MH~, ..., MH~/F. Accoding to Reiter, a default theory may include, in addition to defaults, some formulas that play the role of axioms. However, this doesn't give any additional generality, because an axiom F can be identified with the default true: /F.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 3</head><p>For any extended program II, ( i ) if S is an answer set of II, then the deductive closure of S is an extension of II; ( ii ) every extension of II is the deductive closure of exactly one answer set of II.</p><p>Thus the deductive closure operator establishes a 1-1 correspondence between the answer sets of a program and its extensions.</p><p>The proof of Proposition 3 is based on a few lcmmas. We denote the deductive closure of a set of sentences E by Th(E).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 4</head><p>If a set of sentences E belongs to the range of Fn for some extended program II, then</p><formula xml:id="formula_14">E = Th(E N Lit).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>Let E = Fn(E'). Then E is deductively closed, so that Consequently,</p><formula xml:id="formula_15">Th(E n Lit) C Th(E) = E.</formula><formula xml:id="formula_16">F ~ rn(E') = E.</formula><p>Since F is a literal, it follows that</p><formula xml:id="formula_17">F ~ E n Lit C Th(E N Lit).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 5</head><p>If S is an answer set of an extended program, then Th(S) n Lit = S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>Let S be an answer set of an extended program II. If II is contradictory, then, by Proposition 1, S --Lit and consequently Th(S) VI Lit = Lit. If not, then S is a consistent set of ground literals, so that the ground literals that logically follow from S are precisely the elements of S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 6</head><p>For any extended program II and any deductively closed set of sentences E, rn(E) = Th(a(II~nLi')).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>Since every default in II can be equivalently replaced by its ground instances, it can be assumed without loss of generality that II doesn't contain variables. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Proposition 3</head><p>Let S be an answer set of II. By Lemmas w The Closed World Interpretation of General Logic Programs Syntactically, general logic programs are a special case of extended programs. Moreover, the "canonical" model of a "well-behaved" general program (the unique stable model) is identical to its solution set as defined in Section 2. In spite of this, there is a semantic difference between a set of rules viewed as a general program, and the same set of rules viewed as an extended program. The absence of a ground atom A in the "canonical" model of a general program indicates that A is false in the model, so that the correct answer to the query A is no; the absence of A in the answer set of the same collection of rules treated as an extended program indicates that the answer to this query should be unknown.</p><p>For instance, the answer set of the program </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>w Classical Negation in Disjunctive Databases</head><p>The idea of rules with disjunctive heads has received much attention in recent years. Many attempts have been made to define a declarative semantics for "disjunctive logic programs," or "disjunctive databases"; references can be found in Ref. 23).</p><p>Consider a simple example. Jack is employed by Stanford University or by SRI International; any employed individual has an adequate income. It follows that Jack has an adequate income. It would be easy to formalize this instance of commonsense reasoning in classical logic, but it is not clear how to express the given facts by a logic program. The following "disjunctive database" can be used: Employed(Jack, Stanford) ] Employed(Jack, SRI) ~-, (15) Adequate-Income(x) ~-Employed(x, y).</p><p>We use[rather than V in the head of the disjunctive rule, because there is a subtle difference, as we will see later, between the use of disjunction in the heads of rules and the use of disjunction in classical logic (similar tO the difference between the noncontrapositive ~--and the contrapositive classical implication, discussed in the introduction, or to the difference between not and -~).</p><p>An extended disjunctive database is a set of rules of the form It is interesting that the embedding of extended programs into default logic (Section 5) cannot be generalized to disjunctive databases in a straightforward way. Compare, for instance, the rule P I Q ~-- <ref type="bibr" target="#b15">(16)</ref> with the default PV Q,--:.</p><p>The database ( <ref type="formula">16</ref>) has two answer sets, {P} and {Q}; the default theory (17) has one extension--the deductive closure of P V Q. This example shows that there is a difference between I as used in this paper and classical disjunction used in default logic.</p><p>As another example illustrating the difference between I and V, consider the database</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>O~--e'</head><p>(18) PI ~P~.</p><p>Unlike the law of the excluded middle in classical logic, the second rule cannot be dropped without changing the meaning of the database. This rule expresses that P is either known to be true or known to be false. Any answer set of a database containing this rule includes either P or ~ P. The database consisting of just one rule Q ~ P has one answer set, empty; (18) has two answer sets: {P, Q} and {~P}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>w Conclusion</head><p>Extended logic programs and extended disjunctive databases use both classical negation ~ and negation-as-failure not. Their semantics is based on the method of stable models. Some facts of commonsense knowledge can be represented by logic programs and disjunctive databases more easily when classical negation is available. In particular, rules of extended programs can be used for formalizing the closed world assumption for specific predicates.</p><p>Under rather general conditions, query evaluation for an extended program can be reduced to query evaluation for the general program obtained from it by replacing the classical negation of each predicate by a new predicate.</p><p>An extended program can be viewed as a default theory in which every justification and consequent is a literal, and every precondition is a conjunction of literals.</p><p>A semantic equivalent of a general logic program in the language of extended programs can be formed by adding the closed world assumption for all predicates.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>of any default from D, if G ~ FD(E) and //1 ..... ~ Hk ~ E then F ~ FD(E); (ii) I'D(E) is deductively closed. E is an extension for D if I'D(E) = E. We will identify a rule Lo ~ L1, ..., Lm, not Lm+l, ..., not Ln with the default Lo ~ L1 A ... A Lm: MLm+I ..... ML,,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>15) and 16). ** This restriction allows us to disregard the process of Skolemization, involved in defining extensions in the general case (Ref. 25), Section 7.1). *** In the notation of Ref. 25), (7) would be written as G: MH, ..... MHk F</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>We'll prove</head><label></label><figDesc>the opposite inclusion by showing that Th(E N Lit) satisfies both closure conditions characterizing Fo(E'): ( i ) for any ground instance F ,--G: MHa ..... MHk of a rule of II, if G Th(E N Lit) and ~Ha ..... ~Hk ~ E' then F E Th(E n Lit); (ii) Th(E N Lit) is deductively closed. The second assertion is obvious. Assume that G ~ Th(E N Lit) and -~ Ha ..... Hk ~ E'. As we have seen, Th(E N Lit) C E, so that G ~ E = FH(E').</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>6 and 5 and by the definition of answer set, rn(Th(S)) = Th(a(IITh&lt;s)nLi~))= Th(a(IIS))= Th(S). To prove part (ii), consider an extension E of II. E n Lit is an answer set of II, because, by Lemmas 5 and 6, a(II enL/t) : Th(ot(l-[EnLit)) n L# : I'n(E) n Lit = E n Lit. On the other hand, by Lemma 4, the deductive closure of E n Lit is E. It remains to show that, for any answer set S, Th(S) = E only if S = E n Lit. Assume Th(S) : E. Then, by Lemma 5, E n Lit = Th(S) N Lit = S.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Even(O) ~-, Even(S(S(x)) ~--Even(x)is SO that S' is a solution set of IY.To prove the second claim, take any answer set S' of IY, and define S = S' N Pos. Then s' = a((Ir) S') = a(n s) U {~A: A ~ Pos\S'} = a(II s) U { ~A: A ~ Pos\S}. It is clear that the first summand in this union is the positive part of S', and the second summand is the negative part. We conclude, first, that a(II s) = S" n Pos = S, i.e., S' is an answer set of II, and, second, that { ~A: A U_ Pos\S} = S'\Pos, and consequently S U {-~a: A ~ Pos\S} = S U (S'\Pos) = (S' N Pos) U (S'\Pos) = S'.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>L1 ] ... I ~-Lk+, ..... Lm, not Lm+l ..... not Ln, where n _&gt; m _&gt; k _&gt; 0, and each Li is a literal. The following definition of an answer set for extended disjunctive databases generalizes the definition given in Section 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Lm+l ..... Ln ~ E n Lit. Lit. Furthermore, if Y'n(E) N Lit contains a pair of complementary literals, then it is inconsistent. Since I'H(E) is deductively closed, it coincides with the set of all sentences, so that I'n(E) N Lit = Lit.</figDesc><table><row><cell>Since Lm+l ..... Ln are literals, it follows that</cell><cell></cell></row><row><cell>Lm+l, ..., Ln ~ E.</cell><cell></cell></row><row><cell cols="2">By the definition of 1-'H(E) appliled to the default (8), (13) implies L0 ~ I'n(E),</cell></row><row><cell>and consequently L0 ~ I'n(E) N</cell><cell></cell></row><row><cell></cell><cell>We</cell></row><row><cell>will show first that</cell><cell></cell></row><row><cell>Fn(E) C Th(a(IlenUt))</cell><cell>(9)</cell></row><row><cell cols="2">by proving that Th(a(II~nL~')) satisfies both closure conditions characterizing</cell></row><row><cell>Fn(E). Let (8) be the default corresponding to a rule from II, such that</cell><cell></cell></row><row><cell>L, A ... A Lm ~ Th(a(IIEnut))</cell><cell>(10)</cell></row><row><cell>and</cell><cell></cell></row><row><cell>m</cell><cell></cell></row><row><cell>-~Lm+~ ..... ~L. ~ E.</cell><cell>(11)</cell></row><row><cell>From (10) and Lemma 5,</cell><cell></cell></row><row><cell>L, ..... Lm ~ Th(a(IIEnLi')) A Lit = a(IIEnL").</cell><cell>(12)</cell></row><row><cell>Since E is deductively closed, (11) implies</cell><cell></cell></row><row><cell>Lm.l ..... Ln ~ E.</cell><cell></cell></row><row><cell cols="2">Consequently, the rule Lo ~ L1 ..... Lm belongs to II ~nLi'. In view of (12), it</cell></row><row><cell>follows that</cell><cell></cell></row><row><cell>Lo ~ a(II znu') C Th(a(IIEnLi,)).</cell><cell></cell></row><row><cell cols="2">Furthermore, Th(a(IIEnU')) is deductively closed. The inclusion (9) is proved.</cell></row><row><cell>The opposite inclusion</cell><cell></cell></row><row><cell>Th(a(IIEnLi')) c I"r,(E)</cell><cell></cell></row><row><cell>will be proved if we show that</cell><cell></cell></row><row><cell>a(II EnL'`) c Fn(E),</cell><cell></cell></row><row><cell cols="2">because Fn(E) is deductively closed. We will do that by proving that Fn(E) A</cell></row></table><note>Lit satisfies both closure conditions for a(IIEnL~t). Let L, ..... Lm ~ Fn(E) A Lit<ref type="bibr" target="#b12">(13)</ref> for some rule Lo +--L, ..... Lm of II EnL~t. According to the definition of l-I s (Section 2), this rule is obtained from a rule<ref type="bibr" target="#b6">(7)</ref> of II by deleting not Lm+l ..... not Ln, and, moreover,</note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We are grateful to John McCarthy, Halina Przymusinska, Teodor Przymusinski and Rodney Topor for comments on earlier drafts. This research was supported in part by NSF grants IRI-8906516 IRI-8904611, IRI-9101078 and IRI-9103112 and by DARPA under Contract N00039-84-C-0211.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>{Even(O), Even(S(S(O))) .... }.</head><p>Since this set contains neither Even(S(O)) nor ~Even(S(O)), the semantics of extended programs tells us that the answer to" the query Even(S(O)) is unknown-contrary to the intended meaning of this definition of Even.</p><p>This meaning can be formally expressed in the language of extended programs by adding the closed world assumption for Even: 7 Even(x) ~ not Even(x) (Section 3). Then the solution set becomes</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>{Even(O), -~ Even( S(O)), Even( S( S(O))), -T Even( S( S( S(O)) )) .... }.</head><p>This example suggests that an extended program "semantically equivalent" to a general program II can be obtained from II by adding the closed world assumption for each of its predicates. Define the closed world interpretation CW(II) of a general program 1-I to be the extended program obtained from II by adding the rules P(xl ..... xn) *--not P(xl ..... xn) for all predicate constants P from the language oflI, where xl .... , x~ are distinct variables, and n is the arity of P. The following proposition shows that the answer sets of CW(II) are indeed related to the answer sets of II as we expect. Let Pos stand for the set of all positive ground literals in the language of II.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 4</head><p>If S is an answer set of a general logic program II, then S U {~A: A ~ Pos\S} <ref type="bibr" target="#b13">(14)</ref> is an answer set of CW(II). Moreover, every answer set of CW(II) can be represented in the form <ref type="bibr" target="#b13">(14)</ref>, where S is an answer set of II.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>Without loss of generality, we can assume that II doesn't contain variables. Then the result II' of replacing all rules in CW(II) by their ground instances can be written as</p><p>Let S be an answer set of 1-I; we need to show that <ref type="bibr" target="#b13">(14)</ref> is then an answer set of II'. Denote ( <ref type="formula">14</ref>) by S'. By the definition of II s (Section 2),  (ii) if S contains a pair of complementary literals, then S = Lit.</p><p>Consider, for instance, the database <ref type="bibr" target="#b14">(15)</ref>, with the second rule replaced by its ground instances. It has two answer sets: {Employed(Jack, Stanford), Adequate-Income(Jack)} and { Employed(Jack, SRI), A dequate-Income(Jack) }.</p><p>The answer to a query may depend now on which answer set is selected. For instance, the answer to the query Employed(Jack, Stanford) relative to the first answer set is yes, and the answer to the same query relative to the second set is unknown. The answer to Adequate-Income(Jack) is unconditionally yes.* Now let 11 be any extended disjunctive database without variables. For any set S c Lit, let II s be the extended disjunctive database obtained from II by deleting ( i ) each rule that has a formula not L in its body with L ~ S, and (ii) all formulas of the form not L in the bodies of the remaining rules. Clearly, II s doesn't contain not, so that its answer sets are already defined. If S is one of them, then we say that S is an answer set of II.** In order to apply the definition of an answer set to an extended disjunctive database with variables, we first replace each rule by its ground instances.</p><p>As an example, let us add the closed world assumption for Employed Employed ( x, y) *--not <ref type="bibr">Employed ( x, y )</ref> to <ref type="bibr" target="#b14">(15)</ref>. The new database has two answer sets: {Employed(Jack, Stanford), ~ Employed(Jack, SRI), Adequate-Income(Jack)} and { Employed(Jack, SRI), ~ Employed(Jack, Stanford), Adequate-Income(Jack)}.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Minimalism Subsumes Default Logic and Cricumscription</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bidoit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Froidevaux</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of LICS-87</title>
				<meeting>of LICS-87</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="89" to="97" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Negation by Default and Nonstratifiable Logic Programs</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bidoit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Froidevaux</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="volume">437</biblScope>
		</imprint>
		<respStmt>
			<orgName>Universit6 Paris XI</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Paraconsistent Logic Programming</title>
		<author>
			<persName><forename type="first">H</forename><surname>Blair</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">S</forename><surname>Subrahmanian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">68</biblScope>
			<biblScope unit="page" from="135" to="154" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A Kripke-Kleene Semantics for Logic Programs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fitting</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Joternal of Logic Programming</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="295" to="312" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The Stable Model Semantics for Logic Programming</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gelfond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Lifschitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Fifth Int&apos;l Conf. and Symp</title>
				<editor>
			<persName><forename type="first">Logic</forename><surname>Programming</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">(</forename><forename type="middle">R</forename><surname>Kowalski</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><surname>Bowen</surname></persName>
		</editor>
		<meeting>of the Fifth Int&apos;l Conf. and Symp</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="1070" to="1080" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Compiling Circumscriptive Theories into Logic Programs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gelfond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Lifschitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2nd International Workshop</title>
		<title level="s">Lecture Notes in Artificial Intelligence</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Reinfrank</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>De Kleer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Ginsberg</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Sandewall</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">346</biblScope>
			<biblScope unit="page" from="74" to="99" />
		</imprint>
	</monogr>
	<note>Non-Monotonic Reasoning</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Logic Programs with Classical Negation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gelfond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Lifschitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Seventh Int&apos;l Conf</title>
				<editor>
			<persName><forename type="first">Logic</forename><surname>Programming</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">(</forename><forename type="middle">D</forename><surname>Warren</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Szeredi</surname></persName>
		</editor>
		<meeting>of the Seventh Int&apos;l Conf</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="579" to="597" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On Stratified Autoepistemic Theories</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gelfond</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. AAAI-87</title>
				<meeting>AAAI-87</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="207" to="211" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Autoepistemic Logic and Formalization of Commonsense Reasoning</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gelfond</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2rid International Workshop</title>
		<title level="s">Lecture Notes in Artificial Intelligence</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Reinfrank</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>De Kleer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Ginsberg</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Sandewall</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">346</biblScope>
			<biblScope unit="page" from="176" to="186" />
		</imprint>
	</monogr>
	<note>Non-Monotonic Reasoning</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Logic Programs with Exceptions</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kowalski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Sadri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Seventh Int&apos;l Conf</title>
				<editor>
			<persName><forename type="first">Logic</forename><surname>Programming</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">(</forename><forename type="middle">D</forename><surname>Warren</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Szeredi</surname></persName>
		</editor>
		<meeting>of the Seventh Int&apos;l Conf</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="598" to="613" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The Treatment of Negation in Logic Programs for Representing Legislation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kowalski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Second Int&apos;t Conf. on Artificial Intelligence and Law</title>
				<meeting>of the Second Int&apos;t Conf. on Artificial Intelligence and Law</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="11" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Between Circumscription and Autoepistemic Logic</title>
		<author>
			<persName><forename type="first">V</forename><surname>Lifschitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the First Int&apos;l Conf. on Principles of Knowledge Representation and Reasoning</title>
				<editor>
			<persName><forename type="first">R</forename><surname>Brachman</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Levesque</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Reiter</surname></persName>
		</editor>
		<meeting>of the First Int&apos;l Conf. on Principles of Knowledge Representation and Reasoning</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="235" to="244" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Argument Systems: A Uniform Basis for Nonmonotonic Reasoning</title>
		<author>
			<persName><forename type="first">F</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Shoham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the First lnt&apos;l Conf. on Principles of Knowledge Representation and Reasoning</title>
				<editor>
			<persName><forename type="first">R</forename><surname>Brachman</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Levesque</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Reiter</surname></persName>
		</editor>
		<meeting>of the First lnt&apos;l Conf. on Principles of Knowledge Representation and Reasoning</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="245" to="255" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Foundations of Logic Programming</title>
		<author>
			<persName><forename type="first">J</forename><surname>Lloyd</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984">1984</date>
			<publisher>Sprin~ger-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Autoepistemic Logic, Defaults and Truth Maintenance</title>
		<author>
			<persName><forename type="first">W</forename><surname>Marek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Truszczyfiski</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
	<note>Manuscript</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Relating Autoepistemic and Default Logic</title>
		<author>
			<persName><forename type="first">W</forename><surname>Marek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Truszczyfiski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc</title>
				<meeting>null</meeting>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
