<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">MONDRIAN: Annotating and querying databases through colors and blocks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Floris</forename><surname>Geerts</surname></persName>
							<email>fgeerts@inf.ed.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="department">School of Informatics</orgName>
								<orgName type="institution">University of Edinburgh</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Anastasios</forename><surname>Kementsietsidis</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">School of Informatics</orgName>
								<orgName type="institution">University of Edinburgh</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Diego</forename><surname>Milano</surname></persName>
							<email>diego.milano@dis.uniroma1.it</email>
							<affiliation key="aff2">
								<orgName type="department">Dipartimento di Informatica e Sistemistica</orgName>
								<orgName type="institution">Universit√† di Roma &quot;La Sapienza</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">MONDRIAN: Annotating and querying databases through colors and blocks</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">557EDF66B3AF168D23A9D543A2595614</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:33+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Annotations play a central role in the curation of scientific databases. Despite their importance, data formats and schemas are not designed to manage the increasing variety of annotations. Moreover, DBMS's often lack support for storing and querying annotations. Furthermore, annotations and data are only loosely coupled. This paper introduces an annotation-oriented data model for the manipulation and querying of both data and annotations. In particular, the model allows for the specification of annotations on sets of values and for effectively querying the information on their association. We use the concept of block to represent an annotated set of values. Different colors applied to the blocks represent different annotations. We introduce a color query language for our model and prove it to be both complete (it can express all possible queries over the class of annotated databases), and minimal (all the algebra operators are primitive). We present MONDRIAN, a prototype implementation of our annotation mechanism, and we conduct experiments that investigate the set of parameters which influence the evaluation cost for color queries.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>From biology to astronomy, scientific databases play a central role in the advancement of science by providing access to large collections of data. At the same time, these databases are of particular interest to computer scientists due to the challenges that they pose in terms of data management <ref type="bibr" target="#b7">[9]</ref>. Apart from the often staggering amounts of data, there are two additional characteristics of scientific databases that make their management challenging. First, the data stored in scientific databases often have different formats which range from flat-formatted files to images and electronic publications. Thus, part of the challenge is to integrate <ref type="bibr" target="#b13">[15]</ref>, annotate <ref type="bibr">[7]</ref> and cross-reference <ref type="bibr" target="#b18">[20]</ref> such diverse collections of data. Second, scientists often analyze data that are collected from a variety of sources and, in turn, this analysis results in new data which are used by other scientists, resulting a continuous feedback of data. In such a setting, it becomes difficult for scientists to keep track of where the particular data that they are using came from. Thus, the challenge here is to maintain data provenance <ref type="bibr" target="#b8">[10,</ref><ref type="bibr" target="#b20">22]</ref>.</p><p>In this paper, we offer a new model to annotate databases and a new language to query annotated databases. Our work is motivated by the pressing needs of biological databases and our examples are drawn from this domain. Figure <ref type="figure" target="#fig_0">1</ref> shows example relations from three biological databases, namely, GDB  Relations from three biological sources <ref type="bibr" target="#b1">[2]</ref> (a human gene database), Swissprot <ref type="bibr" target="#b2">[3]</ref> (a protein database), and PIR <ref type="bibr" target="#b0">[1]</ref> (a protein sequence database).</p><p>In Figure <ref type="figure" target="#fig_0">1</ref>(a), relation GDB records for each gene its identifier, name, and chromosome. In Figure <ref type="figure" target="#fig_0">1</ref>(b), relation Swissprot stores the identifier of each protein, its name, and the related species. Finally, in Figure <ref type="figure" target="#fig_0">1</ref>(c), the PIR relation stores protein sequence identifiers and their names.</p><p>Two key points distinguish our work from existing annotation mechanisms. First, we argue that for an annotation mechanism to be useful in practice, it should be able to support the annotation of value associations. In the literature, existing annotation mechanisms assume that each annotation is attached to a particular value of a specific attribute (e.g., see <ref type="bibr" target="#b5">[6]</ref>). So, one can annotate, for example, the gene name NF1, in Figure <ref type="figure" target="#fig_0">1(a)</ref>, with the name of the researcher that discovered this gene. A possible implementation of such a mechanism requires adding a column, say annot gname, in the GDB relation and use it to store the annotations of the gname column values.</p><p>However, in a number of domains, including scientific databases, it becomes increasingly important to annotate not only data values but also value associations. This need is highlighted by the Gene Ontology (GO) database website <ref type="bibr" target="#b11">[13]</ref> which states the importance to support advanced annotations to express complex statements of the form: "gene G has function F during process P in cell component C". In the GO database, such a statement is currently represented by annotating three independent associations, namely, between the gene G and function F (G, F), the gene G and process P (G, P), the gene G and cell C (G, C). The first and second associations are annotated with the term "acts during", while the first and third associations are annotated with the term "acts in". However, as stated in the website, this first attempt to support complex annotations is still unsatisfactory since it only supports the annotation of binary associations (hence, it is not evident in the current representation that all three binary associations form one logical unit).</p><p>As another example, consider the relation shown in Figure <ref type="figure" target="#fig_1">2</ref>. This relation results from partially integrating the relations in Figure <ref type="figure" target="#fig_0">1</ref>. The relation associates gene identifiers from the GDB database to protein (and protein sequence) identifiers from the Swissprot and PIR databases. The semantics of this association is that the specified gene is related to the indicated protein (and protein sequence). Such relations are widely used in the biological domain and offer a quick way to cross-reference and establish associations between independent biological sources <ref type="bibr" target="#b18">[20,</ref><ref type="bibr" target="#b20">22]</ref>. In this setting, it is useful to record, for each association, what evidence exists for its validity <ref type="bibr" target="#b11">[13]</ref>. In the figure, we show possible annotations of the integrated relation in the form of blocks and block labels. In more detail, blocks are used to indicate the set of values for which an annotation exists, while block labels are used to indicate the annotations themselves. In our example, the annotations indicate the names of the curators who verified that a particular association holds. So, in the first tuple, a block indicates Mary's belief that the gene with GDB id 120231 produces protein with id P21359. Although conceptually easy to illustrate, complex annotations like those shown here pose interesting challenges in terms of how they can be implemented. In this paper, we propose an implementation that has two desirable properties: first, it does not require any restructuring of the existing schema of the database to be annotated (only extra tables need to be added); and second, it is such that the annotation of the database imposes minimum overhead both in terms of space, and in terms of query execution time when compared to its unannotated version.</p><p>Our second claim about annotations is that they should be treated as first-class citizens of the database, that is, we should be able to query values and annotations alike (in isolation or in unison). Currently, query languages cannot see the annotations and they can only transmit them <ref type="bibr" target="#b9">[11]</ref>. However, for curators, annotations are of equal or even greater importance than values. A curator using the relation in Figure  As another example, the curator might be interested in finding which gene-protein sequence (gid, sid) pairs are annotated, and by whom. This is not a value-based annotation query. Rather, it refers to the attributes on which annotations are applied on each tuple. Finally, we note that sometimes the lack of annotations might also be of interest to a curator. In a heavily curated database, like Swissprot, a curator might want to find which gene-protein (gid, pid) pairs are not annotated. All these operations assume that we have a query language capable of expressing queries over annotated databases.</p><p>Desirable properties of such a query language are that it is at a level of abstraction that is independent of the chosen representation of annotations and that it is user friendly. Any relational representation of annotated databases that we can think of offers the relational algebra or, on a practical level, SQL as candidate query languages. However, each query posed in these languages is not annotation-representation independent. A change in the representation of annotations requires us to reformulate all our queries. Furthermore, while writing such queries, we should make sure that the result of each query must be interpretable as an annotated database again. It is clear that one needs to pose severe syntactic and semantic conditions on such queries in order to achieve this goal. It is not clear what these conditions should be.</p><p>We opt for a different approach and introduce a new query language hereafter referred to as the color algebra (since we use colors to represent annotations). By definition, our algebra is annotation-representation independent. Furthermore, any query in this language produces a color (annotated) relation on every input color relation. Moreover, the semantics of colors and blocks is transparent in each algebra operator. Our algebra facilitates the querying of color databases and can easily express queries such as the ones described in the previous paragraphs.</p><p>The contributions of this paper are as follows: ‚Ä¢ We introduce an annotation mechanism for relational databases that is capable of annotating both single values and the associations between multiple values. We investigate generic properties of annotations and, through these properties, we are able to define annotations with a range of semantics. To the best of our knowledge, our mechanism is both the first to support the annotation of value associations and the first to investigate the properties of annotations.</p><p>‚Ä¢ We introduce an algebra to query values and annotations alike. Our algebra includes well-known operators, like selection and projection, properly re-defined to account for colors and blocks, along with new operators that are particular to the querying of annotations. We formalize the notion of annotation in relational databases and we prove that our algebra is both complete (it expresses all possible queries over annotated databases) and minimal (every operator is primitive, and thus necessary).</p><p>‚Ä¢ We present MONDRIAN <ref type="foot" target="#foot_0">1</ref> which is an implementation of our annotation mechanism over a relational DBMS. We investigate the space overhead of our representation, and we study the cost of evaluating queries over annotated databases and the parameters that influence this cost.</p><p>The remainder of this paper is organized as follows. First, we review related work. Section 2 introduces the basic notions of colors and blocks. Section 3 presents the color algebra while Section 4 describes the relational representation and presents the completeness result. Section 5 introduces MONDRIAN and offers a description of our implementation and experiments. Section 6 concludes with a summary of the results and a discussion on future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.">Related work</head><p>Most existing annotation systems focus on text and HTML documents (e.g., Annotea <ref type="bibr" target="#b16">[18]</ref>) and are often specialized to support annotations for a particular kind of data, e.g., genomic sequences <ref type="bibr" target="#b17">[19,</ref><ref type="bibr">7]</ref>. Research on these systems has been focused on scalability, distributive support of annotations, and other features.</p><p>Bhagwat et al. <ref type="bibr" target="#b5">[6]</ref> propose an annotation mechanism for relational databases where annotations are stored in extra annotation attributes. The authors extend the Select-Project-Join-Union fragment of SQL with a PROPAGATE clause which allows the user to specify how annotations should propagate. The focus is thus on the propagation of the annotations through queries, and the issue of how to query the annotations themselves is not addressed. Also, only single values are annotated. The DBNotes system <ref type="bibr" target="#b10">[12]</ref> extends this framework and offers limited support of querying annotations over single values.</p><p>A more extensive literature exists regarding the computation of provenance. Annotations provide a solid way of keeping track of provenance. Indeed, computing provenance by forwarding annotations along data transformations has been proposed in various forms <ref type="bibr" target="#b21">[23,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b16">18,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b19">21]</ref>. The data provenance problem without the use of annotation is studied by Cui et al. <ref type="bibr" target="#b12">[14]</ref>, Buneman et al. <ref type="bibr" target="#b8">[10,</ref><ref type="bibr" target="#b9">11]</ref>, and Widom <ref type="bibr" target="#b22">[24]</ref>. In this work, a "reverse" query is generated to compute data provenance. In this paper, we will not address the issue of provenance. Instead we provide a foundation on which both provenance information and other forms of annotations can be managed.</p><p>An unrelated work (although the title suggests otherwise) regards "Colorful XML" <ref type="bibr" target="#b15">[17]</ref>. A new XML data model, called multi-colored trees, is proposed and colors are used to add semantic structure over the XML data nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Colors and blocks</head><p>As already mentioned, our aim is to provide a mechanism for annotating groups of attribute values. We refer to such a group of attribute values as a block. As an example, in Figure <ref type="figure" target="#fig_1">2</ref>, there are six different blocks, and each block has an associated annotation. In the remainder of the paper, for ease of presentation and notational convenience, we assume that each annotation is represented by a color. Therefore, instead of talking about annotations and annotated blocks we talk about colors and color blocks, respectively. Similarly, we talk about color databases (databases that are annotated) and color queries (queries on annotated databases) that are written using a color algebra (an algebra that accounts for annotations).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Coloring notations and properties</head><p>We first describe the data model used in this paper. Let D be a standard relational database consisting of the relations R 1 , . . . , R k . For each relation R i , we denote its set of attributes by sort(R i ), while we use r i to denote an instance of the relation. We use upper-case letters early in the alphabet (A, B, . . .) to denote attribute names while upper-case letters late in the alphabet (X, Y, . . .) are used to denote sets of attributes. Accordingly, lower-case letters early in the alphabet (a, b, . . .) are used to denote attribute values, while those late in the alphabet (x, y, . . .) are used to denote sets of attributes values. Finally, C denotes a set of colors.</p><p>Let r be an instance of relation R and let t be a tuple in r. The annotation, or coloring, of a tuple t is performed through a coloring function œá. Function œá accepts as input a tuple t and a non-empty set of attributes Y ‚äÜ sort(R) and assigns a set of colors to the values in t[Y ]. For a tuple t, the triplet (t, Y, œá(t, Y )) defines a color block which consists of the attribute values in t[Y ] along with their assigned colors. If œá(t, Y ) = ‚àÖ, then the values in t[Y ] are not within a color block. Hereafter, we use r, œá to denote a relation r whose tuples are colored through function œá.</p><p>Example 1. Consider the relation in Figure <ref type="figure" target="#fig_1">2</ref>. Then, the coloring of each tuple in the relation is expressed through the following coloring function œá (where, t i is the ith tuple in the relation):</p><formula xml:id="formula_0">œá(t 1 , {pid, gid}) = {John} œá(t 1 , {gid, sid})= {Mary} œá(t 2 , {pid, gid}) = {John, Mary} œá(t 2 , {gid, sid})= {John} œá(t 3 , {gid, sid})= {Mary} œá(t 4 , {pid, gid, sid}) = {Peter} Note that œá(t i , Y</formula><p>) is equal to the empty set, for every tuple t i and every other set of attributes Y .</p><p>Color blocks permit the specification of annotations with diverse semantics. As an example, consider Figure <ref type="figure" target="#fig_1">2</ref>. A color could represent a curator who has approved or verified an association of values. Alternatively, a color may indicate just the provenance of values. We present below a set of properties of colors and blocks that can be used to capture such diverse semantics. Furthermore, we use these properties while answering queries over the color databases. Block overlapping We allow an attribute value t[A], A ‚àà sort(R) to participate in more than one color blocks. Intuitively, this property allows a value to participate in multiple independent annotated associations. This is the case in Figure <ref type="figure" target="#fig_1">2</ref> where, in the first tuple, the gene with GDB id 120231 is colored twice, once because it produces the Swissprot protein P21359 and once because it is associated to the PIR protein sequence with id I78852. Inheritance We say that a coloring function is inheriting if for every color block (t, Y, œá(t, Y )), and every set of attributes Y ‚Ä≤ ‚äÜ Y , the following blocks are implied:</p><formula xml:id="formula_1">(t, Y ‚Ä≤ , œá(t, Y ‚Ä≤ )) is a block with œá(t, Y ‚Ä≤ ) ‚äá œá(t, Y )</formula><p>Intuitively, in certain domains, we want to place a set of values within a color block and, at the same time, we want any possible subsets of these values to inherit this color. For example, assume that the annotations in Figure <ref type="figure" target="#fig_1">2</ref> denote that certain genes and proteins are mentioned in a publication whose author name appears in the annotation. Then, we expect that the annotation is also inherited by any subset of these values since any such subset is in the publication.</p><p>A coloring function is non-inheriting if no blocks are implied apart from the ones explicitly defined by the function. As we discussed in the introduction, we often annotate values because they have a property as a set, while no subset of these values has the property. As an example, consider the annotations in Figure <ref type="figure" target="#fig_1">2</ref> which represent names of curators who believe that certain genes and proteins are related. Remember that these annotations are on the relationship between genes and proteins and not the individual values. Transitivity We say that a coloring function œá is transitive if for any two blocks (t, X, œá(t, X)) and (t, Y, œá(t, Y )), with œá(t, X) ‚à© œá(t, Y ) = ‚àÖ, the following color block exists (t, X ‚à™ Y, œá(t, X) ‚à© œá(t, Y )). Intuitively, a transitive function merges blocks whose sets of colors overlap. This might be desirable when, for example, we have a coloring function such as the one of Figure <ref type="figure" target="#fig_1">2</ref>, which expresses the belief of a curator in an association. In the second tuple of the figure, curator John has validated the association of both the pid A45770 with the gid 120232, and the association of this gid with sid P35240. If we assume a transitive coloring function, then a color block with all three values is implied whose semantics is that John has validated the association of all the values in the tuple.</p><p>Given the introduced notation and properties, in the next section, we present an algebra that can be used to query color databases. The algebra includes standard operators, like selection and projection, properly re-defined to account for colors and blocks, along with a set of block-specific operators. In this paper, we do not consider negation in our algebra. Its inclusion is part of our future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Color algebra (CA)</head><p>In what follows, we introduce the main set of operators of the color algebra (CA) and we present a number of examples to illustrate their use. We start with two basic operators through which we can refer relations in our database and introduce new constants.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Input relation:</head><p>The operator R accepts as input an instance r, œá and returns r, œá , if r is an instance of R, and the empty relation otherwise.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Unary singleton constant:</head><p>We allow for the creation of (un-)annotated single values. Specifically, the operator (A, a) takes as input any instance r, œá and returns the instance of sort {A} containing a unique element a. The operator (A, a, c) takes as input any instance r, œá and returns the instance of sort {A} </p><formula xml:id="formula_2">r ‚Ä≤ = {t[A 1 , . . . , A k ] | t ‚àà r} (normal projection)</formula><p>and for any t ‚àà r, and any</p><formula xml:id="formula_3">Y ‚äÜ {A 1 , . . . , A k }, œá ‚Ä≤ (t[A 1 , . . . , A k ], Y ) = Z œá(t, Y ‚à™ Z),</formula><p>where Z ranges over all subsets of sort(R) \ {A 1 , . . . , A k }. Our projection operator treats the coloring function as an inheriting one since it projects the blocks in each tuple of r to the projected attributes. In the end of this section, we show how to define an alternative projection operator that treats the coloring function as non-inheriting.</p><p>Example 2. Consider the relation r, œá shown in Figure <ref type="figure" target="#fig_1">2</ref>. Then, expression œÄ pid,gid (r) returns the relation r ‚Ä≤ shown in Figure <ref type="figure" target="#fig_2">3</ref>(a). Notice that, due to inheritance, tuples t 1 , t 2 and t 3 have blocks involving only the {gid} attribute, while tuple t 4 has a block involving the {pid,gid} attributes.</p><p>The projection operator removes parts of a relational instance based on schema-level information. Here, we introduce a corresponding operator that uses schema-level information to remove blocks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Block Projection:</head><p>We offer two types of block projection that allow for the projection of blocks based on whether blocks contain or are contained in a specified set of attributes. Specifically, the L-type (Lower) block projection operator Œ† L A1,...,A k takes as input an instance r, œá of sort containing {A 1 , . . . , A k }, and returns the instance r ‚Ä≤ , œá ‚Ä≤ of the same sort defined by r ‚Ä≤ = {t | t ‚àà r and there exists a block (t, Y, œá(t, Y )) with A 1 , . . . , A k ‚äÜ Y } and for any t ‚àà r ‚Ä≤ , and any set of attributes Y ‚äÜ sort(R ‚Ä≤ ),</p><formula xml:id="formula_4">œá ‚Ä≤ (t, Y ) = œá(t, Y ) if {A 1 , . . . , A k } ‚äÜ Y , œá(t, Y ) = ‚àÖ; ‚àÖ otherwise.</formula><p>The U-type (Upper) projection operator Œ† U A1,...,A ‚Ñì is defined similarly, except that r ‚Ä≤ = r and in the definition of œá ‚Ä≤ (t, Y ), Y ‚äÜ {A 1 , . . . , A k } must hold. We also define Œ† L ‚àÖ = Id, while Œ† U ‚àÖ only returns the unannotated tuples.</p><p>Example 3. Consider the relation r, œá in Figure <ref type="figure" target="#fig_2">3(a)</ref>. Assume that we want to find all the tuples with at least one annotation that involves the protein identifier (pid) attribute. Expression Œ† L pid (r) returns the desired result, shown in Figure <ref type="figure" target="#fig_2">3(b)</ref>. Operator Œ† L sets a lower bound on the set of attributes that must participate in a selected block. Thus, in our example, both tuples that do not have an annotation involving the pid attribute, and blocks that do not annotate the attribute, are removed. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 4. The selection and union operators</head><p>On the other hand, we may want all the tuples of relation r that might have an annotation only on the gid attribute. Then, the expression Œ† U gid (r) finds all such tuples. The resulting relation is shown in Figure <ref type="figure" target="#fig_2">3(c</ref>). Operator Œ† U sets an upper bound on the set of attributes that may participate in a selected block. Blocks only involving a subset of this upper bound are also selected. In our example, any block that involves an attribute other that gid is removed.</p><p>We note that an unannotated tuple always satisfies the condition of the Œ† U operator while it always violates the condition of the Œ† L operator. Thus, it is always preserved by the former and dropped by the latter.</p><p>By combining Œ† L and Œ† U , we can find all tuples that have a block on a specific attribute set (and only this set). Expression Œ† L gid (Œ† U gid (r)) returns all tuples with a block on gid alone. These are the first three tuples in Figure <ref type="figure" target="#fig_2">3(c)</ref>.</p><p>Selection: On input r, œá , operator œÉ A=a returns the instance r ‚Ä≤ , œá ‚Ä≤ of the same sort defined by r ‚Ä≤ = {t | t ‚àà r, t[A] = a} and œá ‚Ä≤ is the restriction of œá to r ‚Ä≤ .</p><p>On input r, œá of sort containing {A, B}, operator œÉ A=B returns the instance r ‚Ä≤ , œá ‚Ä≤ of the same sort defined by</p><formula xml:id="formula_5">r ‚Ä≤ = {t | t ‚àà r, t[A] = t[B]}. Concerning œá ‚Ä≤ , for any t ‚àà r ‚Ä≤ , and any Y ‚äÜ sort(R ‚Ä≤ ) we have that œá ‚Ä≤ (t, Y ) = œá(t, Y ) A, B ‚àà Y ; œá(t, Y ) ‚à© Œ≤(t, A) ‚à© Œ≤(t, B) otherwise.</formula><p>where Œ≤(t, A) (resp. Œ≤(t, B)) is the set of colors of all blocks in t containing attribute A (resp. B). So, for tuples that satisfy the selection condition at the value level, only those blocks containing A (resp. B) for which there exists a block, of the same color, containing B (resp. A), are selected. If no such blocks exist, the selection attributes become unannotated. Thus, selection requires an agreement on both the data and block level, as one of our following examples illustrates (Example 5).</p><p>Similar to the selection operator, that identifies tuples with a particular data value, we offer a block selection operator that identifies blocks which have a specific color.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Block Selection:</head><p>The operator Œ£ c , where c ‚àà C, takes as input any instance r, œá and returns the instance r ‚Ä≤ , œá ‚Ä≤ of the same sort defined by r ‚Ä≤ = {t | t ‚àà r and there exists a block in t of color c}, and for any t ‚àà r ‚Ä≤ and any set of attributes</p><formula xml:id="formula_6">Y ‚äÜ sort(R), œá ‚Ä≤ (t, Y ) = œá(t, Y ) ‚à© {c}.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Union:</head><p>The union operator takes as input any two instances r, œá r and s, œá s , of the same sort, and returns the instance r ‚Ä≤ , œá ‚Ä≤ of the same sort defined by r ‚Ä≤ = s ‚à™ r (set union) and for any t ‚àà r ‚Ä≤ , and any set of attributes Y ‚äÜ sort(R ‚Ä≤ ), we have that œá</p><formula xml:id="formula_7">‚Ä≤ (t, Y ) = œá r (t, Y ) ‚à™ œá s (t, Y ).</formula><p>Example 4. Consider again relation r, œá in Figure <ref type="figure" target="#fig_1">2</ref>. Assume that we want to find all the tuples that have a block annotated by Mary, or concern the protein with sid P08138. Also, assume that we are only interested in keeping the {gid, sid} attributes from these tuples. Then, the expression œÄ gid,sid ((Œ£ Mary (r)) ‚à™ (œÉ sid="P 08138" (r)))</p><p>returns the desired result. Figure <ref type="figure">4</ref> shows both the intermediate results for each part of the union, and the final result of the query. Notice that the block selection operator maintains only the tuples that have at least one annotation from Mary. At the same time, from these tuples, the operator keeps only the blocks belonging to Mary. On the other hand, a selection predicate of the form A = a focuses on values without altering the block structure. Our next example shows that this is not the case for selections of the form</p><formula xml:id="formula_8">A = B.</formula><p>The next two operators are of particular importance both for the completeness of our algebra and because, along with the selection operator, they define the color join.</p><p>Product: Given two instances r, œá r and s, œá s of disjoint sorts, the product operator √ó returns the instance r ‚Ä≤ , œá ‚Ä≤ with sort(R ‚Ä≤ ) = sort(R) ‚à™ sort(S) defined by r ‚Ä≤ = r √ó s (normal product). For any tuple t ‚àà r ‚Ä≤ and Y ‚äÜ sort(R ‚Ä≤ ),</p><formula xml:id="formula_9">œá ‚Ä≤ (t, Y ) = Ô£± Ô£¥ Ô£≤ Ô£¥ Ô£≥ œá r (œÄ sort(R) (t), Y ) if Y ‚äÜ sort(R); œá s (œÄ sort(S) (t), Y ) if Y ‚äÜ sort(S); ‚àÖ otherwise.</formula><p>Merge: Assuming a transitive coloring function, a natural operation on blocks is merging. The merge operator ¬µ Y,Z , with Y, Z being sets of attributes such that Y ‚à© Z = ‚àÖ, takes as input instances r, œá of sort sort(R) containing Y ‚à™ Z and returns the instance r ‚Ä≤ , œá ‚Ä≤ of the same sort defined by r ‚Ä≤ = r. For any t ‚àà r ‚Ä≤ and any</p><formula xml:id="formula_10">X ‚äÜ sort(R), œá ‚Ä≤ (t, X) = œá(t, X 1 ) ‚à© œá(t, X 2 ), where X = X 1 ‚à™ X 2 , X 1 ‚äÜ Y , X 2 ‚äÜ Z and œá(t, X) = ‚àÖ.</formula><p>Intuitively, the merge operator considers each tuple t and it identifies pairs of blocks that are contained in Y and Z, respectively, and have the same color. Then, it replaces two equi-colored blocks with a new block that is the result of their merging. Blocks that are contained in Y and Z but cannot be merged, are dropped, as are the blocks not contained in Y and Z.</p><p>Renaming: Let f be an attribute renaming of a finite set of attributes R such that f (A) = A. The renaming operator Œ¥ f accepts as input an instance r, œá of sort R, and returns the instance r ‚Ä≤ , œá ‚Ä≤ of sort f (R) defined by</p><formula xml:id="formula_11">r ‚Ä≤ = {t ‚Ä≤ | t ‚àà r and ‚àÄA ‚àà R, t(A) = t ‚Ä≤ (f (A))},</formula><p>Furthermore, for any t ‚Ä≤ ‚àà r ‚Ä≤ and any set of attributes  <ref type="figure" target="#fig_3">5(a</ref>) and (b) for convenience). Figure <ref type="figure" target="#fig_3">5(c)</ref> shows the relation that results from taking the product of r and r ‚Ä≤ and applying an equality condition on the gid attribute, that is,</p><formula xml:id="formula_12">Y ‚Ä≤ ‚äÜ sort(R ‚Ä≤ ), œá ‚Ä≤ (t ‚Ä≤ , Y ‚Ä≤ ) = œá(t, Y ), where Y = {A 1 , . . . , A k } and f (A i ) = A ‚Ä≤ i and t ‚Ä≤ [f (A i )] = t[A i ] for i ‚àà [1, k].</formula><formula xml:id="formula_13">œÉ gid=gid' (r √ó Œ¥ f (r ‚Ä≤ ))</formula><p>where f is a renaming function such that f (gid) = gid ‚Ä≤ and f (sid) = sid ‚Ä≤ . Notice that the selection only selects those blocks containing gid which have a equi-colored block containing gid', and vice versa. If no such blocks exists, as is the case for gid 120231, the resulting tuple is unannotated.</p><p>Given the relation in Figure <ref type="figure" target="#fig_3">5</ref>(c), we may want to remove the duplicate gid column, through projection. However, depending on which of the two gid columns we project out, we end up with a different block structure. The two possible outcomes are shown in Figures <ref type="figure">6(a</ref>) and (b). We can avoid such an undesirable situation by using the ¬µ {pig, gid},{gid', sid'} operator. After the merge operator is applied, irrespectively of which of the two attributes is projected out, the resulting relation is the same. This is shown in Figure <ref type="figure">6(c)</ref>.</p><p>The presented operators, along with the operators of union, renaming, and recoloring (which changes the color of a block), which are not presented here, constitute the whole set of operators of our algebra. Since the result of each operator on a color relation is again a color relation, we can compose all operators. Our first theoretical result shows that we cannot hope to reduce the set of operators in our algebra and that all the operators are necessary. In the next section, Theorem 3 shows that our operators are also sufficient for our needs.</p><p>Theorem 1 (Minimality). The set of operators in the color algebra is minimal.</p><p>Proof: The proof considers each operator in turn and shows that it cannot be expressed in terms of the other operators. We refer to the appendix for the full details) . We conclude this section with a few observations. The first observation concerns the color queries that are written using the color operators that have a relational algebra counter-part (e.g. selection, projection, product). Each such color query results in the same set of tuples as the one we would get by applying the corresponding relational algebra query on an unannotated database. The difference between the two queries is the presence of blocks. Thus, by using the CA algebra, we don't lose any data.</p><p>Our second observation relates to our discussion on annotation properties. By default, we offer a projection operator that assumes an inheriting coloring function. However, our algebra can express a (nonprimitive) projection operator that assumes a non-inheriting function. Indeed, the expression</p><formula xml:id="formula_14">œÄ A1,‚Ä¢‚Ä¢‚Ä¢ ,A k (Œ† U A1,‚Ä¢‚Ä¢‚Ä¢ ,A k (r))</formula><p>does exactly this. For flexibility, we choose not to encode such a property in each individual block. Instead, at query time, we allow each user to decide how she wants to interpret the coloring functions by applying appropriate operators.</p><p>Our final observation is that we can define a color join in CA as well. This join identifies attributes based on both their values and block structure and merges the "common" blocks. More specifically, we define r, œá r ‚ä≤‚ä≥ s, œá s by the expression (assuming we join on attributes A i and A j )</p><formula xml:id="formula_15">œÄ sort(r)‚à™sort(s)\{Aj} ¬µ sort(r),sort(s) (Œ† L Ai (œÉ Ai=Aj (r √ó s)) ‚à™ (Œ† L Aj œÉ Ai=Aj (r √ó s)))</formula><p>As noted in Example 5, we obtain an equivalent expression when projection includes A j instead of A i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Connection with relational model</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Relational representation</head><p>In this section, we provide a relational representation of color databases. In what follows, we define a mapping rep from color databases to a special type of relational databases. Let CD denote the class of color databases, and let S denote the image set rep(CD) in the class of all relational databases. We also define the inverse mapping rep -1 , but only on S.</p><p>Let r, œá be a color relation instance over R. Let sort(R) = {A 1 , . . . , A k }. We define the relation S of sort {A 1 , . . . , A k , B 1 , . . . , B k , Œ≥}, where the attributes A i are of type data, the attributes B i are of type Boolean, and the Œ≥ attribute is of type color. Moreover, we assume that there is a bijection between the data and Boolean attributes. We denote by assoc(A i , B i ) that A i are B i are mapped onto each other by this bijection. The Boolean attributes are used to determine which of the corresponding data attributes belong to a block. We denote the class of relational databases satisfying the above schema constraints by S.</p><p>For each annotated tuple t ‚àà r and each Y ‚äÜ sort(R) such that œá(t, Y ) = ‚àÖ, we populate the relation rep( r, œá ) by adding to it the set of tuples</p><formula xml:id="formula_16">{(t, B 1 , . . . , B k , c) | c ‚àà œá(t, Y )},</formula><p>where B i = 1 if A i ‚àà Y and assoc(A i , B i ) holds, and b i = 0 otherwise. Furthermore, for each tuple t ‚àà r, we insert an unannotated tuple (t, 0, . . . , 0, c) in the representation, where c is a color not appearing in r. This concludes the definition of mapping rep. The extension to color databases, i.e., a set of color relations, is defined analogously.</p><p>Concerning rep -1 , if we are given a relational instance s in class S, whose schema is {A 1 , . . . , A k , B 1 , . . . , B k , Œ≥}, we can easily convert s back to a color relation rep -1 ( r, œá ). Due to lack of space, we omit the details of how this is achieved. Example 6. Consider again the color relation r, œá given in Figure <ref type="figure" target="#fig_1">2</ref>. The following relation contains the three tuples in rep( r, œá ) which correspond to the representation of the first tuple in r, œá . We assume that assoc(pid, bpid), assoc(gid, bgid), and assoc(sid, bsid). A few words about the choice of representation. First, we note that we can normalize our representation so that the values of a tuple are not repeated for every block. Separating the data from the annotation representation not only saves space but also facilitates the incorporation of our mechanism to existing databases since no re-structuring of the existing schemas is necessary. Second, our experience shows that our representation offers significant savings, in terms of space, over alternative representations. Consider, for example, a representation where a column is created for each element in the power-set of the set of attributes of a relation. Assuming single-colored blocks, for each block in an annotated tuple, its color becomes the value of the column that corresponds to the set of attributes in the block. Such a representation has a schema which is exponential, in the size of the schema of the annotated relation, and it requires one tuple for each annotated tuple in the relation. Our representation has a schema of linear size but it requires one tuple for each color of each block. Thus, exponential number of tuples might be necessary to represent an annotated tuple. However, in our representation, apart from the unannotated tuples, a tuple is created only if a block exists. In the alternative representation, we have a column for each set of attributes, irrespectively of whether a block for this set exists, or not. Furthermore, our encoding of blocks through Boolean attributes offers additional space savings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Expressiveness</head><p>The relational representation of color databases suggests another candidate query language, namely the normal relational algebra on this representation and specifically the fragment consisting of the union of conjunctive queries. In this section, we establish a link between our algebra and this fragment of the normal relational algebra.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Color relational algebra (CRA)</head><p>It is clear that not every relational algebra query on a representation of a color relation results in a representation of a color relation again. For example, any projection consisting only of data attributes, does not correspond to a color database. It would therefore be desirable to identify the class of algebra expressions which, when applied to any representation of a color relation, results in a representation of a color relation.</p><p>Recall the S is the set of relational databases which represent a color database through the rep mapping.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.</head><p>A positive relational algebra query Q is colored if for every relational database D ‚àà S, the query result Q(D) ‚àà S as well.</p><p>We identify the following three necessary and sufficient syntactic conditions for a positive relational algebra query to be colored. Without loss of generality we may assume that such query is given in normal form <ref type="bibr" target="#b3">[4]</ref>. More specifically it is the union of conjunctive queries of the form œÄ</p><formula xml:id="formula_17">X œÉ F (R 1 √ó ‚Ä¢ ‚Ä¢ ‚Ä¢ √ó R k ).</formula><p>Clearly, a positive query is colored if it is the union of colored conjunctive queries. It is easily verified that a conjunctive query is colored iff it satisfies the following three properties:</p><p>(i) The projection must contain a single color attribute;</p><p>(ii) Since each data attribute corresponds to a unique Boolean attribute (and vice versa), queries should "respect" this relationship. In other words, if a data attribute is part of a query result schema, then the associated Boolean attribute should also be (and vice versa); (iii) If some new data attributes are introduced which are in the schema of the query result, also associated new Boolean attributes should be introduced (and vice versa).</p><p>The above characterization is simple and provides an easy test (which runs in linear time in the size of the expression) to check whether a query, written as a union of conjunctive queries, is colored. Definition 3. The color relational algebra (CRA) consists of the class of colored positive relational algebra queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Color algebra vs Color relational algebra</head><p>The color algebra (CA) and the class of color relational algebra (CRA) queries are closely connected. First of all, there exists a translation of any CA query into a CRA query. More specifically, Theorem 2 (Soundness). For every color database D, œá and every CA expression Q, there exists a color relational algebra (CRA) expression P such that</p><formula xml:id="formula_18">rep(Q( D, œá )) = P (rep( D, œá )).</formula><p>Moreover, given the CA expression Q, the CRA expression P is of polynomial size, to that of Q.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof:</head><p>The proof consists of translating each operator in CA into a CRA query. (see the appendix for the translation rules) . The previous theorem gives us a way of implementing the CA on top of existing relational DBMS. Our color DBMS, represents color databases as described in Section 4 and when a CA query is issued, it translates it first into the corresponding CRA query and then to the equivalent SQL query. Then, the SQL query is executed in a standard relational DBMS.</p><p>Our theoretical result is that the CA has the same functionality (expressive power) as the CRA. More specifically:</p><p>Theorem 3 (Completeness). For every relational database D in S, and every color relational algebra expression P , there exists a color algebra expression Q such that</p><formula xml:id="formula_19">rep -1 (P (D)) = Q(rep -1 (D)).</formula><p>Proof: The proof consists of a translation of any CRA query into a CA query and relies heavily on the fact that CRA queries only have a single color attribute in their projection. See the appendix for details.</p><p>Since the CA and CRA have the same expressive power why opt for one versus the other? For one thing, CRA queries are complex to write. The simple CA expression œÉ Ai=Aj (r) is equivalent to the following CRA expression (which consists of a union of four CRA queries):</p><formula xml:id="formula_20">œÉ Ai=Aj ‚àßBi=0‚àßBj =0 (rep(r)) ‚à™ œÉ Ai=Aj ‚àßBi=1‚àßBj =1 (rep(r))‚à™ œÄ sort(rep(r)) (œÉ Ai=Aj ‚àßBi=1‚àßBj =0 (rep(r)) ‚ãä ‚ãâ Œ¥ f (œÉ Ai=Aj‚àßBi=0‚àßBj =1 (rep(r))‚à™ œÄ Œ¥ f (sort(()r)) (œÉ Ai=Aj ‚àßBi=1‚àßBj =0 (rep(r)) ‚ãä ‚ãâ Œ¥ f (œÉ Ai=Aj ‚àßBi=0‚àßBj =1 (rep(r))</formula><p>Clearly, a user cannot be expected to write such CRA expressions. The CA is not only simple syntactically but also independent of the underlying representation of annotations. Any change on the representation of annotations leaves CA queries unaffected. On the other hand, such a change would probably necessitate a re-writting of the equivalent CRA query.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">The MONDRIAN System</head><p>In spite of its syntactic simplicity, we don't expect users to write CA queries directly. Instead, our vision of the MONDRIAN annotation system is to provide a combination of a graphical and text-based query specification interface. Operators like block projections (Œ† L and Œ† U ) and block selection Œ£ are easily expressible through a graphical interface. For example, the user can point to a block of a particular color and request to retrieve all the tuples with equi-colored blocks. This intuitive operation directly translates to our Œ£ operator. On the other hand, operators like selection and projection might be easier to specify textually since users are probably already familiar with these operators by interacting with relational databases.</p><p>The current status of the MONDRIAN system includes the following components. MONDRIAN is implemented on top of the MySQL relational DBMS. The MySQL server runs on a linux-based Pentium 4 PC (CPU 1.8GHz, 2GB RAM). On top of MySQL, we have implemented a module that accepts textbased CA queries. The module translates each such query first to its equivalent CRA query and then to an equivalent SQL query. The resulting SQL query is then sent to the MySQL server and is executed against the representation of an annotated database.</p><p>In our experiments, we used real biological data from the Swissprot <ref type="bibr" target="#b2">[3]</ref> database. The relational representation of the Swissprot data was based on the schema of the USCS Genome Browser database <ref type="bibr" target="#b17">[19]</ref>. From this relational representation, we extracted two relations for our experiments, namely, relation Protein containing 200,000 protein tuples (560MB in size), and relation Public that contained four million tuples that concern publications related to proteins (750MB in size). Relation Protein has eight attributes in its schema, while relation Public has five. We used the above two relations as pools from which we generated three different experimental data sets. Each set contained five unannotated relations for each of the two pools. The sizes of these five relations varied from 10,000 to 50,000 tuples (in 10,000 tuple increments). Thus, the total number of created relations was 30. Each experimental data set allowed for executing experiments with different relation sizes. By using different data sets, we avoided any possible bias in the measurements due to characteristics of the underlying data.</p><p>A second module of the implementation was responsible for annotating unannotated relations. The annotation process is influenced by three parameters whose values are user specified. The first parameter, called MaxNo, limits the number of blocks that can appear in each annotated tuple. Given a number for MaxNo, the system randomly decides, for each tuple, to generate a number of blocks that is less than, or equal to, MaxNo. The second parameter, called AvgNo, specifies the average size of each generated block. Again, given a number for AvgNo, the system generates blocks that, in majority, are of size AvgNo. The last parameter is the cardinality of C (the number of available colors). In general, C can vary between one (all blocks have the same color) and the number of blocks in the relation (each block has its own color).</p><p>Given the above setting, we conducted two sets of experiments with the following goals in mind: To prove feasibility, i.e., that our annotation mechanism can be implemented efficiently in practise, and to study performance, i.e., its precise overhead both in terms of time and space.</p><p>(1): In the first set, we compared the cost of executing CA queries over annotated databases versus the cost of executing equivalent CRA queries over the corresponding unannotated databases.</p><p>(2): In the second set, we investigated how the annotation parameters influence the evaluation cost of CA queries. All reported times are averaged over five runs of each experiment, over each of the different sets of (un)annotated relation instances (to rule out CPU interference and any bias from using a single instance). For annotated relations, the reported size is the number of annotated tuples and not the number of representation tuples. The cumulative size of the (un)annotated data sets used in these experiments is 26GB.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Costs of using colors and blocks</head><p>In this experiment, we investigate the additional cost, in terms of time and space, in querying an annotated database instead of an unannotated one. The experiment has two parts. Initially, we considered three types of queries, all written in relational algebra, where each type uses one of the operators of selection, projection and join. For example, one query projects on the id and description of a protein, while another selected only proteins of tomatoes. In the second part, we annotated the relations used in the first part. While generating the annotated relations, we used what we consider to be representative parameter values. We assumed that both MaxNo and AvgNo are equal to three, since tuples are expected to involve a small number of blocks with a few attributes in each one. Furthermore, we assumed that C is 100. Our choice on the number of colors is motivated by the assumption that each color represents a curator. In a scientific database, this number is less than 100. For example, the number of curators in Swissprot, one of the most heavily curated databases, is close to 40.</p><p>Given the annotated relations, we considered queries that, syntactically, are identical to the queries in the first part of the experiment. However, instead of the normal relational algebra operators, the queries used their color counterparts, i.e., they contained a CA projection instead of a projection, a CA selection instead of a selection and a color join instead of a normal join (note that a color join can be expressed through the select, merge and project CA operators). So, for example, the query that projects on the id and description of proteins was translated to a query that projects on the data and blocks of these two attributes. Given the queries, we measured their evaluation time over the annotated databases, and we compared these times with the times collected from the first part.</p><p>Figure <ref type="figure" target="#fig_5">7</ref> shows the results of this comparison for various relation sizes. Next to the cost of each relational operator, we show the cost of its color counter-part. In general, each color operator costs from three to five times as much as its relational counterpart. There are two main reasons for this. First, remember that color operators are actually applied on the representation of the annotated relation. This representation is bigger in size than the corresponding unannotated relation since it includes one tuple for each color of each block. With MaxNo equal to three, annotating a relation with 10,000 tuples results in a relation that is close to 30,000 tuples (assuming single colored blocks). Thus, while a normal projection is applied on 10,000 tuples, a color projection is actually applied on 30,000. Second, remember that color operators perform extra processing since they also consider Boolean attributes and operate on them.</p><p>Note that the overhead of supporting annotations is not prohibitive and it is more than balanced by the added value of being able to represent and query complex annotations. We expect that further optimizations of our implementation (e.g. use of specialized indexes) would further reduce the above costs making our solutions even more attractive.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Query evaluation cost parameters</head><p>As the number of blocks and colors varies in an annotated database, we expect that query evaluation costs will also vary. In what follows, we investigate the relationship between this cost and the three anno- During these experiments, we considered three different types of color queries. The first type included color queries that involved only the selection operator where the selection was on a data value. Note that the size of the result set of such queries is expected to be independent of blocks. The second type of color queries involved operators that are mostly block-dependent, namely, the operators of block projection and block selection. Finally, the third type of queries involved both block-independent and block-dependent operators. We used three different parameter configurations to annotate relations. For each resulting annotated relation, in each configuration, we executed queries of all three types and measured the corresponding evaluation times. In what follows, we present each parameter configuration and we review our key findings. Configuration 1: In this configuration, we annotated the relations in our experimental data sets once for each value of MaxNo between one and five. The AvgNo parameter was set to three and the C was 100. In Figure <ref type="figure" target="#fig_6">8</ref>, we show the running times for the first and second type of queries, for different relation sizes (the third type exhibits the same running time trends as the second type). The main conclusion from these experiments is that the evaluation cost of most CA operators, with the exception of selections on data values, is heavily influenced by the maximum number of blocks per tuple. This is because this number increases the number of tuples in the underlying representation. The trend shown in Figure <ref type="figure" target="#fig_6">8</ref> as follows. In the representation, there is one tuple for each color of each block. Assuming single-colored blocks, for an annotated relation with X tuples, there are (MaxNo + 1) √ó X representation tuples. As the figure shows, evaluation time increases sharply, when both MaxNo and X increase. In spite of the increase representation size, operations on the data side, like selections on data values, are not influenced by the variance of MaxNo, as Figure <ref type="figure" target="#fig_6">8</ref>(a) illustrates. Configuration 2: For our second configuration, we annotated relations of various sizes by varying, this time, the AvgNo parameter between the values of one and five. Parameter MaxNo was set to three and C to 100. Again, we executed color queries from all the types and recorded their evaluation times. Our experiments showed that varying the AvgNo parameter had negligible effects on the running times of various queries, for a fixed number of annotated tuples. To a large extent, this is to be expected since any variance of AvgNo does not influence the number of tuples in the underlying representation. As AvgNo increases, the only change, representation-wise, is that more Boolean attributes are set to 1, instead of 0. It is interesting to note the interaction between the value of AvgNo and the size of the result of block projections. As an example, in Figure <ref type="figure" target="#fig_7">9</ref> we show that, for a relation of fixed size, as we increase AvgNo we decrease the number of tuples in the result size of a U-type block projection on three attributes. This is because as we increase AvgNo, increasingly less blocks are contained within the projected attribute set. Configuration 3: Our last configuration considered annotated relations where both MaxNo and AvgNo were set to three. Here, five different values where considered for C, namely, 1, 10, 100, 1000 and as many colors as there are blocks. Our experiments showed that the parameter has negligible effects on the evaluation times of algebra operators (since again availability of colors does not affect the representation size) with the exception of the block selection operator. As Figure <ref type="figure" target="#fig_8">10</ref>(a) shows, when C is 10, there is a sharp increase on the evaluation time of the operator. The reason for this is shown in Figure <ref type="figure" target="#fig_8">10(b)</ref>. With less available colors, there is a large number of blocks sharing a color.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusions and future work</head><p>In this paper, we proposed a new model for data annotations which, unlike previous works, it allows annotating not only values but also value associations. Furthermore, our work is novel in that it also considers the importance of querying annotations. To this end, we introduced a color algebra, and we proved that it is both complete and minimal. We presented the MONDRIAN annotation management system and we performed experiments on the feasibility and performance of our solutions.</p><p>We believe that colored databases provide the right framework to answer data provenance questions. Future work will be directed towards showing this. In terms of implementation, we need to complete the construction of the graphical query interface and we are considering migrating our implementation from the MySQL server to MonetDB <ref type="bibr" target="#b6">[8]</ref>. MonetDB offers a vertical fragmentation storage model and initial investigation shows that this model is particularly suitable for the processing performed by CA algebra operators. Finally, an interesting topic is the extension of our algebra to account for negation. and Rel 2 is obtained similarly by replacing Œ¥ gi (S i ) √ó Œ¥ gj (S j ) in Rel by Œ¥ gi (Œ† U sort(Si)\A k (S i )) √ó Œ¥ gj (Œ† U sort(Sj )\A ‚Ñì (S j )).</p><p>We can push the union outside the projection and deal with the two parts separately. So can ignore the union for the moment and omit the subscript of Rel from now on.</p><p>‚Ä¢ œÉ Œ¥ f i (Si.color)=Œ¥ f j (Sj.color) : Note that when Rel is applied to any colored database instance, the blocks in the result do not cross between attributes of S i or S j , To get the blocks of the same color in S i and S j we first apply K = merge sort(Si),sort(Sj) (S i √ó S j ) which merges all blocks in S i with blocks in S j of the same color and removes all other blocks. We then replace S i (resp. S j ) in Rel by œÄ sort(Si) (K) (resp, œÄ sort(Sj ) (K)). Again, we can push the union outside the expression and can ignore it for the remainder of the proof.</p><p>‚Ä¢ œÉ Œ¥ f i (Si.A k )=Œ¥ f j (Sj.A ‚Ñì ) : To get the corresponding CRA expression we proceed as follows. We first compute K = (œÉ S ‚Ä≤ i .A k =(S ‚Ä≤ j .A ‚Ñì ) (S ‚Ä≤ i √ó S ‚Ä≤ j ) √ó recolor Sj (recolor Si (A, a, c))) ‚à™ (S ‚Ä≤ i √ó S ‚Ä≤ j √ó (A, a)).</p><p>Hence, in K the tuples satisfying the selection criterium will have an annotated A attribute and will have the original block structure because of the union with the original relations. Next, we consider L = merge sort(Si)‚à™sort(Sj),A (K), which merges all blocks in S i √ó S j in the (only those) tuples satisfying the selection criterium with the block in the A attribute. We then extract the desired tuples based on this property with Œ† L A (L) and we are done.</p><p>Since the projection contains a single color attribute, we know exactly where the colors in the result come from. Suppose that the color attribute of R 1 is taken. As above, we can use the recolor operator to recolor all blocks in the other relations (and also in Const) with the colors in R 1 . As a result every block has at least one common color with blocks in R 1 .</p><p>We then apply the sequence of merges</p><formula xml:id="formula_21">merge A1‚Ä¢‚Ä¢‚Ä¢Ap;sort(Œ¥ f 1 (R1)) ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚Ä¢ merge A1‚Ä¢‚Ä¢‚Ä¢sort(Œ¥ f m-1 (Rm-1);Œ¥ fm (Rm)</formula><p>on the expression we got so far. This creates the right block structure with the right colors. Finally, we apply the projection corresponding to the projection in the SPJRU-expression and we're done.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Relations from three biological sources</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. An integrated relation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. The projection operators</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Example 5 .</head><label>5</label><figDesc>Consider relation r, œá from Figure 3(b) and relation r ‚Ä≤ , œá ‚Ä≤ from Figure 4(c) (which are copied in Figures</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>c is a new color. The other tuples in rep( r, œá ) are obtained similarly.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. Color vs. normal algebra</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. Varying the MaxNo parameter</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. Result size of the Œ† U operator</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 10 .</head><label>10</label><figDesc>Figure 10. Block selection as C varies</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Piet Mondrian: Dutch painter whose paintings mainly consist of color blocks.</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix Proof of Theorem 1</head><p>In this section we show that the set of operators in the CA is minimal, i.e., we cannot express any of the operators using only the other ones.</p><p>Projection œÄ : There is no other operator which reduces the number of attributes, so it clearly cannot be expressed in terms of the other operators.</p><p>Selection œÉ A=a , œÉ A=B : Observe that any other operator op does not see the data values. More specifically, for any D and D ‚Ä≤ which have the same block structure (i.e., for any tuple t ‚àà D there exists a tuple t inD ‚Ä≤ such that Œ≤(t, Y ) = ‚àÖ iff Œ≤ ‚Ä≤ (t ‚Ä≤ , Y ) = ‚àÖ for all Y ‚äÜ sort(D)), we have that op(D) and op(D ‚Ä≤ ) have the same block structure. Hence, if œÉ was expressible in terms of the other operators, œÉ should satisfy this property as well. This is clearly not the case. Indeed, let D be the database consisting of a tuple t satisfying the selection condition, and D ‚Ä≤ be the database consisting of a tuple t ‚Ä≤ not satisfying the selection condition but with the same block structure as t. Then œÉ(D) = ‚àÖ while œÉ(D ‚Ä≤ ) = ‚àÖ.</p><p>Cartesian product √ó : There is no other operator which increases the number of attributes, so it clearly cannot be expressed in terms of the other operators.</p><p>Color selection Œ£ c : Observe that any other operator op is color blind. More specifically, if D and D ‚Ä≤ are two databases which the same data values and block structure, and for which there exists a bijection between the set of colors C in D and the set of colors C ‚Ä≤ of D, then op(D) and op(D) satisfy the same property. Suppose that Œ£ c is expressible in terms of the other operators then Œ£ c must have this property as well, which is obviously not the case.</p><p>Color projection Œ† U : Observe that any other operator op satisfies the property that if D is contained in D ‚Ä≤ (both on the data values and block level), then op(D) is also contained in op(D ‚Ä≤ ). Clearly Œ† U ‚àÖ does not satisfy this property: Let D = {t} where t is not annotated and D = {t ‚Ä≤ } where t ‚Ä≤ is equal to t on the data values but t ‚Ä≤ has an annotation. Then Œ† U ‚àÖ (D) = {t} and Œ† U ‚àÖ (D ‚Ä≤ ) = ‚àÖ.</p><p>Color projection Œ† L : Observe that any other operator op satisfies the following property: for any tuple t and block Œ≤(t, Y ), either op(t) removed this block, it was projected out, or copied and or modified. Now, if a block Œ≤(t, Y ) is removed by op, then also all super-blocks Œ≤(t, Z) for Y ‚äÜ Z of the same color as Œ≤(t, Y ) are removed. Clearly, this is not a property which Œ† L has since. it can remove small blocks while keeping larger blocks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Merge ¬µ X;</head><p>Y : There is no other operator which possible increases the size of blocks, so it cannot be expressed in terms of the other operators.</p><p>Recoloring œÅ : There is no other operator which can change the color of existing blocks (however, you can insert a new block with a specific color), so it cannot be expressed in terms of the other operators.</p><p>Renaming Œ¥ : There is no other operator which reorder the attributes, so it cannot be expressed by the other operators.</p><p>Union : This is shown as for the standard relational algebra.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Theorem 2</head><p>We have to prove that for any colored database D, œá and any CRA expression Q, there exists a colored relational algebra expression P such that</p><p>Moreover, given Q, P can be obtained in time polynomial in the size of Q.</p><p>We will treat each operator in CRA seperately: If R is a relation name of a colored relation, then we abuse notation and denote by R also the corresponding relation name of its relational representation.</p><p>, then P consists of the union of four queries, one which selects all blocks not containing A i and A j , one which selects all blocks containing A i and A j , one which selects all blocks containing A i but not A j and for which there exists an equi-colored block (in the same tuple) containing A j but not A i , and one which is similar to the previous one but with the roles of A i and A j interchanged. More formally,</p><p>where f is a renaming function renaming only the boolean attributes.</p><p>Product If Q ‚â° R √ó S, then P is the union of two queries. One which joins the two relations (on the data part) and extends all blocks in an instance r with zeros in the attributes of an instance s, and a similar one where the roles of r and s are interchanged. More formally,</p><p>where A i (resp A ‚Ä≤ i ) are the data attributes of S (resp. R), and B i (resp. B ‚Ä≤ i ) are the boolean attributes of S (resp. R). Recall that the sorts of R and S are assumed to be disjoint.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Block projection If</head><p>, where A i are the data attributes of R.</p><p>where f is a renaming of the boolean attributes of sort(R).</p><p>Since all translations are unions of conjunctive queries and always result in a colored relational database, so are all compositions of these queries. As a result we can easily obtain a translation of an arbitrary CRA query into an equivalent colored relational algebra query on their respective representations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Theorem 3</head><p>We have to prove that for every colored relational algebra query P , there exists an expression Q in CRA such that for any colored relational database D, we have that</p><p>It is a well-known fact <ref type="bibr" target="#b3">[4]</ref> any expression positive query P can be written as the (finite) union of expressions of the form</p><p>where all {Y 1 , . . . , Y ‚Ñì } ‚äÜ {X 1 , . . . , X k }, Y i = Y j for all i &lt; j and i, j ‚àà <ref type="bibr">[1, ‚Ñì]</ref>. The Y i s do not appear as an attribute in any rewriting</p><p>So, P is the union of queries P i of the form (1). We construct the desired CRA expression Q i for each P i separately, and obtain the final CRA expression by taking the CRA union of all Q) i . Hence, we may assume that P is of the form <ref type="bibr" target="#b0">(1)</ref>. We obtain the corresponding CRA expression Q as follows:</p><p>First, we push as many as possible selections in P through the joins.</p><p>‚Ä¢ œÉ Œ¥ f i (Ri.color)=c : This can be pushed onto the relation R i . It is clear that we obtain the equivalent result with the CRA expression Œ¥ gi (Œ£ c (R i ). Here, g i is defined as the restriction of f i to the data attributes.</p><p>‚Ä¢ œÉ Œ¥ f i (Ri.Aj )=a (R i ): This can be pushed onto the relation R i , We obtain the equivalent result in CRA with the expression Œ¥ gi (œÉ Ri .Aj=a (R i ).</p><p>‚Ä¢ œÉ Œ¥ f i (Ri.Bj )=1 : This can be pushed onto the relation</p><p>, where A j is such that ass(A i , B j ) holds, is the equivalent CRA expression. Similarly, selections on blocks of the form œÉ Œ¥ f i (Ri.Bj )=0 can be simulated by applying the CRA expression Œ¥ gi (Œ† U sort(Ri)\Ri.Aj (R i ), where A j is such that ass(A i , B j ) holds.</p><p>Note that we may assume that these selections do not relate to the constant expression (Y 1 , a 1 ) ‚ä≤‚ä≥ ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚ä≤‚ä≥ (Y ‚Ñì , a ‚Ñì ) since such selections would always yield true or false.</p><p>Let S i , for i ‚àà [1, m], denote the CRA expression consisting of R i on which the relevant CRA expression corresponding to the selections (as described above) are applied.</p><p>Next, we consider the CRA-expression</p><p>The constant part (Y 1 , a 1 ) ‚ä≤‚ä≥ ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚ä≤‚ä≥ (Y ‚Ñì , a ‚Ñì ) in P is treated as follows. Here, we distinguish between the following cases: If the color attribute in the projection corresponds to the colored attribute in the constant part, then (Y 1 , a 1 ) ‚ä≤‚ä≥</p><p>p , b p ) ‚ä≤‚ä≥ (Œ≥ ‚Ä≤ : c) where p = (‚Ñì -1)/2) (This is because all Y i 's are in the projection). Hence, we need to build a tuple (a 1 , . . . , a p ) with a block (containing the attributes A i for which b i = 1) of color c. Let Q 1 = merge A1;A2 ((A 1 , a 1 , c) √ó (A 2 , a 2 , c)), and Q i = merge att(Qi-1);Ai (Q i-1 √ó (A i , a i , c)). Then, Const = Q p is the desired CRA expression for the constant part.</p><p>In case that the color attribute in the projection does not correspond to the colored attribute, we join (Y 1 , a 1 ) ‚ä≤‚ä≥ ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚ä≤‚ä≥ (Y ‚Ñì , a ‚Ñì ) with (Œ≥, c) and end up with an equivalent expression. We then do the same as in the previous case.</p><p>Consider now Const √ó Rel. We translate the selections in F containing pairwise comparisons into the CRA.</p><p>‚Ä¢ œÉ Œ¥ f i (Si.B k )=Œ¥ f j (Sj .B ‚Ñì ) . To get the equivalent CRA expression, we replace Const√ó Rel by (Const√ó Rel 1 ) ‚à™ (Const √ó Rel 2 ), where Rel 1 is obtained by replacing Œ¥ gi (S i ) √ó Œ¥ gj (S j ) in Rel by Œ¥ gi (Œ† L A k (S i )) √ó Œ¥ gj (Œ† L A ‚Ñì (S j ))</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The Protein Information Resource</title>
		<author>
			<persName><forename type="first">Cathy</forename><forename type="middle">H</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lai-Su</surname></persName>
		</author>
		<author>
			<persName><surname>Yeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Research</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="345" to="347" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Human Genome Database [database online</title>
		<author>
			<persName><surname>Gdb(tm)</surname></persName>
		</author>
		<ptr target="http://www.gdb.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<ptr target="http://www.ebi.ac.uk/swissprot/" />
		<title level="m">The SWISS-PROT Protein Knowledgebase</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Foundations of Databases</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vianu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Meta-data support for data transformations using microsoft repository</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Bergstraesser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Data Eng. Bull</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="9" to="14" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">An Annotation Management System for Relational Databases</title>
		<author>
			<persName><forename type="first">D</forename><surname>Bhagwat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Chiticariu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-C</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Vijayvargiya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Int&apos;l Conf. on Very Large Data Bases (VLDB)</title>
		<meeting>of the Int&apos;l Conf. on Very Large Data Bases (VLDB)</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="900" to="911" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Monet: A Next-Generation DBMS Kernel For Query-Intensive Applications</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Boncz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002-05">May 2002</date>
			<pubPlace>Amsterdam, The Netherlands</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Universiteit van Amsterdam</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.d. thesis</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The two cultures of digital curation</title>
		<author>
			<persName><forename type="first">P</forename><surname>Buneman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SSDBM</title>
		<imprint>
			<biblScope unit="page" from="7" to="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Why and where: A characterization of data provenance</title>
		<author>
			<persName><forename type="first">P</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Khanna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">C</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Int&apos;l Conf. on Database Theory (ICDT)</title>
		<meeting>of the Int&apos;l Conf. on Database Theory (ICDT)</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="316" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">On propagation of deletions and annotations through views</title>
		<author>
			<persName><forename type="first">P</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Khanna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">C</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Symp. on Principles of Database Systems (PODS)</title>
		<meeting>of the Symp. on Principles of Database Systems (PODS)</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="150" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Dbnotes: a post-it system for relational databases based on provenance</title>
		<author>
			<persName><forename type="first">L</forename><surname>Chiticariu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">C</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Vijayvargiya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Int&apos;l Conf. on the Management of Data (ACM SIGMOD)</title>
		<meeting>of the Int&apos;l Conf. on the Management of Data (ACM SIGMOD)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="942" to="944" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The gene ontology (go) database and informatics resource</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">G O</forename><surname>Consortium</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucl. Acids Res</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="258" to="261" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Tracing the lineage of view data in a warehousing environment</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Wiener</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="179" to="227" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Challenges in Integrating Biological Data Sources</title>
		<author>
			<persName><forename type="first">S</forename><surname>Davidson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">C</forename><surname>Overton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Buneman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computational Biology</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="557" to="572" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">MONDRIAN: Annotating and querying databases through colors and blocks</title>
		<author>
			<persName><forename type="first">F</forename><surname>Geerts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kementsietsidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Milano</surname></persName>
		</author>
		<ptr target="http://www.lfcs.inf.ed.ac.uk/research/database/annotation.html" />
		<imprint/>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Colorful xml: One hierarchy isn&apos;t enough</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">V</forename><surname>Jagadish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">V S</forename><surname>Lakshmanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Scannapieco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Wiwatwattana</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Int&apos;l Conf. on the Management of Data (ACM SIGMOD)</title>
		<meeting>of the Int&apos;l Conf. on the Management of Data (ACM SIGMOD)</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="251" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Annotea: an open rdf infrastructure for shared web annotations</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kahan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>-R. Koivunen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Swick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Networks</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="589" to="608" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The UCSC Genome Browser Database</title>
		<author>
			<persName><forename type="first">D</forename><surname>Karolchik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Baertsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Diekhans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Furey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hinrichs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Roskin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schwartz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sugnet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Haussler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Kent</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucl. Acids Res</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="51" to="54" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Data Mapping in Peer-to-Peer Systems: Semantics and Algorithmic Issues</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kementsietsidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Int&apos;l Conf. on the Management of Data (ACM SIGMOD)</title>
		<meeting>of the Int&apos;l Conf. on the Management of Data (ACM SIGMOD)</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="325" to="336" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Containment of relational queries with annotation propagation</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">C</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">9th Int&apos;l Workshop on Database Programming Languages (DBPL)</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="37" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Research Problems in Data Provenance</title>
		<author>
			<persName><forename type="first">W.-C</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Data Engineering Bulletin</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="45" to="52" />
			<date type="published" when="2004-12">Dec 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A Polygon Model for Heterogeneous Database Systems: the Source Tagging Perspective</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">R</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">E</forename><surname>Madnick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Int&apos;l Conf. on Very Large Data Bases (VLDB)</title>
		<meeting>of the Int&apos;l Conf. on Very Large Data Bases (VLDB)<address><addrLine>Brisbane, Australia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990-08">Aug. 1990</date>
			<biblScope unit="volume">16</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Trio: A system for integrated management of data, accuracy, and lineage</title>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2nd Biennial Conf. on Innovative Data Systems Research (CIDR)</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="262" to="276" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
