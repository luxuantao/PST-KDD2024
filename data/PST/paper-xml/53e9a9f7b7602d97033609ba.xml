<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Some Plausible Constructions of Double-Block-Length Hash Functions</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Shoichi</forename><surname>Hirose</surname></persName>
							<email>hirose@fuee.fukui-u.ac.jp</email>
							<affiliation key="aff0">
								<orgName type="department">Faculty of Engineering</orgName>
								<orgName type="institution">The University of Fukui</orgName>
								<address>
									<postCode>910-8507</postCode>
									<settlement>Fukui</settlement>
									<country key="JP">Japan</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Some Plausible Constructions of Double-Block-Length Hash Functions</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">02912FE954B05B2E635469BBAECFB9E6</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T09:06+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this article, it is discussed how to construct a compression function with 2n-bit output using a component function with n-bit output. The component function is either a smaller compression function or a block cipher. Some constructions are presented which compose collision-resistant hash functions: Any collision-finding attack on them is at most as efficient as the birthday attack in the random oracle model or in the ideal cipher model. A new security notion is also introduced, which we call indistinguishability in the iteration, with a construction satisfying the notion.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>A cryptographic hash function is a function which maps an input of arbitrary length to an output of fixed length. It satisfies preimage resistance, secondpreimage resistance and collision resistance. It is one of the most important primitives in cryptography <ref type="bibr" target="#b18">[19]</ref>. For simplicity, a cryptographic hash function is called a hash function in this article.</p><p>A hash function usually consists of iteration of a compression function with fixed input/output length. This type of hash function is called an iterated hash function. There has been an interest in constructing a compression function from component functions with smaller output length. Many schemes have been presented following the approach <ref type="bibr">[4, 10, 11, 13-15, 17, 20]</ref>. It is typical for constructions using block ciphers. For example, suppose that AES is used for construction. The block length of AES is 128 bits, and a hash function with 128-bit output is no longer secure against the birthday attack. Thus, it is desired to construct a compression function with larger output length.</p><p>In this article, we study how to construct a compression function with 2nbit output using a component function with n-bit output. A hash function with such a compression function is called a double-block-length (DBL) hash function (as opposed to a single-block-length (SBL) hash function, where the compression function has n-bit output). The component function may be either a block cipher or a smaller compression function.</p><p>We first discuss constructions using a smaller compression function. We focus on the constructions formalized by Nandi <ref type="bibr" target="#b21">[22]</ref>. In his formalization, the compression function is of the form F (x) = (f (x), f(p(x))), where f is a component compression function and p is a permutation such that both p and p -1 are easy to compute. We show that any collision-finding attack on a hash function with the compression function F is at most as efficient as the birthday attack if f is a random oracle and p satisfies some properties. Our properties for p are easy to be satisfied; for example, they are satisfied by the permutation p(x) = x ⊕ c, where ⊕ is bit-wise addition and c is a non-zero constant.</p><p>Similar results are in fact already obtained by Nandi <ref type="bibr" target="#b20">[21]</ref>, whose analysis actually applies to a broader range of hash functions than our analysis. However, our results are sharper. We give a significantly better upper bound on the probability of finding a collision as a function of the number of queries made by the adversary.</p><p>A new security notion for a compression function is also introduced, which we call indistinguishability in the iteration. It is really weaker than the notion proposed in <ref type="bibr" target="#b4">[5]</ref>. However, it may be valuable in practice. Loosely speaking, a compression function</p><formula xml:id="formula_0">F (x) = (f (x), f(p(x)))</formula><p>where f is a random oracle is called indistinguishable in the iteration if F cannot be distinguished from a random oracle in the iterated hash function. We give sufficient conditions on p for F to be indistinguishable in the iteration. Second, we discuss constructions using a block cipher. A compression function composed of a block cipher is presented and its collision resistance is analyzed. We show that any collision-finding attack on a hash function composed of the compression function is at most as efficient as the birthday attack if the block cipher used is ideal. A block cipher is ideal if it is assumed to be a keyed invertible random permutation. The compression function presented in this article is quite simple but has not been explicitly discussed previously.</p><p>In <ref type="bibr" target="#b9">[10]</ref>, it is shown that a collision-resistant hash function can be easily composed of a compression function using two distinct block ciphers. It is wellknown that two distinct block ciphers can be obtained from a block cipher by fixing, for example, one key bit by 0 and 1. However, it is preferable in practice that fixing key bits is avoided. Moreover, fixing one bit may not be sufficient and more bits may be required to be fixed. Our new construction does not involve any fixing of key bits by constants.</p><p>The technique in <ref type="bibr" target="#b2">[3]</ref> is used in the security proofs in this article. However, the analysis is more complicated than the one in <ref type="bibr" target="#b2">[3]</ref> since the relation of two component-compression-function/block-cipher calls in a compression function need to be taken into account.</p><p>The rest of this article is organized as follows. Section 2 includes notations, definitions and a brief review of the related works. Section 3 discusses compression functions composed of a smaller compression function, including the results on collision resistance and our new notion of indistinguishability in the iteration. Section 4 exhibits a block-cipher-based compression function whose associated hash function has optimal collision resistance; the proof of collision resistance is given in the appendix. Section 5 gives a concluding remark which mentions a recent collision attack on the scheme in Sect. 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Iterated Hash Function</head><p>A hash function H : {0, 1} * → {0, 1} usually consists of a compression function F : {0, 1} × {0, 1} → {0, 1} and a fixed initial value h 0 ∈ {0, 1} . An input m is divided into the -bit blocks m 1 , m 2 , . . . , m l . Then,</p><formula xml:id="formula_1">h i = F (h i-1 , m i ) is computed successively for 1 ≤ i ≤ l and h l = H(m). H is called an iterated hash function.</formula><p>Before being divided into the blocks, unambiguous padding is applied to the input. The length of the padded input is a multiple of . In this article, Merkle-Damgård strengthening <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b19">20]</ref> is assumed for padding. Thus, the last block contains the length of the input.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Random Oracle Model and Ideal Cipher Model</head><formula xml:id="formula_2">Random Oracle Model. Let F n ,n = {f | f : {0, 1} n → {0, 1} n }.</formula><p>In the random oracle model, the function f is assumed to be randomly selected from F n ,n . The computation of f is simulated by the following oracle.</p><p>The oracle f first receives an input x i as a query. Then, it returns a randomly selected output y i if the query has never been asked before. It keeps a table of pairs of queries and replies, and it returns the same reply to the same query.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Ideal Cipher Model.</head><p>A block cipher with the block length n and the key length κ is called an (n, κ) block cipher. Let e : {0, 1} κ × {0, 1} n → {0, 1} n be an (n, κ) block cipher. Then, e(k, •) is a permutation for every k ∈ {0, 1} κ , and it is easy to compute both e(k, •) and e(k, •) -1 .</p><p>Let B n,κ be the set of all (n, κ) block ciphers. In the ideal cipher model, e is assumed to be randomly selected from B n,κ . The encryption e and the decryption e -1 are simulated by the following two oracles.</p><p>The encryption oracle e first receives a pair of a key and a plaintext as a query. Then, it returns a randomly selected ciphertext. On the other hand, the decryption oracle e -1 first receives a pair of a key and a ciphertext as a query. Then, it returns a randomly selected plaintext. The oracles e and e -1 share a table of triplets of keys, plaintexts and ciphertexts, (k i , x i , y i )'s, which are produced by the queries and the corresponding replies. Referring to the table, they select a reply to a new query under the restriction that e(k, •) is a permutation for every k. They also add the triplet produced by the query and the reply to the table.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">DBL Hash Function</head><p>An iterated hash function whose compression function is composed of a block cipher is called a single-block-length (SBL) hash function if its output length is equal to the block length of the block cipher. It is called a double-block-length (DBL) hash function if its output length is twice larger than the block length.</p><p>Let F be a compression function composed of a block cipher. For an iterated hash function composed of F , the rate r defined below is often used as a measure of efficiency:</p><formula xml:id="formula_3">r = |m i | (the number of block-cipher calls in F ) × n .</formula><p>In this article, we also call an iterated hash function a DBL hash function if its compression function F is composed of a smaller compression function f and its output length is twice larger than the output length of f .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Related Work</head><p>Knudsen and Preneel studied the schemes to construct secure compression functions with longer outputs from secure ones based on error-correcting codes <ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref>. It is an open question whether optimally collision-resistant compression functions are constructed by their schemes. A hash/compression function is optimally collision-resistant if any attack to find its collision is at most as efficient as the birthday attack.</p><p>Our work is largely motivated by the recent works by Lucks <ref type="bibr" target="#b17">[18]</ref> and Nandi <ref type="bibr" target="#b21">[22]</ref>. Nandi generalized the results by Lucks and by Hirose <ref type="bibr" target="#b9">[10]</ref>. He discussed how to construct DBL hash functions and presented optimally collision-resistant ones. However, their security analysis is not so sharp as ours, which is mentioned in Sect. 1.</p><p>Coron, Dodis, Malinaud and Puniya <ref type="bibr" target="#b4">[5]</ref> discussed how to construct a random oracle with arbitrary input length given a random oracle with fixed input length.</p><p>As is reviewed in the following, there are many papers on hash functions composed of block ciphers.</p><p>Preneel, Govaerts and Vandewalle <ref type="bibr" target="#b24">[25]</ref> discussed the security of SBL hash functions against several generic attacks. They considered SBL hash functions with compression functions represented by h i = e(k, x) ⊕ z, where e is an (n, n) block cipher, k, x, z ∈ {h i-1 , m i , h i-1 ⊕m i , c} and c is a constant. They concluded that 12 out of 64(= 4 3 ) hash functions are secure against the attacks. However, they did not provide any formal proofs.</p><p>Black, Rogaway and Shrimpton <ref type="bibr" target="#b2">[3]</ref> presented a detailed investigation of provable security of SBL hash functions given in <ref type="bibr" target="#b24">[25]</ref> in the ideal cipher model. The most important result in their paper is that 20 hash functions including the 12 mentioned above is optimally collision-resistant.</p><p>Knudsen, Lai and Preneel <ref type="bibr" target="#b15">[16]</ref> discussed the insecurity of DBL hash functions with the rate 1 composed of (n, n) block ciphers. Hohl, Lai, Meier and Waldvogel <ref type="bibr" target="#b10">[11]</ref> discussed the security of compression functions of DBL hash functions with the rate 1/2. On the other hand, the security of DBL hash functions with the rate 1 composed of (n, 2n) block ciphers was discussed by Satoh, Haga and Kurosawa <ref type="bibr" target="#b25">[26]</ref> and by Hattori, Hirose and Yoshida <ref type="bibr" target="#b7">[8]</ref>. These works presented no construction for DBL hash functions with optimal collision resistance.</p><p>Many schemes with the rates less than 1 were also presented. Merkle <ref type="bibr" target="#b19">[20]</ref> presented three DBL hash functions composed of DES with the rates at most 0.276. They are optimally collision-resistant in the ideal cipher model. MDC-2 and MDC-4 <ref type="bibr" target="#b3">[4]</ref> are also DBL hash functions composed of DES with the rates 1/2 and 1/4, respectively. Lai and Massey proposed the tandem/abreast Davies-Meyer <ref type="bibr" target="#b16">[17]</ref>. They consist of an (n, 2n) block cipher and their rates are 1/2. It is an open question whether the four schemes are optimally collision-resistant or not.</p><p>Hirose <ref type="bibr" target="#b9">[10]</ref> presented a large class of DBL hash functions with the rate 1/2, which are composed of (n, 2n) block ciphers. They were shown to be optimally collision-resistant in the ideal cipher model. However, his construction requires two independent block ciphers, which makes the results less attractive.</p><p>Nandi, Lee, Sakurai and Lee <ref type="bibr" target="#b22">[23]</ref> also proposed an interesting construction with the rate 2/3. However, they are not optimally collision-resistant. Knudsen and Muller <ref type="bibr" target="#b11">[12]</ref> presented some attacks against it and illustrated its weaknesses, none of which contradicts the security proof in <ref type="bibr" target="#b22">[23]</ref>.</p><p>Black, Cochran and Shrimpton <ref type="bibr" target="#b1">[2]</ref> showed that it is impossible to construct a highly efficient block-cipher-based hash function provably secure in the ideal cipher model. A block-cipher-based hash function is highly efficient if it makes exactly one block-cipher call for each message block and all block-cipher calls use a single key.</p><p>Gauravaram, Millan and May proposed a new approach based on iterated halving to design a hash function with a block cipher <ref type="bibr" target="#b6">[7]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">DBL Hash Function in the Random Oracle Model</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Compression Function</head><p>In this section, we consider the DBL hash functions with compression functions given in the following definition.</p><formula xml:id="formula_4">Definition 1. Let F : {0, 1} 2n × {0, 1} b → {0, 1} 2n be a compression function such that (g i , h i ) = F (g i-1 , h i-1 , m i ), where g i , h i ∈ {0, 1} n and m i ∈ {0, 1} b . F consists of f : {0, 1} 2n × {0, 1} b → {0, 1} n</formula><p>and a permutation p : {0, 1} 2n+b → {0, 1} 2n+b as follows:</p><formula xml:id="formula_5">g i = F U (g i-1 , h i-1 , m i ) = f (g i-1 , h i-1 , m i ) h i = F L (g i-1 , h i-1 , m i ) = f (p(g i-1 , h i-1 , m i )) .</formula><p>p satisfies the following properties:</p><p>-It is easy to compute both p and p -1 , -p(p(•)) is an identity permutation, -p has no fixed points, that is, p</p><formula xml:id="formula_6">(g i-1 , h i-1 , m i ) = (g i-1 , h i-1 , m i ) for any (g i-1 , h i-1 , m i ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Collision Resistance</head><p>We will analyze the collision resistance of DBL hash functions composed of F under the assumption that f is a random oracle. Two queries to the oracle f are required to compute the output of F for an input. For this compression function, a query to f for F U or F L uniquely determines the query to f for the other since p is a permutation. Moreover, for every w ∈ {0, 1} 2n+b , f (w) and f (p(w)) are only used to compute F (w) and F (p(w)), and w = p(w) from the properties for p in Definition 1. Thus, it is reasonable to assume that a pair of queries w and p(w) to f are asked at a time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2. A pair of distinct inputs w, w to F are called a matching pair if w = p(w). Otherwise, they are called a non-matching pair.</head><p>Notice that w = p(w) iff w = p(w ) since p(p(•)) is an identity permutation.</p><p>Definition. Insecurity is quantified by success probability of an optimal resourcebounded adversary. The resource is the number of the queries to f in the random oracle model.</p><p>For a set S, let z ← R S represent random sampling from S under the uniform distribution. For a probabilistic algorithm M, let z ← R M mean that z is an output of M and its distribution is based on the random choices of M.</p><p>Let H be a DBL hash function composed of a compression function F in Definition 1. The following experiment FindColHF(A, H) is introduced to quantify the collision resistance of H. The adversary A with the oracle f is a collisionfinding algorithm of H.</p><formula xml:id="formula_7">FindColHF(A, H) f ← R F 2n+b,n ; (m, m ) ← R A f ; if m = m ∧ H(m) = H(m ) return 1; else return 0;</formula><p>FindColHF(A, H) returns 1 iff A finds a collision. Let Adv coll H (A) be the probability that FindColHF(A, H) returns 1. The probability is taken over the uniform distribution on F 2n+b,n and random choices of A.</p><formula xml:id="formula_8">Definition 3. For q ≥ 1, let Adv coll H (q) = max A Adv coll H (A) ,</formula><p>where A makes at most q pairs of queries to f in total.</p><p>Without loss of generality, it is assumed that A does not ask the same query twice. A can keep pairs of queries and their corresponding answers by himself.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Analysis.</head><p>The following theorem shows the collision resistance of a hash function composed of F in Definition 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1.</head><p>Let H be a hash function composed of a compression function F specified in Definition 1. Then, for every</p><formula xml:id="formula_9">1 ≤ q ≤ 2 n , Adv coll H (q) ≤ q 2 n 2 + q 2 n .</formula><p>Proof. Let A be a collision-finding algorithm of H with the oracle f . A asks q pairs of queries to f in total. Suppose that A finds a colliding pair m, m of H. Then, it is easy to find a colliding pair of inputs for F without any additional queries to the oracle. Moreover, a pair of inputs to F are either matching or non-matching, so are the colliding pair of inputs for F . For 2 ≤ j ≤ q, let C j be the event that a colliding pair of non-matching inputs are found for F with the j-th pair of queries. Namely, it is the event that (f (w j ), f(p(w j )) ∈ {(f (w j ), f(p(w j ))), (f (p(w j )), f(w j ))} for some j &lt; j, where w j and p(w j ) are the j-th pair of queries. Since both f (w j ) and f (p(w j )) are randomly selected by the oracle,</p><formula xml:id="formula_10">Pr[C j ] ≤ 2(j -1) 2 2n .</formula><p>Let C be the event that a colliding pair of non-matching inputs are found for F with q pairs of queries. Then,</p><formula xml:id="formula_11">Pr[C] = Pr[C 2 ∨ C 3 ∨ • • • ∨ C q ] ≤ q j=2 Pr[C j ] ≤ q 2 n 2 .</formula><p>For 1 ≤ j ≤ q, let C m j be the event that a colliding pair of matching inputs are found for F with the j-th pair of queries, that is, f (w j ) = f (p(w j )). Thus,</p><formula xml:id="formula_12">Pr[C m j ] = 1 2 n .</formula><p>Let C m be the event that a colliding pair of matching inputs are found for F with q pairs of queries. Then,</p><formula xml:id="formula_13">Pr[C m ] = Pr[C m 1 ∨ C m 2 ∨ • • • ∨ C m q ] ≤ q j=1 Pr[C m j ] = q 2 n .</formula><p>Thus, if q ≤ 2 n , then</p><formula xml:id="formula_14">Adv coll H (A) ≤ Pr[C ∨ C m ] ≤ Pr[C] + Pr[C m ] ≤ q 2 n 2 + q 2 n ,</formula><p>which holds for any A.</p><p>From Theorem 1, any constant probability of success in finding a collision of H requires Ω(2 n ) queries.</p><p>A better bound can be obtained with more restricted permutations.</p><p>Theorem 2. Let H be a hash function composed of a compression function F specified in Definition 1. Suppose that the permutation p is represented by p(g, h, m) = (p cv (g, h), p m (m)), where p cv : {0, 1} 2n → {0, 1} 2n and p m : {0, 1} b → {0, 1} b . Suppose that p cv has no fixed points and that p cv (g, h) = (h, g) for any (g, h). Then, for every</p><formula xml:id="formula_15">1 ≤ q ≤ 2 n , Adv coll H (q) ≤ 3 q 2 n 2 .</formula><p>Proof. Let A be a collision-finding algorithm of H with the oracle f . A asks q pairs of queries to f in total. Suppose that A finds a colliding pair m, m of H. Then, it is easy to find a colliding pair of inputs for F without any additional queries. Moreover, a pair of inputs to F are either matching or non-matching, so are the colliding pair of inputs for F . Let C be the event that a colliding pair of non-matching inputs are found for F with q pairs of queries. Then, as in the proof of Theorem 1,</p><formula xml:id="formula_16">Pr[C] ≤ q 2 n 2 .</formula><p>Suppose that a colliding pair of matching inputs are obtained for F from the collision of H found by A. Let (g, h, m) and (g , h , m ) be the colliding pair. Then, (g, h) = p cv (g , h ) (and (g , h ) = p cv (g, h)). (g, h) and (g , h ) are both outputs of F , or at most one of them is the initial value (g 0 , h 0 ) of H since (g, h) = (g , h ). Thus, a pair of inputs w and w are also found for F from the collision of H such that F (w) = p cv (F (w )) or F (w) = p cv (g 0 , h 0 ).</p><p>Suppose that (g, h) = F (w) and (g , h ) = F (w ). Then, a pair of w and w are non-matching since (g, h) = p cv (g , h ) = (h , g ).</p><p>For 1 ≤ j ≤ q, let Ĉm j be the event that, for the j-th pair of queries w j and p(w j ),</p><formula xml:id="formula_17">F (w j ) ∈ {p cv (g 0 , h 0 )} ∪ 1≤j &lt;j {p cv (F (w j )), p cv (F (p(w j )))} or F (p(w j )) ∈ {p cv (g 0 , h 0 )} ∪ 1≤j &lt;j {p cv (F (w j )), p cv (F (p(w j )))} . Thus, Pr[ Ĉm j ] ≤ 2(2j -1) 2 2n . Let Ĉm = Ĉm 1 ∨ • • • ∨ Ĉm q . Then, Pr[ Ĉm ] ≤ q j=1 Pr[ Ĉm j ] ≤ q j=1 2(2j -1) 2 2n = 2 q 2 n 2 .</formula><p>Thus,</p><formula xml:id="formula_18">Adv coll H (A) ≤ Pr[C ∨ Ĉm ] ≤ Pr[C] + Pr[ Ĉm ] ≤ 3 q 2 n 2 ,</formula><p>for 1 ≤ q ≤ 2 n , which holds for any A.</p><p>For q &lt; 2 n-1 , Theorem 2 gives a smaller upper bound than Theorem 1. The difference between their upper bounds is significant. For example, let n = 128 and q = 2 80 . Then, the upper bound of Theorem 1 is about 2 -48 , while the upper bound of Theorem 2 is less than 2 -94 .</p><p>Example 1. Here is an example of the permutation p satisfying the conditions given in Theorem 2:</p><formula xml:id="formula_19">p(g, h, m) = (g ⊕ c 1 , h ⊕ c 2 , m) ,</formula><p>where c 1 and c 2 are distinct constants in {0, 1} n .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Indistinguishability in the Iteration</head><p>We introduce a new security notion which is called indistinguishability in the iteration. (3) j ) from (w (1) , w (2) , w (3) ) (w (1) , w (2)  1) , v (2) ) ∧ w (3) ∈ {0, 1} b , where (v (1) , v (2) ) is O's answer to the -th query for ≥ 1 and (v</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition. Let F be a compression function specified in</head><formula xml:id="formula_20">) ∈ j-1 =0 (v<label>(</label></formula><formula xml:id="formula_21">(1) 0 , v<label>(2)</label></formula><p>0 ) is some fixed initial value of a hash function H. F is assumed to be used only in the iteration of H.</p><formula xml:id="formula_22">DistinguishCF(A, F ) d ← R {0, 1}; d ← R A O(d) ; if d = d return 1; else return 0;</formula><p>Let Succ ind-it F (A) be the probability that DistinguishCF(A, F ) returns 1. Without loss of generality, it can be assumed that Succ ind-it F (A) ≥ 1/2 because the probability that d = d is 1/2 even if A chooses d randomly. It can also be assumed that A does not ask the same query twice. Let</p><formula xml:id="formula_23">Adv ind-it F (A) def = Succ ind-it F (A) -1/2 . Definition 4. For q ≥ 1, let Adv ind-it F (q) = max A Adv ind-it F (A) ,</formula><p>where A makes at most q queries to O.</p><p>As long as Adv ind-it F (q) is small enough, the compression function F behaves like a random function in the iterated hash function. The following theorem presents an upper bound on Adv ind-it F (q) with additional restriction on the permutation p. Theorem 3. Let F be a compression function specified in Definition 1. Suppose that the permutation p is represented by p(g, h, m) = (p cv (g, h), p m (m)), where p cv : {0, 1} 2n → {0, 1} 2n and p m : {0, 1} b → {0, 1} b . Suppose that p cv has no fixed points. Then, for every</p><formula xml:id="formula_24">1 ≤ q ≤ 2 n , Adv ind-it F (q) ≤ 1 2 q 2 n 2 .</formula><p>Proof. Let A be the optimal distinguishing algorithm for F which makes q queries. Let w j be A's j-th query to O and</p><formula xml:id="formula_25">T = {w j | 1 ≤ j ≤ q} ∩ {p(w j ) | 1 ≤ j ≤ q}. Suppose that d = 1. Then, O returns F (w j ) = (f (w j ), f(p(w j ))) for w j . If T = φ, then F is completely indistinguishable from R.</formula><p>It is because each one of f (w j ) and f (p(w j )) for 1 ≤ j ≤ q appears only once and it is chosen randomly by O.</p><p>Let Empty be the event that T = φ. Then,</p><formula xml:id="formula_26">Succ ind-it F (A) = Pr[d = d ] = Pr[d = d ∧ Empty] + Pr[d = d ∧ ¬Empty] = Pr[d = d | Empty] Pr[Empty] + Pr[d = d | ¬Empty] Pr[¬Empty] ≤ 1 2 + Pr[¬Empty] .</formula><p>Let v j be the initial value if j = 0 and the answer of O to the j-th query by</p><formula xml:id="formula_27">A if j ≥ 1. For 1 ≤ j ≤ q, let C j be the event that v j ∈ {p cv (v ) | 0 ≤ ≤ j -1}. Then, Pr[C j ] ≤ j 2 2n . For 1 ≤ q ≤ 2 n , Pr[¬Empty] ≤ Pr[C 1 ∨ • • • ∨ C q-1 ] ≤ q-1 j=1 Pr[C j ] ≤ 1 2 q 2 n 2 which implies that Adv ind-it F (q) ≤ (q/2 n ) 2 /2.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">DBL Hash Function in the Ideal Cipher Model</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Compression Function</head><p>In this section, the collision resistance of a DBL hash function composed of a compression function using a block cipher is analyzed. The compression function specified in the following definition is considered.</p><formula xml:id="formula_28">Definition 5. Let F : {0, 1} 2n × {0, 1} b → {0, 1} 2n be a compression function such that (g i , h i ) = F (g i-1 , h i-1 , m i ), where g i , h i ∈ {0, 1} n and m i ∈ {0, 1} b . F consists of a (n, n + b)</formula><p>block cipher e as follows:</p><formula xml:id="formula_29">g i = F U (g i-1 , h i-1 , m i ) = e(h i-1 m i , g i-1 ) ⊕ g i-1 h i = F L (g i-1 , h i-1 , m i ) = e(h i-1 m i , g i-1 ⊕ c) ⊕ g i-1 ⊕ c ,</formula><p>where represents concatenation and c ∈ {0, 1} n -{0 n } is a constant.</p><p>The compression function in Definition 5 is also shown in Fig. <ref type="figure">1</ref>. It is one of the compression functions specified in Definition 1 and its f and p are specified as follows: </p><formula xml:id="formula_30">f (g i-1 , h i-1 , m i ) = e(h i-1 m i , g i-1 ) ⊕ g i-1 , p(g i-1 , h i-1 , m i ) = (g i-1 ⊕ c, h i-1 , m i ) . e e m i g i-1 h i-1 g i h i c</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Collision Resistance</head><p>Let F be a compression function specified in Definition 5. Two queries to the oracles e and e -1 in total are required to compute the output of F for an input. It is easy to see from Fig. <ref type="figure">1</ref> that a query to e or e -1 and the corresponding reply for F U (F L ) uniquely determine the query to e for F L (F U ). Moreover, these two queries are only used to compute the outputs of F for a matching pair of inputs. Thus, it is assumed that a pair of queries to e, e -1 required to compute an output of F are asked at a time.</p><p>Definition. The following experiment FindColHF(A, H) is similar to the one in Sect. 3 except that the adversary A is a collision-finding algorithm with the oracles e, e -1 . where A makes at most q pairs of queries to e, e -1 in total.</p><p>Without loss of generality, it is assumed that A asks at most only once on a triplet of a key, a plaintext and a ciphertext obtained by a query and the corresponding reply.</p><p>Analysis. The following theorem shows the collision resistance of a hash function composed of F in Definition 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 4.</head><p>Let H be a hash function composed of the compression function F specified in Definition 5. Then, for every 1 ≤ q ≤ 2 n-2 ,</p><formula xml:id="formula_31">Adv coll H (q) ≤ 3 q 2 n-1 2 .</formula><p>The proof of Theorem 4 is given in the appendix.</p><p>In this article, some plausible constructions have been proposed for DBL hash functions.</p><p>Recently, Pramstaller and Rijmen presented a collision attack on the scheme in Sect. 4 with DESX as an underlying block cipher <ref type="bibr" target="#b23">[24]</ref>. Their result does not contradict Theorem 4. It is a warning that we should be careful when we choose an underlying block cipher. It also shows a limitation of the random oracle/ideal cipher model. Related topics are discussed in <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b8">9]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Definition 1. The following experiment DistinguishCF(A, F ) is introduced to quantify the indistinguishability in the iteration of F . The adversary A is a distinguishing algorithm of F . A has an oracle O. In this experiment, a randomly chosen bit d ∈ {0, 1} is given to O first. If d = 1, then O chooses f ∈ F 2n+b,n randomly in advance. Then, O returns F (w) = (f (w), f(p(w))) to each query w from A. If d = 0, then O chooses R ∈ F 2n+b,2n randomly in advance. Then, O returns R(w) to each query w from A. A makes a chosen message attack and tries to tell whether O uses F or R. However, A is only allowed to select his j-th query w j = (w</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 . 2 F</head><label>12</label><figDesc>Fig. 1. A compression function considered in Sect. 4.2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>FindColHFDefinition 6 .</head><label>6</label><figDesc>(A, H) e ← R B n,n+b ; (m, m ) ← R A e,e -1 ; if m = m ∧ H(m) = H(m ) return 1; else return 0;Let Adv coll H (A) be the probability that FindColHF(A, H) returns 1. The probability is taken over the uniform distribution on B n,n+b and random choices of A. For q ≥ 1, letAdv coll H (q) = max A Adv coll H (A) ,</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>which holds for any A.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements. The author would like to thank the anonymous reviewers for their helpful comments.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Proof of Theorem 4</head><p>Let A be a collision-finding algorithm of H with oracles e, e -1 . A asks q pairs of queries to e, e -1 in total.</p><p>Since g i = e(h i-1 m i , g i-1 ) ⊕ g i-1 , g i depends both on the plaintext and the ciphertext of e and one of them is fixed by a query and the other is determined randomly by the answer from the oracle. Thus, g i is randomly determined by the answer. h i is also randomly determined by the other answer.</p><p>Let (k 1,j k 2,j , x j , y j ) and (k 1,j k 2,j , x j ⊕ c, z j ) be the triplets of e obtained by the j-th pair of queries and the corresponding answers.</p><p>For every 2 ≤ j ≤ q, let C j be the event that a colliding pair of non-matching inputs are found for F with the j-th pair of queries. Namely, it is the event that, for some j &lt; j,</p><p>Let C be the event that a colliding pair of non-matching inputs are found for F with q pairs of queries. Then,</p><p>Suppose that a colliding pair of matching inputs are obtained for F from the collision of H found by A. Let (g, h, m) and (g , h , m ) be the colliding pair of F . Then, (g, h) = (g ⊕ c, h ). (g, h) and (g , h ) are both outputs of F or at most one of them is the initial value (g 0 , h 0 ) of H. Thus, a pair of inputs w and w are also found for F from the collision of H such that</p><p>Then, a pair of w and w are non-matching since</p><p>For 1 ≤ j ≤ q, let (k 1,j k 2,j , x j , y j ) and (k 1,j k 2,j , x j ⊕ c, z j ) be the pair of triplets of e obtained by the j-th pair of queries and the corresponding answers. Let Ĉm j be the event that</p><p>Thus, if q ≤ 2 n-2 , then</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The ideal-cipher model, revisited: An uninstantiable blockcipherbased hash function</title>
		<author>
			<persName><forename type="first">J</forename><surname>Black</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2005">2005/210, 2005</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
	<note>Also appear in this proceedings</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">On the impossibility of highly efficient blockcipher-based hash functions</title>
		<author>
			<persName><forename type="first">J</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Cochran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Shrimpton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2005 Proceedings</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3494</biblScope>
			<biblScope unit="page" from="526" to="541" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Black-box analysis of the block-cipherbased hash-function constructions from PGV</title>
		<author>
			<persName><forename type="first">J</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Shrimpton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2002 Proceedings, Lecture Notes in Computer Science 2442</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="320" to="335" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Data authentication using modification detection codes based on a public one-way encryption function</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">O</forename><surname>Brachtl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Coppersmith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Hyden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Matyas</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H W</forename><surname>Meyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Oseas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Pilpel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schilling</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990-03">mar 1990</date>
			<biblScope unit="page">861</biblScope>
			<pubPlace>U. S</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Merkle-damgård revisited: How to construct a hash function</title>
		<author>
			<persName><forename type="first">J.-S</forename><surname>Coron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Malinaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Puniya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2005 Proceedings</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3621</biblScope>
			<biblScope unit="page" from="430" to="448" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Collision free hash functions and public key signature schemes</title>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT &apos;87 Proceedings</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="volume">304</biblScope>
			<biblScope unit="page" from="203" to="216" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">CRUSH: A new cryptographic hash function using iterated halving technique</title>
		<author>
			<persName><forename type="first">P</forename><surname>Gauravaram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Millan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>May</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Cryptographic Algorithms and their Uses</title>
		<meeting>Cryptographic Algorithms and their Uses</meeting>
		<imprint>
			<date type="published" when="2004">2004. 2004</date>
			<biblScope unit="page" from="28" to="39" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Analysis of double block length hash functions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hattori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hirose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yoshida</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th IMA International Conference on Cryptography and Coding</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 9th IMA International Conference on Cryptography and Coding</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2898</biblScope>
			<biblScope unit="page" from="290" to="302" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Secure block ciphers are not sufficient for one-way hash functions in the Preneel-Govaerts-Vandewalle model</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hirose</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th Selected Areas in Cryptography (SAC 2002)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 9th Selected Areas in Cryptography (SAC 2002)</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2595</biblScope>
			<biblScope unit="page" from="339" to="352" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Provably secure double-block-length hash functions in a black-box model</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hirose</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th Internatinal Conference on Information Security and Cryptology (ICISC 2004)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 7th Internatinal Conference on Information Security and Cryptology (ICISC 2004)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3506</biblScope>
			<biblScope unit="page" from="330" to="342" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Security of iterated hash functions based on block ciphers</title>
		<author>
			<persName><forename type="first">W</forename><surname>Hohl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Lai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Meier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Waldvogel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO &apos;93 Proceedings</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">773</biblScope>
			<biblScope unit="page" from="379" to="390" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Some attacks against a double length hash proposal</title>
		<author>
			<persName><forename type="first">L</forename><surname>Knudsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Muller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2005 Proceedings</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3788</biblScope>
			<biblScope unit="page" from="462" to="473" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Hash functions based on block ciphers and quaternary codes</title>
		<author>
			<persName><forename type="first">L</forename><surname>Knudsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Preneel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT &apos;96 Proceedings</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1163</biblScope>
			<biblScope unit="page" from="77" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Fast and secure hashing based on codes</title>
		<author>
			<persName><forename type="first">L</forename><surname>Knudsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Preneel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO &apos;97 Proceedings</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1294</biblScope>
			<biblScope unit="page" from="485" to="498" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Construction of secure and fast hash functions using nonbinary error-correcting codes</title>
		<author>
			<persName><forename type="first">L</forename><surname>Knudsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Preneel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="2524" to="2539" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Attacks on fast double block length hash functions</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">R</forename><surname>Knudsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Lai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Preneel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="59" to="72" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Hash function based on block ciphers</title>
		<author>
			<persName><forename type="first">X</forename><surname>Lai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Massey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT &apos;92 Proceedings</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">658</biblScope>
			<biblScope unit="page" from="55" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A failure-friendly design principle for hash functions</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lucks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2005 Proceedings</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3788</biblScope>
			<biblScope unit="page" from="474" to="494" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Handbook of Applied Cryptography</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Menezes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>Van Oorschot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Vanstone</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>CRC Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">One way hash functions and DES</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Merkle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO &apos;89 Proceedings</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">435</biblScope>
			<biblScope unit="page" from="428" to="446" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Design of Iteration on Hash Functions and Its Cryptanalysis</title>
		<author>
			<persName><forename type="first">M</forename><surname>Nandi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
		<respStmt>
			<orgName>Indian Statistical Institute</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Towards optimal double-length hash functions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Nandi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th International Conference on Cryptology in India (INDOCRYPT 2005)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 6th International Conference on Cryptology in India (INDOCRYPT 2005)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3797</biblScope>
			<biblScope unit="page" from="77" to="89" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Security analysis of a 2/3-rate double length compression function in the black-box model</title>
		<author>
			<persName><forename type="first">M</forename><surname>Nandi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sakurai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th Fast Software Encryption (FSE 2005)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 12th Fast Software Encryption (FSE 2005)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">35571</biblScope>
			<biblScope unit="page" from="243" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A collision attack on a double-blocklength hash proposal</title>
		<author>
			<persName><forename type="first">N</forename><surname>Pramstaller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Rijmen</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2006">2006/116, 2006</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Hash functions based on block ciphers: A synthetic approach</title>
		<author>
			<persName><forename type="first">B</forename><surname>Preneel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Govaerts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vandewalle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO &apos;93 Proceedings</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">773</biblScope>
			<biblScope unit="page" from="368" to="378" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Towards secure and fast hash functions</title>
		<author>
			<persName><forename type="first">T</forename><surname>Satoh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Haga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kurosawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEICE Transactions on Fundamentals</title>
		<imprint>
			<biblScope unit="volume">82</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="55" to="62" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
