<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Erasure coding for distributed storage: an overview †</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2018-09-06">6 September 2018</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Balaji</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Communication Engineering</orgName>
								<orgName type="institution">Indian Institute of Science</orgName>
								<address>
									<postCode>560012</postCode>
									<settlement>Bangalore</settlement>
									<country key="IN">India</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">M</forename><forename type="middle">Nikhil</forename><surname>Krishnan</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Communication Engineering</orgName>
								<orgName type="institution">Indian Institute of Science</orgName>
								<address>
									<postCode>560012</postCode>
									<settlement>Bangalore</settlement>
									<country key="IN">India</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Myna</forename><surname>Vajha</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Communication Engineering</orgName>
								<orgName type="institution">Indian Institute of Science</orgName>
								<address>
									<postCode>560012</postCode>
									<settlement>Bangalore</settlement>
									<country key="IN">India</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Vinayak</forename><surname>Ramkumar</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Communication Engineering</orgName>
								<orgName type="institution">Indian Institute of Science</orgName>
								<address>
									<postCode>560012</postCode>
									<settlement>Bangalore</settlement>
									<country key="IN">India</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Birenjith</forename><surname>Sasidharan</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Communication Engineering</orgName>
								<orgName type="institution">Indian Institute of Science</orgName>
								<address>
									<postCode>560012</postCode>
									<settlement>Bangalore</settlement>
									<country key="IN">India</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">&amp;</forename><forename type="middle">P Vijay</forename><surname>Kumar</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Communication Engineering</orgName>
								<orgName type="institution">Indian Institute of Science</orgName>
								<address>
									<postCode>560012</postCode>
									<settlement>Bangalore</settlement>
									<country key="IN">India</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Ming Hsieh Department of Electrical Engineering</orgName>
								<orgName type="institution">University of Southern California</orgName>
								<address>
									<settlement>Los Angeles CA90089</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Erasure coding for distributed storage: an overview †</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2018-09-06">6 September 2018</date>
						</imprint>
					</monogr>
					<idno type="MD5">317642E62BF3C6C1446C4C8901C3AC85</idno>
					<idno type="DOI">10.1007/s11432-018-9482-6</idno>
					<note type="submission">Received 5 April 2018/Revised 4 May 2018/Accepted 7 July 2018/</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T15:45+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>distributed storage</term>
					<term>regenerating codes</term>
					<term>locally recoverable codes</term>
					<term>codes with locality</term>
					<term>erasure codes</term>
					<term>node repair</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In a distributed storage system, code symbols are dispersed across space in nodes or storage units as opposed to time. In settings such as that of a large data center, an important consideration is the efficient repair of a failed node. Efficient repair calls for erasure codes that in the face of node failure, are efficient in terms of minimizing the amount of repair data transferred over the network, the amount of data accessed at a helper node as well as the number of helper nodes contacted. Coding theory has evolved to handle these challenges by introducing two new classes of erasure codes, namely regenerating codes and locally recoverable codes as well as by coming up with novel ways to repair the ubiquitous Reed-Solomon code. This survey provides an overview of the efforts in this direction that have taken place over the past decade.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>This survey article deals with the use of erasure coding for the reliable and efficient storage of large amounts of data in settings such as that of a data center. The amount of data stored in a single data center can run into tens or hundreds of petabytes. Reliability of data storage is ensured in part by introducing redundancy in some form, ranging from simple replication to the use of more sophisticated erasure-coding schemes such as Reed-Solomon (RS) codes. Minimizing the storage overhead that comes with ensuring reliability is a key consideration in the choice of erasure-coding scheme. More recently a second problem has surfaced, namely, that of node repair. In <ref type="bibr" target="#b0">[1,</ref><ref type="bibr">2]</ref>, the authors study the Facebook warehouse cluster and analyze the frequency of node failures as well as the resultant network traffic relating to node repair. It was observed in <ref type="bibr" target="#b0">[1]</ref> that a median of 50 nodes is unavailable per day and that a median of 180 TB of cross-rack traffic is generated as a result of node unavailability. It was also reported that 98.08% of the cases have exactly one block missing in a stripe. The erasure code that was deployed in this instance was an [n = 14, k = 10] RS code. Here n denotes the block length of the code and k the dimension. The conventional repair of an [n, k] RS code is inefficient in that the repair of a single node, calls for contacting k other (helper) nodes and downloading k times the amount of data stored in the failed node, which is clearly inefficient. Thus there is significant practical interest in the design of erasure-coding techniques that offer both low overhead and which can also be repaired efficiently. Coding theorists have responded to this need by coming up with two new classes of codes, namely regenerating (RG) and locally recoverable (LR) codes. The focus in an RG code is on minimizing the amount of data download needed to repair a failed node, termed the repair bandwidth while LR codes seek to minimize the number of helper nodes contacted for node repair, termed the repair degree. In a different direction, coding theorists have also re-examined the problem of node repair in RS codes and have come up with new and more efficient repair techniques. This survey provides an overview of these recent developments. An outline of the survey itself appears in Figure <ref type="figure" target="#fig_0">1</ref>.</p><p>RG codes are discussed in Section 2. The two principal classes of RG codes, namely minimum bandwidth regenerating (MBR) and minimum storage regeneration (MSR) appear in the two sections that follow. These two classes of codes are at the two extreme ends of a tradeoff known as the storage-repair bandwidth (S-RB) tradeoff. A discussion on codes that correspond to the interior points of this tradeoff appears in Section 5. The theory of RG codes has been extended in several directions and these are explored in Section 6. Section 7 examines LR codes. There have been several approaches at extending the theory of LR codes to handle multiple erasures and these are dealt with in Section 8. A class of codes known as locally regenerating (LRG) codes that offer both low repair bandwidth and low repair degree within a single erasure code is discussed in Section 9. This is followed by Section 10 that discusses recent advances in the repair of RS codes. A brief description of a different approach based on capacity considerations and leading to the development of a liquid cloud storage system appears in Section 11. The final section, discusses practical evaluations and implementations.</p><p>Disclaimer. This survey is presented from the perspective of the authors and is biased in this respect. Given the explosion of research activity in this area, the survey also does not claim to be comprehensive and we offer our apologies to the authors whose work has inadvertently or for lack of space, not been appropriately cited. We direct the interested reader to some of the excellent surveys of codes on distributed storage contained in the literature including <ref type="bibr" target="#b2">[3]</ref><ref type="bibr" target="#b3">[4]</ref><ref type="bibr" target="#b4">[5]</ref><ref type="bibr" target="#b5">[6]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RG codes</head><p>Definition 1 ( <ref type="bibr" target="#b6">[7]</ref>). Let F q denote a finite field of size q. Then an RG code C over F q having integer parameter set ((n, k, d), (α, β), B) where 1 k n -1, k d n -1, β α, maps a file u ∈ F B q on to a collection {c i } n i=1 of n α-tuples over F q using an encoding map  with the α components of c i stored on the i-th node in such a way that the following two properties (see Figure <ref type="figure" target="#fig_1">2</ref>) are satisfied:</p><formula xml:id="formula_0">E(u) = [c T 1 , c T 2 , . . . , c T n ] T</formula><p>• Data collection. the message u can be uniquely recovered from the contents {c ij } k j=1 of any k nodes. • Node repair. If the f -th node storing c f fails, then a replacement node can (1) contact any subset D ⊆ [n] \ {f } of the remaining (n -1) nodes of size |D| = d; (2) map the α contents c h of each helper node h ∈ D on to a collection of β repair symbols a D h,f ∈ F β q ;</p><p>(3) pool together the dβ repair symbols thus computed to use them to create a replacement vector ĉf ∈ F α q whose α components are stored in the replacement node, in such a way that the contents of the resultant nodes, with the replacement node replacing the failed node, once again forms an RG code.</p><p>An RG code is said to be exact-repair (ER) RG code if the contents of the replacement node are exactly same as that of the failed node, ie., ĉf = c f . Else the code is said to be functional-repair (FR) RG code. An RG code is said to be linear if (1) E(u 1 + θu 2 ) = E(u 1 ) + θE(u 2 ), u 1 , u 2 ∈ F B q , θ ∈ F q and (2) the map mapping the contents c h of the h-th helper node on to the corresponding β repair symbols a D h,f is linear over F q .</p><p>Thus an RG code is a code over a vector alphabet F α q and the quantity α is termed the sub-packetization level of the RG code. The total number dβ of F q symbols to be transferred for repair of failure node is called the repair bandwidth of the RG code. The rate of the RG code is given by R = B nα . Its reciprocal nα B is the storage overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Cut-set bound</head><p>Let us assume that C is an FR RG code having parameter set ((n, k, d), (α, β), B). Since an ER RG code is also an FR code, this subsumes the case when C is an ER RG code. Over time, nodes will undergo failures and every failed node will be replaced by a replacement node. Let us assume to begin with, that we are only interested in the behavior of the RG code over a finite-but-large number N ≫ n of node repairs. For simplicity, we assume that repair is carried out instantaneously. Then at any given time instant t, there are n functioning nodes whose contents taken together comprise an RG code. At this time instant, a data collector could connect to k nodes, download all of their contents and decode to recover underlying message vector u. Thus in all, there are at most N n k distinct data collectors which are distinguished based on the particular set of k nodes to which the data collector connects.</p><p>Next, we create a source node that possesses the B message symbols {u i } B i=1 , and draw edges connecting the source to the initial set of n nodes. We also draw edges between the d helper nodes that assist a replacement node and the replacement node itself as well as edges connecting each data collector with the corresponding set of k nodes from which the data collector downloads data. All edges are directed in the direction of information flow. We associate a capacity β with edges emanating from a helper node to a replacement node and an ∞ capacity with all other edges. Each node can only store α symbols over F q . We take this constraint into account using a standard graph-theory construct, in which a node is replaced by 2 nodes separated by a directed edge (leading towards a data collector) of capacity α. We have in this way, arrived at a graph (Figure <ref type="figure" target="#fig_2">3</ref>) in which there is one source S and at most N n k sinks {T i }. Each sink T i would like to be able to reconstruct all the B source symbols {u i } from the symbols it receives. This is precisely the multicast setting of network coding. A principal result in network coding tells us that in a multicast setting, one can transmit messages along the edges of the graph in such a way that each sink T i is able to reconstruct the source data, provided that the minimum capacity of a cut separating S from T i is B. A cut separating S from T i is simply a partition of the nodes of the network into 2 sets: A i containing S and A c i containing T i . The capacity of the cut is the sum of capacities of the edges leading from a node in A i to a node in A c i . A careful examination of the graph will reveal that the minimum capacity Q of a cut separating a sink T i from source S is given by Q = k-1 i=0 min{α, (d -i)β} (Figure <ref type="figure" target="#fig_2">3</ref> shows an example cut separating source from sink). This leads to the following upper bound on file size <ref type="bibr" target="#b6">[7]</ref>:</p><formula xml:id="formula_1">B k-1 i=0 min{α, (d -i)β}.<label>(1)</label></formula><p>Network coding also tells us that when only a finite number of regenerations take place, this bound is achievable and furthermore achievable using linear network coding, i.e., using only linear operations at each node in the network when the size q of the finite field F q is sufficiently large. In a subsequent result <ref type="bibr" target="#b7">[8]</ref>, Wu established using the specific structure of the graph, that even in the case when the number of sinks is infinite, the upper bound in <ref type="bibr" target="#b0">(1)</ref> continues to be achievable using linear network coding.</p><p>In summary, by drawing upon network coding, we have been able to characterize the maximum file size of an RG code given parameters {k, d, α, β} for the case of functional repair when there is constraint placed on the size q of the finite field F q . Note interestingly, that the upper bound on file size is independent of n. Quite possibly, the role played by n is that of determining the smallest value of field size q for which a linear network code can be found having file size B satisfying <ref type="bibr" target="#b0">(1)</ref>. A functional RG code having parameters ((n, k, d), (α, β), B) is said to be optimal provided (a) the file size B achieves the bound in <ref type="bibr" target="#b0">(1)</ref> with equality and (b) reducing either α or β will cause the bound in (1) to be violated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Storage-repair bandwidth tradeoff</head><p>We have thus far, specified code parameters (k, d)(α, β) and asked what is the largest possible value of file size B. If however, we fix parameters (n, k, d, B) and ask instead what are the smallest values of (α, β) for which one can hope to achieve <ref type="bibr" target="#b0">(1)</ref>, it turns out, as might be evident from the form of the summands on the RHS of <ref type="bibr" target="#b0">(1)</ref>, that there are several pairs (α, β) for which equality holds in <ref type="bibr" target="#b0">(1)</ref>. In other words, there are different flavors of optimality.</p><p>For a given file size B, the storage overhead and normalized repair bandwidth are given respectively by nα B and dβ B . Thus α reflects the amount of storage overhead while β determines the normalized repair bandwidth. The several pairs (α, β) for which equality holds in <ref type="bibr" target="#b0">(1)</ref>, represent a tradeoff between storage overhead on the one hand and normalized repair bandwidth on the other as can be seen from the example plot in Figure <ref type="figure" target="#fig_3">4</ref>. Clearly, the smallest value of α for which the equality can hold in (1) is given by α (n -k + 1). By the singleton bound, the largest size M of a code of block length n and minimum distance d min is given by M Q n-dmin+1 Q k , where Q is the size of alphabet of the code. Since Q = q α in the case of RG code, it follows that the size M of an RG code must satisfy M q kα , or equivalently q B q kα , i.e., B kα. But B = kα in the case of an MSR code and it follows that an MSR code is a maximum distance separable (MDS) code over a vector alphabet. Such codes also go by the name MDS array code.</p><formula xml:id="formula_2">= B k . Given α = B k ,</formula><p>From a practical perspective, ER RG codes are easier to implement as the contents of the n nodes in operation do not change with time. Partly for this reason and partly for reasons of tractability, with few exceptions, most constructions of RG codes belong to the class of ER RG codes. Examples of FR RG code include the d = (k + 1) construction in <ref type="bibr" target="#b8">[9]</ref> as well as the construction in <ref type="bibr" target="#b9">[10]</ref>.</p><p>Early constructions of RG codes focused on the two extreme points of the S-RB tradeoff, namely the MSR and MBR points. The various constructions of MBR and MSR codes are described in Sections 3 and 4. Not surprisingly, given the vast amount of data stored, the storage industry places a premium on low storage overhead. In this connection, we note that the maximum rate of an MBR code is given by</p><formula xml:id="formula_3">R MBR = B nα = (dk -k 2 )β ndβ = dk -k 2 nd ,</formula><p>which can be shown to be upper bounded by R MBR 1 2 and is achieved when k = d = (n -1). In the case of MSR codes, there is no such limitation and MSR codes can have rates approaching 1.</p><p>An RG code is said to be a help-by-transfer (HBT) RG code if repair of a failed node can be accomplished without incurring any computation at a helper node. If no computation is required at either helper node or at the replacement node, then the code is termed a repair-by-transfer (RBT) RG code. Clearly, an RBT RG code is also an HBT RG code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">MBR codes</head><p>Remark 2. If the B message symbols are drawn randomly with uniform distribution from F B q , it can be shown that in any RG code achieving the cut-set bound, the contents of each node correspond to a random variable that is uniform over F α q . In an MBR code, repair is accomplished by downloading a total of just α symbols which clearly, is the minimum possible. Remark 3. Let C be an MBR code. If C has the RBT property, it trivially follows that all scalar codesymbols of C are replicated at least twice. In <ref type="bibr" target="#b10">[11]</ref>, it is shown that for an MBR code it is not possible to have even a single scalar code-symbol replicated more than twice. Thus the RBT property implies that the collection of nα scalar code-symbols associated with a codeword represent a set of nα 2 distinct code symbols, each repeated twice. The converse is not true in general. However when d = (n -1), it can be shown that the two properties are equivalent. Remark 4. In <ref type="bibr" target="#b11">[12]</ref>, it is shown that for d &lt; (n -1), it is not possible to construct an MBR code that has the HBT property.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Polygonal MBR codes</head><p>In the following, we describe with the help of an example, one of the first explicit families of MBR codes <ref type="bibr" target="#b12">[13]</ref>. We term these codes as polygonal MBR codes. The construction holds for parameters k d = n -1, β = 1 and the constructed MBR codes possess the RBT property.  uniquely assigned an edge. Each node of the MBR code stores the code-symbols corresponding to the edges incident on that node (Figure <ref type="figure" target="#fig_6">5</ref>). The data collection property follows as any collection of k = 3 nodes yields nine distinct (MDS) code-symbols. If a node fails, the replacement node can download from each of the remaining four nodes, the code-symbol corresponding to the edge it shares with the failed node. Hence repair is accomplished by merely transferring the data without any computation (RBT).</p><p>Remark 5. For the general construction, in order to construct an [n, k, d = n -1], β = 1 MBR code, one first forms the complete graph on n vertices. Each edge is then mapped to a code-symbol of an [N, B] MDS code, where N = n 2 and B is the file size parameter. An O(n 2 ) field-size requirement is thus imposed by the underlying scalar MDS code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Product-matrix (PM) MBR codes</head><p>A second, general construction for MBR codes is the PM construction <ref type="bibr" target="#b13">[14]</ref> which derives its name from the fact that the contents of n nodes can be expressed in the form of a product of two matrices. The two matrices are respectively an encoding matrix and a second, message matrix containing the message symbols. This construction yields MBR codes for all feasible parameters k d n -1, β = 1, with an O(n) field-size requirement. The (n × d) encoding matrix ψ is of the form: ψ = [φ ∆], where φ, ∆ are (n × k), (n × (d -k)) matrices, respectively. Let the i-th row of ψ be denoted by ψ T i . The sub-matrices φ and ∆ are here chosen such that any d rows of ψ and any k rows of φ are linearly independent. The</p><formula xml:id="formula_4">(d × d) symmetric message matrix M is derived from the B = kd -k 2 message symbols as M = [ S V V T 0 ], where S is a symmetric (k × k) matrix and V a (k × (d -k)) matrix.</formula><p>The i-th node, under the PM-MBR construction, stores the matrix product ψ T i M . The repair data passed on by helper node j to replacement node i is given by ψ T j M ψ i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Other work</head><p>In <ref type="bibr" target="#b14">[15]</ref>, the authors introduce a family of RBT MBR codes for d = n -1, that are constructed based on a congruent transformation applied to a skew-symmetric matrix of message symbols. In comparison with the O(n 2 ) field requirement of polygonal MBR codes, in this construction, a field-size of O(n) suffices. In <ref type="bibr" target="#b15">[16]</ref>, the authors stay within the PM framework, but provide a different set of encoding matrices for MSR and MBR codes that have least-possible update complexity within the PM framework. The authors of <ref type="bibr" target="#b15">[16]</ref> also analyze the codes for their ability to correct errors and provide corresponding decoding algorithms. Ref. <ref type="bibr" target="#b11">[12]</ref> proves the non-existence of HBT MBR codes with d &lt; (n -1). The paper also provides PM-based constructions for two relaxations, namely (i) any failed node which is a part of a collection of systematic nodes can be recovered in HBT fashion from any d other nodes and (ii) for every failed node, there exists a corresponding set of d helper nodes which permit HBT repair.</p><p>Ref. <ref type="bibr" target="#b10">[11]</ref> provides binary MBR constructions for the parameters</p><formula xml:id="formula_5">(k = d = n -2), (k + 1 = d = n -2)</formula><p>and studies the existence of MBR codes with inherent double replication, for all parameters. In <ref type="bibr" target="#b16">[17]</ref>, the authors provide regenerating-code constructions that asymptotically achieve the MSR or MBR point as k increases and these codes can be constructed over any field, provided the file size is large enough.</p><p>In <ref type="bibr" target="#b17">[18]</ref>, the authors introduce some extensions to the classical MBR framework by permitting the presence of a certain number of error-prone nodes during repair/reconstruction and by introducing flexibility in choosing the parameter d during node repair.</p><p>Open problems 1. Determine the smallest possible field size q of an MBR code for given {(n, k, d), (α, β)}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">MSR codes</head><p>Among the class of RG codes, MSR codes have received the greatest attention, and the reasons include the fact that (a) the storage overhead of an MSR code can be made as small as desired, (b) MSR codes are MDS codes and (c) MSR codes have been challenging to construct.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Introduction</head><p>As noted previously, an MSR code with parameters (n, k, d, α) has file size B = kα and β = α d-k+1 . Although MSR codes are vector MDS codes that have optimum repair-bandwidth of dβ for the repair of any node among the n nodes, there are papers in the literature that refer to a code as an MSR code even if optimal repair holds only for the systematic nodes. In the current paper, we refer to such codes as systematic MSR codes. While only β symbols are sent by each of the d helper nodes, the number of symbols accessed by the helper node in order to generate these β symbols could be &gt; β. The class of MSR codes that access at each helper node, only as many symbols as are transferred, are termed optimal-access MSR codes. MSR codes that alter a minimum number of parity symbols while updating a single, systematic symbol, are called update-optimal MSR codes.</p><p>There are several ER MSR constructions available in the literature. Shah et al. <ref type="bibr" target="#b8">[9]</ref> show that interference alignment (IA) is necessarily present in every ER MSR code, and use IA techniques to construct systematic MSR codes, known as MISER codes, for d = n -1 2k -1. The IA condition in the context of MSR codes (observed earlier in <ref type="bibr" target="#b18">[19]</ref>) demands that the interference components in the data passed by helper nodes must be aligned so that they can be cancelled at the replacement node by data received from the systematic helper nodes. In <ref type="bibr" target="#b19">[20]</ref>, Suh et al. build on <ref type="bibr" target="#b8">[9]</ref> to construct MSR codes for d 2k -1 with optimal repair bandwidth for all nodes, under the condition that the helper-node set necessarily includes systematic nodes. In <ref type="bibr" target="#b13">[14]</ref>, the well-known PM framework is introduced to provide MSR constructions for d 2k -1, thereby settling the problem of MSR code construction in the low-rate regime, k/n 0.5. While the method adopted in <ref type="bibr" target="#b13">[14]</ref> to provide a construction for d &gt; 2k -1 is to suitably shorten a code for d = 2k -1, an extension of the PM framework that yields constructions for any d 2k -1 in a single step is provided in <ref type="bibr" target="#b20">[21]</ref>. Apart from a few notable constructions such as the Hadamard-design-based code <ref type="bibr" target="#b21">[22]</ref> for (k + 2, k) and its generalization for (n -k) &gt; 2 for systematic node-repair, the problem of high-rate constructions (i.e., k/n 0.5) for all-node repair remained open. The first major result in this direction, is due to Cadambe et al. <ref type="bibr" target="#b22">[23]</ref> where the authors apply the notion of symbol extension in IA where multiple symbols are grouped together to form a single vector symbol, to jointly achieve IA. The symbol-extension viewpoint is then used to show that ER MSR codes exist for all (n, k, d), as B goes to infinity. The second major development was the zigzag code construction <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b24">25]</ref>, the first non-asymptotic high-rate MSR code construction with d = (n -1) permitting rates as close as 1 as desired, with additional desirable properties such as optimal access and optimal update. Zigzag codes however, require a sub-packetization level (α) that grows exponentially with k and a very large finite field size, while the earlier PM codes for the low-rate regime, have α = (k + 1) and field-size that is linear in n. In a subsequent work <ref type="bibr" target="#b25">[26]</ref>, the authors present a systematic MSR construction having α = k 2 4 and rate R = 2/3. A second systematic MSR code with α = r k r+1 is presented in <ref type="bibr" target="#b26">[27]</ref>. A lower bound on sub-packetization level α of a general MSR code is derived in <ref type="bibr" target="#b27">[28]</ref>. The same paper shows that α r k-1 r in the case of an optimal-access MSR code. An improved lower bound for general MSR codes</p><formula xml:id="formula_6">2 log 2 α log ( r r-1 ) α + 1 + 1 k (2)</formula><p>appears in <ref type="bibr" target="#b28">[29]</ref>. These developments made it clear that the ultimate goal in MSR code construction was to construct a high-rate MSR code that simultaneously had low sub-packetization level α, low field-size q, arbitrary repair degree d and the optimal-access property.</p><p>In <ref type="bibr" target="#b29">[30]</ref>, a parity-check viewpoint is adopted to construct a high-rate MSR code for d = n -1 with a sub-packetization level r n r , requiring however, a large field-size. The construction was extended in <ref type="bibr" target="#b30">[31]</ref>, to d satisfying k d n -1. In <ref type="bibr" target="#b31">[32]</ref>, the authors provide a construction of MSR codes that holds for all k d n -1, but which once again required large field size. In <ref type="bibr" target="#b32">[33]</ref>, the authors provide a construction for an optimal-access systematic MSR code that holds for any parameter set (n, k, d = n-1) having sub-packetization α matching the lower bound given in <ref type="bibr" target="#b27">[28]</ref>. In <ref type="bibr" target="#b23">[24]</ref><ref type="bibr" target="#b24">[25]</ref><ref type="bibr" target="#b25">[26]</ref><ref type="bibr" target="#b26">[27]</ref><ref type="bibr" target="#b29">[30]</ref><ref type="bibr" target="#b30">[31]</ref><ref type="bibr" target="#b31">[32]</ref><ref type="bibr" target="#b32">[33]</ref>, combinatorial nullstellensatz <ref type="bibr" target="#b33">[34]</ref> is used to prove the MDS property due to which the codes are non-explicit and have large field sizes.</p><p>In <ref type="bibr" target="#b34">[35]</ref>, an explicit optimal-access, systematic MSR code is constructed with optimal α, but for limited values of n -k = 2, 3. In <ref type="bibr" target="#b35">[36]</ref>, the authors present two different classes of explicit MSR constructions, one of which possessed the optimal-access property. Both constructions are for any (n, k, d) with subpacketization level growing exponential in n.</p><p>In a major advance, Ye and Barg <ref type="bibr" target="#b36">[37]</ref> present an explicit construction of a high-rate, optimal-access MSR code with α = r ⌈ n r ⌉ , field size no larger than r⌈ n r ⌉, and d = (n -1). Essentially the same construction was independently rediscovered in <ref type="bibr" target="#b37">[38]</ref> from a different coupled-layer perspective, where layers of an arbitrary MDS codes are coupled by a simple pairwise coupling transform to yield an MSR code. Just prior to the appearance of these two papers, in an earlier version of <ref type="bibr" target="#b38">[39]</ref>, the authors show how a systematic MSR code can be converted into an MSR code by increasing the sub-packetization level by a factor of r = (n -k) using a pairwise symbol transformation. This result is then extended in <ref type="bibr" target="#b38">[39]</ref>, to present a technique that takes an MDS code, increases sub-packetization level by a factor of r and converts it into a code in which the optimal repair of r nodes can be carried out. By applying this transform repeatedly ⌈ n r ⌉ times, it is shown that any scalar MDS code can be transformed into an MSR code. It turns out that the three papers <ref type="bibr" target="#b36">[37]</ref><ref type="bibr" target="#b37">[38]</ref><ref type="bibr" target="#b38">[39]</ref>, either explicitly or implicitly, employed as a key part of the construction, essentially the same pairwise-coupling transform.</p><p>Let s = (d -k + 1). More recently, the lower bound α s n s was derived in <ref type="bibr" target="#b39">[40]</ref> for optimal-access MSR codes. The same paper also shows that the sub-packetization level of an MDS code that can optimally repair any w of the n nodes must satisfy α s ⌈ w s ⌉ . These results established that the earlier constructions in <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b36">[37]</ref><ref type="bibr" target="#b37">[38]</ref><ref type="bibr" target="#b38">[39]</ref><ref type="bibr" target="#b40">41]</ref> were optimal in terms of sub-packetization level α. It is also shown in <ref type="bibr" target="#b39">[40]</ref>, that a vector MDS code that can repair failed nodes belonging to a fixed set of Q nodes with minimum repair bandwidth and in optimal-access fashion, and having minimum sub-packetization level α = s n s must necessarily have a coupled-layer structure, similar to that found in <ref type="bibr" target="#b36">[37]</ref><ref type="bibr" target="#b37">[38]</ref><ref type="bibr" target="#b38">[39]</ref>. An explicit construction of MSR codes for d &lt; (n -1) with α achieving the lower bound α s n s for s = 2, 3, 4 was recently provided in <ref type="bibr" target="#b40">[41]</ref>. Please refer to Table <ref type="table" target="#tab_0">1</ref> for a summary of MSR code constructions in existing literature.</p><p>Open problems 2. Derive a tight lower bound on the sub-packetization level of MSR codes and provide matching constructions.</p><p>Open problems 3. Constructions for explicit optimal-access MSR codes for any (n, k, d) with optimal sub-packetization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Constructions of MSR codes</head><p>Product matrix construction <ref type="bibr" target="#b13">[14]</ref>. We provide a brief description of the PM construction for parameter set (n, k, d = 2k -2), (α = k -1, β = 1, B = k(k -1)). The message symbols {u i } B i=1 are arranged in the form of a (d × α) matrix M : M = [S 1 S 2 ] T , where the S 1 , S 2 are symmetric (k -1) × (k -1) matrices containing the B = k(k -1) message symbols. Encoding is carried out using a (n × d) matrix Li et al. <ref type="bibr" target="#b38">[39]</ref> for optimal-access MSR Vajha et al. <ref type="bibr" target="#b40">[41]</ref> (n, k, d)</p><formula xml:id="formula_7">d ∈ {k + 1, k + 2, k + 3} s ⌈ n s ⌉ O(n) Yes Yes Ψ = [Φ ΛΦ],</formula><p>where Φ is an n × (k -1) matrix and Λ is a diagonal matrix. Let the i-th row of Ψ be ψ T i , the i-th row of Φ be φ T i and the i-th diagonal element in Λ be λ i . The α symbols stored in node i are given by c</p><formula xml:id="formula_8">T i = ψ T i M = φ T i S 1 + λ i φ T i S 2 .</formula><p>The matrix Ψ is required to satisfy the properties (1) any d rows of Ψ are linearly independent, (2) any α rows of Φ are linearly independent and (3) the n diagonal elements of Λ are distinct.</p><p>• Node repair. Let f be the index of failed node, thus the aim is to reconstruct c f . The i-th helper node, h i , i ∈ [d], passes on the information: c T hi φ f = ψ T hi M φ f . Upon aggregating the repair information we obtain the vector [</p><formula xml:id="formula_9">ψ h1 ψ h2 • • • ψ h d ] T [M φ f ].</formula><p>As any d-rows of Ψ are linearly independent, the vector M φ f can be recovered. From M φ f , we can obtain S 1 φ f and S 2 φ f . Since S 1 and S 2 are symmetric, we can recover the contents c</p><formula xml:id="formula_10">T f = φ T f S 1 + λ f φ T f S 2 of the replacement node. • Data collection. Let Ψ DC = [Φ DC Λ DC Φ DC ]</formula><p>be the (k × d) sub matrix of Ψ corresponding to the k nodes contacted for data collection. We wish to retrieve M from Ψ DC M = Φ DC S 1 + Λ DC Φ DC S 2 . This can be done in three steps.</p><p>(</p><formula xml:id="formula_11">) First compute Ψ DC M Φ T DC = Φ DC S 1 Φ T DC +Λ DC Φ DC S 2 Φ T DC and set P = Φ DC S 1 Φ T DC , Q = Φ DC S 2 Φ T DC .<label>1</label></formula><p>(2) It is clear that P, Q are symmetric. Thus we know both P ij + λ i Q ij and P ij + λ j Q ij . Since λ i = λ j for i = j, we can recover P ij and Q ij for all i = j.</p><p>(3) Since we know P ij for j = i, we can compute the vector</p><formula xml:id="formula_12">φ T i S 1 [φ 1 , . . . , φ i-1 , φ i+1 , . . . , φ k ].</formula><p>Since any α rows of Φ are linearly independent, we can recover {φ T i S 1 |1 i k}. For any set of α distinct elements</p><formula xml:id="formula_13">φ T i , we can compute [φ 1 • • • φ α ] T S 1</formula><p>, from which S 1 can be recovered. S 2 can be similarly recovered from Q. The present description assumes data collection from the first k nodes, while a similar argument holds true for any arbitrary set of k nodes.</p><p>Coupled layer code. We present here the constructions in <ref type="bibr" target="#b36">[37]</ref><ref type="bibr" target="#b37">[38]</ref><ref type="bibr" target="#b38">[39]</ref> from a coupled-layer perspective. We explain the construction here only for parameter sets of the form (n = st, k = s(t -1), d = n -1), (α = s t , β = s t-1 ), q n, where s 1, t 2. (The construction can however, be extended to yield MSR codes for any (n, k, d = n -1) using a technique called shortening). The coupled-layer code can be constructed in two steps: (a) we layer α, (n, k) MDS codewords to form an uncoupled data-cube; (b) the symbols within the uncoupled-data cube are transformed using a pairwise-forward-transform (PFT) to obtain the coupled  layer code. While we discuss only the case when the MDS code employed in the layers is a scalar MDS code, there is a straightforward extension that permits the use of vector MDS codes <ref type="bibr" target="#b37">[38]</ref>.</p><p>Let us first consider the nα symbols {U (x, y, z) | (x, y) ∈ Z s × Z t , z ∈ Z t s } of an uncoupled code U where each code symbol U (x, y, •) is a vector of α symbols in F q . These nα symbols can be organized to form a three-dimensional (3D) data cube (Figure <ref type="figure" target="#fig_7">6</ref>), where (x, y) ∈ Z s × Z t is the node index and where z ∈ Z t s serves to index the contents of a node. For fixed z ∈ Z t s , we think of the symbols {U (x, y, z) | (x, y) ∈ Z s × Z t } as forming a plane or a layer and thus the value of z may be regarded as identifying a plane or layer. The symbols in each layer of the uncoupled data cube form an (n, k) MDS code.</p><p>Let Θ be the ((n -k) × n) parity check (p-c) matrix of an arbitrarily chosen (n, k) scalar MDS code defined over F q . Let θ x,y (ℓ) denote the element of Θ lying in the ℓ-th row, and (x, y)-th column. Then the symbols of the uncoupled code satisfy the p-c equations</p><formula xml:id="formula_14">(x,y)∈Z s ×Z t θ x,y (ℓ)U (x, y; z) = 0, ∀ℓ ∈ [0, n -k -1], ∀z ∈ Z t s .<label>(3)</label></formula><p>Next, consider an identical data-cube (Figure <ref type="figure" target="#fig_8">7</ref>) containing the nα symbols {C(x, y, z) | (x, y) ∈ Z s ×Z t , z ∈ Z t s } corresponding to the coupled-layer code. This data-cube will be referred to as the coupled data cube. The symbols of the coupled data cube are derived from the symbols of the uncoupled data cube as follows. Let γ be an element in F q \{0}, γ 2 = 1. Let us define z(y, x) = (z 0 , . . . , z y-1 , x, z y+1 , . . . , z t-1 ). Each symbol C(x, y, z) which is such that z y = x is paired with a symbol C(z y , y, z(y, x)). The values of the symbols so paired, are derived from those of their counterparts in the uncoupled data cube as per the (2 × 2) linear transformation given below, termed as the PFT</p><formula xml:id="formula_15">C(x, y, z) C(z y , y, z(y, x)) = 1 γ γ 1 -1 U (x, y, z) U (z y , y, z(y, x)) .<label>(4)</label></formula><p>In the case of the symbols C(x, y, z) when z y = x, the relation between symbols in the two data cubes is even simpler and given by C(x, y, z) = U (x, y, z). The pairwise reverse transform (PRT) is simply the inverse of the PFT and is used to obtain the uncoupled symbols U (•) from the coupled symbols C(•). The p-c equations satisfied by the coupled-layer code can be derived using the p-c equations (3) satisfied by the symbols in the uncoupled data cube and the PRT</p><formula xml:id="formula_16">(x,y)∈Z s ×Z t θ x,y (ℓ)C(x, y, z) + y∈Z t x =zy γθ x,y (ℓ)C(z y , y, z(y, x)) = 0, ∀z ∈ Z t s , ℓ ∈ [0, n -k -1].<label>(5)</label></formula><p>• Node repair. Let (x 0 , y 0 ) be the failed node. To recover the symbols {C(x 0 , y 0 , z) | z ∈ Z t s }, each of the remaining nodes (x, y) = (x 0 , y 0 ) sends helper information {C(x, y, z) | z ∈ Z t s , z y0 = x 0 }. Focusing on ( <ref type="formula" target="#formula_16">5</ref>) for z such that z y0 = x 0 and retaining on the left side the unknown symbols, leads to equations of the form</p><formula xml:id="formula_17">θ x0,y0 (ℓ)C(x 0 , y 0 , z) + x =x0 γθ x,y0 (ℓ)C(x 0 , y 0 , z(y 0 , x)) = κ * , ∀ℓ ∈ [0, n -k -1],<label>(6)</label></formula><p>where κ * is a known value. These equations can be solved for the contents of the replacement node.</p><p>• Data collection. Please refer to <ref type="bibr" target="#b37">[38]</ref> for the proof of data collection property.</p><p>Ye-Barg codes <ref type="bibr" target="#b35">[36]</ref>. In <ref type="bibr" target="#b35">[36]</ref>, the authors present two constructions, for non optimal-access MSR and optimal-access MSR codes, respectively. These are the only known MSR constructions that are explicit and yield MSR codes for any parameter set (n, k, d). The same codes are also optimal for the repair of multiple nodes. We describe here, for simplicity, the construction of (n, k, d) MSR codes having parameters (n, k, d), (α = s n , β = s n-1 ), q sn where s = d -k + 1, defined over finite field</p><formula xml:id="formula_18">F q for s 1. Let {C(i, z) | i ∈ [n], z ∈ Z n</formula><p>s } be the collection of nα symbols of a codeword, where i is the node index and z is the scalar symbol index. The code is defined via the p-c equations given as follows:</p><formula xml:id="formula_19">i∈[n] λ ℓ i,zi C(i; z) = 0, ∀z ∈ Z n s , ℓ ∈ [0, n -k -1],<label>(7)</label></formula><p>where the {λ i,j , i ∈ [n], j ∈ [0, s -1]} are all distinct, thereby requiring a field size q sn. • Node repair. Let f be the failed node, D be the set of d helper nodes. The helper information sent by a node i ∈ D is given by {µ</p><formula xml:id="formula_20">i f (z) = s-1 j=0 C(i, z(f, j)) | z ∈ Z n s , z f = 0}. Next, fixing z i , ∀i ∈ [n]</formula><p>\ {f } and summing equations <ref type="bibr" target="#b6">(7)</ref> over the values of z f , we get</p><formula xml:id="formula_21">s-1 z f =0 λ ℓ f,z f C(f, z) + i∈[n]\{f } λ ℓ i,zi µ i f (z) = 0, ∀ℓ ∈ [0, n -k -1].<label>(8)</label></formula><p>It can be shown that the collection of symbols</p><formula xml:id="formula_22">{µ i f (z)|i ∈ [n] \ {f }} form an [n -1, d] MDS code.</formula><p>Therefore, all the µ i f (z) can be computed from the known d values supplied by the helper nodes and the symbols {C(f, z) | z ∈ Z n s } can thus be recovered from (8). • Data collection. For every z ∈ Z n s , the collection {C(i, z)|i ∈ [n]} forms an (n, k) MDS code. Therefore, any (n -k) erased symbols can be recovered.</p><p>Multiple node repair. Let 1 t n -k be the number of erasures to be recovered. It was shown in <ref type="bibr" target="#b22">[23]</ref> that the minimum repair bandwidth required to repair t erasures in an MDS code having subpacketization level α is lower bounded by γ t t(n-t)α n-k . Given that k d n -t is the number of helper nodes that need to be contacted during the repair of t nodes, γ t is lower bounded by γ t tdα d+t-k . The Ye-Barg code presented above achieves this bound <ref type="bibr" target="#b35">[36]</ref>. The t node repair discussed here assumes a centralized repair setting whereas an alternate, cooperative repair approach is discussed in Subsection 6.1.</p><p>Adaptive repair. Adaptive-repair (n, k) MSR codes are MSR codes that can repair a failed node by connecting to any d nodes, for any d ∈ [k, n -1] and can reconstruct the failed node by downloading α d-k+1 symbols each from the d helper nodes. Constructions of MSR codes with adaptive repair can be found in <ref type="bibr" target="#b31">[32,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b41">42]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">On the S-RB tradeoff under exact repair</head><p>We distinguish between the S-RB tradeoffs for exact and FR RG code, by referring to them as the ER and FR tradeoff respectively. The file size B under exact repair cannot exceed that in the FR case since ER may be regarded as a trivial instance of FR. However, unlike in the case of FR codes, the data collection problem in the ER setting, cannot be identified with a multicast problem simply because each replacement node for a failed node acts as a sink for a different set of data. Thus it is not clear that the cut-set bound for FR can be achieved under ER, leaving the door open for an S-RB tradeoff in the case of ER that lies strictly above and to the right of the FR tradeoff in the (α, β)-plane. There do exist constructions of ER MBR and MSR codes meeting the cut-set bound with equality, showing that the ER tradeoff coincides with the FR tradeoff at the extreme MSR and MBR points.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">The non-existence of ER codes achieving FR tradeoff</head><p>The first major result on the ER tradeoff was the result in <ref type="bibr" target="#b42">[43]</ref>, showing that apart from the MBR point and a small region adjacent to the MSR point, there do not exist ER codes whose (α, β) values lie on the interior point of the FR tradeoff. We set α MSR = β(d -k + 1) to be the value of α at the MSR point.</p><p>Theorem 1. For any given values of (n, k 3, d), ER codes having parameters (α, β, B) corresponding to an interior point on the FR tradeoff do not exist, except possibly for α in the range</p><formula xml:id="formula_23">α MSR α α MSR 1 + 1 α MSR (α MSR + 1)<label>(9)</label></formula><p>corresponding to a small region in the neighborhood of the MSR point.</p><p>Proof. (Sketch) By restricting attention to any (d + 1) symbols of an RG code having parameter set (n, k, d, (α, β), B) one obtains a second RG code with parameter set ((d + 1), k, d, (α, β), B) in which all the remaining nodes participate in the repair of a failed node. This simplifies the analysis of the repair setting and with this in mind, in the proof, we set n = (d + 1). When the message vector u is picked uniformly at random, we have associated nodal random variables</p><formula xml:id="formula_24">{W i | i ∈ [n]} and repair data variables {S j i | i ∈ [n]</formula><p>\ j}, where S j i denotes the data passed from node i to replacement node j. The repair matrix S (Figure <ref type="figure" target="#fig_9">8</ref>) is an (n × n) matrix whose (i, j)-th entry i = j, is S j i . The diagonal elements of S do not figure in the discussion and maybe set equal to 0. Given subsets</p><formula xml:id="formula_25">H, N ⊂ [n], we set W N = {W i | i ∈ N }, S N H = {S j i | i ∈ H, j ∈ N }. We introduce the index sets X = {1, 2, . . . , m}, Y = [k] \ X and Z = [k + 1, d + 1] for m k.</formula><p>The file size B can be expressed in terms of the joint entropy of the node and repair-data variables (with logs computed to base q)</p><formula xml:id="formula_26">B = H(W X , W Y ) = H(W X , S Y Y ∪Z ) (10) = H(W X ) + H(S Y Y ∪Z | W X ) H(W X ) + k j=m+1 H S j [m+1,j-1]∪Z | W X (11) mα + k i=m+1 (d -i + 1)β := B m , m = 0, 1, . . . , k.<label>(12)</label></formula><p>The cut-set bound in (1) corresponds to the inequalities: B min m=0,1,...,k B m . For the bound to hold with equality, the joint random variables S Y Y and S Y Z must have maximum entropy. However it can be shown that the entropy of a row in the repair matrix is limited by β if the cut-set bound holds with equality. This leads to a contradiction, concluding the proof. Theorem 1 does not however, rule out the possibility of an ER code having tradeoff approaching the FR tradeoff asymptotically i.e., as the file size B → ∞.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5.2</head><p>The S-RB tradeoff for <ref type="bibr" target="#b3">(4,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b2">3)</ref> It is possible that the entropies of the random variables involved satisfy Shannon inequalities other than the ones we have noted and which shed light on the ER tradeoff. For the particular case (n, k, d) = (4, 3, 3), Tian <ref type="bibr" target="#b43">[44]</ref> was able to identify such an inequality with the help of a modified version of the information theory inequality prover (ITIP) <ref type="bibr" target="#b44">[45,</ref><ref type="bibr" target="#b45">46]</ref>.</p><p>Let ᾱ = α B , β = β B represent the normalization of α and β with respect to file size B. A point (ᾱ, β) is said to be achievable if for any ǫ &gt; 0, there exists an ER-RG code whose (ᾱ 1 , β1 ) is ǫ-close to (ᾱ, β). The normalized tradeoff, i.e., the tradeoff expressed in terms of ᾱ and β allows comparison of codes across file sizes B. In the limit as B → ∞, the S-RB tradeoff becomes a smooth curve. Let C 1 , C 2 be RG codes over F q having respective parameter sets (n, k, d, (α 1 , β 1 ), B 1 ) and (n, k, d, (α 2 , β 2 ), B 2 ). Consider a codeword array c obtained by vertically stacking M 1 codeword arrays of C 1 and M 2 codeword arrays of C 2 . The code C comprising of all such arrays is said to be the spaceshared code of C 1 and C 2 . Then C is also an RG code with parameter set (n, k, d,</p><formula xml:id="formula_27">(M 1 α 1 + M 2 α 2 , M 1 β 1 + M 2 β 2 ), M 1 B 1 + M 2 B 2 ).</formula><p>The notion of space-sharing clearly extends to multiple codes.</p><p>Theorem 2. For (n, k, d) = (4, 3, 3), the achievable region R is given by</p><formula xml:id="formula_28">R = (ᾱ, β) 3 ᾱ 1, 2 ᾱ + β 1, 6 β 1, 4 ᾱ + 3 β 1 .<label>(13)</label></formula><p>Proof. Of the four inequalities listed, the first 3 follow the entropy constraints listed in ( <ref type="formula" target="#formula_26">12</ref>) above. The last inequality 4 ᾱ + 3 β 1 does not follow from ( <ref type="formula" target="#formula_26">12</ref>), and was found in <ref type="bibr" target="#b43">[44]</ref> using an ITIP. It remains to construct a code that operate on points on the (ᾱ, β)-plane, satisfying the inequalities with equality. A <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b2">3]</ref> single parity-check code serves as an MSR code C 1 for (4, 3, 3). A (4, 3, 3) MBR code C 2 can be constructed using the polygonal construction described in Section 3. A hand-crafted code C 3 operating at the interior point of deflection (Figure <ref type="figure" target="#fig_11">9</ref>) is given in <ref type="bibr" target="#b43">[44]</ref>. Every point on the lines determined by equality in ( <ref type="formula" target="#formula_28">13</ref>) is achieved by a code obtained by space-sharing among C 1 , C 2 and C 3 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Layered codes for interior points</head><p>A simple code-construction technique based on the layering of MDS codes turns out to provide codes that perform well with respect to file size in the interior region of the S-RB tradeoff. Let C MDS be an MDS code having parameters [w + γ, w, γ + 1]. Let n be such that w + γ n and L = n w+γ . Let</p><formula xml:id="formula_29">{S i ⊂ [n] | i = 1, 2, . . . , L} denote an ordering of the collection of all possible (w + γ) subsets of [n]. Let u i ∈ F w q , i = 1, 2, .</formula><p>. . , L be L message vectors, not necessarily distinct, and c i be the codeword in C MDS associated with u i . We create an (L × n) array in which we place the symbols of codeword c i in the location specified by subset S i . It turns out that this array represents an array code which possesses the data collection property of an RG code, but not the repair property. By replicating the array a certain number V of times, it turns out that one obtains an RG code with parameters (n, k = n -γ, d = k, B 0 = LV w), operating between the MSR and MBR points. Further details can be found in <ref type="bibr" target="#b46">[47]</ref>. We will refer to this code as the canonical layered code C can (Figure <ref type="figure" target="#fig_16">10</ref>). The canonical layered-code construction has been extended to construct codes with k &lt; d by making use of an outer code designed using linearized polynomials. An alternate generalization of the canonical code to the case of k &lt; d involved adding additional layers consisting of carefully designed parity symbols. Such an approach leads to the improved layered codes in <ref type="bibr" target="#b47">[48]</ref>, that turn out to be optimal for the set of parameters (n, k = 3, d = n -1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">ER tradeoff strictly away from FR tradeoff for all (n, k, d)</head><p>In <ref type="bibr" target="#b48">[49]</ref>, it was shown that the ER tradeoff cannot approach the FR tradeoff even when B → ∞ for any value of (n, k, d). This was established by deriving a positive lower bound 0 &lt; δ &lt; β on the gap between the ER and FR tradeoffs.   Theorem 3. The ER tradeoff between ᾱ and β for any ER RG code, with k 3 is strictly separated from the FR tradeoff, apart from the MSR and MBR endpoints as well as the region surrounding the MSR point appearing in <ref type="bibr" target="#b8">(9)</ref>. The proof the theorem involves identifying contradicting bounds on the entropy of various trapezoidalshaped subsets within the repair matrix. Subsequent papers <ref type="bibr" target="#b49">[50,</ref><ref type="bibr" target="#b50">51]</ref> derive better bounds, thereby improving the gap δ to go beyond β. In <ref type="bibr" target="#b51">[52]</ref>, the authors adopt a different approach by first providing three different expression for the entropy B of the data file involving mutual information between various repair-data variables, and taking a linear combination of these expressions that leads to a significantly tighter bound on B:</p><formula xml:id="formula_30">B min 0 p k (3k -2p)α + p(2(d-k)+p+1)β 2 + (d -k + 1) min{α, pβ} 3 . (<label>14</label></formula><formula xml:id="formula_31">)</formula><p>The authors in <ref type="bibr" target="#b52">[53]</ref> improve upon the result in ( <ref type="formula" target="#formula_30">14</ref>) using repair-matrix techniques, in combination with the bound in Theorem 3, leading to the best-known outer bound on the ER tradeoff. For the case of (n, k = 3, d = n -1), the outer bound is achieved by the improved layered codes, thus characterizing the ER tradeoff. The bound also characterizes certain interior points when k = 4 <ref type="bibr" target="#b48">[49]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Determinant codes for interior points</head><p>The construction given in <ref type="bibr" target="#b53">[54]</ref> </p><formula xml:id="formula_32">has parameters α = k m , β = k-1 m-1 and file size B = m k+1 m+1</formula><p>, where m ∈ {1, 2, . . . , k} is an auxiliary parameter. The message symbols are first precoded to obtain k k m symbols, and these are then arranged in a data matrix M of size (k × α) in a particular manner. The codeword array is then obtained as in the case of the product matrix framework introduced in <ref type="bibr" target="#b13">[14]</ref>, by setting C n×α = ψ n×k M k×α , where ψ n×k is a Vandermonde matrix. The data collection and repair properties of the code are proved by making use of the Laplace expansion of determinants, and the codes for this reason, are called determinant codes. The codes achieve an outer bound discussed in the next subsection, and thus form an optimal family of codes for parameters (n, k, k). An extension of the construction to include the parameter set (n, k, d = k + 1) can be found in <ref type="bibr" target="#b54">[55]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">ER tradeoff under linear setting</head><p>In <ref type="bibr" target="#b50">[51,</ref><ref type="bibr" target="#b55">56,</ref><ref type="bibr" target="#b56">57]</ref>, the authors characterize the ER tradeoff for (n, k = n -1, d = n -1) for the subclass of linear codes, using an approach that involves lower bounding the rank of the parity-check matrix of an RG code. The upper bound in <ref type="bibr" target="#b55">[56]</ref> holds in general for any (n, k, d = k). </p><formula xml:id="formula_33">MSCR n = d + 2, k = t = 2 [63] MSCR n = 2k, d = n -2, k 2, t = 2 [62] MSCR n = 2k, d = n -t, k 2, k t 2 [62]</formula><p>(Repair of systematic nodes only)</p><formula xml:id="formula_34">MSCR n, k, k d (n -t), t 1 [64]</formula><p>Theorem 4. Consider an ER linear RG code with parameters {(n 4, k, d), (α, β)} and file size</p><formula xml:id="formula_35">B = nα -ρ. Then ρ        2rnα -n(n -1)β r 2 + r , dβ r α dβ r -1 , 2 r n -2, 2α -β, dβ n -1 α dβ n -2 . (<label>15</label></formula><formula xml:id="formula_36">)</formula><p>The corresponding bound on file size B coincides with the achievable region of layered codes when k = d = (n -1). Determinant codes achieve the above bound in general for (n, k, k), thus characterizing the linear ER tradeoff in this case.</p><p>Open problems 4. Characterization of ER tradeoff for general (n, k, d) in both the linear and nonlinear settings.</p><p>6 Variations on the theme of RG codes</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Cooperative repair</head><p>This subsection was contributed at the request of the authors, by Kenneth Shum. The potential benefit of allowing data exchange among the nodes being regenerated while repairing multiple node failures simultaneously, was first investigated by Hu et al. <ref type="bibr" target="#b57">[58]</ref>. The cooperative-repair process consists of two phases. In the first phase, each of the new nodes selects a set of d surviving nodes, and downloads a total of dβ 1 symbols from them. In the second phase, a new node downloads β 2 symbols from each of the other new nodes. If t new nodes are re-built at the same time, the repair bandwidth per new node is dβ 1 + (t -1)β 2 . As in the non-cooperative case, there is a tradeoff between the amount of data stored in a node and the repair bandwidth. In the following, we denote the repair bandwidth per new node by γ. The minimum-storage cooperative regenerating (MSCR) point and minimum-bandwidth cooperative regenerating (MBCR) point are determined in <ref type="bibr" target="#b58">[59,</ref><ref type="bibr" target="#b59">60]</ref>, and are given by</p><formula xml:id="formula_37">(α MSCR , γ MSCR ) = B k , B(d + t -1) k(d + t -k) , (α MBCR , γ MBCR ) = B(2d + t -1) k(2d + t -k) (1, 1),</formula><p>where t is the number of nodes to be repaired simultaneously. When t = 1, they reduce to the corresponding operative points for single-node repair. The full FR tradeoff curve between storage and repair bandwidth per node is derived in <ref type="bibr" target="#b59">[60]</ref>. In the case of exact repair, the explicit construction of cooperative RG codes for all parameters at the minimum-bandwidth point was first presented in <ref type="bibr" target="#b60">[61]</ref>. The construction in <ref type="bibr" target="#b60">[61]</ref> is presented in an alternate way in <ref type="bibr" target="#b61">[62]</ref>. Constructions for minimum-storage cooperative codes are relatively rare (e.g., <ref type="bibr" target="#b61">[62,</ref><ref type="bibr" target="#b62">63]</ref>). Table <ref type="table" target="#tab_2">2</ref> summarizes the existing constructions of MSCR and MBCR codes. We note that the MSCR codes in <ref type="bibr" target="#b61">[62]</ref> share the same encoding method as in <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b19">20]</ref>. It is shown in <ref type="bibr" target="#b61">[62]</ref> that with the MSR codes in <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b19">20]</ref>, we can repair multiple systematic nodes with repair bandwidth achieving the MSCR point. In <ref type="bibr" target="#b63">[64]</ref>, the authors present constructions for any (n, k, k d n -t, t) MSCR codes.</p><p>The cooperative repair model was extended to partial cooperative repair in <ref type="bibr" target="#b64">[65]</ref>. The first phase of repair is the same as described above. Each of the t new nodes contacts d other nodes and download a total of β 1 data packets. In the second phase, a new node exchanges β 2 data packets with t -s other new nodes, where s is a system parameter between 1 and t. When s = t, it is the original single-loss repair model. When s = 1, it reduces to the cooperative repair model. The minimum-storage and minimum bandwidth point are derived in <ref type="bibr" target="#b64">[65]</ref>. With partial collaboration, the minimum-storage and minimum-bandwidth operating points are given respectively by</p><formula xml:id="formula_38">(α, γ) = B k , B(d + t -s) k(d -k + t -s + 1) and (α, γ) = B(2d + t -s) k(2d -k + t -s + 1)</formula><p>(1, 1).</p><p>Two explicit codes for partial collaborative repair are presented in <ref type="bibr" target="#b65">[66]</ref>. The code construction in <ref type="bibr" target="#b61">[62]</ref> for MBCR codes can be extended to achieve all minimum-bandwidth points with partial collaboration. The security of cooperative RG codes is investigated in <ref type="bibr" target="#b66">[67,</ref><ref type="bibr" target="#b67">68]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">MDS codes with repair capability</head><p>We discuss in this subsection, vector MDS codes that are not MSR, which nevertheless offer some savings in repair bandwidth in comparison to the conventional repair of RS codes while keeping the subpacketization level α small. The piggybacking framework introduced in <ref type="bibr" target="#b68">[69]</ref>, was one of the first such efforts. In <ref type="bibr" target="#b69">[70]</ref>, the authors introduce codes that offer a choice of sub-packetization levels, namely, α = r p for 1 p &lt; ⌈ n r ⌉. The corresponding repair download from each helper node is given by β = (1 + 1 p )r p-1 . When p = ⌈ n r ⌉ these codes coincide with the construction in <ref type="bibr" target="#b29">[30]</ref>. A similar approach was followed by the authors of <ref type="bibr" target="#b70">[71]</ref> where they provide constructions for MDS codes for any given 1 α r ⌈ k r ⌉ . However, the constructions here are restricted to systematic node repair and the bandwidth needed from each helper node is not uniform. These constructions are motivated by the systematic MSR code with α = r ⌈ k r ⌉ appearing in <ref type="bibr" target="#b32">[33]</ref>. In more recent work <ref type="bibr" target="#b71">[72]</ref>, the ǫ-MSR framework was introduced to construct MDS codes that somewhat surprisingly, have sub-packetization α that is logarithmic in n for a modest increase in repair bandwidth by a multiplicative factor (1 + ǫ).</p><p>Piggybacking framework. The piggybacking framework <ref type="bibr" target="#b68">[69]</ref> begins with a collection of α codewords drawn form an MDS code and proceeds to modify the code symbols as described below. Let C be an MDS code and let (f 1 (u), f 2 (u), . . . , f n (u)) represent the codeword corresponding to message u. Next, consider codewords of C corresponding to α distinct messages, u 1 , . . . , u α . The α code symbols f j (u i ), i = 1, 2, . . . , α are stored on node j. We first modify the code by adding a function g ij (u 1 , . . . , u i-1 ) to the j-th symbol of i-th codeword f j (u i ), for all i ∈ {2, . . . , α}, j ∈ {1, . . . , n}. The values so added are termed as piggybacks. This modification does not affect our ability to decode the code, if the codewords are decoded in sequence. Applying an invertible linear transform T i to the α code symbols in the i-th node, similarly does not affect our ability to decode the α codewords, nor a node's ability to serve as a helper node. By carefully choosing the piggybacking functions and the set T i of invertible linear transformations it possible to reduce the repair bandwidth for the collective repair of the α MDS codewords in comparison with the repair bandwidth needed for the conventional repair of α MDS codewords. Three families of piggybacking-based MDS codes with reduced repair bandwidth and disk read are constructed in <ref type="bibr" target="#b68">[69]</ref>. The piggybacking framework typically provides savings between 25% to 50% depending up on the parameters and choice of piggybacking functions. For example, Figure <ref type="figure" target="#fig_12">11</ref> shows modification of a [4, 2] MDS code with sub-packetization level 2 in such a way that the systematic nodes can be repaired by reading 3 symbols (instead of the 4 symbols required for MDS decoding), resulting in a 25% repair bandwidth and disk read saving.</p><p>ǫ-MSR framework. The motivation for constructing ǫ-MSR codes <ref type="bibr" target="#b71">[72]</ref> is the larger sub-packetization level of an MSR code, which could possibly prove to be a hurdle in its practical implementation. The authors of <ref type="bibr" target="#b71">[72]</ref> provide a generic way to transform an MSR code into an ǫ-MSR code. Definition 2. An MDS code C with sub-packetization α over a finite field B is said to be an (n, k, d = n -1, α) B ǫ-MSR code, ǫ &gt; 0, if for every i ∈ [n] there exists a linear repair scheme for the code symbol c i which downloads The construction of an ǫ-MSR code presented in <ref type="bibr" target="#b71">[72]</ref> combines a short block-length MSR code with a code having large minimum distance. Let C I be an</p><formula xml:id="formula_39">β ij (1 + ǫ) ℓ n-k symbols over B from the (n -1) nodes storing code symbols c j , for j ∈ [n] \ {i}. a 1 a 2 a 1 +a 2 X b 1 b 1 +b 2 X X X a 1 +2a 2 b 1 b 1 b 2 b 1 +b 2 b 1 +2b 2 +a 1 b 1 b 2 b 1 +b 2 b 1 +2b 2 a 1 a 1 a 2 a 1 +a 2 2a 2 -2b 2 -b 1 a 2 a 1 +a 2 2a 2 -2b 2 -b 1 a 1 a 2 a 1 +a 2 b 2 b 1 +2b 2 +a 1 b 2 b 1 +b 2 b 1 +2b 2 +a 1 2a 2 -2b 2 -b 1</formula><formula xml:id="formula_40">(n = k + r, k, d = n -1, α) B MSR code having parity check matrix H =     H 1,1 H 1,2 . . . H 1,n . . . . . . . . . H r,1 H r,2 . . . H r,n     ,</formula><p>where the sub-matrices H i,j are of size (α × α). Next, let C II be a (not necessarily linear) code having block length N , size M and minimum distance D = δN over an alphabet G of size |G| n. Let us associate with every codeword c = (c 1 , . . . , c N ) of C II , an (rN α × N α) matrix }. An additional requirement is that for a given ǫ &gt; 0, the code C II should be chosen such that the parameter δ satisfies δ 1 -ǫ r-1 . The ǫ-MSR codes constructed using this approach can have sub-packetization level scaling logarithmically in the block length.</p><formula xml:id="formula_41">H c =     u 1,c Diag(H 1,c1 , . . . , H 1,cN ) . . .</formula><p>In <ref type="bibr" target="#b71">[72]</ref>, ǫ-MSR codes are constructed by picking the non-optimal-access MSR constructions as C I . For instance, using </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Fractional repetition codes</head><p>Fractional repetition codes <ref type="bibr" target="#b72">[73]</ref> are regarded as codes that generalize the RBT MBR construction in <ref type="bibr" target="#b12">[13]</ref>. A fractional repetition code is associated with the parameter set {n, k, α, ρ}, where n is the number of nodes and k is the smallest number such that one can retrieve the entire data file from connecting to any set of that many nodes. Let K be the file size of the fractional repetition code. To encode and store data, a fractional repetition code begins by encoding a collection {u 1 , . . . , u K } of message symbols drawn from a finite field F q using a scalar [N, K] MDS code A, also referred to as the DRESS code in <ref type="bibr" target="#b73">[74]</ref>. Let (v 1 , v 2 , . . . , v N ) denote the symbols of a codeword in A. Each of the N scalar code symbols is replicated ρ times and the resultant ρN symbols are stored across the n nodes in such a way that there are α symbols per node and each code symbol is present in precisely ρ distinct nodes. Combinatorial techniques such as t-designs are used to make such an assignment possible. For this to happen, we must have that nα = N ρ. In order to be able to recover the entire data file by connecting to any k nodes we must clearly have that , which conform to the parameters n, α and ρ. Hence a fractional repetition code is said to be k-optimal <ref type="bibr" target="#b74">[75]</ref>, if it satisfies K = C fr (n, k, α, ρ).</p><p>In contrast to an MBR code, a fractional repetition code requires the existence of just a single set of d = α helper nodes to perform RBT. However it follows naturally from the ρ-replication of code symbols that such a set of d helper nodes is available, even in the presence of (ρ -1) node failures.</p><p>Example 2 ( <ref type="bibr" target="#b72">[73]</ref>). Consider a fractional repetition code C with parameters n = 7, k = 3, d = 3, ρ = 3. The code is described using the Fano plane as shown in Figure <ref type="figure" target="#fig_15">12</ref>. Here R C (k) = 6. By choosing the outer MDS code to be the <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b5">6]</ref> single parity check code, data collection property follows. As each symbol is shared by three lines, ρ = 3 and hence C permits RBT up to 2 node failures.</p><p>The following bound on the maximum rate of a fractional repetition code with parameters (n, k, α, ρ), is derived in <ref type="bibr" target="#b72">[73]</ref>.</p><formula xml:id="formula_42">C fr (n, k, α, ρ) min nα ρ 1 - n-ρ k n k , g(n, k, α, ρ) ,</formula><p>where g(n, 1, α, ρ) = 1, and g(n, k + 1, α, ρ) = g(n, k, α, ρ) + α -⌈ ρg(n,k,α,ρ)-kα n-k</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>⌉.</head><p>Ref. <ref type="bibr" target="#b74">[75]</ref> considers fractional repetition codes with parameters α k, β = 1 and provides several k-optimal constructions. Ref. <ref type="bibr" target="#b75">[76]</ref> considers fractional repetition codes with parameter β 1 and also introduces a certain notion of locally recoverable fractional repetition codes where the parameter α &lt; k. In <ref type="bibr" target="#b76">[77]</ref>, the authors study fractional repetition codes that have α much larger than replication degree, ρ. In <ref type="bibr" target="#b77">[78]</ref>, the authors identify necessary and sufficient conditions for the existence of fractional repetition codes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Secure RG codes</head><p>Three secrecy models in the context of an RG code are introduced in <ref type="bibr" target="#b78">[79]</ref>: (a) a passive eavesdropper model, where the eavesdropper can read the contents of any ℓ nodes but cannot modify the content of these nodes, (b) an active omniscient adversary model, where the adversary can read the content of ℓ = k nodes and can also modify the content of b nodes where 2b k, and (c) an active limited-knowledge adversary model, where the adversary can read the content of ℓ &lt; k nodes and can modify the content of b ℓ nodes. In the case of a passive eavesdropper, the secrecy capacity (B s ) is the maximum amount of information that can be stored without any information being revealed to the eavesdropper. In the active eavesdropper model, the resiliency capacity (B r ) is the maximum amount of information that can be stored such that it can be reliably made available to a legitimate data collector, in spite of the tampering on the data in b nodes done by the eavesdropper. In <ref type="bibr" target="#b78">[79]</ref>, the following upper bound on secrecy capacity of the passive eavesdropper model was derived:</p><formula xml:id="formula_43">B s (α, γ = dβ) k i=ℓ+1 min{(d -i + 1)β, α}. (<label>16</label></formula><formula xml:id="formula_44">)</formula><p>If α is not constrained, then the resultant bandwidth-limited secrecy capacity B s,BL becomes a function of (k, d, β) alone. The value of B s,BL is determined <ref type="bibr" target="#b78">[79]</ref> for d = (n -1) by providing a bound and an optimal construction. It was also shown that the resiliency capacity satisfies B r (α, γ) k i=i0 min{(d-i+1)β, α}, where i 0 is equal to 2b + 1 for omniscient case and b + 1 for the limited knowledge case.</p><p>In an alternate setting, Rashmi et al. <ref type="bibr" target="#b79">[80]</ref> assume a noisy channel for transmission of data during repair and reconstruction, and introduce the notion of an (s, t)-resilient RG code that can correct up to t errors and s errors during both repair and reconstruction. The model is aligned with the active eavesdropper model where the eavesdropper can tamper the contents of b nodes. An (s, t)-resilient RG code is shown to satisfy B k i=1 min{(d -i + 1)β, α} where, d = ∆ -2t -s, k = κ -2t -s and ∆, κ are the number of nodes contacted during repair and reconstruction respectively. Constructions of MSR and MBR codes that are (s, t) resilient are also provided in <ref type="bibr" target="#b79">[80]</ref>. In <ref type="bibr" target="#b35">[36]</ref>, the authors extend this model to the repair of multiple nodes and provide MSR constructions that are resilient to t errors during repair. In <ref type="bibr" target="#b80">[81]</ref>, the authors extend the passive eavesdropper model to the setting where out of the ℓ nodes accessed, the eavesdropper can read the contents of ℓ 1 nodes and can observe the information passed on for the repair of ℓ 2 = ℓ -ℓ 1 nodes. The upper bound in ( <ref type="formula" target="#formula_43">16</ref>) also holds for this extended case. In the case of an MBR code, since the amount of data stored equals the amount of data received for node repair, the breakup between ℓ 1 , ℓ 2 is immaterial.</p><p>However in the case of an MSR code, dβ &gt; α. In <ref type="bibr" target="#b80">[81]</ref>, the authors provide explicit, secure MBR, and low-rate MSR code constructions that achieve the upper bound ( <ref type="formula" target="#formula_43">16</ref>) for ℓ 2 = 0. The secure MSR construction from <ref type="bibr" target="#b80">[81]</ref> provides a lower bound to the secure file size of an MSR code</p><formula xml:id="formula_45">B s (k -ℓ)(α -ℓ 2 β) for ℓ 2 &gt; 0.</formula><p>The upper bound on secure MSR file size B s (k -ℓ)α given by ( <ref type="formula" target="#formula_43">16</ref>) is improved in <ref type="bibr" target="#b81">[82]</ref><ref type="bibr" target="#b82">[83]</ref><ref type="bibr" target="#b83">[84]</ref><ref type="bibr" target="#b84">[85]</ref>. In <ref type="bibr" target="#b85">[86]</ref>, Rawat established that the secrecy capacity of an MSR codes is given by</p><formula xml:id="formula_46">B s = (k -ℓ)(1 -1 n-k ) ℓ2</formula><p>α by providing an MSR construction. An upper bound that matches with Rawat's construction is proved by Goparaju et.al <ref type="bibr" target="#b83">[84]</ref> under the constraint of linearity. In <ref type="bibr" target="#b86">[87]</ref>, secure MSR codes with smaller field sizes for all parameters were constructed. In <ref type="bibr" target="#b87">[88,</ref><ref type="bibr" target="#b88">89]</ref>, the ER tradeoff is studied for secure RG codes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Locally recoverable codes</head><p>The earliest-known appearance of LR codes can be found in <ref type="bibr" target="#b89">[90,</ref><ref type="bibr" target="#b90">91]</ref>. A construction for a code with locality appears in <ref type="bibr" target="#b91">[92]</ref>. A formal treatment of codes with locality with a bound on minimum distance (discussed below) appears in <ref type="bibr" target="#b92">[93]</ref>. The extension to the non-linear case for all-symbol (AS) and information-symbol (IS) locality appear in <ref type="bibr" target="#b93">[94,</ref><ref type="bibr" target="#b94">95]</ref>, respectively.</p><p>Let C be an [n, k] linear code over F q . For a subset S ⊆ [n], we use C| S to denote the restriction of C to the coordinates in S. Let G be a (k × n) generator matrix for C having columns</p><formula xml:id="formula_47">{g i } n i=1 , i.e., G = [g 1 , g 2 , . . . , g n ]. An information set E = {e 1 , e 2 , . . . , e k } is any subset of [n] of size k satisfying rk(G| E ) = rk[g e1 , . . . , g e k ] = k. An [n, k] code C is said to have (r, δ)</formula><p>IS locality if there is an information set E = {e 1 , e 2 , . . . , e k } such that for every e i ∈ E, there exists a subset</p><formula xml:id="formula_48">S i ⊆ [n], with e i ∈ S i , dim(C| Si ) r, d min (C| Si ) δ,<label>(17)</label></formula><p>C is said to have (r, δ) AS locality if for every coordinate i ∈ [n], there exists a subset S i ⊆ [n] with i ∈ S i , such that (17) holds. Clearly, a code with AS locality also possesses IS locality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Bound on minimum distance</head><p>A major result in the theory of LR codes is the minimum distance bound derived in <ref type="bibr" target="#b92">[93]</ref>, which in the context of the theorem below, was derived for δ = 2. An analogous proof for δ = 2 and nonlinear codes can be found in <ref type="bibr" target="#b93">[94,</ref><ref type="bibr" target="#b94">95]</ref>. The bound in <ref type="bibr" target="#b92">[93]</ref> was extended adopting the same approach as in <ref type="bibr" target="#b92">[93]</ref>, to the general case δ &gt; 2 in <ref type="bibr" target="#b95">[96]</ref> and appears in Theorem 5 below. The extension to codes over a vector alphabet can be found in <ref type="bibr" target="#b96">[97]</ref>.</p><p>Theorem 5 <ref type="bibr">([96]</ref>). Let C be an [n, k] linear code over F q having (r, δ) IS locality. Then</p><formula xml:id="formula_49">d min (n -k + 1) - k r -1 (δ -1). (<label>18</label></formula><formula xml:id="formula_50">)</formula><p>Our proof will make use of Lemma 1. Proof. Since rk(G| S ) k-1, it follows that there exists a nonzero message vector u such that u T G| S = 0. Let c = u T G, then 0 &lt; wt(c) n -|S| and the result follows.</p><p>Proof. (of Theorem 5) Let E = {e 1 , e 2 , . . . , e k } be the information set with respect to which C has IS locality. Let the subsets S i ⊆ [n], 1 i k, be such that e i ∈ S i , C| Si is an (r, δ) code, i.e., dim(C| Si ) r, d min (C| Si ) δ. Let V i denote the column space of G| Si . Next, over the course of several iterations, we incrementally build up a set S, beginning with S = φ. We use j to indicate the iteration number and begin with j = 1. On the j-th iteration, j 1, we first search for an index i such that V i ⊂ Col(G| S ) (Col(A) refers to the column space of A). This will always be possible, as we always ensure rk(G| S ) k -1. Having found such an index i, we next examine the rk(G| S∪Si ). If rk(G| S∪Si ) k -2, we set</p><formula xml:id="formula_51">a j = |S ∪ S i | -|S|, γ j = rk(G| S∪Si ) -rk(G| S ), S = S ∪ S i , j = j + 1 (<label>19</label></formula><formula xml:id="formula_52">)</formula><p>in order from left to right, and repeat the procedure in (j + 1)-th iteration by searching for an index i such that V i ⊂ Col(G| S ). If at the j-th iteration, for any j, we find that Case (i). rk(G| S∪Si ) = k -1, we then replace the procedure in <ref type="bibr" target="#b18">(19)</ref> with the steps a j = |S ∪ S i | -|S|, γ j = rk(G| S∪Si )rk(G| S ), S = S ∪ S i , m = j, and terminate the program.</p><p>Case (ii). rk(G| S∪Si ) = k. In this case, we replace the procedure in ( <ref type="formula" target="#formula_51">19</ref>) by selecting a subset T i ⊆ S i such that rk(G| S∪Ti ) = k -1 (this can always be done), and then setting a j = |S ∪ T i | -|S|, γ j = rk(G| S∪Ti )rk(G| S ), S = S ∪ T i , m = j, and then terminating the program.</p><p>Thus m indicates the number of iterations that took place before the program was terminated. Note that since for every i, rk(G| Si ) r, we have that γ j r. Let j 1. At the j-th iteration, let i be the index chosen such that V i ⊂ Col(G| S ) and Let R i ⊆ S i \S be such that |R i | = γ j -1 and rk(G| Ri ) = γ j -1. Since the code having generator matrix G| Si has minimum distance δ and since rk(G| (S∩Si)∪Ri ) r-1, by Lemma 1,</p><formula xml:id="formula_53">δ |S i | -|(S ∩ S i ) ∪ R i | = |S i | -|(S ∩ S i )| -|R i | = |S i \ S| -(γ j -1)</formula><p>. It follows from this that a j γ j + (δ -1).</p><p>• Algorithm terminates under Case (i). Since the incremental rank is at most r, it follows that the number of iterations m satisfies m ⌈ k-1 r ⌉. We thus have</p><formula xml:id="formula_54">|S| = m j=1 a j m j=1 (γ j + δ -1) = (k -1) + (δ -1)m (k -1) + k -1 r (δ -1).</formula><p>• Algorithm terminates under Case (ii). Arguing similarly, we have that m ⌈ k r ⌉ and</p><formula xml:id="formula_55">|S| = m j=1 a i m-1 j=1 (γ j + δ -1) + γ m = (k -1) + (δ -1)(m -1) (k -1) + k r -1 (δ -1).</formula><p>Case (ii) leads to a smaller lower bound on |S|. Hence from Lemma 1 it follows that</p><formula xml:id="formula_56">d min (n -k + 1) - k r -1 (δ -1).</formula><p>We note the following:</p><p>(1) Setting δ = 1 (i.e., no locality constraint) in <ref type="bibr" target="#b17">(18)</ref>, one recovers the classical Singleton bound. For this reason, the bound in ( <ref type="formula" target="#formula_49">18</ref>) is commonly referred to in the context of locality as the Singleton bound.</p><p>(2) The pyramid-code construction in Subsection 7.2.1 provides a general construction of codes with IS locality that achieves the Singleton bound for all parameters (n, k, r, δ).</p><p>(3) For many parameter sets, one can construct codes with AS locality that achieve the bound in <ref type="bibr" target="#b17">(18)</ref>, include all cases where (r + 1)|n, see Subsection 7.2.2 below.</p><p>(4) For δ = 2, bounds for AS locality that are tighter than the Singleton bound for IS locality appearing in <ref type="bibr" target="#b17">(18)</ref>, can be found in <ref type="bibr" target="#b97">[98]</ref><ref type="bibr" target="#b98">[99]</ref><ref type="bibr" target="#b99">[100]</ref><ref type="bibr" target="#b100">[101]</ref>. Constructions for codes achieving the tightened bound in <ref type="bibr" target="#b98">[99]</ref> for the case of n 1 &gt; n 2 where n 1 = ⌈ n r+1 ⌉, n 2 = n 1 (r + 1) -n and having exponential field size can also be found there.</p><p>(5) It is shown in <ref type="bibr" target="#b101">[102]</ref> that one can construct codes with AS locality and field size of order n whose minimum distance is within 1 of the bound in (18) provided r ∤ k, n = 1 (mod r + 1). In <ref type="bibr" target="#b102">[103]</ref>, it is shown that this can be achieved for any parameter set if one permits the field size to be exponential in n.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Constructions</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.1">Pyramid code construction</head><p>The pyramid code construction technique which appeared in <ref type="bibr" target="#b90">[91]</ref>, allows us to construct for any given parameter set {n, k, r, δ} a code with (r, δ) IS locality achieving the d min bound in <ref type="bibr" target="#b17">(18)</ref>. We sketch the construction for the case k = 2r. The general case k = ar, a &gt; 2 or even when r ∤ k, follows along similar lines. The construction begins with the systematic generator matrix G MDS of an [n 1 , k] scalar MDS code C MDS having block length n 1 = n -(δ -1). It then reorganizes the sub-matrices of G MDS to create the generator matrix G PYR of the pyramid code: </p><formula xml:id="formula_57">G MDS =    I r P 1 Q 1 I r P 2 (r×(δ-1)) Q 2 (r×s)    ⇒ G PYR = I r P 1 Q 1 I r P 2 Q 2 , where s = n 1 -2r -(δ -<label>1</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.2">The Tamo-Barg construction</head><p>The construction below by Tamo and Barg <ref type="bibr" target="#b101">[102]</ref>, provides a construction for LR codes with AS locality.</p><p>While for simplicity, we present the construction for the case δ = 2, the construction has a natural extension to the general case δ &gt; 2 <ref type="bibr" target="#b101">[102]</ref>. We will refer to the construction in the sequel as the Tamo-Barg (T-B) construction. Theorem 6. Let F q be a finite field of size q, let r 2, n = m(r+1) q, with m 2 and 2 k (n-1).</p><formula xml:id="formula_58">Set k = ar + b, 0 b (r -1). Let A = {θ 1 , θ 2 , . . . , θ n } ⊆ F q and A i ⊂ A, 1 i m, |A i | = (r + 1), A i ∩ A j = φ, i = j represent a partitioning A = ∪ m i=1 A i of A. Let g(x)</formula><p>be a 'good' polynomial, by which is meant, a polynomial over F q that is constant on each A i and of degree (r + 1). Let</p><formula xml:id="formula_59">f (x) = a-1 j=0 r-1 i=0 a ij [g(x)] j x i + j=a b-1 i=0 a ij [g(x)] j x i ,<label>(20)</label></formula><p>where the a ij ∈ F q are the message symbols and where the second term is vacuous for b = 0, i.e., when r|k. Consider the code C of block length n and dimension k where the code symbols are obtained through evaluation of the above collection of polynomials at the elements in A. Then C is an (r, δ) AS locality code with δ = 2 and is optimal with respect to the d min bound in <ref type="bibr" target="#b17">(18)</ref>. The i-th local code has support set A i .</p><p>Proof. In <ref type="bibr" target="#b19">(20)</ref>, it can be checked that by varying {a ij }, one obtains a collection of k linearly independent polynomials and since k &lt; n, it follows that the code has dimension k. Let g(θ) = γ ℓ , all θ ∈ A ℓ . Next, let θ ∈ A ℓ . Then we have which is a polynomial of degree (r -1), see Figure <ref type="figure" target="#fig_18">13</ref>, and hence the corresponding evaluation code, when restricted to A i has d min 2, leading to the desired locality and ability to recover from a single erasure. To determine d min , assume b 1. The maximum degree of a polynomial f (x) then equals</p><formula xml:id="formula_60">f (x)| θ∈A ℓ = a-1 j=0 r-1 i=0 a ij [γ ℓ ] j x i + j=a b-1 i=0 a ij [γ ℓ ] j x i ,</formula><formula xml:id="formula_61">a(r + 1) + b -1 = (ar + b) + (a -1) = k + k r -2.</formula><p>When b = 0 and hence k = ar, the maximum degree equals</p><formula xml:id="formula_62">(a -1)(r + 1) + (r -1) = (ar) + (a -2) = k + k r -2.</formula><p>It follows that the code is optimal as d min (n -k + 1) -(⌈ k r ⌉ -1). An example of how good polynomials may be constructed is given below, corresponding to the annihilator polynomial of a multiplicative subgroup G of F * q . Example 3. Let H &lt; G F * q be a chain of cyclic subgroups, where |H| = (r + 1), |G| = n so that (r + 1)|n|(q -1). Let n = (r + 1)t. Let {A i = γ i H | i ∈ {1, 2, . . . , t}} be the t multiplicative cosets of H in G, with γ 1 being the multiplicative identity so that A 1 = H. It follows that β∈Ai (x -β) = x r+1 -γ r+1 i , so that x r+1 is constant on all the cosets of H in G and may be selected as the good polynomial g(x) i.e., g(x) = x r+1 is one possible choice of good polynomial based on multiplicative group H.</p><p>Further examples may be found in <ref type="bibr" target="#b101">[102,</ref><ref type="bibr" target="#b103">104,</ref><ref type="bibr" target="#b104">105]</ref>. For constructions meeting the Singleton bound with field size of O(n) and more flexible value of r <ref type="bibr" target="#b105">[106]</ref>. Construction of LR codes meeting the Singleton bound with O(n) field size can also be found in <ref type="bibr" target="#b106">[107]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Alphabet-size dependent bounds on code rate</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.1">General bound</head><p>The bound in Theorem 5 as well as the bounds for non-linear and vector codes derived in <ref type="bibr" target="#b93">[94,</ref><ref type="bibr" target="#b96">97]</ref> hold regardless of the size q of the underlying finite field. The theorem below takes the size q of the code symbol alphabet into account and provides a tighter upper bound on the dimension of a code with locality that is valid even for nonlinear codes. The 'dimension' of a nonlinear code C over an alphabet Q of size q = |Q| is defined to be the quantity k = log q (|C|).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 7 ([108]</head><p>). For any (n, k, d) code C that is an LR code with parameter r over an alphabet Q of size q = |Q|,</p><formula xml:id="formula_63">k min t∈Z+ tr + k (q) opt (n -t(r + 1), d) ,<label>(21)</label></formula><p>where k (q) opt (n-t(r+1), d) is the largest possible dimension of a code over Q having block length (n-t(r+1)) and minimum distance d.  Proof. (Sketch of proof) The bound holds for linear as well as nonlinear codes. In the linear case, with Q = F q , the derivation proceeds as follows. Let G be a (k × n) generator matrix of the LR code C. Then it can be shown that for any integer t &gt; 0, there exists an index set I such that |I| = min(t(r + 1), n) and rank(G| I ) = s tr. This implies that C has a generator matrix of the form (after permutation of columns):</p><formula xml:id="formula_64">G =    A (s×|I|) B [0] D   .</formula><p>In turn, this implies that the rowspace of D defines an [n -t(r + 1), k -s k -tr, d] code over F q , if k -tr &gt; 0. It follows that k tr + k (q) opt (n -t(r + 1), d) and the result follows. Note that the row space of D corresponds to a shortening C S of C with respect to the coordinates I ⊆ [n]. The proof in the general case is a (nontrivial) extension to the nonlinear setting. Remark 6. The above bound was obtained by showing that shortening of an [n, k, d] LR code with parameter r, leads to an [n -t(r + 1), k -tr, d] code. Classical bounds on coding theory can be applied to this shortened code, to yield "lifted" bounds on the parent code having locality. This shortening approach, presented for the first time in <ref type="bibr" target="#b107">[108]</ref>, has since been employed in subsequent papers in <ref type="bibr" target="#b108">[109,</ref><ref type="bibr" target="#b109">110]</ref>.</p><p>An alphabet-size-dependent bound on d min (based on the shortening approach in <ref type="bibr" target="#b107">[108]</ref>), and which uses upper bounds on generalized Hamming weights (GHW) <ref type="bibr" target="#b110">[111]</ref> of the dual code derived in <ref type="bibr" target="#b97">[98]</ref>, appears in <ref type="bibr" target="#b109">[110]</ref>. The approach in <ref type="bibr" target="#b109">[110]</ref> can also be used to derive the following upper bound on dimension which is in general tighter than <ref type="bibr" target="#b20">(21)</ref> k min {i:ei&lt;n-d+1}</p><formula xml:id="formula_65">e i -i + k (q) opt (n -e i , d) . (<label>22</label></formula><formula xml:id="formula_66">)</formula><p>The integers {e i } i appearing here can be recursively computed for a given (n, r), and represent upper bounds on the GHW of the dual code (Subsection 8.2.3). A bound on the dimension of a binary LR code for a given (n, r, d min ) based on the Hamming bound for d min 5 and 2 r n 2 -2 appears in <ref type="bibr" target="#b111">[112]</ref>. This bound is shown to be tighter than <ref type="bibr" target="#b20">(21)</ref> for some cases including 5 d min 8 for n large.</p><p>In <ref type="bibr" target="#b108">[109]</ref>, the authors employ the shortening approach to derive an alphabet-size-dependent bound on the minimum distance and dimension of codes having IS locality. An example comparison of the bounds on dimension for linear LR codes in ( <ref type="formula" target="#formula_63">21</ref>), ( <ref type="formula" target="#formula_65">22</ref>) and the Hamming-bound based bound in <ref type="bibr" target="#b111">[112]</ref> is presented in Table <ref type="table" target="#tab_4">3</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.2">Bounds with disjoint repair groups</head><p>Bounds on the dimension of a binary LR code C for a given n, r, d min under the assumption that the local codes (C| Si ) have pairwise disjoint support appear in <ref type="bibr" target="#b111">[112]</ref><ref type="bibr" target="#b112">[113]</ref><ref type="bibr" target="#b113">[114]</ref>. The bound in <ref type="bibr" target="#b111">[112]</ref> make use of the Hamming bound and is shown to be tighter than <ref type="bibr" target="#b20">(21)</ref> for some cases. A tightening of this bound appears in <ref type="bibr" target="#b112">[113]</ref>. The tightest known bounds for this setting appear in <ref type="bibr" target="#b113">[114]</ref> and are based on linear programming.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.3">Bounds on the dimension of cyclic LR code</head><p>A linear-programming-based upper bound on the dimension of cyclic LR codes appears in <ref type="bibr" target="#b114">[115]</ref>. Other bounds can be found in <ref type="bibr" target="#b115">[116,</ref><ref type="bibr" target="#b116">117]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.4">Asymptotic bounds</head><p>Upper bounds on asymptotic rate R q (r, 1, ∆) (see Subsection 8.2.5 for a definition) for a given fractional minimum distance of a binary LR code appear in <ref type="bibr" target="#b113">[114]</ref>, that represent a slight tightening of the asymptotic version of the bound in <ref type="bibr" target="#b20">(21)</ref>. An achievable asymptotic Gilbert-Varshamov type lower bound for LR code appear in <ref type="bibr" target="#b117">[118]</ref> to be</p><formula xml:id="formula_67">R q (r, 1, ∆) 1 -min 0&lt;s 1 1 r + 1 log q ((1 + (q -1)s) r+1 + (q -1)(1 -s) r+1 ) -∆ log q (s) . (<label>23</label></formula><formula xml:id="formula_68">)</formula><p>Constructions achieving the lower bound ( <ref type="formula" target="#formula_67">23</ref>) can also be found in <ref type="bibr" target="#b107">[108]</ref>. An improved lower bound obtained via a construction that makes use of algebraic-geometric codes based on the Garcia-Stichtenoth curves appear in <ref type="bibr" target="#b118">[119]</ref> </p><formula xml:id="formula_69">R q (r, 1, ∆) r r + 1 1 -∆ - √ q + r q -1 for (r + 1)|( √ q + 1).</formula><p>Constructions based on algebraic geometry and covering a wider range of parameters can be found in <ref type="bibr" target="#b119">[120]</ref>. The algebraic-geometry-based constructions improve upon the GV-type bound in <ref type="bibr" target="#b22">(23)</ref> for some selected range of parameters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Small-alphabet constructions</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4.1">Construction of binary codes</head><p>Constructions for binary codes that achieve the bound on dimension given in <ref type="bibr" target="#b20">(21)</ref> for binary codes, appear in <ref type="bibr" target="#b120">[121]</ref><ref type="bibr" target="#b121">[122]</ref><ref type="bibr" target="#b122">[123]</ref>. While <ref type="bibr" target="#b120">[121,</ref><ref type="bibr" target="#b122">123]</ref> provide constructions for d min = 4 and d min = 6 respectively, the constructions in <ref type="bibr" target="#b121">[122]</ref> handle the case of larger minimum distance but have locality parameter restricted to r ∈ {2, 3}. In <ref type="bibr" target="#b108">[109]</ref>, the authors give optimal binary constructions with information and all symbol locality with d min ∈ {3, 4}. The construction is optimal with respect to a bound similar to <ref type="bibr" target="#b20">(21)</ref> derived in <ref type="bibr" target="#b108">[109]</ref>. Constructions achieving the bound on dimension appearing in <ref type="bibr" target="#b111">[112]</ref> and the further tightened bound for disjoint repair groups given in <ref type="bibr" target="#b112">[113]</ref> for binary codes, appear respectively, in <ref type="bibr" target="#b111">[112,</ref><ref type="bibr" target="#b112">113]</ref>. These constructions are for the case d min = 6. In <ref type="bibr" target="#b122">[123]</ref>, the authors present a characterization of binary LR codes that achieve the Singleton bound <ref type="bibr" target="#b17">(18)</ref>. In <ref type="bibr" target="#b123">[124]</ref>, the authors present constructions of binary codes meeting the Singleton bound. These codes are a subclass of the codes characterized in <ref type="bibr" target="#b122">[123]</ref> for the case d min 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4.2">Constructions with small, non-binary alphabet</head><p>In <ref type="bibr" target="#b124">[125]</ref>, the authors characterize ternary LR codes achieving the Singleton bound <ref type="bibr" target="#b17">(18)</ref>. In <ref type="bibr" target="#b122">[123,</ref><ref type="bibr" target="#b123">124,</ref><ref type="bibr" target="#b125">126]</ref>, the authors provide constructions for codes over a field of size O(r) that achieve the Singleton bound in <ref type="bibr" target="#b17">(18)</ref> for d min 5. Some codes from algebraic geometry achieving the Singleton bound <ref type="bibr" target="#b17">(18)</ref> for restricted parameter sets are presented in <ref type="bibr" target="#b126">[127]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4.3">Construction of cyclic LR codes</head><p>Cyclic LR codes can be constructed by carefully selecting the generator polynomial g(x) of the cyclic code. We illustrate a key idea behind the construction of a cyclic LR code by means of an example.</p><p>Example 4. Let α be a primitive element of F 16 satisfying x 4 + x + 1 = 0. Let C 1 be a cyclic [n = 15, k = 10] code having generator polynomial g 1 (x) = (x + 1)(x 4 + x + 1). Since the consecutive powers {1, α, α 2 } of α are zeros of g 1 (x), it follows that d min (C)</p><p>3 + 1 = 4 by the BCH bound. Suppose we desire to ensure that a code C having generator polynomial g(x) has d min 4 and in addition, is locally recoverable with parameter (r + 1) = 5, then we do the following. Set The unshaded circles along with the shaded circle corresponding to α 0 = 1 indicate the zeros {1, α, α 2 , α 4 , α 8 } of g 1 (x) selected to impart the code with d min 4. The shaded circles indicate the periodic train of zeros {1, α 5 , α 10 } introduced to cause the code to be locally recoverable with parameter (r + 1) = 5. The common element 1 is helpful both to impart increased minimum distance as well as locality. It follows that the symbols {c t |t = 0 (mod 3)} of C form a local code as they satisfy the constraint of an overall parity-check. Since the code C is cyclic the same holds for the code symbols {c t+τ |t = 0 (mod 3)}, for τ = 0, 1, 2. Thus through this selection of generator polynomial g(x), we have obtained a code that has both locality and d min 4. The zeros of g(x) are illustrated in Figure <ref type="figure" target="#fig_19">14</ref>. The code C has parameters [n = 15, k = 8, d min 4] and r = 4. Note that the price we pay for introduction of locality is a loss in code dimension, equal to the degree of the polynomial g2(x) gcd{g1(x),g2(x)} . Thus an efficient code will choose the zeros of g 1 (x), g 2 (x) for maximum overlap.</p><formula xml:id="formula_70">s = n (r+1) = 3. Let g 2 (x) = s-1=2 l=0 (x -α 5l ) and g(x) = lcm{g 1 (x), g 2 (x)} = g 1 (x)g 2 (x)/(x + 1). It follows that</formula><p>The above idea of constructing cyclic LR code was introduced in <ref type="bibr" target="#b115">[116]</ref> and extended in <ref type="bibr" target="#b114">[115,</ref><ref type="bibr" target="#b116">117,</ref><ref type="bibr" target="#b127">128,</ref><ref type="bibr" target="#b128">129]</ref>. In <ref type="bibr" target="#b129">[130]</ref>, the use of locality for reducing the complexity of decoding a cyclic code is explored. The same paper also makes a connection with earlier work <ref type="bibr" target="#b130">[131]</ref> that can be interpreted in terms of locality of a cyclic code. In <ref type="bibr" target="#b115">[116]</ref>, a construction of binary cyclic LR codes for r = 2 an d min ∈ {2, 6, 10} achieving a bound derived within the same paper for binary codes is provided. In <ref type="bibr" target="#b127">[128]</ref>, the authors give constructions of optimal binary, ternary codes meeting the Singleton bound <ref type="bibr" target="#b17">(18)</ref> for d min = 4, r ∈ {1, 3} and d min = 6, r = 2 as well as a construction of a binary code meeting the bound given in <ref type="bibr" target="#b111">[112]</ref> for d min = 6, r = 2 based on concatenating cyclic codes. A discussion on the locality of classical binary cyclic codes as well as of codes derived from them through simple operations such as shortening, can be found in <ref type="bibr" target="#b108">[109,</ref><ref type="bibr" target="#b131">132]</ref>. The principal idea here is that any cyclic code has locality d ⊥ -1 where d ⊥ is the minimum distance of the dual code C ⊥ . In <ref type="bibr" target="#b116">[117]</ref>, the authors construct optimal cyclic codes under the constraint that the local code is either a simplex code or else, a Reed-Muller code. In <ref type="bibr" target="#b114">[115]</ref>, the authors provide a construction of cyclic codes with field size O(n) achieving the Singleton bound <ref type="bibr" target="#b17">(18)</ref> and also study the locality of subfield subcodes as well as their duals, the trace codes. In <ref type="bibr" target="#b128">[129]</ref>, constructions of cyclic LR codes with d min ∈ {3, 4} for any q and flexible n are provided.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.5">Maximal recoverable (MR) codes</head><p>An [n, k] MDS code can recover from any pattern of (n -k) erasures. MR codes <ref type="bibr" target="#b132">[133]</ref> are codes that operate under some pre-specified linearity constraints and which can recover from any pattern of (n -k) erasures that is not precluded by the pre-specified linearity constraints imposed. In the context of locality, these constraints are the ones imposed on the local codes. A different perspective of MR codes based on k-core subsets (defined below) is given in <ref type="bibr" target="#b92">[93]</ref>. Definition 3. Let H 0 be an (ρ × n) matrix over F q whose row space has m = q ρ -1 nonzero vectors with respective support sets A i ⊆ [n], i = 1, 2, . . . , m. We view H 0 as the matrix that imposes locality constraints. Let us define a subset S ⊂ [n] to be a k-core with respect to H 0 if |S| = k and |A i ∩ S c | 1, for all i = 1, 2, . . . , m. Then with respect to H 0 , an MR code is an [n, k, H 0 , q] code C possessing a (k × n) generator matrix G with k n -ρ satisfying the property that H 0 G T = [0] and for any k-core S,</p><formula xml:id="formula_71">rank (G| S ) = k. (<label>24</label></formula><formula xml:id="formula_72">)</formula><p>Remark 7. Let H = [ H0 H1 ] denote the parity-check matrix of the MR code, where H 1 represents the additional parity-checks that need to be imposed to satisfy the requirements of an MR code. It could happen that the elements of H 0 belong to a small base field B and over that field it is not possible to find a matrix H 1 which will result in an MR code. It turns out that in such instances, one can always choose the elements of H 1 to lie in a suitable extension field F q of B, resulting in an MR code over F q .</p><p>Remark 8. The condition in <ref type="bibr" target="#b23">(24)</ref> imposed on the k-core subsets S is equivalent to the following condition. Let B ⊆ [n] be such that |B c ∩ A i | 1, ∀i = 1, 2, . . . , m. Then G| B is a generator matrix of an [n = |B|, k] MDS code. This follows since any k columns of G| B are required to be linearly independent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.5.1">General construction with exponential field size</head><p>The following construction is based on parity check matrix. There is an equivalent construction based on generator matrix which is presented in <ref type="bibr" target="#b92">[93]</ref>. Saying that S is a k-core is equivalent to saying that S is an information set since the k underlying message symbols can be uniquely recovered from the k code symbols {c i |i ∈ S}. From the perspective of the parity check matrix H, S is a k-core if and only if rk (H | S c ) = (n -k). This suggests a construction technique. Setting H = [ H 0</p><p>H 1 ] as earlier, we regard the symbols in the ((n-k-ρ)×n) matrix H 1 as variables. We need to select H 1 such that any (n-k)×(n-k) sub-matrix of H corresponding to the complement S c of a k-core, has nonzero determinant. Let P (H 1 ) be the polynomial in the symbols of H 1 obtained by taking the product of these determinants. Note that the definition of a k-core ensures that each of these determinants are non-zero polynomials. The product polynomial is a polynomial in the entries (variables) of the matrix H 1 and each variable appears with degree at most n-1 n-k-1 . By the combinatorial nullstellensatz <ref type="bibr" target="#b33">[34]</ref>, it follows that there is a field of size q &gt; n-1 n-k-1 such that this product of determinants can be made nonzero. Thus an MR code always exists of field size q &gt; n-1 n-k-1 . The interest is of course, in explicit constructions of MR codes having low field size q. It is also possible to use linearized polynomials to construct MR codes, but while this results in an explicit construction, the field size is still in general, of exponential size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.5.2">Partial MDS codes</head><p>In the literature, the focus motivated by practical considerations, is on the following subclass of MR codes, also sometimes termed as partial MDS (P-MDS) codes <ref type="bibr" target="#b133">[134]</ref>. Definition 4. An (r, δ, s) MR code or P-MDS code is defined as an [n = m(r + δ), k = mr -s] code over F q in which the n code symbols can be arranged as an array of (m × (r + δ)) code symbols in such a way that each row in the array forms an [r + δ, r, δ + 1] MDS code and upon puncturing any δ code symbols from each row of the array, the resulting code becomes an [mr, mr -s] MDS code.</p><p>A tabular listing of some constructions of P-MDS codes <ref type="bibr" target="#b106">[107,</ref><ref type="bibr" target="#b133">[134]</ref><ref type="bibr" target="#b134">[135]</ref><ref type="bibr" target="#b135">[136]</ref><ref type="bibr" target="#b136">[137]</ref><ref type="bibr" target="#b137">[138]</ref><ref type="bibr" target="#b138">[139]</ref><ref type="bibr" target="#b139">[140]</ref><ref type="bibr" target="#b140">[141]</ref> appears in Table <ref type="table" target="#tab_5">4</ref>. In <ref type="bibr" target="#b141">[142]</ref>, the authors characterize the weight enumerators and higher support weights of an (r, 1, s) MR code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">LR codes for multiple erasures</head><p>We begin with an overview of the different classes (Figure <ref type="figure" target="#fig_32">15</ref>) of LR codes that are capable of recovering from multiple erasures proposed in the literature. All the codes defined in this section are over the finite field F q .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Various classes of multiple-erasure LR codes</head><p>• Sequential-recovery LR codes. An (n, k, r, t) sequential-recovery LR code (abbreviated as S-LR code) is an [n, k] linear code C having the following property. Given a collection of s t erased code symbols, there is an ordering (c i1 , c i2 , . . . , c is ) of these s erased symbols such that for each index i j , there exists a subset S j ⊆ [n] satisfying </p><p>(r, δ, s) (q ′ ) mr where q ′ is a prime power r + δ.</p><p>[136] (r, δ, s) max((q ′ ) δ+s m s-1 , (q ′ ) s(δ+s) ) with q ′ a prime power r + δ.</p><formula xml:id="formula_74">δ = 1 [134] (r, 1, s) O(2 n ) [137] (r, 1, s) O(m ⌈(s-1)(1-1 2 r )⌉ ) or n m+s 2</formula><p>for m + s even and 2n</p><p>m+s-1 2 for m + s odd, when r + 1 and m are powers of 2. <ref type="bibr" target="#b137">[138]</ref> (r, 1, s) (q ′ ) ⌊(1-1 m )s⌋+m-1 (q ′ is prime power n) and for some special case, the field size of their construction is (q ′ ) ⌊(1-1 m )s⌋+m-2 . For m = 2, 4|s, (q ′ ) s 2 where q ′ n is a power of 2.</p><p>[136] (r, 1, s) 2 ℓ (1+(s-1)⌈log 2 ℓ (m)⌉) where ℓ = ⌈ s+1 2 ⌉⌈log 2 (r + δ)⌉. s = 1 <ref type="bibr" target="#b133">[134]</ref> (r, δ, 1) O(max(m, r + δ))</p><p>[139] (r, δ, 1)</p><formula xml:id="formula_75">O(r + δ) s = 2 [140] (r, 1, 2) O(n) [141] (r, δ, 2) m((δ + 1)(r -1) + 1) ≈ δ × n<label>[107] (r, δ, 2) O(n) s = 3 [137] (r, 1, 3) O(k 3 2 ) [136] (r, δ, 3) if m</label></formula><formula xml:id="formula_76">&lt; (r + δ) 3 then O((r + δ) 3(δ+3) ) otherwise O((r + δ) δ+3 m 1.5 ) s = 4 [<label>137] (r, 1, 4) O(k 7 3 )</label></formula><p>δ</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Codes with sequential recovery</head><p>Codes with parallel recovery</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Availability codes</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Codes with cooperative recovery</head><p>Codes with hierarchical locality</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Codes with (r, ) locality</head><p>Figure <ref type="figure" target="#fig_32">15</ref> The various code classes corresponding to different approaches to recovery from multiple erasures.</p><formula xml:id="formula_77">(i) |S j | r, (ii) S j ∩ {i j , i j+1 , . . . , i s } = φ,<label>(25)</label></formula><formula xml:id="formula_78">(iii) c ij = ℓ∈Sj u ℓ c ℓ , u ℓ ∈ F q .</formula><p>It follows from the definition that an (n, k, r, t) S-LR code can recover from the erasure of s code symbols c i1 , c i2 , . . . , c is , for 1 s t by using <ref type="bibr" target="#b24">(25)</ref> to recover the symbols c ij , j = 1, 2, . . . , s, in succession.</p><p>• Parallel-recovery LR codes. If in the definition of the S-LR code, we replace the condition (ii) in ( <ref type="formula" target="#formula_77">25</ref>) by the more stringent requirement S j ∩{i 1 , i 2 , . . . , i s } = φ, then the LR code will be referred to as a parallel recovery LR code, abbreviated as P-LR code. Clearly the class of P-LR codes is a subclass of S-LR codes. From a practical perspective, P-LR codes are preferred since as the name suggests, the erased symbols can be recovered in parallel. However, this will in general come at the expense of storage overhead. We note that under parallel recovery, depending upon the specific code, this may require the same helper (i.e., non-erased) code symbol to participate in the repair of more than one erased symbol c ij .</p><p>• Availability codes. An (n, k, r, t) availability LR code, is an LR code having the property that in the event of a single but arbitrary erased symbol c i , there exist t recovery sets {R i j } t j=1 which are pair-wise disjoint and of size |R i j | r with R i j ⊆ [n] -{i} such that for each j, 1 j t, c i can be expressed as</p><formula xml:id="formula_79">c i = ℓ∈R i j a iℓ c ℓ , a iℓ ∈ F q .</formula><p>An (n, k, r, t) availability code is also an (n, k, r, t) P-LR code. This follows because the presence of at most t erasures implies, that there will be at least one recovery set for each erased code symbol all of whose symbols remain unerased. If the t disjoint recovery sets are available only for code symbols corresponding to an information set, the code is said to be an IS availability code as opposed to the AS availability implicit in the previous definition.</p><p>• (r, δ) codes. Recovery from t erasures can also be accomplished by using the codes with (r, δ) locality introduced in Section 7, if one ensures that the code has d min t + 1. However in this case, repair is local only in those cases where the erasure pattern is such that the number of erasures e i within each local code satisfies e i δ -1. Thus one may regard (r, δ) codes as offering probabilistic guarantees of local recovery in the presence of t erasures in exchange for a potential increase in code rate. Of course, one could always employ an (r, δ) locality with each local code being an MDS code and δ t + 1, but this would result in a significant rate penalty.</p><p>• Cooperative recovery codes. A cooperative recovery (n, k, r, t) LR (C-LR) code is an LR code such that if a subset (c i1 , c i2 , . . . , c is ), 1 s t of symbols are erased, then there exists a subset {c j1 , c j2 , . . . , c jr } of r other code symbols (i.e., i a = j b for any a, b) such that for all a ∈ [s], c ia = r b=1 θ a,b c j b , θ a,b ∈ F q . Clearly an (n, k, r, t) C-LR code is also an (n, k, r, t) P-LR code, but the r in the case of a C-LR code will tend to be significantly larger. One may regard C-LR codes as codes that seek to minimize the number of unerased symbols contacted per erased symbol on average, rather than insist that each code symbol be repaired by contacting r other code symbols.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Availability codes</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2.1">Bounds on code rate</head><p>The following upper bound on the rate of an availability code was given in <ref type="bibr" target="#b117">[118]</ref>. <ref type="bibr">Theorem 8 ([118]</ref>). If C is an (n, k, r, t) availability code, then its rate R must satisfy</p><formula xml:id="formula_80">R = k n 1 t j=1 (1 + 1 jr ) .<label>(26)</label></formula><p>The parity check matrix of an availability code can be written in the form</p><formula xml:id="formula_81">H T = [H T a H T b ]</formula><p>where the rows of H a are the distinct parity checks associated with the recovery sets R i j , ∀i ∈ [n], j ∈ [t] and where the matrix H b contains all the remaining parity checks. Clearly the Hamming weight of each row of H a is (r + 1) and the column weight t.</p><p>• Codes with strict availability. Codes with strict availability (SA-LR codes) are simply the subclass of availability codes where each row of H a has weight equal to (r + 1) and each column of H a has weight equal to t. Thus the number m of rows of H a must satisfy m(r + 1) = nt. Further, if the support sets of the rows in H a having a non-zero entry in the i-th column are given respectively by S (i) j , j = 1, 2, . . . , t, then we must have by the disjointness of the recovery sets, that S (i) j ∩ S (i) l = {i}, ∀ 1 j = l t. Each code symbol c i in an SA-LR code is thus protected by a collection of t 'orthogonal' parity checks, each of weight (r + 1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 9 ([110]</head><p>). Let R = k n be the maximum possible rate of an (n, k, r, t) SA-LR code. Then R must satisfy the upper bound</p><formula xml:id="formula_82">R 1 - t r + 1 + t r + 1 1 r+1 j=1 (1 + 1 j(t-1) ) . (<label>27</label></formula><formula xml:id="formula_83">)</formula><p>The above bound <ref type="bibr" target="#b26">(27)</ref>, derived in <ref type="bibr" target="#b109">[110]</ref>, is tighter than (26) as r increases for any fixed t. An upper bound on rate of an (n, k, r = 2, t) SA-LR code over F 2 that for large t, becomes tighter in comparison with the bounds in either <ref type="bibr" target="#b25">(26)</ref> or <ref type="bibr" target="#b26">(27)</ref>, is presented in <ref type="bibr" target="#b142">[143]</ref>. Also contained in <ref type="bibr" target="#b142">[143]</ref>, is an upper bound on the rate of an (n, k, r, 3) SA-LR code over F 2 which is tighter than the bound in either <ref type="bibr" target="#b25">(26)</ref> or <ref type="bibr" target="#b26">(27)</ref> for r &gt; 72 and which makes use of the "transpose"-based rate equation appearing in <ref type="bibr" target="#b109">[110]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2.2">Constructions</head><p>• The product code. Consider the [(r+1) t , r t ] product code in t dimensions. Clearly this is an (n = (r+1) t , k = r t , r, t) availability code, having rate R = ( r r+1 ) t . • The Wang et al. <ref type="bibr" target="#b143">[144]</ref> construction. For any given parameter pair (r, t), Wang et al. <ref type="bibr" target="#b143">[144]</ref> provide a construction for an (n, k, r, t) availability code which is defined through its parity-check matrix. Let S be a set of m = (r + t) elements. Then in the construction, each row of H corresponds to a distinct subset of S of cardinality (t -1) and each column, to a distinct subset of S of cardinality t. We set h ij = 1 if the i-th (t -1)-subset belongs to the j-th t-subset and zero otherwise. Thus H is of size m t-1 × m t . It is easy to verify that each row of H has constant row weight (r + 1) and each column of H has constant weight t. It turns out that the rank of H is given by m-1 t-1 and that H defines an (n, k, r, t) availability code, having parameters n = m t , k = m t -m-1 t-1 and rate R = r r+t . Thus this code provides improved rate in comparison with the product code. Since r+t t &lt; (r + 1) t , the code has smaller block length as well.</p><p>• Direct-sum construction. It is shown in <ref type="bibr" target="#b142">[143]</ref> that the direct sum of m copies of the <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b2">3]</ref> simplex code yields an SA-LR code with parameters (7m, 3m, 2, 3) having maximum possible rate for n = 7m, r = 2, t = 3, q = 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2.3">Bounds on minimum distance</head><p>Let d min (n, k, r, t) be the maximum possible minimum distance of an (n, k, r, t) availability code. In <ref type="bibr" target="#b144">[145]</ref>, the following bound on the minimum distance of an information symbol availability code (and hence applicable to the case of AS availability codes as well) was presented</p><formula xml:id="formula_84">d min (n, k, r, t) n -k + 2 - t(k -1) + 1 t(r -1) + 1 .<label>(28)</label></formula><p>This bound was derived by adopting the approach employed in Gopalan et al. <ref type="bibr" target="#b92">[93]</ref> to bound the minimum distance of an availability code. An improved minimum-distance estimate appears in <ref type="bibr" target="#b117">[118]</ref> </p><formula xml:id="formula_85">d min (n, k, r, t) n - t i=0 k -1 r i .<label>(29)</label></formula><p>• Approach via minimum support weights. The next bound on minimum distance relies upon an easyto-compute sequence that represents upper bounds on the GHW of the dual of an availability code. Let there be b subsets {S 1 , . . . , S b } of [n], each of size at most r + 1. We assume that [n] = ∪ b i=1 S i . Let f i be the minimum size of the union of any i out of the b subsets, i.e., <ref type="bibr" target="#b97">98]</ref> where the {e i } b i=1 are recursively calculated in the reverse direction as follows: set e b = n, and for 2 i b, set</p><formula xml:id="formula_86">f i = min {T :T ⊆[b]:|T |=i} | ∪ j∈T S j |. Then f i e i [</formula><formula xml:id="formula_87">e i-1 = min e i , e i - 2e i i + r + 1 .<label>(30)</label></formula><p>From the definition of e j , it is clear that e j is an upper bound on the j-th minimum support weight or j-th GHW of a code containing b linearly independent codewords with the i-th codeword having support S i , i ∈ [b]. We will refer to the sequence {e i } associated with a given parameter set (n, r, b) as the minimum-support-weight (MSW) sequence associated to (n, r, b). The bound below in <ref type="bibr" target="#b31">(32)</ref> appeared in <ref type="bibr" target="#b109">[110]</ref> and makes use of the fact that shortening of an (n, k, r, t) availability code results in a second availability code with parameters (n -∆ n , k -∆ k , r, t) having the same or larger d min . By applying the bound in <ref type="bibr" target="#b28">(29)</ref> to the shortened code, one often obtains a bound on the original code (i.e., the parent code before shortening) that is significantly tighter. To estimate (∆ n , ∆ k ), the bound makes use of the MSW sequence discussed above.</p><p>Theorem 10 ( <ref type="bibr" target="#b109">[110]</ref>). Let b = ⌈n(1 -ρ(r, t))⌉ and e i be calculated as per <ref type="bibr" target="#b29">(30)</ref>, where</p><formula xml:id="formula_88">ρ(r, t) =                  r r + t , if t ∈ {1, 2}, r 2 (r + 1) 2 , if t = 3, 1 t j=1 (1 + 1 jr ) , if t &gt; 3.<label>(31)</label></formula><p>Then,</p><formula xml:id="formula_89">d min (n, k, r, t) min 1 i b, ei-i&lt;k    n -k -i + 1 - t j=1 k + i -e i -1 r j    . (<label>32</label></formula><formula xml:id="formula_90">)</formula><p>The calculation of ρ(r, t) for t = 1 was not explicitly stated in <ref type="bibr" target="#b109">[110]</ref> but is well known. Also contained in <ref type="bibr" target="#b109">[110]</ref> is an improved upper bound on d min in the case of codes with strict availability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2.4">Alphabet-size dependent bounds on d min</head><p>Let d q min (n, k, r, t) be the maximum possible minimum distance of an (n, k, r, t) availability code over F q . In <ref type="bibr" target="#b108">[109]</ref>, the authors provide a bound on minimum distance of an (n, k, r, t) IS availability code (the bound thus also applies to AS availability codes as well) that depends on the size q of the underlying finite field F q d q min (n, k, r, t) min</p><formula xml:id="formula_91">1 x ⌈ k (r-1)t+1 ⌉, x ∈ Z + , y ∈ [t]</formula><p>x , A(r, x, y) &lt; k d q (n -B(r, x, y), k -A(r, x, y)), <ref type="bibr" target="#b32">(33)</ref> where A(r, x, y) = x j=1 (r -1)y j + x, B(r, x, y) = x j=1 ry j + x and d q (n, k) is the maximum possible minimum distance of a classical (i.e., no locality necessary) [n, k] block code over F q . There is a similar bound on the dimension of an availability code with parameters n, r, t, d min over F q .</p><p>The following bound on the minimum distance of an (n, k, r, t) availability code over F q that is tighter than the bound in <ref type="bibr" target="#b32">(33)</ref> appears in <ref type="bibr" target="#b109">[110]</ref> and is currently the tightest-known bound on d q min (n, k, r, t):</p><formula xml:id="formula_92">d q min (n, k, r, t) min i∈S d q min (n -e i , k + i -e i , r, t),<label>(34)</label></formula><p>where S = {i : e i -i &lt; k, 1 i b} and b = ⌈n(1 -ρ(r, t))⌉ and e i is calculated as per <ref type="bibr" target="#b29">(30)</ref>. This bound is also based on the shortening approach introduced in [108].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2.5">Asymptotic bounds on rate</head><p>Let R q (r, t, ∆) = lim sup n→∞ log q (Aq(n,r,t,⌈∆n⌉)) n</p><p>, where A q (n, r, t, d) is the maximum number of codewords in an availability code with parameters (n, r, t) with minimum distance d over F q . The only known upper bounds on sup q R q (r, t, ∆) are based on converting the minimum distance bounds appearing in <ref type="bibr" target="#b27">(28)</ref>, <ref type="bibr" target="#b28">(29)</ref> and ( <ref type="formula" target="#formula_89">32</ref>) into asymptotic bounds. There are constructions which provide lower bounds on R q (r, t, ∆). A lower bound on sup q R q (r, t, ∆) for any r t is provided in <ref type="bibr" target="#b117">[118]</ref>. For the specific case t = 2, <ref type="bibr" target="#b117">[118]</ref> provides lower bounds on R q (r, 2, ∆):</p><formula xml:id="formula_93">R q (r, 2, ∆) r r + 2 -min 0&lt;s 1 1 r+2 2 log q (g (2)</formula><p>q (s)) -∆ log q (s) valid for any q, (35)</p><formula xml:id="formula_94">g (2) 2 (s) = 1 2 r+2 r+2 i=0 r + 2 i (1 + s) ( r+2 2 )-i(r+2-i) (1 -s) i(r+2-i) valid only for q = 2. (<label>36</label></formula><formula xml:id="formula_95">)</formula><p>The reader is referred to <ref type="bibr" target="#b117">[118]</ref> for an expression for g</p><p>(2)</p><p>q (s) for general q as well as a lower bound on sup q R q (r, t, ∆) for any r t. A further lower bound on R q (r, t, ∆) for the case t = 2 and based on algebraic geometry codes appears in <ref type="bibr" target="#b118">[119]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3">Codes with sequential recovery</head><p>Somewhat surprisingly, the maximum possible rate of an (n, k, r, t) S-LR code has been precisely determined via a tight upper bound and a matching construction. The case t = 2, 3 is respectively settled in <ref type="bibr" target="#b97">[98,</ref><ref type="bibr" target="#b145">146]</ref>, where the authors derive the respective bounds</p><formula xml:id="formula_96">n k + 2k r for t = 2, n k + 2k + ⌈ k r ⌉ r for t = 3,</formula><p>and provide matching constructions in each case. Matching constructions for the t = 2 case can be derived either from complete graphs or Turan graphs <ref type="bibr" target="#b97">[98]</ref>. Interestingly, the construction based on Turan graphs turns out to be optimal with respect to GHW as well. The general t 4 case was settled in <ref type="bibr" target="#b146">[147,</ref><ref type="bibr" target="#b147">148]</ref> and is presented below.</p><p>Theorem 11 <ref type="bibr">([147, 148]</ref>). Let C be an (n, k, r, t) S-LR code over a finite field F q . Let r 3. Then</p><formula xml:id="formula_97">k n          r t 2 r t 2 + 2 t 2 -1 i=0 r i , t even, r s r s + 2 s-1 i=1 r i + 1 , for t odd,<label>(37)</label></formula><p>where s = t+1 2 . Moreover, there exist binary codes (i.e., codes over F q with q = 2) that achieve this bound.</p><p>The rate bound given in <ref type="bibr" target="#b36">(37)</ref> proves a conjecture given in <ref type="bibr" target="#b148">[149]</ref> for maximum achievable rate of an (n, k, r, t) S-LRC. The proof of the bound <ref type="bibr" target="#b36">(37)</ref> given in <ref type="bibr" target="#b146">[147,</ref><ref type="bibr" target="#b147">148]</ref>, shows that a code achieving the above rate bound must have a parity check matrix (upto a permutation of rows and columns) with a specific, sparse, staircase structure. An example of this for the case t = 8 is shown in Figure <ref type="figure" target="#fig_22">16</ref>. Based on this, it can shown that a binary code achieving the rate bound <ref type="bibr" target="#b36">(37)</ref> and hence having parity check matrix of the form as shown in Figure <ref type="figure" target="#fig_22">16</ref>, must be based on a tree-like graph with girth t + 1 with degree r + 1 for most nodes, where each edge of the graph represents a code symbol and each node represents a parity check of the code symbols incident on it. Codes achieving the rate bound <ref type="bibr" target="#b36">(37)</ref> appeared in <ref type="bibr" target="#b146">[147,</ref><ref type="bibr" target="#b147">148,</ref><ref type="bibr" target="#b149">150]</ref> and are based on constructing these tree-like graphs with girth t + 1.</p><p>We note that a construction of codes based on (r + 1)-regular bipartite graphs having girth t + 1 and achieving rate close to <ref type="bibr" target="#b36">(37)</ref> was suggested earlier in <ref type="bibr" target="#b150">[151]</ref>. It was noted that these codes have rate r-1 r+1 . It is not hard to show that these codes have rate equal to r-1 r+1 + 1 n <ref type="bibr" target="#b146">[147]</ref>. For certain n, the resultant codes achieve the rate bound in <ref type="bibr" target="#b36">(37)</ref>. However these values of n correspond to the existence of Moore graphs of degree r + 1, and girth = t + 1 with that number n of edges. For r 2, Moore graphs exist only for t ∈ {2, 3, 4, 5, 7, 11} <ref type="bibr" target="#b151">[152]</ref>.</p><p>In Figure <ref type="figure" target="#fig_23">17</ref>, we compare the tight bound in <ref type="bibr" target="#b36">(37)</ref> on the rate of an S-LR code with the upper bound in <ref type="bibr" target="#b25">(26)</ref>, due to Tamo et al. <ref type="bibr" target="#b117">[118]</ref> on the rate of a code with availability. The plots suggest that codes with sequential recovery offer a significant rate advantage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.4">(r, δ) codes</head><p>The (Singleton) bound on the minimum distance of a code with (r, δ) locality was presented above in <ref type="bibr" target="#b17">(18)</ref>. We collect together in this subsection, other results on this class of codes that have appeared in the literature.  The general form <ref type="bibr" target="#b146">[147,</ref><ref type="bibr" target="#b147">148]</ref> of the parity-check matrix H of a rate-optimal S-LR code for t = 8. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.4.1">Constructions and characterization of distance optimal (r, δ) codes</head><p>We focus here only on optimal constructions having low field size. A detailed investigation of codes which achieve the Singleton bound on minimum distance of a code with (r, δ) locality for all symbols appears in <ref type="bibr" target="#b152">[153]</ref> (see in particular, Figure <ref type="figure" target="#fig_1">2</ref> of <ref type="bibr" target="#b152">[153]</ref> which provides a characterization of the existence of codes achieving the Singleton bound). In <ref type="bibr" target="#b101">[102]</ref>, a construction of codes achieving <ref type="bibr" target="#b17">(18)</ref> with field size O(n) for the case (r + δ -1)|n is provided. A construction of cyclic codes with (r, δ) locality achieving the bound <ref type="bibr" target="#b17">(18)</ref> for (r + δ -1)|n and field size of O(n) appears in <ref type="bibr" target="#b153">[154]</ref>. 8.4.2 (r, δ) codes with small alphabet size • Upper bounds on dimension. Several alphabet-size dependent bounds on dimension for a code with (r, δ) AS locality and given minimum distance d min appear in <ref type="bibr" target="#b113">[114]</ref>. The bounds take on the form</p><formula xml:id="formula_98">k n -d + 1 r + δ -1 + 1 log q (B(r + δ -1, δ)),</formula><p>where B(r + δ -1, δ) is an upper bound on the number of codewords in a code of block length (r + δ -1) and minimum distance δ and is log-convex in the block length. The different bounds are obtained by substituting various bounds for B(r + δ -1, δ). The authors also present bounds for disjoint local codes derived based on association schemes and linear programming which provide the tightest-known bounds in the literature on codes with (r, δ) locality with disjoint local codes.</p><p>• Binary codes with (r, δ) locality. In <ref type="bibr" target="#b154">[155]</ref>, distance-optimal (codes achieving the Singleton bound) binary codes are characterized and the authors of <ref type="bibr" target="#b154">[155]</ref>, prove that there are only 2 classes of binary, distance-optimal codes for δ &gt; 2. They make use of the fact in their proof that since the code is binary and achieves the Singleton bound on minimum distance, the code after shortening a sufficient number of selected symbols must be an [ℓ, 1, ℓ] MDS code for some ℓ &lt; n.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.4.3">Achievability results on asymptotic rate</head><p>In <ref type="bibr" target="#b118">[119]</ref>, the following GV-type bound is derived</p><formula xml:id="formula_99">R q (r, δ, ∆) r r + δ -1 -min 0&lt;s 1 log q (b δ (s)) r + δ -1 -∆ log q (s) ,</formula><p>where ∆ denotes the fractional minimum distance and δ is the parameter associated with (r, δ) locality and where b δ (s) = 1 + (q -1)</p><formula xml:id="formula_100">r+δ-1 w=δ r + δ -1 w s w q w-δ w-δ j=0 w -1 j (-q) -j .</formula><p>A second lower bound, based on a construction appearing in <ref type="bibr" target="#b118">[119]</ref> applies whenever r + δ -1 = √ q and improves upon the above GV-type bound in some parameter range R q (r, δ, ∆) </p><formula xml:id="formula_101">r r+δ-1 (1 -∆ -3 √ q+1 ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.5">Codes with hierarchical locality</head><p>Codes with hierarchical locality are codes proposed in <ref type="bibr" target="#b155">[156]</ref> having multiple tiers of locality. We restrict the discussion for simplicity here to 2 tiers. The motivation here is that in a code with 2-tier locality, the higher probability single-erasure event can be repaired with the help of a short local code, while the lower-probability, multiple-erasure event can be handled by accessing a larger number of symbols from the next level local code, termed here as the 'middle' code. A hierarchical topology of local codes as illustrated by the example shown in Figure <ref type="figure" target="#fig_24">18</ref> is proposed in <ref type="bibr" target="#b155">[156]</ref> and a bound on the minimum distance derived for the general case. The bound for a two-level hierarchy is presented below.</p><p>Theorem 12. Let C be an [n, k, d]-linear code with hierarchical locality with the local and middle codes having dimensions at most r 1 , r 2 respectively, and minimum distances at least δ 1 , δ 2 respectively. Then</p><formula xml:id="formula_102">d n -k + 1 - k r 2 -1 (δ 2 -1) - k r 1 -1 (δ 1 -δ 2 ).<label>(38)</label></formula><p>Optimal constructions are provided in <ref type="bibr" target="#b155">[156,</ref><ref type="bibr" target="#b156">157]</ref>. We note that in the context of a practical distributedstorage system, the authors in <ref type="bibr" target="#b157">[158]</ref> had previously suggested the topology of hierarchical codes and compared hierarchical codes with RS codes in terms of repair-efficiency using real data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.6">LR code with cooperative recovery (C-LR code)</head><p>Let d min (n, k, r, t) be the maximum possible minimum distance of a C-LR code with parameters (n, k, r, t). In <ref type="bibr" target="#b150">[151]</ref>, the authors introduce the notion of cooperative local repair and provide the following bound on minimum distance for both linear as well as non-linear codes</p><formula xml:id="formula_103">d min (n, k, r, t) n -k + 1 -t k -t r .</formula><p>They also give a second bound for r t. The paper also contains the following alphabet-size dependent bound on dimension</p><formula xml:id="formula_104">k min γ min(⌊ n r+t ⌋,⌊ k-1 r ⌋) rγ + log q (A q (n -γ(r + t), d)),</formula><p>where A q (n, d) is the maximum size of a q-ary code of block length n and minimum distance d.</p><p>Open problems 5 (Codes for multiple erasures). (1) For a given (n, k, r, δ), what is the maximum achievable minimum distance of codes having (r, δ) locality for a given constraint on field size?</p><p>(2) For a given (n, k, r), what is the minimum field size over which we can construct a code with locality (δ = 2) meeting the Singleton bound?</p><p>(3) The construction of codes with locality (δ = 2) over a field F q of size q = O(1) for a larger range of (d min , r) (say large d min , r) which are d min optimal over F q .</p><p>(4) The construction of MR codes with smaller field size for a wide range of parameters.</p><p>(5) What is the maximum achievable rate k n for a given (r, t) of codes with availability and C-LR codes?</p><p>(6) For a given (n, k, r, t), what is the maximum achievable minimum distance of an S-LR code, a code with availability, or a C-LR code? (7) Questions 5 and 6 when restricted to a finite field F q .</p><p>(8) All the above questions on minimum distance can be rephrased as a question on maximum achievable dimension for a given (n, d min , r, t) over a finite field F q .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Locally RG codes</head><p>As is clear from the discussion in the preceding sections, while RG codes aim to minimize the repair bandwidth, LR codes focus in keeping the repair degree low. It is natural to ask if it is possible to construct codes that possess both low repair bandwidth and repair degree. The class of LRG codes introduced independently in <ref type="bibr" target="#b82">[83,</ref><ref type="bibr" target="#b158">159]</ref>, answers this question in the affirmative. These codes are perhaps best viewed as codes with locality in which the local codes are RG codes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.1">Locality in vector codes</head><p>We begin by studying the notion of locality in a vector code, i.e., a code over a vector alphabet. Let C be an [[n, K, d min , α]] vector code over the vector alphabet F α q having block length n and minimum Hamming distance d min . Let K be the dimension of the code viewing the code as a vector space over F q . Let C s be the scalar code of length nα obtained from C by replacing each vector symbol by the corresponding α scalar symbols. Let G be a generator matrix for C s , where the first α columns correspond to the first vector code symbol of C and so on. For 1 i n, we use the terminology i-th thick column to denote the set of columns [(i -1)α + 1, iα] of G corresponding to the i-th vector code symbol of C. Clearly, the scalar code C s has dimension K.</p><p>For a subset S ⊆ [n], of indices, let C| S denote the vector code obtained by restricting the code C to the thick columns associated with the indices in S. We similarly define G| S to be the restriction of G to the thick columns associated to S. The definition below is a natural extension of the notion of locality to a code over vector alphabet. Definition 5. For i ∈ [0, n -1] and δ 2, the i-th vector code symbol of C is said to have (r, δ) locality if there exists a set S i ⊆ [n] such that i ∈ S i , |S i | r + δ -1 and d min (C| Si ) δ. The restriction of C to S, i.e., code C| Si will be referred to as the local code associated to S i . Definition 6. A vector code C is said to have (r, δ) IS locality if there exists I ⊆ [n] such that rank(G| I ) = K and the i-th vector code symbol of C has (r, δ) locality for all i ∈ I.</p><p>C is said to have (r, δ) AS locality if I can be set to be [n] in the definition above. If for a code having (r, δ) AS locality, S i = S j or |S i ∩ S j | = 0, for all i = j, then the code is said to have disjoint locality. Definition 7. An [[n, K, d min , α]] vector code C is said to have the uniform rank accumulation (URA) property if there exists a sequence {a i } n i=1 of non-negative integers satisfying (i)</p><formula xml:id="formula_105">a 1 = α, (ii) rank(G| I ) = i j=1 a i , ∀I ⊆ [n] : |I| = i. The integer sequence {a i , i ∈ [n]</formula><p>} is referred to as the rank profile of C. Remark 9. It is shown in <ref type="bibr" target="#b11">[12]</ref> that both MSR and MBR codes possess the URA property. The rank profile in the case of ((n, k, d), (α, β), K) MSR, MBR codes, are respectively given by i=1 . Let {b i } ∞ i=1 be a periodic sequence, where b i = a i for 1 i n ℓ and b n ℓ +j = b j for j 1. Define P (s) s i=1 b i : s 1. For x 1, set P (inv) (x) to be the smallest integer y such that P (y) x, i.e., P (inv) (x) = y.    </p><formula xml:id="formula_106">a i MSR = α, 1 i k, 0, (k + 1) i n, a i MBR = α -(i -1)β, 1 i k,<label>0</label></formula><formula xml:id="formula_107">d min (C) n - K α + 1 - K αr -1 (δ -1).</formula><p>In <ref type="bibr" target="#b158">[159]</ref>, the authors give minimum-distance bounds for general vector codes with locality and a tighter bound for the case when the local codes have the URA property. LRG codes with MSR or MBR AS locality, and IS locality that meet the minimum-distance bound, are provided for various parameters. The field-size requirement here is at least O(n 2 ) for the AS locality code constructions. In <ref type="bibr" target="#b82">[83]</ref>, the authors present an explicit construction of a vector code with MSR AS locality, that requires a field-size that is exponential in n. In <ref type="bibr" target="#b159">[160]</ref>, the authors construct a related family of vector codes with IS locality, where the local codes are vector MDS codes with near-optimal bandwidth and small sub-packetization (α) levels. In <ref type="bibr" target="#b160">[161,</ref><ref type="bibr" target="#b161">162]</ref>, the authors consider vector codes with locality featuring functional repair and achieving a reduction in repair bandwidth by carefully choosing for each failed node, a set of r k helper nodes. In <ref type="bibr" target="#b162">[163]</ref>, the authors provide linear field-size constructions for LRG codes with AS locality, where the local codes are either MSR or MBR.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.2">Codes where local codes are MSR/MBR</head><p>It is possible to construct LRG codes which are minimum-distance optimal where the local codes are MSR or MBR using the T-B construction of optimal scalar LR codes. </p><formula xml:id="formula_108">= 10, δ ′ = N ℓ -K ℓ + 1 = 2, ν = n n ℓ = 3. Take a minimum-distance optimal [νN ℓ = 30, K = 20, 9] scalar T-B code C ′ with (K ℓ = 9, δ ′ = 2) AS locality. Note that each local code of C ′ is a [N ℓ = 10, K ℓ = 9] MDS code.</formula><p>The LRG code with the required parameters is obtained by mapping each such local MDS code to an MBR code, using the polygonal MBR construction. The resultant code (Figure <ref type="figure" target="#fig_16">19</ref>) is shown to be minimum-distance optimal in <ref type="bibr" target="#b158">[159]</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">Repairing RS codes</head><p>The conventional repair of an [n, k] scalar MDS code treats each code symbol as an indivisible unit and leads to a total repair bandwidth of k times the amount of data stored in the failed node, where k is the dimension of the code. Over the past couple of years, new techniques have surfaced that present a different picture for the repair of scalar MDS codes, particularly for RS codes. These techniques realize that the code symbols (say, over F q ) of a scalar MDS code can be viewed as vectors whose entries are over some subfield, B ⊆ F q . For example, consider the <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b7">8]</ref> RS code obtained by evaluating message polynomials of degree 7 over all the elements in F 2 4 . Under the traditional repair, the repair bandwidth will be 8 code symbols over F 2 4 , which is equivalent to 32 bits. As we will shortly see, it is possible to perform single-node repair in this instance, by downloading just 1 bit from each of the fifteen surviving nodes. This results in a repair bandwidth of 15 bits, which is a clear improvement over the 32 bits downloaded under the conventional scheme. This line of work which vectorizes scalar MDS codes and performs repair operations over a suitable subfield B for bandwidth gains, began with the pioneering work of Shanmugam et al. <ref type="bibr" target="#b163">[164]</ref> who showed the existence of an efficient repair scheme for node repair, when k = n -2, that improved up on the traditional repair bandwidth. In a subsequent paper, Guruswami and Wootters <ref type="bibr" target="#b164">[165]</ref> consider generalized Reed-Solomon (GRS) codes and all-node repair. There have been other papers since as well.</p><p>Let t be the degree of the field extension [F q : B]. Clearly, through vector representation over the subfield B of over F, t can be regarded as the sub-packetization level of the MDS code. Traditional RS codes have code lengths typically on the order of |F q | corresponding to a sub-packetization level which is logarithmic in code-length. On the other hand, there are fundamental bounds (Subsection 4.1) that require the sub-packetization to be exponential in code length (for a fixed r) in order to achieve the cut-set bound. This leads to the natural and interesting question: what is the least possible repair bandwidth that can be achieved in a low-sub-packetization-level setting?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.1">Linear repair schemes for scalar MDS codes</head><p>In this subsection, we consider the single-node repair of linear, scalar, MDS codes over F q , where q = p t for p a prime power and t a positive integer. Let B be a subfield of F q of size |B| = p. In this setting, by linear repair scheme, we will mean that all repair operations correspond to linear operations over B. For i ∈ [n], let b i denote the least possible repair bandwidth (measured by the number of B-symbols downloaded) to repair the i-th code symbol. The repair bandwidth b is then defined as: b max i∈[n] b i . In the discussion below, by dimension we will throughout mean dimension as a vector space over B. <ref type="bibr">Theorem 14 ([165]</ref>). Let C be a scalar MDS code. Then a linear repair scheme for C with repair bandwidth b exists iff for each code coordinate i ∈ [n], there exists a subset A i of t codewords in the dual code C ⊥ such that dim( a i , a ∈ A i ) = t and max It is easy to see the 'if' part above. The trace function from F q to B is the B-linear map given by T (γ) = t-1 m=0 γ p m . Given a basis {ρ m } t m=1 for F q over B, it is known <ref type="bibr" target="#b165">[166]</ref> that there always exists a second basis {γ m } t m=1 for F q over B, termed the trace-dual basis of {ρ m }, such that any x ∈ F q can be expressed in the form x = </p><p>The definition of A i implies that dim( a i , a ∈ A i ) = t. Let b ij denote the dimension of the set {a j } a∈Ai and let B ij denote a basis for the vector space spanned by {a j } a∈Ai . Using the B-linearity of the trace function, it suffices to compute the b ij trace values {T (c j x) : x ∈ B ij } which can be used to obtain {T (c j a j ) : a ∈ A i }. Hence by downloading n j=1,j =i b ij symbols over B, one can compute {T (c i a i ) : a ∈ A i } using <ref type="bibr" target="#b38">(39)</ref>. Using the trace-dual basis, c i can be reconstructed from these t traces.</p><p>Next, consider the specific case of an [n, k] GRS code C, whose symbols are n (scaled) evaluations of message polynomials f (x) ∈ F[x] of degree k -1. Let the evaluation points be denoted by the set A = {α j } n j=1 . As the dual of a GRS code is a GRS code, codewords in the dual are scaled evaluations of message polynomials of degree (n -k -1). Thus in the context of a GRS code and ignoring w.o.l.o.g. the scaling coefficients, (39) takes on the form T (f (α i )g(α i )) = -n j=1,j =i T (f (α j )g(α j )), for all g(x) ∈ P i ,</p><p>where f (x) and g(x) are polynomials having degrees at most k -1 and n -k -1, respectively, P i is the set of t message polynomials having degree at most n -k -1 corresponding to the t dual codewords in A i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.2">Guruswami-Wootters GRS repair scheme</head><p>Let k n -p t-1 for a GRS code. Then it is possible repair each code-symbol (say, i-th) by downloading just one symbol over B each from the remaining (n -1) nodes. The scheme is as follows. Consider the set of t polynomials P i = {g i,m (x)} t m=1 and a basis {ρ m } t m=1 , where</p><formula xml:id="formula_111">g i,m (x) = T ρ m (x -α i ) (x -α i ) = t-1 s=0 ρ p s m (x -α i ) p s -1 .</formula><p>Each polynomial g i,m (x) has degree p t-1 -1 n -k -1. Hence the evaluations of this polynomial represent a codeword in C ⊥ . Note that {g i,m (α i ) = ρ m , m ∈ [t]} forms a basis for F over B, i.e., dim F {g i,m (α i ), m ∈ [t]} = t. Also, dim F {g i.m (α j ), m ∈ [t]} = 1 ∀j ∈ [n] \ {i}. . By Theorem 15, the repair scheme discussed above is optimal when A = F q and n -k = p t-1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.3">Other related work</head><p>In <ref type="bibr" target="#b166">[167]</ref>, the authors improve the Guruswami-Wootters approach to a larger class of parameters. In <ref type="bibr" target="#b167">[168]</ref>, the authors provide a family of RS codes that has asymptotically optimal repair bandwidth with respect to the cut-set bound. This result is further developed in <ref type="bibr" target="#b168">[169]</ref> to reduce the sub-packetization levels. In <ref type="bibr" target="#b169">[170]</ref>, the authors present RS codes that meet the MSR point for all parameters k &lt; d &lt; n -1. Bandwidthefficient recovery from multiple erasures in RS codes is addressed in <ref type="bibr" target="#b170">[171]</ref> and is further extended to include general scalar MDS codes in <ref type="bibr" target="#b171">[172]</ref>. In <ref type="bibr" target="#b172">[173]</ref>, the authors present codes that universally achieve the optimal bandwidth points for all parameters h n -k and k d n -h simultaneously (see Table <ref type="table" target="#tab_8">5</ref> for a summary of RS repair schemes appearing in the literature). 11 An information capacity approach</p><p>• Capacity bounds. In <ref type="bibr" target="#b173">[174]</ref>, a generic distributed storage system model is introduced and fundamental limits presented. The notion of information capacity of a distributed system is introduced. Let m denote the source data size in bits. Consider a distributed storage system with N nodes, each storing s bits of data. If ∆ denotes the average time between node failures, the erasure rate ǫ can be defined as ǫ = s ∆ . When a node failure takes place, a repairer carries out node repair in a manner which ensures that the source data can be recovered from the data in the surviving nodes at any point of time. The mean time to data loss (MTTDL) is the average amount of time over which the source data can be recovered. Let γ denote the repair rate, which is the rate at which the repairer reads and writes data. Let σ = γ ǫ denote the repair rate to erasure rate ratio. The information capacity of a distributed storage system is then defined as the largest amount of source data m for which a large MTTDL is possible. In <ref type="bibr" target="#b173">[174]</ref>, it is shown that the information capacity approaches (1 -1 2σ )N s bits as σ and N grow. • Liquid storage. In <ref type="bibr" target="#b174">[175]</ref>, the idea of liquid cloud storage was proposed in which codes of large block length (for example, authors use a code of block length 3010 in one of their simulations) are used to spread data stored pertaining to every object over a large number of nodes. Liquid storage employs a lazy repair strategy where the repair runs slowly in the background. The authors present simulation results that shows that liquid storage gives better MTTDL performance in comparison with systems based on small block length codes. The performance of liquid storage systems is shown to approach the fundamental limits proved in <ref type="bibr" target="#b173">[174]</ref>.</p><p>12 Codes in practice Distributed systems such as Hadoop, Google file system and Windows Azure have evolved to include support for erasure codes within their systems, in order to enjoy the benefits of improved storage efficiency in comparison with triple replication. However, the use of traditional erasure codes results in additional repair traffic resulting in larger repair times. This led to several theoretical code constructions for efficient node repair and these were discussed in the preceding sections of this article. Among the biggest success stories is undoubtedly the adoption of LR codes in the Windows Azure production cluster.</p><p>• LR codes. In <ref type="bibr" target="#b175">[176]</ref>, the authors compare performance-evaluation results of an (n = 16, k = 12, r = 6) LR code with that of an [n = 16, k = 12] RS code in the Azure production cluster and demonstrate the repair savings offered by the LR code. Subsequently, the authors implemented an (n = 18, k = 14, r = 7) LR code in Windows Azure storage and showed that this code has repair degree comparable to that of an <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b5">6]</ref> RS code, but has storage overhead 1.29 versus 1.5 in the case of the RS code. This code has reportedly resulted in the savings of millions of dollars for Microsoft <ref type="bibr" target="#b176">[177]</ref>. The authors of [2] implemented HDFS-Xorbas which uses LR codes in place of RS codes in HDFS-RAID. Xorbas LR code is build on top of an RS code by adding extra local XOR parties. The experimental evaluation of Xorbas was carried out in Amazon EC2 and a cluster in Facebook, in which the repair performance of (n = 16, k = 10, r = 5) LR code was compared against a [14, 10] RS code. A second distributed storage system that has an LR code plug-in <ref type="bibr" target="#b177">[178]</ref> is Ceph.</p><p>• MDS codes with bandwidth savings. The Hitchhiker erasure coded system presented in <ref type="bibr" target="#b178">[179]</ref> is a practical implementation of the piggybacking framework introduced in <ref type="bibr" target="#b68">[69]</ref>. The authors implemented the Hitchhiker in HDFS and evaluated its performance on a data-warehouse cluster at Facebook. The Hitchhiker has now been incorporated into Apache Hadoop. In <ref type="bibr" target="#b179">[180]</ref>, the HDFS implementation of a class of MDS array codes called HashTag codes is discussed. The theoretical framework of HashTag codes was presented in <ref type="bibr" target="#b70">[71]</ref>. These codes allow low sub-packetization levels at the expense of increased repair bandwidth and are designed to efficiently repair systematic nodes.</p><p>• RG codes. The NCCloud <ref type="bibr" target="#b9">[10]</ref> is one of the earliest works that dealt with the practical performance evaluation of RG codes. The NCCloud storage system is build on top of a 2-parity functional MSR code. In <ref type="bibr" target="#b180">[181]</ref>, the performance of the pentagon code (which is a RBT MBR code) and a heptagonlocal code (which is an LRG code) in a Hadoop setting are studied. These two codes possess inherent double replication of code symbols, have storage overhead slightly greater than 2 and their performance is compared against double and triple replication. In <ref type="bibr" target="#b181">[182]</ref>, the authors present an optimal-access version of the PM MSR code, which they refer to as the PM-RBT code. The results of an experimental evaluation of a rate 1 2 PM-RBT code on Amazon EC2 instances is reported. In <ref type="bibr" target="#b182">[183]</ref>, the authors introduced erasure codes termed Beehive that are built on top of MSR codes. These codes repair multiple failures simultaneously and are implemented using the PM MSR in C++ using the Intel storage acceleration library (ISAL). In <ref type="bibr" target="#b183">[184]</ref>, the authors present the evaluation of a high-rate MSR code known as the butterfly code in both Ceph and HDFS. This code is a simplified version of the MSR codes presented in <ref type="bibr" target="#b184">[185]</ref> corresponding to the presence of two parity nodes. This code possesses the optimal-access property except in the case of the repair of a single parity node, and has sub-packetization level α = 2 k-1 . More recently in <ref type="bibr" target="#b185">[186]</ref>, the authors present Clay code that corresponds to the codes in <ref type="bibr" target="#b36">[37]</ref><ref type="bibr" target="#b37">[38]</ref><ref type="bibr" target="#b38">[39]</ref>. The Clay code is implemented over Ceph based on the coupled-layer perspective in <ref type="bibr" target="#b37">[38]</ref> and is evaluated over an Amazon AWS cluster. The Clay code is simultaneously optimal in terms of storage overhead, repair bandwidth, optimal access and sub-packetization level. As a part of this work, vector code support has been added to Ceph and the Clay code is under consideration to become a part of Ceph's master code-base.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 (</head><label>1</label><figDesc>Figure 1 (Color online) An overview of the different classes of codes for distributed storage discussed in this survey article.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 (</head><label>2</label><figDesc>Figure 2 (Color online) An illustration of the data collection and node repair properties of an RG code.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 (</head><label>3</label><figDesc>Figure 3 (Color online) The graph behind the cut-set file size bound.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 (</head><label>4</label><figDesc>Figure 4 (Color online) Storage-repair bandwidth tradeoff. Here, n = 60, k = 51, d = 58, B = 33660.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Remark 1 .</head><label>1</label><figDesc>the smallest permissible value of β is given by β = α d-k+1 . This represents the MSR point and codes achieving (1) with α = B k and β = α d-k+1 are known as MSR codes. At the other end of the tradeoff, we have the MBR code whose associated (α, β) values are given by β = B dk-( k 2 ) , α = dβ. Since an RG code can tolerate (n -k) erasures by the data collection property, it follows that the minimum Hamming weight d min of an RG code must satisfy d min</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Example 1 .</head><label>1</label><figDesc>Consider the parameters n = 5, k = 3, d = 4 and β = 1. Thus B = kdβ -k 2 β = 9. First construct a complete graph with n = 5 vertices and N = 5 2 = 10 edges. The nine message symbols are then encoded using a [10, 9] MDS code to produce ten code-symbols. Each code-symbol is then</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 5 (</head><label>5</label><figDesc>Figure 5 (Color online) An example RBT MBR code for the parameters n = 5, k = 3, d = 4. Here file size is 9.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 6 (</head><label>6</label><figDesc>Figure 6 (Color online) Uncoupled data cube for s = 2, t = 3. The red dots represent plane-index z.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7 (</head><label>7</label><figDesc>Figure 7 (Color online) Paired symbols are shown using yellow rectangles connected by dotted lines. Uncoupled symbols are transformed using PFT to get the coupled symbols in the coupled data cube.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 8 (</head><label>8</label><figDesc>Figure 8 (Color online) The repair matrix.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 9 (</head><label>9</label><figDesc>Figure 9 (Color online) The (4,3,3) normalized tradeoff.Figure 10 (Color online) An (n = 5, k = 4, d = 4) canonical layered code.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 11 (</head><label>11</label><figDesc>Figure 11 (Color online) Here two codewords of a [4,2] MDS code are piggybacked. The first systematic node can be repaired by reading b 2 , b 1 + b 2 and b 1 + 2b 2 + a 1 , whereas the second systematic node repair requires b 1 , b 1 + b 2 and 2a 2 -2b 2b 1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>u</head><label></label><figDesc>r,c Diag(H r,c1 , . . . , H r,cN ) {u i,c } are non-zero coefficients, drawn from B. Next, using the fact that the number of codewords in C II is M , let us form an (rN α × M N α) matrix H with each of the M 'thick' columns H c corresponding to a different codeword c ∈ C II . It can be shown that the code having H as its parity-check matrix is an (M , M -r, d = M -1, N α) B ǫ-MSR code, where ǫ = (r -1)(1 -δ). Ensuring this requires judicious selection of the base MSR code C I as well as the non-zero scalars {u i,c</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>C I with parameters (n = 3, k = 1, d = 2, α = 2 3 = 8) and C II with parameters N = 20, M = 27 and D = 13 over F 3 one can construct a (M = 27, M -r = 25, M -1 = 26, N α = 160) ǫ-MSR code. Note that the MSR code C I with parameters (n = 27, k = 25, d = 26) requires a sub-packetization level of 2 27 , whereas this ǫ-MSR code has sub-packetization level of 160 (≪ 2 27 ) and repair bandwidth is within 1.35 times that of the MSR code.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 12 (</head><label>12</label><figDesc>Figure12(Color online) Each of the seven lines in the Fano plane indicates a node and points within a line denote the code symbols stored in the corresponding node. For instance,N 1 = {c 1 , c 2 , c 3 }. R C (k) min J⊆[n]:|J|=k | ∪ j∈J N j | K, where N j indicates the set of α code symbols stored in j-th node, j ∈ [n]. Note that R C (k) is defined with respect to a given collection {N j } n j=1 . Let C fr (n, k, α, ρ) denote the maximum R C (k)possible across all possibilities of {N j } n j=1 , which conform to the parameters n, α and ρ. Hence a fractional repetition code is said to be k-optimal<ref type="bibr" target="#b74">[75]</ref>, if it satisfies K = C fr (n, k, α, ρ).In contrast to an MBR code, a fractional repetition code requires the existence of just a single set of d = α helper nodes to perform RBT. However it follows naturally from the ρ-replication of code symbols that such a set of d helper nodes is available, even in the presence of (ρ -1) node failures.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Lemma 1 .</head><label>1</label><figDesc>Let C be an [n, k] code and let S ⊆ [n] such that rk(G| S ) k -1. Then d min (C) n -|S|.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head></head><label></label><figDesc>). It is not hard to show that the [n, k] code C PYR generated by G PYR has (r, δ) IS locality and that d min (C PYR ) d min (C MDS ). It follows that d min(C PYR ) d min (C MDS ) = n 1 -k + 1 = (n -k + 1) -(δ -1), and the code C PYR is thus optimal with respect to the d min bound in<ref type="bibr" target="#b17">(18)</ref>.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Figure 13 (</head><label>13</label><figDesc>Figure 13 (Color online) In the T-B construction, code symbols in the local codes of length (r + 1) correspond to the evaluations of polynomials of degree (r -1). Here, r = 2 implying evaluation at 3 points of a linear polynomial.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>Figure 14</head><label>14</label><figDesc>Figure 14 Zeros of the generator polynomial g(x) = g 1 (x)g 2 (x) (x+1) of the cyclic code in Example 4 are identified by circles.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>14 t=0 14 t=0c</head><label>1414</label><figDesc>c t α 5lt = 0, l = 0, 1, 2. Summing over l we obtain2 l=0 t α 5lt = 0 ⇒ t:t=0 (mod 3) c t = 0.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head></head><label></label><figDesc>rate for t=10 for sequential recovery Tamo et al. upper bound on rate for t=10 for availability</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head>Figure 16</head><label>16</label><figDesc>Figure<ref type="bibr" target="#b15">16</ref> The general form<ref type="bibr" target="#b146">[147,</ref><ref type="bibr" target="#b147">148]</ref> of the parity-check matrix H of a rate-optimal S-LR code for t = 8.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head>Figure 17 (</head><label>17</label><figDesc>Figure 17 (Color online) Comparison of rate bounds on codes with sequential recovery (37) and codes with availability (26) for t = 10.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head>Figure 18 (</head><label>18</label><figDesc>Figure 18 (Color online) Illustration of a code with hierarchical locality. Each code symbol is protected by a [4, 3, 2] local code. Each local code is contained in a [12, 8, 3] middle code.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_25"><head>Theorem 13 (</head><label>13</label><figDesc><ref type="bibr" target="#b158">[159]</ref>). Let C be an[[n, K, d  min , α]] code with URA locality, where the local codes have parameter set [[n ℓ , K ℓ , d ℓ , α]]. Then, we have d min (C) n -P (inv) (K) + 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_26"><head>P</head><label></label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_27"><head>Figure 19 (Corollary 1 .</head><label>191</label><figDesc>Figure 19 (Color online) An [[n = 15, K = 20, d min = 5, α = 4]] LRG code C where local codes are MBR codes. Here the local codes are ((n ℓ = 5, r = 3, d = 4), (α = 4, β = 1), K ℓ = 9) MBR codes.Corollary 1. Consider the case of a vector with locality, where the local codes are ((n ℓ , r, d), (α, β), K ℓ ) MSR codes. Using Remark 9 and Theorem 13, it follows that<ref type="bibr" target="#b82">[83,</ref><ref type="bibr" target="#b158">159]</ref> </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_28"><head>Example 5 (</head><label>5</label><figDesc><ref type="bibr" target="#b158">[159]</ref>).An  LRG code C having parameters [[n = 15, K = 20, d min = 5, α = 4]] where the local codes are ((n ℓ = 5, r = 3, d = 4), (α = 4, β = 1), K ℓ = 9) MBR codes, can be constructed as follows. Let N ℓ n ℓ 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_29"><head>Example 6 (</head><label>6</label><figDesc><ref type="bibr" target="#b162">[163]</ref>). From the discussion in Subsection 7.2.2, it can be inferred that each local code in a T-B code is an MDS code. Let (n ℓ -r)|r and n ℓ |n. In order to construct a code with MSR local regeneration, we initially stack α = (n ℓ -r) n ℓ n ℓ -r independent layers of codewords from an [n, k, d TB ] T-B code with (r, δ) AS locality. We then perform the pairwise forward transform (introduced in Subsection 4.2) independently, for each local code. This results in an [[n, K = kα, d min , α]] LRG code C where local codes are ((n ℓ , r, d), (α, β), K ℓ ) MSR codes, with d = n ℓ -1. Let d TB denote the (optimal) minimumdistance of the underlying T-B code. The code will be minimum-distance optimal if d TB 2(n ℓ -r + 1).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_30"><head></head><label></label><figDesc>i∈[n]   j∈[n]\i dim( a j , a ∈ A i )   b.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_31"><head>t m=1 T</head><label>m=1</label><figDesc>(xρ m )γ m . Let A i be as defined in Theorem 14. For a ∈ A i ⊆ C ⊥ and Balaji S B, et al. Sci China Inf Sci October 2018 Vol. 61 100301:37c ∈ C, we have that c i a i = -n j=1,j =i c j a j . HenceT (c i a i ) = -n j=1,j =iT (c j a j ), for a ∈ A i .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_32"><head>Theorem 15 .</head><label>15</label><figDesc>Let C be an [n, k] MDS code over F q . For any linear repair scheme for C over B, the repair bandwidth, b (counted according to the number of symbols from B) satisfiesb (n -1) log |B| n -1 n -k + k-1 |F |</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1</head><label>1</label><figDesc>A list of MSR constructions and the parameters. In the table r = nk, s = dk + 1 and when all node repair is No, the constructions are systematic MSR. By 'non-explicit' field-size, we mean that the order of the size of the field from which coefficients are picked is not given explicitly</figDesc><table><row><cell>MSR code</cell><cell></cell><cell>Parameters</cell><cell cols="2">α</cell><cell></cell><cell>Field size</cell><cell cols="2">All node repair Optimal access</cell><cell>Notes</cell></row><row><cell>Shah et al. [9] Suh et al. [20]</cell><cell cols="4">(n, k, d = n -1 (n, k, d 2k -1) 2k -1) r s (n, k 3, d)</cell><cell></cell><cell>2r 2r</cell><cell></cell><cell>No Yes</cell><cell>Yes No</cell><cell>IA framework IA framework</cell></row><row><cell cols="2">Rashmi et al. [14] Papailiopoulos et al. [22] Tamo et al. [24] Wang et al. [25]</cell><cell>(n (n, k, d = n -1) 2k -1, k, d) (n, k, d = n -1)</cell><cell cols="5">r r k r k+1 4 when r n non-explicit else non-explicit 3,</cell><cell>Yes No Yes</cell><cell>No No Yes</cell><cell>Product matrix framework High rate systematic MSR High rate MSR known as Zigzag codes</cell></row><row><cell>Cadambe et al. [26] Sasidharan et al. [30]</cell><cell>(n</cell><cell cols="5">3k 2 , k, d = n -1) O(k 2 ) non-explicit (n, k, d = n -1) r ⌈ n r ⌉ O(n r )</cell><cell></cell><cell>No Yes</cell><cell>Yes Yes</cell><cell>Introduced parity-check viewpoint, optimal α</cell></row><row><cell>Goparaju et al. [32]</cell><cell></cell><cell>(n, k, d)</cell><cell>s k</cell><cell cols="2">r s</cell><cell>-</cell><cell></cell><cell>No</cell><cell>Yes</cell><cell>Very large field-size needed</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>See Sec. IV in [32] for details</cell></row><row><cell>Rawat et al. [31] Ye et al. [36]</cell><cell></cell><cell>(n, k, d) (n, k, d)</cell><cell cols="2">s ⌈ n s s n</cell><cell>⌉</cell><cell>O(n r ) sn</cell><cell></cell><cell>Yes Yes</cell><cell>Yes No</cell><cell>Extended [30] for d &lt; n -1</cell></row><row><cell></cell><cell></cell><cell>(n, k, d)</cell><cell cols="3">s n-1</cell><cell>n + 1</cell><cell></cell><cell>Yes</cell><cell>Yes</cell></row><row><cell>Ye et al. [37]</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Sasidharan et al. [38]</cell><cell></cell><cell>(n, k, d = n -1)</cell><cell cols="2">r ⌈ n r</cell><cell>⌉</cell><cell>r⌈ n r ⌉</cell><cell></cell><cell>Yes</cell><cell>Yes</cell><cell>Optimal α</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2</head><label>2</label><figDesc>Parameters of explicit constructions of cooperative RG codes</figDesc><table><row><cell>Type</cell><cell>Code parameters</cell><cell>Ref.</cell></row><row><cell>MBCR</cell><cell>n, k, k d (n -t), t 1</cell><cell>[61]</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3</head><label>3</label><figDesc>A comparison of upper bounds on the dimension k of binary LR code, for given (n, d min , r, q) n = 31, q = 2, d min = 5</figDesc><table><row><cell>r (locality)</cell><cell>2</cell><cell>3</cell><cell>4</cell><cell>5</cell><cell>6</cell></row><row><cell>Bound (21)</cell><cell>17</cell><cell>19</cell><cell>20</cell><cell>20</cell><cell>20</cell></row><row><cell>Bound in [112]</cell><cell>15</cell><cell>18</cell><cell>20</cell><cell>22</cell><cell>23</cell></row><row><cell>Bound (22)</cell><cell>16</cell><cell>18</cell><cell>19</cell><cell>20</cell><cell>20</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 4</head><label>4</label><figDesc>Constructions for P-MDS codes</figDesc><table><row><cell>Ref.</cell><cell>Parameters of MR code</cell><cell>Field size</cell></row><row><cell></cell><cell>General r, δ, s</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>An [[n, K, d min , α]] vector code C is said to have URA locality, if the code has either information or AS locality and if in addition, local codes are [[n ℓ , K ℓ , d ℓ , α]] vector codes having the URA property with identical rank profiles. Consider the vector code C having URA locality with parameters as in Definition 8. The rank profile for any given [[n ℓ , K ℓ , d ℓ , α]] local code is denoted by {a i } n ℓ</figDesc><table><row><cell>,</cell><cell>(k + 1) i n.</cell></row><row><cell>Definition 8.</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 5</head><label>5</label><figDesc>A summary of schemes appearing in the literature for the repair of RS codes</figDesc><table><row><cell>Ref.</cell><cell>Bandwidth</cell><cell cols="2">Sub-packetization Cut-set bound achievability</cell><cell>Remarks</cell></row><row><cell>[165] [167] [168] [169] &lt; [170] [171] [171] [172]</cell><cell>n -1 (n -1)t(1 -log n (n -k)) &lt; t(n+1) n-k t(n-1+3(n-k)) n-k ; (n -k) = s m td d-k+1 2(n -1)(2-erasures); 3(n -1)(3-erasures) 2(n -2)(2-erasures); 3(n -3)(3-erasures) h(n -h) -(p -1)(h -1) (h-erasures)</cell><cell>log p n log p n (n -k) n s m+n-1 ≅ n n log p n log p n log p n</cell><cell>No No Asymptotically Asymptotically Yes No No No</cell><cell>Single node repair; (n -k) p t-1 Single node repair; (n -k) p ℓ ; ℓ ∈ [t -1] Single node repair Single node repair Codes exist for any given d ∈ [k, n -1] Distributed repair Centralized repair Centralized repair h √ log n</cell></row><row><cell>[173]</cell><cell>tdh d-k+h</cell><cell>≅ n n</cell><cell>Yes; bound in [23]</cell><cell>Code works simultaneously for any</cell></row></table><note><p><p>given number of failures, h</p>: h ∈ [1, nk] and any d : d ∈ [k, nh]</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements This work was supported in part by National Science Foundation of USA (Grant No. 1421848) and in part by an India-Israel UGC-ISF Joint Research Program Grant.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A solution to the network challenges of data recovery in erasure-coded distributed storage systems: a study on the facebook warehouse cluster</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">V</forename><surname>Rashmi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N B</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th USENIX Workshop on Hot Topics in Storage and File Systems</title>
		<meeting>the 5th USENIX Workshop on Hot Topics in Storage and File Systems<address><addrLine>San Jose</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">XORing elephants</title>
		<author>
			<persName><forename type="first">M</forename><surname>Sathiamoorthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Asteris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Papailiopoulos</surname></persName>
		</author>
		<idno type="DOI">10.14778/2535573.2488339</idno>
	</analytic>
	<monogr>
		<title level="j">Proc VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="325" to="336" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A survey on network codes for distributed storage</title>
		<author>
			<persName><forename type="first">K</forename><surname>Dimakis A G, Ramchandran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y N</forename><surname>Wu</surname></persName>
		</author>
		<idno type="DOI">10.1109/JPROC.2010.2096170</idno>
	</analytic>
	<monogr>
		<title level="j">Proc IEEE</title>
		<imprint>
			<biblScope unit="volume">99</biblScope>
			<biblScope unit="page" from="476" to="489" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">An overview of codes tailor-made for better repairability in networked distributed storage systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Datta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Oggier</surname></persName>
		</author>
		<idno type="DOI">10.1145/2447712.2447735</idno>
	</analytic>
	<monogr>
		<title level="j">SIGACT News</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page">89</biblScope>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Erasure coding for cloud storage systems: a survey</title>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Li</surname></persName>
		</author>
		<idno type="DOI">10.1109/TST.2013.6522585</idno>
	</analytic>
	<monogr>
		<title level="j">Tinshhua Sci Technol</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="259" to="272" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">An overview of coding for distributed storage systems</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Oggier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Network Coding and Subspace Designs</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="363" to="383" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Network coding for distributed storage systems</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Dimakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P B</forename><surname>Godfrey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2010.2054295</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="page" from="4539" to="4551" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Existence and construction of capacity-achieving network codes for distributed storage</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE J Sel Areas Commun</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="277" to="288" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Interference alignment in regenerating codes for distributed storage: necessity and code constructions</title>
		<author>
			<persName><forename type="first">N B</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Rashmi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P V</forename><surname>Kumar</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2011.2178588</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="page" from="2134" to="2158" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">NCCloud: applying network coding for the storage repair in a cloud-of-clouds</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">C</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chen</forename><forename type="middle">H C H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P P C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th USENIX Conference on File and Storage Technologies</title>
		<meeting>the 10th USENIX Conference on File and Storage Technologies<address><addrLine>San Jose</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">On MBR codes with replication</title>
		<author>
			<persName><forename type="first">M</forename><surname>Krishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">V</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Barcelona</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="71" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">On minimizing data-read and download for storage-node recovery</title>
		<author>
			<persName><forename type="first">N</forename><surname>Shah</surname></persName>
		</author>
		<idno type="DOI">10.1109/LCOMM.2013.040213.130006</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Commun Lett</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="964" to="967" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Explicit construction of optimal exact regenerating codes for distributed storage</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">V</forename><surname>Rashmi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N B</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P V</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 47th Annual Allerton Conference on Communication, Control, and Computing</title>
		<meeting>the 47th Annual Allerton Conference on Communication, Control, and Computing<address><addrLine>Monticello</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="1243" to="1249" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Optimal exact-regenerating codes for distributed storage at the MSR and MBR points via a product-matrix construction</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">V</forename><surname>Rashmi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">V</forename><surname>Kumar</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2011.2159049</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="page" from="5227" to="5239" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Novel repair-by-transfer codes and systematic exact-mbr codes with lower complexities and smaller field sizes</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chung</forename><forename type="middle">W</forename></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename></persName>
		</author>
		<idno type="DOI">10.1109/TPDS.2013.2297109</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Parallel Distrib Syst</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="3232" to="3241" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Update-efficient error-correcting product-matrix codes</title>
		<author>
			<persName><forename type="first">Y S</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H T</forename><surname>Pai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Zheng</surname></persName>
		</author>
		<idno type="DOI">10.1109/TCOMM.2015.2424416</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Commun</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="page" from="1925" to="1938" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Asymptotically optimal regenerating codes over any field</title>
		<author>
			<persName><forename type="first">N</forename><surname>Raviv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Aachen</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1416" to="1420" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Bandwidth adaptive &amp; error resilient MBR exact repair regenerating codes</title>
		<author>
			<persName><forename type="first">K</forename><surname>Mahdaviani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Khisti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mohajer</surname></persName>
		</author>
		<idno>ArXiv:1711.02770</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Reducing repair traffic for erasure coding-based storage via interference alignment</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Dimakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Seoul</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="2276" to="2280" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Exact-repair mds code construction using interference alignment</title>
		<author>
			<persName><forename type="first">C</forename><surname>Suh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ramchandran</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2011.2105003</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="page" from="1425" to="1442" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A unified form of exact-MSR codes via product-matrix frameworks</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chung</forename><forename type="middle">W</forename></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="page" from="873" to="886" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Repair optimal erasure codes through Hadamard designs</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Papailiopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Dimakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">R</forename><surname>Cadambe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="page" from="3021" to="3037" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Asymptotic interference alignment for optimal repair of MDS codes in distributed storage</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">R</forename><surname>Cadambe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Jafar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Maleki</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2013.2237752</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="page" from="2974" to="2987" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Zigzag codes: MDS array codes with optimal rebuilding</title>
		<author>
			<persName><forename type="first">I</forename><surname>Tamo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bruck</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2012.2227110</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="page" from="1597" to="1616" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">On codes for optimal rebuilding access</title>
		<author>
			<persName><forename type="first">Z Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Tamo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bruck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 49th Annual Allerton Conference on Communication, Control, and Computing</title>
		<meeting>the 49th Annual Allerton Conference on Communication, Control, and Computing<address><addrLine>Monticello</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="1374" to="1381" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Polynomial length MDS codes with optimal repair in distributed storage</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">R</forename><surname>Cadambe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 45th Asilomar Conference on Signals, Systems and Computers</title>
		<meeting>the 45th Asilomar Conference on Signals, Systems and Computers<address><addrLine>Pacific Grove</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="1850" to="1854" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Long MDS codes for optimal repair bandwidth</title>
		<author>
			<persName><forename type="first">Z Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Tamo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bruck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Cambridge</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="1182" to="1186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Access versus bandwidth in codes for storage</title>
		<author>
			<persName><forename type="first">I</forename><surname>Tamo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bruck</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2014.2305698</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="page" from="2028" to="2037" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">An improved sub-packetization bound for minimum storage regenerating codes</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goparaju</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Tamo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Calderbank</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2014.2309000</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="page" from="2770" to="2779" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A high-rate MSR code with polynomial sub-packetization level</title>
		<author>
			<persName><forename type="first">B</forename><surname>Sasidharan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">V</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Hong Kong</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="2051" to="2055" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Progress on high-rate MSR codes: enabling arbitrary number of helper nodes</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Rawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">O</forename><surname>Koyluoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vishwanath</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Information Theory and Applications Workshop</title>
		<meeting>Information Theory and Applications Workshop<address><addrLine>La Jolla</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Minimum storage regenerating codes for all parameters</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goparaju</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fazeli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vardy</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2017.2690662</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="page" from="6318" to="6328" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">An alternate construction of an access-optimal regenerating code with optimal sub-packetization level</title>
		<author>
			<persName><forename type="first">G K</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Sasidharan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">V</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st National Conference on Communications</title>
		<meeting>the 21st National Conference on Communications<address><addrLine>Mumbai</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Combinatorial nullstellensatz</title>
		<author>
			<persName><forename type="first">N</forename><surname>Alon</surname></persName>
		</author>
		<idno type="DOI">10.1017/S0963548398003411</idno>
	</analytic>
	<monogr>
		<title level="j">Combinator Probab Comp</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="7" to="29" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Constructions of high-rate minimum storage regenerating codes over small fields</title>
		<author>
			<persName><forename type="first">N</forename><surname>Raviv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Silberstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Etzion</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2017.2658660</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="page" from="2015" to="2038" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Explicit constructions of high-rate MDS array codes with optimal repair bandwidth</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Barg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="page" from="2001" to="2014" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Explicit constructions of optimal-access MDS codes with nearly optimal sub-packetization</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Barg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="page" from="6307" to="6317" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">An explicit, coupled-layer construction of a high-rate MSR code with low sub-packetization level, small field size and all-node repair</title>
		<author>
			<persName><forename type="first">B</forename><surname>Sasidharan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vajha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kumar</surname></persName>
		</author>
		<idno>ArXiv:1607.07335</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">A generic transformation for optimal repair bandwidth and rebuilding access in MDS codes</title>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X H</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Tian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Aachen</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1623" to="1627" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">A tight lower bound on the sub-packetization level of optimal-access MSR and MDS codes</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Balaji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">V</forename><surname>Kumar</surname></persName>
		</author>
		<idno>ArXiv:1710.05876</idno>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">Explicit MSR codes with optimal access, optimal sub-packetization and small field size for d = k + 1, k + 2, k + 3</title>
		<author>
			<persName><forename type="first">M</forename><surname>Vajha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Balaji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">V</forename><surname>Kumar</surname></persName>
		</author>
		<idno>ArXiv:1804.00598</idno>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Product matrix MSR codes with bandwidth adaptive exact repair</title>
		<author>
			<persName><forename type="first">K</forename><surname>Mahdaviani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mohajer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Khisti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="page" from="3121" to="3135" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Distributed storage codes with repair-by-transfer and nonachievability of interior points on the storage-bandwidth tradeoff</title>
		<author>
			<persName><forename type="first">N B</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Rashmi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P V</forename><surname>Kumar</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2011.2173792</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="page" from="1837" to="1852" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Characterizing the rate region of the (4,3,3) exact-repair regenerating codes</title>
		<author>
			<persName><forename type="first">C</forename><surname>Tian</surname></persName>
		</author>
		<idno type="DOI">10.1109/JSAC.2014.140516</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE J Sel Areas Commun</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="967" to="975" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title level="m" type="main">Information theory inequality prover</title>
		<ptr target="http://user-www.ie.cuhk.edu.hk/∼ITIP/" />
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">A framework for linear information inequalities</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Yeung</surname></persName>
		</author>
		<idno type="DOI">10.1109/18.641556</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="1924" to="1934" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Layered exact-repair regenerating codes via embedded error correction and block designs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Sasidharan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Aggarwal</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2015.2408595</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="page" from="1933" to="1947" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Improved layered regenerating codes characterizing the exact-repair storagerepair bandwidth tradeoff for certain parameter sets</title>
		<author>
			<persName><forename type="first">K</forename><surname>Senthoor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Sasidharan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Information Theory Workshop</title>
		<meeting>IEEE Information Theory Workshop<address><addrLine>Jerusalem</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">An improved outer bound on the storage repair-bandwidth tradeoff of exactrepair regenerating codes</title>
		<author>
			<persName><forename type="first">B</forename><surname>Sasidharan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Senthoor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">V</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Honolulu</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="2430" to="2434" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<title level="m" type="main">Outer bounds for exact repair codes</title>
		<author>
			<persName><forename type="first">I</forename><surname>Duursma</surname></persName>
		</author>
		<idno>ArXiv:1406.4852</idno>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Shortened regenerating codes</title>
		<author>
			<persName><forename type="first">I</forename><surname>Duursma</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2018.2840995</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory (Early Access)</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">New bounds on the (n, k, d) storage systems with exact repair</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mohajer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tandon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Hong Kong</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015. 2056-2060</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Outer bounds on the storage-repair bandwidth trade-off of exact-repair regenerating codes</title>
		<author>
			<persName><forename type="first">B</forename><surname>Sasidharan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Prakash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M N</forename><surname>Krishnan</surname></persName>
		</author>
		<idno type="DOI">10.1504/IJICOT.2016.079498</idno>
	</analytic>
	<monogr>
		<title level="j">Int J Inf Coding Theory</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="255" to="298" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Determinant coding: a novel framework for exact-repair regenerating codes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Elyasi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mohajer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="page" from="6683" to="6697" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Exact-repair trade-off for (n, k = d -1, d) regenerating codes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Elyasi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mohajer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 55th Annual Allerton Conference on Communication, Control, and Computing</title>
		<meeting>the 55th Annual Allerton Conference on Communication, Control, and Computing<address><addrLine>Monticello</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="934" to="941" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">The storage-repair-bandwidth trade-off of exact repair linear regenerating codes for the case d = k = n -1</title>
		<author>
			<persName><forename type="first">N</forename><surname>Prakash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">N</forename><surname>Krishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Hong Kong</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="859" to="863" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Linear exact repair rate region of (k + 1, k, k) distributed storage systems: a new approach</title>
		<author>
			<persName><forename type="first">M</forename><surname>Elyasi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mohajer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tandon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory (ISIT)</title>
		<meeting>IEEE International Symposium on Information Theory (ISIT)<address><addrLine>Hong Kong</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="2061" to="2065" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Cooperative recovery of distributed storage systems from multiple losses with network coding</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<idno type="DOI">10.1109/JSAC.2010.100216</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE J Sel Areas Commun</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="268" to="276" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Repairing multiple failures with coordinated and adaptive regenerating codes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kermarrec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">L</forename><surname>Scouarnec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Straub</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Symposium on Networking Coding</title>
		<meeting>International Symposium on Networking Coding<address><addrLine>Beijing</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Cooperative regenerating codes</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">W</forename><surname>Shum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Hu</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2013.2274265</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="page" from="7229" to="7258" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Exact cooperative regenerating codes with minimum-repair-bandwidth for distributed storage</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE INFOCOM</title>
		<meeting>IEEE INFOCOM<address><addrLine>Turin</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="400" to="404" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Cooperative repair of multiple node failures in distributed storage systems</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">W</forename><surname>Shum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chen</forename><forename type="middle">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int J Inf Coding Theory</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="299" to="323" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Exact scalar minimum storage coordinated regenerating codes</title>
		<author>
			<persName><forename type="first">N</forename><surname>Scouarnec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Cambridge</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="1197" to="1201" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<monogr>
		<title level="m" type="main">Optimal MDS codes for cooperative repair</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Barg</surname></persName>
		</author>
		<idno>ArXiv:1801.09665</idno>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">On storage codes allowing partially collaborative repairs</title>
		<author>
			<persName><forename type="first">S Q</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">E</forename><surname>Oggier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory Proceedings</title>
		<meeting>IEEE International Symposium on Information Theory Proceedings<address><addrLine>Honolulu</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="2440" to="2444" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Two storage code constructions allowing partially collaborative repairs</title>
		<author>
			<persName><forename type="first">S Q</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">E</forename><surname>Oggier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Symposium on Information Theory and its Applications</title>
		<meeting>International Symposium on Information Theory and its Applications<address><addrLine>Melbourne</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="378" to="382" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Secure cooperative regenerating codes for distributed storage systems</title>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">O</forename><surname>Koyluoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Rawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vishwanath</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2014.2319271</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="page" from="5228" to="5244" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Security concerns in minimum storage cooperative regenerating codes</title>
		<author>
			<persName><forename type="first">K</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Parampalli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Xian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="page" from="6218" to="6232" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">A piggybacking design framework for read-and download-efficient distributed storage codes</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">V</forename><surname>Rashmi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Shah N B, Ramchandran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="page" from="5802" to="5820" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">MDS code constructions with small sub-packetization and near-optimal repair bandwidth</title>
		<author>
			<persName><forename type="first">V</forename><surname>Guruswami</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rawat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th Annual ACM-SIAM Symposium on Discrete Algorithms</title>
		<meeting>the 28th Annual ACM-SIAM Symposium on Discrete Algorithms<address><addrLine>Barcelona</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="2109" to="2122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">General sub-packetized access-optimal regenerating codes</title>
		<author>
			<persName><forename type="first">K</forename><surname>Kralevska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gligoroski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Øverby</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Commun Lett</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="1281" to="1284" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">ǫ-MSR codes with small sub-packetization</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Rawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Tamo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Guruswami</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Aachen</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="2043" to="2047" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Fractional repetition codes for repair in distributed storage systems</title>
		<author>
			<persName><forename type="first">S Y E</forename><surname>Rouayheb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ramchandran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 48th Annual Allerton Conference on Communication, Control, and Computing</title>
		<meeting>the 48th Annual Allerton Conference on Communication, Control, and Computing<address><addrLine>Allerton</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">DRESS codes for the storage cloud: simple randomized constructions</title>
		<author>
			<persName><forename type="first">S</forename><surname>Pawar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Noorshams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S Y E</forename><surname>Rouayheb</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory Proceedings</title>
		<meeting>IEEE International Symposium on Information Theory Proceedings<address><addrLine>St. Petersburg</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="2338" to="2342" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">Optimal fractional repetition codes based on graphs and designs</title>
		<author>
			<persName><forename type="first">N</forename><surname>Silberstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Etzion</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2015.2442231</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="page" from="4164" to="4180" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">Fractional repetition codes with flexible repair from combinatorial designs</title>
		<author>
			<persName><forename type="first">O</forename><surname>Olmez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ramamoorthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="page" from="1565" to="1591" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">Scalable constructions of fractional repetition codes in distributed storage systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Koo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">T</forename><surname>Gill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 49th Annual Allerton Conference on Communication, Control, and Computing</title>
		<meeting>the 49th Annual Allerton Conference on Communication, Control, and Computing<address><addrLine>Monticello</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="1366" to="1373" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<monogr>
		<title level="m" type="main">The existence of fractional repetition codes</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ernvall</surname></persName>
		</author>
		<idno>ArXiv:1201.3547</idno>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">Securing dynamic distributed storage systems against eavesdropping and adversarial attacks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Pawar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S Y E</forename><surname>Rouayheb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ramchandran</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2011.2162191</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="page" from="6734" to="6753" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">Regenerating codes for errors and erasures in distributed storage</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">V</forename><surname>Rashmi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Shah N B, Ramchandran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding of IEEE International Symposium on Information Theory Proceedings</title>
		<meeting>eeding of IEEE International Symposium on Information Theory eedings<address><addrLine>Cambridge</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="1202" to="1206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">Information-theoretically secure erasure codes for distributed storage</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">V</forename><surname>Rashmi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Shah N B, Ramchandran</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2017.2769101</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="page" from="1621" to="1646" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<analytic>
		<title level="a" type="main">Toward optimal secure distributed storage systems with exact repair</title>
		<author>
			<persName><forename type="first">R</forename><surname>Tandon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Amuru</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T C</forename><surname>Clancy</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2016.2544340</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="page" from="3477" to="3492" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b82">
	<analytic>
		<title level="a" type="main">Optimal locally repairable and secure codes for distributed storage systems</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Rawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">O</forename><surname>Koyluoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Silberstein</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2013.2288784</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="page" from="212" to="236" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<analytic>
		<title level="a" type="main">Data secrecy in distributed storage systems under exact repair</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goparaju</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S Y E</forename><surname>Rouayheb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Calderbank</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Symposium on Network Coding</title>
		<meeting>International Symposium on Network Coding<address><addrLine>Calgary</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<analytic>
		<title level="a" type="main">On secrecy capacity of minimum storage regenerating codes</title>
		<author>
			<persName><forename type="first">K</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Parampalli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Xian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="page" from="1510" to="1524" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<analytic>
		<title level="a" type="main">Secrecy capacity of minimum storage regenerating codes</title>
		<author>
			<persName><forename type="first">A</forename><surname>Rawat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Aachen</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1406" to="1410" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b86">
	<analytic>
		<title level="a" type="main">Security for minimum storage regenerating codes and locally repairable codes</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kadhe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sprintson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Aachen</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1028" to="1032" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b87">
	<analytic>
		<title level="a" type="main">The rate region for secure distributed storage systems</title>
		<author>
			<persName><forename type="first">F</forename><surname>Ye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">W</forename><surname>Shum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Yeung</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2017.2740939</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="page" from="7038" to="7051" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b88">
	<analytic>
		<title level="a" type="main">On the tradeoff region of secure exact-repair regenerating codes</title>
		<author>
			<persName><forename type="first">S</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Tian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="page" from="7253" to="7266" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b89">
	<analytic>
		<title level="a" type="main">Reliable memories with subline accesses</title>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Lastras-Montano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Nice</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="2531" to="2535" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b90">
	<analytic>
		<title level="a" type="main">Pyramid codes: flexible schemes to trade space for access efficiency in reliable data storage systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th IEEE International Symposium on Network Computing and Applications</title>
		<meeting>the 6th IEEE International Symposium on Network Computing and Applications<address><addrLine>Cambridge</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="79" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b91">
	<analytic>
		<title level="a" type="main">Self-repairing homomorphic codes for distributed storage systems</title>
		<author>
			<persName><forename type="first">F</forename><surname>Oggier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Datta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE INFOCOM</title>
		<meeting>IEEE INFOCOM<address><addrLine>Shanghai</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="1215" to="1223" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b92">
	<analytic>
		<title level="a" type="main">On the locality of codeword symbols</title>
		<author>
			<persName><forename type="first">P</forename><surname>Gopalan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Simitci</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2012.2208937</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="page" from="6925" to="6934" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b93">
	<analytic>
		<title level="a" type="main">Locally repairable codes</title>
		<author>
			<persName><forename type="first">D</forename><surname>Papailiopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Dimakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Cambridge</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="2771" to="2775" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b94">
	<analytic>
		<title level="a" type="main">On the locality of codeword symbols in non-linear codes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Forbes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yekhanin</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.disc.2014.01.016</idno>
	</analytic>
	<monogr>
		<title level="j">Discrete Math</title>
		<imprint>
			<biblScope unit="volume">324</biblScope>
			<biblScope unit="page" from="78" to="84" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b95">
	<analytic>
		<title level="a" type="main">Optimal linear codes with a local-error-correction property</title>
		<author>
			<persName><forename type="first">N</forename><surname>Prakash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Kamath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Lalitha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory Proceedings</title>
		<meeting>IEEE International Symposium on Information Theory Proceedings<address><addrLine>Cambridge</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="2776" to="2780" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b96">
	<analytic>
		<title level="a" type="main">Optimal locally repairable codes via rank-metric codes</title>
		<author>
			<persName><forename type="first">N</forename><surname>Silberstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Rawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">O</forename><surname>Koyluoglu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Istanbul</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1819" to="1823" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b97">
	<analytic>
		<title level="a" type="main">Codes with locality for two erasures</title>
		<author>
			<persName><forename type="first">N</forename><surname>Prakash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Lalitha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Honolulu</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="1962" to="1966" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b98">
	<analytic>
		<title level="a" type="main">An integer programming-based bound for locally repairable codes</title>
		<author>
			<persName><forename type="first">A</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Zhang</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2015.2472515</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="page" from="5280" to="5294" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b99">
	<monogr>
		<title level="m" type="main">Some improvements on locally repairable codes</title>
		<author>
			<persName><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ge</surname></persName>
		</author>
		<idno>ArXiv:1506.04822</idno>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b100">
	<analytic>
		<title level="a" type="main">On minimum distance of locally repairable codes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Mehrabi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ardakani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th Canadian Workshop on Information Theory</title>
		<meeting>the 15th Canadian Workshop on Information Theory<address><addrLine>Quebec</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b101">
	<analytic>
		<title level="a" type="main">A family of optimal locally recoverable codes</title>
		<author>
			<persName><forename type="first">I</forename><surname>Tamo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Barg</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2014.2321280</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="page" from="4661" to="4676" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b102">
	<analytic>
		<title level="a" type="main">Constructions of optimal and almost optimal locally repairable codes</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ernvall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Westerback</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hollanti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th International Conference on Wireless Communications, Vehicular Technology, Information Theory and Aerospace Electronic Systems</title>
		<meeting>the 4th International Conference on Wireless Communications, Vehicular Technology, Information Theory and Aerospace Electronic Systems<address><addrLine>Aalborg</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b103">
	<analytic>
		<title level="a" type="main">New constructions of optimal locally recoverable codes via good polynomials</title>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mesnager</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="page" from="889" to="899" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b104">
	<monogr>
		<title level="m" type="main">Optimal LRC codes for all lenghts n q</title>
		<author>
			<persName><forename type="first">O</forename><surname>Kolosov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Barg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Tamo</surname></persName>
		</author>
		<idno>ArXiv:1802.00157</idno>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b105">
	<monogr>
		<title level="m" type="main">Construction of optimal locally repairable codes via automorphism groups of rational function fields</title>
		<author>
			<persName><forename type="first">Jin</forename><forename type="middle">L</forename></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L M</forename><surname>Xing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">P</forename></persName>
		</author>
		<idno>ArXiv:1710.09638</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b106">
	<analytic>
		<title level="a" type="main">On partial maximally-recoverable and maximally-recoverable codes</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Balaji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">V</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Hong Kong</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1881" to="1885" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b107">
	<analytic>
		<title level="a" type="main">Bounds on the size of locally recoverable codes</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">R</forename><surname>Cadambe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mazumdar</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2015.2477406</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="page" from="5787" to="5794" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b108">
	<analytic>
		<title level="a" type="main">Binary linear locally repairable codes</title>
		<author>
			<persName><forename type="first">P</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Yaakobi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Uchikawa</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2016.2605119</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="page" from="6268" to="6283" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b109">
	<analytic>
		<title level="a" type="main">Bounds on the rate and minimum distance of codes with availability</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Balaji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">V</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Aachen</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="3155" to="3159" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b110">
	<analytic>
		<title level="a" type="main">Generalized Hamming weights for linear codes</title>
		<author>
			<persName><forename type="first">V</forename><surname>Wei</surname></persName>
		</author>
		<idno type="DOI">10.1109/18.133259</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="1412" to="1418" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b111">
	<analytic>
		<title level="a" type="main">Bounds and constructions for linear locally repairable codes over binary fields</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">F</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Aachen</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="2033" to="2037" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b112">
	<monogr>
		<title level="m" type="main">Optimal binary linear locally repairable codes with disjoint repair groups</title>
		<author>
			<persName><forename type="first">J X</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">N</forename><surname>Ge</surname></persName>
		</author>
		<idno>ArXiv:1711.07138</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b113">
	<analytic>
		<title level="a" type="main">Combinatorial alphabet-dependent bounds for locally recoverable codes</title>
		<author>
			<persName><forename type="first">A</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Barg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="page" from="3481" to="3492" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b114">
	<monogr>
		<title level="m" type="main">Cyclic LRC codes, binary LRC codes, and upper bounds on the distance of cyclic codes</title>
		<author>
			<persName><forename type="first">I</forename><surname>Tamo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Barg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goparaju</surname></persName>
		</author>
		<idno>ArXiv:1603.08878</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b115">
	<analytic>
		<title level="a" type="main">Binary cyclic codes that are locally repairable</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goparaju</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Calderbank</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Honolulu</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="676" to="680" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b116">
	<analytic>
		<title level="a" type="main">Optimal linear and cyclic locally repairable codes over small fields</title>
		<author>
			<persName><forename type="first">A</forename><surname>Zeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Yaakobi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Information Theory Workshop</title>
		<meeting>IEEE Information Theory Workshop<address><addrLine>Jerusalem</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b117">
	<analytic>
		<title level="a" type="main">Bounds on the parameters of locally recoverable codes</title>
		<author>
			<persName><forename type="first">I</forename><surname>Tamo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Barg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Frolov</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2016.2518663</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="page" from="3070" to="3083" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b118">
	<analytic>
		<title level="a" type="main">Locally recoverable codes on algebraic curves</title>
		<author>
			<persName><forename type="first">A</forename><surname>Barg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Tamo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vladut</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2017.2700859</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="page" from="4928" to="4939" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b119">
	<monogr>
		<title level="m" type="main">Construction of asymptotically good locally repairable codes via automorphism groups of function fields</title>
		<author>
			<persName><forename type="first">X D</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L M</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">P</forename><surname>Xing</surname></persName>
		</author>
		<idno>ArXiv:1711.07703</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b120">
	<analytic>
		<title level="a" type="main">Binary locally repairable codes with minimum distance at least six based on partial t-spreads</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Nam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">Y</forename><surname>Song</surname></persName>
		</author>
		<idno type="DOI">10.1109/LCOMM.2017.2697424</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Commun Lett</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="1683" to="1686" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b121">
	<analytic>
		<title level="a" type="main">Optimal binary locally repairable codes via anticodes</title>
		<author>
			<persName><forename type="first">N</forename><surname>Silberstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Hong Kong</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1247" to="1251" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b122">
	<analytic>
		<title level="a" type="main">Some results on optimal locally repairable codes</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chen</forename><forename type="middle">B</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Barcelona</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="440" to="444" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b123">
	<analytic>
		<title level="a" type="main">A class of binary locally repairable codes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Shahabinejad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Khabbazian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ardakani</surname></persName>
		</author>
		<idno type="DOI">10.1109/TCOMM.2016.2581163</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Commun</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="page" from="3182" to="3193" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b124">
	<analytic>
		<title level="a" type="main">On optimal ternary locally repairable codes</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chen</forename><forename type="middle">B</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Aachen</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="171" to="175" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b125">
	<monogr>
		<title level="m" type="main">Bounds and constructions of locally repairable codes: parity-check matrix approach</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Xia</surname></persName>
		</author>
		<idno>ArXiv:1601.05595</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b126">
	<monogr>
		<title level="m" type="main">Optimal locally repairable codes via elliptic curves</title>
		<author>
			<persName><forename type="first">X D</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L M</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">P</forename><surname>Xing</surname></persName>
		</author>
		<idno>ArXiv:1712.03744</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b127">
	<analytic>
		<title level="a" type="main">New constructions of binary and ternary locally repairable codes using cyclic codes</title>
		<author>
			<persName><forename type="first">C</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>No</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Commun Lett</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="228" to="231" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b128">
	<monogr>
		<title level="m" type="main">Optimal locally repairable codes of distance 3 and 4 via cyclic codes</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">P</forename><surname>Xing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Yuan</surname></persName>
		</author>
		<idno>ArXiv:1801.03623</idno>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b129">
	<analytic>
		<title level="a" type="main">Exploiting locality for improved decoding of binary cyclic codes</title>
		<author>
			<persName><forename type="first">M N</forename><surname>Krishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Puranik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P V</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Commun</title>
		<imprint>
			<biblScope unit="volume">66</biblScope>
			<biblScope unit="page" from="2346" to="2358" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b130">
	<analytic>
		<title level="a" type="main">Maximum-likelihood soft decision decoding of BCH codes</title>
		<author>
			<persName><forename type="first">A</forename><surname>Vardy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">'</forename><surname>Be</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename></persName>
		</author>
		<idno type="DOI">10.1109/18.312184</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="546" to="554" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b131">
	<analytic>
		<title level="a" type="main">Cyclic linear binary locally repairable codes</title>
		<author>
			<persName><forename type="first">P</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Yaakobi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Uchikawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Information Theory Workshop</title>
		<meeting>IEEE Information Theory Workshop<address><addrLine>Jerusalem</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b132">
	<analytic>
		<title level="a" type="main">On the maximally recoverable property for multi-protection group codes</title>
		<author>
			<persName><forename type="first">M H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Nice</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="486" to="490" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b133">
	<analytic>
		<title level="a" type="main">Partial-MDS codes and their application to RAID type of architectures</title>
		<author>
			<persName><forename type="first">M</forename><surname>Blaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Hafner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hetzler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="page" from="4510" to="4519" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b134">
	<analytic>
		<title level="a" type="main">A general construction for PMDS codes</title>
		<author>
			<persName><forename type="first">G</forename><surname>Calis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">O</forename><surname>Koyluoglu</surname></persName>
		</author>
		<idno type="DOI">10.1109/LCOMM.2016.2627569</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Commun Lett</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="452" to="455" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b135">
	<analytic>
		<title level="a" type="main">Constructions of partial MDS codes over small fields</title>
		<author>
			<persName><forename type="first">R</forename><surname>Gabrys</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Yaakobi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Blaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Aachen</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b136">
	<analytic>
		<title level="a" type="main">Explicit maximally recoverable codes with locality</title>
		<author>
			<persName><forename type="first">P</forename><surname>Gopalan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Jenkins</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2014.2332338</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="page" from="5245" to="5256" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b137">
	<analytic>
		<title level="a" type="main">New constructions of SD and MR codes over small finite fields</title>
		<author>
			<persName><forename type="first">G</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yekhanin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Barcelona</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1591" to="1595" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b138">
	<analytic>
		<title level="a" type="main">Sector-disk codes and partial MDS codes with up to three global parities</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">W</forename><surname>Shum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Hong Kong</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1876" to="1880" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b139">
	<monogr>
		<title level="m" type="main">Construction of PMDS and SD codes extending RAID 5</title>
		<author>
			<persName><forename type="first">M</forename><surname>Blaum</surname></persName>
		</author>
		<idno>ArXiv:1305.0032</idno>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b140">
	<analytic>
		<title level="a" type="main">Construction of partial MDS and sector-disk codes with two global parity symbols</title>
		<author>
			<persName><forename type="first">M</forename><surname>Blaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J S</forename><surname>Plank</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schwartz</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2016.2536720</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="page" from="2673" to="2681" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b141">
	<analytic>
		<title level="a" type="main">Weight enumerators and higher support weights of maximally recoverable codes</title>
		<author>
			<persName><forename type="first">V</forename><surname>Lalitha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">V</forename><surname>Lokam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 53rd Annual Allerton Conference on Communication, Control, and Computing</title>
		<meeting>the 53rd Annual Allerton Conference on Communication, Control, and Computing<address><addrLine>Monticello</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="835" to="842" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b142">
	<monogr>
		<title level="m" type="main">Rate optimal binary linear locally repairable codes with small availability</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kadhe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Calderbank</surname></persName>
		</author>
		<idno>ArXiv:1701.02456</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b143">
	<analytic>
		<title level="a" type="main">Achieving arbitrary locality and availability in binary codes</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Hong Kong</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1866" to="1870" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b144">
	<analytic>
		<title level="a" type="main">Repair locality with multiple erasure tolerance</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Zhang</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2014.2351404</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="page" from="6979" to="6987" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b145">
	<monogr>
		<title level="m" type="main">Locally repairable codes with functional repair and multiple erasure tolerance</title>
		<author>
			<persName><forename type="first">W T</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Yuen</surname></persName>
		</author>
		<idno>ArXiv:1507.02796</idno>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b146">
	<analytic>
		<title level="a" type="main">A tight rate bound and a matching construction for locally recoverable codes with sequential recovery from any number of multiple erasures</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Balaji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">V</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Aachen</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1778" to="1782" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b147">
	<monogr>
		<title level="m" type="main">A bound on rate of codes with locality with sequential recovery from multiple erasures</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Balaji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">R</forename><surname>Kini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kumar</surname></persName>
		</author>
		<idno>ArXiv:1611.08561</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b148">
	<analytic>
		<title level="a" type="main">On sequential locally repairable codes</title>
		<author>
			<persName><forename type="first">W T</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Yuen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="page" from="3513" to="3527" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b149">
	<analytic>
		<title level="a" type="main">A rate-optimal construction of codes with sequential recovery with low block length</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Balaji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">V</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of National Conference on Communications</title>
		<meeting>National Conference on Communications<address><addrLine>Hyderabad</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b150">
	<monogr>
		<title level="m" type="main">Cooperative local repair in distributed storage</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Rawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mazumdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vishwanath</surname></persName>
		</author>
		<idno>ArXiv:1409.3900</idno>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b151">
	<analytic>
		<title level="a" type="main">Dynamic cage survey</title>
		<author>
			<persName><forename type="first">G</forename><surname>Exoo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jajcay</surname></persName>
		</author>
		<ptr target="http://pdfs.semanticscholar.org/43b8/" />
	</analytic>
	<monogr>
		<title level="j">The Electronic Journal Combinatorics</title>
		<imprint>
			<date type="published" when="2013">2013. 2016a2ef8f394f2cb1954439248198d2c274</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b152">
	<analytic>
		<title level="a" type="main">Optimal locally repairable linear codes</title>
		<author>
			<persName><forename type="first">W</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">H</forename><surname>Dau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Yuen</surname></persName>
		</author>
		<idno type="DOI">10.1109/JSAC.2014.140521</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE J Sel Areas Commun</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="1019" to="1036" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b153">
	<analytic>
		<title level="a" type="main">Constructions of optimal cyclic (r, δ) locally repairable codes</title>
		<author>
			<persName><forename type="first">B</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hao</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2017.2761120</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="page" from="2499" to="2511" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b154">
	<analytic>
		<title level="a" type="main">On the linear codes with (r, δ)-locality for distributed storage</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chen</forename><forename type="middle">B</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Conference on Communications</title>
		<meeting>IEEE International Conference on Communications<address><addrLine>Paris</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b155">
	<analytic>
		<title level="a" type="main">Codes with hierarchical locality</title>
		<author>
			<persName><forename type="first">B</forename><surname>Sasidharan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G K</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Symposium on Information Theory (ISIT)</title>
		<meeting>International Symposium on Information Theory (ISIT)<address><addrLine>Hong Kong</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1257" to="1261" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b156">
	<analytic>
		<title level="a" type="main">Codes on curves with hierarchical locality</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ballentine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Barg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory (accepted)</title>
		<meeting>IEEE International Symposium on Information Theory (accepted)<address><addrLine>Hong Kong</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b157">
	<analytic>
		<title level="a" type="main">Hierarchical codes: how to make erasure codes attractive for peer-to-peer storage systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Duminuco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Biersack</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Conference on Peer-to-Peer Computing</title>
		<meeting>the 8th International Conference on Peer-to-Peer Computing<address><addrLine>Aachen</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="89" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b158">
	<analytic>
		<title level="a" type="main">Codes with local regeneration and erasure correction</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Kamath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Prakash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Lalitha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="page" from="4637" to="4660" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b159">
	<monogr>
		<title level="m" type="main">Repair duality with locally repairable and locally regenerating codes</title>
		<author>
			<persName><forename type="first">D</forename><surname>Gligoroski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kralevska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Jensen</surname></persName>
		</author>
		<idno>ArXiv:1701.06664</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b160">
	<analytic>
		<title level="a" type="main">On the minimum storage overhead of distributed storage codes with a given repair locality</title>
		<author>
			<persName><forename type="first">H D L</forename><surname>Hollmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Honolulu</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="1041" to="1045" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b161">
	<analytic>
		<title level="a" type="main">When locally repairable codes meet regenerating codes -what if some helpers are unavailable</title>
		<author>
			<persName><forename type="first">I</forename><surname>Ahmad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">C</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Hong Kong</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="849" to="853" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b162">
	<monogr>
		<title level="m" type="main">Codes with combined locality and regeneration having optimal Rate, d min and linear field size</title>
		<author>
			<persName><forename type="first">M N</forename><surname>Krishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">R</forename><surname>Anantha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kumar</surname></persName>
		</author>
		<idno>ArXiv:1804.00564</idno>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b163">
	<analytic>
		<title level="a" type="main">A repair framework for scalar MDS codes</title>
		<author>
			<persName><forename type="first">K</forename><surname>Shanmugam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Papailiopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Dimakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE J Sel Areas Commun</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="998" to="1007" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b164">
	<analytic>
		<title level="a" type="main">Repairing Reed-Solomon codes</title>
		<author>
			<persName><forename type="first">V</forename><surname>Guruswami</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wootters</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2017.2702660</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Inf Theory</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="page" from="5684" to="5698" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b165">
	<monogr>
		<title level="m" type="main">The theory of error-correcting codes</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Macwilliams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N J A</forename><surname>Sloane</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1977">1977</date>
			<publisher>Elsevier</publisher>
			<biblScope unit="volume">68</biblScope>
			<biblScope unit="page" from="185" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b166">
	<analytic>
		<title level="a" type="main">Optimal repair schemes for some families of full-length Reed-Solomon codes</title>
		<author>
			<persName><forename type="first">H</forename><surname>Dau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Milenkovic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Aachen</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="346" to="350" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b167">
	<analytic>
		<title level="a" type="main">Explicit constructions of MDS array codes and RS codes with optimal repair bandwidth</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Barg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Barcelona</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1202" to="1206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b168">
	<analytic>
		<title level="a" type="main">Improved schemes for asymptotically optimal repair of MDS codes</title>
		<author>
			<persName><forename type="first">A</forename><surname>Chowdhury</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vardy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 55th Annual Allerton Conference on Communication, Control, and Computing</title>
		<meeting>the 55th Annual Allerton Conference on Communication, Control, and Computing<address><addrLine>Monticello</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="950" to="957" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b169">
	<analytic>
		<title level="a" type="main">Optimal repair of reed-solomon codes: achieving the cut-set bound</title>
		<author>
			<persName><forename type="first">I</forename><surname>Tamo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Barg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 58th IEEE Annual Symposium on Foundations of Computer Science</title>
		<meeting>the 58th IEEE Annual Symposium on Foundations of Computer Science<address><addrLine>Berkeley</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="216" to="227" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b170">
	<monogr>
		<title level="m" type="main">Repairing Reed-Solomon codes with multiple erasures</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">H</forename><surname>Dau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">M</forename><surname>Duursma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kiah</forename><forename type="middle">H M</forename></persName>
		</author>
		<idno>ArXiv:1612.01361</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b171">
	<analytic>
		<title level="a" type="main">Repairing multiple failures for scalar MDS codes</title>
		<author>
			<persName><forename type="first">B</forename><surname>Bartan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wootters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 55th Annual Allerton Conference on Communication, Control, and Computing</title>
		<meeting>the 55th Annual Allerton Conference on Communication, Control, and Computing<address><addrLine>Monticello</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1145" to="1152" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b172">
	<monogr>
		<title level="m" type="main">Repairing Reed-Solomon codes: universally achieving the cut-set bound for any number of erasures</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Barg</surname></persName>
		</author>
		<idno>ArXiv:1710.07216</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b173">
	<monogr>
		<title level="m" type="main">Capacity bounds for distributed storage</title>
		<author>
			<persName><forename type="first">M</forename><surname>Luby</surname></persName>
		</author>
		<idno>ArXiv:1610.03541</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b174">
	<monogr>
		<title level="m" type="main">Liquid cloud storage</title>
		<author>
			<persName><forename type="first">M</forename><surname>Luby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Padovani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T J</forename><surname>Richardson</surname></persName>
		</author>
		<idno>ArXiv:1705.07983</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b175">
	<analytic>
		<title level="a" type="main">Erasure coding in windows azure storage</title>
		<author>
			<persName><forename type="first">C</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Simitci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of USENIX Annual Technical Conference</title>
		<meeting>USENIX Annual Technical Conference<address><addrLine>Boston</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="15" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b176">
	<analytic>
		<author>
			<persName><forename type="first">D</forename><surname>Gantenbein</surname></persName>
		</author>
		<author>
			<persName><surname>Balaji S B</surname></persName>
		</author>
		<ptr target="45blog/better-way-store-data/" />
	</analytic>
	<monogr>
		<title level="m">A better way to store data. Microsoft research blog</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">61</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b177">
	<monogr>
		<title level="m" type="main">Locally repairable erasure code plugin</title>
		<author>
			<persName><surname>Ceph</surname></persName>
		</author>
		<ptr target="http://docs.ceph.com/docs/master/rados/operations/erasure-code-lrc/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b178">
	<analytic>
		<title level="a" type="main">A &quot;hitchhiker&apos;s&quot; guide to fast and efficient data reconstruction in erasure-coded data centers</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">V</forename><surname>Rashmi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N B</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGCOMM Conference</title>
		<meeting>ACM SIGCOMM Conference<address><addrLine>Chicago</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="331" to="342" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b179">
	<analytic>
		<title level="a" type="main">Hashtag erasure codes: from theory to practice</title>
		<author>
			<persName><forename type="first">K</forename><surname>Kralevska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gligoroski</surname></persName>
		</author>
		<author>
			<persName><surname>Jensen R E</surname></persName>
		</author>
		<idno type="DOI">10.1109/TBDATA.2017.2749255</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Big Data</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b180">
	<analytic>
		<title level="a" type="main">Evaluation of codes with inherent double replication for Hadoop</title>
		<author>
			<persName><forename type="first">M</forename><surname>Krishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Prakash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Lalitha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th USENIX Workshop on Hot Topics in Storage and File Systems</title>
		<meeting>the 6th USENIX Workshop on Hot Topics in Storage and File Systems<address><addrLine>Philadelphia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b181">
	<analytic>
		<title level="a" type="main">Having your cake and eating it too: jointly optimal erasure codes for I/O, storage, and network-bandwidth</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">V</forename><surname>Rashmi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Nakkiran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th USENIX Conference on File and Storage Technologies</title>
		<meeting>the 13th USENIX Conference on File and Storage Technologies<address><addrLine>Santa Clara</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="81" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b182">
	<analytic>
		<title level="a" type="main">Beehive: erasure codes for fixing multiple failures in distributed storage systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Parallel Distrib Syst</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="1257" to="1270" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b183">
	<analytic>
		<title level="a" type="main">Opening the chrysalis: on the real repair performance of MSR codes</title>
		<author>
			<persName><forename type="first">L</forename><surname>Pamies-Juarez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Blagojevic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mateescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th USENIX Conference on File and Storage Technologies</title>
		<meeting>the 14th USENIX Conference on File and Storage Technologies<address><addrLine>Santa Clara</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="81" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b184">
	<analytic>
		<title level="a" type="main">Repair-optimal MDS array codes over GF(2)</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">E</forename><surname>Gad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mateescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Blagojevic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Symposium on Information Theory</title>
		<meeting>IEEE International Symposium on Information Theory<address><addrLine>Istanbul</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="887" to="891" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b185">
	<analytic>
		<title level="a" type="main">Clay codes: moulding MDS codes to yield an MSR code</title>
		<author>
			<persName><forename type="first">M</forename><surname>Vajha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Ramkumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Puranik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th USENIX Conference on File and Storage Technologies</title>
		<meeting>the 16th USENIX Conference on File and Storage Technologies<address><addrLine>Oakland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="139" to="154" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
