<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The Higher-Order Recursive Path Ordering</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><roleName>Bâtiment</roleName><forename type="first">J.-P</forename><forename type="middle">Jouannaud</forename><surname>Lri</surname></persName>
						</author>
						<author role="corresp">
							<persName><forename type="first">A</forename><surname>Rubio</surname></persName>
							<email>rubio@lsi.upc.es</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="laboratory">UMR CNRS 8623</orgName>
								<orgName type="institution">Université de Paris</orgName>
								<address>
									<postCode>91405</postCode>
									<settlement>Orsay</settlement>
									<country key="FR">FRANCE</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Dep. LSI Univ. Politècnica de Catalunya Modul C6</orgName>
								<address>
									<addrLine>Jordi Girona 1 08034</addrLine>
									<settlement>Barcelona</settlement>
									<country key="ES">SPAIN</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">The Higher-Order Recursive Path Ordering</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">98FA30A46EDEC6213EEEA3E37A6FE55E</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T15:23+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper extends the termination proof techniques based on reduction orderings to a higher-order setting, by adapting the recursive path ordering definition to terms of a typed lambda-calculus generated by a signature of polymorphic higher-order function symbols. The obtained ordering is well-founded, compatible with -reductions and with polymorphic typing, monotonic with respect to the function symbols, and stable under substitution. It can therefore be used to prove the strong normalization property of higher-order calculi in which constants can be defined by higher-order rewrite rules. For example, the polymorphic version of Gödel's recursor for the natural numbers is easily oriented. And indeed, our ordering is polymorphic, in the sense that a single comparison allows to prove the termination property of all monomorphic instances of a polymorphic rewrite rule. Several other non-trivial examples are given which examplify the expressive power of the ordering.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Rewrite rules are increasingly used in programming languages and logical systems, with two main goals: defining functions by pattern matching; describing rule-based decision procedures. ML, Alf <ref type="bibr" target="#b3">[4]</ref> and Isabelle <ref type="bibr" target="#b16">[17]</ref> examplify the first use. A future version of Coq <ref type="bibr" target="#b8">[9]</ref> will examplify the second use <ref type="bibr" target="#b7">[8]</ref>. In Isabelle, rules operate on terms in -normal, -expanded form. In ML and Alf, they operate on arbitrary terms. In the future version of Coq, both kinds should coexist.</p><p>Our ambition is to develop for the higher-order case the kind of semi-automated termination proof techniques that are available for the first-order case, of which the most popular one is the recursive path ordering <ref type="bibr" target="#b5">[6]</ref>.</p><p>Our contribution to this program is a reduction ordering for typed higher-order terms which conservatively extends Dershowitz's recursive path ordering for first-order terms. In the latter, the precedence rule allows to decrease from the term s = f(s 1 ; : : : ; s n ) to the term g(t 1 ; : : : ; t n ), provided that (i) f is bigger than g in the given precedence on function symbols, and (ii) s is bigger than every t i . For typing reasons, in our ordering the latter condition becomes: (ii) for every t i , either s is bigger than t i or some s j is bigger than or equal to t i . Indeed, we can instead allow t i to be obtained from the subterms of s by computability preserving operations. Here, computability refers to Tait and Girard's strong normalization proof technique which we have used to show that our ordering is well-founded and compatible with -reductions.</p><p>In the litterature, one can find several attempts at designing methods for proving strong normalization of higherorder rewrite rules based on ordering comparisons. These orderings are either quite weak <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b10">11]</ref>, or need an important user interaction <ref type="bibr" target="#b4">[5]</ref>. Besides, they operate on terms in -long -normal form, hence apply only to the higher-order rewriting "à la Nipkow" <ref type="bibr" target="#b14">[15]</ref>, based on higher-order pattern matching modulo . To our knowledge, our ordering is the first to operate on arbitrary higher-order terms, therefore applying to the other kind of rewriting, based on plain pattern matching. And indeed we want to stress four important features of our approach. First, it can be seen as a way to lift an ordinal notation operating on a first-order language (here, the set of labelled trees ordered by the recursive path ordering) to an ordinal notation of higher type operating on a set of well-typed -expressions built over the first-order language. Secondly, the analysis of our ordering, based on Tait and Girard's computability predicate proof technique, leads to hiding this technique away, by allowing one to carry out future meta-theoretical investigations based on ordering comparisons rather than by a direct use of the computability predicate technique. Thirdly, we obtain as a biproduct a new proof of well-foundedness of Dershowitz's recursive path ordering which does not use Kruskal's tree theorem anymore. Fourthly, our ordering can be adapted to operate on terms in -long -normal form, yielding an ordering stronger than the already existing ones <ref type="bibr" target="#b11">[12]</ref>.</p><p>To hint at the strength of the ordering described in the present paper, let us mention that the polymorphic version of Gödel's recursor for the natural numbers is easily oriented. And indeed, our ordering can prove at once the termination property of all monomorphic instances of a polymorphic rewrite rule. Many other examples are given which examplify the expressive power of the ordering.</p><p>The framework we use is described in Section 2. The ordering is defined and studied in Section 3, where several examples are also given. The notion of computable closure used to boost the expressivity of the ordering is introduced and studied in Section 4. The discussion of the potential improvements and extensions of our work is carried out in Section 5. Some related work is mentionned in conclusion. The reader is expected to be familiar with the basics of term rewriting systems <ref type="bibr" target="#b6">[7]</ref> and typed lambda calculi <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Types</head><p>Given a set S of sort symbols of a fixed arity, as in s : n ! , and a set S 8 of type variables, the set T S 8 of polymorphic types is generated from these sets by the constructor ! for functional types: T S 8 := s(T n S 8 ) j S 8 j (T S 8 ! T S 8 ) for s : n ! 2 S We will denote by T S the set of ground types.</p><p>Types are functional when they are headed by the ! symbol, and data types otherwise. By a basic type, we mean a</p><p>In the following, we use ; and to denote types. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Signatures</head><p>We are given a set of function symbols which are meant to be algebraic operators, equipped with a fixed number n of arguments (called the arity) of respective types 1 ; : : : ; n , and an output type which is assumed to be a non-variable type: F = </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Terms</head><p>The set of untyped algebraic -terms is generated from the signature F and a denumerable set X of variables according to the grammar:</p><p>T := X j ( X:T ) j T (T ) j F(T ; : : : ; T ): u(v) denotes the application of u to v. We will usually write the application operator explicitly, as in @(u; v). As a matter of convenience, we may write u(v 1 ; : : : ; v n ), or @(u; v 1 ; : : : ; v n ) for u(v 1 ) : : : (v n ), assuming n 1. The term @(u; v) is called a (partial) left-flattening of s = u(v 1 ) : : : (v n ), u being possibly an application itself.</p><p>We denote by Var(t) the set of free variables of t. We may assume for convenience (and without further notice) that bound variables in a term are all different, and are different from the free ones. We use the letter for substitutions and postfix notation for their application. Substitutions behave as endomorphisms defined on free variables (avoiding captures).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Typing Rules</head><p>Typing rules restrict the set of terms by constraining them to follow a precise discipline. Environments are sets of pairs written x : , where x is a variable and is a type.</p><p>Our typing judgements are written as ? `M : if the term M can be proved to have the type in the environment ?:</p><p>Variables:</p><p>x : 2 ? ? `x : Functions: F : 1 : : : n ! 2 F ? `t1 : 1 : : : ? `tn : n ? `F(t 1 ; : : : ; t n ) :</p><p>Abstraction:</p><p>? fx : g `t : ? `( x : :t) : ! Application:</p><p>? fx : g `s : ! ? `t : ? `s(t) :</p><p>A term M has type in the environment ? if ? `M :</p><p>is provable in the above inference system. A term M is typable in the environment ? if there exists a type such that M has type in the environment ?. A term M is typable if it is typable in some environment ?. Note that function symbols are uncurried, hence must come along with all their arguments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Conversion rules</head><p>Three particular equations originate from the -calculus, -, -and -equality:</p><formula xml:id="formula_0">( x:v)(u) = vfx 7 ! ug x:u(x) = u if x 6 2 Var(u) x:v = y:vfx 7 ! yg if y 6 2 BVar(v) (Var(v) n fxg)</formula><p>As usual, we do not distinguish -convertible terms. We use ! for the congruence generated by the -equality, and ?! for the -reduction rule: ( x:v)(u) ?! vfx 7 ! ug</p><p>The simply typed -calculus is confluent and terminating (or strongly normalizing in the lambda-calculus jargon) with respect to -reductions. We could order as well -equality as a reduction and carry it along to the price of some easy extra technical complications. We did not think it was worth doing it, since makes more sense in the context of higher-order pattern matching modulo , a kind of higher-order rewriting that we do not consider in the present paper, as explained next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Higher-order rewrite rules</head><p>A (possibly higher-order) term rewriting system is a set of rewrite rules R = f? i `li ! r i : i g i , where l i and r i are higher-order terms such that l i and r i have the same type i in the environment ? i . Given a term rewriting system R, Several examples of higher-order rewrite systems are developped in section 3.</p><formula xml:id="formula_1">a</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.7">Polymorphic Reduction Orderings</head><p>We will make intensive use of well-founded orderings for proving strong normalization properties. We will use the vocabulary of rewrite systems for orderings. For our purpose, a strict ordering, usually denoted by &gt;, is an irreflexive and transitive relation, and an ordering, usually denoted by , is the union of its strict part with -conversion. We will essentially use strict orderings, and hence, we will use the word ordering for them too. Rewrite orderings are monotonic and stable orderings, and reduction orderings are in addition well-founded. Monotonicity of &gt; is defined as u &gt; v implies s u] p &gt; s v] p for all contexts s ] p . Stability of &gt; is defined as u &gt; v implies s &gt; t for all substitutions . Reduction orderings are used to prove termination of rewrite systems by simply comparing the left and righthand sides of rules. The following results will play a key role, see <ref type="bibr" target="#b6">[7]</ref>: Assume &gt; 1 ; : : : ; &gt; n are well-founded orderings on sets S 1 ; : : : ; S n . Then (&gt; 1 ; : : : ; &gt; n ) lex is a well-founded ordering on S 1 : : : S n . We write &gt; lex if all sets and orderings are equal.</p><p>Assume &gt; is a well-founded ordering on a set S. Then &gt; mul is a well-founded ordering on the set of multisets of elements of S. It is defined as the transitive closure of the following relation &gt;&gt; on multisets (using for multiset union):</p><p>M fsg &gt;&gt; M ft 1 ; : : : ; t n g if s : &gt; t i : 8i 2 1::n]</p><p>We end up with the definition of a polymorphic reduction ordering operating on higher-order terms, and allowing one's to show that the relation ?! R ?! is well-founded by simply comparing the lefthand and righthand sides of the (polymorphic) rules in R:</p><formula xml:id="formula_2">Definition 2.1 An ordering &gt; is polymorphic if s &gt; t in a polymorphic signature F implies s &gt; t in all monomorphic instances F of F.</formula><p>A polymorphic higher-order reduction ordering is a monotonic and stable polymorphic ordering &gt; of the set of higher-order terms, such that &gt; ?! is well-founded.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">The Higher-Order Recursive Path Ordering</head><p>From now on, the application operator is written explicitly.</p><p>Our ordering on terms uses two basic ingredients:</p><p>A partition Mul ] Lex of F, together with a wellfounded ordering &gt; F on F, called the precedence; as usual, variables will be considered as constants incomparable in &gt; F among themselves and with other function symbols.</p><p>A (partial) quasi-ordering on types TS which is as- sumed to satisfy the following two properties:</p><p>(i: preservation of arrows) ! TS implies that = TS 0 ! 0 , 0 TS and TS 0 .</p><p>(ii: stability under substitutions) If &gt; TS , ( = TS</p><p>, respectively) then &gt; TS for every ground type substitution ( = TS , respectively).</p><p>(iii: well-foundedness) &gt; TS is well-founded.</p><p>Note that two functyional types are equivalent if both their input and output types are equivalent. A form of preservation of data types follows from the preservation of arrows: if s(sigma) = TS , then is not functional.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Definition of the ordering</head><p>The following higher-order recursive path ordering (HORPO) is essentially the same as Dershowitz's recursive path ordering for first-order terms. The main difference is that we take care of higher-order arguments on the smaller side by having a corresponding bigger higher-order argument on the bigger side.</p><p>We will denote by A the proposition: 8t i 2 ts horpo t i or s j horpo t i for somes j 2 s Definition 3.1 s : horpo t : iff &gt; TS and 1. s = f(s) with f 2 F, and s i horpo t for some s i 2 s.</p><p>2. s = f(s) and t = g(t) with f &gt; F g, and A</p><p>3. f = g 2 Mul and s( horpo ) mul t 4. f = g 2 Lex and s( horpo ) lex t, and A 5. f 2 F, @(t) is some partial left-flattening of t, and A</p><p>6. s = @(s 1 ; s 2 ), t = @(t 1 ; t 2 ) and s 1 horpo t 1 and s 2 horpo t 2</p><p>7. s = x:u, t = x:v and u horpo v</p><p>Important observations are the following:</p><p>The definition is recursive, and recursive calls operate on pairs of terms whose sum of sizes has strictly decreased. This ensures the well-foundedness of the definition. Note that the type of the bigger side of a recursive comparison may have increased in case ??.</p><p>Our ordering compares terms related types, improving over [?], where terms of equivalent types only could be compared.</p><p>When the signature is first-order, cases 1, 2, 3, and 4 reduce to the usual recursive path ordering for first-order terms.</p><p>Case 7 compares two abstractions. No other case applies to an abstraction on the bigger side. Case 1 may compare a term headed by a function symbol on the bigger side with an abstraction on the smaller side.</p><p>In Case 6, type considerations show that the first arguments are compared together as well as the second's. On the other hand, Case 5 compares a term s headed by a function symbol with an application on the smaller side, for which an appropriate (partial) left-flattening has to be chosen nondeterministically. This non-deterministic choice is essential for stability. Of course, the ordering can be approximated by chosing an arbitrary flattening, the best practical choice being likely the maximal one. But type considerations may also help finding a left-flattening quickly.</p><p>In rec(0; u; X) ! u rec(s(x); u; X) ! @(X; x; rec(x; u; X))</p><p>We use here for the ordering on types the equivalence generated by the equality of the sort constants. The first rule succeeds immediately by case 1. For the second rule, we apply case 5, and need to show recursively that (i) X horpo X, (ii) s(x) horpo x, and (iii) rec(s(x); u; X) horpo rec(x; u; X). (i) is trivial. (ii) is by case 1. (iii) is by case 3, calling again recursively for s(x) horpo x.</p><p>Note that we have proved Gödel's polymorphic recursor, for which the output type of rec is any given type. This is because we do not care about types in our comparisons, provided two compared terms are typable with equivalent types, hence of the same functionnal structure.</p><p>We can of course now add some defining rules for sum and product:</p><p>x + 0 ! 0 x + s(y) ! s(x + y)</p><p>x y ! rec(y; 0; z 1 z 2 :x + z 2 )</p><p>The first two first-order rules are easily taken care of. For the third, we use the precedence &gt; F rec to eliminate the rec operator. But the computation fails, since there is no higher-order subterm of x y to take care of the righthand side subterm z:x + z. map(nil; X) ! nil map(cons(x; l); X) ! cons(@(X; x); map(l; X))</p><p>Using the same ordering on types as prewviously, the first rule is trivially taken care of by gcase 1. For the second, let map 2 Mul and map &gt; F cons.</p><p>Since map &gt; F cons, applying case 2, we need to show that map(cons(x; l); X) horpo @(X; x) and map(cons(x; l); X) horpo map(l; X). The latter is true by case 3, since cons(x; l) horpo l by case 1. The first is by case 5 (note the use of the equivalence on sorts), as X is an argument of the first term and cons(x; l) horpo x by case 1.</p><p>Considering now a polymorphic version of the same example, with S = fListg, S 8 = f g, and F = fcons : ! List ! List; map : List ( ! ) ! Listg, then the computation fails since X(x) has now type which cannot be compared to the sort List.</p><p>We can however reformulate this example by using a sort constructor List : ! . Assuming List( ) &gt; TS in our ordering (see section ??), the computation goes exactly as previously.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Properties of the higher-order recursive path ordering</head><p>Theorem 3.2 horpo is a decidable, polymorphic, higher- order reduction ordering.</p><p>Monotonicity, stability under substitutions and polymorphism are proved by induction on the size of terms. Although the proofs are slightly more difficult technically than the usual proofs for the recusive path ordering, they follow the same kind of pattern (polymorphism was actually never considered before). This contrasts with the proof of wellfoundedness and compatibility with -reductions, for which we need to show that the relation ?! = horpo ?! is strongly normalizing.</p><p>The well-foundedness of the recursive path ordering is usually proved by using the fact that it contains the embedding relation which is a well-order by Kruskal's tree theorem. Since we do not know of any non-trivial extension of Kruskal's tree theorem for higher-order terms that includes -reductions, we will adopt a completely different method, the computability predicate proof method due to Tait and Girard. As a bi-product, we obtain a new proof of wellfoundedness for the recursive path ordering on first-order terms. Indeed, this proof method will also suggest improvements of our ordering, that will be discussed in Section 4. We give no more than the necessary details for the understanding of the reader.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Candidate Terms</head><p>Types will be interpreted by sets of terms which may not be typable in the type system of figure ??. They are however typable in an extended type system described by tyhe following rules:</p><p>Variables:</p><p>x : 2 ? ? `x : C Functions:</p><p>F : 1 : : : n ! 2 F ? `t1 : C 1 : : : ? `tn : C n ? `F(t 1 ; : : : ; t n ) : C Abstraction:</p><p>? fx : g `t : C ? `( x : :t) : C ! Application:</p><p>? `s : C ! ? `t : C 0 9 2 T S TS TS 0 ? `s(t) : C Terms typable in this type system are called candidate terms.</p><p>The following two properties of the above type system are straightforward: Proof: We can try to prove that every term typable in the above system is typable in the intersection type system.</p><formula xml:id="formula_3">Lemma 3.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Candidate interpretations of ground types</head><p>Our definition of computability for candidate terms of a ground type is standard, but we make sure that computability is compatible with the equivalence = TS on types. Tech- nically, we will denote by k k the computability predicate of the type , which, by construction, will be equal to the predicate k k for any type = TS . Definition 3. <ref type="bibr" target="#b5">6</ref> The family of candidate interpretations fk kg 2TS is the family of sets of candidates whose elements are the least sets satisfying the following properties: (i) A variable of type belongs to k k; (ii) If is a data type, then s : C 2 k k iff 8t : such that s ?! t, then t 2 k k;</p><p>(iii) If s : C = 1 ! : : : ! n ! , where n &gt; 0 and is a data type, then s 2 k k if @(s; t 1 ; : : : ; t n ) 2 k k for all t 1 2 k 1 k; : : : ; t n 2 k n k;</p><formula xml:id="formula_4">(iv) If TS , then k k k k.</formula><p>A candidate term s of ground type is said to be computable if s 2 k k. A vector s of terms is computable iff so are all its components. A term is neutral if it is not an abstraction.</p><p>The above definition is based on an induction on the type ordering, which is well-founded by assumption, and, for each type, on a fixpoint computation. By an "induction on the definition of the candidate interpretations", we will mean a first induction on the type ordering, followed (in the sense of a lexicographic composition) by a second induction on the fixpoint computation. A straightforward consequence of the fact that the candidate interpretations are defined as fixpoints, is that the set k k is inhabited by terms of type such that TS .</p><p>In the sequel, we will always assume that is a data type and n &gt; 0 when writing = 1 ! : : : ! n ! .</p><p>We first recall the properties of the interpretations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Property 3.7 (Computability Properties)</head><p>(i) Every computable term is strongly normalizable;</p><p>(ii) Assuming that t is computable and t ?! s, then s is computable;</p><p>(iii) A neutral term t is computable iff s is computable for all s such that t ?! s;</p><p>(iv) If t be a vector of at least two computable terms, then @(t) is computable;</p><p>(v) x : :u is computable iff ufx 7 ! wg is computable for every computable term w : = TS ; (vi) A term t whose type is a sort is computable iff it is strongly normalizable.</p><p>Proof: All proofs are standard with minor modifications.</p><p>(i). Let s 2 k k. The proof that s is strongly normalizable is by induction on the definition of the interpretations.</p><p>If s is a variable, it is strongly normalizable. If s 2 k k for some such that &gt; TS , then s is SN by induction hypothesis. Otherwise, assuming is a data type, all reducts of s are either of a smaller type, or of an equivalent type, hence are SN by induction hypothesis, and therefore, so is s.</p><p>If = 1 ! : : : ! n ! given n variables x 1 ; : : : ; x n of respective types 1 ,. . . , n , then @(s; x) 2 k k by definition of k k, hence @(s; x) is SN by induction hypothesis, and therefore its subterm s is SN.</p><p>(ii) Assume that s 2 k k and s ?! t : . We show that t 2 k k by induction on the ordering on types. If s 2 k k for some type such that &gt; TS , then the properties follows by induction hypothesis. Otherwise, if is a data type, then the properties follows by definition. Finally, if is a functional type 1 ! : : : ! n ! , and therefore, = 1 ! : : : ! n ! , with i TS i and TS by condition (i) on types. Since s is computable, given n terms u 1 2 k 1 k; : : : ; u n 2 k n k, @(s; u 1 ; : : : ; u n ) 2 k k, hence, by induction hypothesis, @(t; u 1 ; : : : ; u n ) 2 k k. Since k i k k i k, this proves that t 2 k k.</p><p>(iii) Since the only if part is property (ii), we prove the if part. Let t 2 k k. As previously, the only nonstraightforward case is when t has type = 1 ! : : : ! n ! , where n &gt; 0 and is a data type. We will use, as previously, condition (i) on types, without mentionning it. Given n terms u 1 2 ksigma 1 k; : : : ; u n 2 k n k, we use induction on their multiset ordered by ?! mul , which is well-founded by property (i). Since the term @(t; u 1 ; : : : ; u n ) is neutral, and of a data type, it will be in k k if all its reducts are. Now, its reducts are of the form @(t; u 1 ; : : : ; v i ; : : : ; u n ) where v i is a reduct of u i , and hence this term is computable by the induction hypothesis, or of the form @(s; u 1 ; : : : ; u n ) where s is a reduct of t, and therefore @(s; u 1 ; : : : ; u n ) is computable by the definition. Hence, t is computable.</p><p>(iv) straigtforward.</p><p>(v) The only if part is Property 3.7 (ii). For the converse, we prove that @( x:u; w) is computable for an arbitrary term w : if ufx 7 ! wg and w are computable. Since variables are computable, u = ufx 7 ! xg is computable by assumption. By property (i), u and w are strongly normalizable. We prove that @( x:u; w) is computable by induction on the set fu; wg ordered by (?!) mul .</p><p>By (iii), the neutral term @( x:u; w) is computable iff v is computable for all v such that @( x:u; w) ?! v. There are several cases to be considered.</p><p>1. Let v = @( x:u 0 ; w) with u ?! u 0 . Then, ufx 7 ! wg ?! u 0 fx 7 ! wg. Hence, by assumption and (ii), u 0 fx 7 ! wg is computable for every computable w : . Since fu; wg(?!) mul fu 0 ; wg, by induction hypothesis, v is computable.</p><p>2. Let v = @( x:u; w 0 ) with w ?! w 0 . Then fu; wg(?!) mul fu; w 0 g, and by induction hypothesis, v is computable.</p><p>3. v = ufx 7 ! wg is computable by assumption.</p><p>4. Let t = @( x:u; w) horpo v = @(v 0 ; w 0 ) by case 6.</p><p>For typing reasons, w horpo w 0 and x:u horpo v 0 . Hence, w 0 is computable by (ii). On the other hand, by property of the ordering, v 0 = x:u 0 with u horpo u 0 . Now, since ufx 7 ! wg is computable for every computable w : by assumption, u 0 fx 7 ! wg is computable for every computable w : by (ii). Hence</p><p>x:u 0 is computable, and therefore v is computable. 2</p><p>The following lemma and proof are both essential: For the following two cases, s = f(s), with s i : i . 3. If f(t) horpo s by case 3, then t( horpo ) mul s. By definition of the multiset comparison, for every s i 2 s there is some t j 2 t, s.t. t j horpo s i , hence, by Property 3.7 (ii), s i is computable. This allows us to conclude by the outer induction hypothesis that s is computable.</p><formula xml:id="formula_5">Property</formula><p>4. If f(t) horpo s by case 4, then t( horpo ) lex s and for every s i 2 s or t j horpo s i for some t j 2 t. As in the precedence case, this implies that s is computable. Then, since t( horpo ) lex s, s is computable by the outer induction hypothesis.</p><p>5. If f(t) horpo s by case 5, let @(s 1 ; : : : ; s n ) be the partial left-flattening of s used in that proof. By the same token as in case 2, every term in s is computable, hence s is computable by Property 3.7 (iv).</p><p>2 Lemma 3.9 Let be a computable substitution and t be an algebraic -term. Then t is computable.</p><p>Proof: The proof proceeds by induction on jtj v . </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>We can now easily conclude the proof of well-foundedness and compatibility with -reductions needed for our main theorem, by showing that every term is strongly normalizable with respect to ?!. Given an arbitrary term t, let be the identity substitution. Since is computable, t = t is computable by Lemma 3.9, and strongly normalizable by Property 3.7 (i).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Polymorphic types</head><p>We simply relate polymorphic types to ground types via a ground type instantiation. This uses properties (ii) of the type ordering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">Examples</head><p>The following example gives a set of rewrite rules defining the insertion algorithm for the (ascending or descending) sort of a list of natural numbers. max(0; x) ! x max(x; 0) ! x max(s(x); s(y)) ! s(max(x; y)) min(0; x) ! 0 min(x; 0) ! 0 min(s(x); s(y)) ! s(min(x; y))</p><p>We simply need the precedence max; min &gt; F 0 for these first-order rules. insert(n; nil; X; Y ) ! cons(n; nil) insert(n; cons(m; l); X; Y ) ! cons(X(n; m); insert(Y (n; m); l; X; Y ))</p><p>The first insert rule is easily taken care of by applying case 2 with the precedence insert &gt; F cons, and then case 1. For the second insert rule, we apply first case 2, and we recursively need to show: firstly, that insert(n; cons(m; l); X; Y ) horpo @(X; n; m), which follows by applying rule 2, and then case 1 recursively; and secondly that insert(n; cons(m; l); X; Y ) horpo insert(Y (n; m); l; X; Y ), which succeeds as well by case 4, with a right-to-left lexicographic status for insert, and calling recursively with insert(n; cons(m; l); X; Y ) horpo @(Y; n; m), which is solved by case 6. sort(nil; X; Y ) ! nil sort(cons(n; l); X; Y ) ! insert(n; sort(l; X; Y ); X; Y ) Again, these rules are easily oriented by horpo , by us- ing the precedence sort &gt; F insert. On the other hand, horpo fails to orient the following two seemingly easy rules.</p><p>ascending sort(l) ! sort(l; xy:min(x; y); xy:max(x; y)) descending sort(l) ! sort(l; xy:max(x; y); xy:min(x; y)) This is so, because the term xy:min(x; y) occuring in the lefthand side has type IN ! IN ! IN, which is not comparable to any lefthand side type. We will come back to this example in Section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">The ordering on types 4 Computational Closure</head><p>The ordering is quite sensitive to innocent variations of the language, like adding (higher-order) dummy arguments to righthand sides, or -converting expressions. We will now solve these problems by improving our definition in the light of the strong normalization proof. In that proof, it was crucial to show the computability of the righthand side subterms by using the lefthand side subterms. In our definition, we actually require that for each righthand side subterm v, there exists a lefthand side subterm u such that u horpo v. Assuming u is computable, then v is computable by Property 3.7 (ii). But any computability preserving operation applied to the lefthand side subterms in order to construct a term of the appropriate type would do as well. For example, the higher-order variable X is computable if and only if x:X(x) is computable. Therefore, both forms may coexist. This discussion is formalized below with the notion of a computational closure adapted from <ref type="bibr" target="#b2">[3]</ref>. Definition 4.1 Given a term t = f(t), we define its computable closure CC(t) as CC(t; ;), where CC(t; V), with V \ Var(t) = ;, is the smallest set of well-typed terms containing all variables in V and all terms in t, as well as their subterms u : such that is a sort and Var(u) Var(t), and closed under the following operations:</p><p>1. precedence: let g such that f &gt; F g, and s 2 CC(t; V); then g(s) 2 CC(t; V); 2. recursive call: let s be a sequence of terms in CC(t; V) such that f(s) is well typed, Var(s) Var(t) and t(?! ) stat f s; then f(s) 2 CC(t; V);</p><p>3. application: let s : 1 ! : : : ! n ! 2 CC(t; V) and u i : i 2 CC(t; V) for every i 2 1::n]; then @(s; u 1 ; : : : ; u n ) 2 CC(t; V);</p><formula xml:id="formula_6">4. abstraction: let x =</formula><p>2 Var(t) V and s 2 CC(t; V fxg); then x:s 2 CC(t; V); 5. reduction: let u 2 CC(t; V), and u ?! v; then v 2 CC(t; V).</p><p>Note the conditions Var(u) Var(t) in the basic case, and Var(s) Var(t) in case 2. These two conditions are one of the main weaknesses of our definition.</p><p>Apart from the reduction rule, membership to the computation closure of a term may not be decidable. On the other hand, it becomes easily decidable if the use of the reduction rule is bounded.</p><p>The following property can easily be shown by induction on the definition of the computable closure: Lemma 4.2 Assume that u 2 CC(t). Then, u 2 CC(t ) for every substitution .</p><p>We can now modify our ordering as follows: Definition 4.3 s : horpo t : iff and 1. s = f(s) with f 2 F, and s i horpo t for some s i 2 s. 2. f; g 2 F, f &gt; F g and t = g(t) and 8t i 2 t either s horpo t i or s j horpo t i for some s j 2 s or t i 2 CC(s) As previously, the or occuring in the clause s horpo t i or s j horpo t i for some s j 2 s or t i 2 CC(s)</p><p>is non-deterministic. Again, we can make it deterministic by approriately ordering the clauses.</p><p>The following lemma is easy to prove: Lemma 4.4 horpo is monotonic, stable, and polymor- phic.</p><p>We now show that terms in the computable closure of a term are computable under the appropriate hypotheses for its use. For this, we first remark that the computability properties are still valid, without any change in the proofs. Property 4.5 Assume t : is computable, as well as every term g(s) with s computable and g(s) smaller than t = f(t) in the ordering h&gt; F ; (?! ) stat i operating on pairs hf; ti where stat is the status of f. Then, every term in CC(t) is computable.</p><p>The precise formulation of this statement arises from its forthcoming use inside the proof of Lemma 4.6. Note that we have increased the ordering (?!) stat used in the proof of lemma 3.8 by adding strict subterm, yielding the ordering (?! ) stat . This is possible, because the latter is wellfounded on a given set of terms when so is the former, since ?! has just be shown to be monotonic, see <ref type="bibr" target="#b6">[7]</ref> for the argument.</p><p>Proof: We prove that u is computable for every computable substitution of domain V and every u 2 CC(t; V) such that V \ Var(t) = ;. We obtain the result by taking V = ;. The proof is by induction on the definition of the computational closure. For the basic case: if u 2 t, we conclude by assumption that t is computable since u = u by assumption on V; if u 2 V, then u is computable by assumption on ; otherwise, u is a subterm of type a sort of some v 2 t. As before, v = v is computable, hence is normalizable by <ref type="bibr">Property 3.7 (i)</ref>. By definition of the closure, u = u, therefore, since v is strongly normalizable, by monotonicity, u is also strongly normalizable, and hence computable by <ref type="bibr">Property 3.7 (vi)</ref>. We now discuss the successive operations to form the closure.</p><p>1. case 1: u = g(u) where u 2 CC(t; V). By induction hypothesis, u is computable, and, by assumption, since f &gt; F g, u is computable.</p><p>2. case 2: u = f(u) where u 2 CC(t; V) and Var(u) Var(t). By induction hypothesis, u = u is computable, and, by assumption, since t(?! ) stat f u, u = u is computable.</p><p>3. case 3: by induction and Property 3.7 (iv).</p><p>4. case 4: let u = x:s with x 6 2 Var(t) V and u 2 CC(t; V fxg). By induction hypothesis, s( fx 7 ! wg) is computable for an arbitrary computable w, and by Property 3.7 (v), ( x:s) is computable.</p><p>5. case 5. By Property 3.7 (ii).</p><p>2</p><p>We now restate Property 3.8 and show in one case how the proof makes use of Property 4.5.</p><p>Property 4.6 Let f 2 F and let t be a set of terms. If t is computable, then f(t) is computable.</p><p>Proof: We prove that f(t) is computable by an outer induction on the pair hf; ti ordered lexicographically by the ordering (&gt; F ; (?! ) stat ) lex introduced in Property 4.5, and an inner induction on the size of the reducts of t. Since the proof is similar to the proof of Property 3.8, we do only case 2.</p><p>2. Let t = f(t) horpo s by case 2. Then s = g(s), f &gt; F g and for every s i 2 s either t horpo s i or t j horpo s i for some t j 2 t and s i is computable as in the proof of Property 3.8, or s i 2 CC(t), and then, by induction hypothesis, we can apply Property 4.5 and conclude that s i is computable.</p><p>2 Theorem 4.7 horpo is included in a polymorphic higher- order reduction ordering.</p><p>Proof: Thanks to Property 4.5, the strong normalization proof of this improved ordering is exactly the same as previously. Then by Lemma 4.4 we conclude that the transitive closure of horpo is a higher-order polymorphic reduction ordering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>This new definition is much stronger than the previous one. In addition to prove the strong normalization property of the remaining rules of the sorting example, and for the same reason, we can easily also add the following rule to the other rules of Example 1:</p><formula xml:id="formula_7">Example 4 n m ! rec(n; 0; z 1 z 2 :m + z 2 )</formula><p>This additional rule can be proved terminating with the precedence: &gt; F frec; +; 0g, since z 1 z 2 :m + z 2 2 CS(n m): by base case, m and z 2 belong to CC(n m; fz 1 ; z 2 g), hence m+z 2 2 CC(n m; fz 1 ; z 2 g) by case 1 of the definition of the computational closure. Applying case 4 twice yields then the result.</p><p>We end this section with two examples showing the current limits of our ordering. The first one is an example about process algebra, in which a quantifier ( ) binds variables via the use of a functional argument, that is, an abstraction: Example 5 (taken from <ref type="bibr" target="#b4">[5]</ref>) Let S = fproc; datag, F = f+ : proc proc ! proc; : proc proc ! proc; : proc; : (proc ! proc) ! proc)g. The rules are the following:</p><p>x + x ! x (x + y) z ! (x z) + (y z) (x y) z ! x (y z) x + ! x x ! ( y:x) ! x ( y:P(y)) + P(D) ! ( y:P(y)) ( y:P(y) + Q(y)) ! ( y:P(y)) + ( y:Q(y))</p><p>( y:P(y)) x ! ( y:P(y) x)</p><p>All rules but the last one can be oriented. This is quite surprising, since due to the fact that no application occurs in the example, it seems that proving its termination should be simple. We will come back to this example in Section 5. 3.</p><p>Example 6 (inspired by <ref type="bibr" target="#b12">[13]</ref>) Let S = fListg, S 8 = f g, F = fnil : List; cons : List ! List; fcons : ( ! ) ! List; dapply : ( ! ) ( ! ) !</p><p>; lapply : List ! g. The rules are the following: dapply(x; F; G) ! F(G(x)) lapply(x; nil) ! x lapply(x; cons(F; L)) ! F(lapply(x; L))</p><p>We can easily prove the first two rules, which do not even need the closure. For the third, we face the problem that F is not in the closure of the lefthand side, as a higher-order variable occuring inside a strict subterm of a lefthand side argument. This is important, as shown in <ref type="bibr" target="#b9">[10]</ref>, where a nonterminating example is constructed by using such a deep variable. We will come back to this problem in Section 5. 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Discussion</head><p>Our definition of the higher-order recursive path ordering can be improved again in several different ways that we discuss in turn.</p><p>1. By replacing the condition s j horpo t i for some s j 2 s or t i 2 CC(s) in cases 2 and 4 of the definition of the improved higher-order recursive path ordering by the weaker condition u horpo t i for some u 2 CC(s).</p><p>This extension does not complicate the proofs, but seems of little practical value while increasing the complexity of the computation.</p><p>2. By replacing the condition u ?! v in case 5 of the definition of the computable closure, by the weaker condition u ?! horpo v. This variant will result in important complications in the proofs, since, with this modification, the ordering and the computational closure become mutually inductive definitions. We plan to study it for two reasons. Firstly, because it may yield a transitive relation; transitivity is essentially a matter of aesthetics, of course, since well-foundedness does not rely on transitivity. Secondly, and this second reason is more important, because of the potential practical improvement that it may provide.</p><p>3. In our ordering, all arrow type terms are treated as if they could become applied and serve in a -reduction. This makes it difficult to prove the termination of rules whose righthand side has arrow type subterms which do not occur as lefthand side arguments. In such a case, the use of the computable closure may sometimes help, but Example 5 shows that this is not always the case.</p><p>In this example, the righthand side arrow type subterm y:P(y) x is treated as if it could be applied, but it will never be. We have already studied a solution to this problem that will be part of a full version of this paper. The idea is to split the set of function symbols in two subsets: those for which case 6 can be used (that is, which are greater than application) and all the others. For the first subset, the same condition as now for its arrow type subterms must be required, since by applying case 6 this subterms can occur as first argument of an application; for the second subset, however, this will never occur and hence the conditions can be relaxed.</p><p>4. The set of types is generated from a set of sort constants. We plan to use an algebra of sort terms instead, allowing us to have sort constructors, resulting in polymorphic data structures such as lists of elements of an arbitrary type. This should allow us to extend the computable closure of a term t whose type is a sort term s, by taking any immediate subterm u whose type is a subterm of s. For an example, the higher-order variable F of example 6 would be in the closure of lapply(x; cons(F; L)). We even believe that any subterm of t whose type is a subterm of s would do, but this has to be checked.</p><p>5. As important, is the development of an ordering able to compare terms of the calculus of constructions. Such an ordering is easily obtained by adding a new clause ensuring monotonicity of dependent products, in the same way as case 7 for abstractions. The difficulty then is to show the compatibility of the ordering with the reduction relation of the calculus, because the ob-tained extension of the calculus of constructions becomes dependent on the ordering via its conversion rule. As a consequence, it becomes impossible to separate strong normalization, confluence and subject reduction. Since similar problems have been encountered in the past when investigating other extensions of the calculus of constructions, such an extension should not be out of hands.</p><p>6. Another important question is whether these techniques apply for proving termination of rules operating on higher-order terms in -long -normal form. We have already studied the question, and the answer is affirmative. As an aplication of the present work, we have obtained such an ordering which significantly improves the few attempts that we know of <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b10">11]</ref>.</p><p>In particular, none of them was able to order automatically the recursor for natural numbers, which we can do easily. On the other hand, the obtained ordering is not fully polymorphic as the one described here, and we are still working on an improved fully polymorphic version.</p><p>7. Finally, we plan to apply the same technique to other orderings operating on first-order terms, either to variants of the recursive path ordering such as its associative commutative versions <ref type="bibr" target="#b18">[19]</ref>, or to stronger ordinal notations, such as quasi ordinal diagrams <ref type="bibr" target="#b15">[16]</ref>. We believe that the first extension should not be too difficult.</p><p>The second is likely to work as well, since we do not rely on the subterm property for the strong normalization proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>We have defined a powerful mecanism for defining orderings operating on higher-order terms. Based on the notion of the computable closure of a term, we have succeeded to define a conservative extension of Dershowitz's recursive path ordering, which is indeed a polymorphic reduction ordering compatible with -reductions. To our knowledge, this is the first such ordering ever.</p><p>The idea of the computable closure is also used in a different context in <ref type="bibr" target="#b2">[3]</ref>. The goal there is to define a syntactic class of higher-order rewrite rules that are compatible with beta reductions and with recursors for arbitrary positive inductive types. The language is indeed the calculus of inductive constructions generated by a monomorphic signature. The usefulness of the notion of closure in this different context shows the strength of this concept.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>This work was partly supported by the ESPRIT Basic Research Action CCL-II, ref. WG # 22457. and the CICYT project HEMOSS ref. TIC98-0949-C02-01</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>is called a first-order signature if all its type declarations are first-order, and a higher-order signature otherwise. It is called a polymorphic signature if some type declaration is polymorphic, and a monomorphic signature otherwise. Given a type substitution extending to types a mapping from S 8 to T S , we denote by F the monomorphic signature ff : s 1 ! s 2 ! : : : ! s n j f : s 1 ! s 2 !</figDesc><table><row><cell>F 1 ::: n!</cell></row><row><cell>1;:::; n;</cell></row></table><note><p>F : : : ! s n 2 Fg. Polymorphic signatures capture infinitely many monomorphic ones via type instantiation.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>The subterm of t at position p is denoted by tj p , and we write t tj p . The result of replacing tj p at position p in t by u is denoted by t u] p . We use t u] to indicate that u is a subterm of t, and simply t ] p for a term with a hole, also called a context. The notation s will be ambiguously used to denote a list, or a multiset, or a set of terms s 1 ; : : : ; s n . Substitutions are written as in fx 1 7 ! t 1 ; : : : ; x n 7 ! t n g where, for every i 2 1::n], t i is assumed different from x i .</figDesc><table /><note><p><p>Terms are identified with finite labeled trees by considering x:, for each variable x, as a unary function symbol.</p>By jtj we denote de size of t, i.e. the number of symbols occurring in t, and by jtj v , the size of t without counting the variables. Positions are strings of positive integers. and denote respectively the empty string (root position) and the concatenation of strings. The latter may sometimes be omitted.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>term s rewrites to a term t at position p with the rule l ! r is a redex in s, and t is the reduct of s. Irreducible terms are said to be in R-normal form. A substitution is in R-normal form if x is in R-normal form for all x. We denote by ?! R the reflexive, transitive closure of the rewrite relation ?! R , and by ! R its reflexive, sym-It is confluent if s ?! u and s ?! v implies that u ?! t and v ?! t for some t.</figDesc><table><row><cell>and the substitution , written s p ?! l!r t, or simply s ! R t, if sj p = l and t = s r ] p . A term s such that s p ?! R t is called reducible (with re-spect to R). sj p metric, transitive closure. We are actually interested in the relation ?! R = ?! R ?! . Given a rewrite relation ?!, a term s is strongly normal-</cell></row><row><cell>izing if there is no infinite sequence of rewrites issuing from s. The rewrite relation itself is strongly normalizing, or ter-</cell></row><row><cell>minating, if all terms are strongly normalizing, in which</cell></row><row><cell>case it is called a reduction.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>Let S = fINg, S 8 = f g and F = f0 : IN; s : IN ! IN; rec : IN (IN ! ! ) ! g. Gödel's recursor for natural numbers is defined by the following rewrite rules:</figDesc><table><row><cell>Example 1</cell><cell></cell><cell></cell></row><row><cell cols="3">cases 2, 4, and 5, the non-deterministic or comparison of proposition A can be replaced by the equivalent deter-</cell></row><row><cell cols="2">ministic one:</cell><cell></cell></row><row><cell>if t i :</cell><cell>thens horpo t i otherwise s j horpo</cell><cell>t i for some s j : 2 s such that</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>It is easy to see that the set of candidate terms is closed under -reductions. Similarly, our ordering applies to candidate terms as well, by keeping the same definition.</figDesc><table><row><cell>Lemma 3.5 Candidate terms are strongly normalizable</cell></row><row><cell>with respect to -reductions.</cell></row></table><note><p>3 Every candidate has a unique type derivation in a given environment ?. Lemma 3.4 Given an environment ?, if ? `s : then ? `s : C .</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>3.8 Let f 2 F and let t be a set of terms. If t is computable, then f(t) is computable. Proof: Let t i : i and f(t) : . Since terms in t are computable, by Property 3.7 (i), they are strongly normalizable. We use this remark to build our induction argument: we prove that f(t) is computable by induction on the pair hf; ti ordered lexicographically by F ; (?!) stat ) lex where stat is either mul or lex, depending on the symbol f. . By Property 3.7 (ii), t 0 i is computable, and since t(?!) stat s for any status stat, s is computable by application of the outer induction hypothesis. We are left with the cases corresponding to the application of horpo to the term s. 1. Let f(t) horpo s by case 1, hence t i horpo s for some t i 2 t. Since t i is computable, s is computable by Property 3.7 (ii). 2. Let t = f(t) horpo s by case 2. Then s = g(s), f &gt; F g and for every s i 2 s either t horpo s i , in which case s i is computable by the inner induction hypothesis, or t j horpo s i for some t j 2 t and s i is</figDesc><table><row><cell>Since f(t) is neutral, by Property 3.7 (iii), it is com-putable iff every s such that f(t) ?! s is computable, which we prove by an inner induction on the size of s. Let us assume first that s = f(t 1 ; : : : ; t 0 i ; : : : ; t n ), with t i ?! t 0 i</cell></row></table><note><p>computable by Property 3.7 (ii). Therefore, s is computable, and since f &gt; F g, s is computable by the outer induction hypothesis.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>1. t is a variable x. Then x is computable by assumption.2. t is an abstraction x:u. By Property 3.7 (v), t is computable if u fx 7 ! wg is computable for every well-typed computable term w. Taking = fx 7 ! wg, we have u fx 7 ! wg = u( fx 7 ! wg) since x may not occur in . Since is computable, and jtj v &gt; juj v , by induction hypothesis, u is computable.3. t = @(t 1 ; t 2 ) or t = f(t 1 ; : : : ; t n ), and some t i is not a variable. Let s = f(x 1 ; : : : ; x n ) or s = @(x 1 ; x 2 ) and = fx i 7 ! t i j 1 i ng. By induction hypothesis t i is computable for all i, hence is computable. Since not all t i are variables, jtj v &gt; jsj v and, by induction hypothesis s is computable. 4. t = @(x 1 ; x 2 ). Then t is computable by Property 3.7</figDesc><table><row><cell>(iv).</cell></row><row><cell>5. t = f(x 1 ; : : : ; x n ). Then t is computable by Prop-</cell></row><row><cell>erty 3.8.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Example 3</head><label>3</label><figDesc>Insertion Sort. Let S = fIN; Listg and F = fnil : List; cons : IN List ! List; max; min : IN IN ! IN; insert : IN List (IN IN ! IN) (IN IN ! IN) ! List; sort : List (IN IN ! IN) (IN IN ! IN) ! List; ascending sort; descending sort : List !</figDesc><table><row><cell>Listg.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head></head><label></label><figDesc>3. f = g 2 Mul and s( horpo ) mul t 4. f = g 2 Lex and s( horpo ) lex t, and 8t i 2 t either s horpo t i or s j horpo t i for some s j 2 s or t i 2 CC(s)5. f 2 F, @(t) is some partial left-flattening of t, and 8t i 2 t either s horpo t i or s j horpo t i for some s j 2 s or t i 2 CC(s)6. s = @(s 1 ; s 2 ), t = @(t 1 ; t 2 ) and fs 1 ; s 2 g( horpo ) mul ft 1 ; t 2 g 7. s = x:u and t = x:v and u horpo v</figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments:</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Handbook of Theoretical Computer Science, volume B, chapter Functional Programming and Lambda Calculus</title>
		<author>
			<persName><forename type="first">H</forename><surname>Barendregt</surname></persName>
		</author>
		<editor>J. van Leeuwen</editor>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="321" to="364" />
			<pubPlace>North-Holland</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Handbook of Logic in Computer Science, chapter Typed lambda calculi</title>
		<author>
			<persName><forename type="first">H</forename><surname>Barendregt</surname></persName>
		</author>
		<editor>Abramsky et al.</editor>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>Oxford Univ. Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The Calculus of Algebraic Constructions</title>
		<author>
			<persName><forename type="first">F</forename><surname>Blanqui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Jouannaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Okada</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Tenth Int. Conf. on Rewriting Techniques and Applications</title>
		<meeting><address><addrLine>Trento</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
	<note>To appear in</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Type Theory and Programming</title>
		<author>
			<persName><forename type="first">T</forename><surname>Coquand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Nordström</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Sydow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EATCS Bulletin</title>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="203" to="228" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Strict functionals for termination proofs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Van De Pol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Schwichtenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Typed Lambda Calculi and Applications</title>
		<meeting><address><addrLine>Edinburgh</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">902</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Orderings for term rewriting systems</title>
		<author>
			<persName><forename type="first">N</forename><surname>Dershowitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="279" to="301" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Rewrite systems</title>
		<author>
			<persName><forename type="first">N</forename><surname>Dershowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Jouannaud</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Van Leeuwen</surname></persName>
		</editor>
		<meeting><address><addrLine>North-Holland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">B</biblScope>
			<biblScope unit="page" from="243" to="309" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Theorem proving modulo</title>
		<author>
			<persName><forename type="first">G</forename><surname>Dowek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Hardin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kirchner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
	<note>Rapport de recherche INRIA 3400</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">The coq proof assistant user&apos;s guide version 5.6. INRIA Rocquencourt and ENS Lyon</title>
		<author>
			<persName><forename type="first">G</forename><surname>Dowek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Felty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Herbelin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Huet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Paulin-Mohring</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Werner</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Abstract data type systems</title>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Jouannaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Okada</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">173</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="349" to="391" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Rewrite orderings for higherorder terms in -long -normal form and the recursive path ordering</title>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Jouannaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rubio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">208</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="3" to="31" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">A Recursive Path Ordering for Higher-Order Terms in -Long -Normal Form</title>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Jouannaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rubio</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Termination of combined (rewrite and -calculus) systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Loría-Sáenz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Steinbach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd Int. Workshop on Conditional Term Rewriting Systems, Pont-à-Mousson</title>
		<meeting>3rd Int. Workshop on Conditional Term Rewriting Systems, Pont-à-Mousson</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">656</biblScope>
			<biblScope unit="page" from="143" to="147" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A termination ordering for higher order rewrite systems</title>
		<author>
			<persName><forename type="first">O</forename><surname>Lysne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Piris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 6th Rewriting Techniques and Applications</title>
		<meeting>6th Rewriting Techniques and Applications<address><addrLine>Kaiserslautern; Kaiserslautern, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">914</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Higher-order rewrite systems and their confluence</title>
		<author>
			<persName><forename type="first">R</forename><surname>Mayr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Nipkow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">192</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="29" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">On the theory of quasi ordinal diagrams</title>
		<author>
			<persName><forename type="first">M</forename><surname>Okada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Takeuti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic and Combinatorics</title>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">G</forename><surname>Simpson</surname></persName>
		</editor>
		<imprint>
			<publisher>American Mathematical Society</publisher>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Isabelle: the next 700 theorem provers</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Paulson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic and Computer Science</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Odifreddi</surname></persName>
		</editor>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Elf: A language for logic definition and verified meta-programming</title>
		<author>
			<persName><forename type="first">F</forename><surname>Pfenning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 4th IEEE Symp. Logic in Computer Science</title>
		<meeting>4th IEEE Symp. Logic in Computer Science</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="313" to="322" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A fully syntactic AC-RPO</title>
		<author>
			<persName><forename type="first">A</forename><surname>Rubio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Tenth Int. Conf. on Rewriting Techniques and Applications</title>
		<meeting><address><addrLine>Trento</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
	<note>To appear in</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
