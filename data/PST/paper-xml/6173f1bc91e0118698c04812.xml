<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">PDede: Partitioned, Deduplicated, Delta Branch Target Buffer</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Niranjan</forename><surname>Soundararajan</surname></persName>
							<email>niranjan.k.soundararajan@intel.com</email>
						</author>
						<author>
							<persName><roleName>Tanvir</roleName><forename type="first">Peter</forename><surname>Braun</surname></persName>
							<email>pvbraun@ucsc.edu</email>
						</author>
						<author>
							<persName><forename type="first">Tanvir</forename><forename type="middle">Ahmed</forename><surname>Khan</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Heiner</forename><surname>Litz</surname></persName>
							<email>hlitz@ucsc.edu</email>
						</author>
						<author>
							<persName><forename type="first">Ahmed</forename><surname>Khan</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Baris</forename><surname>Kasikci</surname></persName>
							<email>barisk@umich.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="laboratory">Architecture Research Lab</orgName>
								<orgName type="institution">Intel Labs</orgName>
								<address>
									<country key="IN">India</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Santa Cruz</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">University of Michigan</orgName>
								<address>
									<country>USA Baris Kasikci</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">University of Michigan</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Santa Cruz</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="laboratory">Architecture Research Lab</orgName>
								<orgName type="institution">Intel Labs</orgName>
								<address>
									<country key="IN">India</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">PDede: Partitioned, Deduplicated, Delta Branch Target Buffer</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/3466752.3480046</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2023-01-01T13:25+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Superscalar cores</term>
					<term>Branch Target Buffer</term>
					<term>Performance</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Due to large instruction footprints, contemporary data center applications suffer from frequent frontend stalls. Despite being a significant contributor to these stalls, the Branch Target Buffer (BTB) has received less attention compared to other frontend structures such as the instruction cache. While prior works have looked at enhancing the BTB through more efficient replacement policies and prefetching policies, a thorough analysis into optimizing the BTB's storage efficiency is missing. In this work, we analyze BTB accesses for a large number (100+) of frontend bound applications to understand their branch target characteristics. This analysis, provides three significant observations about the nature of branch targets: (1) a significant number of branch instructions have the same branch target, (2) a significant number of branch targets share the same page address, and (3) a significant percentage of branch instructions and their targets are located on the same page. Furthermore, we observe that while applications' address spaces are sparsely populated, they exhibit spatial locality within and across pages. We refer to these multi-page addresses as regions and we show that applications traverse a significantly smaller number of regions than pages. Based on these insights, we propose PDede, an efficient re-design of the BTB micro-architecture that improves storage efficiency by removing redundancy among branches and their targets. PDede introduces three techniques, (a) BTB Partitioning, (b) Branch Target Deduplication, and (c) Delta Branch Target Encoding to reduce BTB miss induced frontend stalls. We evaluate PDede across 100+ applications, spanning several usage scenarios, and show that it provides an average 14.4% (up to 76%) IPC speedup by reducing BTB misses by 54.7% on average (and up to 99.8%).</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>The CPU frontend bottleneck is a well-known performance problem across several usage scenarios including web-scale data center applications <ref type="bibr" target="#b4">[6,</ref><ref type="bibr" target="#b14">16,</ref><ref type="bibr" target="#b26">28,</ref><ref type="bibr" target="#b37">39,</ref><ref type="bibr" target="#b48">50]</ref>. Due to the large code footprints of these applications, the size of the instruction working set often exceeds the microarchitectural resources of contemporary processors, such as the instruction cache (Icache), the instruction translation lookaside buffer (ITLB), the branch direction predictor, and the branch target buffer (BTB). The inability of these components to deliver instructions fast enough to the processor leads to frontendstalls, significantly reducing the overall instructions per cycle (IPC) performance of a system. For instance, Google has reported that 23.5% of all CPU cycles are lost to frontend stalls for its Web search binary <ref type="bibr" target="#b6">[8]</ref>.</p><p>Prior work <ref type="bibr">[5, 7, 8, 16-18, 29, 31, 34-36, 39, 42, 43, 48, 49, 53, 58</ref>] has observed the significance of the frontend bottleneck and proposed instruction prefetching techniques to address it. By predicting the control flow of applications and prefetching instructions into the Icache, a steady flow of instructions can be provided to the CPU pipeline even when the instruction working set exceeds processor resources. While instruction prefetching is effective, it only addresses one aspect of the frontend challenge, namely Icache misses, however, branch target buffer (BTB) misses significantly contribute to frontend stalls as well. In particular, we find that the limited BTB capacity leads to a significant number of BTB misses, resulting in BTB-resteer events and pipeline flushes. Furthermore, until the BTB miss is detected, the processor executes wrong path instructions, potentially polluting the Icache and additional structures. Figure <ref type="figure">1</ref> shows a Top-Down analysis <ref type="bibr" target="#b55">[57]</ref> of over 100 frontend-bound applications, identifying BTB induced resteers are the largest contributor of frontend stalls accounting for over 40% of all frontend stall cycles. In addition to Icache misses, which has been the focus of most prior works, addressing the frontend latency bottleneck from BTB Figure <ref type="figure">1</ref>: Frontend stall and branch resteering for 100+ applications leveraging the Top-Down methodology <ref type="bibr" target="#b55">[57]</ref> captured on Skylake-like core.</p><p>resteers hence warrants a detailed analysis. To understand the nature of the BTB capacity problem, we perform a comprehensive study across these 100+ frontend-bound applications. We find that (1) frontend-bound applications with large code footprints, many libraries, and high branch frequencies span only 6% unique pages across all targets, in memory. <ref type="bibr" target="#b0">(2)</ref> There exist 30% duplicate branch targets among different branch instructions, and (3) the branch PC and the branch target are located in the same page in over 60% of all cases.</p><p>Based on our findings, we study several microarchitectural techniques to address the BTB capacity problem: (1) Branch Target Deduplication stores a single branch target shared by multiple branches only once to improve the storage efficiency of the BTB, translating into an IPC gain of 1.6%. (2) BTB Partitioning breaks the BTB into separate structures, each capturing different portions of the branch target. While prior works <ref type="bibr" target="#b44">[46]</ref> have explored partitioning, these studies lack a comprehensive analysis of branches and their targets, in particular, in the context of a modern aggressive OOO core. Our work contributes by introducing an improved partitioning technique (regions and pages) and recognizes the impact of a partitioned cache on the lookup latency by introducing and evaluating a twocycle lookup BTB. Our combined partitioning techniques result in an additional 5.3% IPC improvement. Finally, we propose (3) Delta Branch Target Encoding, a technique that further increases space efficiency by optimizing branches whose PC and target reside in the same page. For these branches, we derive the page and region address from the PC and hence only need to store the page offset of the target. This results in a significant reduction in the distinct number of pages stored in the BTB, further improving storage efficiency and providing an additional 2.5% IPC gain. With Delta Branch Target Encoding, we observe that supporting both branches with targets in the same page (referred to as same-page branches) and in a different page (referred as different-page branches) leads to less efficient use of the BTB storage. We propose and evaluate two different designs that make better use of the available storage. In the first PDede-Multi Target design, we opportunistically support multiple same-page branches targets within a single BTB entry. This novel technique dynamically packs multiple targets in the same BTB entry without increasing the overhead for additional tags. On top of the prior gains, packing multiple targets into a single entry provides an additional 2% IPC gain. In the second PDede-Multi Entry size design, we support both same-page and different-page branches by providing This results in a mean IPC speedup of 14.4% (up to 76%) across the wide range of (100+) modern CPU applications. Additionally, to provide similar mispredictions as the baseline BTB, PDede lowers the storage requirements by 50% highlighting the effectiveness of our changes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">BACKGROUND</head><p>Modern out-of-order (OOO) cores leverage superpipelining and superscalar execution to process hundreds of instructions simultaneously. To achieve high utilization of these pipelines, the processor frontend is required to deliver multiple instructions per cycle to the back-end of the core. One of the program characteristics that limit high utilization in the pipeline are branch instructions that determine the control path in the program flow. Branches typically get classified into,</p><p>• Conditional, Direct Branches such as loops and forward conditionals (if-then-else) that are executed based on a condition to determine the taken or not-taken branch direction. The target address is encoded as part of the instruction. • Unconditional, Direct Branches including function calls and constructs like goto that jump to a different address in the code. These branches are always taken and the target address is encoded as part of the instruction. • Unconditional, Indirect Branches including function calls and jumps for which the target location is unknown at compile time. These branches are also always taken.</p><p>Taken branches require the processor to fetch instructions starting from the branch target instead of just fetching the next sequential instruction. If the branch target is unknown, pipelines need to effectively stall, significantly reducing throughput <ref type="bibr" target="#b26">[28,</ref><ref type="bibr" target="#b38">40]</ref>. To address this challenge, processors support a branch target buffer (BTB) to predict the target address of all branch types discussed above. Figure <ref type="figure">2</ref> shows a typical fetch-directed instruction prefetching(FDIP) based OOO core as studied in this work. Every cycle, the frontend reads instructions from the Icache, decodes them, and forwards them to the functional units for execution. As seen in Figure <ref type="figure">2</ref>, decoding an instruction itself happens several cycles after it enters the pipeline and, as such, branches need to be accurately predicted well in advance to guarantee a steady flow of instructions.</p><p>If the BTB cannot provide the correct branch target, for direct branches, the pipeline resteering only happens once the branch target is decoded. For indirect branches, the resteering happens only once the branch completes execution. Given that in modern OOO cores where instructions potentially spend tens to hundreds of cycles in the pipeline, BTB updates happen speculatively once the target address is known. The BTB is implemented as a cache, storing the most recent branch targets of taken branches in an application. The BTB is searched using the branch PC where a subset of the PC address bits are interpreted as the index selecting one set from the BTB. Each BTB entry stores the branch target as well as metadata for implementing a replacement policy (e.g., Static Re-Reference Interval Prediction (SRRIP) <ref type="bibr" target="#b25">[27]</ref>) and maintaining counters that indicate the confidence in a target prediction. For the BTB analysis, we assume an 8-way set associative BTB with 4096 entries resembling those used in recent BTB works <ref type="bibr" target="#b1">[3]</ref>. The branch PC used for accessing the BTB and the targets stored in the BTB are virtual addresses. Branch targets are 57 bits wide, supporting recent processors with 5-level paging <ref type="bibr" target="#b23">[25]</ref>. BTB entries utilize a restricted 12-bit tag to disambiguate branch PCs mapping to the same cache set. Tags utilize less than address − index bits to reduce storage overheads. Utilizing a smaller tag introduces the possibility of multiple branches aliasing to the same entry, forcing a resteer event, but it does not affect the correctness of instruction execution. With a good hashing technique, as adopted in this work, such resteering can be minimised. The per-entry confidence counters are incremented on a successful target prediction and represent a measure of the usefulness of a BTB entry, relevant for indirect branches. In particular, as the BTB stores a single target address per branch PC, it utilizes the confidence value to determine whether an indirect target address is frequently used and hence valuable or whether it should be replaced with a different target address. Finally, the SRRIP bits capture a priority order in which entries of a set can be replaced. They help implement the BTB's replacement policy, in case new branch PCs need to be inserted into the BTB. The only control-flow changing instructions that do not consume BTB entries are returns that are handled via the return address stack (RAS). In Section 5.6, we also evaluate alternate baseline  BTB configurations. While most of our analysis is on a single level BTB, we do evaluate PDede for multi-level BTBs in section 5.9. Our observations and proposed optimizations are equally applicable for other BTB organizations as well <ref type="bibr" target="#b8">[10]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">BTB ANALYSIS</head><p>To guide the BTB microarchitecture we propose in the next section, we conduct a comprehensive analysis of 102 frontend-bound applications listed in Table <ref type="table" target="#tab_2">1</ref>. They are picked from an internal repository consisting of thousands of real world applications (including open source and proprietary ones). The selected applications are a representative set of widely used applications<ref type="foot" target="#foot_0">1</ref> showing a high percentage of front-end stalls (refer section 1) with branch resteering being a significant contributor.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Frequency of Taken Branches</head><p>Branch instructions only consume entries in the BTB if they are taken, as for non-taken branches the fall-through address can be computed trivially. As a result, BTB capacity is only an issue for applications whose branch working set exceeds the size of the BTB and whose branches are frequently taken. Figure <ref type="figure" target="#fig_1">3</ref> shows the percentage of taken branches among all static branch PCs and dynamic branch instructions. From both metrics, it can be seen that branches are taken more than 50% of the time, indicating that BTB capacity plays a critical role in determining frontend performance. Given that Icaches capture only a limited portion of the instruction footprint, for modern data center applications, a highly effective BTB that captures the targets effectively can hide a large portion of the Icache stalls by providing the target locations that need to be fetched into Icache.</p><p>Observation: Significant number of branches are taken, especially in front-end bound applications. Insight: Optimizing BTB storage space efficiency is required to store more branch targets and improving performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Branch Type Classification</head><p>Prior work has proposed microarchitectural techniques focusing on specific branch types <ref type="bibr" target="#b13">[15]</ref>. In this section, we show that such targeted techniques are not sufficient because datacenter applications execute a variety of branch types at runtime. We analyze three common branch types introduced in §2. Figure <ref type="figure" target="#fig_2">4</ref> shows a breakdown of these different branch types among all taken branches seen in the analyzed applications. While the distribution is skewed towards conditional and unconditional direct branches, all three branch types occur frequently enough and, therefore, need to be considered when designing BTBs.</p><p>Observation: BTBs need to cope with a variety of branch types including conditional, unconditional, direct, and indirect branches.</p><p>Insight: A generic solution supporting all different branch types is required.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Target Region and Page Partitioning</head><p>In emerging large code footprint workloads, utilizing many dynamicallymapped shared libraries, application code is spread sparsely across several pages in the address space. Operating systems also employ address space layout randomization <ref type="bibr" target="#b52">[54]</ref> to spread out application and library code in clusters across the address space for security reasons. These address clusters could be separated by several thousand pages. Typically, different static and dynamic libraries get loaded across these different address clusters. Applications, periodically jump across these multi-page address clusters, which we refer as regions. As such, there is good spatial and temporal locality when applications execute in a specific region. Figure <ref type="figure" target="#fig_4">5</ref>, shows a runtime plot across branches for a web-assembly based browser application <ref type="bibr" target="#b53">[55]</ref>. As seen from Figure <ref type="figure" target="#fig_4">5b</ref>, the application executes instructions from 450 different pages. Some of these pages are separated by &gt;65K pages in the address space. However, when focusing on regions as seen in Figure <ref type="figure" target="#fig_4">5a</ref>, addresses exhibit significant temporal and spatial locality. Our analysis, later, shows that the number of regions are fewer than the pages by 100× which we exploit for significant storage savings. Across all workloads, as shown in Figure <ref type="figure" target="#fig_5">6</ref>, we that each page can hold about 18 branch targets while each region includes about 2200 branch targets. This insight motivates us to split the target addresses into regions, pages and offsets, thereby reducing the number of unique regions and pages compared to the number of unique full addresses. When examining the offset addresses within a page, as seen in Figure <ref type="figure" target="#fig_4">5c</ref>, we did not observe much spatial or temporal locality anymore as the address utilization within a page is dense and used equally   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Branch Target Address Sharing</head><p>BTBs are indexed with the PC of a branch instruction to serve the corresponding target address. There exists several high-level programming constructs such as loops with multiple conditional breaks or continue where the target is identical among several branches. Figure <ref type="figure" target="#fig_6">7</ref> shows the number of unique branch target addresses, branch target regions, branch target page addresses as well as branch target page offsets among all analyzed branches. The number of unique targets is 67% of the total number of unique branch PCs, indicating that 30% of the target addresses can be deduplicated. As discussed in section 3.3, the deduplication opportunities is further increased when partitioning the branch target into region, page, and page offset, yielding only 0.07%, 5% and 18% unique entities, respectively. Based on these findings, we propose Branch Target Deduplication in Section 4.2, a technique that stores every target region and page only once to minimize BTB occupancy. This technique eventually enables the BTB to support a larger number of branch PCs since the storage required to track the respective target addresses is significantly reduced. As shown in Section 3.3, page offsets are dense, leaving little opportunity for deduplication. As a result, PDede does not deduplicate page offsets and stores them explicitly per branch.</p><p>Observation: Multiple branch targets share the same region and page address bits. Insight: Deduplicating BTB entries can further improve BTB storage space-efficiency by re-using the same region and page address bits among multiple branches. Based on this insight we propose Branch Target Deduplication.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Page Sharing between Branch and Target</head><p>The most frequently executed branch instructions are often tight inner loops. If these loops only contain a few instructions, it is likely that the branch PC and the branch target reside within the same page. We refer to these branches as same-page branches. On the other hand, calls frequently redirect the control flow to an instruction that is far away from the branch PC. These branches which have their target in a different page are referred to as differentpage branches. Figure <ref type="figure" target="#fig_7">8</ref> analyzes the distance between the branch PC and its target for the different branch types, showing that in over 60% of the cases, the branch PC and target reside within the same page. As a result, for a given branch, the target address can be derived from its branch PC. Based on this finding, we propose Delta Branch Target Encoding, a new technique that only stores the page offset of the branch target in the BTB for same-page branches. To improve the BTB storage efficiency, in section 4, we propose two designs that can effectively utilize the overall BTB storage to better pack same-page and different-page branches.</p><p>Observation: Branch PCs and branch targets are often located on the same page. Insight: Based on this insight, we propose Delta Branch Target Encoding to only store offsets for branches whose targets are in same page.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">PDEDE ARCHITECTURE</head><p>Based on our analysis in the previous section, we discuss the microarchitectural changes required to support the three techniques to improve the space efficiency of BTBs. By increasing space efficiency, we can increase the number of branches in the BTB while keeping the overall storage capacity constant, thereby, improving the performance of frontend-bound applications. A high-level depiction of the architecture is shown in Figure <ref type="figure" target="#fig_8">9</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">BTB-Partitioning</head><p>As seen in Figure <ref type="figure">2</ref>, the target address (57b) consumes most of the storage in the BTB. Given that there exists a significant difference in the spatial locality exhibited by regions, pages, and offsets, as shown in Section 3.3, PDede exploits this insight by storing the three branch target components in different structures of differing sizes. In contrast to the baseline BTB storing 4K entries, our design utilizes 1k entries for the Page-BTB and just 4 entries for the Region-BTB and supports the 4K page offsets as is. BTB-partitioning, however, introduces a new challenge. When implemented as separate structures, the Page-BTB and Region-BTB are both required to duplicate tag and maintain other meta data for each branch PC. PDede eliminates the duplicate tag and meta data by introducing a level of indirection, through a structure we refer to as the BTB-Monitor (BTBM). More details about the BTB-Monitor are provided in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Branch Target Deduplication</head><p>Deduplicating the region and page addresses as motivated in Section 3.4 requires multiple branch PCs to refer to the same entry in the Page and Region-BTBs. PDede achieves this via the BTB-Monitor (BTBM), a structure that is indexed with the branch PC address and that stores pointers to the Page-BTB and a Region-BTB in each entry. The BTB-Monitor improves storage efficiency in two ways. First, the indirection (which maps a branch PC to a Page-BTB entry and an Region-BTB entry) allows multiple branch PCs to point to the same page and region entries, enabling deduplication. Second, since PDede maintains the tags in the BTB-Monitor, the Page-BTB and the Region-BTB do not require tags nor duplicate meta data. Page offsets are directly stored in the BTB-Monitor to avoid any separate structure or level of indirection. This is because page offsets do not exhibit locality and hence a relatively large (4K) Offset-BTB would be required. Instead of storing a 12-bit pointer into the Offset-BTB, the BTBM stores the 12-bit offset directly. We perform an analysis of the required storage resources and overheads in Section 4.4.3.</p><p>The BTBM lookup needs to be performed before accessing the Page and Region-BTBs, which introduces a lookup latency challenge. Note that, the lookup in the Page and Region-BTBs is a simple memory addressing operation that does not require an associative lookup with tag matching as in conventional caches. Instead, tag matching is only performed for the BTBM. We quantify the overall BTB access latency when accessing the two structures sequentially in section 5.4. Furthermore, we design and evaluate a new BTB mechanism, that can hide most of the performance penalty of the two-cycle BTB lookup. We explored an alternate multi-tag BTB design option in which the Page and Region-BTBs are extended to store tags so a single region or page entry can be re-used across multiple branch PCs. We opted against this option as it suffers from two disadvantages. First, multiple tags per entry increase the tag overhead, and second, the number of tags statically limits the number of branches that can have the same target.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Delta Branch Target Encoding</head><p>In Section 3.5, we showed that for over 60% of all the branches, the branch PC and the branch target reside in the same page. Our proposed delta branch target encoding scheme exploits this fact by only storing the page offset of the branch target, omitting the rest of the fields. To store only the target offset, and use the branch PC to get the rest of the target, we add an additional delta-bit to each entry of the BTBM identifying that the branch target is in the same page as the branch PC. When a branch PC is looked-up from the BTBM, the delta bit determines whether a) the branch target is formed by concatenating the Region-BTB entry, Page-BTB entry and offset, or b) the branch target is formed by concatenating information from the branch PC with the offset from the BTBM. This technique significantly reduces the number of distinct pages and regions that need to be tracked in the BTBM. Furthermore, since the offset information is available in the BTBM entry, it avoids the need to lookup Region/Page-BTB lookup, eliminating the one additional cycle latency for same-page branches. As we show later in Figure <ref type="figure" target="#fig_11">11b</ref> , opportunistically eliminating the extra cycle access improves the performance gains that PDede can provide.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.</head><p>3.1 Optimizations enabled by Delta-Encoded BTB. Omitting the page and region addresses for same-page branches reduces the number of required entries in the Page-and Region-BTB, however, it still wastes storage capacity by storing null pointers in the BTBM. In the following, we explore two different techniques to eliminate this storage overhead as well. In the first optimization, referred to as PDede-Multi Target and shown in Figure <ref type="figure" target="#fig_8">9B</ref>, we opportunistically re-use the Region-and Page-BTB pointer fields in the BTBM to store targets of other branches, under the following conditions.</p><p>• The two stored branches need to be same-page branches • The branch PC of the second branch represents the next taken branch after first branch in the instruction sequence.</p><p>In this case, the next taken branch follows the target of the first branch.</p><p>To retrieve a target from the PDede-Multi Target we perform the following operations. Every time an entry is read out from the BTBM, we check for a valid next target and store it in a temporary global 12-bit Next Target Offset register. To enable this, every BTBM entry is extended with a valid bit (Next Target bit). If the next taken PC misses in the BTBM, we use the offset from Next Target Offset register to provide the target for this (next taken) PC. Note that, the target might not always be correct but since the PC missed in the BTBM and will resteer eventually, providing the target from Next Target Offset register does not increase the resteers. This technique has two advantages. Firstly, the technique optimizes for same-page branches which, according to section 3.5, represent 60% of all branches. Secondly, it is only invoked for the immediate taken branch, following the PC, that misses in the BTBM. As such, there is limited additional storage required per entry (only 1 bit per entry). Figure <ref type="figure" target="#fig_8">9</ref> highlights these changes. There are several extensions to this idea, in terms of adding simple tags to provide targets beyond the next taken branch or having multiple Last BTBM set and way registers to improve BTBM utilization, which we plan to explore later.</p><p>We explore a second design alternative, referred to as PDede-Multi Entry size, that restructures the BTB to support two different entry sizes. In each set of the BTBM, half of the ways are reserved for same-page branches and avoid the region and page pointer fields. Only the other half include these page and region pointers. We redistribute the storage savings to increase the total number of BTBM entries. Such a static split of ways might not be optimal    <ref type="table" target="#tab_4">2</ref>, even if the application only has targets in different pages, the number of suitable entries match the baseline BTB and, therefore, at least provide the baseline performance. Figure <ref type="figure" target="#fig_8">9C</ref> shows the two different entry types supported.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Putting it all Together</head><p>Figure <ref type="figure" target="#fig_8">9A</ref> shows the overall microarchitecture for PDede. The BTBM serves the incoming branch PC lookups and stores pointers to the Region-BTB and Page-BTB. The BTBM maintains a 12-bit tag per entry to disambiguate branch PCs with the same index. Each BTBM entry also contains a 1 bit process ID (PID), 2 bits for SRRIP-based replacement, 1 delta-bit and 2 bits for prediction confidence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.1">Lookup Operation.</head><p>To perform a BTB lookup, the index bits from the branch PC address are used to read entries from the corresponding set from the BTBM. Next, the tag bits from the branch PC are compared to the BTBM entries of the set and, if there is a match, the Region and Page-BTB pointers as well as the offset and the delta-bits are retrieved. If the delta bit is set, the branch PC is concatenated with the target offset, immediately returning the target without incurring the additional 1 cycle penalty. Furthermore, in the case of PDede-Multi Target, if the Next Target Bit is set as well, the region and page pointers are reinterpreted and stored into the Next Target Offset register. If the next BTBM lookup misses, the target for that PC will be served from the Next Target Offset register, otherwise the register is cleared. No additional tasks need to be performed for the PDede-Multi Entry size implementation. If, on a BTB lookup, the delta bit is not set, the page and region pointers are used to lookup the corresponding entries from the Page-BTB and Region-BTB. The region, page, and offset address bits are concatenated to form the target address. In this case, due to the two sequential lookups in the BTBM and the Page-BTB, the total BTB lookup latency is higher than the baseline BTB. In this work, we conservatively assume an extra cycle to complete the read access (since the cycle time is really decided by the most critical path in the pipeline). Once the region pointer is know, the Region-BTB access happens in parallel with the Page-BTB access.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.2">Update/Allocation</head><p>Operations. Once a branch has been decoded or executed, the correct target information is known. The confidence counters in the BTBM are updated based on the correctness of the final target prediction.Note that for each update operation, meta information (confidence counter, replacement bits) in the BTBM, Region-BTB, and Page-BTB need to be updated. One difference between PDede and the baseline BTB is that the allocation in the BTBM is only made if the allocations in the Region and Page-BTBs have been successful, avoiding invalid entries in the BTBM. Allocations in the Region-BTB and Page-BTB are SRRIPguided <ref type="bibr" target="#b25">[27]</ref>. SRRIP is sufficient as an entry shared across multiple often-occurring targets will always remain in the corresponding table. These tables are indexed using the corresponding portion from the target address (region and page) so as to detect if a particular region or page already exists in the table and allocation is done only when needed. We do not do anything special to invalidate the pointers in the BTB Monitor when entries in Page-BTB or Region-BTB get replaced. The reason is that if the Region-BTB or Page-BTB entry was popular it would not be replaced as it would continuously be accessed by one of the entries pointing to it. But it is possible for a BTBM entry to read an updated Page BTB entry leading to the wrong target. Such cases were very rare (0.06%) and hence we did not find the need to add the additional complexity to clear the BTBM entries when page and region BTB entries get replaced.</p><p>In the PDede-Multi Target design, if the branch that is allocated has its target in the same page, then its BTBM set and way are recorded in the Last BTBM set and Last BTBM way registers. When the next taken branch, whose target is in the same page, is updated, then using the Last BTBM set and way registers, the BTBM entry is updated to hold a valid next target offset and next target bit is also set. If the next taken branch is not a branch, the Last BTBM set and way registers are cleared. In the PDede-Multi Entry size design, the only change is that allocations are restricted for different-page branches as only half the ways, per set, are available.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.3">Storage Requirements. Table 2 provides an architecturally feasible</head><p>PDede configuration whose size matches the baseline BTB as close as possible to enable an ISO-storage comparison.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">EVALUATION</head><p>We now evaluate the impact of PDede on BTB mispredictions per kilo instructions (MPKI) and instructions per cycle (IPC) performance via simulation. We break down the IPC performance gains across the three proposed techniques and provide sensitivity studies to evaluate different BTB configurations and storage sizes. We also study the latency impact of accessing the two BTB structures sequentially.Finally, we also provide an iso-MPKI configuration and show the significant storage reduction that PDede can enable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Methodology</head><p>Our performance evaluation is done using our in-house cycleaccurate execution driven simulator modeling an x86 core clocked at 3.9 GHz. The simulator models pipeline latency based on functional unit contention, resource back-pressure due to data dependencies, a decoupled frontend, resteering due to branch misprediction and accurate wrong path modeling. The microarchitectural parameters are similar to the latest Intel Icelake processor [1] and we list the relevant parameters in Table <ref type="table">3</ref>.</p><p>As the baseline BTB, we leverage the architecture described in Section 2. We define BTB misses as follows. A BTB miss occurs if either a) a branch PC does not have a valid entry in the BTB, of b) if a branch PC is contained in the BTB, however, the target address is incorrect. To evaluate, PDede we use the applications introduced Table <ref type="table">3</ref>: Simulator Parameters in Section 3. We leverage Simpoints <ref type="bibr" target="#b21">[23]</ref> to identify the regions of interest and run detailed simulations with 10M+ instructions after warming up the memory sub-system and microarchitectural structures using 100M+ instructions. While the MPKI reduction and IPC gains presented below are normalized with the baseline, none of the applications had low baseline MPKI as their performance are bound by the BTB re-steering (refer Figure <ref type="figure">1</ref>). Our simulator and application performance estimation methodology is correlated to within 5% error to real silicon in the market. (c) Per-application IPC gains curve highlighting some of the applications. All applications gain more than 3%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">IPC and MPKI Performance of PDede</head><p>Figure <ref type="figure">10</ref>: IPC and MPKI improvements provided by PDede that reduces branch re-steering events. The overall MPKI reduction is a direct result of PDede's ability to track more branch PCs in the BTBM. A 50% larger baseline BTB provides the same IPC gains except for requiring an additional 37KB. PDede-Multi Target improves upon PDede-Default with its ability to opportunistically store 2 targets in a single BTBM entry. The IPC gains increase to 11.4% due to the 5% additional MPKI reduction provided by supporting more targets in the same storage footprint. The PDede-Multi Entry size, on the other hand, increases the IPC gains to 14.4% by storing targets for twice the number of branches as baseline. All branch types experience a decrease in MPKI including Indirect branches, which have a much higher misprediction penalty, that show a 4% decrease in mispredictions. Conditional direct branches see 74% reduction while unconditional direct branches see 49% reduction in MPKI.</p><p>Figure <ref type="figure">10c</ref> shows the IPC gains for all of the 100+ evaluated applications comparing the PDede-Multi Target and PDede-Multi Entry size configurations. For clarity, we omit the PDede-Default configuration. As can be seen, IPC gains range from 3% to 76%. Figure <ref type="figure">10c</ref> highlights specific applications such as Javascript static analyzer, which benefits the most, seeing a 76% IPC gain resulting from a 99.8% reduction in BTB MPKI. This BTB MPKI reduction lowers the branch re-steering frontend stalls seen in this application by 75% translating directly into IPC gains. Similar performance improvements can be observed in the Imaging and Microservice applications showing &gt;18% IPC gains. On the other hand, in the Animation application, the BTB MPKI is lowered only by 23% since the hot code working set of the application is large, exceeding PDede's resources. The Animation application has a 2.3× larger page footprint than the Javascript static analyzer and, hence, only sees a limited IPC gain for existing BTB sizes.</p><p>PDede is well-equipped to handle the different requirements of the diverse applications we analyze in this paper. For instance, in the Data Analytics application, which has a high percentage of branches whose targets occur in the same page as the branch PC (90%), the BTBM provides the targets. Not only does it benefit from limited front-end stalls but we also observe that this workload gains more with PDede-Multi Target as multiple targets in the same page can be packed better in this design than PDede-Multi Entry size. In the Microservices and the OLTP applications, on the other hand, the branch PCs and their corresponding targets frequently span different pages (only 50% of branch PC and targets are in same page in these applications), yet the Region and Page-BTBs combine effectively to capture the targets. Even in PDede-Multi Entry size, where only half the entries can support targets across different pages, there are enough entries available to support the varying dynamic requirements across the different branch types to result in the MPKI reduction. The HTML5-rendering application highlights the benefit of region and page deduplication. This application exhibits an average of &gt; 15 branch targets for each page and &gt; 2K per region maximizing the efficiency of the Page and Region BTBs.</p><p>Going forward, for the next sections, we use PDede-Multi Entry size to study the sensitivity to the different parameters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Sensitivity to design observations</head><p>To quantify the impact of the main observations on which PDede is architected on, Figure <ref type="figure" target="#fig_11">11a</ref> shows the IPC gains obtained by each optimization technique. Deduplicating targets (which are 67% of branch PCs) alone is not very effective and provides only 1.6% IPC gains. Once the targets are split into regions and pages, and individually deduplicated, the gains are much more significant (5.3%). This is in line with what was observed in Figure <ref type="figure" target="#fig_6">7</ref>. Finally, adding delta branch encoding to the two techniques increases IPC by an additional 2.5%. Further, the multi-target and multi-entry size optimizations, enabled by our delta branch encoding, improve the IPC gains significantly by a further 2% and 5% respectively.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Component</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">PDede access latency</head><p>Using Cacti7 <ref type="bibr" target="#b54">[56]</ref>, we studied the access latency of the baseline BTB and PDede at 22nm in Table <ref type="table" target="#tab_6">4</ref>. The critical path for PDede access is the BTBM access followed by an access to the Page-BTB. 22nm is the most recent technology supported by Cacti7. We highlight two different configurations, one utilizing 1 read-write (RW) port and another with 6 RW ports. Note that even a 1-RW design can support multiple BTB accesses per cycle when leveraging a banked design while the 6 port design matches the pipeline width. As seen, PDede has higher access latency than the baseline BTB only when sequentially accessing the Page-BTB. Otherwise, the access latency of the BTBM is lesser than the baseline BTB's access latency. Hence, PDede, only incurs a 1 cycle penalty to provide the branch target when accessing the page and region BTBs is required. We also evaluated the impact when the BTB access for every taken branch take two cycles, irrespective of whether it requires an access to the Region-BTB and Page-BTB or not. This configuration lowers the overall IPC gains from 14.4% to 13.4%. In a decoupled frontend <ref type="bibr" target="#b24">[26,</ref><ref type="bibr" target="#b42">44]</ref>, delaying the BTB lookup by one cycle is not exposed to later pipeline stages. The additional cycle renders it more challenging for the frontend to run-ahead, however, since typical basic blocks involve a few instructions, the branch predictor can proceed quickly enough to predict future branches. Figure <ref type="figure" target="#fig_11">11b</ref> shows the IPC impact when varying the fetch queue size. As expected, the gains are lower at smaller fetch queue size (12.7%) which increases as the fetch queue becomes larger (15.4% when fetch queue has 128 entries). In a FDIP pipeline, the fetch queue controls how far ahead the branch predictor and BTB (at high accuracy) can fetch and hence the IPC gains scale accordingly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">PDede performance with Perfect Branch Direction Predictor</head><p>To analyze the interactions between the branch direction predictor and the BTB, we studied the effectiveness of PDede with a perfect branch direction predictor improving the overall IPC gains over the baseline from 14.4% to 15.2%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Impact of Indirect Branches</head><p>Modern cores incorporate an Indirect Target TAGE (ITTAGE) <ref type="bibr" target="#b43">[45]</ref> predictor to predict the target of indirect branches. The storage requirements of ITTAGE (64KB) is quite high, although indirect branches only represent 10% of total dynamic branches. We evaluate PDede and the baseline BTB system with an additional 64-KB ITTAGE. For both designs, indirect branch targets are not allocated in the BTB. PDede provides a 13.9% IPC gain over the baseline BTB. IPC improvements are lower than in the configuration without ITTAGE, as the indirect branch MPKI reduction provided by PDede does not apply in this case. Also, the baseline BTB now has additional entries available for storing direct branches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.7">Impact of Storing Return Instructions</head><p>The RAS is common in most modern architectures as it can store the targets of return instructions with perfect accuracy. Nevertheless, to reduce storage costs and, for simplicity, architectures may opt to omit the RAS and instead store return targets in the BTB. We see a 13.7% IPC gain for PDede over the baseline BTB when storing return targets in the BTB. Note that our sizing analysis performed in Section 3 does not include return targets and hence Page and Offset-BTBs may be sized non-optimally for this configuration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.8">Sensitivity at larger BTB Sizes</head><p>In Figure <ref type="figure" target="#fig_12">12b</ref>, we highlight the IPC gains provided by PDede at larger BTB sizes. These gains primarily stem from PDede's ability to track more PCs in the BTBM (6K additional PCs tracked in Con-figB compared to baseline) and both the Region and Page-BTBs not having to scale up much to support the additional targets. We continue scaling the BTB size to 16K entries (150KB), and PDede still provides a 3.3% IPC improvement across 100+ applications at iso-storage. The IPC gains are lower as the active footprint of several applications start to fit in this size. Nevertheless, for the JITed server applications with large footprints, IPC gains of 6% are still significant. To be iso-MPKI, with the 150KB baseline BTB, PDede only requires 87 KB. This results in 42% lower storage resulting in area and energy savings, and as workload footprint sizes are continuing to increase <ref type="bibr" target="#b26">[28]</ref>, PDede will continue to provide significant benefits.  In Figure <ref type="figure" target="#fig_11">11c</ref>, we study PDede in a 2-level BTB configuration <ref type="bibr" target="#b20">[22]</ref>.</p><p>We study a baseline configuration with Level0 BTB at multiple sizes providing predictions at 1 cycle latency along with a 4K-entry Level1 BTB providing predictions at 2 cycles. In this setup, PDede is used to optimize only the Level1 BTB and yet it provides significant IPC gains. Further, as the Level1 BTB size grows, as shown in Figure <ref type="figure" target="#fig_12">12b</ref>, PDede will continue to remain efficient and provide significant IPC benefits over the conventional BTB organization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.10">Comparison to state-of-art BTBs</head><p>In Figure <ref type="figure" target="#fig_12">12a</ref>, we show that the state of art BTB design, Shotgun <ref type="bibr" target="#b33">[35]</ref>, brings only about 2.7% IPC speedup over the baseline BTB studied in this work (4K-entries at 37.5KB). As seen, Shotgun gives only about 0.8% IPC gains over the baseline, at iso-storage, which increases to about 2.7% at 45KB. Note that we did not model the Return Instruction Buffer (RIB) and instead use the RSB to provide target address for returns similar to baseline. Prefetching the conditionals following the return was modelled similar to what was done in <ref type="bibr" target="#b33">[35]</ref>. Several factors contribute to Shotgun's lower gains. These include the need to capture targets of all taken/not taken conditional branches in CBTB, which lower its hit rate. The baseline BTB is PC-indexed and therefore only needs to capture taken branches in it. Further, the prefetching is only triggered when a prior unconditional branch hits in the uBTB and only the conditional branches within a certain offset from the unconditional branch are prefetched. Prefetching into ICache, on top of FDIP <ref type="bibr" target="#b24">[26]</ref>, also pollutes the ICache entries due to the high speculation in the front-end. Confluence <ref type="bibr" target="#b27">[29]</ref> and SN4L <ref type="bibr" target="#b3">[5]</ref> operate at the cache line granularity and store the branch information in the cache line as meta-data. For RISC-ISAs, given the fixed instruction length, simple bit vectors suffice to capture the meta-data. For the x64 CISC ISA, there is a need to store branch offsets which is much harder to accommodate. SN4L estimates that it would require at least an additional 65KB metadata, virtualized, for a 2K-entry BTB. For Confluence, the meta-data that needs to be stored is much larger (960KB). This is discussed in Section V-D of SN4L paper. The high storage costs make these techniques harder to adopt. On the other hand, PDede provides all its gains at iso-storage.</p><p>PDede can definitely complement Confluence, Shotgun, and other BTB prefetching techniques to hold more branches in the BTB and in turn reduce the prefetching needed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.11">PDede with Deeper Future Pipelines</head><p>Modern OOO cores continue to increase in their pipeline width and depth to extract more single-thread performance. A side-effect of this growth is the performance penalty of BTB mispredictions increases as the pipeline stages between when the BTB prediction is given and when the actual branch target is available increases. Therefore, lowering the BTB MPKI will only become more critical in future cores. To study this impact, we scale the pipeline parameters listed in Table <ref type="table">3</ref> by 1.5x and 2x of their current size to reflect future cores. The IPC gains from PDede BTB increases to 16.8% in the 1.5x Icelake-like core which increases further to 20.1% in the 2x Icelake-like core.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.12">Iso-MPKI PDede Storage Savings</head><p>While the prior sections studied the performance impact of isostorage PDede configuration in different scenarios, storage savings are equally important both from cost and energy savings perspective. As such, in Figure <ref type="figure" target="#fig_12">12c</ref>, we also studied the smallest size PDede BTB that is iso-MPKI with the baseline BTB. The smallest PDede configuration requires only 19KB, resulting in 49% storage savings over the baseline.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">RELATED WORK</head><p>Significant effort has gone in to studying the frontend bottleneck and proposing techniques to lower its impact <ref type="bibr">[5, 7, 8, 17, 18, 29-32, 39, 42]</ref>. By predicting the control flow of applications and prefetching instructions into the Icache and BTB, a steady flow of instructions can be provided. PDede is complementary to these works. Recent papers from Samsung and IBM <ref type="bibr" target="#b0">[2,</ref><ref type="bibr" target="#b20">22]</ref> have shown the significant investments made in BTB storage emphasizing the importance of lowering BTB resteers. Also, as shown in Figure <ref type="figure" target="#fig_12">12b</ref>, PDede still gives good performance gains at larger BTB sizes.</p><p>Seznec <ref type="bibr" target="#b44">[46]</ref> proposed the page pointer table, which has also been used by Garza <ref type="bibr" target="#b17">[19]</ref>, to improve the storage efficiency of the BTB via partitioning. While the proposed technique is related, PDede improves over the page pointer table by splitting the page address into regions and page offsets and deduplicating the individual structures to help lower the storage costs. PDede introduces Delta Encoding of branch targets to further improve storage efficiency. Delta Encoding enables PDede-Multi Target to opportunistically store multiple targets in the same entry which has not been explored till now. Further, it allows the entries to be sized differently, bringing in significant IPC benefits via the PDede-Multi Entry size design. Lastly, for a thorough evaluation, PDede takes the performance implication of accessing multiple structures into account. Our analysis and newly introduced techniques improve the performance by an additional 7.5% over implementations that only support partitioning (Figure <ref type="figure" target="#fig_11">11a</ref>).</p><p>Several works have looked to enhance the efficiency of the BTB by applying different replacement policies. These works <ref type="bibr" target="#b7">[9,</ref><ref type="bibr" target="#b39">41]</ref> investigate different BTB allocation strategies for different branch types. GHRP <ref type="bibr" target="#b1">[3]</ref> was introduced to improve the BTB replacement policy which is again orthogonal to our work and can be combined with PDede. Several proposals <ref type="bibr" target="#b13">[15,</ref><ref type="bibr" target="#b18">20,</ref><ref type="bibr" target="#b31">33,</ref><ref type="bibr" target="#b35">37,</ref><ref type="bibr" target="#b36">38,</ref><ref type="bibr" target="#b49">51]</ref> aim to reduce misspredictions for indirect branches. PDede contributes over these works by tackling all branch types while showing a MPKI reduction for indirect branches as well. The Phantom-BTB <ref type="bibr" target="#b8">[10]</ref> increases effective BTB capacity by adding a virtual second level BTB in the L2 cache, prefetching branch metadata into the BTB to mitigate the added latency. This solution still leverages a dedicated BTB component whose storage efficiency can be improved with PDede.</p><p>Several prior studies on caches have exploited data redundancy to lower the storage requirements either by deduplicating <ref type="bibr">[12-14, 24, 47, 52]</ref> the data or by proposing efficient compression <ref type="bibr" target="#b2">[4,</ref><ref type="bibr" target="#b19">21]</ref>. Such compression techniques are infeasible for BTBs which need to provide fast lookups whereas PDede has been optimized for performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSION</head><p>In this paper we present PDede, the Partitioned, Deduplicated, Delta Branch Target Buffer. PDede proposes three novel techniques to increase the space-efficiency of BTBs leading to significant performance gains for frontend-bound applications. Our Delta-branch target encoding is novel and allows us to store multiple targets in a single entry and we evaluate the impact of supporting different entry sizes. In an iso-storage configuration, PDede shows an average BTB MPKI reduction of 54.7% and an average IPC improvement of 14.4% over the baseline BTB. Alternately, PDede achieves iso-MPKI at 49% lower storage than baseline. We believe that our analysis provides insights that eases future research on this topic to develop better branch target buffers increasing the efficiency and throughput of contemporary microprocessors.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Percentage of static branch PCs and dynamic branch occurrences that are taken.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Percentage of the total branches belonging to the different branch types averaged per category.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Region access over time. Region differ by 65K pages in the address space and typically different libraries get dynamically mapped across these regions. Pages access over time. Less temporal locality and more unique pages accessed with respect to regions. Page offsets accessed over runtime.There is very little locality to exploit.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Runtime plot from a web assembly application showing the region, page and offset span of the branch targets.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: The average number of targets seen per page and region across the different applications.</figDesc><graphic url="image-1.png" coords="5,76.78,83.69,151.32,109.85" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Unique number of branch targets, target page addresses, and target page offsets.</figDesc><graphic url="image-2.png" coords="5,230.34,83.71,151.32,109.83" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Distance in pages between the branch PC and its target</figDesc><graphic url="image-3.png" coords="5,383.90,86.44,151.32,107.02" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: (A) PDede BTB Architecture with Region-and Page-BTBs emphasizing how the tables provide different portions of the branch target. (B) PDede-Multi Target design which supports multiple targets in an entry when branches that have their targets in the same page. Changes required are shown in yellow. (C) PDede-Multi Entry size design to support multiple entry sizes in different ways of the same set in the BTBM. Branches with targets in different pages cannot allocate in entries that do not have Region and Page Pointers. (D) PDede introduces a 1 cycle stall to provide branch targets for different-page branches.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 10a ,</head><label>10a</label><figDesc>Figure 10a, 10b shows the performance benefits of PDede over the baseline configuration, shown in Section 4.4.3, for three configurations of PDede. Overall, PDede-Default improves IPC by 9.4% by lowering the BTB MPKI by 35.4% across the 100+ applications. The Server category containing large code footprint webscale applications shows the highest reduction in MPKI of 40.7% resulting in IPC gains of 11.2%. The IPC gains are a direct result of reducing the front-end stalls provided by the increased effective BTB capacity</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>IPC gains when BTB stalls for every taken branch and across different fetch queue sizes IPC gains in a 2 level BTB organization with the Level1 BTB rearchitected based on PDede. The gains are shown for different sizes of Level0 BTB.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: PDede IPC contributions and sensitivity in different configurations</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: PDede IPC sensitivity at larger sizes, in future cores and storage savings possible at Iso-MPKI</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Branch Prediction Unit (BPU) Re-steer pipeline on Wrong Target from BTB for Direct Branches Re-steer pipeline on Wrong Target from BTB for Indirect Branches In-order Retire</head><label></label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell></cell><cell>ICache</cell><cell cols="2">Pre-decode</cell><cell>Instr. Queue</cell><cell>Decoders</cell><cell>Micro-op Queue</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>MUX</cell></row><row><cell cols="2">Branch</cell><cell></cell><cell>Branch</cell><cell></cell><cell cols="2">Return</cell><cell>Micro-</cell></row><row><cell cols="2">Direction</cell><cell></cell><cell>Target</cell><cell cols="3">Address</cell><cell>op</cell></row><row><cell cols="2">Predictor</cell><cell cols="3">Buffer (BTB)</cell><cell>Stack</cell><cell></cell><cell>cache</cell></row><row><cell>Branch PC</cell><cell>PID (1b)</cell><cell>Tag (12b)</cell><cell>Target (57 b)</cell><cell>SRRIP (3b)</cell><cell>Conf (2b)</cell><cell cols="2">Update BTB (PC, Actual Target)</cell><cell>Back-End (RAT/ROB/ RS/LB/SB)</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Memory</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Subsystem</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Instruction Fetch Increment for Non-Branch and Not-Taken Branches For Taken Branches, Next Instruction PC to Fetch = Branch Target Branch Target</head><label></label><figDesc></figDesc><table /><note>Figure2: Pipeline describing the OOO core we study. Modern OOO cores incorporate a fetch-directed instruction prefetching (FDIP)<ref type="bibr" target="#b24">[26]</ref> pipeline. On BTB misses/mispredictions, resteering happen post decode for direct branches or post execution for indirect branches.variable-length entries in the BTB. This re-design of the BTB entries provides an additional 5% IPC gains on top of the delta encoding resulting mostly from re-distributing the BTB storage to support additional PCs. We implement the microarchitectural modifications proposed by PDede in our industry-class, in-house, cycle-accurate simulator modeling the latest Intel Icelake processor [1] and study PDede's effectiveness of reducing BTB misses for a large number (100+) of frontend bound applications. For all such applications, our best performing design reduces BTB misses significantly (54.7% on average and up to 99.8%) compared to a similar-size baseline BTB.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 :</head><label>1</label><figDesc>Evaluated application categories</figDesc><table><row><cell>Category</cell><cell>Description</cell><cell>Count</cell></row><row><cell>Server</cell><cell>Online transaction processing, Web traf-</cell><cell>61</cell></row><row><cell></cell><cell>fic processing, Cloud services, Microser-</cell><cell></cell></row><row><cell></cell><cell>vices</cell><cell></cell></row><row><cell>Browser</cell><cell>HTML5-based, Javascript, JVM, Web as-</cell><cell>20</cell></row><row><cell></cell><cell>sembly, Games, Image-rendering</cell><cell></cell></row><row><cell>Business Produc-</cell><cell>File compression, Email, Presentations,</cell><cell>11</cell></row><row><cell>tivity(BP)</cell><cell>Spreadsheet, Document processing</cell><cell></cell></row><row><cell>Personal</cell><cell>Email, Image Editing, Games, Video</cell><cell>10</cell></row><row><cell></cell><cell>playback/sharing</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 2 :</head><label>2</label><figDesc>Storage Requirements of PDede and the Baseline BTB across all applications but, as shown in Table</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 4 :</head><label>4</label><figDesc>Access Latency comparison at 22nm. For PDede, access latency shown for default cacti parameters.</figDesc><table><row><cell></cell><cell>Access Time</cell><cell>Access</cell><cell>Time</cell></row><row><cell></cell><cell>(ns)</cell><cell>(ns)</cell></row><row><cell></cell><cell>1 RW port</cell><cell cols="2">6 RW ports</cell></row><row><cell>Baseline BTB</cell><cell>0.24</cell><cell>0.72</cell></row><row><cell>BTBM</cell><cell>0.21</cell><cell>0.55</cell></row><row><cell>Page-BTB(PBTB)</cell><cell>0.09</cell><cell>0.16</cell></row><row><cell>PDede (BTBM+PBTB)</cell><cell>0.3</cell><cell>0.71</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0">The exact listing of applications in the benchmark suite is anonymized due to the private nature of the data.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>We thank the anonymous reviewers for their insightful feedback and suggestions. This work was supported by the Intel Corporation, the NSF grants #1823559 and #2010810, and the Applications Driving Architectures (ADA) Research Center, a JUMP Center cosponsored by SRC and DARPA. Any opinions, findings, conclusions, or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the funding agencies.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The IBM z15 High Frequency Mainframe Branch Predictor Industrial Product</title>
		<author>
			<persName><forename type="first">N</forename><surname>Adiga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bonanno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Collura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Heizmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">R</forename><surname>Prasky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Saporito</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2020 ACM/IEEE 47th Annual International Symposium on Computer Architecture (ISCA)</title>
				<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="27" to="39" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Exploring predictive replacement policies for instruction cache and branch target buffer</title>
		<author>
			<persName><forename type="first">Samira</forename><surname>Mirbagher Ajorpaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Elba</forename><surname>Garza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sangam</forename><surname>Jindal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">A</forename><surname>Jiménez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 ACM/IEEE 45th Annual International Symposium on Computer Architecture (ISCA)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="519" to="532" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Adaptive cache compression for highperformance processors</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Alameldeen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings. 31st Annual International Symposium on Computer Architecture</title>
				<meeting>31st Annual International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2004">2004. 2004</date>
			<biblScope unit="page" from="212" to="223" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Divide and Conquer Frontend Bottleneck</title>
		<author>
			<persName><forename type="first">Ali</forename><surname>Ansari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pejman</forename><surname>Lotfi-Kamran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hamid</forename><surname>Sarbazi-Azad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 47th Annual International Symposium on Computer Architecture (ISCA)</title>
				<meeting>the 47th Annual International Symposium on Computer Architecture (ISCA)</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Memory hierarchy for web search</title>
		<author>
			<persName><forename type="first">Grant</forename><surname>Ayers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jung</forename><surname>Ho Ahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christos</forename><surname>Kozyrakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Parthasarathy</forename><surname>Ranganathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 IEEE International Symposium on High Performance Computer Architecture (HPCA)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="643" to="656" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Classifying Memory Access Patterns for Prefetching</title>
		<author>
			<persName><forename type="first">Grant</forename><surname>Ayers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Heiner</forename><surname>Litz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christos</forename><surname>Kozyrakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Parthasarathy</forename><surname>Ranganathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Fifth International Conference on Architectural Support for Programming Languages and Operating Systems</title>
				<meeting>the Twenty-Fifth International Conference on Architectural Support for Programming Languages and Operating Systems</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="513" to="526" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">AsmDB: understanding and mitigating front-end stalls in warehouse-scale computers</title>
		<author>
			<persName><forename type="first">Grant</forename><surname>Ayers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nayana</forename><forename type="middle">Prasad</forename><surname>Nagendra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">I</forename><surname>August</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hyoun</forename><forename type="middle">Kyu</forename><surname>Cho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Svilen</forename><surname>Kanev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christos</forename><surname>Kozyrakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Trivikram</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Heiner</forename><surname>Litz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tipp</forename><surname>Moseley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Parthasarathy</forename><surname>Ranganathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 46th International Symposium on Computer Architecture</title>
				<meeting>the 46th International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="462" to="473" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Strategies for branch target buffers</title>
		<author>
			<persName><forename type="first">Brian</forename><forename type="middle">K</forename><surname>Bray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Flynn</surname></persName>
		</author>
		<idno type="DOI">10.1145/123465.123473</idno>
		<ptr target="https://doi.org/10.1145/123465.123473" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th annual international symposium on Microarchitecture -MICRO 24</title>
				<meeting>the 24th annual international symposium on Microarchitecture -MICRO 24<address><addrLine>Albuquerque, New Mexico, Puerto Rico</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="42" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Phantom-BTB: a virtualized branch target buffer design</title>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Burcea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Moshovos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acm Sigplan Notices</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page" from="313" to="324" />
			<date type="published" when="2009">2009. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<ptr target="https://www.jilp.org/cbp2016/" />
		<title level="m">Championship Branch Prediction (CBP-5)</title>
				<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">CMD: Classification-based memory deduplication through page access characteristics</title>
		<author>
			<persName><forename type="first">Licheng</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhipeng</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zehan</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mingyu</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haiyang</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yungang</forename><surname>Bao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="page" from="65" to="76" />
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">HICAMP: architectural support for efficient concurrency-safe shared structured data access</title>
		<author>
			<persName><forename type="first">David</forename><surname>Cheriton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amin</forename><surname>Firoozshahian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alex</forename><surname>Solomatnikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">P</forename><surname>Stevenson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Omid</forename><surname>Azizi</surname></persName>
		</author>
		<idno type="DOI">10.1145/2248487.2151007</idno>
		<ptr target="https://doi.org/10.1145/2248487.2151007" />
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="287" to="300" />
			<date type="published" when="2012-03">2012. March 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Duplicate Management for Reference Data</title>
		<author>
			<persName><forename type="first">Timothy</forename><forename type="middle">E</forename><surname>Denehy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Windsor</forename><forename type="middle">W</forename><surname>Hsu</surname></persName>
		</author>
		<idno>RJ10305</idno>
	</analytic>
	<monogr>
		<title level="j">IBM</title>
		<imprint>
			<biblScope unit="page">15</biblScope>
			<date type="published" when="2003">2003. 2003</date>
		</imprint>
	</monogr>
	<note type="report_type">Research Report</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Value Based BTB Indexing for indirect jump prediction</title>
		<author>
			<persName><forename type="first">M</forename><surname>Farooq</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Kurian</surname></persName>
		</author>
		<idno type="DOI">10.1109/HPCA.2010.5416659</idno>
		<ptr target="https://doi.org/10.1109/HPCA.2010.5416659" />
	</analytic>
	<monogr>
		<title level="m">2010 IEEE 16th International Symposium on High Performance Computer Architecture (HPCA)</title>
				<meeting><address><addrLine>Los Alamitos, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Clearing the clouds: a study of emerging scale-out workloads on modern hardware</title>
		<author>
			<persName><forename type="first">Almutaz</forename><surname>Michael Ferdman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Onur</forename><surname>Adileh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stavros</forename><surname>Kocberber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohammad</forename><surname>Volos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Djordje</forename><surname>Alisafaee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cansu</forename><surname>Jevdjic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adrian</forename><forename type="middle">Daniel</forename><surname>Kaynak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anastasia</forename><surname>Popescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Babak</forename><surname>Ailamaki</surname></persName>
		</author>
		<author>
			<persName><surname>Falsafi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acm sigplan notices</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="page" from="37" to="48" />
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Proactive instruction fetch</title>
		<author>
			<persName><forename type="first">Cansu</forename><surname>Michael Ferdman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Babak</forename><surname>Kaynak</surname></persName>
		</author>
		<author>
			<persName><surname>Falsafi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Microarchitecture</title>
				<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Temporal instruction fetch streaming</title>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">F</forename><surname>Michael Ferdman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anastasia</forename><surname>Wenisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Babak</forename><surname>Ailamaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Falsafi</surname></persName>
		</author>
		<author>
			<persName><surname>Moshovos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Microarchitecture</title>
				<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Bit-level Perceptron Prediction for Indirect Branches</title>
		<author>
			<persName><forename type="first">E</forename><surname>Garza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mirbagher-Ajorpaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Jiménez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2019 ACM/IEEE 46th Annual International Symposium on Computer Architecture (ISCA)</title>
				<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="27" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Bit-level Perceptron Prediction for Indirect Branches</title>
		<author>
			<persName><forename type="first">E</forename><surname>Garza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mirbagher-Ajorpaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Jiménez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2019 ACM/IEEE 46th Annual International Symposium on Computer Architecture (ISCA)</title>
				<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="27" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Thesaurus: Efficient Cache Compression via Dynamic Clustering</title>
		<author>
			<persName><forename type="first">Amin</forename><surname>Ghasemazar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Prashant</forename><surname>Nair</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mieszko</forename><surname>Lis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Fifth International Conference on Architectural Support for Programming Languages and Operating Systems</title>
				<meeting>the Twenty-Fifth International Conference on Architectural Support for Programming Languages and Operating Systems</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="527" to="540" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Evolution of the Samsung Exynos CPU Microarchitecture</title>
		<author>
			<persName><forename type="first">B</forename><surname>Grayson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rupley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">Z</forename><surname>Zuraski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Quinnell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Jiménez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Nakra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kitchin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hensley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Brekelbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Sinha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ghiya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2020 ACM/IEEE 47th Annual International Symposium on Computer Architecture (ISCA)</title>
				<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="40" to="51" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">SimPoint 3.0: Faster and More Flexible Program Phase Analysis</title>
		<author>
			<persName><forename type="first">Greg</forename><surname>Hamerly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Erez</forename><surname>Perelman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeremy</forename><surname>Lau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brad</forename><surname>Calder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Instruction Level Parallelism</title>
		<imprint>
			<biblScope unit="page" from="1" to="28" />
			<date type="published" when="2005">2005. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Duplicate Data Elimination in a SAN File System</title>
		<author>
			<persName><forename type="first">Bo</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Demyn</forename><surname>Plantenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">MSST</title>
		<imprint>
			<biblScope unit="page">14</biblScope>
			<date type="published" when="2004">2004. 2004. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">5-Level Paging and 5-Level EPT</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<publisher>Intel</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Rebasing Instruction Prefetching: An Industry Perspective</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nathella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sunwoo</surname></persName>
		</author>
		<idno type="DOI">10.1109/LCA.2020.3035068</idno>
		<ptr target="https://doi.org/10.1109/LCA.2020.3035068" />
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Architecture Letters</title>
		<imprint>
			<biblScope unit="volume">5555</biblScope>
			<biblScope unit="page" from="1" to="1" />
			<date>oct 5555</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">High Performance Cache Replacement Using Re-Reference Interval Prediction (RRIP)</title>
		<author>
			<persName><forename type="first">Aamer</forename><surname>Jaleel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kevin</forename><forename type="middle">B</forename><surname>Theobald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simon</forename><forename type="middle">C</forename><surname>Steely</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joel</forename><surname>Emer</surname></persName>
		</author>
		<idno type="DOI">10.1145/1815961.1815971</idno>
		<ptr target="https://doi.org/10.1145/1815961.1815971" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 37th Annual International Symposium on Computer Architecture</title>
				<meeting>the 37th Annual International Symposium on Computer Architecture<address><addrLine>Saint-Malo, France; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="60" to="71" />
		</imprint>
	</monogr>
	<note>ISCA &apos;10)</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Profiling a warehousescale computer</title>
		<author>
			<persName><forename type="first">Svilen</forename><surname>Kanev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juan</forename><forename type="middle">Pablo</forename><surname>Darago</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kim</forename><surname>Hazelwood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tipp</forename><surname>Parthasarathy Ranganathan</surname></persName>
		</author>
		<author>
			<persName><surname>Moseley</surname></persName>
		</author>
		<author>
			<persName><surname>Gu-Yeon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><surname>Brooks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 42nd Annual International Symposium on Computer Architecture</title>
				<meeting>the 42nd Annual International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="158" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Confluence: unified instruction supply for scale-out servers</title>
		<author>
			<persName><forename type="first">Cansu</forename><surname>Kaynak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Boris</forename><surname>Grot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Babak</forename><surname>Falsafi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 48th International Symposium on Microarchitecture</title>
				<meeting>the 48th International Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="166" to="177" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Twig: Profile-Guided BTB Prefetching for Data Center Applications</title>
		<author>
			<persName><forename type="first">Ahmed</forename><surname>Tanvir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nathan</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Akshitha</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName><surname>Sriraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rakesh</forename><surname>Niranjan K Soundararajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joseph</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sreenivas</forename><surname>Devietti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gilles</forename><forename type="middle">A</forename><surname>Subramoney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Heiner</forename><surname>Pokam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Baris</forename><surname>Litz</surname></persName>
		</author>
		<author>
			<persName><surname>Kasikci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">54th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)</title>
				<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">I-SPY: Context-Driven Conditional Instruction Prefetching with Coalescing</title>
		<author>
			<persName><forename type="first">Tanvir</forename><surname>Ahmed Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Akshitha</forename><surname>Sriraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joseph</forename><surname>Devietti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gilles</forename><surname>Pokam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Heiner</forename><surname>Litz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Baris</forename><surname>Kasikci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2020 53rd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="146" to="159" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Ripple: Profile-Guided Instruction Cache Replacement for Data Center Applications</title>
		<author>
			<persName><forename type="first">Tanvir</forename><surname>Ahmed Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dexin</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Akshitha</forename><surname>Sriraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joseph</forename><surname>Devietti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gilles</forename><surname>Pokam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Heiner</forename><surname>Litz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Baris</forename><surname>Kasikci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 48th International Symposium on Computer Architecture</title>
				<meeting>the 48th International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
	<note>ISCA 2021</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Virtual Program Counter (VPC) Prediction: Very Low Cost Indirect Branch Prediction Using Conditional Branch Prediction Hardware</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Joao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Mutlu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">N</forename><surname>Patt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cohn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="page" from="1153" to="1170" />
			<date type="published" when="2009">2009. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">RDIP: return-addressstack directed instruction prefetching</title>
		<author>
			<persName><forename type="first">Aasheesh</forename><surname>Kolli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ali</forename><surname>Saidi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">F</forename><surname>Wenisch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2013 46th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="260" to="271" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Blasting through the front-end bottleneck with shotgun</title>
		<author>
			<persName><forename type="first">Rakesh</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Boris</forename><surname>Grot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vijay</forename><surname>Nagarajan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="30" to="42" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Boomerang: A metadata-free architecture for control flow delivery</title>
		<author>
			<persName><forename type="first">Rakesh</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cheng-Chieh</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Boris</forename><surname>Grot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vijay</forename><surname>Nagarajan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2017 IEEE International Symposium on High Performance Computer Architecture (HPCA)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="493" to="504" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Rehashable BTB: an adaptive branch target buffer to improve the target predictability of Java code</title>
		<author>
			<persName><forename type="first">Tao</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ravi</forename><surname>Bhargava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lizy</forename><surname>Kurian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on High-Performance Computing</title>
				<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="597" to="608" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Adapting branch-target buffer to improve the target predictability of java code</title>
		<author>
			<persName><forename type="first">Tao</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ravi</forename><surname>Bhargava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lizy</forename><surname>Kurian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Architecture and Code Optimization</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="109" to="130" />
			<date type="published" when="2005">2005. 2005</date>
		</imprint>
	</monogr>
	<note>TACO)</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Scale-out processors</title>
		<author>
			<persName><forename type="first">Pejman</forename><surname>Lotfi-Kamran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Boris</forename><surname>Grot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Ferdman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stavros</forename><surname>Volos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Onur</forename><surname>Kocberber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Javier</forename><surname>Picorel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Almutaz</forename><surname>Adileh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Djordje</forename><surname>Jevdjic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sachin</forename><surname>Idgunji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emre</forename><surname>Ozer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Babak</forename><surname>Falsafi</surname></persName>
		</author>
		<idno type="DOI">10.1145/2366231.2337217</idno>
		<ptr target="https://doi.org/10.1145/2366231.2337217" />
	</analytic>
	<monogr>
		<title level="j">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="500" to="511" />
			<date type="published" when="2012-06">2012. June 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Elastic Instruction Fetching</title>
		<author>
			<persName><forename type="first">A</forename><surname>Perais</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sheikh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Yen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mcilvaine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">D</forename><surname>Clancy</surname></persName>
		</author>
		<idno type="DOI">10.1109/HPCA.2019.00059</idno>
		<ptr target="https://doi.org/10.1109/HPCA.2019.00059" />
	</analytic>
	<monogr>
		<title level="m">2019 IEEE International Symposium on High Performance Computer Architecture (HPCA)</title>
				<meeting><address><addrLine>Los Alamitos, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="478" to="490" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Branch target buffer design and optimization</title>
		<author>
			<persName><forename type="first">H</forename><surname>Chris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alan</forename><forename type="middle">Jay</forename><surname>Perleberg</surname></persName>
		</author>
		<author>
			<persName><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE transactions on computers</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="396" to="412" />
			<date type="published" when="1993">1993. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Fetching instruction streams</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ramirez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">J</forename><surname>Santana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Larriba-Pey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Valero</surname></persName>
		</author>
		<idno type="DOI">10.1109/MICRO.2002.1176264</idno>
		<ptr target="https://doi.org/10.1109/MICRO.2002.1176264ISSN" />
	</analytic>
	<monogr>
		<title level="m">35th Annual IEEE/ACM International Symposium on Microarchitecture</title>
				<imprint>
			<date type="published" when="2002">2002. 2002</date>
			<biblScope unit="page" from="1072" to="4451" />
		</imprint>
	</monogr>
	<note>Proceedings. 371-382</note>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Fetch directed instruction prefetching</title>
		<author>
			<persName><forename type="first">Glenn</forename><surname>Reinman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brad</forename><surname>Calder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><surname>Austin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MICRO-32. Proceedings of the 32nd Annual ACM/IEEE International Symposium on Microarchitecture. IEEE</title>
				<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="16" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Optimizations Enabled by a Decoupled Front-End Architecture</title>
		<author>
			<persName><forename type="first">Glenn</forename><surname>Reinman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brad</forename><surname>Calder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><surname>Austin</surname></persName>
		</author>
		<idno type="DOI">10.1109/12.919279</idno>
		<ptr target="https://doi.org/10.1109/12.919279" />
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="338" to="355" />
			<date type="published" when="2001-04">2001. April 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">A 64-Kbytes ITTAGE indirect branch predictor</title>
		<author>
			<persName><forename type="first">André</forename><surname>Seznec</surname></persName>
		</author>
		<ptr target="https://hal.inria.fr/hal-00639041" />
	</analytic>
	<monogr>
		<title level="m">JILP</title>
				<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Don&apos;t Use the Page Number, but a Pointer to It</title>
		<author>
			<persName><forename type="first">S</forename><surname>Seznec</surname></persName>
		</author>
		<idno type="DOI">10.1145/232973.232985</idno>
		<ptr target="https://doi.org/10.1145/232973.232985" />
	</analytic>
	<monogr>
		<title level="m">23rd Annual International Symposium on Computer Architecture. IEEE Computer Society</title>
				<meeting><address><addrLine>Los Alamitos, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">104</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Pageforge: a near-memory content-aware page-merging architecture</title>
		<author>
			<persName><forename type="first">Dimitrios</forename><surname>Skarlatos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nam</forename><forename type="middle">Sung</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Josep</forename><surname>Torrellas</surname></persName>
		</author>
		<idno type="DOI">10.1145/3123939.3124540</idno>
		<ptr target="https://doi.org/10.1145/3123939.3124540" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 50th Annual IEEE/ACM International Symposium on Microarchitecture</title>
				<meeting>the 50th Annual IEEE/ACM International Symposium on Microarchitecture<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="302" to="314" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Effective instruction prefetching in chip multiprocessors for modern commercial applications</title>
		<author>
			<persName><forename type="first">Lawrence</forename><surname>Spracklen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuan</forename><surname>Chou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Santosh G</forename><surname>Abraham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on High-Performance Computer Architecture</title>
				<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Branch history guided instruction prefetching</title>
		<author>
			<persName><forename type="first">Viji</forename><surname>Srinivasan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Edward</forename><forename type="middle">S</forename><surname>Davidson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gary</forename><forename type="middle">S</forename><surname>Tyson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><forename type="middle">J</forename><surname>Charney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">R</forename><surname>Puzak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on High-Performance Computer Architecture</title>
				<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Softsku: Optimizing server architectures for microservice diversity@ scale</title>
		<author>
			<persName><forename type="first">Akshitha</forename><surname>Sriraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Abhishek</forename><surname>Dhanotia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">F</forename><surname>Wenisch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 46th International Symposium on Computer Architecture</title>
				<meeting>the 46th International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="513" to="526" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Contrasting branch characteristics and branch predictor performance of C++ and C programs</title>
		<author>
			<persName><forename type="first">D-Cd</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ann</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Marie</forename><forename type="middle">Grizzaffi</forename><surname>Maynard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lizy</forename><surname>Kurian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">1999 IEEE International Performance, Computing and Communications Conference (Cat. No. 99CH36305</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="275" to="283" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Last-Level Cache Deduplication</title>
		<author>
			<persName><forename type="first">Yingying</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Samira</forename><forename type="middle">M</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">A</forename><surname>Jiménez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gabriel</forename><forename type="middle">H</forename><surname>Loh</surname></persName>
		</author>
		<idno type="DOI">10.1145/2597652.2597655</idno>
		<ptr target="https://doi.org/10.1145/2597652.2597655" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th ACM International Conference on Supercomputing</title>
				<meeting>the 28th ACM International Conference on Supercomputing<address><addrLine>Munich, Germany; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="53" to="62" />
		</imprint>
	</monogr>
	<note>ICS &apos;14)</note>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Instruction cache prefetching using multilevel branch prediction</title>
		<author>
			<persName><forename type="first">Alexander</forename><forename type="middle">V</forename><surname>Veidenbaum</surname></persName>
		</author>
		<idno type="DOI">10.1007/BFb0024203</idno>
		<ptr target="https://doi.org/10.1007/BFb0024203" />
	</analytic>
	<monogr>
		<title level="m">High Performance Computing</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Constantine</forename><surname>Polychronopoulos</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Kazuki</forename><surname>Joe</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Keijiro</forename><surname>Araki</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Makoto</forename><surname>Amamiya</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="51" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<ptr target="https://en.wikipedia.org/wiki/Address_space_layout_randomization" />
		<title level="m">Wikipedia contributors</title>
				<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
	<note>ASLR</note>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<ptr target="https://en.wikipedia.org/wiki/WebAssembly" />
		<title level="m">Wikipedia contributors</title>
				<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
	<note>WebAssembly</note>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">CACTI: an enhanced cache access and cycle time model</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J E</forename><surname>Wilton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Jouppi</surname></persName>
		</author>
		<idno type="DOI">10.1109/4.509850</idno>
		<ptr target="https://doi.org/10.1109/4.509850" />
	</analytic>
	<monogr>
		<title level="j">IEEE Journal of Solid-State Circuits</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="677" to="688" />
			<date type="published" when="1996">1996. 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">A top-down method for performance analysis and counters architecture</title>
		<author>
			<persName><forename type="first">Ahmad</forename><surname>Yasin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2014 IEEE International Symposium on Performance Analysis of Systems and Software (ISPASS)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="35" to="44" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Execution history guided instruction prefetching</title>
		<author>
			<persName><forename type="first">Yi</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steve</forename><surname>Haga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rajeev</forename><surname>Barua</surname></persName>
		</author>
		<idno type="DOI">10.1145/514191.514220</idno>
		<ptr target="https://doi.org/10.1145/514191.514220" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th international conference on Supercomputing (ICS &apos;02)</title>
				<meeting>the 16th international conference on Supercomputing (ICS &apos;02)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="199" to="208" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
