<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Thermometer: Profile-Guided BTB Replacement for Data Center Applications</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Shixin</forename><surname>Song</surname></persName>
							<email>shixins@umich.edu</email>
						</author>
						<author>
							<persName><forename type="first">Tanvir</forename><forename type="middle">Ahmed</forename><surname>Khan</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Sara</forename><forename type="middle">Mahdizadeh</forename><surname>Shahri</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Akshitha</forename><surname>Sriraman</surname></persName>
							<email>akshitha@cmu.edu</email>
						</author>
						<author>
							<persName><forename type="first">Sreenivas</forename><surname>Subramoney</surname></persName>
							<email>sreenivas.subramoney@intel.com</email>
						</author>
						<author>
							<persName><forename type="first">Daniel</forename><forename type="middle">A</forename><surname>Jim√©nez</surname></persName>
							<email>djimenez@acm.org</email>
						</author>
						<author>
							<persName><forename type="first">Heiner</forename><surname>Litz</surname></persName>
							<email>hlitz@ucsc.edu</email>
						</author>
						<author>
							<persName><forename type="first">Baris</forename><surname>Kasikci</surname></persName>
							<email>barisk@umich.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">University of Michigan</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">University of Michigan</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">University of Michigan</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">Carnegie Mellon University</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="department">Niranjan K Soundararajan</orgName>
								<orgName type="institution">Intel Corporation</orgName>
								<address>
									<country key="IN">India</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="institution">Intel Corporation</orgName>
								<address>
									<country key="IN">India</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff6">
								<orgName type="institution">Texas A&amp;M University</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff7">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Santa Cruz</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff8">
								<orgName type="institution">University of Michigan</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Thermometer: Profile-Guided BTB Replacement for Data Center Applications</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/3470496.3527430</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2023-01-01T13:25+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Cache replacement</term>
					<term>frontend stalls</term>
					<term>branch target buffer</term>
					<term>data center</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Modern processors employ a decoupled frontend with Fetch Directed Instruction Prefetching (FDIP) to avoid frontend stalls in data center applications. However, the large branch footprint of data center applications precipitates frequent Branch Target Buffer (BTB) misses that prohibit FDIP from eliminating more than 40% of all frontend stalls. We find that the state-of-the-art BTB optimization techniques (e.g., BTB prefetching and replacement mechanisms) cannot eliminate these misses due to their inadequate understanding of branch reuse behavior in data center applications.</p><p>In this paper, we first perform a comprehensive characterization of the branch behavior of data center applications, and determine that identifying optimal BTB replacement decisions requires considering both transient and holistic (i.e., across the entire execution) branch behavior. We then present Thermometer, a novel BTB replacement technique that realizes the holistic branch behavior via a profile-guided analysis. Based on the collected profile, Thermometer generates useful BTB replacement hints that the underlying hardware can leverage. We evaluate Thermometer using 13 widelyused data center applications and demonstrate that it provides an average speedup of 8.7% (0.4%-64.9%) while outperforming the state-of-the-art BTB replacement techniques by 5.6√ó (on average, the best performing prior work achieves 1.5% speedup). We also demonstrate that Thermometer achieves a performance speedup that is, on average, 83.6% of the speedup achieved by the optimal BTB replacement policy.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Large instruction footprints exhibited by modern data center applications induce significant stalls in the frontend of the processor pipeline, introducing performance losses worth millions of dollars <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b41">42,</ref><ref type="bibr" target="#b66">67,</ref><ref type="bibr" target="#b103">104,</ref><ref type="bibr" target="#b106">107,</ref><ref type="bibr" target="#b132">133]</ref>. Modern data center applications exhibit multi-megabyte code footprints <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b66">67,</ref><ref type="bibr" target="#b105">106,</ref><ref type="bibr" target="#b106">107]</ref> due to their complex application logic <ref type="bibr" target="#b103">[104]</ref> and frequent use of different libraries <ref type="bibr" target="#b66">[67]</ref>, language runtimes <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b102">103]</ref>, and kernel modules <ref type="bibr" target="#b26">[27]</ref>. Data center applications' large code footprints do not fit in the processor's instruction cache (I-cache) <ref type="bibr" target="#b24">[25]</ref>. As a result, the processor fails to fetch sufficient instructions, leading to frequent frontend stalls. Since even single-digit performance gains in data center applications can minimize the Total Cost of Ownership (TCO) <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b66">67]</ref> and reduce data center carbon emissions <ref type="bibr" target="#b132">[133]</ref>, there is a critical need to mitigate frontend stalls to improve data center efficiency.</p><p>Prior works have proposed numerous techniques to mitigate frontend stalls including compiler-based Profile-Guided Optimizations (PGO) <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b46">47,</ref><ref type="bibr" target="#b105">106,</ref><ref type="bibr" target="#b106">107,</ref><ref type="bibr" target="#b112">113]</ref> and hardware-based instruction prefetchers <ref type="bibr">[43, 44, 72, 73, 82-84, 108, 119, 121, 131]</ref>. On the software side, PGO techniques improve instruction locality by putting frequently executed I-cache lines together. Though, in theory, these  <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b59">60,</ref><ref type="bibr" target="#b61">62]</ref> over an LRU baseline: existing mechanisms provide an average speedup of 1.5%, although an optimal replacement policy <ref type="bibr" target="#b28">[29]</ref> provides an average speedup of 10.4%.</p><p>Hence, there is a significant performance gap between the state-of-the-art and the optimal replacement policy. code layout optimization techniques are sensitive to profile quality <ref type="bibr" target="#b54">[55]</ref>, they work exceptionally well in practice <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b46">47,</ref><ref type="bibr" target="#b99">100,</ref><ref type="bibr" target="#b105">106,</ref><ref type="bibr" target="#b106">107]</ref>. Profiles for data center applications change slowly over several weeks <ref type="bibr" target="#b32">[33]</ref> while data center operators profile and recompile applications multiple times a day <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b105">106,</ref><ref type="bibr" target="#b106">107]</ref>. Consequently, these automated techniques have ample opportunity to adapt to changing application profiles and are widely used in today's data centers <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b46">47,</ref><ref type="bibr" target="#b105">106,</ref><ref type="bibr" target="#b106">107]</ref>. For example, half of all CPU cycles in Google data centers are spent in PGO-optimized binaries <ref type="bibr" target="#b32">[33]</ref>. Therefore, we leverage PGO techniques' effectiveness in this work. Among hardware techniques, Fetch Directed Instruction Prefetching (FDIP) <ref type="bibr" target="#b117">[118,</ref><ref type="bibr" target="#b118">119]</ref> is an effective technique employed by modern processors <ref type="bibr" target="#b48">[49,</ref><ref type="bibr" target="#b108">109,</ref><ref type="bibr" target="#b122">123,</ref><ref type="bibr" target="#b134">135]</ref> to reduce frontend stalls. FDIP decouples the branch prediction unit from the instruction fetch unit so that the frontend can run ahead, producing the instruction addresses likely to be executed in the near future. Prefetching I-cache lines corresponding to these future accesses avoids potential frontend stalls <ref type="bibr" target="#b82">[83,</ref><ref type="bibr" target="#b83">84]</ref>, providing performance similar to aggressive I-cache prefetchers <ref type="bibr" target="#b56">[57,</ref><ref type="bibr" target="#b57">58]</ref>.</p><p>However, FDIP performs well only as long as the Branch Target Buffer (BTB) supplies correct targets for all taken branches <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b74">75,</ref><ref type="bibr" target="#b82">83,</ref><ref type="bibr" target="#b83">84,</ref><ref type="bibr" target="#b131">132]</ref>. Prior works have found that FDIP's performance is significantly limited by BTB misses that stall FDIP's prefetching <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b74">75,</ref><ref type="bibr" target="#b82">83,</ref><ref type="bibr" target="#b83">84]</ref> or cause FDIP to prefetch incorrect instructions on the wrong path <ref type="bibr" target="#b43">[44,</ref><ref type="bibr" target="#b131">132]</ref>. As we and others <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b74">75,</ref><ref type="bibr" target="#b82">83,</ref><ref type="bibr" target="#b83">84,</ref><ref type="bibr" target="#b131">132]</ref> show, this limitation inhibits FDIP from eliminating more than 40% of all frontend stalls in data center applications.</p><p>To this end, we thoroughly analyze the BTB access behavior of modern data center applications that limit FDIP's effectiveness. We find that data center applications exhibit a unique branch reuse behavior that is difficult to capture, causing wasteful BTB evictions. As a result, existing BTB prefetching mechanisms <ref type="bibr" target="#b72">[73,</ref><ref type="bibr" target="#b82">83]</ref> fall short as they bring in unused branch entries into the BTB, failing to avoid the majority of frontend stalls. Since avoiding wasteful evictions is the main responsibility of an effective BTB replacement policy, we evaluate state-of-the-art replacement policies (GHRP <ref type="bibr" target="#b19">[20]</ref>, Hawkeye <ref type="bibr" target="#b59">[60]</ref>, and SRRIP <ref type="bibr" target="#b61">[62]</ref>) in the context of data center applications' BTB access patterns. As shown in Fig. <ref type="figure" target="#fig_0">1</ref>, these policies provide a negligible speedup (1.5% on average) over the Least Recently Used (LRU <ref type="bibr" target="#b95">[96]</ref>) replacement policy. In contrast, an optimal BTB replacement policy provides 10.4% average speedup over LRU.</p><p>The key takeaway from our characterization is that existing replacement policies do not account for the diversity of BTB access patterns among different executions of the same branch, inhibiting them from predicting and evicting the branch that is taken furthest in the future.</p><p>We quantify the diversity of BTB access patterns using reuse distance <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b61">62]</ref> and introduce the concept of transient and holistic reuse distance. The transient reuse distance is the most recent reuse distance that the BTB entry experiences. The holistic reuse distance of a BTB entry is the average reuse distance for all instances of a branch across the entire execution. For data center applications, we show that the transient reuse distance varies significantly (more than 2√ó) from the holistic reuse distance. Consequently, we observe that replacing BTB entries based on a holistic pattern is more beneficial than replacement decisions made using a transient pattern used by prior work <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b59">60,</ref><ref type="bibr" target="#b61">62]</ref>.</p><p>To classify branches using their holistic pattern, we introduce a metric, "branch temperature" based on the hit-to-taken percentage of a branch under the optimal BTB replacement policy, which measures the benefit (i.e., the number of BTB hits) per given execution of a branch (i.e., the number of times the branch is taken). We find that a branch's hit-to-taken percentage captures the holistic pattern of that branch as 'hot' branches with a high hit-to-taken percentage result in more hits and are more valuable to keep in the BTB than 'cold' branches with a low hit-to-taken percentage.</p><p>Driven by our characterization's insights, we propose Thermometer, a novel BTB replacement technique that accommodates both holistic and transient patterns of branches in data center applications. Thermometer calculates the holistic pattern via an offline profile-guided analysis. Thermometer performs this analysis on a trace of executed branch instructions collected via efficient hardware support (e.g., Intel PT <ref type="bibr" target="#b0">[1]</ref>). Based on this profile-guided analysis, Thermometer tags each branch with a hint defining its holistic pattern. Finally, Thermometer introduces a small hardware enhancement to the BTB replacement policy to enable eviction decisions based on both the injected hint and the transient pattern.</p><p>We evaluate Thermometer for (1) 13 widely-used data center applications that experience frequent frontend stalls, (2) 663 industry traces from 5 ùë°‚Ñé Championship Branch Prediction (CBP-5) <ref type="bibr" target="#b14">[15]</ref>, and (3) 50 traces from 1 ùë†ùë° Instruction Prefetching Championship (IPC-1) <ref type="bibr" target="#b16">[17]</ref>. Across all applications, Thermometer achieves an average IPC speedup of 8.7% (0.4%-64.9%) by avoiding 21.3% of all BTB misses. In comparison, the best performing prior work <ref type="bibr" target="#b61">[62]</ref> provides an average IPC speedup of 1.5% and covers 6.7% of all BTB misses. Consequently, Thermometer achieves 5.6√ó greater speedup by eliminating 3.2√ó additional misses compared to the state-of-the-art BTB replacement techniques <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b59">60,</ref><ref type="bibr" target="#b61">62]</ref>. Across 663 CBP-5 traces (that do not allow generating IPC numbers <ref type="bibr" target="#b19">[20]</ref>), Thermometer provides an average BTB miss reduction of 2.25% over the best performing prior work <ref type="bibr" target="#b19">[20]</ref>. Across 50 IPC-1 traces, Thermometer achieves an average IPC speedup of 1.07% compared to 0.45% mean speedup provided by the best performing prior work <ref type="bibr" target="#b61">[62]</ref>. Overall, Thermometer achieves a performance speedup that is, on average, 83.6% of the speedup offered by the optimal BTB replacement policy.</p><p>In summary, we contribute: ‚Ä¢ A comprehensive characterization of the branch behavior of data center applications that shows that considering both holistic and </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">UNDERSTANDING THE CHALLENGES OF BTB REPLACEMENT</head><p>In this section, we analyze the frontend performance of 13 data center applications. We find that performance, to a large degree, is determined by the BTB's hit rate, which in turn is limited by the efficacy of the BTB replacement policy. We show that existing replacement policies exhibit a large performance gap compared to an optimal policy. We also provide insights to close this performance gap by 83.6%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Experimental methodology</head><p>Simulation parameters. We simulate and evaluate Thermometer using the ChampSim <ref type="bibr" target="#b4">[5]</ref> simulator and adjust simulation parameters to resemble a recent state-of-the-art industry FDIP baseline <ref type="bibr" target="#b56">[57,</ref><ref type="bibr" target="#b57">58]</ref>, as listed in Table <ref type="table" target="#tab_0">1</ref>. We implement the optimal BTB replacement policy (Belady's algorithm <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b60">61]</ref>) and other existing policies including SRRIP <ref type="bibr" target="#b61">[62]</ref>, GHRP <ref type="bibr" target="#b19">[20]</ref>, and Hawkeye <ref type="bibr" target="#b59">[60]</ref> to compare them with Thermometer. Data center applications. Prior work from Google and Facebook shows that their widely-deployed data center applications lose more than 15% of all pipeline slots due to frontend stalls <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b66">67,</ref><ref type="bibr" target="#b132">133]</ref>. As these applications are proprietary, we use the applications used by prior work <ref type="bibr" target="#b74">[75,</ref><ref type="bibr" target="#b76">77,</ref><ref type="bibr" target="#b77">78,</ref><ref type="bibr" target="#b85">86,</ref><ref type="bibr" target="#b99">100,</ref><ref type="bibr" target="#b137">138,</ref><ref type="bibr" target="#b149">150]</ref>, where frontend stalls are similarly frequent (more than 15%) due to large instruction footprints. These applications include cassandra <ref type="bibr" target="#b1">[2]</ref>, kafka <ref type="bibr" target="#b2">[3]</ref>, and tomcat <ref type="bibr" target="#b3">[4]</ref> from the Java DaCapo benchmark suite <ref type="bibr" target="#b30">[31]</ref>, drupal <ref type="bibr" target="#b141">[142]</ref>, wordpress <ref type="bibr" target="#b143">[144]</ref>, and mediawiki <ref type="bibr" target="#b142">[143]</ref> from Facebook's OSS -performance benchmark suite <ref type="bibr" target="#b15">[16]</ref>, finagle-chirper and finagle-http <ref type="bibr" target="#b11">[12]</ref> from the Java Renaissance benchmark suite <ref type="bibr" target="#b113">[114]</ref>, clang <ref type="bibr" target="#b5">[6]</ref> while building LLVM <ref type="bibr" target="#b84">[85]</ref>, PostgreSQL <ref type="bibr" target="#b9">[10]</ref> while serving pgbench <ref type="bibr" target="#b8">[9]</ref> queries, Python <ref type="bibr" target="#b13">[14]</ref> while running the pyperformance <ref type="bibr" target="#b10">[11]</ref> benchmark suite, MySQL <ref type="bibr" target="#b145">[146]</ref> while serving TPC-C queries <ref type="bibr" target="#b34">[35]</ref>, and verilator <ref type="bibr" target="#b12">[13]</ref> while emulating the Rocket Chip <ref type="bibr" target="#b6">[7]</ref>. We use traces collected via Intel PT <ref type="bibr" target="#b0">[1]</ref> and modify ChampSim to simulate these traces. Using these traces, we characterize BTB replacement challenges to design Thermometer, a novel profileguided BTB replacement technique. We validate Thermometer's effectiveness on 13 data center applications and on CBP-5 <ref type="bibr" target="#b14">[15]</ref> and IPC-1 <ref type="bibr" target="#b16">[17]</ref> traces that prior work <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b56">57,</ref><ref type="bibr" target="#b57">58]</ref> evaluate their frontend optimizations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Why is the BTB replacement policy important?</head><p>To establish the importance of the BTB performance in modern Outof-Order (OoO) cores, we perform limit studies of different frontend structures determining their individual impact on performance. In Fig. <ref type="figure">2</ref>, we measure the Instructions Per Cycle (IPC) speedup achieved by a perfect BTB that faces no misses (i.e., every BTB access is a hit), a perfect branch predictor that always predicts taken and not taken branches correctly, and a perfect I-cache with no misses. On average, a perfect BTB achieves 63.2% speedup. In contrast, perfect branch direction prediction achieves merely 11.3% speedup and a perfect I-cache achieves only 21.5% speedup. These results indicate that with a perfect BTB, FDIP can provide more benefits than with a perfect I-cache or a perfect branch predictor. Hence, optimizing BTB performance is critical to eliminate frontend stalls in the most efficient manner (as also reported by prior work <ref type="bibr" target="#b74">[75,</ref><ref type="bibr" target="#b82">83,</ref><ref type="bibr" target="#b83">84,</ref><ref type="bibr" target="#b131">132]</ref>).</p><p>As shown in Fig. <ref type="figure">2</ref>, the perfect BTB and perfect I-cache provides significantly greater speedup for verilator than any other applications. As shown in Fig. <ref type="figure">3</ref>, this is because verilator exhibits at least 300√ó greater L2 cache level instructions Misses Per Kilo Instructions (L2iMPKI) than any other applications in the study. Recent works from data center providers <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b132">133]</ref> observe that their workloads' L2iMPKIs range from 10-40, which are considerably greater than L2iMPKIs of all 12 other applications and closer to verilator's L2iMPKI <ref type="bibr" target="#b41">(42)</ref>. Therefore, we study verilator's behavior as a proxy <ref type="bibr" target="#b52">[53]</ref> for real world data center applications.</p><p>We next investigate if the performance gap between a practical BTB and a perfect BTB can be closed by existing BTB optimization techniques. Prior work such as Confluence <ref type="bibr" target="#b72">[73]</ref> and Shotgun <ref type="bibr" target="#b82">[83]</ref> use BTB prefetching to reduce BTB misses and improve FDIP performance. In Fig. <ref type="figure">4</ref>, we compare the IPC speedups of these prior techniques against a perfect BTB's speedup. We assume that the baseline BTB does not have any prefetching and uses the LRU replacement policy.</p><p>As also observed by recent work <ref type="bibr" target="#b74">[75,</ref><ref type="bibr" target="#b131">132]</ref>, we find in Fig. <ref type="figure">4</ref> that Confluence <ref type="bibr" target="#b72">[73]</ref>   <ref type="bibr" target="#b72">[73,</ref><ref type="bibr" target="#b82">83]</ref> provide merely 1.4% mean speedup, while a perfect BTB offers 63.2% mean speedup. The optimal BTB replacement policy <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b60">61]</ref> significantly reduces this performance gap by providing 10.4% mean speedup.</p><p>Shotgun <ref type="bibr" target="#b82">[83]</ref> faces a slight slowdown as it wastes critical BTB capacity to store unused prefetch metadata. We corroborate the findings <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b74">75,</ref><ref type="bibr" target="#b131">132]</ref> of recent work and identify three reasons behind the performance degradation induced by these prior BTB prefetching policies <ref type="bibr" target="#b72">[73,</ref><ref type="bibr" target="#b82">83]</ref>. First, like any temporal prefetcher <ref type="bibr" target="#b138">[139]</ref><ref type="bibr" target="#b139">[140]</ref><ref type="bibr" target="#b140">[141]</ref>,</p><p>Confluence and Shotgun cannot avoid new and non-recurring temporal streams of BTB misses which constitute almost half (48%) of all BTB misses <ref type="bibr" target="#b74">[75]</ref>. Second, Shotgun statically partitions the BTB according to the branch type (e.g., conditional, unconditional). However, Shotgun's static partitioning does not necessarily match the working set sizes of conditional and unconditional branches for data center applications <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b74">75]</ref>. Third, Shotgun allocates valuable on-chip storage for not-taken branches <ref type="bibr" target="#b131">[132]</ref>, resulting in 26 ‚àí 45% of all conditional branches not fitting in the BTB <ref type="bibr" target="#b74">[75]</ref>. Hence, both these prior BTB prefetching techniques significantly fall short of the 63.2% average speedup achieved by a perfect BTB. In Fig. <ref type="figure">4</ref>, we also show the speedup achieved by a BTB with an optimal replacement policy (Belady's algorithm <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b60">61]</ref>). This provably optimal yet impractical replacement policy evicts the BTB entry that will be used furthest in the future <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b95">96,</ref><ref type="bibr" target="#b97">98]</ref>. Such a BTB makes optimal replacement decisions with perfect future knowledge and achieves an average IPC speedup of 10.4%. Moreover, the optimal BTB replacement policy improves the performance of these prior BTB prefetching techniques by avoiding prefetchinduced wasteful evictions. These results demonstrate that a BTB replacement policy that is more optimized than prior work <ref type="bibr" target="#b72">[73,</ref><ref type="bibr" target="#b82">83]</ref> can better close the performance gap between a baseline and a perfect BTB.</p><p>Observation: An optimal BTB replacement policy enables FDIP to achieve near-ideal performance. Insight: An efficient BTB replacement policy is crucial to improve FDIP's performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Why do prior replacement policies fall short?</head><p>In ¬ß2.2, we showed that the optimal BTB replacement policy achieves 10.4% average speedup. Now, we investigate whether existing replacement policies can provide similar speedup. To our knowledge, GHRP <ref type="bibr" target="#b19">[20]</ref> is the only replacement policy designed for the BTB. To expand the scope of our analysis, we also adapt existing data cache replacement policies such as Hawkeye <ref type="bibr" target="#b59">[60]</ref> and SRRIP <ref type="bibr" target="#b61">[62]</ref> to BTB. GHRP <ref type="bibr" target="#b19">[20]</ref> predicts dead BTB entries (entries that do not experience hits until eviction <ref type="bibr" target="#b96">[97]</ref>) using the global control flow history. To make a replacement decision, GHRP evicts the BTB entry that is most likely to be dead based on the prediction results.</p><p>Hawkeye <ref type="bibr" target="#b59">[60]</ref> simulates the optimal replacement policy [29] on an access history to determine if a given branch instruction is "BTB-friendly" or "BTB-averse", i.e., whether storing the branch information in the BTB results in a hit or a miss. When making a replacement decision, Hawkeye favors keeping BTB-friendly entries in the BTB and evicting BTB-averse entries.</p><p>SRRIP <ref type="bibr" target="#b61">[62]</ref> assumes that all newly-executed branch instructions are BTB-averse. SRRIP only marks a branch as BTB-friendly when the branch is executed again after it has been inserted into the BTB. When making replacement decisions, SRRIP prefers to evict BTB-averse entries.</p><p>Fig. <ref type="figure" target="#fig_0">1</ref> shows the speedup for different BTB replacement policies over the LRU baseline. As shown, none of the 13 applications we study significantly benefit from these existing replacement policies. Specifically, the state-of-the-art BTB replacement policy, GHRP does not perform well for applications with large working sets <ref type="bibr" target="#b77">[78]</ref>.</p><p>As purely hardware techniques, GHRP, Hawkeye, and SRRIP have no information about branches currently not in the BTB. Moreover, they lose all the information about a branch every time the corresponding BTB entry is evicted. Since large working set sizes (both instruction and branch footprint) are the key characteristics of data center applications <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b66">67,</ref><ref type="bibr" target="#b74">75,</ref><ref type="bibr" target="#b76">77,</ref><ref type="bibr" target="#b77">78,</ref><ref type="bibr" target="#b131">132]</ref>, it is necessary to retain branch reuse behavior even when the corresponding entry is not present in the BTB.</p><p>Among existing policies, only SRRIP provides a speedup (1.5% on average, up to 5.9%) for these data center applications. Still, SRRIP falls short of the optimal BTB replacement policy which offers an average IPC speedup of 10.4%.</p><p>To understand why existing BTB replacement policies perform poorly for data center applications, we introduce the concept of transient and holistic reuse distances. For a given BTB entry ùëã , reuse distance <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b61">62]</ref> is the number of unique BTB entries accessed between two consecutive accesses to ùëã (within the associative set to which ùëã belongs). The transient reuse distance refers to the reuse distance between the last two references of a BTB entry (e.g., the LRU replacement policy considers the transient reuse distance of accesses). The holistic reuse distance is the average reuse distance for all instances of a branch across the entire execution of a program. We find that existing BTB replacement policies perform poorly for data center applications because they only consider the transient reuse distance. For data center applications, this transient reuse distance significantly differs from the holistic reuse distance as we observe that the reuse distance for a given branch instruction varies widely during the program execution.</p><p>To quantify the variance of branch instructions' reuse distances, we define the reuse distance vector ùëé ùëñ of a certain branch ùëé, where ùëñ represents the ùëñ ùë°‚Ñé execution of that branch for ùëñ = 2, 3 . . . , ùëõ. Prior techniques <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b59">60,</ref><ref type="bibr" target="#b61">62]</ref> perform BTB replacement decisions based on a branch's transient (most recent) reuse distance and hence, they experience transient variance defined as follows:</p><formula xml:id="formula_0">Transient variance = 1 ùëõ ‚àí 2 ùëõ‚àí1 ‚àëÔ∏Å ùëñ=2 (ùëé ùëñ ‚àí ùëé ùëñ+1 ) 2</formula><p>Instead, we recommend performing BTB replacement decisions based on the holistic (average) reuse distance, ùëé, which experience holistic variance defined as follows:</p><formula xml:id="formula_1">Holistic variance: = 1 ùëõ ‚àí 1 ùëõ ‚àëÔ∏Å ùëñ=2 (ùëé ùëñ ‚àí ùëé) 2 .</formula><p>In Fig. <ref type="figure" target="#fig_1">5</ref>, we show the average transient and holistic variance for all 13 data center applications. As shown, transient variance for data center applications is significantly greater than the holistic variance. Consequently, replacement decisions made based on the transient reuse distance are less likely to be accurate as they suffer from higher variance than replacement decisions made using the holistic reuse distance.</p><p>Qualitatively, holistic reuse distance is more accurate than transient reuse distance as holistic reuse distance is computed using reuse distance samples from the entire execution. On the other hand, transient reuse distance is computed using samples from a short execution fragment. Consequently, holistic reuse distance is more accurate and representative of the broad dynamic behavior of a program. Moreover, data center applications' dynamic behavior shows increasing variation due to growing software complexity <ref type="bibr" target="#b66">[67,</ref><ref type="bibr" target="#b102">103,</ref><ref type="bibr" target="#b103">104,</ref><ref type="bibr" target="#b106">107]</ref>, making holistic reuse distance more useful.</p><p>Our observation also explains why prior replacement policies fall significantly short of the optimal replacement policy, as shown earlier in this subsection. The optimal BTB replacement policy makes replacement decisions using more holistic, future knowledge. Consequently, the optimal BTB replacement policy can compute a perfect reuse distance, making it more accurate than a policy using the transient reuse distance.</p><p>Observation: Existing replacement policies fall short when applied to BTB. Insight: It is necessary to analyze holistic branch execution patterns to design a new replacement policy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">How do we redesign BTB replacement?</head><p>As shown in ¬ß2.3, existing replacement policies suffer from a high transient variance due to their limited knowledge of the behavior of branches over time, and hence, perform poorly for data center applications. Since the optimal BTB replacement policy allows determining the perfect reuse distance for a given branch based on its future knowledge, we analyze the optimal BTB replacement policy to determine the holistic behavior of branches.</p><p>Our goal is to capture the relative benefit of caching a BTB entry. To do this, we define and compute a normalized metric called hitto-taken percentage, which measures the benefit (i.e., the number of BTB hits) per given execution of a branch instruction (i.e., the number of times the branch is taken).</p><p>Fig. <ref type="figure">6</ref> shows the distribution of hit-to-taken percentage for the optimal BTB replacement policy on several data center applications' execution traces. Due to space constraints, we only portray the behavior of three data center applications, drupal, kafka, and verilator; the remaining applications exhibit similar behaviors to drupal and kafka.</p><p>In Fig. <ref type="figure">6</ref>, the ùëã -axis represents the percentage of unique taken branches and the ùëå -axis represents the corresponding hit-to-taken percentage for the optimal BTB replacement policy. The hit-to-taken percentage indicates which branches would result in more hits (relative to how many times the branch is taken) and are hence more valuable to retain in the BTB. As shown in Fig. <ref type="figure">6</ref>, all branches from these applications can be categorized to three different types based on their hit-to-taken percentage. We mark branches with the highest hit-to-taken percentage as "hot" branches (marked by the red region), branches with the lowest hit-to-taken percentage as "cold" branches (marked by the blue region), and branches with a medium hit-to-taken percentage as "warm" branches (marked by the yellow region).</p><p>Consequently, we introduce a new metric based on the hit-totaken percentage, called the "branch temperature". The temperature of a branch indicates the branch's "hot/warm/cold" access behavior as observed under the optimal BTB replacement policy. In particular, for a given branch ùë• with a hit-to-taken percentage equal to ùë¶, we define ùë•'s branch temperature as:</p><formula xml:id="formula_2">Temperature (ùë•) = Ô£± Ô£¥ Ô£¥ Ô£¥ Ô£≤ Ô£¥ Ô£¥ Ô£¥ Ô£≥ cold ùë¶ ‚â§ ùë¶ 1 warm ùë¶ 1 &lt; ùë¶ ‚â§ ùë¶ 2 hot ùë¶ &gt; ùë¶ 2 ,</formula><p>where ùë¶ 1 and ùë¶ 2 are two empirically decided thresholds such that 0 ‚â§ ùë¶ 1 ‚â§ ùë¶ 2 ‚â§ 1. In our experiments, we find that using ùë¶ 1 = 50%, ùë¶ 2 = 80% works best. As shown in Fig. <ref type="figure">6</ref>, only half of all unique branches are hot and consistently retained in the BTB by the optimal replacement policy. Next, we analyze all dynamic BTB accesses to classify them based on the branch temperature. In Fig. <ref type="figure" target="#fig_3">7</ref>, the ùëã -axis represents the percentage of unique taken branches while the ùëå -axis represents The distribution of hit-to-taken percentage using the optimal BTB replacement policy for all unique taken branches. Branches are sorted (in descending order) based on their hit-to-taken percentage. The optimal policy consistently retains "hot" branches (half of all unique branches) and rarely stores "cold" branches (20% of all unique branches). accesses for all unique taken branches. Branches are sorted (in descending order) based on their hit-to-taken percentage for the optimal BTB replacement policy. "Hot" branches constitute a large majority (90%) of all BTB accesses.</p><p>the percentage of dynamically taken branches, i.e., the percentage of BTB accesses. We also mark regions of the corresponding "hot/warm/cold" branches as defined in Fig. <ref type="figure">6</ref>. We find that the "hot" branches marked in Fig. <ref type="figure" target="#fig_3">7</ref> account for more than 90% of dynamically taken branches. Therefore, when making replacement decisions, we can achieve a near-optimal performance if we retained more "hot" branches in the BTB and evict the "cold" and "warm" branches.</p><p>Finally, we compute the correlation between branch temperature and the holistic (average) reuse distance. As shown in Fig. <ref type="figure" target="#fig_5">8</ref>, branch temperature is strongly correlated with the holistic reuse distance. Therefore, branch temperature is able to capture the holistic behavior of branches over time.</p><p>In Fig. <ref type="figure" target="#fig_5">8</ref>, we also show if branch temperature has any correlation with properties of branch instructions such as the branch type (e.g., conditional and unconditional branches), branch target distance, and branch bias. If any of these properties have a strong correlation with the branch temperature, we could predict branch temperature based on those correlated properties without simulating the optimal BTB replacement policy on the entire application's trace. However, we observe that these branch properties do not have any strong correlation with the branch temperature. Therefore, we must compute the branch temperature by simulating the optimal BTB replacement policy on a data center application's trace.   Figure <ref type="figure">9</ref>: Average percentage of bypass out of all misses for branches with different temperature: the optimal replacement policy does not even insert cold branches into the BTB in more than 50% cases.</p><p>Observation: Branch "temperature" (determined by a branch's hit-to-taken percentage) is a good metric to drive efficient BTB replacement decisions.</p><p>Insight: Evicting cold or warm branches while keeping hot branches in the BTB can help attain near-optimal performance. However, accurate measurement of branch temperature requires simulation of the optimal BTB replacement policy on data center applications' traces.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Which entries are worth inserting into the BTB?</head><p>In ¬ß2.4, we showed how to redesign BTB replacement using the branch temperature. A BTB entry is replaced when a new entry is inserted. Now, we investigate if some of these insertions can be avoided to begin with, i.e., whether the BTB can be bypassed <ref type="bibr" target="#b44">[45,</ref><ref type="bibr" target="#b89">90]</ref> for some branches based on its temperature. For this, we measure the number of times a branch is inserted into the BTB and the number of times it bypasses the BTB, using the optimal replacement policy. We use these measurements to compute the average bypass ratio for branches in each temperature category.</p><p>As shown in Fig. <ref type="figure">9</ref>, both cold and warm branches have a higher bypass ratio, while hot branches have a lower bypass ratio. Hence, for a given cold or warm branch, we must compare the branch's temperature with the temperature of branches currently in the BTB to determine whether this branch must bypass the BTB. In contrast, based on Fig. <ref type="figure">9</ref>, we must always insert hot branches into the BTB to make near-optimal replacement decisions. Observation: The optimal replacement policy inserts most hot branches into the BTB, while (on average) half of all cold branches are not inserted. Insight: Before inserting a branch in the BTB, comparing it's temperature with branches that are already in the BTB to determine whether to bypass or not, can help make nearoptimal decisions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">DESIGN OF THERMOMETER</head><p>Our analysis shows that BTB replacement policies significantly affect the performance of data center applications. While the optimal BTB replacement policy achieves an average IPC speedup of 10.4% for data center applications, prior replacement policies <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b59">60,</ref><ref type="bibr" target="#b61">62]</ref> are unable to provide a substantial performance benefit (only 1.5% mean IPC speedup) over LRU. Prior replacement policies fall short since they only leverage transient branch information and do not consider holistic branch behavior. We now present Thermometer, a novel BTB replacement technique that leverages hardware-software co-design to accommodate both holistic and transient branch behavior of data center applications. Specifically, Thermometer introduces a profile-guided software mechanism to learn holistic branch behavior and then introduces minor hardware modifications to the replacement policy to consider both behaviors, enabling near-optimal replacement decisions.</p><p>Thermometer determines branch temperature based on the hitto-taken percentage under the optimal replacement policy using a profile-guided analysis. Branch instructions are annotated with their temperature and stored as part of a BTB entry whenever a branch is inserted into the BTB. Whenever the replacement policy needs to determine an eviction candidate it considers both temperature and LRU information of the candidates as described in Algorithm 1. In particular, Thermometer first selects the coldest branch (including the branch to be inserted in BTB) for eviction or, in the case of a tie, selects a candidate based on LRU.</p><p>We show all four of Thermometer's design components in Fig. <ref type="figure" target="#fig_7">10</ref>. In step 1 ( ¬ß3.1), Thermometer collects the basic block execution profile of data center applications at run time with the help of efficient hardware mechanisms <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b75">76,</ref><ref type="bibr" target="#b78">79]</ref>. In step 2 ( ¬ß3.2), Thermometer simulates the optimal BTB replacement policy offline on the branch execution profile to determine the temperature of all branch instructions. In step 3 ( ¬ß3.3), Thermometer encodes the temperature as a hint in the branch instruction. Finally, in step 4 ( ¬ß3.4), Thermometer's updated BTB replacement policy leverages Thermometer-injected hints to make close-to-optimal replacement decisions. Now, we describe each of these four components in detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Profile Collection</head><p>Thermometer collects the basic block execution trace using Intel PT <ref type="bibr" target="#b0">[1]</ref>. Similar to prior work <ref type="bibr" target="#b77">[78]</ref>, Thermometer uses Intel PT due to its low runtime overhead (only up to 1% <ref type="bibr" target="#b68">[69]</ref><ref type="bibr" target="#b69">[70]</ref><ref type="bibr" target="#b70">[71]</ref><ref type="bibr" target="#b150">151]</ref>) and widespread adoption in today's data centers <ref type="bibr" target="#b35">[36,</ref><ref type="bibr" target="#b38">39]</ref>. Intel PT provides Thermometer with a trace of dynamically executed branch instructions. As we show in Fig. <ref type="figure" target="#fig_7">10</ref>, the trace contains two specific data points for each branch instruction. First, the trace includes the direction of a branch, i.e., taken (T) or not-taken (NT). Second, in case of a taken indirect branch, the trace also contains the address of the next executed instruction. While Intel PT provides a comprehensive execution history that enables control-flow analysis, it does not collect any data about BTB replacement actions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Measuring the Branch Temperature</head><p>Thermometer simulates the branch execution trace offline using the optimal replacement policy (Belady's algorithm <ref type="bibr" target="#b28">[29]</ref>) to measure the temperature of all branch instructions in the application. As we show in ¬ß4.2, the overhead of simulating the optimal replacement policy is similar to those of widely-adopted profile-guided optimization techniques <ref type="bibr" target="#b105">[106,</ref><ref type="bibr" target="#b106">107]</ref>. To calculate branch temperature, Thermometer counts two metrics for each branch instruction. First, Thermometer counts the times a given branch instruction is taken during the program execution. Second, Thermometer counts the times when the taken branch's target can be found in the BTB while operating under the optimal replacement policy. Thermometer computes the temperature for each branch instruction after dividing the second value (BTB hit count under optimal replacement policy) by the first value (branch taken count) and expressing the division result as a fraction of 100.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Hint Injection</head><p>The goal of Thermometer's hint injection is to mark hot and cold branch instructions differently so that the BTB replacement policy can evict cold branches while keeping hot branches in the BTB. In the context of hint injection, Thermometer faces two main design decisions: (1) how many temperature categories (and resulting bits) to use and (2) which temperature thresholds to use for classifying branches into one of these categories. Hint size. Encoding the temperature as part of every branch instruction increases the instruction working set size and also requires additional storage in the BTB. For example, assuming an 8K entry BTB and 16 temperature categories, Thermometer introduces a storage overhead of 4KB which may be better invested in additional BTB entries. Using a small number of bits, on the other hand, introduces quantization errors as Thermometer may inject the same hint for two branches with a high temperature difference. It is therefore important to pick a suitable number of temperature categories while minimizing storage overheads. In practice, we find that a 2-bit hint offers a good trade-off between quantization inaccuracy and storage overhead. Such a 2-bit hint is practically implementable since both x86 and arch64 branch instruction formats have at least 2 unused bits reserved for future usage <ref type="bibr" target="#b49">[50,</ref><ref type="bibr" target="#b123">124]</ref>. Consequently, a 2-bit hint enables Thermometer to provide the temperature category as a replacement hint without incurring any overhead to the application's code footprint. We study Thermometer's sensitivity for different hint sizes in ¬ß4.3. Temperature thresholds. Depending on the number of temperature categories, Thermometer must determine how to classify branches into categories. A naive approach is to divide branches uniformly so that all temperature categories have an equal number of branches. However, with such an approach, Thermometer may group two branches with high temperature difference together in the same category. Such a categorization might occur especially for branches near the cliffs <ref type="bibr" target="#b27">[28]</ref> (areas with high slope in Figure <ref type="figure">6</ref>, where temperature drops sharply). To address this issue, Thermometer assigns temperature categories to different branch instructions based on empirically determined temperature thresholds. Specifically, with three categories (i.e., hot, warm, and cold), we observe that the temperature thresholds, 80% and 50% yield the best performance for data center applications. If needed, these thresholds are configurable to meet different applications' behavior.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Microarchitectural Modifications</head><p>Thermometer extends the BTB replacement policy implemented in hardware to consider the temperature hint encoded in the branch instruction. As Thermometer encodes a 2-bit hint for each branch instruction, Thermometer modifies the baseline BTB to include 2 extra bits per BTB entry. For an 8K-entry, 4-way, 75KB baseline BTB, this modification introduces a 2KB of extra storage overhead (2.67%). Using these extra bits, the BTB policy can distinguish hot (or BTB-friendly entries) from cold (or BTB-averse entries) to make eviction decisions during the program execution.</p><p>Algorithm 1 presents a simplified version of Thermometer's BTB replacement policy implemented in hardware. The algorithm takes a list of branch instructions as input and returns the victim branch instruction to be evicted from the BTB as output. Along with branches that are already in the BTB, the algorithm also considers the current branch instruction, ùë• 0 for which the new entry would be inserted into the BTB, as the potential victim. For all these instructions, the algorithm populates the temperature (Line 1-2) and then finds the coldest temperature, ùë° (Line 3) among them to leverage holistic reuse behavior. Next, the algorithm considers all branch instructions with the coldest temperature ùë° as possible victim candidates (Line 4). Among those victim candidates Thermometer selects the final line according to the least recently used heuristic (Line 7) leveraging transient reuse behavior. Thus, Thermometer combines the best of both worlds: holistic and transient branch reuse behavior to make effective BTB replacement decisions.</p><p>Thermometer adds one extra operation over the LRU baseline, which is finding the coldest temperature. For a 4-way BTB, this operation requires comparing five (ùê¥, ùêµ, ùê∂, ùê∑, ùê∏) 2-bit values. We can compute whether A is the coldest way as, ùê¥ ùëê = (ùê¥&lt;ùêµ) &amp; (ùê¥&lt;ùê∂) &amp; (ùê¥&lt;ùê∑) &amp; (ùê¥&lt;ùê∏). Each of these comparisons has an overall gate delay of only 3 logic gates (e.g., ùê¥&lt;ùêµ = (ùêµ</p><formula xml:id="formula_3">1 &amp;!ùê¥ 1 ) | (ùêµ 0 &amp;ùêµ 1 &amp;!ùê¥ 0 ) | (!ùê¥ 1 &amp;!ùê¥ 0 &amp;ùêµ 0 )</formula><p>) and different comparisons (e.g., ùê¥&lt;ùêµ and ùê¥&lt;ùê∂) can be performed in parallel. Similarly, the logic to compute ùêµ ùëê and ùê∂ ùëê can also be performed in parallel. Even if this whole logic cannot be computed in a single cycle it can be easily pipelined, e.g., by registering the results of ùê¥&lt;ùêµ, ùê¥&lt;ùê∂, ùê¥&lt;ùê∑, and ùê¥&lt;ùê∏ in one cycle and performing the &amp; operation in the next cycle. Finally, Thermometer can also ensure fast lookup for the newly inserted BTB entries by placing them in a small replacement buffer similar to 32-entry prefetch buffer used by state-of-the-art BTB prefetching solutions <ref type="bibr" target="#b74">[75,</ref><ref type="bibr" target="#b82">83]</ref>. return ùë• 0 ‚ä≤ Bypass 7: ùëß ‚Üê the least recently used branch in ùëÜ. 8: return ùëß BTB size dependency. Thermometer categorizes branch instructions based on their temperature for a specific BTB size and associativity. While this classification is target architecture dependent, such target-dependent optimizations are already deployed in today's data centers by widely-used profile-guided optimization techniques <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b84">85,</ref><ref type="bibr" target="#b105">106,</ref><ref type="bibr" target="#b106">107]</ref>. Data center operators (e.g., Google and Facebook) already compile and deploy individual binaries for diverse processor types in their fleet <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b105">106,</ref><ref type="bibr" target="#b106">107,</ref><ref type="bibr" target="#b132">133]</ref>. Hence, Thermometer can be combined with existing build and deployment mechanisms used in real data centers today.</p><formula xml:id="formula_4">Algorithm</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">EVALUATION</head><p>In this section, we first describe our experimental methodology. Next, we evaluate how Thermometer improves data center applications' performance using several key metrics. Finally, we present various sensitivity studies, showing how different design parameters affect Thermometer's effectiveness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Methodology</head><p>Data center applications and inputs. As described in ¬ß2.1, we evaluate Thermometer using 13 widely-used data center applications. For these applications, we vary input configurations by changing the input data size (e.g., large vs small), the webpage requested by the client (e.g., feed=rss2 vs p=37), the number of client requests per second (e.g., 2 vs 10), random number seeds (e.g., 1 vs 10), different query mapping styles (e.g., imperative vs declarative), different database scaling factors (e.g., 100 vs 8000), and different database queries (e.g., oltp_read_only vs oltp_write_only). We profile only a portion of each application's execution; this portion is different from the tested execution and uses different inputs. Apart from evaluating Thermometer on these 13 real-world applications, we also evaluate Thermometer on a wide-range of common traces (663 CBP-5 <ref type="bibr" target="#b14">[15]</ref> traces and 50 IPC-1 <ref type="bibr" target="#b16">[17]</ref> traces) like prior work <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b56">57,</ref><ref type="bibr" target="#b57">58]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Performance analysis</head><p>We evaluate Thermometer's effectiveness using key performance metrics. First, we compare Thermometer's IPC speedup to the speedup offered by the optimal BTB replacement policy and state-of-the-art BTB replacement techniques <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b59">60,</ref><ref type="bibr" target="#b61">62]</ref>. We also evaluate the BTB miss reduction Thermometer achieves. Next, we show how Thermometer generalizes across different application inputs. We also evaluate Thermometer's replacement coverage and accuracy. IPC speedup. We measure the IPC speedup that Thermometer achieves over an LRU baseline for 13 data center applications. Fig. <ref type="figure" target="#fig_0">11</ref> shows Thermometer's speedup compared against speedups achieved by the optimal BTB replacement policy and three existing replacement policies (SRRIP <ref type="bibr" target="#b61">[62]</ref>, GHRP <ref type="bibr" target="#b19">[20]</ref>, and Hawkeye <ref type="bibr" target="#b59">[60]</ref>). We find that Thermometer always outperforms prior replacement policies and achieves comparable performance to the theoretically optimal BTB replacement policy. In particular, Thermometer provides 8.7% average speedup compared to 10.4% average speedup achieved by the optimal BTB replacement policy. In other words, Thermometer achieves an average speedup that is 83.6% of the average speedup achieved by the optimal BTB replacement policy. The small performance gap between Thermometer and the optimal BTB replacement policy stems from few cases where the branch behavior temporally diverges from both the profiled holistic and transient branch behavior.</p><p>We also investigate whether Thermometer would improve performance of a 75KB, 8K entry BTB when considering 2-bit overhead for each branch in BTB. We measure the speedup gained by a 7979-entry BTB that uses Thermometer over an 8K entry BTB that uses LRU. We ensure the same BTB size since 7979 √ó (entry size + 2 bits overhead) = 8192 √ó entry size = 75K. As shown, a 7979-entry BTB that uses Thermometer significantly outperforms existing BTB replacement mechanisms and achieves comparable performance to the optimal BTB replacement policy.</p><p>We use address modulo total number of BTB sets as the BTB hash function. For this function, the 7979-entry BTB distributes branches for some applications (e.g., cassandra, kafka, mysql) more uniformly than the 8192-entry BTB. Consequently, Thermometer achieves slightly better performance with the 7979-entry BTB than the 8192-entry BTB for these applications. BTB miss reduction. Fig. <ref type="figure" target="#fig_0">12</ref> shows the BTB miss reduction over LRU achieved by Thermometer and prior replacement policies. Thermometer achieves an average BTB miss reduction of 21.3%, outperforming existing replacement policies which achieve at most 6.7% average miss reduction. Thermometer's performance corresponds to 62.6% of the performance of the optimal BTB replacement policy which achieves an average miss reduction of 34%. Performance across different application inputs. Computing branch temperatures for one program input still provides replacement benefits for a different application input since on average 81% of all branches fall in the same temperature category across different inputs. We quantify this benefit in terms of Thermometer's speedup using three separate input configurations ('#1' to '#3').</p><p>We optimize each application using the training profile from input '#0' and measure Thermometer's speedup for all three different test inputs ('#1, #2, #3') in Fig. <ref type="figure" target="#fig_0">13</ref> (indicated as 'training-profile'). Next, we measure the speedup when Thermometer optimizes each application with the same input's profile for comparison, i.e., Thermometer's speedup for input '#1' using profile information that is also gathered using input '#1'. Fig. <ref type="figure" target="#fig_0">13</ref> shows this result as 'Sameinput-profile'. As shown, Thermometer provides significant speedup across different application inputs even with the training input's (different from the test input) profile since most branches have same temperature across different inputs.</p><p>For some applications (e.g., finagle-chirper and postgresql), Thermometer's speedup with the training input's profile is even greater than Thermometer's speedup with the same input's profile even though the training input's profile causes slightly more BTB misses than the same input's profile. In these cases, we find that training input's profile triggers less expensive BTB misses than the same input's profile as BTB misses incur variable miss penalty. Static and dynamic overhead. For each branch instruction, Thermometer introduces 2 bits for encoding the temperature category. Both ARM and x86 branch instructions have at least 2 unused bits reserved in the ISA for future optimizations <ref type="bibr" target="#b49">[50,</ref><ref type="bibr" target="#b123">124]</ref>, which we can use to encode the category information without any overhead in the new binary. Profiling overhead and cost of optimal replacement policy simulation. There is no extra online cost of Thermometer's profiling, as data center applications are already routinely profiled with Intel LBR and PT <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b38">39,</ref><ref type="bibr" target="#b105">106,</ref><ref type="bibr" target="#b106">107]</ref>. As we describe in ¬ß3, Thermometer simulates the optimal BTB replacement policy offline. The execution time for this offline simulation is in the order of seconds (4.18-167 seconds and 23.53 seconds on average), as shown in Fig. <ref type="figure" target="#fig_0">14</ref>. These durations are similar to those of existing postlink profile-guided optimization techniques <ref type="bibr" target="#b105">[106,</ref><ref type="bibr" target="#b106">107]</ref> (19.5-168.3 seconds <ref type="bibr" target="#b106">[107]</ref>). Replacement coverage and accuracy. We define "not covered by Thermometer" as the cases when all branches in a target set are in the "coldest category", and Thermometer relies on LRU to choose a victim. This case will be similar to the LRU baseline. We measure Thermometer's replacement coverage in terms of the percentage of evictions that are "covered by Thermometer". As show in Fig. <ref type="figure" target="#fig_1">15</ref>, Thermometer achieves an average coverage of 61.4%.</p><p>In Fig. <ref type="figure" target="#fig_0">16</ref>, we also show the replacement accuracy by measuring the percentage of victims whose reuse distance is equal to or larger than the number of BTB ways. In particular, we evaluate 3 techniques. The first technique only considers transient reuse behavior. The second technique only considers holistic reuse behavior. The third technique, Thermometer, utilizes both transient and holistic reuse information. Note that the optimal replacement policy always ensures 100% replacement accuracy. On average, transient behavior achieves 46.06% accuracy, holistic behavior achieves 63.72% accuracy, and Thermometer achieves 68.20% accuracy. BTB miss reduction on CBP-5 traces. We also validate Thermometer's effectiveness in reducing BTB misses for 663 CBP-5 traces <ref type="bibr" target="#b14">[15]</ref>. Since these traces do not allow generating IPC numbers <ref type="bibr" target="#b19">[20]</ref>, we measure the BTB miss reduction (%) achieved by Thermometer over the best performing prior work, GHRP <ref type="bibr" target="#b19">[20]</ref>   these traces. As shown in Fig. <ref type="figure" target="#fig_12">17</ref>, Thermometer achieves an average BTB miss reduction of 2.25% over GHRP. Among all traces (52) that face BTB Misses Per Kilo Instructions (MPKI) of 1 or greater, Thermometer outperforms GHRP by 11.48% on average. Thermometer outperforms GHRP for 306 out of 663 traces while GHRP outperforms Thermometer only for 59 traces. The remaining 298 traces only suffer from compulsory BTB misses and all replacement policies achieve identical performance.</p><p>Thermometer could not outperform GHRP for 59 traces because the 50% and 80% thresholds do not yield the best performance for those traces. Consequently, when we find a better threshold using two-fold cross-validation <ref type="bibr" target="#b144">[145]</ref> for these 663 traces, Thermometer outperforms GHRP for all but 32 traces, as also shown in Fig. <ref type="figure" target="#fig_12">17</ref>. Speedup on IPC-1 traces. To further evaluate Thermometer, we also measure and show the IPC speedup achieved by Thermometer for 50 IPC-1 <ref type="bibr" target="#b16">[17]</ref> traces in Fig. <ref type="figure" target="#fig_13">18</ref>. Thermometer achieves an average IPC speedup of 1.07% (up to 5.36%) and outperforms prior replacement mechanisms. The best-performing prior work, SRRIP offers merely 0.45% speedup on average. Among all traces (9) that suffer from a BTB MPKI of at least 1, Thermometer achieves an average IPC speedup of 3.59%. For one of the IPC-1 traces (server_010), both Thermometer and SRRIP outperform the optimal replacement policy in terms of IPC speedup though they incur more BTB misses than the optimal replacement policy. That is because the optimal replacement policy is optimal in terms of reducing the total number of misses and does not consider the variable latency incurred by each individual misses <ref type="bibr" target="#b115">[116]</ref>. Nevertheless, Thermometer achieves 85.7% of the speedup (on average 1.25%) provided by the optimal BTB replacement policy. Therefore, Thermometer is able to make near-optimal BTB replacement decisions for IPC-1 traces.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Sensitivity analysis</head><p>Number of BTB entries. We vary the number of BTB entries from 1024 to 32768 to measure how sensitive Thermometer is to the BTB size. As shown in Fig. <ref type="figure" target="#fig_14">19</ref> (left), Thermometer outperforms SRRIP significantly for any BTB size and performs better relative to the optimal BTB replacement policy with a larger BTB size. BTB associativity. We also measure Thermometer's sensitivity to the BTB associativity by varying the number of BTB ways from 4 to 128. As shown in Fig. <ref type="figure" target="#fig_14">19</ref> (right), Thermometer outperforms SRRIP significantly for any number of BTB ways. For some traces like cassandra and drupal, Thermometer's performance relative to the optimal BTB replacement policy decreases as the number of BTB ways increases, while for other traces like tomcat, Thermometer's performance increases as the number of BTB ways increases. Number of bits encoding branch temperature. We investigate Thermometer's effectiveness with various hint sizes to encode branch temperatures. We change the number of encoding bits from 1 to 4 and choose 2, 3, 4, 8, 16 categories to measure Thermometer's speedup compared to the optimal BTB replacement policy. As shown in Fig. <ref type="figure" target="#fig_16">20</ref> (left), Thermometer achieves the best performance when (1) using 2 bits to encode categories and (2) classifying branches into 3 or 4 categories. With fewer categories (e.g., 2 categories), Thermometer cannot characterize all branches' reuse behavior, reducing coverage as more branches are misclassified into the same category. Using more categories such as 8 or 16, leads to separation of branches with similar reuse behavior into different categories, reducing the opportunity for the backing LRU policy to determine transient changes in the reuse behavior dynamically. FDIP run-ahead. We evaluate Thermometer's sensitivity to the size of Fetch Target Queue (FTQ), i.e., the maximum run-ahead distance of the decoupled frontend. We carry out the experiment using FTQ sizes of {64, 128, 192, 256} and measure the optimal BTB speedup percentage achieved by Thermometer. As shown in Fig. <ref type="figure" target="#fig_16">20 (right)</ref>, Thermometer achieves almost constant speedup relative to the optimal BTB replacement policy with different FTQ sizes. Therefore, Thermometer generalizes well for different FDIP implementations. Prefetch-aware replacement. We evaluate Thermometer's sensitivity to the state-of-the-art BTB prefetching mechanism, Twig <ref type="bibr" target="#b74">[75]</ref> and show the results in Fig. <ref type="figure" target="#fig_17">21</ref>. As shown, the combination of Thermometer and Twig provides an average IPC speedup of 30.9% over    the baseline combination of LRU and Twig. Even with BTB prefetching, Thermometer significantly outperforms the best performing prior replacement policy (SRRIP) which provides only 1.37% mean speedup. On average, Thermometer's speedup is 95.9% of the average speedup (32.2%) provided by the optimal replacement policy.   with state-of-the-art BTB prefetching, Twig <ref type="bibr" target="#b74">[75]</ref>. Thermometer +Twig achieves an average speedup of 30.9% over the LRU+Twig baseline. Thus, Thermometer achieves 95.9% of the average speedup (32.2%) provided by the optimal replacement policy.</p><formula xml:id="formula_5">#1 #2 #3 #1 #2 #3 #1 #2 #3 #1 #2 #3 #1 #2 #3 #1 #2 #3 #1 #2 #3 #1 #2 #3 #1 #2 #3 #1 #2 #3 #1 #2 #3 #1 #2 #3 #1 #2 #3</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">RELATED WORK</head><p>I-cache performance optimization. There are three main classes of prior techniques that optimize I-cache performance: software, hardware, and hybrid software-hardware. Software techniques include hot/cold splitting <ref type="bibr" target="#b33">[34]</ref>, block reordering <ref type="bibr" target="#b104">[105,</ref><ref type="bibr" target="#b112">113]</ref>, and other profile-guided optimization approaches <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b51">52,</ref><ref type="bibr" target="#b53">54,</ref><ref type="bibr" target="#b62">63,</ref><ref type="bibr" target="#b88">89,</ref><ref type="bibr" target="#b90">91,</ref><ref type="bibr" target="#b93">94,</ref><ref type="bibr" target="#b94">95,</ref><ref type="bibr" target="#b105">106,</ref><ref type="bibr" target="#b110">111,</ref><ref type="bibr" target="#b116">117,</ref><ref type="bibr" target="#b148">149]</ref>. While software techniques improve instruction and eliminate a subset of all I-cache misses, in practice it is intractable to find the optimal code layout <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b111">112]</ref>. Hardware techniques include next-line prefetchers <ref type="bibr" target="#b130">[131]</ref>, path-based prefetchers <ref type="bibr" target="#b58">[59,</ref><ref type="bibr" target="#b121">122]</ref>, record-and-replay prefetchers <ref type="bibr" target="#b42">[43,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b71">72,</ref><ref type="bibr" target="#b72">73]</ref>, and BTBdirected prefetchers <ref type="bibr" target="#b82">[83,</ref><ref type="bibr" target="#b83">84]</ref>. These techniques usually have one of two limitations: (1) the design is more complex <ref type="bibr" target="#b71">[72,</ref><ref type="bibr" target="#b72">73,</ref><ref type="bibr" target="#b81">82]</ref> than real hardware prefetching implementations <ref type="bibr" target="#b118">[119,</ref><ref type="bibr" target="#b121">122]</ref> or (2) the on-chip storage cost is too high <ref type="bibr" target="#b42">[43,</ref><ref type="bibr" target="#b43">44]</ref>. Hybrid techniques <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b76">77]</ref> combine the effectiveness of software and hardware mechanisms but further increase the code footprint of data center applications. FDIP <ref type="bibr" target="#b117">[118,</ref><ref type="bibr" target="#b118">119]</ref> offers a good trade-off among existing I-cache prefetchers as it provides performance comparable to state-of-theart prefetchers <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b45">46,</ref><ref type="bibr" target="#b47">48,</ref><ref type="bibr" target="#b50">51,</ref><ref type="bibr" target="#b98">99,</ref><ref type="bibr" target="#b100">101,</ref><ref type="bibr" target="#b119">120,</ref><ref type="bibr" target="#b126">127]</ref> without incurring a high storage cost <ref type="bibr" target="#b56">[57,</ref><ref type="bibr" target="#b57">58]</ref>. Consequently, FDIP and its variants are employed in modern processors <ref type="bibr" target="#b48">[49,</ref><ref type="bibr" target="#b108">109,</ref><ref type="bibr" target="#b122">123,</ref><ref type="bibr" target="#b134">135]</ref>. Therefore, we attempted to improve the effectiveness of FDIP in this work through an optimized BTB replacement policy which requires negligible extra storage and hardware modification. BTB redesign and compression. In addition to storing branch targets <ref type="bibr" target="#b86">[87,</ref><ref type="bibr" target="#b109">110]</ref>, BTB entries generally contain a tag and prediction information, while block-oriented BTBs also need to store the size of the corresponding basic block <ref type="bibr" target="#b147">[148]</ref>. Existing work <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b39">40,</ref><ref type="bibr" target="#b64">65,</ref><ref type="bibr" target="#b80">81,</ref><ref type="bibr" target="#b109">110,</ref><ref type="bibr" target="#b117">118,</ref><ref type="bibr" target="#b127">128,</ref><ref type="bibr" target="#b131">132]</ref> proposes BTB compression techniques including using tags of fewer bits, removing page number, storing the branch target as a distance from the branch PC, or using a multilevel BTB. These techniques are orthogonal and can be combined with Thermometer to further improve the BTB storage efficiency.</p><p>Cache and BTB replacement mechanisms. Prior cache replacement policies can be categorized into two types: heuristic-based and learning-based replacement policies. The former category consists of LRU <ref type="bibr" target="#b67">[68,</ref><ref type="bibr" target="#b87">88,</ref><ref type="bibr" target="#b101">102,</ref><ref type="bibr" target="#b129">130]</ref>, MRU <ref type="bibr" target="#b114">[115]</ref>, reuse distance prediction <ref type="bibr" target="#b37">[38,</ref><ref type="bibr" target="#b40">41,</ref><ref type="bibr" target="#b92">93]</ref>, re-reference interval prediction (RRIP <ref type="bibr" target="#b61">[62]</ref>), and additional policies <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b44">45,</ref><ref type="bibr" target="#b55">56,</ref><ref type="bibr" target="#b79">80,</ref><ref type="bibr" target="#b115">116,</ref><ref type="bibr" target="#b124">125,</ref><ref type="bibr" target="#b133">134,</ref><ref type="bibr" target="#b135">136]</ref>. In the latter category, some learning-based replacement policies <ref type="bibr" target="#b60">[61,</ref><ref type="bibr" target="#b73">74,</ref><ref type="bibr" target="#b146">147]</ref> classify cache lines as cache-friendly and cache-adverse, others <ref type="bibr" target="#b59">[60,</ref><ref type="bibr" target="#b91">92,</ref><ref type="bibr" target="#b128">129]</ref> use information provided by the optimal replacement policy <ref type="bibr" target="#b28">[29]</ref>. Some recent replacement policies also use machine learning mechanisms <ref type="bibr" target="#b63">[64,</ref><ref type="bibr" target="#b65">66,</ref><ref type="bibr" target="#b136">137]</ref>. However, existing replacement polices are mainly designed for data caches and fall short when applied to the BTB. GHRP <ref type="bibr" target="#b19">[20]</ref> is a replacement policy designed for the BTB, but it falls short for data center applications due to their large instruction footprints. We propose a novel profile-guided BTB replacement approach that outperforms these existing replacement policies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSION</head><p>Data center applications exhibit large branch footprints and suffer from frequent BTB misses. Prior BTB prefetching and replacement mechanisms cannot mitigate these misses as they lack proper understanding of branch temperature in data center applications. In this work, we propose Thermometer, a profile-guided BTB replacement mechanism that considers both holistic and transient branch behaviour in data center applications. For 13 widely-used data center applications, Thermometer provides on average 8.7% (0.4%-64.9%) speedup that is 83.6% of the mean speedup achieved by the optimal BTB replacement policy.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure1: Speedup for state-of-the-art BTB replacement policies<ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b59">60,</ref><ref type="bibr" target="#b61">62]</ref> over an LRU baseline: existing mechanisms provide an average speedup of 1.5%, although an optimal replacement policy<ref type="bibr" target="#b28">[29]</ref> provides an average speedup of 10.4%. Hence, there is a significant performance gap between the state-of-the-art and the optimal replacement policy. code layout optimization techniques are sensitive to profile quality<ref type="bibr" target="#b54">[55]</ref>, they work exceptionally well in practice<ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b46">47,</ref><ref type="bibr" target="#b99">100,</ref><ref type="bibr" target="#b105">106,</ref><ref type="bibr" target="#b106">107]</ref>. Profiles for data center applications change slowly over several weeks<ref type="bibr" target="#b32">[33]</ref> while data center operators profile and recompile applications multiple times a day<ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b105">106,</ref><ref type="bibr" target="#b106">107]</ref>. Consequently, these automated techniques have ample opportunity to adapt to changing application profiles and are widely used in today's data centers<ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b46">47,</ref><ref type="bibr" target="#b105">106,</ref><ref type="bibr" target="#b106">107]</ref>. For example, half of all CPU cycles in Google data centers are spent in PGO-optimized binaries<ref type="bibr" target="#b32">[33]</ref>. Therefore, we leverage PGO techniques' effectiveness in this work.Among hardware techniques, Fetch Directed Instruction Prefetching (FDIP)<ref type="bibr" target="#b117">[118,</ref><ref type="bibr" target="#b118">119]</ref> is an effective technique employed by modern processors<ref type="bibr" target="#b48">[49,</ref><ref type="bibr" target="#b108">109,</ref><ref type="bibr" target="#b122">123,</ref><ref type="bibr" target="#b134">135]</ref> to reduce frontend stalls. FDIP decouples the branch prediction unit from the instruction fetch unit so that the frontend can run ahead, producing the instruction addresses likely to be executed in the near future. Prefetching I-cache lines corresponding to these future accesses avoids potential frontend stalls<ref type="bibr" target="#b82">[83,</ref><ref type="bibr" target="#b83">84]</ref>, providing performance similar to aggressive I-cache prefetchers<ref type="bibr" target="#b56">[57,</ref><ref type="bibr" target="#b57">58]</ref>.However, FDIP performs well only as long as the Branch Target Buffer (BTB) supplies correct targets for all taken branches<ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b74">75,</ref><ref type="bibr" target="#b82">83,</ref><ref type="bibr" target="#b83">84,</ref><ref type="bibr" target="#b131">132]</ref>. Prior works have found that FDIP's performance is significantly limited by BTB misses that stall FDIP's prefetching<ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b74">75,</ref><ref type="bibr" target="#b82">83,</ref><ref type="bibr" target="#b83">84]</ref> or cause FDIP to prefetch incorrect instructions on the wrong path<ref type="bibr" target="#b43">[44,</ref><ref type="bibr" target="#b131">132]</ref>. As we and others<ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b74">75,</ref><ref type="bibr" target="#b82">83,</ref><ref type="bibr" target="#b83">84,</ref><ref type="bibr" target="#b131">132]</ref> show, this limitation inhibits FDIP from eliminating more than 40% of all frontend stalls in data center applications.To this end, we thoroughly analyze the BTB access behavior of modern data center applications that limit FDIP's effectiveness. We find that data center applications exhibit a unique branch reuse behavior that is difficult to capture, causing wasteful BTB evictions. As a result, existing BTB prefetching mechanisms<ref type="bibr" target="#b72">[73,</ref><ref type="bibr" target="#b82">83]</ref> fall short as they bring in unused branch entries into the BTB, failing to avoid the majority of frontend stalls. Since avoiding wasteful evictions is the main responsibility of an effective BTB replacement policy, we evaluate state-of-the-art replacement policies (GHRP<ref type="bibr" target="#b19">[20]</ref>, Hawkeye<ref type="bibr" target="#b59">[60]</ref>, and SRRIP<ref type="bibr" target="#b61">[62]</ref>) in the context of data center applications' BTB access patterns. As shown in Fig.1, these policies provide a negligible speedup (1.5% on average) over the Least Recently Used (LRU<ref type="bibr" target="#b95">[96]</ref>) replacement policy. In contrast, an optimal BTB replacement policy provides 10.4% average speedup over LRU.The key takeaway from our characterization is that existing replacement policies do not account for the diversity of BTB access</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Average transient and holistic reuse distance variance for data center applications: the transient variance is significantly larger (more than 2√ó) than the holistic variance.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Figure6: The distribution of hit-to-taken percentage using the optimal BTB replacement policy for all unique taken branches. Branches are sorted (in descending order) based on their hit-to-taken percentage. The optimal policy consistently retains "hot" branches (half of all unique branches) and rarely stores "cold" branches (20% of all unique branches).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 7 :</head><label>7</label><figDesc>Figure7: The cumulative distribution of all dynamic BTB accesses for all unique taken branches. Branches are sorted (in descending order) based on their hit-to-taken percentage for the optimal BTB replacement policy. "Hot" branches constitute a large majority (90%) of all BTB accesses.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>c a s s a n d r a c l a n g d r u p a l fi n a g l e -c h i r p e r fi n a g l e -h t t p k a f k a m e d i a w i k i m y s q l p o s t g r e s q l p y t h o n t o m c a t v e r i l a t o r w o r d p r e s</head><label></label><figDesc>type v.s. temperature Distance v.s. temperature Branch bias v.s. temperature Avg reuse distance v.s. temperature</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Correlation between branch type, target distance, bias, holistic reuse distance and branch temperature: holistic reuse distance and branch temperature are strongly correlated, however, branch type, bias, or target distance do not have strong correlation with branch temperature.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>c a s s a n d r a c la n g d r u p a l fi n a g le -c h ir p e r fi n a g le -h t t p k a f k a m e d ia w ik i m y s q l p o s t g r e s q l p y t h o n t o m c a t v e r il a t o r w o r d p r e s s A v g</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: High level design of Thermometer</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>for</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>c a s s a n d r a c l a n g d r u p a l fi n a g l e -c h i r p e r fi n a g l e -h t t p k a f k a m e d i a w i k i m y s q l p o s t g r e s q l p y t h o n t o m c a t v e r i l a t o r w o r d p r e s s A v g n o v e r i l a t oFigure 11 :Figure 12 :</head><label>1112</label><figDesc>Figure11: Thermometer's IPC speedup compared to optimal and state-of-the-art replacement policies over an LRU baseline (with FDIP): Thermometer achieves an average speedup of 8.7% that is 83.6% of the average speedup provided by the optimal BTB replacement policy.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Avg 0 50 100 %Figure 13 :Figure 14 :Figure 15 :k a f k a m e d ia w ik i m y s q l p o s t g r e s q l p y t h o n t o m c a t v e r il a t o r w o r d p r e s s AFigure 16 :</head><label>10013141516</label><figDesc>Figure 13: Thermometer's IPC speedup across different application inputs as the percentage of the optimal BTB performance</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 17 :</head><label>17</label><figDesc>Figure 17: Thermometer's BTB miss reduction over the best performing prior work, GHRP [20] on CBP-5 traces [15]: Thermometer achieves an average BTB miss reduction of 2.25% over the GHRP baseline.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 18 :</head><label>18</label><figDesc>Figure 18: Thermometer's IPC speedup over an LRU baseline (with FDIP) for 50 IPC-1 traces<ref type="bibr" target="#b16">[17]</ref>: Thermometer outperforms all prior replacement techniques and provides speedups comparable to the optimal BTB replacement policy.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 19 :</head><label>19</label><figDesc>Figure 19: % of speedup Thermometer obtains compared to the optimal BTB replacement policy while varying the number of BTB entries (left) and the number of BTB ways (right).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 20 :</head><label>20</label><figDesc>Figure 20: % of speedup Thermometer obtains compared to the optimal BTB replacement policy while varying the number of branch temperature categories (left) and the FTQ size (right).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Figure 21 :</head><label>21</label><figDesc>Figure21: Thermometer's speedup over an LRU baseline with state-of-the-art BTB prefetching, Twig<ref type="bibr" target="#b74">[75]</ref>. Thermometer +Twig achieves an average speedup of 30.9% over the LRU+Twig baseline. Thus, Thermometer achieves 95.9% of the average speedup (32.2%) provided by the optimal replacement policy.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1</head><label>1</label><figDesc></figDesc><table><row><cell></cell><cell>: Simulation parameters</cell></row><row><cell>Parameter</cell><cell>Value</cell></row><row><cell>CPU</cell><cell>6-wide, 24-entry (192-instruction) FTQ, 60-</cell></row><row><cell></cell><cell>entry Decode Queue, 352-entry Re-order Buffer,</cell></row><row><cell></cell><cell>128-entry Reservation Station</cell></row><row><cell>Branch pre-</cell><cell>8192-entry 4-way BTB, 4096-entry IBTB, 32-</cell></row><row><cell>diction units</cell><cell>entry RAS, 64KB TAGE-SC-L [126]</cell></row><row><cell>Caches</cell><cell>64B block: 32KB, 8-way L1I, 48KB, 12-way L1D,</cell></row><row><cell></cell><cell>512KB 8-way L2C, 2MB 16-way LLC</cell></row><row><cell cols="2">transient access patterns is critical to achieve near-ideal frontend</cell></row><row><cell>performance.</cell><cell></cell></row><row><cell cols="2">‚Ä¢ Thermometer: A novel profile-guided BTB replacement mecha-</cell></row><row><cell cols="2">nism that identifies holistic branch patterns offline and consid-</cell></row><row><cell cols="2">ers both holistic and transient patterns online to make close-to-</cell></row><row><cell cols="2">optimal BTB replacement decisions.</cell></row></table><note>‚Ä¢ An extensive evaluation of Thermometer in the context of frontendbound data center applications, demonstrating Thermometer's potential to avoid costly BTB misses and achieve significant performance improvements.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>1 BTB replacement policy (implemented in hardware) to consider both holistic and transient reuse behavior. Input: Current branch to insert, ùë• 0 , branches already in the BTB, ùë• ùëñ , ùëñ = 1, 2, . . . , ùëõ, ùëõ is the number of BTB ways. Output: Victim, ùëß ùë¶ ùëñ ‚Üê temperature of ùë• ùëñ 3: ùë° ‚Üêmin(ùë¶ 0 , ùë¶ 1 , ùë¶ 2 , . . . ùë¶ ùëõ ) ‚ä≤ Find the coldest temperature 4: ùëÜ ‚Üê ùë• ùëó : ùë¶ ùëó = ùë° 5: if ùë• 0 ‚àà ùëÜ &amp;&amp; |ùëÜ | = 1 then</figDesc><table><row><cell>6:</cell></row></table><note>1: for ùëñ = 0, 1, 2, . . . , ùëõ do 2:</note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>We thank the anonymous reviewers for their insightful feedback and suggestions. This work was supported by the generous gifts from Intel Labs, NSF grants #1942754, #2010810, CCF-1912617, CNS-1938064, a Rackham Predoctoral Fellowship, and the Applications Driving Architectures (ADA) Research Center, a JUMP Center cosponsored by SRC and DARPA. We thank the University of Michigan Summer Undergraduate Research in Engineering (SURE) program as Shixin Song completed this work as her summer undergraduate research project. Any opinions, findings, conclusions, or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the funding agencies.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Adding processor trace support to linux</title>
		<ptr target="https://lwn.net/Articles/648154/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Apache cassandra</title>
		<ptr target="http://cassandra.apache.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Apache kafka</title>
		<ptr target="https://kafka.apache.org/powered-by" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Apache tomcat</title>
		<ptr target="https://tomcat.apache.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Champsim</title>
		<ptr target="https://github.com/ChampSim/ChampSim" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Clang c language family frontend for llvm</title>
		<ptr target="https://clang.llvm.org/" />
		<imprint>
			<date type="published" when="2021-11">Nov-2021</date>
			<biblScope unit="volume">19</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Github -chipsalliance/rocket-chip: Rocket chip generator</title>
		<ptr target="https://github.com/chipsalliance/rocket-chip" />
		<imprint>
			<date type="published" when="2021-11">Nov-2021</date>
			<biblScope unit="volume">19</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">An introduction to last branch records</title>
		<ptr target="https://lwn.net/Articles/680985/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Postgresql: Documentation: 14: pgbench</title>
		<ptr target="https://www.postgresql.org/docs/current/pgbench.html" />
		<imprint>
			<date type="published" when="2021-11">Nov-2021</date>
			<biblScope unit="volume">19</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Postgresql: The world&apos;s most advanced open source database</title>
		<ptr target="https://www.postgresql.org/" />
		<imprint>
			<date type="published" when="2021-11">Nov-2021</date>
			<biblScope unit="volume">19</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">The python performance benchmark suite</title>
		<ptr target="https://pyperformance.readthedocs.io/" />
		<imprint>
			<date type="published" when="2021-11">Nov-2021</date>
			<biblScope unit="volume">19</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Twitter finagle</title>
		<ptr target="https://twitter.github.io/finagle/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Verilator</title>
		<ptr target="https://www.veripool.org/wiki/verilator" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Welcome to python.org</title>
		<ptr target="https://www.python.org/" />
		<imprint>
			<date type="published" when="2021-11">Nov-2021</date>
			<biblScope unit="volume">19</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Championship branch prediction</title>
		<ptr target="https://jilp.org/cbp2016/" />
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">facebookarchive/oss-performance: Scripts for benchmarking various php implementations when running open source software</title>
		<ptr target="https://github.com/facebookarchive/oss-performance" />
		<imprint>
			<date type="published" when="2019-11">2019. November-2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">The 1st instruction prefetching championship</title>
		<ptr target="https://research.ece.ncsu.edu/ipc/" />
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Iatac: a smart predictor to turn-off l2 cache lines</title>
		<author>
			<persName><forename type="first">J</forename><surname>Abella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gonz√°lez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Vera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>O'boyle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Architecture and Code Optimization (TACO)</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="55" to="77" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The hiphop virtual machine</title>
		<author>
			<persName><forename type="first">K</forename><surname>Adams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Maher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ottoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Paroski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Simmers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Yamauchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages &amp; Applications</title>
				<meeting>the 2014 ACM International Conference on Object Oriented Programming Systems Languages &amp; Applications</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="777" to="790" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Exploring predictive replacement policies for instruction cache and branch target buffer</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Ajorpaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Garza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jindal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Jim√©nez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 ACM/IEEE 45th Annual International Symposium on Computer Architecture (ISCA)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="519" to="532" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Keeping master green at scale</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ananthanarayanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Ardekani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Haenikel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Varadarajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Soriano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Patel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A.-R</forename><surname>Adl-Tabatabai</surname></persName>
		</author>
		<idno type="DOI">10.1145/3302424.3303970</idno>
		<ptr target="https://doi.org/10.1145/3302424.3303970" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourteenth EuroSys Conference 2019, ser. EuroSys &apos;19</title>
				<meeting>the Fourteenth EuroSys Conference 2019, ser. EuroSys &apos;19<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Mana: Microarchitecting an instruction prefetcher</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ansari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Golshan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lotfi-Kamran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Sarbazi-Azad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The First Instruction Prefetching Championship</title>
				<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Divide and conquer frontend bottleneck</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ansari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lotfi-Kamran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Sarbazi-Azad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 47th Annual International Symposium on Computer Architecture (ISCA)</title>
				<meeting>the 47th Annual International Symposium on Computer Architecture (ISCA)</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Btb-x: A storage-effective btb organization</title>
		<author>
			<persName><forename type="first">T</forename><surname>Asheim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Grot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Architecture Letters</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="134" to="137" />
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Memory hierarchy for web search</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ayers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Ahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kozyrakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ranganathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 IEEE International Symposium on High Performance Computer Architecture (HPCA)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="643" to="656" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Classifying memory access patterns for prefetching</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ayers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Litz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kozyrakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ranganathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Fifth International Conference on Architectural Support for Programming Languages and Operating Systems</title>
				<meeting>the Twenty-Fifth International Conference on Architectural Support for Programming Languages and Operating Systems</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="513" to="526" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Asmdb: understanding and mitigating front-end stalls in warehouse-scale computers</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ayers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Nagendra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">I</forename><surname>August</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">K</forename><surname>Cho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kanev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kozyrakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Litz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Moseley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ranganathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 46th ISCA</title>
				<meeting>the 46th ISCA</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Talus: A simple way to remove cliffs in cache performance</title>
		<author>
			<persName><forename type="first">N</forename><surname>Beckmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sanchez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 IEEE 21st International Symposium on High Performance Computer Architecture (HPCA)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="64" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A study of replacement algorithms for a virtual-storage computer</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Belady</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM Systems journal</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="78" to="101" />
			<date type="published" when="1966">1966</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">On-line measurement of paging behavior by the multivalued min algorithm</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Belady</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">P</forename><surname>Palermo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM Journal of Research and Development</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="2" to="19" />
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Blackburn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Garner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hoffmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Khang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Mckinley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bentzur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Diwan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Feinberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Frampton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">Z</forename><surname>Guyer</surname></persName>
		</author>
		<title level="m">Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications</title>
				<meeting>the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="169" to="190" />
		</imprint>
	</monogr>
	<note>The dacapo benchmarks: Java benchmarking development and analysis</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Bulldozer: An approach to multithreaded compute performance</title>
		<author>
			<persName><forename type="first">M</forename><surname>Butler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Barnes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">D</forename><surname>Sarma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Gelinas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="6" to="15" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Autofdo: Automatic feedback-directed optimization for warehouse-scale applications</title>
		<author>
			<persName><forename type="first">D</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Moseley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">X</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CGO</title>
				<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Hot cold optimization of large windows/nt applications</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cohn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Lowney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th Annual IEEE/ACM International Symposium on Microarchitecture. MICRO 29</title>
				<meeting>the 29th Annual IEEE/ACM International Symposium on Microarchitecture. MICRO 29</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="80" to="89" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Tpc-c</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">P P</forename><surname>Council</surname></persName>
		</author>
		<ptr target="http://www.tpc.org/tpcc/" />
		<imprint>
			<date type="published" when="2021-11">Nov-2021</date>
			<biblScope unit="volume">19</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">{REPT}: Reverse debugging of failures in deployed software</title>
		<author>
			<persName><forename type="first">W</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Ge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kasikci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Niu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Yun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">13th {USENIX} Symposium on Operating Systems Design and Implementation ({OSDI} 18)</title>
				<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="17" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Predicting whole-program locality through reuse distance analysis</title>
		<author>
			<persName><forename type="first">C</forename><surname>Ding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN 2003 conference on Programming language design and implementation</title>
				<meeting>the ACM SIGPLAN 2003 conference on Programming language design and implementation</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="245" to="257" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Improving cache management policies using dynamic reuse distances</title>
		<author>
			<persName><forename type="first">N</forename><surname>Duong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cammarota</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Valero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Veidenbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2012 45th Annual IEEE/ACM International Symposium on Microarchitecture</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="389" to="400" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">Reverse debugging at scale</title>
		<author>
			<persName><forename type="first">W</forename><surname>Erquinigo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Carrillo-Cisneros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tang</surname></persName>
		</author>
		<ptr target="https://engineering.fb.com/2021/04/27/developer-tools/reverse-debugging/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Partial resolution in branch target buffers</title>
		<author>
			<persName><forename type="first">B</forename><surname>Fagin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1142" to="1145" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Leeway: Addressing variability in dead-block prediction for last-level caches</title>
		<author>
			<persName><forename type="first">P</forename><surname>Faldu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Grot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2017 26th International Conference on Parallel Architectures and Compilation Techniques (PACT)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="180" to="193" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Clearing the clouds: a study of emerging scale-out workloads on modern hardware</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ferdman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Adileh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Kocberber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Volos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Alisafaee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Jevdjic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kaynak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Popescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ailamaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Falsafi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acm sigplan notices</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="37" to="48" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Proactive instruction fetch</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ferdman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kaynak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Falsafi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Microarchitecture</title>
				<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Temporal instruction fetch streaming</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ferdman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Wenisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ailamaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Falsafi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moshovos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Microarchitecture</title>
				<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">A dueling segmented lru replacement algorithm with adaptive bypassing</title>
		<author>
			<persName><forename type="first">H</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wilkerson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">JWAC 2010-1st JILP Worshop on Computer Architecture Competitions: Cache Replacement Championship</title>
				<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">The temporal ancestry prefetcher</title>
		<author>
			<persName><forename type="first">N</forename><surname>Gober</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Chacon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Jim√©nez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">V</forename><surname>Gratz</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title level="m" type="main">Propeller: Profile guided optimizing large scale llvm-based relinker</title>
		<author>
			<persName><surname>Google</surname></persName>
		</author>
		<ptr target="https://github.com/google/llvm-propeller" />
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<title level="m" type="main">Barca: Branch agnostic region searching algorithm</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A J P V</forename><surname>Gratz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">C N</forename><surname>Gober</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Evolution of the samsung exynos cpu microarchitecture</title>
		<author>
			<persName><forename type="first">B</forename><surname>Grayson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rupley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">Z</forename><surname>Zuraski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Quinnell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Jim√©nez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Nakra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kitchin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hensley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Brekelbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Sinha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2020 ACM/IEEE 47th Annual International Symposium on Computer Architecture (ISCA)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="40" to="51" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Intel¬Æ 64 and ia-32 architectures software developer&apos;s manual</title>
		<author>
			<persName><forename type="first">P</forename><surname>Guide</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">System programming Guide, Part</title>
				<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<title level="m" type="main">Run-jump-run: Bouquet of instruction pointer jumpers for high performance instruction prefetching</title>
		<author>
			<persName><forename type="first">V</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">S</forename><surname>Kalani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Panda</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Steps towards cache-resident transaction processing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Harizopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ailamaki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International conference on Very large data bases</title>
				<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<title level="m" type="main">Active benchmarking for better performance predictions</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">Harshard</forename><surname>Sane</surname></persName>
		</author>
		<ptr target="https://www.intel.com/content/dam/www/central-libraries/us/en/documents/dpm-workloads-explainer-tech-brief.pdf" />
		<imprint/>
	</monogr>
	<note>Principle Software Engineer</note>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title level="m" type="main">Learning memory access patterns</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hashemi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Swersky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ayers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Litz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kozyrakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ranganathan</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1803.02329</idno>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Profile inference revisited</title>
		<author>
			<persName><forename type="first">W</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mestre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Pupyrev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
				<imprint>
			<date type="published" when="2022">2022</date>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="1" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Timekeeping in the memory system: predicting and optimizing memory behavior</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kaxiras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Martonosi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 29th Annual International Symposium on Computer Architecture</title>
				<meeting>29th Annual International Symposium on Computer Architecture</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="209" to="220" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Rebasing instruction prefetching: An industry perspective</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nathella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sunwoo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Architecture Letters</title>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Re-establishing fetch-directed instruction prefetching: An industry perspective</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nathella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sunwoo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Symposium on Performance Analysis of Systems and Software</title>
				<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Path-based next trace prediction</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Jacobson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Rotenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 30th Annual International Symposium on Microarchitecture</title>
				<meeting>30th Annual International Symposium on Microarchitecture</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="14" to="23" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Back to the future: leveraging belady&apos;s algorithm for improved cache replacement</title>
		<author>
			<persName><forename type="first">A</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2016 ACM/IEEE 43rd Annual International Symposium on Computer Architecture (ISCA</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="78" to="89" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Rethinking belady&apos;s algorithm to accommodate prefetching</title>
		<author>
			<persName><forename type="first">A</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 ACM/IEEE 45th Annual International Symposium on Computer Architecture (ISCA)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="110" to="123" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">High performance cache replacement using re-reference interval prediction (rrip)</title>
		<author>
			<persName><forename type="first">A</forename><surname>Jaleel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">B</forename><surname>Theobald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Steely</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Emer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="60" to="71" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Apt-get: Profile-guided timely software prefetching</title>
		<author>
			<persName><forename type="first">S</forename><surname>Jamilan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ayers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kasikci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Litz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Seventeenth European Conference on Computer Systems</title>
				<meeting>the Seventeenth European Conference on Computer Systems</meeting>
		<imprint>
			<date type="published" when="2022">2022</date>
			<biblScope unit="page" from="747" to="764" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Insertion and promotion for tree-based pseudolru last-level caches</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Jim√©nez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 46th Annual IEEE/ACM International Symposium on Microarchitecture</title>
				<meeting>the 46th Annual IEEE/ACM International Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="284" to="296" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">The impact of delay on the design of branch predictors</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Jim√©nez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Keckler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd annual ACM/IEEE international symposium on Microarchitecture</title>
				<meeting>the 33rd annual ACM/IEEE international symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="67" to="76" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Multiperspective reuse prediction</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Jim√©nez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Teran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2017 50th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="436" to="448" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Profiling a warehouse-scale computer</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kanev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Darago</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hazelwood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ranganathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Moseley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G.-Y</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Brooks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 42nd ISCA</title>
				<meeting>the 42nd ISCA</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Caching strategies to improve disk system performance</title>
		<author>
			<persName><forename type="first">R</forename><surname>Karedla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Love</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">G</forename><surname>Wherry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="38" to="46" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">Lazy diagnosis of in-production concurrency bugs</title>
		<author>
			<persName><forename type="first">B</forename><surname>Kasikci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Ge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Niu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th Symposium on Operating Systems Principles</title>
				<meeting>the 26th Symposium on Operating Systems Principles</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="582" to="598" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Failure sketches: A better way to debug</title>
		<author>
			<persName><forename type="first">B</forename><surname>Kasikci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pereira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Pokam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Schubert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Musuvathi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Candea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ser. Hot Topics in Operating Systems</title>
		<imprint>
			<biblScope unit="page">5</biblScope>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">Failure sketching: A technique for automated root cause diagnosis of in-production failures</title>
		<author>
			<persName><forename type="first">B</forename><surname>Kasikci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Schubert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pereira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Pokam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Candea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th Symposium on Operating Systems Principles</title>
				<meeting>the 25th Symposium on Operating Systems Principles</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="344" to="360" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Shift: Shared history instruction fetch for lean-core server processors</title>
		<author>
			<persName><forename type="first">C</forename><surname>Kaynak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Grot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Falsafi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Microarchitecture</title>
				<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Confluence: unified instruction supply for scale-out servers</title>
		<author>
			<persName><forename type="first">C</forename><surname>Kaynak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Grot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Falsafi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 48th International Symposium on Microarchitecture</title>
				<meeting>the 48th International Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="166" to="177" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">Sampling dead block prediction for last-level caches</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Jimenez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2010 43rd Annual IEEE/ACM International Symposium on Microarchitecture</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="175" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">Twig: Profile-guided btb prefetching for data center applications</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sriraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">K</forename><surname>Soundararajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Devietti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Subramoney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">A</forename><surname>Pokam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Litz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kasikci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MICRO-54: 54th Annual IEEE/ACM International Symposium on Microarchitecture</title>
				<imprint>
			<date type="published" when="2021">2021</date>
			<biblScope unit="page" from="816" to="829" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">Dmon: Efficient detection and correction of data locality problems using selective profiling</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Neal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Pokam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mozafari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kasikci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">15th {USENIX} Symposium on Operating Systems Design and Implementation</title>
				<imprint>
			<date type="published" when="2021">2021</date>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="163" to="181" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">I-spy: Context-driven conditional instruction prefetching with coalescing</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sriraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Devietti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Pokam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Litz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kasikci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2020 53rd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="146" to="159" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<analytic>
		<title level="a" type="main">Ripple: Profile-guided instruction cache replacement for data center applications</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sriraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Devietti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Pokam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Litz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kasikci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the 48th International Symposium on Computer Architecture (ISCA), ser. ISCA 2021</title>
				<imprint>
			<date type="published" when="2021-06">Jun. 2021</date>
		</imprint>
	</monogr>
	<note>in Proceedings (to appear) of</note>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">Huron: hybrid false sharing detection and repair</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Pokam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mozafari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kasikci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
				<meeting>the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="453" to="468" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">Counter-based cache replacement algorithms</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kharbutli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Solihin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2005 International Conference on Computer Design</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="61" to="68" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">A cost-effective branch target buffer with a two-level table organization</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kobayashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yamada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ando</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Shimada</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd International Symposium of Low-Power and High-Speed Chips (COOL Chips II)</title>
				<meeting>the 2nd International Symposium of Low-Power and High-Speed Chips (COOL Chips II)</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<analytic>
		<title level="a" type="main">Rdip: return-address-stack directed instruction prefetching</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kolli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Saidi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Wenisch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2013 46th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="260" to="271" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b82">
	<analytic>
		<title level="a" type="main">Blasting through the front-end bottleneck with shotgun</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Grot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Nagarajan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="30" to="42" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<analytic>
		<title level="a" type="main">Boomerang: A metadata-free architecture for control flow delivery</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-C</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Grot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Nagarajan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2017 IEEE International Symposium on High Performance Computer Architecture (HPCA)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="493" to="504" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<analytic>
		<title level="a" type="main">Llvm: A compilation framework for lifelong program analysis &amp; transformation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Lattner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Adve</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Code Generation and Optimization</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2004">2004. 2004. 2004</date>
			<biblScope unit="page" from="75" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<analytic>
		<title level="a" type="main">Codestitcher: inter-procedural basic block layout optimization</title>
		<author>
			<persName><forename type="first">R</forename><surname>Lavaee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Criswell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ding</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th International Conference on Compiler Construction</title>
				<meeting>the 28th International Conference on Compiler Construction</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="65" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b86">
	<analytic>
		<title level="a" type="main">Branch prediction strategies and branch target buffer design</title>
		<author>
			<persName><forename type="first">Smith</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="6" to="22" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b87">
	<analytic>
		<title level="a" type="main">On the existence of a spectrum of policies that subsumes the least recently used (lru) and least frequently used (lfu) policies</title>
		<author>
			<persName><forename type="first">D</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-H</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">H</forename><surname>Noh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">L</forename><surname>Min</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Cho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1999 ACM SIGMETRICS international conference on Measurement and modeling of computer systems</title>
				<meeting>the 1999 ACM SIGMETRICS international conference on Measurement and modeling of computer systems</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="134" to="143" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b88">
	<analytic>
		<title level="a" type="main">Lightweight feedback-directed cross-module optimization</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ashok</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hundt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th annual IEEE/ACM international symposium on Code generation and optimization</title>
				<meeting>the 8th annual IEEE/ACM international symposium on Code generation and optimization</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="53" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b89">
	<analytic>
		<title level="a" type="main">Optimal bypass monitor for high performance last-level caches</title>
		<author>
			<persName><forename type="first">L</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Cheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st international conference on Parallel architectures and compilation techniques</title>
				<meeting>the 21st international conference on Parallel architectures and compilation techniques</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="315" to="324" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b90">
	<analytic>
		<title level="a" type="main">CRISP: critical slice prefetching</title>
		<author>
			<persName><forename type="first">H</forename><surname>Litz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ayers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ranganathan</surname></persName>
		</author>
		<idno type="DOI">10.1145/3503222.3507745</idno>
		<ptr target="https://doi.org/10.1145/3503222.3507745" />
	</analytic>
	<monogr>
		<title level="m">ASPLOS &apos;22: 27th ACM International Conference on Architectural Support for Programming Languages and Operating Systems</title>
				<editor>
			<persName><forename type="first">B</forename><surname>Falsafi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Ferdman</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Lu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Wenisch</surname></persName>
		</editor>
		<meeting><address><addrLine>Lausanne, Switzerland</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2022-02-28">28 February 2022 -4 March 2022. 2022</date>
			<biblScope unit="page" from="300" to="313" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b91">
	<monogr>
		<title level="m" type="main">An imitation learning approach for cache replacement</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hashemi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Swersky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ranganathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ahn</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2006.16239</idno>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b92">
	<analytic>
		<title level="a" type="main">Cache bursts: A new approach for eliminating dead blocks and increasing cache efficiency</title>
		<author>
			<persName><forename type="first">H</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ferdman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Huh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Burger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2008 41st IEEE/ACM International Symposium on Microarchitecture</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="222" to="233" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b93">
	<analytic>
		<title level="a" type="main">Ispike: a post-link optimizer for the intel/spl reg/itanium/spl reg/architecture</title>
		<author>
			<persName><forename type="first">C.-K</forename><surname>Luk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Muth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Patil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cohn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lowney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Code Generation and Optimization</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2004">2004. 2004. 2004</date>
			<biblScope unit="page" from="15" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b94">
	<analytic>
		<title level="a" type="main">Cooperative prefetching: Compiler and hardware support for effective instruction prefetching in modern processors</title>
		<author>
			<persName><forename type="first">C.-K</forename><surname>Luk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">C</forename><surname>Mowry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Microarchitecture</title>
				<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b95">
	<analytic>
		<title level="a" type="main">Evaluation techniques for storage hierarchies</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Mattson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gecsei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Slutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">L</forename><surname>Traiger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM Systems journal</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="78" to="117" />
			<date type="published" when="1970">1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b96">
	<analytic>
		<title level="a" type="main">Dead page and dead block predictors: Cleaning tlbs and caches together</title>
		<author>
			<persName><forename type="first">C</forename><surname>Mazumdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mitra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Basu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2021 IEEE International Symposium on High-Performance Computer Architecture (HPCA)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2021">2021</date>
			<biblScope unit="page" from="507" to="519" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b97">
	<analytic>
		<title level="a" type="main">Some mathematical facts about optimal cache replacement</title>
		<author>
			<persName><forename type="first">P</forename><surname>Michaud</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Architecture and Code Optimization (TACO)</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1" to="19" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b98">
	<analytic>
		<title level="a" type="main">Pips: Prefetching instructions with probabilistic scouts</title>
		<author>
			<persName><forename type="first">P</forename><surname>Michaud</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The 1st Instruction Prefetching Championship</title>
				<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b99">
	<analytic>
		<title level="a" type="main">Vespa: static profiling for binary optimization</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Moreira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ottoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">M</forename><surname>Pereira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA</title>
				<imprint>
			<date type="published" when="2021">2021</date>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="1" to="28" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b100">
	<monogr>
		<title level="m" type="main">D-jolt: Distant jolt prefetcher</title>
		<author>
			<persName><forename type="first">T</forename><surname>Nakamura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Koizumi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Degawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Irie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sakai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Shioya</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b101">
	<analytic>
		<title level="a" type="main">The lru-k page replacement algorithm for database disk buffering</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">J</forename><surname>O'neil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">E</forename><surname>O'neil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Weikum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acm Sigmod Record</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="297" to="306" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b102">
	<analytic>
		<title level="a" type="main">Hhvm jit: A profile-guided, region-based compiler for php and hack</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ottoni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 39th ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
				<meeting>the 39th ACM SIGPLAN Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="151" to="165" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b103">
	<analytic>
		<title level="a" type="main">Hhvm jump-start: Boosting both warmup and steadystate performance at scale</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ottoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2021 IEEE/ACM International Symposium on Code Generation and Optimization (CGO</title>
				<imprint>
			<publisher>IEEE</publisher>
			<biblScope unit="page" from="340" to="350" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b104">
	<analytic>
		<title level="a" type="main">Optimizing function placement for large-scale datacenter applications</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ottoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Maher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2017 IEEE/ACM International Symposium on Code Generation and Optimization (CGO)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="233" to="244" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b105">
	<analytic>
		<title level="a" type="main">Bolt: a practical binary optimizer for data centers and beyond</title>
		<author>
			<persName><forename type="first">M</forename><surname>Panchenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Auler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Nell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ottoni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2019 IEEE/ACM International Symposium on Code Generation and Optimization (CGO)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="2" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b106">
	<analytic>
		<title level="a" type="main">Lightning bolt: powerful, fast, and scalable binary optimization</title>
		<author>
			<persName><forename type="first">M</forename><surname>Panchenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Auler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Sakka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ottoni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th ACM SIGPLAN International Conference on Compiler Construction</title>
				<meeting>the 30th ACM SIGPLAN International Conference on Compiler Construction</meeting>
		<imprint>
			<date type="published" when="2021">2021</date>
			<biblScope unit="page" from="119" to="130" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b107">
	<analytic>
		<title level="a" type="main">B-fetch: Branch prediction directed prefetching for in-order processors</title>
		<author>
			<persName><forename type="first">R</forename><surname>Panda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">V</forename><surname>Gratz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Jim√©nez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Architecture Letters</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="41" to="44" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b108">
	<analytic>
		<title level="a" type="main">The arm neoverse n1 platform: Building blocks for the next-gen cloud-to-edge infrastructure soc</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pellegrini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Stephens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bruce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pusdesris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Raja</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Abernathy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Koppanalil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ringe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tummala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="53" to="62" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b109">
	<analytic>
		<title level="a" type="main">Branch target buffer design and optimization</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Perleberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE transactions on computers</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="396" to="412" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b110">
	<analytic>
		<title level="a" type="main">Architectural and compiler support for effective instruction prefetching: a cooperative approach</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">L</forename><surname>Peterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b111">
	<analytic>
		<title level="a" type="main">The hardness of cache conscious data placement</title>
		<author>
			<persName><forename type="first">E</forename><surname>Petrank</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Rawitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
				<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b112">
	<analytic>
		<title level="a" type="main">Profile guided code positioning</title>
		<author>
			<persName><forename type="first">K</forename><surname>Pettis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN 1990 conference on Programming language design and implementation</title>
				<meeting>the ACM SIGPLAN 1990 conference on Programming language design and implementation</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="16" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b113">
	<monogr>
		<title level="m" type="main">Renaissance: Benchmarking suite for parallel applications on the jvm</title>
		<author>
			<persName><forename type="first">A</forename><surname>Prokopec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ros√†</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Leopoldseder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Duboscq</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>T≈Øma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Studener</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bulej</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Villaz√≥n</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Simon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>W√ºrthinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Binder</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
	<note>in Programming Language Design and Implementation</note>
</biblStruct>

<biblStruct xml:id="b114">
	<analytic>
		<title level="a" type="main">Adaptive insertion policies for high performance caching</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Qureshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jaleel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">N</forename><surname>Patt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Steely</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Emer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="381" to="391" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b115">
	<analytic>
		<title level="a" type="main">A case for mlp-aware cache replacement</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Qureshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">N</forename><surname>Lynch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Mutlu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">N</forename><surname>Patt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">33rd International Symposium on Computer Architecture (ISCA&apos;06)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="167" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b116">
	<analytic>
		<title level="a" type="main">Code layout optimizations for transaction processing workloads</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ramirez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Barroso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Gharachorloo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cohn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Larriba-Pey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Lowney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Valero</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b117">
	<analytic>
		<title level="a" type="main">A scalable front-end architecture for fast instruction delivery</title>
		<author>
			<persName><forename type="first">G</forename><surname>Reinman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Austin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="234" to="245" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b118">
	<analytic>
		<title level="a" type="main">Fetch directed instruction prefetching</title>
		<author>
			<persName><forename type="first">G</forename><surname>Reinman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Austin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MICRO-32. Proceedings of the 32nd Annual ACM/IEEE International Symposium on Microarchitecture. IEEE</title>
				<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="16" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b119">
	<analytic>
		<title level="a" type="main">The entangling instruction prefetcher</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jimborean</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Architecture Letters</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="84" to="87" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b120">
	<analytic>
		<title level="a" type="main">A cost-effective entangling prefetcher for instructions</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jimborean</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2021 ACM/IEEE 48th Annual International Symposium on Computer Architecture (ISCA)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2021">2021</date>
			<biblScope unit="page" from="99" to="111" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b121">
	<analytic>
		<title level="a" type="main">Trace cache: a low latency approach to high bandwidth instruction fetching</title>
		<author>
			<persName><forename type="first">E</forename><surname>Rotenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bennett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th Annual IEEE/ACM International Symposium on Microarchitecture</title>
				<meeting>the 29th Annual IEEE/ACM International Symposium on Microarchitecture</meeting>
		<imprint>
			<publisher>MICRO 29. IEEE</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="24" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b122">
	<analytic>
		<title level="a" type="main">Samsung exynos m3 processor</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rupley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Hot Chips</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b123">
	<monogr>
		<title level="m" type="main">ARM architecture reference manual</title>
		<author>
			<persName><forename type="first">D</forename><surname>Seal</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>Pearson Education</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b124">
	<analytic>
		<title level="a" type="main">The evicted-address filter: A unified mechanism to address both cache pollution and thrashing</title>
		<author>
			<persName><forename type="first">V</forename><surname>Seshadri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Mutlu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Kozuch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">C</forename><surname>Mowry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2012 21st International Conference on Parallel Architectures and Compilation Techniques (PACT)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="355" to="366" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b125">
	<analytic>
		<title level="a" type="main">Tage-sc-l branch predictors</title>
		<author>
			<persName><forename type="first">A</forename><surname>Seznec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">JILP-Championship Branch Prediction</title>
				<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b126">
	<analytic>
		<title level="a" type="main">The fnl+ mma instruction cache prefetcher</title>
		<author>
			<persName><forename type="first">A</forename><surname>Seznec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IPC-1-First Instruction Prefetching Championship</title>
				<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b127">
	<analytic>
		<title level="a" type="main">Don&apos;t use the page number, but a pointer to it</title>
		<author>
			<persName><forename type="first">S</forename><surname>Seznec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">23rd Annual International Symposium on Computer Architecture (ISCA&apos;96)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="104" to="104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b128">
	<analytic>
		<title level="a" type="main">Applying deep learning to the cache replacement problem</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 52nd Annual IEEE/ACM International Symposium on Microarchitecture</title>
				<meeting>the 52nd Annual IEEE/ACM International Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="413" to="425" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b129">
	<analytic>
		<title level="a" type="main">Eelru: simple and effective adaptive page replacement</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Smaragdakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kaplan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wilson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGMETRICS Performance Evaluation Review</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="122" to="133" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b130">
	<analytic>
		<title level="a" type="main">Sequential program prefetching in memory hierarchies</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="7" to="21" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b131">
	<analytic>
		<title level="a" type="main">Pdede: Partitioned, deduplicated, delta branch target buffer</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">K</forename><surname>Soundararajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Braun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kasikci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Litz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Subramoney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MICRO-54: 54th Annual IEEE/ACM International Symposium on Microarchitecture</title>
				<imprint>
			<date type="published" when="2021">2021</date>
			<biblScope unit="page" from="779" to="791" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b132">
	<analytic>
		<title level="a" type="main">Softsku: Optimizing server architectures for microservice diversity@ scale</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sriraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Dhanotia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Wenisch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 46th International Symposium on Computer Architecture</title>
				<meeting>the 46th International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="513" to="526" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b133">
	<analytic>
		<title level="a" type="main">Adaptive caches: Effective shaping of cache behavior to workloads</title>
		<author>
			<persName><forename type="first">R</forename><surname>Subramanian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Smaragdakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">H</forename><surname>Loh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2006 39th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO&apos;06)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="385" to="396" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b134">
	<analytic>
		<title level="a" type="main">The amd &quot;zen 2&quot; processor</title>
		<author>
			<persName><forename type="first">D</forename><surname>Suggs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Subramony</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Bouvier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="45" to="52" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b135">
	<analytic>
		<title level="a" type="main">Inter-reference gap distribution replacement: an improved replacement algorithm for set-associative caches</title>
		<author>
			<persName><forename type="first">M</forename><surname>Takagi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hiraki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th annual international conference on Supercomputing</title>
				<meeting>the 18th annual international conference on Supercomputing</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="20" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b136">
	<analytic>
		<title level="a" type="main">Perceptron learning for reuse prediction</title>
		<author>
			<persName><forename type="first">E</forename><surname>Teran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Jim√©nez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2016 49th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b137">
	<analytic>
		<title level="a" type="main">Morrigan: A composite instruction tlb prefetcher</title>
		<author>
			<persName><forename type="first">G</forename><surname>Vavouliotis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Alvarez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Grot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Jim√©nez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Casas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MICRO-54: 54th Annual IEEE/ACM International Symposium on Microarchitecture</title>
				<imprint>
			<date type="published" when="2021">2021</date>
			<biblScope unit="page" from="1138" to="1153" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b138">
	<analytic>
		<title level="a" type="main">Temporal streams in commercial server applications</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Wenisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ferdman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ailamaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Falsafi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moshovos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2008 IEEE International Symposium on Workload Characterization</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="99" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b139">
	<analytic>
		<title level="a" type="main">Practical off-chip meta-data for temporal memory streaming</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Wenisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ferdman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ailamaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Falsafi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moshovos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2009 IEEE 15th International Symposium on High Performance Computer Architecture</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="79" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b140">
	<analytic>
		<title level="a" type="main">Temporal streaming of shared memory</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Wenisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Somogyi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Hardavellas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ailamaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Falsafi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">32nd International Symposium on Computer Architecture (ISCA&apos;05)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="222" to="233" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b141">
	<monogr>
		<ptr target="https://en.wikipedia.org/w/index.php?title=Drupal&amp;oldid=989582664" />
		<title level="m">Drupal -Wikipedia, the free encyclopedia</title>
				<imprint>
			<date type="published" when="2020-11">2020. November-2020</date>
			<biblScope unit="volume">23</biblScope>
		</imprint>
	</monogr>
	<note>Wikipedia contributors</note>
</biblStruct>

<biblStruct xml:id="b142">
	<monogr>
		<ptr target="https://en.wikipedia.org/w/index.php?title=MediaWiki&amp;oldid=989993176" />
		<title level="m">Mediawiki -Wikipedia, the free encyclopedia</title>
				<imprint>
			<date type="published" when="2020-11">2020. November-2020</date>
			<biblScope unit="volume">23</biblScope>
		</imprint>
	</monogr>
	<note>Wikipedia contributors</note>
</biblStruct>

<biblStruct xml:id="b143">
	<monogr>
		<ptr target="https://en.wikipedia.org/w/index.php?title=WordPress&amp;oldid=977243718" />
		<title level="m">Wordpress -Wikipedia, the free encyclopedia</title>
				<imprint>
			<date type="published" when="2020-11">2020. November-2020</date>
			<biblScope unit="volume">23</biblScope>
		</imprint>
	</monogr>
	<note>Wikipedia contributors</note>
</biblStruct>

<biblStruct xml:id="b144">
	<analytic>
		<title level="a" type="main">Cross-validation (statistics) -Wikipedia, the free encyclopedia</title>
		<ptr target="https://en.wikipedia.org/w/index.php?title=Cross-validation_(statistics)&amp;oldid=1055904460" />
	</analytic>
	<monogr>
		<title level="m">Wikipedia contributors</title>
				<imprint>
			<date type="published" when="2021-11">2021. November-2021</date>
			<biblScope unit="volume">24</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b145">
	<monogr>
		<ptr target="https://en.wikipedia.org/w/index.php?title=MySQL&amp;oldid=1054628857" />
		<title level="m">Mysql -Wikipedia, the free encyclopedia</title>
				<imprint>
			<date type="published" when="2021-11">2021. November-2021</date>
			<biblScope unit="volume">19</biblScope>
		</imprint>
	</monogr>
	<note>Wikipedia contributors</note>
</biblStruct>

<biblStruct xml:id="b146">
	<analytic>
		<title level="a" type="main">Ship: Signature-based hit predictor for high performance caching</title>
		<author>
			<persName><forename type="first">C.-J</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jaleel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Hasenplaugh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Martonosi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Steely</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Emer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 44th Annual IEEE/ACM International Symposium on Microarchitecture</title>
				<meeting>the 44th Annual IEEE/ACM International Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="430" to="441" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b147">
	<analytic>
		<title level="a" type="main">A comprehensive instruction fetch mechanism for a processor supporting speculative execution</title>
		<author>
			<persName><forename type="first">T.-Y</forename><surname>Yeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">N</forename><surname>Patt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGMICRO Newsletter</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="129" to="139" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b148">
	<analytic>
		<title level="a" type="main">Buffering databse operations for enhanced instruction cache performance</title>
		<author>
			<persName><forename type="first">J</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">A</forename><surname>Ross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International conference on Management of data</title>
				<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b149">
	<analytic>
		<title level="a" type="main">On the impact of instruction address translation overhead</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dwarkadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2019 IEEE International Symposium on Performance Analysis of Systems and Software (ISPASS)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="106" to="116" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b150">
	<analytic>
		<title level="a" type="main">Execution reconstruction: Harnessing failure reoccurrences for failure reproduction</title>
		<author>
			<persName><forename type="first">G</forename><surname>Zuo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Quinn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bhatotia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Fonseca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kasikci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation</title>
				<meeting>the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2021">2021</date>
			<biblScope unit="page" from="1155" to="1170" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
