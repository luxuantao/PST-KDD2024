<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Large Scale Cohesive Subgraphs Discovery for Social Network Visual Analysis</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Feng</forename><surname>Zhao</surname></persName>
							<email>zhaofeng@comp.nus.edu.sg</email>
						</author>
						<author>
							<persName><forename type="first">Anthony</forename><forename type="middle">K H</forename><surname>Tung</surname></persName>
							<email>atung@comp.nus.edu.sg</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">School of Computing</orgName>
								<orgName type="institution">National University of Singapore</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">School of Computing</orgName>
								<orgName type="institution">National University of Singapore</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">The 39th International Conference on Very Large Data Bases</orgName>
								<address>
									<addrLine>Riva del Garda</addrLine>
									<postCode>26th -30th 2013</postCode>
									<settlement>August, Trento</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Large Scale Cohesive Subgraphs Discovery for Social Network Visual Analysis</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">2E7F782C129D30A4E6DB52E8A20EFD38</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T05:01+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Graphs are widely used in large scale social network analysis nowadays. Not only analysts need to focus on cohesive subgraphs to study patterns among social actors, but also normal users are interested in discovering what happening in their neighborhood. However, effectively storing large scale social network and efficiently identifying cohesive subgraphs is challenging. In this work we introduce a novel subgraph concept to capture the cohesion in social interactions, and propose an I/O efficient approach to discover cohesive subgraphs.</p><p>Besides, we propose an analytic system which allows users to perform intuitive, visual browsing on large scale social networks. Our system stores the network as a social graph in the graph database, retrieves a local cohesive subgraph based on the input keywords, and then hierarchically visualizes the subgraph out on orbital layout, in which more important social actors are located in the center. By summarizing textual interactions between social actors as tag cloud, we provide a way to quickly locate active social communities and their interactions in a unified view.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Graphs play a seminal role in social network analysis nowadays. A large and rapidly growing social network companies store social data as graph structures, such as Facebook<ref type="foot" target="#foot_0">1</ref> and Twitter <ref type="foot" target="#foot_1">2</ref> . In a social graph, vertices represent social actors, while edges represent relationships or interactions between actors. One fundamental operation on social graph is to identify groups of social actors that are highly connected with each other, represented by a cohesive subgraph, in which analysts may discover interesting structural patterns among social actors, and normal users can know what happening in their neighborhood.</p><p>Cohesive subgraph discovery is an intriguing problem and has been widely studied for decades. One fundamental structure is the clique in which every pair of vertices is connected. Finding cliques is NP-Hard <ref type="bibr">[9]</ref> and many work try to relax the clique problem to improve efficiency <ref type="bibr" target="#b15">[15,</ref><ref type="bibr" target="#b1">1,</ref><ref type="bibr" target="#b19">19,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b24">24,</ref><ref type="bibr" target="#b22">22]</ref>. However, these methods do not directly take the characteristics of social network into consideration. For example, in Figure <ref type="figure" target="#fig_1">1a</ref>, we emphasize the 3-core in solid edges and connected vertices, in which every vertex v inside it satisfies d(v) ≥ 3. However, g is not cohesive enough as a whole. Considering cliques inside g, we can find a 5-clique (a, b, c, d, f ) and a 4-clique (c, d, e, f ) on the left, as well as two 4-cliques {(m, n, p, q), (p, q, t, u)} on the right. But vertex a and p are not tightly coupled since they only share one common neighbor j, so the subgraph g is better viewed as two separated cohesive groups.</p><p>This phenomenon, denoted as the tie strength concept, is well studied in the sociological area. Note that tie is same as edge in social graph. Mark Granovetter in his landmark paper <ref type="bibr" target="#b14">[14]</ref> indicates that two actors A and B are likely to have many friends in common if they have a strong tie. In another state-of-the-art sociological paper, White et al. <ref type="bibr" target="#b25">[25]</ref> observe that a group is cohesive to the extent that pairs of its members have multiple social connections, direct or indirect, but within the group, that pull it together. One intuitive real life example is that you and your intimate friends in Facebook may have high possibility to share lots of mutual friends. However, this observation has been missing from many of the cohesive subgraph definitions, which drives us to define a "mutual-friend" structure to capture the tie strength in a quantitative manner for social network analysis. Assume we consider a tie in Figure <ref type="figure" target="#fig_1">1</ref> valid if and only if it is supported by at least two mutual friends. With only supported by one mutual friend j, the tie (a, p) should be disconnected according to the mutual-friend concept, and we successfully separate subgraph g to two groups. We will formally define the problem and compare it to other definitions in details in the subsequent sections.</p><p>How to improve the scalability is one potential challenge of cohesive subgraph discovery for social network analysis. Most of the existing approaches <ref type="bibr" target="#b23">[23,</ref><ref type="bibr" target="#b24">24,</ref><ref type="bibr" target="#b26">26]</ref> mainly focus on the dense region recognition for moderate size graphs. However, many practical social network applications need to store the large scale graph in disks or databases. Like Facebook, over 800 million active actors use its service per month all over the world <ref type="bibr" target="#b3">[3]</ref>, which is impossible to fit in memory. Therefore, besides providing memory based solutions, we focus on developing a solution to handling large scale social  graphs stored in a graph database, which is more scalable for graph operations than a relational database. Like Twitter, recently it migrated its social graph to FlockDB [10], a distributed, fault-tolerant graph database for managing data at webscale. By leveraging graph databases, we extend memory based algorithms to I/O efficient solutions for large scale social networks.</p><p>Additionally, exploring and analyzing social network can be time consuming and not user-friendly. Visual representation of social networks is important for understanding the network data and conveying the result of the analysis. However, it is a challenge to summarize the structural patterns as well as the content information to help users analyze the social network. One previous work <ref type="bibr" target="#b23">[23]</ref> proposes a novel linear plot for graph structure, which sketches out the distribution of dense regions and is suitable for static dense pattern discovery. Unlike this work, our system insulates users from the complexities of social analysis by visualizing cohesive subgraphs and the contents in an interactive fashion. For graph structure, we propose an orbital layout to decompose the graph into hierarchy with respect to the cohesive value, in which more important social actors are located in the center. Figure <ref type="figure" target="#fig_1">1b</ref> shows an orbital layout for the graph in Figure <ref type="figure" target="#fig_1">1a</ref>. Briefly speaking, this layout consists of four orbits with four different colors, in which the more cohesive vertices are located closer to the center. Like the 5-clique (a, b, c, d, f ), all five vertices are in the innermost orbit. As for vertices size setting, ordering and edge filtering, we will explain them in details later in this paper. For the contents, we make use of tag cloud technique to summarize the major semantics for a group of social actors. Generally speaking, our visualization is flexible and can be easily applied to other cohesive graph concepts.</p><p>In this paper, we develop a novel social network visual analytic framework for large scale cohesive subgraphs discovery. Our contributions are summarized as follows:</p><p>• We have introduced a novel cohesive subgraph concept to capture the intrinsic feature of social network analysis nicely.</p><p>• By leveraging graph databases, we have devised an offline algorithm to compute global cohesive subgraphs efficiently. Moreover, we have developed an online algorithm to further refine local cohesive subgraphs based on the results of offline computations.</p><p>• We have developed an orbital layout to decompose the cohesive subgraph into a set of orbits, and coupled with tag cloud summarization, which allows users to locate important actors and their interactions inside subgraphs clearly.</p><p>• We have conducted extensive experiments, and the results show that our approach is both effective and efficient.</p><p>The rest of the paper is organized as follows. Section 2 reviews the related literature on cohesive subgraph finding and social network analysis. Section 3 defines the cohesive subgraph discovery problem handled throughout this paper. Section 4 presents the offline computations in the graph database, and the online visual analytic system is described in Section 5. Our extensive experimental study is reported in Section 6. Section 7 concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RELATED WORK</head><p>Modeling a cohesive subgraph mathematically has been extensively studied for decades. One of the earliest graph models was the clique model <ref type="bibr" target="#b16">[16]</ref>, in which there exists an edge between any two vertices. However, the clique model idealizes cohesive properties so that it seldom exists and hard to compute. Alternative approaches are suggested that essentially relaxes the clique definition in different aspects. Luce <ref type="bibr" target="#b15">[15]</ref> introduces a distance based model called k-clique and Alba <ref type="bibr" target="#b1">[1]</ref> introduces a diameter based model called kclub. Generally speaking, these models relax the reachability among vertices from 1 to k. Another line of work focuses on a degree based model, like k-plex <ref type="bibr" target="#b19">[19]</ref> and kcore <ref type="bibr" target="#b18">[18]</ref>. The k-plex is still NP-Complete since it restricts the subgraph size, while k-core further relaxes it to achieve the linear time complexity with respect to the number of edges. A new direction based on the edge triangle model, like DN-Graph <ref type="bibr" target="#b24">[24]</ref> and truss decomposition <ref type="bibr" target="#b22">[22]</ref>, is more suitable for social network analysis since it captures the tie strength between actors inside the subgroup. Our proposed mutual friend concept belongs to this model and we will compare it with the above two concepts in Section 3 in details. Recently, database researchers try to scale up the disk based cohesive subgraph discovery. Cheng et al. <ref type="bibr" target="#b6">[6]</ref> propose a partition based solution for massive k-core mining. They also develop a disk based triangulation method <ref type="bibr" target="#b7">[7]</ref> as a fundamental operation for cohesive subgraph discovery. Differently, we store the social graph in graph database that is more scalable for graph traversal based algorithms.</p><p>Besides, social network characteristics has been well investigated in sociology communities. The most related one is the tie strength theory, which is introduced by Mark Granovetter in his landmark paper <ref type="bibr" target="#b14">[14]</ref>. Recently, many social network researchers investigate this important theory in online social network, such as the user behaviors in Facebook <ref type="bibr" target="#b12">[12,</ref><ref type="bibr" target="#b3">3]</ref> and Twitter <ref type="bibr" target="#b13">[13]</ref>. Their conclusions show that the strength of tie is still a tenable theory in social media, which are the bases of the mutual-friend subgraph definition in this paper.</p><p>Social network visualization and analysis has received a great deal of attention recently. Wang et al. <ref type="bibr" target="#b23">[23]</ref> proposes a linear plot based on graph traversal to capture the dense subgraph distribution in the whole graph. Zhang et al. <ref type="bibr" target="#b26">[26]</ref> extends it to compare the pattern changing between two graph snapshots. Place vertices in concentric circles with different levels is a popular way to visualize graph structures, such as k shell decomposition <ref type="bibr" target="#b2">[2]</ref>, centralities visualization <ref type="bibr" target="#b8">[8]</ref> and so on. We leverage the circular idea and devise the orbital layout to visualize k-mutual-friend subgraphs in an interactive manner. Note that the orbital layout is perpendicular to linear plot. We could seamlessly integrate the linear plot for global subgraph distribution and the orbital layout for local subgraph representation. Besides, Arnetminer <ref type="bibr" target="#b21">[21]</ref> provides comprehensive search and mining services for academic social networks. It is a full fledged framework with nice visual exploring function like the relationship graph between two researchers. However, the focus of this visualization is to show the connections between two researchers instead of the importance of individuals in the cohesive subgraphs as in our solution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">PROBLEM DEFINITION</head><p>In this section, we first introduce the preliminary knowledge, then define the maximal k-mutual-friend finding problem, and show several important properties about this concept. Furthermore, we compare it with clique, k-core, DN -Graph as well as truss decomposition in depth.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Preliminaries</head><p>As stated in Section 1, we model a social network as an undirected, simple social graph G(V, E) in which vertices represent social actors and edges represent interactions between actors. The k-mutual-friend subgraph proposed in this paper is derived from clique and k -core <ref type="bibr" target="#b18">[18]</ref>. Clique is a fully connected subgraph, in which every pair of vertices is connected by an edge. If the size of a clique is c, we call the clique a c-clique. k -core is one successful degree relaxation of clique concept defined as follows.</p><p>Definition 3.1. (k-core Subgraph) A k-core is a connected subgraph g such that each vertex v has degree d(v) ≥ k within the subgraph g.</p><p>The k-core is motivated by the property that every vertex has degree d(v) = c -1 in a c-clique. k-core also needs to satisfy the degree condition, but the restriction on subgraph size is not required. As such, k-core can be efficiently computed in O(|E|) time complexity <ref type="bibr" target="#b18">[18]</ref>. Differently, based on the observation in Section 1, we propose the k-mutual-friend subgraph to emphasize on tie strength. One important property about edges in clique is that every edge is supported by T r(e) = k -2 triangles in a k-clique. Analogous to the kcore definition, the k -mutual-friend sets a lower bound for every edge's triangle count. Next we will formally define the k -mutual-friend and show its relationships to other cohesive structures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The k -mutual-friend Subgraph</head><p>Definition 3.2. (k-mutual-friend Subgraph) A k-mutual-friend is a connected subgraph g ∈ G such that each edge is supported by at least k pairs of edges forming a triangle with that edge within g. The k-mutual-friend number of this subgraph, denoted as M(g), equals k.</p><p>Note that we need to exclude the trivial situation to consider a single vertex as a mutual-friend. Given the parameter k, we may discovery many k-mutual-friend subgraphs that overlap with each other. In the worst case, the number of k-mutual-friend subgraphs can be exponential to the graph size. Therefore, we further define the maximal k -mutualfriend subgraph to avoid redundancy. Definition 3.3. (Maximal k-mutual-friend Subgraph) A maximal k-mutual-friend subgraph is a k-mutual-friend subgraph that is not a proper subgraph of any other k-mutualfriend subgraph.</p><p>To compare with clique and core, we present two interesting properties about the k -mutual-friend subgraph.</p><formula xml:id="formula_0">Property 3.1. Every (k + 2)-clique of G is contained in a k-mutual-friend of G.</formula><p>Proof. Since a (k + 2)-clique is a fully connected subgraph with order k + 2, each edge is supported by k triangles. Therefore, it is contained in a k-mutual-friend subgraph by Definition 3.2.</p><formula xml:id="formula_1">Property 3.2. Every k-mutual-friend of G is a subgraph of a (k + 1)-core of G.</formula><p>Proof. For each vertex v in g k , it connects to at least k triangles. Every triangle adds one neighbor vertex to v except the first adding two neighbors, so that v has (k + 1) neighbors, i.e. d(v) ≥ (k + 1). Therefore, g k qualifies as a (k + 1)-core of G.</p><p>The above two properties suggest one important observation: (k + 2)-clique ⊆ k-mutual-friend ⊆ (k + 1)-core, showing that the mutual-friend is a kind of cohesive subgraph between the clique and the core. Note that the reverse of the above two properties are not true. Again in Figure <ref type="figure" target="#fig_1">1</ref>, the 4-clique (m, n, p, q) is a subgraph of the 2-mutualfriend (m, n, p, q, t, u), while 2-mutual-friend (a, b, c, d, e, f ) and (m, n, p, q, t, u), both of them are contained in the <ref type="figure">b,</ref><ref type="figure">c,</ref><ref type="figure">d,</ref><ref type="figure">e,</ref><ref type="figure">f,</ref><ref type="figure">m,</ref><ref type="figure">n,</ref><ref type="figure">p,</ref><ref type="figure">q,</ref><ref type="figure">t,</ref><ref type="figure">u</ref>). Finally, we define the main problem we investigate in this paper as follows.</p><p>Problem 1. (Maximal k-mutual-friend Subgraph Finding) Given a social graph G(V, E) and the parameter k, find all the maximal k-mutual-friend subgraphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Comparison to DN -Graph</head><p>Before we illustrate the solution to Problem 1, we further state an interesting connection between the mutual-friend concept and the DN -Graph concept proposed by Wang et al. <ref type="bibr" target="#b24">[24]</ref> recently. A DN -Graph, denoted by G ′ (V ′ , E ′ , λ), is a connected subgraph G ′ (V ′ , E ′ ) of graph G(V, E) that satisfies the following two conditions: (1) Every connected pair of vertices in G ′ shares at least λ common neighbors.</p><p>(2) For any v ∈ V \V ′ , λ(V ′ {v}) &lt; λ; and for any</p><formula xml:id="formula_2">v ∈ V ′ , λ(V ′ -{v}) ≤ λ.</formula><p>At the first glance, DN -graph is similar to the maximal k-mutual-friend subgraph. However, these two concepts are distinct due to the second condition in DN -Graph definition. Intuitively, the DN -graph defines a strict condition that the maximal subgraphs need to reach the local maximum even for adding or deleting only one vertex. On the other hand, the maximal k-mutual-friend defines the local maximal subgraph that is not a proper subgraph of any other k -mutual-friend subgraph. As demonstrated in Figure <ref type="figure" target="#fig_1">1a</ref>, (m, n, p, q), (p, q, t, u) and (m, n, p, q, t, u) are all DN -Graphs with λ = 2, since the λ value can only decrease if adding or removing any vertices. However, only (m, n, p, q, t, u) is the maximal 2-mutual-friend since other two are its subgraphs. This example shows that the DN -Graph finding may generate many redundant subgraphs. Furthermore, due to the hardness of satisfying the second condition, solving the DN -Graph problem is NP-Complete as proven by the authors. To solve it they iteratively refine the upper bound for each edge to approach the real value, but it still has high complexity and isn't suitable for large scale graph. Actually, the mutual friend finding is inspired by the DN -Graph concept and we improve it by providing efficient solution in polynomial time subsequently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Comparison to Truss Decomposition</head><p>Truss decomposition is a process to compute the k-truss of a graph G for all 2 ≤ k ≤ kmax, in which k-truss is a cohesive subgraph ensures that all the edges in it are supported by at least (k -2) triangles <ref type="bibr" target="#b22">[22]</ref>. The truss definition is similar to but proposed independently with the mutual friend defined in this paper except the meaning for k. Besides, the authors for truss decomposition realize that memory solution can not handle large scale social networks. They develop two I/O efficient algorithms. One is a bottom-up approach that employs an effective pruning strategy by removing a large portion of edges before the computation of each k-truss. The second one takes a top down approach, which is tailor for applications that prefer the k-trusses of larger values of k. Differently, we store the social graph in graph database that is scalable for graph traversal based algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">OFFLINE COMPUTATIONS</head><p>In this section, we first propose memory based solutions to solve Problem 1 in polynomial time, and then leverage the graph database to extend the solution for large scale social network analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Memory based Solution</head><p>Given a social graph G and the parameter k, the intuitive idea of discovering the maximal k-mutual-friend is to remove all the unsatisfied vertices and edges from G. Based on the Definition 3.2, we iteratively remove edges that are not contained in k triangles until all of them satisfy the condition T r(e) ≥ k. The procedure is illustrated in Example 1.</p><p>Example 1. Considering a maximal k-mutual-friend finding with k = 2 over the graph in Figure <ref type="figure" target="#fig_2">2a</ref>, the left part of Figure <ref type="figure" target="#fig_1">1a</ref>. First, edges {(e, i), (e, h), (e, g), (f, h)} are removed since their triangle counts are less than 2. Next, {(d, g), (f, g), (g, h)} are further removed since their triangle counts become less than 2, while e(d, e) is still part of the 2-mutual-friend due to T r(e(d, e)) = 2. In the third loop, T r(e(d, f )) reduces to 3 but still satisfies the condition. Because all the remaining edges with triangle counts larger than or equal to 2, the graph remains unchanged and the loop terminates. Lastly, we delete all the isolated vertices and obtain 2-mutual-friend (a, b, c, d, e, f ) as in Figure <ref type="figure" target="#fig_2">2b</ref>. Although this is a straight forward solution, the computational complexity is relatively high because it has lots of unnecessary triangle computations. In the worst case it removes one edge at a time and needs |E| times loops to remove all the edges from G. As such, the total complexity is</p><formula xml:id="formula_3">|E| × e(u,v)∈G (d(u) + d(v)), in which d(u) + d(v)</formula><p>is the complexity to compute the triangle count for one edge. This expression can be further simplified to the order of |E| × v∈G d(v) 2 , because we need to get the v's neighbors d(v) times in one loop. For practical case, we seldom encounter this extreme situation, but a large number of iterations is still a bottleneck of this solution.</p><p>As such, we propose an improved algorithm based on the following observation. When an edge is deleted, it only decreases the triangle counts of the edges which are forming triangles with that edge. Thus we can obtain edges affected by the deleted edge and only decrease triangle counts for them. This intuition is reflected in Algorithm 1, which can be divided into three steps. First, one necessary condition for T r(e(u, v)) ≥ k is d(u) ≥ k + 1 and d(v) ≥ k + 1 as in the proof of Property 3.2. This is a lightweight method of deleting many vertices and their adjacent edges before removing unsatisfied edges with insufficient triangles. The remaining graph is then processed by the second step, which costs most of the workload to remove edges not supported by at least k triangles. From line 6 to 9, we first check all the edges' triangle counts. The Q is implemented as a hash set to record non-redundant removed edge elements. Next, instead of computing the triangle on all the edges to check the stability of the graph, we iteratively retrieve the affected edges from Q until Q is empty. This is the indicator that the graph becomes unchanged. Finally, the removal of inadequate edges likely results in isolated vertices, which are removed in the end. We show the procedure in the running example as follows.</p><p>Example 2. We consider a maximal 2-mutual-friend finding in Figure <ref type="figure" target="#fig_2">2a</ref> again based on Algorithm 1. According to the degree condition, we first remove vertex i and the edge (e, i) since the degree of i is less than 3. We then check the edge's triangle counts and delete {(e, g), (e, h), (f, h)}. Moreover, we record these edges in Q for affected edges. Edges {(d, g), (f, g), (g, h)} are further removed until Q is empty. Finally, we delete all the isolated vertices and generate the same result as in Example 1.</p><p>We next prove the correctness of Algorithm 1 in two aspects. On one hand, the remaining vertices and edges are part of the maximal-k-mutual-friend subgraphs. This aspect is true according to the definition of k-mutual-friend subgraph. On the other hand, the removed vertices and edges are not part of the maximal-k-mutual-friend subgraphs. Because the only modification on G is the removal of edges, bringing about the decrease of triangle counts, the edges supported by less than k triangles can be safely deleted since they cannot be part of a k-mutual-friend subgraph any more. As for complexity analysis, the improved algorithm outperforms the naive one remarkably because it avoids a great deal of unnecessary triangle computations. The first step takes O(|V |) complexity to check vertices' degree. The second step dominates the whole procedure. The initial triangle counting has time complexity v∈G d(v) 2 . From line 10 to 17, finding all the edges forming triangles with the current edge e(u, v) takes d(u)+d(v) work. In the worst case, all the edges are removed from Q. Since Q only stores each edge one time, the total cost is e(u,v)∈G (d(u) + d(v)), equal to v∈G d(v) 2 . The last step also takes O(|V |) complexity to delete isolated vertices. As a whole, the total time complexity is O( v∈G d(v) 2 ). It not only avoids the unnecessary iterations, but also reduces the graph size with relative small effort in the first step. Although the above algorithm is efficient, but is not suitable for large scale graph processing stored in disk. Retrospect the algorithm, it needs O(|E|) space complexity, which is too large to store in memory. So we extend it to the disk based solution in the following section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Solution in Graph Database</head><p>In this section, we first introduce the concept of graph database, and then present a streaming solution in graph database and improve it by means of partitioning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">The graph database</head><p>A graph database <ref type="bibr" target="#b17">[17]</ref> represents vertices and edges as a graph structure instead of storing data in separated tables. It is designed specifically for graph operations. To this end, a graph database provides index-free adjacency that every vertex and edge has a direct reference to its adjacent vertices or edges. More explicitly, there are two fundamental storage primitives: vertex store and edge store, which layouts are shown in figure <ref type="figure">3</ref>. Both of them are fixed size records so that we could use offset as a "mini" index to locate the adjacency in the file. Vertex store represents each vertex with one integer that is the offset of the first relationship this node participates in. Edge store represents each edge with six integers. The first two integers are the offset of the first vertex and the offset of the second vertex. The next four integers are in order: The offset of the previous edge of the first vertex, the offset of the next edge of the first vertex, the offset of the previous edge of the second vertex and finally the offset of the next edge of the second vertex. As such, edges form a doubly linked list on disk, so that this model possesses a significant advantage: there is a near constant Example 3. Consider the process of the triangle counting. Given e(u, v), we need to fetch N (u) and N (v). In relational database, we can utilize vertices to query the edge table index with O(log |V |) I/O cost, and then compute the shared neighbors as the triangle count. This procedure can be largely improved in graph database. According to the edge store, we can retrieve N (u) and N (v) as the traversal in the double linked list. prevEdge and nextEdge in Figure <ref type="figure">3</ref> provide reference to all the neighbors of vertices u and v, so that we can finish this step with O(d(v)) I/O cost, which is invariant to the graph size.</p><p>Later in this section, we make use of the traversal operator extending the in memory algorithm to I/O-efficient algorithms in a graph database. We define the traversal operator as traverse(elem, step) for better demonstration, which means that the length of shortest paths from graph element elem to the satisfied results cannot be larger than step. For example, traverse(u, 1) retrieves all the vertices that are directly connected to u and the edges among them. For implementation, we utilize the Neo4j<ref type="foot" target="#foot_2">3</ref> graph database. Note that we could easily migrate our algorithms to other popular graph databases as long as they are optimized for graph traversal, such as DEX <ref type="foot" target="#foot_3">4</ref> , OrientDB<ref type="foot" target="#foot_4">5</ref> and so forth.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Streaming based solution</head><p>The streaming based solution is modified from Algorithm 1 and implemented in the graph database. The major changes are two-fold. On one hand, we use graph traversal to access vertices and edges (line 1 and 3), as well as compute triangle counts (line 5 and 6). On the other hand, we build index on edge attributes to mark edges as deleted (line 7, 9 and 15) and record edges' triangle counts (line 8, 13 and 14). Note that the edge attributes are in the order of O(|E|), so they still need to be maintained out of core for large graph datasets. In this way, we make full use of the graph database, and keep all the advantages in the improved memory algorithm. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Partition based solution</head><p>Since all the triangle computations are directly operated in graph database, the streaming algorithm fails to make full use of the memory. Therefore, we proposed an improved approach based on the graph partitioning, and load partitions into memory to perform in memory triangle computations to save I/O cost and improve efficiency. To begin with, we derive a greedy based partitioning method in Algorithm 3 from the heuristics in paper <ref type="bibr" target="#b20">[20]</ref>. The basic idea is to streamingly process the graph and then assign every vertex to the partition where it has the largest number of edges connecting to. As in line 11 in Algorithm 3, localP artitionN um records the number of edges in each partition, (1 -|gi| × p/|G|) suggests that partitions with larger size have smaller weight, and the product of the above two factors decides which partition the current vertex belongs to. This algorithm, requiring one breadth first graph traversal, is efficient with linear I/O complexity. However, the resulting partitions cannot be directly used because this algorithm is a vertex partitioning. Typically, it only extends partitions by including all the vertices connecting to the vertices inside the partition, which may result in the loss of triangles. As in Figure <ref type="figure">4a</ref>, the running example is partitioned into three parts {g1, g2, g3}. In this case, the triangle (a, j, p) is missing since its vertices are separated into three partitions. In order to keep all the triangles, we define an induced subgraph as in Definition 4.1. Based on the induced subgraph, the triangle (a, j, p) in Figure <ref type="figure">4a</ref> is allocated in g1 as shown in Figure <ref type="figure">4b</ref>, because id a is smaller than j, p in this triangle. Next we formally prove the correctness of the partitioning method in Lemma 4.1.</p><p>Lemma 4.1. Induced subgraphs {g1, . . . , gp} derived from p partitions of G have the same set of triangles as G.</p><p>Proof. The lemma is equivalent to the statement that every triangle (u, v, w) in G appears once and only once in all partitions. The proof can be divided into three cases. If three vertices belong to Vi of partition i, the triangle can only be inside the same partition. If any two of three vertices belong to Vi of partition i, without loss of generality, we assume that u, v ∈ Vi and w ∈ Vj. The triangle is in partition i but not in partition j, since (u, v) can only be assigned to partition i. If three vertices are located in different partitions, we assign the triangle to the vertex with smallest id as defined in ∆Ei, so this triangle only appears once in induced subgraphs.  Finally, we provide a partition based solution in Algorithm 4. First we partition the graph into p partitions, and for each partition, we do the in memory edge removal. Note that we only consider inside edges, which only affect triangles satisfying {(u, v, w), u, v, w ∈ Vi}. As such, we make use of the memory to reduce the graph size as well as keeping the correctness of the solution. After this, we write the induced subgraphs back to graph database and use Algorithm 2 to do post processing. We take the induced subgraph g1 in figure <ref type="figure">4b</ref> to find 2-mutual-friend subgraph. Note that edges {(a, j), (a, p), (j, p)} are outside edges, while others are inside edges. For inside edges, we directly apply in memory algorithm and remove edges in dotted lines with triangle counts less than 2. But for outside edges, we cannot delete them since they may affect triangle counts in other partitions. After we deal with all the partitions, we post process the refined graph using Algorithm 2 to obtain the final result. In the worst case, this algorithm has the same I/O complexity as Algorithm 2. But in practice, it loads and processes the induced subgraphs to memory and avoids many disk triangle computations. The detailed comparison between this two disk-based solutions will be presented in the experimental section. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">ONLINE VISUAL ANALYSIS</head><p>Based on the algorithms proposed in the previous section, we develop a client-server architecture to support online interactive social visual analysis. As in Figure <ref type="figure" target="#fig_9">5</ref>, the offline computations are the base for the online visual analysis. For online analysis, we retrieve a local subgraph g close to the user selected vertex on top of offline computing result, online compute the exact M values for graph elements inside g, and generate the orbital layout for visualization. Moreover, we select representative tags to summarize the textual information in the local graph. In the client side, user can search and browse the visualized subgraph.</p><p>To support online visual analysis, we implement a visual interactive system accessible on the Web<ref type="foot" target="#foot_5">6</ref> , and provide a use case on Twitter dataset in Figure <ref type="figure" target="#fig_14">8</ref> to illustrate our idea.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Online Algorithm</head><p>Based on the offline computations, we retrieve a local subgraph associated with the input keywords from graph database and compute exact M values for every edge and vertex inside the subgraph. This is a fundamental step to support graph layout later in this section. User can select a focused vertex v from a list of vertices containing the keywords, and our system will return a local subgraph including all the vertices within the distance τ from v and the edges among these vertices, i.e. traverse(v, τ ). For efficient online computation, we show one important stability property of the k-mutual-friend subgraph as follows.</p><p>Property 5.1. The k-mutual-friend is stable with respect to the parameter k, i.e. g k+1 ⊆ g k .  For every edge e in subgraph g k+1 , T r(e) ≥ k + 1 &gt; k suggests that this subgraph is also a g k . Therefore, based on the stability property, if one wants to compute the exact M values for graph elements, we can make use of the offline result as input, with much less work than computing from scratch. Furthermore, the offline computations provide a useful upper bound for online computations. Proof. Since g is a subset of G, for every edge e ∈ g, its local triangle count should be smaller or equal to the global triangle count, i.e. T rg(e) ≤ T rG(e). Based on the definition of k-mutual-friend subgraph, the local triangle count bounds the Mg value. All in all, we obtain the relationship Mg(e) ≤ T rg(e) ≤ T rG(e).</p><p>We implement Algorithm 5 based on the above observations. The first step is to retrieve the local subgraph within the distance τ to v. Then, we iteratively compute the exact gm from m = Mmin to m = Mmax. Finally, we merge all the gm to obtain the local subgraphs with exact M values. To illustrate, we retrieve a local subgraph by traverse(a, 2) from the graph in Figure <ref type="figure" target="#fig_1">1</ref>, and the result local graph is shown in Figure <ref type="figure">6a</ref>. The number shows the triangle counts computed by the offline algorithm, which are the upper bound for the exact M values. Vertices {k, l, j} and edges in dotted lines are immediately removed since their triangle counts are smaller than 2. In the first loop, we remove vertex g and edges e(d, g), e(f, g) because their M values become one in the local graph. The rest of the graph is the 2-mutual-friend. In Figure <ref type="figure">6b</ref>, we use the similar procedure to find 3-mutual-friend from the 2-mutual-friend, which includes vertices {a, b, c, d, f } and edges connecting them. The algorithm terminates since the Mmax is updated to the current largest triangle count equal to three.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Visualizing k -mutual-friend Subgraph</head><p>Based on the online algorithm results, we next visualize the local subgraph reflecting the characteristics of the kmutual-friend in social network. To begin with, we propose an orbital layout to decompose the network into hierarchy. Subsequently, we describe the implementation details of this layout in our visual system. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">Orbital layout</head><p>As claimed in the introduction, the k-mutual-friend definition is proposed to capture the tie strength property in social network. Intuitively, vertices with larger M values are more important since they are closely connected with each other in the social network with many mutual friends. Therefore, a good layout for k-mutual-friend needs to emphasize elements with larger M values since they compose more cohesive subgraphs. With this observation we propose a layout with a set of concentric orbits. Vertices with larger M values are located close to the center, while vertices with smaller M values are placed on orbits further away from the center. Since the layout is analogous to the planetary orbits, it is called orbital layout as depicted in Figure <ref type="figure" target="#fig_1">1b</ref>. The most connected part of the network is also the most central, such as the 5-clique (a, b, c, d, f ) in the innermost orbit.</p><p>Furthermore, since organizes vertices with different M values into separated circles, the orbital layout forms a hierarchical structure. As such, users can filter out outer orbits and focus on the most central vertices, especially useful when the graph size is too large to clearly view. More importantly, the orbital layout is stable in the sense that the central part has the similar topological properties as the original graph. Figure <ref type="figure" target="#fig_13">7</ref> shows the cumulative degree distribution for the Epinions social network introduced in Table <ref type="table" target="#tab_3">2</ref>. Yet interestingly, the shape of the distributions is not affected by the parameter k. Note that the degree is normalized by the corresponding average degree in each kmutual-friend, since it tends to have higher average degree for larger k. The y-axis shows P&gt;(d), i.e. the probability that the vertex degree in this k-mutual-friend subgraph is larger than d. Based on this nice property, the filtering operation on the hierarchy is reasonable without losing much structural information.  Note that users can perceive more insights using orbital layout comparing with other popular layout algorithms, such as the radial layout <ref type="bibr" target="#b4">[4]</ref> and the force directed layout <ref type="bibr" target="#b11">[11]</ref>. Although radial layout is a hierarchical structure, it is sensitive to the focused vertex in the center and the layout may totally change with a different center. Force directed layout represents the topology well but is not a hierarchical structure to highlight social actors with many mutual friends. Also, it is not scalable due to O(|V | 3 ) complexity. The qualitative comparison among these layouts is summarized in Table <ref type="table" target="#tab_2">1</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">Implementations</head><p>To improve the visual effect, we need to overcome the visual complexity of orbital layout, because it is a challenge to clearly present the cohesive subgraph with a large number of vertices. First, we set different colors to distinguish vertices in different orbits. Retrospect the motivating example in Figure <ref type="figure" target="#fig_1">1b</ref>, it consists of four orbits in different colors representing vertices with four M values from 3 inside to 0 outside. In order to distinguish vertices within one orbit, the size of vertices is proportional to vertex degree to reflect the importance. For instance, vertex p has the largest degree so that it has the biggest size.</p><p>Next, we consider how to visualize edges to further reduce the visual complexity. Since vertices within one orbit may form several connected k-mutual-friend subgraphs, so we carefully order vertices such that vertices belongs to one subgraph are located successively on the orbit. As such, we can hide edges within one orbit without losing much connection information. As the Figure <ref type="figure" target="#fig_1">1b</ref> shows, vertices g and h are near in the orbit and vertices j, k and l are near in the orbit. Furthermore, inspired by the radial layout, we put a vertex close to connected vertices in the inner orbit to minimize crossing edges. For example, vertices g and h are located in the top left since they are close to the inner neighbor vertex e.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Representative Tag Cloud Selection</head><p>Besides structure visualization, another dimension of social network analysis is to understand the interactions among social actors, which come from, for instance, the newfeeds from Facebook or tweets from Twitter. Since users may select a group of social actors with a great number of textual contents, we incorporate the tag cloud approach to summarizing various topics inside it. A potential challenge is how to select the most important tags to capture the major interests of these actors. Moreover, for distinct topics, the challenge might be how to discover a set of tags so that they could be comprehensive enough to cover different interests inside the same group.</p><p>To tackle these challenges, we compute a score for each tag by multiplying two factors, the significance and diversity. On the one hand the significance measure guarantees the truly popular tags can be selected, and on other hand the diversity measure captures various rather than only similar topics. In our implementation, we adopt the TF-IDF approach for significance and the semantic distance in Word-Net <ref type="bibr" target="#b5">[5]</ref> for diversity. In representative tag selection, we first generate top N frequent words to form a candidate set, and filter out infrequent words to improve the efficiency. Then, we utilize a greedy strategy that iteratively moves tags with the largest score from the candidate set to the representative set until the number of selected tags reaches n, n &lt; N , a user adjustable parameter. As such, we discover representative tags summarizing the interactions inside the local subgraph. Users can quickly select and browse preferred subgroup of actors to explore what activities they are involved in, or what topics they are taking about, etc.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Case Study</head><p>Based on the real use case on Twitter social graph, we illustrate the functionalities and the advantages of our visual analytic browsing interface in Figure <ref type="figure" target="#fig_14">8</ref>, which consists of three parts, i.e. search input area on the top, information summarization in the left column, and subgraph visualization in the main frame. After users input keywords in search box and select a focused vertex matching the keywords, our system visualizes the local subgraph in the main frame, so that users can select vertices they are interested in with the summarization in the left column. Without loss of generality, this example shows the 3-mutual-friend graph for the keyword "white house", in which vertices represent twitter actors and edges represent the "following" relationships. The depth, equivalent to the distance threshold, is set to 2.</p><p>With the help of online algorithm and layout generation, we dramatically reduce the visual complexity in the main frame. The visible subgraph only contains 89 vertices and 527 edges, which is much smaller the initial local subgraph with 2006 vertices and 2838 edges. As a result, we could quickly perceive that the networking of "The White House" is dominated by various US departments and government officials, which is unlikely to obtain from thousands of vertices with messy information. Furthermore, users can highlight several vertices and their neighbors while other vertices and edges become transparent. Considering in some cases subgraphs are quite large, users can use frontend search to locate preferred vertices within the current subgraph, or ad- The left column displays the M values of the highlighted vertices, the corresponding tag cloud as well as the link information for the vertex representing officials of "Veterans Affairs". The tag cloud is a helpful tool that summarizes the most significant and diverse topics in their tweets. In this example, we select 30 representative tags out of 100 candidates, where "Veterans Affairs" may show great concern about the PTSD (Post Traumatic Stress Disorder) and discrimination problems while "womenshealthgov" mainly focuses on topics like health, breast cancer and baby. In order to know the source of these tags, hovering over specific tag in the tag cloud will trigger the source vertices being highlighted. If we point to the "insurance" tag, the Twitter actor "Barack Obama" will be highlighted indicating that he pays close attention to the insurance issue.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">EXPERIMENTS</head><p>We present experimental studies to evaluate our social network visual analysis system in this section. For simplification, we refer to the intuitive algorithm in Section 4.1 as mNaive, Algorithm 1 as mImproved, while refer to Algorithm 2 as dStream, Algorithm 4 as dPartition. The mOnline is short for the online algorithm. We implement these algorithm in Java language and evaluate on the Windows operating system with Quad-Core AMD Opteron(tm) processor 8356 and 128GB RAM.</p><p>We compare our solutions on a great deal of real social network datasets described in Table <ref type="table" target="#tab_3">2</ref>, most of which are collected from the Stanford Network Analysis Project's website <ref type="foot" target="#foot_6">7</ref> . The datasets are sorted in increasing order of edge number. We utilize moderate size datasets (the first three) to compare in memory algorithms, while use large size datasets (the last three) to compare algorithms in graph database. Moreover, Twitter and DBLP datasets are selected for online visual analysis since they contain rich textual information. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Offline Computations Evaluation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.1">Memory based Algorithms</head><p>We compare mNaive and mImproved algorithms on three datasets and results are summarized in Figure <ref type="figure" target="#fig_15">9</ref>. This figure depicts the effect of k on the response time of three datasets. For Epinions and DBLP datasets, mImproved outperforms mNaive evidently, while their performances on Twitter dataset are in the same level. This is because Twitter dataset having average degree less than 2 is much more sparse than the other two datasets. Therefore, even the naive algorithm can reach the stable state very fast without incurring a great deal of unnecessary triangle computations. For other two datasets, mImproved is about one order faster than mNaive averagely.</p><p>One interesting observation is that the response time is not quite related to k, but mainly determined by the triangle  <ref type="table" target="#tab_4">3</ref>, the triangle computing times for Epinions dataset in mNaive is about ten times of that in mImproved, which is close to the ratio of response time. Thus, the result again justifies our conclusion in Section 4.1 that mImproved outperforms mNaive mainly because it largely reduces the amount of triangle computations. More specifically, when k = 1, because we only remove edges not in any triangles without affecting other edges, mNaive can finish in two iterations (make sure that the graph is unchanged in the second iteration), and mImproved only needs one iteration. The response time for mNaive decreases when k equals to 5 since the number of triangle computations drops to 2, 439k, smaller than the number when k equals to 3 and 4. The triangle computing times for DBLP dataset in the last two rows in Table <ref type="table" target="#tab_4">3</ref> have the similar pattern. For Twitter dataset, both algorithms need the number of triangle computations in the same level, which determines that their response time also close to each other. To sum up, mImproved is much faster than mNaive mainly because it reduces the number of triangle computations, especially when the graph is dense. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.2">Disk based Algorithms</head><p>Next we evaluate the disk based algorithms with three large scale datasets. For partition based algorithm, we control the usage of memory by only allowing to store a subgraph with at most 1GB size. As such, we can estimate the number of partitions p for each dataset according to the graph size in graph database as in Table <ref type="table" target="#tab_5">4</ref>. Since the response time is not determined by k, we set k as 3 to compare the performance of two disk based algorithms. The results in Figure <ref type="figure" target="#fig_16">10</ref> depicts the response time for the three datasets with two parts: I/O time and CPU time. All in all, the partition based algorithm is about five times faster than the streaming based algorithm, and the response times for both of them are increasing with respect to the increase of graph size. In particular, dStream algorithm is dominated by the I/O time, while dPartition is dominated by the CPU time, in accord with our analysis in Section 4.</p><p>In essence, the major difference between dStream and dPartition is the cost for triangle computations. As shown in Table <ref type="table" target="#tab_6">5</ref>, the average cost for triangle computations in dPartition is only one tenth of that in dStream, because most of the triangle computations in the former approach are in memory while all the triangle computations in the later one are in graph database. Comparing three datasets, the average triangle computing time for Facebook is the fastest for both algorithms due to the smallest average degree of Facebook. As a result, although the number of edges in Facebook is much larger than that in FriendFeed, the response time of Facebook is slightly larger than that of FriendFeed. Moreover, Table <ref type="table">6</ref> summarizes the percentages of the partitioning part and the computing part for dPartition algorithm. Because the partitioning algorithm reads the input graph only once and writes the partitions back to graph database, the partitioning part costs small amount of time comparing to the computing part.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Online Analysis Evaluation</head><p>By randomly selecting 10 focused vertices on Twitter and DBLP datasets respectively, we obtain the average performance of online analysis with three components: mOnline algorithm, orbital layout generation and tag cloud selection. All the experiments are based on the 3-mutual-friend graph calculated by the offline solution. For tag cloud selection, we obtain 20 representative tags out of 100 candidates from the text in focused vertices. The major objective is to test whether our system can well support online analysis.</p><p>Table <ref type="table" target="#tab_7">7</ref> shows the efficiency measures by varying the distance threshold τ from 1 to 3. It is clear that the total response time has an ascending trend with the increase of τ for both datasets. Taken separately, the costs of online algorithm and the layout generation are largely increasing with respect to τ . The major reason is that the response time for the first two components is proportional to the number of edges, which increases obviously with respect to τ , as in the bottom row of Table <ref type="table" target="#tab_7">7</ref>. However, the speed of tag cloud selection remains stable since it is only affected by the textual content in the focused vertex. Comparing the difference between two datasets, the tag cloud selection for Twitter is much slower because the number of words in tweets is large than that in paper title. 22 348 7727 Moreover, the average edge number suggests that distance threshold τ = 2 is a practical setting for online analysis, generating local subgraph with reasonable size. Note that we don't consider network transmission time since it is unstable and highly affected by the network condition, which is not the focus of this evaluation. In summary, the whole analytical procedure can be finished less than three second so that it is acceptable for online interactive applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSIONS</head><p>In this paper, we have introduced a novel framework that integrates the cohesive subgraphs discovery with the visual social network analysis. Unlike previous works, we proposed a new cohesive subgraph definition called k-mutual-friend to take the tie strength into consideration. Moreover, a memory based solution is proposed and extended to the scalable solution in the graph database. To further consolidate this interesting framework, we provided a visual analytic browsing interface that helps navigate users in searching and browsing the graph structure as well as semantics. The outcomes from an experimental study demonstrated that our solution is both efficient and effective. As for future research, we expect to extend our framework for other graph based analytic applications, such as protein-protein interaction analysis, RDF graph analysis etc. Another challenging direction is to maintain the cohesive subgraphs with frequently updates. As such, we shall provide a real time analytic toolkit to monitor everyone's evolving social network.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Cohesive Graph Example</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Example of in Memory AlgorithmAlthough this is a straight forward solution, the computational complexity is relatively high because it has lots of unnecessary triangle computations. In the worst case it removes one edge at a time and needs |E| times loops to remove all the edges from G. As such, the total complexity is |E| × e(u,v)∈G (d(u) + d(v)), in which d(u) + d(v) is the complexity to compute the triangle count for one edge. This expression can be further simplified to the order of |E| × v∈G d(v) 2 , because we need to get the v's neighbors d(v) times in one loop. For practical case, we seldom encounter this extreme situation, but a large number of iterations is still a bottleneck of this solution.As such, we propose an improved algorithm based on the following observation. When an edge is deleted, it only decreases the triangle counts of the edges which are forming triangles with that edge. Thus we can obtain edges affected by the deleted edge and only decrease triangle counts for them. This intuition is reflected in Algorithm 1, which can be divided into three steps. First, one necessary condition for T r(e(u, v)) ≥ k is d(u) ≥ k + 1 and d(v) ≥ k + 1 as in the proof of Property 3.2. This is a lightweight method of deleting many vertices and their adjacent edges before removing unsatisfied edges with insufficient triangles. The remaining graph is then processed by the second step, which costs most of the workload to remove edges not supported by at least k triangles. From line 6 to 9, we first check all the edges' triangle counts. The Q is implemented as a hash set to record non-redundant removed edge elements. Next, instead of computing the triangle on all the edges to check the stability of the graph, we iteratively retrieve the affected edges from Q until Q is empty. This is the indicator that the graph becomes unchanged. Finally, the removal of inadequate edges likely results in isolated vertices, which are removed in the end. We show the procedure in the running example as follows.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Algorithm 1 : 2 remove v and related e from G 3 /</head><label>123</label><figDesc>Improved k-mutual-friend Input: Social graph G(V, E) and parameter k Output: k-mutual-friend subgraphs // filter by degree of vertices foreach v ∈ V do 1 if d(v) &lt; k + 1 then / delete edges with insufficient triangles initialize a queue Q to record removed edges 4 initialize a hash table T r to record triangle counts 5 foreach e = (u, v) ∈ E do 6 compute T r(e) based on N (u), N (v) 7 if T r(e) &lt; k then 8 enqueue e to Q 9 while H = ∅ do 10 dequeue e from Q 11 find out edges E ′ forming triangles with e 12 remove e from G 13 foreach e ′ ∈ E ′ do 14 T r(e ′ ) --15 if T r(e ′ ) &lt; k then 16 enqueue e ′ to Q 17 // delete isolated vertices foreach v ∈ G do 18 if d(v) == 0 then remove v from G 19 return G 20</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Algorithm 2 : 2 / 4 N 8 while 9 E 10 remove e from G 11 foreach e ′ ∈ E ′ do 12 T r(e ′ ) -- 13 if T r(e ′ ) &lt; k then 14 mark e ′ as deleted 15 delete isolated vertices from G 16 return G 17 We</head><label>224891011121314151617</label><figDesc>Streaming based Algorithm Input: Social graph G(V, E) and parameter k Output: k-mutual-friend subgraphs // filter by degree of vertices traverse the vertices of G 1 remove v and related edges if d(v) &lt; k + 1 / delete edges with insufficient triangles traverse the edges E of G 3 foreach e = (u, v) ∈ E do (u) ←traverse(u, 1);N (v) ←traverse(v, 1) 5 compute tr(e) according to N (u), N (v) 6 if T r(e) &lt; k then mark e as deleted 7 else set e's mutual number attribute as T r(e) exist edges e(u, v) marked as deleted do ′ ←edges form triangles with e in traverse(e,1) next analyze the I/O cost in this algorithm. Filtering by degree and deleting isolated vertices need O(|E|) I/O. The most costly part is removing edges with insufficient triangles. For edge (u, v), finding triangle count takes O(d(u)+d(v)) I/O work. Similar to the analysis for memory based algorithm, each edge can only be marked as deleted once. We conclude that this step needs O( v∈G d(v) 2 ) I/O cost, which is also the total order of I/O consumptions. Besides, the traversal on vertices and edges is dominated by sequential I/O, which further reduces the I/O cost.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Definition 4 . 1 .</head><label>41</label><figDesc>(Induced Subgraph) Denote gi+ = (Vi+, Ei+) as an induced subgraph of a partition gi(Vi, Ei) of G. The extended vertex set is defined asVi+ = Vi {v : u ∈ Vi, v ∈ V \Vi, (u, v) ∈ E}. The extended edge set is defined as Ei+ = {(u, v) : (u, v) ∈ E, u ∈ Vi} ∆Ei.where ∆Ei are edges satisfying {(v, w) : u ∈ Vi, (u, v), (u, w) ∈ E, v.partition = w.partition, u.id &lt; v.id, u.id &lt; w.id}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>(a) Partition into {g1, g2, g3} (b) Computation on g1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 4 : 2 remove v and related edges; continue 3 initialize the array localP artitionN um with size p 4 N 5 ind ←-u's partition index 6 if 8 pIndex ←-- 1 9for i from 1 to p do 10 curW eight ←- 11 localP 12 maxW eight ←-curW eight 13 pIndex ←-i 14 set v's partition index as pIndex 15 return G 16</head><label>4234568110111213141516</label><figDesc>Figure 4: Example of Partition based Algorithm Algorithm 3: Graph Partitioning Input: Social graph G(V, E), partition number p Output: {g1, . . . , gp} partitions foreach v ∈ G in BFS order do 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Algorithm 4 : 1 for i from 1 to p do 2 load 8 enqueue e to Q 9 repeatly</head><label>41289</label><figDesc>Partition based Algorithm Input: Social graph G(V, E), parameter k, and partition number p Output: k-mutual-friend subgraphs partition the graph based on Algorithm 3 induced subgraph gi+ into memory from the 3 partition i // Do in memory edge removal queue Q ←-∅ 4 hash table T r ←-∅ 5 foreach e = (u, v) ∈ Ei+ e is inside do 6 compute T r(e) based on N (u), N (v) 7 if T r(e) &lt; k then remove inside edges until Q is empty 10 write gi+ back to the graph database 11 use Algorithm 2 to do post processing 12 return G 13</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Social Network Visual Analytic System</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Lemma 5 . 1 .</head><label>51</label><figDesc>Given G(V, E) after offline computation, the edges from the online local subgraph g G satisfy {Mg(e) ≤ T rg(e) ≤ T rG(e), e ∈ g}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Algorithm 5 : 2 Mmin ←-k 3 for m from Mmin to Mmax do 4 compute m-mutual-friend and update g by 5 Figure 6 :</head><label>523456</label><figDesc>Figure 6: Example of Online Computation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Stability Test on Epinions Social Network</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Visual Analysis Interface just the M value lower bound to filter out unsatisfied graph elements using the slide bar at the top left corner. Moreover, we support zoom in/out function to focus on part of the graph and users can view the sketch of the whole subgraph with a thumbnail at the bottom right corner.The left column displays the M values of the highlighted vertices, the corresponding tag cloud as well as the link information for the vertex representing officials of "Veterans Affairs". The tag cloud is a helpful tool that summarizes the most significant and diverse topics in their tweets. In this example, we select 30 representative tags out of 100 candidates, where "Veterans Affairs" may show great concern about the PTSD (Post Traumatic Stress Disorder) and discrimination problems while "womenshealthgov" mainly focuses on topics like health, breast cancer and baby. In order to know the source of these tags, hovering over specific tag in the tag cloud will trigger the source vertices being highlighted. If we point to the "insurance" tag, the Twitter actor "Barack Obama" will be highlighted indicating that he pays close attention to the insurance issue.</figDesc><graphic coords="10,53.76,48.79,502.10,254.33" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Comparison of Memory Algorithms computing times in each algorithm, i.e. how many times the algorithm calls the triangle counting operator. As in the first two rows in Table3, the triangle computing times for Epinions dataset in mNaive is about ten times of that in mImproved, which is close to the ratio of response time. Thus, the result again justifies our conclusion in Section 4.1 that mImproved outperforms mNaive mainly because it largely reduces the amount of triangle computations. More specifically, when k = 1, because we only remove edges not in any triangles without affecting other edges, mNaive can finish in two iterations (make sure that the graph is unchanged in the second iteration), and mImproved only needs one iteration. The response time for mNaive decreases when k equals to 5 since the number of triangle computations drops to 2, 439k, smaller than the number when k equals to 3 and 4. The triangle computing times for DBLP dataset in the last two rows in Table3have the similar pattern. For Twitter dataset, both algorithms need the number of triangle computations in the same level, which determines that their response time also close to each other. To sum up, mImproved is much faster than mNaive mainly because it reduces the number of triangle computations, especially when the graph is dense.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Comparison of Disk Algorithms In conclusion, dPartition trades off a lightweight graph partitioning for fast triangle computing in memory. The result verifies our claim in Section 4 that the partition based algorithm is I/O-efficient in practice.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Based on the above schema, we need to use index to support graph traversal since we cannot directly obtain the adjacent elements from the table. Example 3 shows a comparison between graph database and relational database.</figDesc><table><row><cell>1stEdge</cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="2">Vertex store</cell><cell>Edge store</cell></row><row><cell>1stNode</cell><cell>2ndNode</cell><cell cols="2">1stPrevEdge 1stNextEdge 2ndPrevEdge 2ndNextEdge</cell></row><row><cell cols="4">Figure 3: Graph Database Storage Layout</cell></row><row><cell cols="4">time cost for visiting adjacent elements in a graph in some</cell></row><row><cell cols="4">algorithmic fashion. This is actually a primitive operation</cell></row><row><cell cols="4">in graph-like queries or algorithms, naturally suitable for</cell></row><row><cell cols="4">shortest path finding, maximal connected subgraph problem</cell></row><row><cell cols="4">and graph's diameter computations and so on. Furthermore,</cell></row><row><cell cols="4">it can scale more naturally to large data sets as they do not</cell></row><row><cell cols="4">typically require expensive join operations.</cell></row><row><cell cols="4">Instead, the typical way to store graph data in relational</cell></row><row><cell cols="4">database is to create edge table with index on vertices:</cell></row><row><cell cols="3">CREATE TABLE Edge (</cell></row><row><cell></cell><cell cols="3">1stNode int NOT NULL,</cell></row><row><cell></cell><cell cols="3">2ndNode int NOT NULL</cell></row><row><cell>)</cell><cell></cell><cell></cell></row><row><cell cols="4">CREATE INDEX IndexOne ON Edge (1stNode)</cell></row><row><cell cols="4">CREATE INDEX IndexTwo ON Edge (2ndNode)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 :</head><label>1</label><figDesc>Layout Comparison</figDesc><table><row><cell></cell><cell cols="2">Hierarchy Stability</cell><cell>Cost</cell></row><row><cell>Orbital layout</cell><cell>Yes</cell><cell>Yes</cell><cell>Median</cell></row><row><cell>Radial layout</cell><cell>Yes</cell><cell>No</cell><cell>Low</cell></row><row><cell>Force directed layout</cell><cell>No</cell><cell>Yes</cell><cell>High</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 :</head><label>2</label><figDesc>Dataset Statistics</figDesc><table><row><cell>Dataset</cell><cell cols="2">Vertex Edges</cell><cell>Description</cell></row><row><cell>Epinions</cell><cell>75k</cell><cell>405k</cell><cell>Who-trusts-whom graph</cell></row><row><cell>Twitter</cell><cell>452k</cell><cell>813k</cell><cell>Who-follows-whom graph</cell></row><row><cell>DBLP</cell><cell>916k</cell><cell>3, 063k</cell><cell>Who-cites-whom graph</cell></row><row><cell>Flickr</cell><cell>1, 715k</cell><cell>22, 613k</cell><cell>Flickr contact graph</cell></row><row><cell cols="2">FriendFeed 653k</cell><cell>27, 811k</cell><cell>Friendship graph</cell></row><row><cell>Facebook</cell><cell cols="3">72, 661k 160, 975k Friendship graph</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3 :</head><label>3</label><figDesc>Triangle Computing Times</figDesc><table><row><cell></cell><cell>1</cell><cell>2</cell><cell>3</cell><cell>4</cell><cell>5</cell></row><row><cell>mNaive</cell><cell>717k</cell><cell>2,219k</cell><cell>2,840k</cell><cell>3,088k</cell><cell>2,439k</cell></row><row><cell>mImproved</cell><cell>130k</cell><cell>202k</cell><cell>249k</cell><cell>284k</cell><cell>311k</cell></row><row><cell>mNaive</cell><cell>1,097k</cell><cell>1,261k</cell><cell>1,324k</cell><cell>1,364k</cell><cell>1,391k</cell></row><row><cell>mImproved</cell><cell>873k</cell><cell>867k</cell><cell>836k</cell><cell>819k</cell><cell>817k</cell></row><row><cell>mNaive</cell><cell cols="5">5,950k 24,767k 22,950k 25,166k 21,085k</cell></row><row><cell>mImproved</cell><cell>288k</cell><cell>1,028k</cell><cell>1,921k</cell><cell>2,671k</cell><cell>3,240k</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 4 :</head><label>4</label><figDesc>Number of Partitions in Algorithm 4</figDesc><table><row><cell></cell><cell cols="3">Flickr FriendFeed Facebook</cell></row><row><cell>Size(GB)</cell><cell>1.57</cell><cell>1.92</cell><cell>11.6</cell></row><row><cell>p</cell><cell>2</cell><cell>2</cell><cell>12</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 5 :</head><label>5</label><figDesc></figDesc><table><row><cell cols="5">10k Times Triangle Computing Cost</cell></row><row><cell cols="2">Dataset</cell><cell cols="2">dStream dPartition</cell></row><row><cell>Flickr</cell><cell></cell><cell>122.1s</cell><cell>11.3s</cell></row><row><cell cols="2">FriendFeed</cell><cell>349.6s</cell><cell>33.5s</cell></row><row><cell cols="2">Facebook</cell><cell>12.9s</cell><cell>1.3s</cell></row><row><cell cols="5">Table 6: Percentages of Response Time</cell></row><row><cell></cell><cell cols="4">Flickr FriendFeed Facebook</cell></row><row><cell>Partitioning part</cell><cell cols="2">9.1%</cell><cell>10.5%</cell><cell>13.2%</cell></row><row><cell>Computing part</cell><cell cols="2">90.9%</cell><cell>89.5%</cell><cell>86.8%</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 7 :</head><label>7</label><figDesc>Average Response Time(in ms) distance threshold τ</figDesc><table><row><cell></cell><cell></cell><cell>Twitter</cell><cell></cell><cell></cell><cell>DBLP</cell><cell></cell></row><row><cell>Component</cell><cell>1</cell><cell>2</cell><cell>3</cell><cell>1</cell><cell>2</cell><cell>3</cell></row><row><cell>OnlineAlgo</cell><cell>1</cell><cell>32</cell><cell>563</cell><cell>2</cell><cell>16</cell><cell>498</cell></row><row><cell>Layout</cell><cell>2</cell><cell>6</cell><cell>138</cell><cell>2</cell><cell>5</cell><cell>108</cell></row><row><cell>TagCloud</cell><cell cols="6">1986 1726 1829 164 176 189</cell></row><row><cell>Avg edge num</cell><cell>2</cell><cell cols="2">368 9856</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>https://www.facebook.com</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>https://www.twitter.com</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>http://neo4j.org</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>http://www.sparsity-technologies.com/dex</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>http://www.orientechnologies.com</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>http://db128gb-b.ddns.comp.nus.edu.sg:8080/vis/demo</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_6"><p>http://snap.stanford.edu/</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">ACKNOWLEDGEMENT</head><p>The second author was supported in part by the NUS-ZJU Sensor-Enhanced Social Media (SeSaMe) Centre sponsored by NRF/IDMPO Singapore and also a FRC Grant Number R-252-000-486-112.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A graph-theoretic definition of a sociometric clique</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">D</forename><surname>Alba</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Mathematical Sociology</title>
		<imprint>
			<biblScope unit="page" from="113" to="126" />
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">K-core decomposition of internet graphs: hierarchies, self-similarity and measurement biases. Networks and Heterogeneous Media</title>
		<author>
			<persName><forename type="first">J</forename><surname>Alvarez-Hamelin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Dall'asta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Barrat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vespignani</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page">371</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">The role of social networks in information diffusion</title>
		<author>
			<persName><forename type="first">E</forename><surname>Bakshy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Rosenn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Marlow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Adamic</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>WWW</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">More flexible radial layout</title>
		<author>
			<persName><forename type="first">U</forename><surname>Brandes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Graph Algorithms Appl</title>
		<imprint>
			<biblScope unit="page" from="107" to="118" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Semantic distance in wordnet: An experimental, application-oriented evaluation of five measures</title>
		<author>
			<persName><forename type="first">A</forename><surname>Budanitsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Hirst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on WordNet and Other Lexical Resources</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Efficient core decomposition in massive networks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ozsu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="51" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Triangle listing in massive networks and its applications</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGKDD</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="672" to="680" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Visual reasoning about social networks using centrality sensitivities</title>
		<author>
			<persName><forename type="first">C</forename><surname>Correa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Crnovrsanin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TVCG</title>
		<imprint>
			<biblScope unit="page" from="1" to="15" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Approximating clique is almost np-complete</title>
		<author>
			<persName><forename type="first">U</forename><surname>Feige</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lovasz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Safra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Szegedy</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m">FOCS</title>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="2" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Graph drawing by force-directed placement. Software: Practice and experience</title>
		<author>
			<persName><forename type="first">T</forename><surname>Fruchterman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Reingold</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="1129" to="1164" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Predicting tie strength with social media</title>
		<author>
			<persName><forename type="first">E</forename><surname>Gilbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Karahalios</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CHI</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="211" to="220" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Grabowicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Ramasco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Moro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Pujol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">M</forename><surname>Eguluz</surname></persName>
		</author>
		<title level="m">Social features of online networks: the strength of weak ties in online social media. CoRR</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The strength of weak ties</title>
		<author>
			<persName><forename type="first">M</forename><surname>Granovetter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">American journal of sociology</title>
		<imprint>
			<biblScope unit="page" from="1360" to="1380" />
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Connectivity and generalized cliques in sociometric group structure</title>
		<author>
			<persName><forename type="first">R</forename><surname>Luce</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Psychometrika</title>
		<imprint>
			<biblScope unit="page" from="169" to="190" />
			<date type="published" when="1950">1950</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A method of matrix analysis of group structure</title>
		<author>
			<persName><forename type="first">R</forename><surname>Luce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Psychometrika</title>
		<imprint>
			<biblScope unit="page" from="95" to="116" />
			<date type="published" when="1949">1949</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The graph traversal pattern</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rodriguez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Neubauer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graph Data Management</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="29" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Network structure and minimum degree</title>
		<author>
			<persName><forename type="first">S</forename><surname>Seidman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Social networks</title>
		<imprint>
			<biblScope unit="page" from="269" to="287" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A graph-theoretic generalization of the clique concept</title>
		<author>
			<persName><forename type="first">S</forename><surname>Seidman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Foster</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Mathematical sociology</title>
		<imprint>
			<biblScope unit="page" from="139" to="154" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Streaming graph partitioning for large distributed graphs</title>
		<author>
			<persName><forename type="first">I</forename><surname>Stanton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kliot</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>WWW</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Arnetminer: extraction and mining of academic social networks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Su</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGKDD</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="990" to="998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Truss decomposition in massive networks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="812" to="823" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Csv: visualizing and mining cohesive subgraphs</title>
		<author>
			<persName><forename type="first">N</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Parthasarathy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="445" to="458" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">On triangulation-based dense neighborhood graph discovery</title>
		<author>
			<persName><forename type="first">N</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="58" to="68" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">The cohesiveness of blocks in social networks: Node connectivity and conditional density</title>
		<author>
			<persName><forename type="first">D</forename><surname>White</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Harary</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sociological Methodology</title>
		<imprint>
			<biblScope unit="page" from="305" to="359" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Extracting analyzing and visualizing triangle k-core motifs within networks</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Parthasarathy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
