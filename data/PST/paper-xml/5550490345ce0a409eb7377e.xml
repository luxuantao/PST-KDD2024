<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Iris: Monoids and Invariants as an Orthogonal Basis for Concurrent Reasoning</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ralf</forename><surname>Jung</surname></persName>
							<email>jung@mpi-sws.org</email>
						</author>
						<author>
							<persName><forename type="first">David</forename><surname>Swasey</surname></persName>
							<email>swasey@mpi-sws.org</email>
						</author>
						<author>
							<persName><forename type="first">Filip</forename><surname>Sieczkowski</surname></persName>
							<email>filips@cs.au.dk</email>
						</author>
						<author>
							<persName><forename type="first">Kasper</forename><surname>Svendsen</surname></persName>
							<email>ksvendsen@cs.au.dk</email>
						</author>
						<author>
							<persName><forename type="first">Aaron</forename><surname>Turon</surname></persName>
							<email>aturon@mozilla.com</email>
						</author>
						<author>
							<persName><forename type="first">Lars</forename><surname>Birkedal</surname></persName>
							<email>birkedal@cs.au.dk</email>
						</author>
						<author>
							<persName><forename type="first">Derek</forename><surname>Dreyer</surname></persName>
							<email>dreyer@mpi-sws.org</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">MPI-SWS &amp; Saarland University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Aarhus University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Aarhus University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">Mozilla Research</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution">Aarhus University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Iris: Monoids and Invariants as an Orthogonal Basis for Concurrent Reasoning</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">841A9E6BC0212B9AD1549FF40AE7154D</idno>
					<idno type="DOI">10.1145/2676726.2676980</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:18+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.3.1 [Programming Languages]: Formal Definitions and Theory</term>
					<term>D.3.3 [Programming Languages]: Language Constructs and Features</term>
					<term>F.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Programs Keywords Separation logic, fine-grained concurrency, atomicity, partial commutative monoids, invariants, higher-order logic, compositional verification</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present Iris, a concurrent separation logic with a simple premise: monoids and invariants are all you need. Partial commutative monoids enable us to express-and invariants enable us to enforceuser-defined protocols on shared state, which are at the conceptual core of most recent program logics for concurrency. Furthermore, through a novel extension of the concept of a view shift, Iris supports the encoding of logically atomic specifications, i.e., Hoare-style specs that permit the client of an operation to treat the operation essentially as if it were atomic, even if it is not.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Concurrency is fundamentally about shared state. This is true not only for shared-memory concurrency, where the state takes the form of a "heap" that threads may write to and read from, but also for message-passing concurrency, where the state takes the form of a "network" that threads may send to and receive from (or a sequence of "events" on which threads may synchronize). Thus, to scalably verify concurrent programs of any stripe, we need compositional methods for reasoning about shared state.</p><p>This goal has sparked a long line of work, especially in recent years, during which a synthesis of rely-guarantee reasoning <ref type="bibr" target="#b20">[21]</ref> and separation logic <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b27">28]</ref> has led to a series of increasingly advanced program logics for concurrency: RGSep <ref type="bibr" target="#b36">[37]</ref>, SAGL <ref type="bibr" target="#b12">[13]</ref>, LRG <ref type="bibr" target="#b11">[12]</ref>, CAP <ref type="bibr" target="#b9">[10]</ref>, HLRG <ref type="bibr" target="#b14">[15]</ref>, CaReSL <ref type="bibr" target="#b33">[34]</ref>, iCAP <ref type="bibr" target="#b32">[33]</ref>, FCSL <ref type="bibr" target="#b26">[27]</ref>,</p><p>TaDA <ref type="bibr" target="#b7">[8]</ref>, and others. In this paper, we present a logic called Iris that explains some of the complexities of these prior separation logics in terms of a simpler unifying foundation, while also supporting some new and powerful reasoning principles for concurrency.</p><p>Before we get to Iris, however, let us begin with a brief overview of some key problems that arise in reasoning compositionally about shared state, and how prior approaches have dealt with them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Invariants and their limitations</head><p>The canonical model of concurrency is sequential consistency <ref type="bibr" target="#b22">[23]</ref>: threads take turns interacting with the shared state (reading/writing, sending/receiving), with each turn lasting for one step of computation. <ref type="foot" target="#foot_0">1</ref> Although the semantics of sequentially consistent (SC) concurrency is simple to define, that does not mean it is easy to reason about. In particular, the key question is how to do thread-local reasoning-that is, verifying one thread at a time-even though other threads may interfere with (i.e., mutate) the shared state in between each step of computation in the thread we are verifying.</p><p>The invariant rule. The simplest (and oldest) way in which concurrent program logics account for such interference is via invariants <ref type="bibr" target="#b4">[5]</ref>. An invariant is a property that holds of some piece of shared state at all times: each thread accessing the state may assume the invariant holds before each step of its computation, but it must also ensure that it continues to hold after each step.</p><p>Formally, in concurrent separation logics, the invariant rule looks something like the following (omitting some important details that we explain later in §4):</p><formula xml:id="formula_0">{R * P } e {R * Q} e physically atomic R {P } e {Q}</formula><p>Here, the assertion R states the knowledge that there exists an invariant R governing some piece of shared state. Given this knowledge, the rule tells us that e may gain (exclusive) control of the shared state satisfying R, so long as it ensures that R continues to hold of it when it is finished executing. Note the crucial side condition that e be physically atomic, meaning that it takes exactly one step of computation. If e were not physically atomic, then another thread might access the shared state governed by R during e's execution, in which case it would not be safe for the rule to grant e exclusive control of the shared state throughout its execution.</p><p>The invariant rule is simple and elegant. Unfortunately, it also suffers from two major limitations, which a significant amount of follow-on work has attempted to overcome.</p><p>Limitation #1: The need for protocols. The first limitation pertains to the seemingly static nature of invariants. For the kinds of interference found in more sophisticated concurrent programs, one may require something a bit more "dynamic" than fixed invariants. It is often necessary, for instance, to have a way of expressing:</p><p>• Irreversibility: once a certain change to some shared state has occurred, it is irreversible-we cannot go back.</p><p>• Rights: certain changes to the shared state may only be made by privileged threads that have the "rights" to make those changes.</p><p>At first glance, at least, neither of these seems to be expressible in the limited language of invariants. As a consequence, many more recent logics provide some mechanism-such as rely-guarantee assertions <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b11">12]</ref>, regions <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b7">8]</ref>, STSs <ref type="bibr" target="#b33">[34]</ref>, and concurroids <ref type="bibr" target="#b26">[27]</ref>-to account for irreversibility and rights. All of these mechanisms are effectively different ways of describing protocols on shared state, which assert how the shared state is permitted to evolve over time.</p><p>Although the protocol mechanisms of modern logics are clearly useful, each logic bakes in its own somewhat different mechanism (and corresponding proof rules) as primitive, leading us to wonder: Is this really necessary? Might there be a simpler logical mechanism for legislating interference, from which more advanced mechanisms could be easily derived?</p><p>Limitation #2: The need for logical atomicity. The second limitation pertains to the side condition of the invariant rule requiring the operation e to be physically atomic (take exactly one step of computation). Obviously, this side condition makes it much more desirable (as a client) to program with physically atomic operations than with non-atomic ones. But there are many operations that appear to be atomic even though they take more than one step of computation, and for such operations the invariant rule is not applicable.</p><p>Specifically, it is often desirable to construct concurrent programs so that the interference on shared state is only observable within the limited scope of some mutable ADT (abstract data type). For instance, consider concurrent stacks. A sophisticated implementation <ref type="bibr" target="#b15">[16]</ref> may rely on fine-grained synchronization between threads in order to maximize parallelism, and thus proving it correct demands the use of invariants (or protocols) to account for the rampant interference. But this internal interference need not infect the verification of client code. In particular, the canonical notion of correctness for concurrent stacks is that it should appear to clients as if all stack operations take effect atomically (i.e., in some sequential order), which is typically formalized via linearizability <ref type="bibr" target="#b16">[17]</ref> or contextual refinement <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b33">34]</ref>. In this case, we say that the operations provided by the stack ADT are observably atomic.</p><p>Ideally, we would like to be able to treat observably atomic operations as if they were physically atomic. That way, clients of the stack ADT could establish invariants on the contents of the stack and then use the invariant rule when reasoning about push and pop operations. This can be done to some extent with contextual refinement (see the layered verification in <ref type="bibr" target="#b33">[34]</ref>), but it requires going outside the logic in order to connect up the verification of an ADT with that of its clients. Moreover, the refinement approach is only applicable in higher-level languages where the type system is strong enough to support hiding the internals of an ADT from its clients.</p><p>A more flexible approach, we argue, would be to internalize the notion of observable atomicity as a logical specification, so that both the proof obligation for establishing atomicity and the proof principle it provides to clients take the form of a single Hoarestyle specification written within the logic itself. We refer to such a Elimination stack (Appendix <ref type="bibr" target="#b0">[1]</ref>)</p><p>Mutable references (Figure <ref type="figure" target="#fig_9">18</ref>)</p><p>Channels with blocking receive (Figure <ref type="figure" target="#fig_1">12</ref>)</p><p>Local channel assertions (Figure <ref type="figure" target="#fig_0">11</ref>)</p><p>Asynchronous channels (Figure <ref type="figure">3</ref>) specification as being logically atomic. Intuitively, the key benefit of working with a logically atomic spec is to enable a version of the invariant rule without the side condition that e be physically atomic. This allows clients to treat operations providing such specs as if they were actually atomic, without requiring any extra-logical reasoning. Very recent work by da Rocha Pinto et al. on their logic TaDA <ref type="bibr" target="#b7">[8]</ref> supports precisely such a notion of logically atomic specs, together with a number of useful but nonstandard proof rules, but all of these are baked into the logic as primitive. Furthermore, TaDA is currently not able to reason about a significant class of sophisticated concurrent data structures that employ inter-thread cooperation (aka "helping") <ref type="bibr" target="#b34">[35,</ref><ref type="bibr" target="#b32">33]</ref>.</p><p>This begs the question: Might there be a way to define logical atomicity in terms of simpler logical primitives, and to derive the associated reasoning principles within the logic?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Iris: An orthogonal basis for concurrent reasoning</head><p>In this paper, we propose Iris, a concurrent separation logic based on a very simple premise: monoids and invariants are all you need.</p><p>Invariants we have already discussed at length. As for monoids: Partial commutative monoids (PCMs) are widely known to provide a generic model of resources-both physical resources (like the heap) and logical resources (like ghost state)-suitable for use in a separation logic. A number of modern logics involve PCMs either in the model of the logic <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b33">34]</ref> or as a feature in the logic itself <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b8">9]</ref>. What does not seem to be widely known, however, is that monoids and invariants form a kind of orthogonal basis for concurrent reasoning. In particular:</p><p>• Monoids enable us to express protocols on shared state.</p><p>• Invariants enable us to enforce protocols on shared state. These two mechanisms, put together, are unexpectedly powerful. In particular, using monoids and invariants, we show how to:</p><p>• Encode a variety of the advanced protocol mechanisms from modern logics ( §2 and §3).</p><p>• Derive proof rules that are taken as primitive proof rules in other modern logics ( §4 and §5).</p><p>• Encode TaDA-style logically atomic specs, and derive their most important associated proof rules ( §7).</p><p>• Go beyond TaDA and verify logically atomic specs for finegrained concurrent ADTs that employ helping ( §8).</p><p>A key technical novelty of Iris that facilitates the above contributions is an extension of the concept of view shift that has been proposed in recent work <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b32">33]</ref>. We explain this mechanism in §4. Furthermore, the soundness of Iris's primitive proof rules, which we discuss briefly in §6, has been fully mechanized in Coq <ref type="bibr" target="#b0">[1]</ref>. To demonstrate the effectiveness of abstraction and modular reasoning in Iris, we have applied it to a significant case study that builds a stack of abstractions, with each layer exporting only an abstract atomic specification to the layers above (Figure <ref type="figure" target="#fig_0">1</ref>). The bottom two layers are physically atomic, while the top three are logically atomic.</p><p>At the bottom of the stack we start with a large-footprint physically atomic specification of channels in a λ-calculus with asynchronous message passing ( §2). On top of that we first develop small-footprint specs ( §5.2), followed by channels with a logically atomic blocking receive operation ( §7.2). We then show that we can use channels (via a standard encoding <ref type="bibr" target="#b25">[26]</ref>) to implement a logically atomic spec for mutable references, which we finally use in the verification of a fine-grained elimination stack ADT ( §8). Put together, this constitutes a modular verification of elimination stacks running on a message-passing machine, performed completely within the Iris logic. Full details of the case study, as well as all other omitted technical details, appear in our technical appendix <ref type="bibr" target="#b0">[1]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Iris -Part I: Monoids</head><p>Iris is a higher-order separation logic parameterized by the language of program expressions that one wishes to reason about.</p><p>For the purpose of this paper, we instantiate the programming language to the one shown in Figure <ref type="figure" target="#fig_1">2</ref>, which provides primitive operations send(e, e) and tryrecv e for asynchronous (non-blocking) message passing via channels. We have chosen this language, rather than the usual heap-manipulating command language one finds in most separation-logic papers, in order to emphasize (1) that nothing about Iris is fundamentally tied to shared-memory concurrency, and (2) that heap-like abstractions can in fact be built up within the logic ( §8).</p><p>The logic includes the usual connectives and rules of higherorder separation assertion logic as generated by the grammar below.</p><formula xml:id="formula_1">Σ ::= 1 | Exp | Val | Prop | Σ × Σ | Σ → Σ | • • • t, P, ϕ ::= () | (t, t) | π1 t | π2 t | λx : Σ. t | ϕ t | t =Σ t | False | True | P ∧ P | P ∨ P | P ⇒ P | ∃x : Σ. P | ∀x : Σ. P | P * P | P - * P | • • •</formula><p>Here, Σ denotes the type of a term (written t, P , or ϕ among others) in the logic. Terms include language expressions and values, propositions, and products and function spaces over these. The</p><formula xml:id="formula_2">{ C } newch {c. C[c → ∅] } { C[c → M ] } send(c, m) {v. v = () ∧ C[c → M {m}] } { C[c → M {m}] } tryrecv c {v. v = Some(m) ∧ C[c → M ] } { C[c → ∅] } tryrecv c {v. v = None ∧ C[c → ∅] } Figure 3.</formula><p>Rules derived from the semantics of asynchronous channels (see Figure <ref type="figure" target="#fig_1">2</ref>). typing rules are standard and omitted (see the appendix <ref type="bibr" target="#b0">[1]</ref>). The judgment Γ | P Q says that for all instantiations of the variables in Γ, the propositions P entail Q. The contexts are often left implicit. In the following sections, we will gradually introduce and motivate key features of the logic along with their associated terms and types.</p><p>Physical state. To specify and reason about the behavior of programs, the logic features Hoare triples, written {P } e {v. Q}. Here v serves as a binder for the return value in postcondition Q.</p><p>The logic is parametric in the syntax and semantics of the underlying programming language. As such, the logic only features basic structural rules and lacks Hoare axioms for primitive expressions. However, the logic provides a canonical way of adding such axioms, by internalizing the reduction semantics of the underlying language as axioms about the entire physical machine state.</p><p>To express this, Iris features a physical state assertion, written ς , and a type State of physical states of the underlying language. For every term ς of type State, ς asserts exclusive ownership of the physical state, along with the knowledge that the physical state is exactly ς. Using this assertion we can directly translate the reduction relation defined in Figure <ref type="figure" target="#fig_1">2</ref> into the axioms given in Figure <ref type="figure">3</ref>. The physical state assertion only supports reasoning about the entire physical state; however, as we will see in §5.2, through the combination of monoids and invariants, it is possible to define more local reasoning principles.</p><p>Figure <ref type="figure" target="#fig_3">4</ref> summarizes the syntax and proof rules for physical states and selected structural Hoare rules. For now, ignore the in CSQ and the 2 in VSIMP. Combined, these rules simply yield the standard rule of consequence with implication. In the next section, we will explain how Iris generalizes that rule.</p><p>Ghost state. In addition to physical state assertions, Iris also supports assertions about ghost state (aka auxiliary state). Ghost state was originally proposed as a way to abstractly characterize some  knowledge about the history of a computation that is essential to verifying it <ref type="bibr" target="#b28">[29]</ref>. More generally, ghost state is useful for modularly describing a thread's knowledge about some shared state, as well as the rights it has to modify it <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b21">22]</ref>.</p><p>In many logics, ghost state takes the form of a ghost heap. However, as the name implies, ghost state is a purely logical construct, introduced solely for the purpose of verification, and thus there is no need to tie it to a particular language or machine model. Consequently, in Iris, following several recent logics <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b23">24]</ref>, we model ghost state as a partial commutative monoid (PCM), which is taken as a parameter of the logic. We call the elements of this PCM ghost resources, and we use the term "resources" to refer both to physical states and ghost resources. (Assertions in Iris represent predicates over both kinds of resources.)</p><p>We represent the partial commutative monoid as a (total) commutative monoid with a zero element. The term a • b is thus always well formed. Formally, we require a set |M | with two distinguished elements ⊥ (zero, undefined) and (unit) and an operation • (compose) such that the following properties hold: To reason about these monoid elements, the logic features a type Monoid of monoid elements and internalizes the composition operation as a function on Monoid. For each term a of type Monoid, the logic features a corresponding ghost assertion a , which asserts a = ⊥, along with ownership of an a fragment of the global ghost state. The global ghost state is the composition of all locally owned fragments. Ghost resources can thus be split and combined arbitrarily according to the chosen</p><formula xml:id="formula_3">a • b = b • a • a = a (a • b) • c = a • (b • c) ⊥ • a = ⊥ ⊥ = We call</formula><formula xml:id="formula_4">• operation: t • u ⇔ t * u .</formula><p>Since the ghost state is unrelated to the underlying physical state, we can update the current global ghost state arbitrarily at any time. We express updates of ghost state using view shifts. A view shift from P to Q, written P Q, asserts that it is possible to update the state from P to Q without changing the underlying physical state. The rule of consequence CSQ in Figure <ref type="figure" target="#fig_3">4</ref> thus allows view shifts (and not just implications) to be applied in pre-and postconditions.</p><p>If we own a fragment a of the global ghost state, we must ensure that any updates of the ghost state are consistent with any fragments potentially owned by the environment (e.g., other threads). The FPUPD rule in Figure <ref type="figure" target="#fig_6">5</ref> expresses that we can update a ghost fragment a to an element b ∈ B if this update is frame-preserving (a B);  that is, if it preserves an arbitrary composable frame a f :</p><formula xml:id="formula_5">a B 2∀a f . a # a f ⇒ ∃b ∈ B. b # a f a b a {b} where a # a f is notation for a • a f = ⊥.</formula><p>Note that the premise of rule FPUPD is merely a "fact": it does not express ownership of any state. To express such facts, the logic features an always modality, written 2P , for asserting that P holds and does not assert any ownership. Such assertions are called pure and can be freely duplicated (i.e., we have 2P ⇒ 2P * 2P and 2P ⇒ P ). View shifts and Hoare triples are other examples of pure assertions: the knowledge that a view shift or Hoare triple holds can thus be freely duplicated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Monoid constructions</head><p>The monoid representing ghost resources-together with the framepreserving update rules that it supports-can be seen as a way of expressing a protocol on logical state: given ownership of a particular monoid element, what does the owner know about the global ghost state and how are they permitted to update it? In this section, we present a number of useful monoid constructions (and their attendant frame-preserving update rules), representing different types of protocols. These protocols are not (yet) related to anything else; they just exist on their own. We will see in §5 how to enforce a protocol governing some other shared state.</p><p>The main novelty in this section is an encoding of State Transition Systems as a monoid. State Transistion Systems (STSs) provide a general and intuitive way of describing possible interference, expressed as a directed graph. The nodes of the graph represent possible ghost states, while edges describe how the ghost state may evolve. In §3.7, we show how to internalize this way of describing interference in Iris, through a general STS-as-monoid construction.</p><p>Recall that we represent PCMs as commutative monoids with zero. When defining monoid carriers, we leave this zero element ⊥ implicit. Furthermore, we will not explicitly define the cases of the composition function that involve or ⊥.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The exclusive monoid</head><p>The exclusive monoid over a set X supports two notions of ownership: exclusive ownership of an element x ∈ X vs. no ownership. The owner of an element x ∈ X thus has exact knowledge about the state. Formally, EX(X) is the monoid with carrier X { } and composition only defined when one of the operands is .</p><p>This gives rise to the following frame-preserving update, which captures the ownership intuition given above.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>x a</head><p>Any non-trivial element of the monoid can be updated to any element. In terms of separation-logic reasoning, the already described physical assertions ς behave like ghost assertions about an ex-clusive monoid over physical states ς (see the axiom in Figure <ref type="figure" target="#fig_3">4</ref>), except that of course one cannot use view shifts to update them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The fractional monoid</head><p>It is often desirable to share knowledge about some piece of ghost state (e.g., between different threads). A simple way to do that would be to reuse the carrier from EX(X), but let a • a = a. This captures the right idea of knowledge, but gives up any notion of ownership: since all elements are duplicable, no frame-preserving update is possible. Instead, we would like a way to keep track of how much the knowledge about ghost state has spread, so that, after gathering it all up again, we can do a frame-preserving update. This is achieved by the monoid FRAC(X) which has carrier</p><formula xml:id="formula_6">(0, 1] ∩ Q × X { } and composition (q, x) • (q , x ) (q + q , x) if q + q ≤ 1 and x = x</formula><p>With this monoid, we can do any frame-preserving update after collecting all the pieces:</p><p>(1, x) a</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">The product monoid</head><p>Using a product construction, we can combine any family of monoids (Mi)i∈I into a single monoid, while maintaining their individual reasoning principles (i.e., frame-preserving updates).</p><p>We define the carrier of the product monoid i∈I Mi to be the product of the monoid carriers i∈I |Mi| + . Composition is defined pointwise, if all of the constituent compositions are well defined (otherwise it is ⊥).</p><p>We would like to operate on the ith component of this product monoid just as we would act on the individual monoid Mi, and indeed the following frame-preserving update rule holds.</p><formula xml:id="formula_7">a M i B f [i → a] {f [i → b] | b ∈ B}</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Finite partial functions</head><p>A very common monoid in separation logics is the heap, modeled as a finite partial function from locations to values. We can obtain this monoid from the product monoid, by adding just one new piece. Given a countably infinite domain X and a monoid (codomain) M , define FPFUN(X, M ) to be the product monoid x∈X M , with the additional restriction of the carrier to elements f where the set dom(f ) {x | f (x) = M } is finite. This is well defined, since the set of these f contains the unit (which is the function mapping everything to M ) and is closed under composition. You can think of these f as finite partial functions to |M | + \ { }, where the elements outside their domains are mapped to .</p><p>Since the domain of f ∈ FPFUN(X, M ) is finite, an additional frame-preserving update becomes possible: a new element can be allocated.</p><formula xml:id="formula_8">FPFUNALLOC a ∈ |M | + f {f [x → a] | x / ∈ dom(f )}</formula><p>Note that x is bound by the set comprehension: in applying this update, one cannot choose which x one gets. Consider the monoid HEAP FPFUN(Loc, EX(Val)), where Loc is a set of locations. The carrier of this monoid consists of finite partial functions from locations to values, and composition of h and h is defined if all pointwise compositions are defined. From the composition on EX(Val), it follows that this is the case iff dom(h) and dom(h ) are disjoint. This is exactly the standard composition of heaps in separation logic! Now consider FHEAP(Loc) FPFUN(Loc, FRAC(Val)). This models a fractional heap, another commonly used monoid in separation logics. It can be used as ghost heap. We define the syntactic sugar x q → w to mean [x → (q, v)] if q ∈ (0, 1], and False other-wise. Then we can show:</p><formula xml:id="formula_9">∀v. True ∃x. x 1 → v (1)</formula><p>∀x, q1, q2, v, w. x</p><formula xml:id="formula_10">q 1 → v * x q 2 → w ⇔ x q 1 +q 2 → v * v = w (2) ∀x, q, v. x q → v ⇒ x q → v ∧ q ∈ (0, 1]<label>(3)</label></formula><p>∀x, v, w. x</p><formula xml:id="formula_11">1 → v x 1 → w<label>(4)</label></formula><p>We can use (1) to allocate a new ghost heap cell. Knowledge about the value and ownership of the location can be split and combined using (2). This is useful, in particular, when combining two pieces of a cell that were handed out earlier: one can learn that they point to the same value. Rule (3) says that fractional assertions have wellformed fractions. Having full ownership, the value in the ghost heap can be updated using (4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Named monoid instances and multiple monoids</head><p>In the previous section, we had to fix the global monoid to provide a particular derived construction. We may, however, want to use two different constructions in the same proof without requiring them to share their monoid. It is also useful to be able to obtain a fresh instance of a monoid at any time. As it turns out, all the tools we need to mitigate this are already at hand. Given a family of monoids (Mi)i∈I , we use a combination of the product and finite partial function monoids to define a global monoid M as follows:</p><formula xml:id="formula_12">M i∈I FPFUN(N, Mi)</formula><p>The product construction allows us to use a different monoid for independent parts of the proof, while the finite partial function construction provides named instances of these monoids. For the remainder of the article, we assume Iris has been instantiated with the monoid M given above, constructed from a family of monoids (Mi)i∈I , taken as a parameter. We write a : Mi</p><formula xml:id="formula_13">γ (or just a γ if Mi is clear from the context) for [i → [γ → a]</formula><p>] when a ∈ |Mi| + , and for False when a = ⊥M i . The ghost resource a : Mi γ thus asserts ownership of a part a of the instance named γ of monoid Mi in the current state. From the rules for ghost resources (Figure <ref type="figure" target="#fig_6">5</ref>) and the frame-preserving updates in §3.3 and §3.4, we can derive the following rules for allocating, updating, and combining named monoid ghost resources.</p><formula xml:id="formula_14">NEWGHOST a ∈ |Mi| + True ∃γ. a : Mi γ GHOSTUPD a M i B a : Mi γ ∃b∈B. b : Mi γ GHOSTEQ a : Mi γ * b : Mi γ ⇔ a • b : Mi γ 3.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">The authoritative monoid</head><p>A common pattern in concurrent reasoning is to put "someone" in charge of owning the global, authoritative state of some ghost resource, while "everyone else" owns fragments of that resource together with the knowledge that their fragments are all contained within the authoritative state. We can capture this pattern with the monoid AUTH(M ) where</p><formula xml:id="formula_15">|AUTH(M )| + (x, a) x ∈ |EX(|M | + )| + ∧ a ∈ |M | + ∧ (x = EX(|M | + ) ∨ a ≤M x)</formula><p>So the monoid consists of pairs, where the right component behaves just like M and the left component asserts exclusive ownership of a (non-zero) element of M . We impose the additional restriction that if an authoritative element is present, it must be an extension of the current fragment (a ≤M x, which is shorthand for ∃b. a</p><formula xml:id="formula_16">•M b = x).</formula><p>Composition is defined pointwise, and undefined if it is not in the carrier-i.e., if the combined fragment exceeds the combined authoritative element, or if two authoritative elements are present. Note that ( EX(|M | + ) , M ) is the unit and asserts no ownership or knowledge whatsoever, but ( M , M ) asserts that the authoritative element is M . We write • x to assert full ownership (x, M ) and • a to assert fragmental ownership ( EX(|M | + ) , a). For consistency, we write • x, • a for (x, a).</p><p>The frame-preserving update for this monoid says that, if we own the authoritative element and some fragment, then we can exchange that fragment for anything that's compatible with "the rest":</p><formula xml:id="formula_17">AUTHUPD M cancellative ∧ b # a f (• a • a f , • a) (• b • a f , • b)</formula><p>The rule requires that M be cancellative, which means</p><formula xml:id="formula_18">∀a f , a, b. a f • a = a f • b = ⊥ ⇒ a = b</formula><p>The monoids EX(X) and FRAC(X) are cancellative for any X, and monoid products preserve cancellativity.</p><p>Building on an example from §3.4, consider AUTH(HEAP). This monoid allows us to assert authoritative ownership of some complete heap • h as well as fragmental ownership of, e.g., individual memory locations as • → v. Since HEAP is cancellative, we obtain the following frame-preserving updates.</p><formula xml:id="formula_19">AHEAPUPD (• h • → v, • → v) (• h • → w, • → w) AHEAPADD ∈ dom(h) (• h) (• h • → v, • → v) Owning (• h, • → v), we can deduce that h = h • → v</formula><p>for some h by the definition of the carrier. Moreover, we can add a new location to AUTH(HEAP) at any point we wish, provided we can show that is not allocated in the current authoritative heap. This contrasts sharply with the frame-preserving update FPFUNALLOC for HEAP, where we can never be sure which location we get-we just know it will be fresh.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7">STSs with tokens</head><p>In their logic CaReSL <ref type="bibr" target="#b33">[34]</ref>, Turon et al. show how to usefully characterize the possible interference in a concurrent computation using State Transition Systems (STSs) with tokens <ref type="bibr" target="#b34">[35]</ref>. As suggested in §1.1, these mechanisms serve to express irreversibility of state change and the rights to make state changes. Concretely, an STS comes equipped with a set of states and transitions between them, as well as a set of tokens and a mapping from states to tokens. The transition relation enforces irreversibility by restricting which states are accessible from which other states. The tokens assigned to a particular state are "owned" by the STS, and can be picked up by any thread when transitioning to other states. Tokens must be conserved: when taking transitions, the (disjoint) union of the tokens owned locally and the tokens owned by the STS's current state cannot change. The tokens owned locally by a given thread thus serve to limit the rights of other threads to make certain transitions.</p><p>As an example, consider the possible states of a remote procedure call (RPC) between a client and a server. Initially, a call has been sent, and it is the server's turn to send back a reply. Only after that has happened can the client receive the reply and terminate.</p><p>The corresponding STS is given in Figure <ref type="figure">6</ref>. The second state, Rx, contains the token SRV. This means that the token is owned by the STS if we are at this state. To satisfy conservation of tokens, a transition from Tx to Rx can only be performed by giving up SRV. Owning SRV thus limits the possible interference from the environment: nobody but the owner of SRV can make this transition. Thus, saying we are at least in state Tx and we own token SRV amounts to saying we are exactly in state Tx.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Tx</head><p>Rx (SRV) Done (SRV) Figure <ref type="figure">6</ref>. STS for a remote procedure call. The monoid STSS for an STS (S, →) with token set TokSet and token assignment T : S → TokSet is defined in Figure <ref type="figure" target="#fig_7">7</ref>. It has three parts. First is the STS's current authoritative state s. Ownership and knowledge of this state can only ever be held by one partyhence we use an exclusive monoid to represent it. Even if we do not own the authoritative s, we can use the second part of the monoid, S, to describe what we know about the set of possible states s could be, e.g., that it is accessible from a certain state s0. Composition on these sets is simply intersection, and knowledge about possible states is freely duplicable (as S = S ∩ S). Finally, there is a set of locally owned tokens T : since we own them locally, we know that no other party owns them (composition is defined by ), and that the protocol does not own them either (∀s ∈ S. T (s) ∩ T = ∅).</p><formula xml:id="formula_20">(s, T ) → (s , T ) s → s ∧ T (s) T = T (s ) T frm(s, T ) (s, TokSet \ (T (s) T )) ↑(S, T ) s ∈ S | ∃s ∈ S. frm(s, T ) → * frm(s , T ) |STSS |      (s, S, T ) (s, S, T ) ∈ EX(S) × P(S) × P(T ) ∧ (s = ∨ s ∈ S) ∧ ↑(S, T ) = S ∧ S = ∅ ∧ ∀s ∈ S. T (s) ∩ T = ∅      (s, S, T ) • (s , S , T ) (s • s , S ∩ S , T T ) (where composition is undefined if the result is not in |STSS |)</formula><p>Regarding the second part of the monoid, not all possible sets of states S are sensible. Every such set we define to exist will be stable knowledge, meaning it cannot be invalidated by actions of the environment. We thus restrict the set of possible states to be closed under transitions by the environment, as formalized by the upwardclosure ↑ in Figure <ref type="figure" target="#fig_7">7</ref>: ↑(S, T ) = S. The figure also shows how to lift the relation → between states to a relation between state-token pairs: (s, T ) → (s , T ) says that, owning the tokens in T , one can move from s to s and end up with the tokens in T . In our RPC STS, for example, we have (Tx, {SRV}) → (Rx, ∅). On the other hand, (Tx, ∅) has no successor.</p><p>This definition gives rise to the following frame-preserving update. Owning the authoritative state and some tokens, we can make any transition that is justified by the tokens we own:</p><formula xml:id="formula_21">STSUPD (s, T ) → * (s , T ) (s, S, T ) (s , ↑({s }, T ), T )</formula><p>Note how we use ↑ to stabilize knowledge-having transitioned to s , we know that we are at least in s . While encoding STSs as monoids is interesting, we can only unleash its true power-recovering CaReSL's workhorse, the "island update" rule-once we have a way of enforcing STSs as protocols over the evolution of some shared state. For that, we need invariants.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Iris -Part II: Invariants</head><p>So far, Iris only supports reasoning about state that is owned by one thread or another. There is no mechanism yet for sharing state between threads. To support such sharing, we extend the logic now with invariants. Given a proposition P , the assertion P ι asserts the existence of a shared invariant named ι, which governs resources satisfying P . Since invariant assertions just assert the existence of a shared invariant, they are pure and thus freely duplicable:</p><formula xml:id="formula_22">P ι ⇔ 2 P ι .</formula><p>To access the shared resource they govern, invariants can be opened for the duration of a physically atomic expression. Opening an invariant grants temporary ownership of the shared resource. Once the invariant is reestablished (possibly after resources have been transferred in or out), it can be closed again. The following INV rule (which will turn out to be derivable from other rules) grants e ownership of shared resource R for the duration of its execution. For now, ignore the later modality , we will come back to it later. The rule (read backwards) says that, if you know that an invariant R with name ι exists, you can add its resources to the precondition. The verification of e can then freely use those resources as it wishes, but it must give back control of some resources satisfying R when it is done.</p><p>Masks. To ensure that each invariant is opened at most once, we annotate Hoare triples with an invariant mask. For the Hoare triple {P } e {v. Q}E we can assume the invariants in E hold prior to the execution and must reestablish them after each single physical step. We say that the invariants in E are enabled, which means that they hold on some portion of the shared (physical and logical) state. Here E is a term of type InvMask-the type of invariant masks, which are simply sets of invariant names.</p><p>Mask-changing view shifts. It is helpful to think about the INV rule as combining three separate steps of reasoning. First, note that, in the conclusion, ι is enabled, which means that it can be opened (disabled), and the resource satisfying R can be transferred from shared control to the local control of e. Second, this resource, together with P , is used to reason about e, which reestablishes R and some additional Q under the assumption that ι is disabled. Third, the invariant is closed (reenabled), which returns the resource satisfying R to shared control and restores the original invariant mask. For reasons that will become clear in §7, we find it useful to be able to reason about the opening and closing steps of this rule independently of the reasoning about e that goes on in between. Consequently, instead of taking INV as primitive, Iris employs a novel notion of view shifts that can open or close invariants. This is achieved by annotating view shifts with two sets of invariants: those that are enabled before and after the update. The view shift P E 1 E 2 Q expresses that it is possible to update the local state from P to Q without updating the physical state, where only the invariants in E1 and E2 are required to hold before and after the update, respectively. We write P E Q as syntactic sugar for P E E Q. The INVOPEN and INVCLOSE rules in Figure <ref type="figure" target="#fig_9">8</ref> express invariant opening and closing as mask-changing view shifts.</p><p>The rule of atomic consequence (ACSQ in Figure <ref type="figure">9</ref>) allows us to open invariants E for the duration of an expression e, provided we close them again afterwards. This rule can be composed with INVOPEN and INVCLOSE to obtain INV as a derived rule.</p><p>Note that ACSQ can only be sound for physically atomic expressions: After doing one step in e, another thread may be next to compute, and it may rely on invariants in E . We will see in §7 how to give specifications for functions that are not physically atomic, while still allowing opening invariants. Our more general notion of mask-changing view shifts will prove to be very helpful there.</p><p>View shift rules. View shifts permit a frame rule VSFRAME similar to the usual frame rule for Hoare triples. However, this rule serves VSTRANS</p><formula xml:id="formula_23">E2 ⊆ E1 ∪ E3 P E 1 E 2 Q Q E 2 E 3 R P E 1 E 3 R VSFRAME P E 1 E 2 Q P * R E 1 E E 2 E Q * R VSTIMELESS timeless(P ) P P ACSQ P E E E P {P } e {v. Q } E ∀v. Q E E E Q e phys. atomic {P } e {v. Q} E E Figure 9</formula><p>. Most important view shift rules (cf. our appendix <ref type="bibr" target="#b0">[1]</ref>). not only to frame resources around a view shift. It can also be used to frame invariants: if some invariant ι not covered by either mask of the view shift is known to be enabled, it remains so when the view shift is applied. Hence, view shifts may only affect invariants that they explicitly name in one of their masks. The same kind of framing is possible for Hoare triples; we refer the reader to the appendix <ref type="bibr" target="#b0">[1]</ref> for the full set of rules.</p><p>The view shift transitivity rule VSTRANS allows two view shifts to be combined, provided they agree on the invariants that are enabled between the two view shifts and that those invariants are not forgotten in the conclusion (E2 ⊆ E1 ∪ E3). This side condition is necessary to ensure soundness of the VSFRAME rule.</p><p>New invariants are created by transferring local resources satisfying the invariant to the shared state. As this involves a relabeling of resources (from "local" to "shared") but not any actual change to physical state, it can be expressed as a view shift. The NEWINV rule in Figure <ref type="figure" target="#fig_9">8</ref> allocates an invariant with a name ι, chosen from a set of possible names E. We require E to be infinite to make sure that there is some invariant name in there that is not taken already. And since we can pick the infinite set, we can reason that the different invariants we create have different names (by creating them with applications of NEWINV with disjoint E's). Disjointness of invariant names is important if we wish to apply INV in nested fashion, since we will have to prove that each invariant is opened at most once.</p><p>Later modality. Since any Iris assertion can serve as an invariant, one can define invariants that refer to other invariants or even themselves. This impredicativity introduces a potential circularity. Following iCAP <ref type="bibr" target="#b32">[33]</ref> and CaReSL <ref type="bibr" target="#b33">[34]</ref>, we use step-indexing to break this circularity, and internalize the notion of steps using a later modality. The assertion P expresses that P holds one step later. To ensure that invariants are well defined, the shared resource backing up P ι need only satisfy P . Thus, opening an invariant (INVOPEN) grants ownership of the shared resource one step later. Conversely, to close an invariant (INVCLOSE), it suffices to reestablish the shared resource one step later. If a resource P holds now, it also holds later:</p><formula xml:id="formula_24">P ⇒ P .</formula><p>With timeless propositions, things are simpler. Timeless propositions are not affected by , as expressed in rule VSTIMELESS. Examples of such propositions include physical state assertions and ghost assertions. Timelessness matters primarily when reasoning about propositions appearing in invariants: if an invariant is timeless, we can immediately view shift from P ι to P by opening the invariant to obtain P , then applying VSTIMELESS. The formal definition of timelessness can be found in the appendix <ref type="bibr" target="#b0">[1]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Invariant constructions</head><p>In combination with invariants, the monoid constructions presented in §3 let us encode powerful patterns for local reasoning about protocols on shared resources, including several that were developed in previous work <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b7">8]</ref>. To achieve this, an abstract protocol (as defined by a monoid) is tied to an interpretation of what the protocol is intended to guarantee about some shared resources, and the desired connection between the two is enforced with an invariant. It is then possible to derive Hoare triples for expressions that update the shared resources in accordance with the protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">STSs with interpretation</head><p>The whole point of the encoding of STSs from §3.7 was to be able to define protocols capable of governing some shared resource (e.g., the pointer structure implementing some concurrent mutable ADT, although in general the shared resource need not be physical). To support this functionality, we begin by extending the STSs from §3.7 with an interpretation ϕ(s) for each state s, which will say what property should hold of the underlying shared resource when the current (i.e., authoritative) state of the STS is s.</p><p>Let the STS (S, →), interpretation function ϕ : S → Prop, and instance name γ be given. We then define the following invariant:</p><formula xml:id="formula_25">STSInv(S, ϕ, γ) ∃s. (s, S, ∅) : STSS γ * ϕ(s)</formula><p>By creating this invariant, we enforce that the current authoritative state s of the STS instance γ is a shared resource, as is whatever shared resource backs up its interpretation ϕ(s), which is the state that multiple threads want to access concurrently. Returning to the RPC example from §3.7, let us assume knowledge of an STS invariant governing an instance γ of the RPC STS in Figure <ref type="figure">6</ref>. Suppose we own resources P and the STS resource (Rx, ∅) γ and want to transition the STS to state Done and establish Q. Our ghost resource represents knowledge that the STS is at least in state Rx (and ownership of no tokens). When we open the invariant, we learn the authoritative state, s ∈ {Rx, Done}, and take ownership of ϕ(s). (The knowledge we started with ensures s = Tx.) Since we want to transition to Done, our primary proof obligation is to show that, no matter what s is, we can update the resources on hand, P * ϕ(s), to ϕ(Done) * Q. Having proven that, we can then close the invariant and walk away with (Done, ∅)</p><p>γ * Q.</p><p>(The ghost represents our updated knowledge about the STS.) This general reasoning pattern is reflected in the derived rule STS in Figure <ref type="figure" target="#fig_11">10</ref>. If we ignore the tokens (for simplicity), the rule says: if we know the STS instance γ is at least in state s0 and want to update the STS, then it suffices to show that for any future state s of s0 we can, adding ϕ(s) to our precondition, establish ϕ(s ) in our postcondition (for some future state s of s).</p><p>The rule matches exactly CaReSL's island update rule <ref type="bibr" target="#b33">[34]</ref>. As with INV from the previous section, it is derived using ACSQ, and the proof follows the same decomposition: open invariant, reason with additional resources, close invariant. The only difference is an additional frame-preserving update using STSUPD right before closing the invariant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Authoritative monoids with interpretation</head><p>In this section, we implement the second layer of our stack (Figure <ref type="figure" target="#fig_0">1</ref>) using reasoning principles similar to those Krishnaswami et al. developed for "superficially substructural types" <ref type="bibr" target="#b21">[22]</ref>. We derive these principles by marrying an interpretation to the monoid AUTH(M ), much as we did for the monoid STSS in §5.1.</p><p>Consider the Hoare triples we obtained in Figure <ref type="figure">3</ref> to reason about language primitives. They all carry in their precondition a physical assertion, ς , about the global machine state, which can only ever be held by a single party. These are called large-footprint specifications, as opposed to the small-footprint specifications given in Figure <ref type="figure" target="#fig_0">11</ref>, which only mention the channel they operate on <ref type="bibr" target="#b30">[31]</ref>. We aim to derive these small-footprint specs. We will achieve this by putting ownership of the entire physical state into an invariant, so that it is shared by everybody. The invariant ties this physical state to a ghost resource so that fragments of the ghost resource (which can be split up among different threads) effectively control fragments of the physical state.</p><p>We can model the state of a network using the monoid NET FPFUN(Chan, EX(Bag)). This gives us an adequate level of sharing: we can make assertions about individual channels, without mentioning all the others. Next, we define the interpretation ϕ : |NET| + → Prop that we wish to hold for the authoritative state of this monoid, i.e., the composition of all fragments:</p><formula xml:id="formula_26">ϕ(C) C</formula><p>(Here, we implicitly coerce between the finite partial functions in |NET| + , and the ones comprising the possible physical states).</p><p>To tie the two together, we use an instance γ of AUTH(NET) and the following invariant.</p><formula xml:id="formula_27">ChanInv ∃C. • C : AUTH(NET) γ * ϕ ⊥ (C)</formula><p>We extend ϕ to ϕ ⊥ : |NET| → Prop by setting ϕ ⊥ (⊥) = False. Now assume that we own • c → M γ (which we will write c M ), and consider what we obtain upon opening the invariant ChanInv. While we cannot know which C witnesses the existential, we know from the definition of AUTH(NET) that c → M ≤ C, and thus C(c) = M . With our temporary ownership of the shared physical state C , we can justify operating on our channel c. All of this follows just from owning c M , which is a purely logical assertion that has nothing to do per se with the physical state-it is the invariant which lets us decide how we want to tie the two together. After the operation on c, we make us of the fact that we own both the authoritative state and the fragment governing c, so we know nobody else can hold any knowledge about this channel. Hence we can do a frame-preserving update synchronizing the ghost state with the new physical state, and closing the invariant.</p><p>In general, we may want to give an interpretation ϕ : |M | + → Prop to every (non-zero) element of some cancellative monoid M . We can do so with the invariant</p><formula xml:id="formula_28">AuthInv(M, ϕ, γ) ∃c. • c : AUTH(M ) γ * ϕ ⊥ (c)</formula><p>The reasoning pattern enabled by this construction is codified by rule AUTH in Figure <ref type="figure" target="#fig_11">10</ref>.</p><p>The rule says that if we know an invariant tying the authoritative part of γ to ϕ, and if we own the fragment a in γ, then we can gain access to the interpretation ϕ ⊥ (a • a f ) of the current authoritative state (where a f is everything owned by the environment). If, using the resources of the interpretation together with the P that we carried in, we can establish ϕ ⊥ (b • a f ) (which implies b # a f ) together with Q, then we are allowed to carry out whatever was left in Q, and update our ghost fragment to b. Like STS, this rule combines opening and closing an invariant with a frame-preserving update (except here the update uses AUTHUPD rather than STSUPD).</p><p>The triples given in Figure <ref type="figure" target="#fig_0">11</ref> are derived using AUTH. The mask E chan will contain the name of the invariant governing ChanInv. Note that we make crucial use of the VSTIMELESS rule here: After opening the invariant, we actually obtain C . But physical state assertions are timeless, so we can immediately view shift that to  </p><formula xml:id="formula_29">{True} newch {c. c ∅} {c M } send(c, m) {v. v = () ∧ c M {m}} E chan {c M } tryrecv c { v. (M = ∅ ∧ v = None ∧ c ∅) ∨ (∃m. m ∈ M ∧ v = Some(m) ∧ c M \ {m}) } E chan Figure 11</formula><p>. Derived rules for language primitives (see Figure <ref type="figure">3</ref> for the basic rules).</p><p>C and not bother with the . Furthermore, we obtain a single unified description of tryrecv by case distinction on M .</p><p>This pattern turns out to be very expressive. It is applicable whenever it is necessary to collect some state in a central place, and useful to spread ownership and knowledge about parts of this state. For example, in a heap-manipulating language, this pattern easily scales to provide fractional permissions. Also note that AUTH corresponds closely to Krishnaswami et al.'s "sharing rule" <ref type="bibr" target="#b21">[22]</ref>. This is yet another example of Iris's ability to derive powerful reasoning principles that are built fixed into prior logics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Semantics</head><p>The semantics of Iris is defined in the accompanying technical appendix and formalized in the accompanying Coq development <ref type="bibr" target="#b0">[1]</ref>. In this section we give a very brief overview of the model.</p><p>To model invariants, assertions in Iris are modeled relative to a world that describes the invariants allocated so far. Since invariants are themselves expressed as assertions, this introduces a circularity in the modeling of assertions and worlds. This is the standard type-world circularity that also arises in models of type systems with dynamic allocation and higher-order store <ref type="bibr" target="#b2">[3]</ref>. We use standard metric-based techniques to solve the circularity <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b5">6]</ref> and, in particular, Sieczkowski et al.'s library <ref type="bibr" target="#b31">[32]</ref> for solving such circularities in Coq. Crucially, the construction of the semantic domain of assertions-which allows us to model invariants-is parametric in the ghost state monoid. Invariants and monoids are thus also orthogonal semantically.</p><p>Iris's adequacy theorem expresses that if { ς } e {v. ϕ(v)} is derivable and e executes to a value v when started in physical state ς, then v satisfies ϕ. Here, ϕ(v) is a pure predicate, i.e., it describes a property of v and cannot mention resources or invariants. Formally:</p><formula xml:id="formula_30">Theorem 1 (Adequacy). If { ς } e {v. ϕ(v)} and ς; [i → e] → * ς ; [i → v] T , then ϕ(v).</formula><p>The T in the final state permits e to fork off other threads.</p><p>Soundness of the underlying higher-order separation logic, the rules in Figures <ref type="figure" target="#fig_9">4, 5, 8,</ref> and<ref type="figure">9</ref>, and the adequacy theorem have all been proven in Coq <ref type="bibr" target="#b0">[1]</ref>.</p><formula xml:id="formula_31">{True} newch {c. c ∅} M. c M send(c, m) v. c M {m} ∧ v = () E chan M. c M recv c m. c M \ {m} ∧ m ∈ M E chan</formula><p>where recv rec recv (c).</p><formula xml:id="formula_32">let v = tryrecv c in case v of None ⇒ recv c | Some(m) ⇒ m Figure 12.</formula><p>Logically atomic spec for channels with blocking recv.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Logical atomicity</head><p>How can triples like the ones in Figure <ref type="figure" target="#fig_0">11</ref> be used? Of course, one could just use them as normal Hoare triples, and establish c M before calling them. This, however, would effectively sequentialize access to the channel: every caller would have to prove that they exclusively own the channel in order to access it. Moreover, we often want several threads to be able to "race" for access to the resource. For example, consider the case where there is an invariant ιeven governing the channel, making sure it only ever contains even numbers:</p><formula xml:id="formula_33">∃M. c M ∧ ∀m ∈ M. m ∈ N ∧ m is even ιeven</formula><p>Since send is a physically atomic operation, we can use INV to gain access to the channel. We can open the invariant around the call to send, atomically observing the current state of the channel. If we are sending an even number, we can reestablish the invariant after send is done, and close it again. This is sound because no other thread can interfere with the physically atomic call to send. In this case, we say that we have a physically atomic triple for send. Now consider the blocking implementation of recv defined in Figure <ref type="figure" target="#fig_1">12</ref>. We would like to do the same kind of reasoning, e.g., to verify that recv c always returns an even number. But recv is not physically atomic, so INV does not apply. However, intuitively, recv behaves as if it were atomic: there is a single point in time (often called the linearization point) where the receiving action is (logically) committed, namely the instant when tryrecv succeeds. We ought to be able to exploit this, and call recv based on the channel assertion that is governed by ιeven-but if we only have a normal Hoare triple for recv, there is no way to do this. Our goal is thus to find a notion of a logically atomic triple that admits the reasoning principles given in Figure <ref type="figure" target="#fig_11">10</ref>, but is applicable to functions like recv. Now, note that all of our reasoning principles in Figure <ref type="figure" target="#fig_11">10</ref> were derived using ACSQ, which lets us compose physically atomic triples with view shifts that open and close invariants, whereas the corresponding rule for general expressions, CSQ, works only for view shifts with the same set of invariants enabled on both sides. It is thus justified to say that ACSQ logically captures the essence of what it means to be atomic. Hence, logically atomic triples should support the same kind of reasoning, and we will use this insight in determining how to define them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Logically atomic triples</head><p>In order to motivate the definition of logical atomic specifications, it is helpful to consider the needs of both a client using such a specification, and a module proving it.</p><p>Client perspective. What would it mean for recv to support a reasoning principle like ACSQ? Well, for example, we would like to have the following instantiation of ACSQ:</p><formula xml:id="formula_34">{c M } recv c {m. c M \ {m} ∧ m ∈ M } E chan P E chan E E chan c M ∀m. c M \ {m} ∧ m ∈ M E chan E chan E Q(m) {P } recv c {m. Q(m)} E chan E<label>(5)</label></formula><p>As a client of the module implementing recv , we would expect that module to prove the first premise. We would then give proofs for the two view shifts, and obtain the conclusion. Now, recv is not physically atomic, so ( <ref type="formula" target="#formula_34">5</ref>) is not sound. However, we can transform (5) into the "elimination form" of its first premise, i.e., into the statement that ACSQ can be applied to recv:</p><formula xml:id="formula_35">∀P, Q, E , M. (P E chan E E chan c M ) ∧ (∀m. c M \ {m} ∧ m ∈ M E chan E chan E Q(m)) ⇒ {P } recv c {v. Q(v)} E chan E (6)</formula><p>If this is the interface provided by the module, then we as client can do exactly the reasoning that (5) would allow us to do! The key observation is that such a statement can be made about any operation, be it physically atomic or not.</p><p>There are still some problems, though. Suppose we want to call recv on the channel c governed by the invariant ιeven. To do this, we have to choose some M and then prove that we can view shift from P to c M . However, we only learn the current M after opening the invariant (inside the proof of the the view shift), so we have no way to fix it a priori! Furthermore, we cannot prove the second view shift: at that point, we have forgotten that all messages in M are even numbers, so we cannot reestablish the invariant.</p><p>To solve this, we introduce a special treatment for M such that it only has to be fixed after opening the invariant. We will also bake in an application of FRAME, similar to how ACSQ was baked into <ref type="bibr" target="#b5">(6)</ref>. This leads us to the following:</p><formula xml:id="formula_36">∀P, Q, R, E . (P E chan E E chan ∃M. c M * R(M )) ∧ ∀M, m. c M \{m} ∧ m ∈ M * R(M ) E chan E chan E Q(M, m) ⇒ {P } recv c {m. ∃M. Q(M, m)} E chan E<label>(7)</label></formula><p>This is strong enough to be useful in our example. We choose:</p><formula xml:id="formula_37">P True Q( , m) m ∈ N ∧ m is even E {ιeven} R(M ) ∀m ∈ M. m ∈ N ∧ m is even</formula><p>The view shifts are then easy to show. Applying <ref type="bibr" target="#b6">(7)</ref>, this yields the desired triple, stating that recv c always returns an even number:</p><formula xml:id="formula_38">{True} recv c {m. m ∈ N ∧ m is even} E chan {ιeven}</formula><p>Note how our ability to prove the postcondition (that m is even) relies crucially on the fact that the frame R can depend on M .</p><p>Module perspective. Let us now switch roles, and consider the case of a module that wants to provide a specification like <ref type="bibr" target="#b6">(7)</ref>. This means we get to assume some arbitrary P , Q, R, E and the associated view shifts, and we have to prove an (ordinary) Hoare triple. Unlike in the normal case of proving a triple, we do not have access to the resource c M that we operate on. Instead, we own</p><formula xml:id="formula_39">x. α e v. β E M E EM # E ∧ 2    ∀P, Q, R, ER. x. P α | R(x), ER | v. β Q(x, v) E M E ⇒ {P } e {v. ∃x. Q(x, v)}    x. P α | R, ER | v. β Q E M E timeless(P ) ∧ ER # E ∪ EM ∧ (P -E M -E M -E R ∃x. α * R) ∧ (∀x, v. β * R -E M -E R -E M Q) Figure 13</formula><p>. Definition of logically atomic triples and atomic shifts.</p><p>some P , about which we only know that we can view shift to the desired resource. How can that be enough?</p><p>The key is this: at the "linearization point" (as explained above, the single step of execution where the operation "commits"), we will make use of the view shifts we have been given, together with rule ACSQ, to grant us temporary access to c M for that one step. Formally, at the linearization point, we will use the view shift from P to c M , which may open some islands E -hence, we call it the opening view shift. After operating on the resource, the only way to complete the proof is to use a corresponding closing view shift, of which we have only one, to view shift the updated resource back to Q. Since this marks the point in time where the atomic action commits, we also call this the committing view shift. Note that since we do not know anything about R, we have no choice but to use the same M with Q that we originally got from the opening view shift.</p><p>Sometimes, however, one has to deal with an operation that could be the linearization point, but it is not known up front (i.e., until reasoning about the postcondition) whether that will be the case. For this reason, it is necessary to be able to abort an atomic update. For example, recv internally uses tryrecv, which has two possible outcomes: either a message was received, in which case we can commit and are done, or the channel was empty, in which case we loop again. Thus, in the proof, we would be stuck if the only closing view shift we had at our disposal was the committing one. Hence we extend <ref type="bibr" target="#b6">(7)</ref> to assume an additional aborting view shift (as another closing view shift), which lets us go back to P if the commit did not happen. We arrive at the following, general pattern:</p><formula xml:id="formula_40">∀P, Q, R, E . (P E E E ∃x. α(x) * R(x)) ∧ (∀x, v. β(x, v) * R(x) E E E Q(x, v)) ⇒ {P } e {v. ∃x. Q(x, v)} E E<label>(8)</label></formula><p>Leaving aside the generalization of the predicates, the only difference from ( <ref type="formula" target="#formula_36">7</ref>) is that the first view shift is now bidirectional.</p><p>Formal definition. We define logically atomic triples in Figure <ref type="figure" target="#fig_0">13</ref>. Note that x is free in α, R, β and Q, while v is free in β and Q, and also note that E1 # E2 denotes disjointness of invariant masks. The definition differs from (8) only in a few technical details. First of all, we collect the antecedent of the implication (8) into its own syntactic sugar, which we call an atomic shift. An atomic triple is, roughly, an implication from an atomic shift to a normal Hoare triple that ties the pre-and postconditions of the triple and the shift together. We give this Hoare triple a fixed mask, . Since e will generally not be physically atomic, ACSQ cannot be applied, so a smaller mask would be of no use to a client.</p><p>The definition mentions three masks: E, EM , and ER. What are they? Well, it turns out that rather than talking about the invariants that the client may rely on being enabled (that would be E E in ( <ref type="formula" target="#formula_40">8</ref>)), it is often more convenient to talk about those invariants the client may not rely on. (In Figure <ref type="figure" target="#fig_0">13</ref>, we write -E to denote \ E.) LAATOMIC e phys. atomic ∀x. {α} e {v. β}</p><formula xml:id="formula_41">E M x. α e v. β E M LAHOARE x. α e v. β E M E ∀x. timeless(α) ∀x. {α} e {v. β} LAFRAME x. α e v. β E M E E # EM x. α * P e v. β * P E M E E LAEXIST x, y. α e v. β E M E x. ∃y. α e v. β E M E LACSQ ∀x. α E E E α x. α e v. β E M E ∀x, v. β E E E β E # EM x. α e v. β E M E E LAINV x. R * α e v. R * β E M E ι ∈ EM R ι x. α e v. β E M E {ι} LASTS x, s. s ∈ ↑({s0}, T ) * ϕ(s) * α e v. ∃s , T . (s, T ) → * (s , T ) * ϕ(s ) * β E M E ι ∈ EM STSInv(S, ϕ, γ) ι x. (s0, T ) : STSS γ * α e v. ∃s , T . (s , T ) : STSS γ * β E M E {ι}</formula><p>Figure <ref type="figure" target="#fig_3">14</ref>. Selected proof rules for logically atomic triples.</p><p>Context: The first two masks describe invariants that the module knows and cares about. We call EM the module mask: these are the invariants the module wants to be able to open up before calling client view shifts, so it is essential that the client not depend on these invariants at all. We call E the shared mask: these are the invariants that both the module and the client may depend on, and that therefore the client may not disable in its atomic shift. Both of these masks show up in logically atomic triples themselves.</p><formula xml:id="formula_42">M. P c M | R, ER | m. c M \ {m} ∧ m ∈ M Q(M, m) E chan ∅ {P } LAHOARE P -E chan Open ER c M * R(M ) -E chan ,E R let v = tryrecv c in c ∅ ∧ v = None ∧ M = ∅ ∨ ∃m. c M \ {m} ∧ m ∈ M ∧ v = Some(m) * R(M ) -E chan ,E R P * v = None ∨ ∃M, m. Q(M, m) * v = Some(m) -E chan {P * v = None ∨ ∃M, m. Q(M, m) * v = Some(m)} case v of None ⇒ {P } recv c {m. ∃M. Q(M, m)} | Some(m) ⇒ {∃M, v. Q(M, m)} m {m. ∃M. Q(M, m)}</formula><p>The third mask, ER, we call the client mask. This is a set of invariants that the client depends on and disables in its atomic shift. The module does not know or care about these invariants, and thus the client can choose ER arbitrarily, so long as it is disjoint from the first two masks.</p><p>The atomic shift imposes a (somewhat odd) restriction that P must be timeless, the reason for which is as follows. It is necessary, when opening an invariant, to surround it with the modality (see <ref type="bibr">INVOPEN)</ref>. But with logically atomic triples, it is often the case that invariants are opened in a nested fashion, i.e., the caller opens an invariant "around" the triple (using LAINV, Figure <ref type="figure" target="#fig_3">14</ref>), and the module itself opens another invariant at the linearization point. Ultimately, however, this all happens in an application of ACSQ around a single, physical step of the underlying language. So there is just one physical step available to strip off a single . This issue is solved by making P timeless, which means we can use VSTIMELESS to deal with the . In practice, this is not a serious restriction: The assertions we use are typically either timeless (like ghost resources) or pure (like invariant assertions). It is thus possible to move the pure assertions into the context (which means we can make them available anywhere), and to put the (timeless) resources into P .</p><p>Finally, note that atomic shifts and atomic triples (like view shifts and Hoare triples) are pure facts and can therefore be duplicated.</p><p>Derived rules. These definitions support the derived rules given in Figure <ref type="figure" target="#fig_3">14</ref>. Most important is the rule of consequence (LACSQ), which (like the original ACSQ) may be applied to view shifts that change masks. But with LACSQ, we can open invariants around expressions like recv that are not physically atomic! In other words, for any expression satisfying a logically atomic specification, we can apply well-established reasoning patterns (e.g., LAINV, LASTS) that, in most logics, work only for physically atomic expressions.</p><p>LAATOMIC shows that any physically atomic triple is also logically atomic. The rule LAEXIST permits us to bind a variable in the atomic shift. Unlike in the standard existential rule for Hoare triples (cf. our appendix <ref type="bibr" target="#b0">[1]</ref>), it would be unsound here to move y all the way out of the triple to a universal quantifier. Finally, LAHOARE can be used to convert logically atomic triples to normal ones. This is where the timeless restriction rears its (only slightly ugly) head.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Proof of blocking receive</head><p>As an example of working with logically atomic specifications, we are going to derive the already mentioned specification for recv:</p><formula xml:id="formula_43">∀c. M. c M recv c m. c M \ {m} ∧ m ∈ M E chan (9)</formula><p>First, we unfold the syntactic sugar for atomic triples. We thus get to assume some P , Q, R, ER such that the atomic shift shown at the top of Figure <ref type="figure" target="#fig_12">15</ref> holds.</p><p>The most important step of the proof (outlined in Figure <ref type="figure" target="#fig_12">15</ref>) is to establish the following triple:</p><formula xml:id="formula_44">P tryrecv c v. P * v = None ∨ ∃M, m. Q(M, m) * v = Some(m) E chan -E chan<label>(10)</label></formula><p>Intuitively, tryrecv either returns some message and completes the update (yielding Q), or it returns None and maintains P .</p><p>Once we have shown this, we can use LAHOARE to obtain a normal Hoare triple, and complete the proof with standard reasoning.</p><p>To show <ref type="bibr" target="#b9">(10)</ref> </p><formula xml:id="formula_45">∃M. c M * R(M ) tryrecv c v. c ∅ * R(∅) * v = None ∨ ∃M, m. c M \ {m} ∧ m ∈ M * R(M ) * v = Some(m) E chan -E chan ,E R<label>(11)</label></formula><p>Now we can apply LAEXIST to bind the M , followed by LACSQ (but without changing masks) to make use of this bound variable in the postcondition.</p><formula xml:id="formula_46">M. c M * R(M ) tryrecv c v. c ∅ ∧ v = None ∧ M = ∅ ∨ ∃m. c M \ {m} ∧ m ∈ M ∧ v = Some(m) * R(M ) E chan -E chan ,E R<label>(12)</label></formula><p>Note that after framing R(M ) with LAFRAME, this is exactly a logically atomic version of the spec for tryrecv given in Figure <ref type="figure" target="#fig_0">11</ref>. We are thus just a single application of LAATOMIC away from completing the proof. This also shows that our construction only requires a logically atomic spec for tryrecv-it does not depend on tryrecv being physically atomic.</p><p>Together with the triples for send and newch in Figure <ref type="figure" target="#fig_0">11</ref> and an application of LAATOMIC, this completes the proof of the channel specification from Figure <ref type="figure" target="#fig_1">12</ref>. With this example, we have illustrated (1) how to prove a logically atomic specification for recv, and (2) how the logically atomic specification of tryrecv supports reasoning principles normally reserved for physically atomic expressions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Putting logical atomicity to work</head><p>Now that we have proven a logically atomic spec for recv, we are in a position to state and prove a logically atomic spec for mutable references, using the well-known encoding <ref type="bibr" target="#b25">[26]</ref> in Figure <ref type="figure" target="#fig_14">16</ref>.</p><p>The idea behind this encoding is to represent a reference as a channel, on which a background "server" process listens for requests. Allocating a reference (ref e) involves allocating a fresh channel r (which represents the reference) and forking off a server process (srv r e). This server process will listen for messages from client processes that send it Get, Set, and Cas requests on r in order to perform reads and writes on the reference. Each such request includes a freshly generated reply channel d, along which the server sends the result of the requested operation.</p><p>By analogy with ML-style modules, we wish to show that this encoding is a "functor": 2 If e newch , e send , and erecv satisfy a logically atomic spec for channels, then ref, !, :=, and cas satisfy such a spec for references.</p><p>In Figures <ref type="figure" target="#fig_15">17</ref> and<ref type="figure" target="#fig_9">18</ref>, we define predicates ϕ chan and ϕ ref to represent the "signatures" of channels and references, in which the specific masks, expressions, and abstract predicates (that a particular implementation would define) are held abstract. The concrete predicate in Figure <ref type="figure" target="#fig_1">12</ref> satisfies these properties: we can implement ϕ chan . Note that we require the abstract predicates to be timeless so they can be used with LAHOARE.</p><p>In our appendix <ref type="bibr" target="#b0">[1]</ref>, we verify references as channels by proving ∀E chan , E ref , e newch , e send , erecv.</p><p>ϕ chan (E chan , e newch , e send , erecv) ∧</p><formula xml:id="formula_47">E chan ⊆ E ref ∧ infinite(E ref \ E chan ) E ref ϕ ref (E ref , ref, !, :=, cas)<label>(13)</label></formula><p>2 To our knowledge, the correctness of this encoding has not been specified and proven in this modular style before. Prior work <ref type="bibr" target="#b37">[38]</ref> has shown that an entire language with references can be faithfully translated into π-calculus.</p><p>Let expressions e newch , e send , and erecv be given. Define Since the reference operations use the channel interface, we require that all invariants needed by the channel operations are available in E ref . Furthermore, the reference module allocates an invariant in order to enforce a protocol on the ghost state underlying the abstract points-to predicate. Thus there need to be infinitely many invariant names it can use for its own purposes (E ref \E chan ) to satisfy NEWINV. This is also the reason that ( <ref type="formula" target="#formula_47">13</ref>) is a view shift rather than an implication. Note that we can completely abstract away from how the channel operations treat their invariant names, just as users of ϕ ref do not have to care about the fact that some of the invariants in E ref actually belong to the channel module. This shows that, with some small effort, proper abstraction is possible in Iris despite our use of global invariant masks at view shifts and Hoare triples.</p><p>In our proof of (13), the server thread for a reference is the one that actually commits all operations on it by performing logical updates on behalf of client requests. Hence, a client thread must transfer its atomic shift and precondition P to the server, which it does using the invariant of the reference module. (This transfer is made possible by the fact that invariants in Iris are impredicative, as explained at the end of §4.) The server can then apply the client's opening and committing view shift, sending Q back to the client. This is a particularly simple example of helping <ref type="bibr" target="#b34">[35,</ref><ref type="bibr" target="#b32">33]</ref>, a common phenomenon in fine-grained concurrent algorithms.</p><p>To make the proof work out, we had to change the code in Figure <ref type="figure" target="#fig_14">16</ref> slightly: at some places, we introduced skip to be able to strip off a . Since INVOPEN adds a to the invariant, this means we have to take a physical step if (1) the invariant is opened around the last operation a function is performing and (2) the function's postcondition does not specify a . The need to insert such skips is a known irritation in the world of step-indexed logics, but it is perfectly sound: adding skips does not affect the observable behavior of a program for the kind of observations we are considering.</p><p>As logically atomic triples are compatible with advanced techniques for reasoning with shared state (e.g., LASTS), it is perfectly straightforward to verify clients of the references-as-channels module against the abstract spec ϕ ref . To drive this point home, our appendix <ref type="bibr" target="#b0">[1]</ref> includes a verification of elimination stacks <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b34">35]</ref>, </p><formula xml:id="formula_48">ϕ chan (E chan , e newch , e send , erecv) 2∃(• •) ∈ Val × Bag → Prop. ∀c, M. timeless(c M ) ∧ ∀c, M, M . c M * c M ⇒ False ∧ {True} e newch {c. c ∅} ∧ ∀c, m. M. c M e send (c, m) x. c M {m} ∧ x = () E chan ∧ ∀c. M. c M erecv c m. c M \ {m} ∧ m ∈ M E chan</formula><formula xml:id="formula_49">ϕ ref (E ref , e ref , eget, eset, ecas) 2∃(• → •) ∈ Val × Val → Prop. ∀r, v. timeless(r → v) ∧ ∀r, v, w. r → v * r → w ⇒ False ∧ ∀v. {True} e ref v {r. r → v} ∧ ∀r. v. r → v eget r x. r → v ∧ x = v E ref ∧ ∀r, v. r → eset r v x. r → v ∧ x = () E ref ∧ ∀r, v1, v2. v. r → v ecas(r, v1, v2) b. b = true ∧ v = v1 ∧ r → v2 ∨ b = false ∧ v = v1 ∧ r → v E ref Figure 18</formula><p>. Specification for references.</p><p>a challenging example from the literature that employs helping in a more complex way than the references-as-channels module does. This verification is parameterized by an arbitrary implementation of references that is assumed to satisfy the logically atomic spec ϕ ref .</p><p>The code and proof closely follow those in the technical appendix of iCAP <ref type="bibr" target="#b32">[33]</ref>, the chief difference being that the iCAP proof depends on the reference operations being physically atomic, whereas ours does not. With this, we complete our stack of abstractions (Figure <ref type="figure" target="#fig_0">1</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Related work</head><p>In the introduction, we motivated Iris in relation to the state of the art in modular concurrency verification. Here, we give a few more detailed comparisons with the most closely related work.</p><p>Monoids. The centrality of partial commutative monoids dates back to the earliest models of separation logic, but only recently did a number of different models and logics begin to employ PCMs as a way of characterizing more fine-grained notions of interference <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b23">24]</ref>. The Views framework <ref type="bibr" target="#b8">[9]</ref>, in particular, enables the user to tie logical resources (represented as a PCM of the user's choice) to physical resources, according to a particular user-defined interpretation of logical resources as assertions about physical ones. In this way, Views, like Iris, supports protocol-based reasoning. However, Views is limited in that it effectively requires the user to bake in a fixed invariant tying logical to physical resources, with no logical support for layering further invariants on top of those logical resources. Iris, in contrast, provides built-in logical support for userdefined invariants over logical (ghost) resources; these are crucial, e.g., for enabling the verification of elimination stacks to impose its own invariants over the logical points-to assertions exported by the references-as-channels module one layer below. Furthermore, although we have not emphasized it in this paper, Iris invariants can be defined using higher-order, guarded recursive predicates akin to <ref type="bibr" target="#b32">[33]</ref> (unlike in Views, which only supported first-order logics).</p><p>View shifts were introduced by the Views framework as a specialization of the notion of "repartitioning" from CAP <ref type="bibr" target="#b9">[10]</ref>. A repartitioning describes an update of ghost state in terms of an update of the underlying physical state. A view shift in <ref type="bibr" target="#b8">[9]</ref> is thus simply a repartitioning that preserves the underlying physical state. CAP uses a two-level approach for reasoning about atomic expressions: one has to prove how the expression updates the physical state and separately prove a repartitioning that relates this back to the abstract level. In Iris, rule ACSQ offers more fine-grained control. Instead of going all the way to the concrete physical state, it is possible to open just as many levels of abstraction as are needed to justify the execution of the atomic expression.</p><p>Although we believe our monoid encoding of STSs with tokens is novel, most of the monoid constructions we used have been described previously. In particular, Dockins et al. <ref type="bibr" target="#b10">[11]</ref> treat monoids in an algebraic manner, as separation algebras (SA). They provide various generic building blocks like discrete SAs (equivalent to our exclusive monoid), products and sums, as well as a generalization of fractional monoids they call shares. To facilitate the treatment of sums, their monoids can have multiple units. We believe that our restriction to a single unit (and a single zero) can be lifted easily. Unlike SAs, our monoids do not generally have to be cancellative.</p><p>Invariants. The idea of relating logical resources with physical resources through invariants is also present in Pilkiewicz and Pottier's work on monotonic state <ref type="bibr" target="#b29">[30]</ref>, Jensen and Birkedal's work on "fictional separation logic" <ref type="bibr" target="#b19">[20]</ref>, and Krishnaswami et al.'s work on "superficially substructural types" <ref type="bibr" target="#b21">[22]</ref>. They are all restricted to a sequential setting. Pilkiewicz and Pottier's type-and-capability system uses "fates"-ghost variables whose values grow monotonically-to reason locally about lower bounds on ghost state. Using invariants, they lift these reasoning principles to monotonic physical state. Invariants and fates are orthogonal, independent principles. Iris supports similar reasoning principles for monotonic state, through an encoding of fates as STSs. Fictional separation logic (FSL) combines monoids with indirect Hoare triples specifying an interpretation map, which serves as invariant. Their approach is based on a syntactic translation into a standard separation logic and it is not clear how this approach extends to a concurrent setting. Superficially substructural types (SST) combines the approach of a type system with the more flexible forms of sharing supported by arbitrary monoids in FSL. As we have shown in §5.2 (rule AUTH), we can support reasoning in the style of SST's "sharing rule".</p><p>In the concurrent setting, previous work-e.g., on CaReSL <ref type="bibr" target="#b33">[34]</ref>, iCAP <ref type="bibr" target="#b32">[33]</ref>, and TaDA <ref type="bibr" target="#b7">[8]</ref>-has typically fixed a particular and very useful monoid construction. Iris can be used to encode the patterns of reasoning found in these logics, but with a simpler set of primitive mechanisms and proof rules (whose soundness we have verified in Coq <ref type="bibr" target="#b0">[1]</ref>). In addition, on a technical level, Iris is more general and expressive than these earlier logics. Like iCAP but unlike CaReSL and TaDA, Iris supports full higher-order logic and impredicative invariants, which are useful for giving modular specifications of libraries. Going beyond iCAP, Iris supports maskchanging view shifts; these are essential to our ability to encode TaDA-style logically atomic specs, as shown in §7. The notions of logical atomicity developed in TaDA and Iris are closely related, as is evident by the extra binder both had to introduce (the "funny" universal quantifier in TaDA, and the binder in the precondition of Iris's logically atomic triples), as well the similarity of the proof rules. At this point, Iris lacks the "private" pre-and postcondition of TaDA, but they would be easy to add to the syntactic sugar.</p><p>Like Iris, Cohen et al. <ref type="bibr" target="#b6">[7]</ref> strive to provide a minimal basis for concurrent reasoning, but theirs is based on a ghost heap and twostate invariants, whereas ours is based on arbitrary ghost PCMs and one-state invariants. The two approaches are optimizing for different goals. Our logic is substructural and supports more expressive-e.g., higher-order and logically atomic-specifications. Theirs is not, making it better suited to use with automated verification tools like SMT solvers. However, more work remains to be done to sort out the precise formal relationship between the two orthogonal bases.</p><p>Atomicity. Concerning the proving of logically atomic specs, TaDA is currently not able to reason about fine-grained data structures that employ inter-thread cooperation (aka "helping"). In Iris, this is possible thanks to the impredicative invariants (see the example in §8), similar to the approach taken in iCAP, which in turn was inspired by previous work of Jacobs and Piessens <ref type="bibr" target="#b18">[19]</ref> on VeriFast. To support impredicativity and thus also helping, our model of Iris is based on a solution to a recursive domain equation. That is avoided in VeriFast, which instead attempts to use a kind of Gödel encoding of predicates. However, according to Jacobs <ref type="bibr" target="#b17">[18]</ref>, the soundness and the generality of this encoding approach of VeriFast are unclear.</p><p>Liang and Feng <ref type="bibr" target="#b24">[25]</ref> propose another approach to observable atomicity, based on linearizability. Like CaReSL, they appeal to an extra-logical theorem when verifying clients against modules with observably atomic behavior. However, following ideas from Turon et al. <ref type="bibr" target="#b34">[35]</ref>, their logic also supports speculative execution of linearization points, which they use to establish soundness of the reasoning patterns developed by Vafeiadis in his thesis <ref type="bibr" target="#b35">[36]</ref>.</p><p>Further work remains to be done in order to extend Iris with support for such speculative reasoning <ref type="bibr" target="#b1">[2]</ref>. (The same goes for iCAP and TaDA as well.) Speculation is important in verifying fine-grained concurrent ADTs in which the ordering of a sequence of linearization points may not be known "in real time" but only after the corresponding operations have completed. Intuitively, speculation is challenging in Iris because, when we verify that a module satisfies a logically atomic spec, we perform updates to the state of the module using view shifts provided by the client, so the client can (in theory) observe the linearization points in real time.</p><p>To address this problem, a natural starting point would be to try to follow the model of speculation in Turon et al. <ref type="bibr" target="#b34">[35]</ref> and generalize Iris assertions from predicates over resources to predicates over sets of resources, but it is not yet clear how this would fit into our general approach to logical atomicity.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Case study: A stack of abstractions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. A language with asynchronous channels. (We denote the disjoint union f [x → y] by f [x → y].)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>SyntaxP</head><label></label><figDesc>::= • • • | P P | {P } e {ϕ} | ς | 2P Σ ::= • • • | State Physical state axioms ς * ς ⇒ False Structural Hoare rules FRAME {P } e {v. Q} {P * R} e {v. Q * R} RET {True} w {v. v = w} BIND {P } e {v. Q} ∀v. {Q} K[v] {w. R} {P } K[e] {w.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Physical state and selected structural rules.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>|M | the carrier of the monoid M = (|M |, ⊥, , •) and use |M | + to refer to the carrier without the zero element: |M | \ {⊥}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Syntax a, P::= • • • | a | a • a Σ ::= • • • | Monoid Ghost resource axioms a * b ⇔ a • b for 2∀a f . a # a f ⇒ ∃b ∈ B. b # a f</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Syntax and proof rules for ghost resources.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. Monoid encoding of STSs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>INV{</head><label></label><figDesc>R * P } e {v. R * Q} E e phys. atomic R ι {P } e {v. Q} E {ι}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>SyntaxPFigure 8 .</head><label>8</label><figDesc>Figure 8. Syntax and proof rules for invariants.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>STS ∀s ∈ ↑({s0}, T ). { ϕ(s) * P } e {v. ∃s , T . (s, T ) → * (s , T ) * ϕ(s ) * Q} E e phys. atomic STSInv(S, ϕ, γ) ι {(s 0, T ) γ * P } e {v. ∃s , T . (s , T ) γ * Q} E {ι} INV { R * P } e {v. R * Q} E e phys. atomic R ι {P } e {v. Q} E {ι} AUTH e phys. atomic M cancellative ∀a f . { ϕ ⊥ (a • a f ) * P } e {v. ∃b. ϕ ⊥ (b • a f ) * Q} E AuthInv(M, ϕ, γ) ι {a γ * P } e {v. ∃b. b γ * Q} E {ι}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 10 .</head><label>10</label><figDesc>Figure 10. Derived rules to reason about shared state.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 15 .</head><label>15</label><figDesc>Figure 15. Proof outline for recv.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>, we will have to use the atomic shift. It is clear what to do in the precondition: we are going to open the invariants ER with the opening view shift, obtaining c M . For the postcondition, we are going to use the committing view shift in case tryrecv succeeded, and the aborting view shift otherwise. Hence we have to show:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 16 .</head><label>16</label><figDesc>Figure 16. Implementing references as channels.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 17 .</head><label>17</label><figDesc>Figure 17. Specification for channels with blocking receive.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>There is much recent work on weaker models of concurrency, which are in many ways more realistic, but in this paper we focus on SC concurrency.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This research is supported in part by a Microsoft Research PhD Scholarship, and in part by the ModuRes Sapere Aude Advanced Grant from The Danish Council for Independent Research for the Natural Sciences (FNU). We thank Lisa Kohl for fruitful discussions during her internship at MPI-SWS, and we also thank the anonymous reviewers for extremely helpful and detailed feedback.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<ptr target="http://plv.mpi-sws.org/iris" />
		<title level="m">Appendix and Coq development</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The existence of refinement mappings</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">82</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="253" to="284" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">State-dependent representation independence</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ahmed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dreyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rossberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Solving reflexive domain equations in a category of complete metric spaces</title>
		<author>
			<persName><forename type="first">P</forename><surname>America</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rutten</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="343" to="375" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Proving assertions about parallel programs</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Ashcroft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="110" to="135" />
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Step-indexed Kripke models over recursive worlds</title>
		<author>
			<persName><forename type="first">L</forename><surname>Birkedal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Reus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Schwinghammer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Støvring</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Thamsborg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Invariants, modularity, and rights</title>
		<author>
			<persName><forename type="first">E</forename><surname>Cohen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PSI</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">TaDA: A logic for time and data abstraction</title>
		<author>
			<persName><forename type="first">P</forename><surname>Da Rocha Pinto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Dinsdale-Young</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Gardner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECOOP</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Views: Compositional reasoning for concurrent programs</title>
		<author>
			<persName><forename type="first">T</forename><surname>Dinsdale-Young</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Birkedal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Gardner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Parkinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Concurrent abstract predicates</title>
		<author>
			<persName><forename type="first">T</forename><surname>Dinsdale-Young</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dodds</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Gardner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Parkinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vafeiadis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECOOP</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A fresh look at separation algebras and share accounting</title>
		<author>
			<persName><forename type="first">R</forename><surname>Dockins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hobor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Appel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">APLAS</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Local rely-guarantee reasoning</title>
		<author>
			<persName><forename type="first">X</forename><surname>Feng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">On the relationship between concurrent separation logic and assume-guarantee reasoning</title>
		<author>
			<persName><forename type="first">X</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ferreira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Shao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESOP</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Blaming the client: On data refinement in the presence of pointers</title>
		<author>
			<persName><forename type="first">I</forename><surname>Filipović</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>O'hearn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Torp-Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FACS</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Reasoning about optimistic concurrency using a program logic for history</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CONCUR</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A scalable lock-free stack algorithm</title>
		<author>
			<persName><forename type="first">D</forename><surname>Hendler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Shavit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Yerushalmi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SPAA</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Linearizability: a correctness condition for concurrent objects</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Herlihy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Wing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TOPLAS</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="463" to="492" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">B</forename><surname>Jacobs</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note>Personal communication</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Expressive modular fine-grained concurrency specification</title>
		<author>
			<persName><forename type="first">B</forename><surname>Jacobs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Piessens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Fictional separation logic</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Birkedal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESOP</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Tentative steps toward a development method for interfering programs</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">B</forename><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TOPLAS</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="596" to="619" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Superficially substructural types</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">R</forename><surname>Krishnaswami</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Turon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dreyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Garg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICFP</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">How to make a multiprocessor computer that correctly executes multiprocess programs</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="690" to="691" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Subjective auxiliary state for coarsegrained concurrency</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ley-Wild</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Nanevski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Modular verification of linearizability with non-fixed linearization points</title>
		<author>
			<persName><forename type="first">H</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Feng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Communicating and Mobile Systems: the π-Calculus</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Communicating state transition systems for fine-grained concurrent resources</title>
		<author>
			<persName><forename type="first">A</forename><surname>Nanevski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ley-Wild</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Sergey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">A</forename><surname>Delbianco</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESOP</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Resources, concurrency, and local reasoning</title>
		<author>
			<persName><forename type="first">P</forename><surname>O'hearn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TCS</title>
		<imprint>
			<biblScope unit="volume">375</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="271" to="307" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Verifying properties of parallel programs: An axiomatic approach</title>
		<author>
			<persName><forename type="first">S</forename><surname>Owicki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gries</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CACM</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="279" to="285" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">The essence of monotonic state</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pilkiewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pottier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TLDI</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Separation logic: A logic for shared mutable data structures</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Reynolds</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LICS</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Modular reasoning about concurrent higher-order imperative programs: a Coq tutorial</title>
		<author>
			<persName><forename type="first">F</forename><surname>Sieczkowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bizjak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zakowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Birkedal</surname></persName>
		</author>
		<ptr target="http://users-cs.au.dk/birke/modures/tutorial/index.html" />
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Impredicative concurrent abstract predicates</title>
		<author>
			<persName><forename type="first">K</forename><surname>Svendsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Birkedal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESOP</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Unifying refinement and Hoarestyle reasoning in a logic for higher-order concurrency</title>
		<author>
			<persName><forename type="first">A</forename><surname>Turon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dreyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Birkedal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICFP</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Logical relations for fine-grained concurrency</title>
		<author>
			<persName><forename type="first">A</forename><surname>Turon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Thamsborg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ahmed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Birkedal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dreyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Modular fine-grained concurrency verification</title>
		<author>
			<persName><forename type="first">V</forename><surname>Vafeiadis</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
		<respStmt>
			<orgName>University of Cambridge</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">A marriage of rely/guarantee and separation logic</title>
		<author>
			<persName><forename type="first">V</forename><surname>Vafeiadis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Parkinson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CONCUR</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Objects in the pi-calculus</title>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Comput</title>
		<imprint>
			<biblScope unit="volume">116</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="253" to="271" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
