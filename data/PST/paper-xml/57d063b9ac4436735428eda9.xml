<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Ivy: Safety Verification by Interactive Generalization</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Oded</forename><surname>Padon</surname></persName>
							<email>odedp@mail.tau.ac.il</email>
							<affiliation key="aff0">
								<orgName type="institution">Tel Aviv University</orgName>
								<address>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Kenneth</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Microsoft Research</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mooly</forename><surname>Sagiv</surname></persName>
							<email>msagiv@post.tau.ac.il</email>
							<affiliation key="aff2">
								<orgName type="institution">Tel Aviv University</orgName>
								<address>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sharon</forename><surname>Shoham</surname></persName>
							<email>sharon.shoham@gmail.com</email>
							<affiliation key="aff3">
								<orgName type="institution">Tel Aviv University</orgName>
								<address>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Ivy: Safety Verification by Interactive Generalization</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">CEAAFFFC1D9A100E84320F82AA758AF0</idno>
					<idno type="DOI">10.1145/2908080.2908118</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:24+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.2.4 [Software/Program Verification]: Formal methods; F.3.1 [Specifying and Verifying and Reasoning about Programs]: Invariants Keywords safety verification</term>
					<term>invariant inference</term>
					<term>counterexamples to induction</term>
					<term>distributed systems</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Despite several decades of research, the problem of formal verification of infinite-state systems has resisted effective automation. We describe a system -Ivy -for interactively verifying safety of infinite-state systems. Ivy's key principle is that whenever verification fails, Ivy graphically displays a concrete counterexample to induction. The user then interactively guides generalization from this counterexample. This process continues until an inductive invariant is found. Ivy searches for universally quantified invariants, and uses a restricted modeling language. This ensures that all verification conditions can be checked algorithmically. All user interactions are performed using graphical models, easing the user's task. We describe our initial experience with verifying several distributed protocols.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Despite several decades of research, the problem of formal verification of systems with unboundedly many states has resisted effective automation. Although many techniques have been proposed, in practice they are either too narrow in scope or they make use of fragile heuristics that are highly sensitive to the encoding of the problem. In fact, most efforts towards verifying real-world systems use relatively little proof automation <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b19">20]</ref>. At best, they require a human user to annotate the system with an inductive invariant and use an automated decision procedure to check the resulting verification conditions.</p><p>Our hypothesis is that automated methods are difficult to apply in practice not primarily because they are unreliable, but rather because they are opaque. That is, they fail in ways that are difficult for a human user to understand and to remedy. A practical heuristic method, when it fails, should fail visibly, in the sense that the root cause of the failure is observable to the user, who can then provide an appropriate remedy. If this is true, the user can benefit from automated heuristics in the construction of the proof but does not reach a dead end in case heuristics fail.</p><p>Consider the problem of proving a safety property of a transition system. Most methods for this in one way or another construct and prove an inductive invariant. One way in which this process can fail is by failing to produce an inductive invariant. Typically, the root cause of this is failure to produce a useful generalization, resulting in an over-widening or divergence in an infinite sequence of abstraction refinements. Discovering this root cause in the complex chain of reasoning produced by the algorithm is often extremely difficult. To make such failures visible, we propose an interactive methodology that involves the user in the generalization process. We graphically visualize counterexamples to induction, and let the user guide the generalization with the help of automated procedures.</p><p>Another way the proof might fail is by failing to prove that the invariant is in fact inductive (for example, because of incompleteness of the prover). This can happen even when the invariant is provided manually. A typical root cause for this failure is that matching heuristics fail to produce a needed instantiation of a universal quantifier. Such failures of prover heuristics can be quite challenging for users to diagnose and correct (and in fact the instability of heuristic matching posed significant difficulties for the proof effort of <ref type="bibr" target="#b7">[8]</ref>). To eliminate this sort of invisible failure, we focus on universally quantified invariants and propose a restricted specification language that ensures that all verification conditions can be algorithmically checked.</p><p>We test these ideas by implementing them in a verification tool and applying it to a variety of infinite-state or parameterized systems. Although our correctness proofs were not obtained in a fully automated way, we find that automated generalization heuristics are still useful when applied with human guidance. Moreover, we find that the restrictions imposed by our specification language and by the use of universally quantified invariants are not an impediment to proving safety of parameterized distributed protocols.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Main Results</head><p>The contributions of this paper are:</p><p>• A new methodology for safety verification of infinite-state systems via an interactive search for universally quantified inductive invariants. Our methodology combines user guidance with automated reasoning. To ensure decidability of the automated reasoning, the methodology requires that checking inductiveness of a universal invariant is decidable; and that checking if a universal property holds after a bounded number of transitions is decidable. • A realization of our methodology using a new modeling language called RML (relational modeling language). RML is inspired by Alloy <ref type="bibr" target="#b15">[16]</ref>. It represents program states using sets of first order relations. RML also allows functions to be used in a restricted form. Updates to relations and functions are restricted to be quantifier free. Non-deterministic statements in the style of Boogie and Dafny are supported. RML is designed to guarantee that verification conditions for every loop-free program fragment are expressible in an extension of the Bernays-Schönfinkel-Ramsey fragment of first-order logic, also known as EPR <ref type="bibr" target="#b25">[26]</ref>, for which checking satisfiability is decidable. • A tool, called Ivy, that implements our new methodology for unbounded verification as a part of a verification framework. Ivy also allows model debugging via bounded verification. Using Ivy, we provide an initial evaluation of our methodology on some interesting distributed protocols modeled as RML programs. Ivy and the protocol models reported in this paper are publicly available <ref type="bibr" target="#b14">[15]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Overview: Interactive Verification with Ivy</head><p>This section provides an informal overview of the verification procedure in Ivy.</p><p>Ivy's design philosophy Ivy is inspired by proof assistants such as Isabelle/HOL <ref type="bibr" target="#b22">[23]</ref> and Coq <ref type="bibr" target="#b10">[11]</ref> which engage the user in the verification process. Ivy also builds on success of tools such as Z3 <ref type="bibr" target="#b3">[4]</ref> which can be very useful for bug finding, verification, and static analysis, and on automated invariant inference techniques such as <ref type="bibr" target="#b16">[17]</ref>. Ivy aims to balance between the predictability and visibility of proof assistants, and the automation of decision procedures and automated invariant inference techniques. Compared to fully automated techniques, Ivy adopts a different philosophy which permits visible failures at the cost of more manual work from the users. Compared to proof assistants, Ivy provides the user with automated assistance, solving well-defined decidable problems. To obtain this, we use a restricted modeling language called RML. RML is restricted in a way which guarantees that the tasks performed automatically solve decidable problems. For example, RML does not allow arithmetic operations. However, RML is Turing-complete, and can be used to model many interesting infinite-state systems.</p><p>For systems modeled by RML programs, Ivy provides a verification framework which allows model debugging via bounded verification, as well as unbounded verification using our new methodology for interactively constructing universally quantified inductive invariants.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">A Running Example: Leader Election</head><p>Figure <ref type="figure" target="#fig_9">1</ref> shows an RML program that models a standard protocol for leader election in a ring <ref type="bibr" target="#b2">[3]</ref>. This example is used as a running example in this section. The protocol assumes a ring of unbounded size. Every node has a unique ID with a total order on the IDs. Thus, electing a leader can be done by a decentralized extrema-finding protocol. The protocol works by sending messages in the ring in one direction. Every node sends its own ID to its neighbor. A node forwards messages that contain an ID higher than its own ID. When a node receives a message with its own ID, it declares itself as a leader.</p><p>The RML program uses sorted variables, relations and a single function symbol to model the state of the protocol which evolves over time. Ivy allows only "stratified" function symbols (e.g., if there is a function mapping sort s 1 to sort s 2 , there cannot be a function mapping s 2 to s 1 ). In the leader election example, IDs and nodes are modeled by sorts id and node, respectively. The function id maps each node to its ID. Since IDs are never mapped back to nodes by any function, id obeys the stratification requirement. The function id is uninterpreted, but the axiom unique ids (line 11), which appears in Figure <ref type="figure" target="#fig_12">2</ref>, constrains it to be injective (preventing two different nodes from having the same ID).</p><p>A binary relation le encodes a total order on IDs. The ring topology is represented by a ternary relation btw on nodes with suitable axiomatization that appears in Figure <ref type="figure" target="#fig_12">2</ref>. btw(x, y, z) holds for distinct elements x, y, z, if the shortest path in the ring from x to z goes through y (i.e., y is between x and z in the ring). le and btw are modeled as uninterpreted relations which are axiomatized in a sound and complete way using the universally quantified axioms le total order and ring topology (lines 12 and 13), respectively. The unary relation leader holds for nodes which are identified as leaders.  unique ids, le total order, ring topology, and next(a, b) denote a universally quantified formulas given in Figure <ref type="figure" target="#fig_12">2</ref>.</p><formula xml:id="formula_0">unique ids = ∀n 1 , n 2 . n 1 = n 2 → id(n 1 ) = id(n 2 ) le total order = ∀x. le(x, x) ∧ ∀x, y, z. le(x, y) ∧ le(y, z) → le(x, z) ∧ ∀x, y. le(x, y) ∧ le(y, x) → x = y ∧ ∀x, y. le(x, y) ∨ le(y, x) ring topology = ∀x, y, z. btw(x, y, z) → btw(y, z, x) ∧ ∀w, x, y, z. btw(w, x, y) ∧ btw(w, y, z) → btw(w, x, z) ∧ ∀w, x, y. btw(w, x, y) → ¬btw(w, y, x) ∧ ∀w, x, y. distinct(w, x, y) → btw(w, x, y) ∨ btw(w, y, x) next(a, b) = ∀x.x = a ∧ x = b → btw(a, b, x) Figure 2.</formula><p>Universally quantified formulas used in Figure <ref type="figure" target="#fig_9">1</ref>. unique ids expresses that no two nodes can have the same ID. le total order expresses that le is a reflexive total order. ring topology expresses that btw represents a ring. next(a, b) expresses the fact that b is the immediate successor of a in the ring defined by btw. In the initial state, no node is identified as a leader, and there are no pending messages. This is expressed by lines 14 and 15 respectively.</p><p>The core of the RML program is a non-deterministic loop. The loop starts by asserting that there is at most one leader (line 17). This assertion defines the safety property to verify. The loop body then contains a non-deterministic choice between two operations. The send operation (lines 19 to 23) sends a node's ID to its successor by inserting into the pnd relation. The receive operation (lines 25 to 38) handles an incoming message: it compares the ID in the message to the ID of the receiving node, and updates the leader and pnd relations according to the protocol.</p><p>Graphical visualization of states Ivy displays states of the protocol as graphs where the vertices represent elements, and edges represent relations and functions. As an example consider the state depicted in Figure <ref type="figure" target="#fig_4">7</ref> (a1). This state has two nodes and two IDs, represented by vertices of different shapes. Unary relations are displayed using vertex labels. For example, in Figure <ref type="figure" target="#fig_4">7</ref> (a1), node1 is labeled leader, and node2 is labeled ¬leader, denoting that the leader relation contains only node1. Binary relations such as le and pnd are displayed using directed edges. Higher-arity relations are displayed by means of their projections or derived relations. For example, the ternary relation btw is displayed by the derived binary relation next which captures a single ring edge. Functions such as id are displayed similarly to relations. The state depicted in Figure <ref type="figure" target="#fig_4">7</ref> (a1) contains two nodes, node1 and node2, such that the ID of node1 is lower (by le) than the ID of node2, the ID of node2 is pending at node2, and only node1 is contained in the leader relation. This state is clearly not reachable in the protocol, and the reason for displaying it will be explained in Section 2.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Bounded Verification</head><p>We aim for Ivy to be used by protocol designers to debug and verify their protocols. The first phase of the verification is debugging the protocol symbolically. Bounded model checking tools such as Alloy <ref type="bibr" target="#b15">[16]</ref> can be very effective here. However, the restrictions on RML permit Ivy to implement a more powerful bounded verification procedure which does not a priori bound the size of the input configuration. Instead, Ivy tests if any k transitions (loop iterations) can lead to an assertion violation. In our experience this phase is very effective for bug finding since often the protocol and/or the desired properties are wrong. For example, our initial modeling of the leader election protocol missed the unique ids axiom (line 11). Bounded verification with a bound of 4 transitions resulted in the error trace depicted in Figure <ref type="figure" target="#fig_1">3</ref>. In this trace, node1 identifies itself as a leader when it receives the message with the ID of node2 since they have the same ID (id1), and similarly for node2, leading to violation of the assertion. After adding the missing axiom, we ran Ivy with a bound of 10 transitions to debug the model, and did not get a counterexample trace. Notice again that Ivy does not restrict the size of the ring, only the number of loop iterations.</p><p>In our experience, protocols can be verified for about 10 transitions in a few minutes. Once bounded verification does not find more bugs, the user can prove unbounded correctness by searching for an inductive invariant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Interactive Search for Universally Quantified Inductive Invariants</head><p>The second phase of the verification is to find a universally quantified inductive invariant that proves that the system is correct for any number of transitions. This phase requires more user effort but enables ultimate safety verification. We say that an invariant I is inductive for an RML program if: (i) All initial states of the program satisfy I (initiation). (ii) Every state satisfying I also satisfies the desired safety properties (safety). (iii) I is closed under the transitions of the program, i.e., executing the loop body from any arbitrary program state satisfying I results in a new program state which also satisfies I (consecution).</p><p>If the user has a universally quantified inductive invariant in mind, Ivy can automatically check if it is indeed an inductive invariant. Due to the restrictions of RML, this check is guaranteed to terminate with either a proof showing that the invariant is inductive or a finite counterexample which can be depicted graphically and presented to the user. We refer to such a counterexample as a counterexample to induction (CTI). A CTI does not necessarily imply that the safety property is violated -only that I is not an inductive invariant. Coming up with inductive invariants for infinitestate systems is very difficult. Therefore, Ivy supports an interactive procedure for gradually obtaining an inductive invariant or deciding that the RML program or the safety property need to be revised.</p><p>The search for an inductive invariant starts with a (possibly empty) set of universally quantified conjectures, and advances based on CTIs according to the procedure described in Figure <ref type="figure" target="#fig_3">5</ref>. When a CTI is found it is displayed graphically, and the user has 3 options: 1) The user understands that there is a bug in the model or safety property, in which case the user revises the RML program and starts over in Figure <ref type="figure" target="#fig_1">3</ref>. Note that in this case, the user may choose to retain some conjectures reflecting gained knowledge of the expected protocol behavior. 2) The user understands that one of the conjectures is wrong, in which case the user removes it from the conjecture set, weakening the candidate invariant. 3) The user judges that the CTI is not reachable. This means that the invariant needs to be strengthened by adding a conjecture.</p><p>The new conjecture should eliminate the CTI, and should generalize from it. This is the most creative task, and our approach for it is explained below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Graphical visualization of conjectures</head><p>To allow the user to examine and modify possible conjectures, Ivy provides a graphical visualization of universally quantified conjectures. Such a conjecture asserts that some sub-configuration of the system is not present in any reachable state. That is, any state of the system that contains this sub-configuration is not reachable. Ivy graphically depicts such conjectures by displaying the forbidden sub-configuration. Sub-configurations are visualized similarly to the way states are displayed, but with a different semantics.</p><p>As an example consider the conjecture depicted in Figure <ref type="figure" target="#fig_4">7 (b</ref>). The visualization shows two nodes and their distinct IDs; node1 is shown to be a leader, while node2 is not a leader. Furthermore, the ID of node1 is lower (by le) than the ID of node2. Note that no pending messages appear (no pnd edges), and there is also no information about the topology (no next or btw edges). Viewed as a conjecture, this graph asserts that in any reachable state, there cannot be two nodes such that the node with the lower ID is a leader and the node with the higher ID is not a leader. Thus, this conjecture excludes infinitely many states with any number of nodes above 2 and any number of pending messages. It excludes all states that contain any two nodes such that the node with the lower ID is a leader and the node with the higher ID is not a leader.</p><p>Figure <ref type="figure" target="#fig_4">7</ref> (c) depicts an even stronger (more general) conjecture: unlike Figure <ref type="figure" target="#fig_4">7</ref> (b), node2 is not labeled with ¬leader nor with leader. This means that the conjecture in Figure <ref type="figure" target="#fig_4">7</ref> (c) excludes all the states that contain two nodes such that the node with the lower ID is a leader, regardless of whether the other node is a leader or not.</p><p>Obtaining helpful CTIs Since we rely on the user to guide the generalization, it is critical to display a CTI that is easy to understand and indicative of the proof failure. Therefore, Ivy searches for "minimal" CTIs. Find Minimal CTI automatically obtains a minimal CTI based on user provided minimization parameters. Examples include minimizing the number of elements, and minimizing certain relations (e.g. minimizing the pnd relation).</p><p>Interactive generalization from CTIs When a CTI represents an unreachable state, we should strengthen the invariant by adding a new conjecture to eliminate the CTI. One possible universally quantified conjecture is the one which excludes all states that contain the concrete CTI as a sub-configuration (formally, a substructure) <ref type="bibr" target="#b16">[17]</ref>. However, this conjecture may be too specific, as the CTI contains many features that are not relevant to the failure. This is where generalization is required, or otherwise we may end up in a diverging refinement loop, always strengthening the invariant with more conjectures that are all too specific.</p><formula xml:id="formula_1">C 0 ∀n 1 , n 2 . ¬ leader(n 1 ) ∧ leader(n 2 ) ∧ n 1 = n 2 C 1 ∀n 1 , n 2 . ¬ n 1 = n 2 ∧ leader(n 1 ) ∧ le(id(n 1 ), id(n 2 )) C 2 ∀n 1 , n 2 . ¬ n 1 = n 2 ∧ pnd(id(n 1 ), n 1 ) ∧ le(id(n 1 ), id(n 2 )) C 3 ∀n 1 , n 2 , n 3 . ¬ btw(n 1 , n 2 , n 3 ) ∧ pnd(id(n 2 ), n 1 )∧ le(id(n 2 ), id(n 3 ))</formula><p>Figure <ref type="figure">6</ref>. The conjectures found using Ivy for the leader election protocol. C 0 is the safety property, and the remaining conjectures (C 1 -C 3 ) were produced interactively.</p><formula xml:id="formula_2">C 0 ∧ C 1 ∧ C 2 ∧ C 3 is an inductive invariant for the protocol.</formula><p>This is also where Ivy benefits from user intuition beyond automatic tools, as it asks the user to guide generalization. Ivy presents the user with a concrete CTI, and lets the user eliminate some of the features of the CTI that the user judges to be irrelevant. This already defines a generalization of the CTI that excludes more states.</p><p>Next, the BMC + Auto Generalize procedure, applies bounded verification (with a user-specified bound) to check the user's suggestion and generalize further. If the test fails, it means that the user's generalized conjecture is violated in a reachable state, and a concrete counterexample trace is displayed to let the user diagnose the problem. If the test succeeds (i.e., the bounded verification formula is unsatisfiable), Ivy automatically suggests a stronger generalization, based on a minimal UNSAT core. The user then decides whether to accept the suggested conjecture and add it to the invariant, or to change the parameters in order to obtain a different suggestion.</p><p>Next, we walk through this process for the leader election protocol, demonstrating the different stages, until we obtain an inductive invariant that proves the protocol's safety.</p><p>Illustration using the leader election protocol Figure <ref type="figure">6</ref> summarizes the 3 iterations Ivy required to find an inductive invariant for the leader election protocol. The initial set of conjectures contains only C 0 , which is derived from the assertion in Figure <ref type="figure" target="#fig_9">1</ref> line 17.</p><p>In the first iteration, since C 0 alone is not inductive, Ivy applies Find Minimal CTI. This results in the CTI depicted in Figure <ref type="figure" target="#fig_4">7</ref> (a1). Figure <ref type="figure" target="#fig_4">7</ref> (a2) depicts a successor state of (a1) reached after node2 receives the pending message with its ID. The state (a1) satisfies C 0 , whereas (a2) violates it, making (a1) a CTI. After examining this CTI, the user judges that the state (a1) is unreachable, with the intuitive explanation that node1 identifies itself as a leader despite the fact that node2 has a higher ID. Thus, the user generalizes away the irrelevant information, which includes pnd and the ring topology, resulting in the generalization depicted in Figure <ref type="figure" target="#fig_4">7 (b)</ref>.</p><p>Next, the user applies BMC + Auto Generalize with bound 3 to this generalization. The BMC test succeeds, and Ivy suggests the generalization in Figure <ref type="figure" target="#fig_4">7 (c)</ref>, where the information that node2 is not a leader is also abstracted away. The user approves this generalization, which corresponds to conjecture C 1 shown in Figure <ref type="figure">6</ref>, so C 1 is added to the set of conjectures.</p><p>If the user had used bound 2 instead of 3 when applying BMC + Auto Generalize, then Ivy would have suggested a stronger generalization that also abstracts the ID information, and states that if there are two distinct nodes, none of them can be a leader. This conjecture is bogus, but it is true for up to 2 loop iterations (since with 2 nodes, a node can only become a leader after a send action followed by 2 receive actions). It is therefore the role of the user to select and adjust the bound for automatic generalization, and to identify bogus generalizations when they are encountered.</p><p>After adding the correct conjecture C 1 , Ivy displays the CTI depicted in Figure <ref type="figure" target="#fig_5">8</ref> (a1) with its successor state (a2). Note that (a2) does not violate the safety property, but it violates C 1 that was added to the invariant, since a node with a non-maximal ID becomes a leader. The user examines (a1) and concludes that it is not reachable, since it has a pending message to node1 with its own ID, despite the fact that node2 has a higher ID. Here, the user again realizes that the ring topology is irrelevant and abstracts it away. The user also abstracts away the leader information. On the other hand, the user keeps the pnd information, in accordance with the intuitive explanation of why the CTI is not reachable. The resulting user-defined generalization is depicted in Figure <ref type="figure" target="#fig_5">8 (b)</ref>. BMC + Auto Generalize with bound 3 validates this generalization for 3 transitions, but does not manage to generalize any further. Thus, the generalization is converted to C 2 in Figure <ref type="figure">6</ref> which is added to the invariant, and the process continues.</p><p>Finally, Figure <ref type="figure" target="#fig_6">9</ref> (a1) and (a2) depicts a CTI that leads to a violation of C 2 . This CTI contains three nodes, with a pending message that appears to bypass a node with a higher ID. This time, the user does not abstract away the topology since it is critical to the reason the CTI is not reachable. The user only abstracts the leader information, which leads to the generalization depicted in Figure <ref type="figure" target="#fig_6">9 (b)</ref>. Note that in the generalized conjecture we no longer consider the next relation, but rather the btw relation. This expresses the fact that, as opposed to the concrete CTI, the conjecture generalizes from the specific topology of a ring with exactly 3 nodes, to a ring that contains it as a sub-configuration, i.e. a ring with at least 3 nodes that are not necessarily immediate neighbors of each other. We do require that the three nodes are ordered in such a way that node2 is between node1 and node2 in the ring (equivalently, node3 is between node2 and node1).</p><p>Applying BMC + Auto Generalize with a bound of 3 to Figure <ref type="figure" target="#fig_6">9</ref> (b) confirms this conjecture, and automatically abstracts away the ID of node1, which results in the conjecture depicted in Figure <ref type="figure" target="#fig_6">9</ref> (c), which corresponds to C 3 in Figure <ref type="figure">6</ref>. The user adds this conjecture to the invariant. After adding C 3 , Ivy reports that I = C 0 ∧ C 1 ∧ C 2 ∧ C 3 is an inductive invariant for the leader election protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">RML: Relational Modeling Language with Effectively Propositional Reasoning</head><p>In this section we define a simple modeling language, called Relational Modeling Language (RML). RML is Turingcomplete, and suitable for modeling infinite-state systems. RML is restricted in a way that ensures that checking verification conditions for RML programs is decidable, which enables our interactive methodology for safety verification.</p><p>We start with RML's syntax and informal semantics. We then define a weakest precondition operator for RML, which is used in the verification conditions. RML further restricts programs to consist of a single nondeterministic loop, with possible initialization and finalization commands. Thus, RML commands are loop-free. While this restriction simplifies the presentation of our approach, note that it does not reduce RML's expressive power as nested loops can always be converted to a flat loop.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">RML Syntax and Informal Semantics</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Declarations and states</head><p>The declarations of an RML program define a set of sorts S, a set of sorted relations R, a set of sorted functions F, a set of sorted program variables V, and a set of axioms A in the form of (closed) ∃ * ∀ * -formulas.</p><p>A state of an RML program associates a finite set of elements (domain) with each sort, and defines valuations (interpretations) for all relations, functions, and variables, such that all the axioms are satisfied. The values of relations and functions can be viewed as finite tables (or finite sets of tuples). The values of program variables, relations and functions are all mutable by the program.</p><p>Note that while every program state can be described by finite tables, there is no bound on the size of the tables, and thus an RML program has infinitely many states and can model infinite state systems.</p><p>For example, a network with an unbounded number of nodes can be modeled with sorts for nodes and messages, and a relation that keeps track of pending messages in the network. Functions can be used to relate each node to a unique ID and other node specific data, and to relate each message to its source, destination, and other message fields. While in any given state the number of nodes and the number of pending messages is finite, there is no bound on the possible number of nodes or pending messages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Function stratification</head><p>The set of functions F is required to be stratified. This means that the sorts of the program can be ordered by a total order &lt; such that if F contains a function f : s 1 , . . . , s n → s then s &lt; s i for every 1 ≤ i ≤ n. For example, if F contains a function from rml ::= decls ; cmd ; while * do cmd ; cmd decls :: v denotes an identifier of a zero-arity function. x denotes a vector of logical variables. t (x) denotes a term with free logical variables x and ϕ QF (x) denotes a quantifier-free formula with free logical variables x. ϕ EA denotes a closed formula with quantifier prefix ∃ * ∀ * . The syntax of terms and formulas is given in Figure <ref type="figure" target="#fig_7">11</ref>. messages to nodes (e.g. the message source), then F cannot contain a function from nodes to messages. This restriction on functions is essential for the decidability properties of RML (see Section 3.3).</p><formula xml:id="formula_3">= | decls ; decls | sort s | relation r : s | function f : s → s | variable v : s | axiom ϕ EA cmd ::= skip do nothing | abort terminate abnormally | r (x) := ϕ QF (x) quantifier-free update of relation r | f (x) := t (x) update of function f to term t (x) | v := * havoc of variable v | assume ϕ EA assume ∃ * ∀ * formula holds | cmd ; cmd sequential composition | cmd | cmd non-deterministic choice</formula><p>Commands Each command investigates and potentially updates the state of the program. The semantics of skip and abort are standard. The command r(x 1 , . . . , x n ) := ϕ QF (x 1 , . . . , x n ) is used to update the n-ary relation r to the set of all n-tuples that satisfy the quantifier-free formula ϕ QF . For example, r(x 1 , x 2 ) := (x 1 = x 2 ) updates the binary relation r to the identity relation; r(x 1 , x 2 ) := r(x 2 , x 1 ) updates r to its inverse relation; r 1 (x) := r 2 (x, v) updates r 1 to the set of all elements that are related by r 2 to the current value (interpretation) of program variable v.</p><p>The command f(x 1 , . . . , x n ) := t(x 1 , . . . , x n ) is used to update the n-ary function f to match every n-tuple of elements to the element given by the term t. Note that while relations are updated to quantifier-free formulas, functions are updated to terms. For example, f(x) := x updates the function f to the identity function; f(x 1 , x 2 ) := f(x 2 , x 1 ) updates f to its transpose; f(x) := ite(r(x), x, f(x)) updates f to be the identity function for all elements in r, and leaves it unchanged for all elements not in r.</p><p>The havoc command v := * performs a non-deterministic assignment to v. The assume command is used to restrict the executions of the program to those that satisfy the given</p><formula xml:id="formula_4">t ::= x logical variable x | v program variable v | f ( t , . . . , t ) application of function f | ite (ϕ QF , t , t ) if-then-else term ϕ QF ::= r ( t , . . . , t ) membership in relation r | t = t equality between terms | ϕ QF ∧ ϕ QF | ϕ QF ∨ ϕ QF | ¬ ϕ QF ϕ AF ::= ∃x 1 , . . . , x n ϕ QF | ∀x 1 , . . . , x n ϕ QF | ϕ AF ∧ ϕ AF | ϕ AF ∨ ϕ AF | ¬ ϕ AF ϕ EA ::= ∃x 1 , . . . , x n ∀x n+1 , . . . , x n+m ϕ QF ϕ AE ::= ∀x 1 , . . . , x n ∃x n+1 , . . . , x n+m ϕ QF Figure 11</formula><p>. Syntax of terms and formulas. Formulas in ϕ AF (alternation-free formulas), ϕ EA (∃ * ∀ * -formulas), and ϕ AE (∀ * ∃ * -formulas) are assumed to be closed (without free logical variables). Note that altrenation-free formulas are closed under negation, and negating an ∃ * ∀ * -formula results in a ∀ * ∃ * -formula and vice versa (after converting to prenex normal form).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Syntactic Sugar</head><p>RML Command</p><formula xml:id="formula_5">assert ϕ AE {assume ¬ϕ AE ; abort} | skip if ϕ AF then C 1 else C 2 {assume ϕ AF ; C 1 } | {assume ¬ϕ AF ; C 2 } r.insert (x | ϕ QF (x)) r (x) := r (x) ∨ ϕ QF (x) r.remove (x | ϕ QF (x)) r (x) := r (x) ∧ ¬ϕ QF (x) r.insert t r (x) := r (x) ∨ x = t r.remove t r (x) := r (x) ∧ ¬ x = t f t := t f (x) := ite x = t, t, f (x)</formula><p>Figure <ref type="figure" target="#fig_12">12</ref>. Syntactic sugars for RML. ϕ AE denotes a formula with ∀ * ∃ * prefix. ϕ AF denotes an alternation-free formula. r denotes an n-ary relation, f denotes an n-ary function, x denotes a vector of n logical variables, and t denotes a vector of n closed terms.</p><p>(closed) ∃ * ∀ * -formula. Sequential composition and nondeterministic choice are defined in the usual way. The commands given in Figure <ref type="figure" target="#fig_8">10</ref> are the core of RML. Figure <ref type="figure" target="#fig_12">12</ref> provides several useful syntactic sugars for RML, including an assert command, an if-then-else command, and convenient update commands for relations and functions.</p><p>Executions and safety An RML program has the form decls ; C init ; while * do C body ; C final . Execution traces of an RML program are defined as a sequence of states that correspond to executing C init (from any state satisfying the axioms A), then executing C body any number of times (including zero), and then executing C final . An abort command aborts the execution and terminates the trace. A trace that leads to the execution of an abort command is called an error trace. An RML program is safe if it has no error traces.</p><p>Turing-completeness To see that RML is Turing-complete, we can encode a (Minsky) counter machine in RML. Each counter c i can be encoded with a unary relation r i . The value of counter c i is the number of elements in r i . Testing for zero, incrementing, and decrementing counters can all be easily expressed by RML commands.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Axiomatic Semantics</head><p>We now provide a formal semantics for RML by defining a weakest precondition operator for RML commands with respect to assertions expressed in sorted first-order logic. We start with a formal definition of program states as structures of sorted first-order logic, and program assertions as formulas in sorted first-order logic.</p><p>States Recall that an RML program declares a set of program variables V, relations R, and functions F. We define a sorted first-order vocabulary Σ, that contains a relation symbol for every relation in R, a function symbol for every function in F, and a nullary function symbol for every variable in V, all with appropriate sorts. A state of the program is given by a sorted first-order structure over Σ, defined as follows. Assertions Assertions on program states are specified by closed formulas (i.e., without free logical variables) in sorted first-order logic over Σ (see Figure <ref type="figure" target="#fig_7">11</ref>). In the sequel, we use assertions and formulas interchangeably, and they are always assumed to be closed. A state satisfies an assertion if it satisfies it in the usual semantics of sorted first-order logic. Remark 3.1. The reader should be careful not to confuse program variables (modeled as nullary function symbols in Σ) with logical variables used in first-order formulas.</p><p>Weakest precondition of RML commands Figure <ref type="figure" target="#fig_10">13</ref> presents the definition of a weakest precondition operator for RML, denoted wp. The weakest precondition <ref type="bibr" target="#b4">[5]</ref> of a command C with respect to an assertion Q, denoted wp(C , Q), is an assertion Q such that every execution of C starting from a state that satisfies Q leads to a state that satisfies Q. Further, wp(C , Q) is the weakest such assertion. Namely, Q ⇒wp(C , Q) for every Q as above.</p><formula xml:id="formula_6">wp (skip, Q) = Q wp (abort, Q) = false wp (r (x) := ϕ QF (x) , Q) = (A → Q) [ϕ QF (s) / r (s)] wp (f (x) := t (x) , Q) = (A → Q) [t (s) / f (s)] wp (v := * , Q) = ∀x. (A → Q) [x / v] wp (assume ϕ EA , Q) = ϕ EA → Q wp (C 1 ; C 2 , Q) = wp (C 1 , wp (C 2 , Q)) wp (C 1 | C 2 , Q) = wp (C 1 , Q) ∧ wp (C 2 , Q)</formula><p>The rules for wp of skip and abort are standard, as are the rules for assume, sequential composition and nondeterministic choice. The rules for updates of relations and functions and for havoc are instances of Hoare's assignment rule <ref type="bibr" target="#b9">[10]</ref>, applied to the setting of RML and adjusted for the fact that state mutations are restricted by the axioms A.</p><p>Safety Recall that an RML program is safe if it has no execution trace that leads to an abort command, and that an execution trace of an RML program consists of executing C init from any state satisfying the axioms A, then executing C body any number of times (including zero), and then executing C final . To formalize safety using wp, denote C 0 body = skip and C k+1 body = C k body ; C body for any k ≥ 0. Thus, C k body is C body repeated sequentially k times. An RML program is safe iff for any k ≥ 0 we have</p><formula xml:id="formula_7">A ⇒ wp C init ; C k body ; C final , true (k-safety)<label>(1</label></formula><p>) where A is the set of axioms of the program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Inductive invariants</head><p>The safety of an RML program can be established by providing a formula I, such that the following conditions hold:</p><formula xml:id="formula_8">A ⇒ wp (C init , I) (initiation) A ∧ I ⇒ wp (C final , true) (safety) A ∧ I ⇒ wp (C body , I)<label>(2)</label></formula><p>A formula that satisfies these conditions is called an inductive invariant for the RML program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">RML Decidability Properties</head><p>We now show how the restrictions to quantifier-free updates and ∃ * ∀ * assume's, combined with the requirement that function symbols are stratified, lead to decidability of verification conditions for RML programs.</p><p>A key property of the wp operator (Figure <ref type="figure" target="#fig_10">13</ref>) is that ∀ * ∃ * -formulas are closed under wp: Lemma 3.2. Let C be an RML command. If Q is a ∀ * ∃ *formula, then so is the prenex normal form of wp(C , Q).</p><p>Note that this property depends both on the restriction of updates to quantifier-free formulas, and on the restriction of assume's and axioms to ∃ * ∀ * -formulas.</p><p>EPR The effectively-propositional (EPR) fragment of firstorder logic, also known as the Bernays-Schönfinkel-Ramsey class is restricted to relational first-order formulas (i.e., formulas over a vocabulary that contains constant symbols and relation symbols but no function symbols) with a quantifier prefix ∃ * ∀ * . Satisfiability of EPR formulas is decidable <ref type="bibr" target="#b20">[21]</ref>. Moreover, formulas in this fragment enjoy the finite model property, meaning that a satisfiable formula is guaranteed to have a finite model. The size of this model is bounded by the total number of existential quantifiers and constants in the formula. The reason for this is that given an ∃ * ∀ * -formula, we can obtain an equi-satisfiable quantifier-free formula by replacing the existentially quantified variables by Skolem constants, and then instantiating the universal quantifiers for all constants and Skolem constants.</p><p>While EPR does not allow any function symbols, it can be easily extended to allow stratified function symbols while maintaining both the finite model property and the decidability of the problem (though the models may be larger). The reason for this is that, for a finite set of constant and Skolem constant symbols, stratified function symbols can only generate a finite number of ground terms (for a similar procedure, see <ref type="bibr" target="#b12">[13]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Decidability of checking RML verification conditions</head><p>A common task that arises when verifying an RML program is to check, for a given RML command C and formulas P and Q, whether or not P ⇒ wp(C , Q), as in Equations ( <ref type="formula" target="#formula_7">1</ref>) and (2). The following theorem shows that if P and Q have the right quantifier structure, then this check is decidable. Theorem 3.3. Let C be an RML command, P be an ∃ * ∀ * -formula, and Q be a ∀ * ∃ * -formula. Then, checking if P ⇒ wp(C , Q) is decidable. Furthermore, if P ⇒ wp(C , Q), we can obtain a finite counterexample to the implication.</p><p>Proof. Checking the implication is equivalent to checking the unsatisfiability of the formula P ∧ ¬wp(C , Q). Q is a ∀ * ∃ * -formula, so by Lemma 3.2, wp(C , Q) is a ∀ * ∃ *formula, and ¬wp(C , Q) is an ∃ * ∀ * -formula. Thus, P ∧ ¬wp(C , Q) is an ∃ * ∀ * -formula. Since all function symbols in RML are stratified, this formula is in EPR extended with stratified function symbols, and its satisfiability is decidable. Furthermore, this formula has the finite model property, and thus if it is satisfiable, we can obtain a finite model of it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">An Interactive Methodology for Safety Verification</head><p>In this section, we describe our interactive approach for safety verification of RML programs. Recall that an RML program has the form decls ; C init ; while * do C body ; C final</p><p>We wish to verify the safety of the program, i.e. that it cannot reach an abort command. The core of this problem is to verify that all states reachable at the loop head will not lead to an abort<ref type="foot" target="#foot_1">2</ref> , namely that they satisfy both wp (C final , true) and wp (C body , true).</p><p>The key idea is to combine automated analysis with user guidance in order to construct a universal inductive invariant that proves safety. The next subsection describes a preliminary stage for debugging the RML program, and the following subsections describe our interactive methodology of constructing universal inductive invariants.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Debugging via Symbolic Bounded Verification</head><p>Before starting the search for an inductive invariant, it makes sense to first search for bugs in the RML program. This can be done by unrolling the loop a bounded number of times. As we are most interested in states reachable at the loop head, we define an assertion ϕ to be k-invariant if it holds in all states reachable at the loop head after at most k loop iterations. Thus, ϕ is k-invariant iff:</p><formula xml:id="formula_9">A ⇒ k j=0 wp C init ; C j body , ϕ<label>(3)</label></formula><p>Since the axioms A are ∃ * ∀ * -formulas, then by Theorem 3.3 checking the k-invariance of a ∀ * ∃ * -formula ϕ is decidable. Furthermore, if ϕ is not k-invariant, we can obtain a finite model of A ∧ ¬wp C init ; C j body , ϕ for some 0 ≤ j ≤ k. From this model, we can construct an execution trace that executes j loop iterations and reaches a state that violates ϕ. This trace can be graphically displayed to the user as a concrete counterexample to the invariance of ϕ. Note that while checking k-invariance bounds the number of loop iterations, it does not bound the size of the states. Thus, if a property is found to be k-invariant, it holds in all states reachable by k iterations. This is in contrast to finite-state bounded model checking techniques which bound the state space.</p><p>The first step when using Ivy is to model the system at hand as an RML program, and then debug the program by checking k-invariance of wp (C final , true) and wp (C body , true) (see Figure <ref type="figure" target="#fig_1">3</ref>). If a counterexample is found, the user can examine the trace and modify the RML program to either fix a bug in the code, or to fix a bug in the specification (the assertions). Once no more counterexample traces exist up to a bound that satisfies the user, the user moves to the second step of constructing a universal inductive invariant that proves the safety of the system for unbounded number of loop iterations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Overview of the Interactive Search for Universal Inductive Invariants</head><p>Ivy assists the user in obtaining a universal inductive invariant. Recall that a formula I is an inductive invariant for the RML program if the conditions listed in Equation ( <ref type="formula" target="#formula_8">2</ref>)) hold. Recall further that if I is a universally quantified formula, then by Theorem 3.3 these conditions are decidable, and if I does not satisfy them, we can obtain a finite state s that is a counterexample to one of the conditions. Such a state s is a counterexample to induction (CTI).</p><p>Our methodology interactively constructs a universal inductive invariant represented as a conjunction of conjectures, i.e., I = n i=1 ϕ i . Each conjecture ϕ i is a closed universal formula. In the sequel, we interchangeably refer to I as a set of conjectures and as the formula obtained from their conjunction.</p><p>Our methodology, presented in Figure <ref type="figure" target="#fig_3">5</ref>, guides the user through an iterative search for a universal inductive invariant I by generalization from CTIs. We maintain the fact that all conjectures satisfy initiation (A ⇒ wp (C init , ϕ i )), so each CTI we obtain is always a state that satisfies all conjectures, but leads either to an abort command by executing C body or C final , or to a state that violates one of the conjectures by executing C body .</p><p>Initialization The search starts from a given set of conjectures as a candidate inductive invariant I. For example, I can be initialized to true. If wp (C final , true) and wp (C body , true) are universal, then I can initially include them (after checking that they satisfy initiation). If the search starts after a modification of the RML program (e.g. to fix a bug), then conjectures that were learned before can be reused. Additional initial conjectures can be computed by applying basic abstract interpretation techniques.</p><p>Iterations Each iteration starts by (automatically) checking whether the current candidate I is an inductive invariant. If I is not yet an inductive invariant, a CTI is presented to the user, which is a state s that either leads to an abort via C final (safety violation), or leads to a state that violates I via C body (consecution violation). The user can choose to strengthen I by conjoining it with an additional conjecture that excludes the CTI from I. To this end, we provide automatic mechanisms to assist in generalizing from the CTI to obtain a conjecture that excludes it. In case of a consecution violation, the user may also choose to weaken I by eliminating one (or more) of the conjectures. The user can also choose to modify the RML program in case the CTI indicates a bug. This process continues until an inductive invariant is found.</p><p>For I to be an inductive invariant, all the conjectures ϕ i need to be invariants (i.e., hold in all states reachable at the loop head). This might not hold in the intermediate steps of the search, but it guides strengthening and weakening: strengthening aims at only adding conjectures that are invariants, and weakening aims at identifying and removing conjectures that are not invariants. While strengthening and weakening are ultimately performed by the user, we provide several automatic mechanisms to assist the user in this process.</p><p>Obtaining a minimal CTI When I is not inductive, it is desirable to present the user with a CTI that is easy to understand, and not cluttered with many unnecessary features. This also tends to lead to better generalizations from the CTI. To this end, we automatically search for a "minimal" CTI, where the minimization parameters are defined by the user (see Section 4.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Interactive generalization</head><p>To eliminate the CTI s, the user needs to either strengthen I to exclude s from I, or, in case of a consecution violation, to weaken I to include a state reachable from s via C body . Intuitively, if s is not reachable, then I should be strengthened to exclude it. If s is reachable, then I should be weakened. Clearly, checking whether s is reachable is infeasible. Instead, we provide the user with a generalization assistance for coming up with a new conjecture to strengthen I. The goal is to come up with a conjecture that is satisfied by all the reachable states. During the attempt to compute a generalization, the user might also realize that an existing conjecture is in fact not an invariant (i.e., it is not satisfied by all reachable states), and hence weakening is in order. In addition, the user might also find a modeling bug which means the RML program should be fixed.</p><p>Generalizations are explained in Section 4.4, and the interactive generalization process is explained in Section 4.5. Here again, the user defines various parameters for generalization, and Ivy automatically finds a candidate that meets the criteria. The user can further change the suggested generalization and can use additional automated checks to decide whether to keep it. Remark 4.1. If all the conjectures added by the user exclude only unreachable states (i.e., all are invariants), then weakening is never needed. As such, most of the automated assistance we provide focuses on helping the user obtaining "good" conjectures for strengthening-conjectures that do not exclude reachable states. Weakening will typically be used when some conjecture turns out to be "wrong" in the sense that it does exclude reachable states.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Obtaining Minimal CTIs</head><p>We refine the search for CTIs by trying to find a minimal CTI according to user adjustable measures. As a general rule, smaller CTIs are desirable since they are both easier to under-stand, which is important for interactive generalization, and more likely to result in more general (stronger) conjectures. The basic notion of a small CTI refers to the number of elements in its domain. However, other quantitative measures are of interest as well. For example, it is helpful to minimize the number of elements (or tuples) in a relation, e.g. if the relation appears as a guard for protocol actions (such as the pnd relation in the leader election protocol of Figure <ref type="figure" target="#fig_9">1</ref>). Thus, we define a set of useful minimization measures, and let the user select which ones to minimize, and in which order. Each measure m induces an order ≤ m on structures, and each tuple (m 1 , . . . , m t ) of measures induces a "smaller than" relation on structures which is defined by the lexicographic order constructed from the orders ≤ mi .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Minimization measures</head><p>Minimization procedure Given the tuple of measures to minimize, provided by the user, Algorithm 1 automatically finds a CTI that is minimal with respect to this lexicographic order. The idea is to conjoin ψ cti (which encodes violation of inductiveness) with a formula ψ min that is computed incrementally and enforces minimality. For a measure m, ϕ m (n) is an ∃ * ∀ * clause stating that the value of m is no more than n. Such constraints are added to ψ min for every m, by their order in the tuple, where n is chosen to be the minimal number for which the constraint is satisfiable (with the previous constraints). Finally, a CTI that obeys all the additional constraints is computed and returned.</p><p>For example, consider a k-ary relation r. We encode the property that the number of positive tuples of r is at most n as follows: ∃x 1 , . . . x n . ∀y. r(y) → n i=1 y = x i , where x 1 , . . . , x n , y denote k-tuples of logical variables.</p><p>Algorithm 1: Obtaining a Minimal CTI</p><formula xml:id="formula_10">1 if ψ cti is unsatisfiable then return None; 2 ψ min := true ; 3 for m in (m 1 , . . . , mt) do 4 for n in 0, 1, 2, . . . do 5 if ψ cti ∧ ψ min ∧ ϕm(n) is satisfiable then 6 ψ min := ψ min ∧ ϕm(n) ; 7 break 8 return s such that s |= ψ cti ∧ ψ min</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Formalizing Generalizations as Partial Structures</head><p>In this subsection we present the notion of a generalization and the notion of a conjecture associated with a generalization. These notions are key ingredients in the interactive generalization step described in the next subsection.</p><p>Recall that a CTI is a structure. Generalizations of a CTI are given by partial structures, where relation symbols and function symbols are interpreted as partial functions. {0, 1} such that for any x 1 , . . . , x k ∈ D, I(f )(x 1 , . . . , x k , y) = 1 for at most one element y ∈ D. I must also obey the sort restrictions.</p><p>A partial structure over Σ is a pair (D, I), where I is a partial interpretation function of Σ over domain D.</p><p>Note that a structure is a special case of a partial structure. Intuitively, generalization takes place when a CTI is believed to be unreachable, and a partial structure generalizes a CTI (structure) by turning some values ("facts") to be undefined or unspecified. For example, in a partial structure, I(r)(e) might remain undefined for some tuple e. This is useful if the user believes that the structure is still unreachable, regardless of the value of I(r)(e). In Figures <ref type="figure" target="#fig_6">7 to 9</ref>, (a1) and (a2) always represent total structures, while (b) and (c) represent partial structures.</p><p>A natural generalization partial order can be defined over partial structures: Definition 3 (Generalization Partial Order). Let I 1 and I 2 be two partial interpretation functions of Σ over D 1 and D 2 respectively, such that D 2 ⊆ D 1 . We say that I 2 I 1 if for every k-ary relation or function symbol a ∈ Σ, If e ∈ dom(I 2 (a)), then e ∈ dom(I 1 (a)) as well, and I 2 (a)(e) = I 1 (a)(e).</p><p>For partial structures s 1 = (D 1 , I 1 ) and s 2 = (D 2 , s 2 ) of Σ, we say that s 2 s 1 if D 2 ⊆ D 1 and I 2 I 1 .</p><p>The generalization partial order extends the substructure relation of (total) structures. Intuitively, s 2 s 1 if the interpretation provided by s 1 is at least as "complete" (defined) as the interpretation provided by s 2 , and the two agree on elements (or tuples) for which s 2 is defined. Thus, s 2 s 1 when s 2 represents more states than s 1 , and we say that s 2 is a generalization of s 1 .</p><p>From partial structures to conjectures Intuitively, every partial structure s represents an infinite set of structures that are more specific than s (they interpret more facts), and the conjecture that a partial structure induces excludes all these structures (states). Formally, a partial structure induces a universally quantified conjecture that is obtained as the negation of the diagram of the partial structure, where the classic definition of a diagram of a structure is extended to partial structures. where ψ is the conjunction of:</p><p>• r(x i1 , . . . , x i k ) for every k-ary relation r in Σ and every i 1 , . . . , i k s.t. I(r)(e i1 , . . . , e i k ) = 1, and • ¬r(x i1 , . . . , x i k ) for every k-ary relation r in Σ and every i 1 , . . . , i k s.t. I(r)(e i1 , . . . , e i k ) = 0, and • f (x i1 , . . . , x i k ) = x j for every k-ary function f in Σ and every i 1 , . . . , i k and j s.t. I(f )(e i1 , . . . , e i k , e j ) = 1, and • f (x i1 , . . . , x i k ) = x j for every k-ary function f in Σ and every i 1 , . . . , i k and j s.t. I(f )(e i1 , . . . , e i k , e j ) = 0.</p><p>Intuitively, Diag(s) is obtained by treating individuals in D as existentially quantified variables and explicitly encoding all the facts that are defined in s.</p><p>The negation of the diagram of s constitutes a conjecture that is falsified by all structures that are more specific than s. This includes all structures that contain s as a substructure.</p><p>Definition 5 (Conjecture). Let s be a partial structure. The conjecture associated with s, denoted ϕ(s), is the universal formula equivalent to ¬Diag(s). Lemma 4.2. Let s be a partial structure and let s be a (total) structure such that s s . Then s |= ϕ(s).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Note that if s 2</head><p>s 1 , then ϕ(s 2 )⇒ϕ(s 1 ) i.e., a larger generalization results in a stronger conjecture.</p><p>This connection between partial structures and conjectures is at the root of our graphical interaction technique. We present the user with partial structures, and the user can control which facts to make thus changing the partial structure. The semantics of the partial structure is given by the conjecture associated with it. The conjectures C 1 , C 2 , and C 3 of Figure <ref type="figure">6</ref> are the conjectures associated with the partial structures depicted in Figure <ref type="figure" target="#fig_4">7</ref> (c), Figure <ref type="figure" target="#fig_5">8</ref> (b), and Figure <ref type="figure" target="#fig_6">9</ref> (c) respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Interactive Generalization</head><p>Generalization of a CTI s in Ivy consists of the following conceptual phases that are controlled by the user:</p><p>Coarse-grained manual generalization The user graphically selects an upper bound for generalization s u s, with the intent to obtain a -smallest generalization s of s u . Intuitively, the upper bound s u defines which elements of the domain may participate in the generalization and which tuples of which relations may stay interpreted in the generalization. For example, if a user believes that the CTI remains unreachable even when some I(r)(e) is undefined, they can use this intuition to define the upper bound.</p><p>In Ivy the user defines s u by graphically marking the elements of the domain that will remain in the domain of the partial structure. In addition, for every relation or function symbol a, the user can choose to turn all positive instances of I(a) (i.e., all tuples e such that I(a)(e) = 1) to undefined, or they can choose to turn all negative instances of I(a) to undefined. The user makes such choices by selecting appropriate checkboxes for every symbol.</p><p>In Figures <ref type="figure" target="#fig_6">7 to 9</ref>, (b) depicts the upper bound s u selected by the user according to the user's intuition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fine-grained automatic generalization via k-invariance</head><p>Ivy searches for a -smallest generalization s that generalizes s u such that ϕ(s ) is k-invariant (i.e., s is unreachable in k steps), where k is provided by the user.</p><p>This process begins by checking if ϕ(s u ) is k-invariant using Equation <ref type="bibr" target="#b2">(3)</ref>. If verification fails, the user is presented with a trace that explains the violation. Based on this trace, the user can either redefine s u to be less general, or they may decide to modify the RML program if a bug is revealed.</p><p>If ϕ(s u ) is k-invariant, it means that the negation of Equation ( <ref type="formula" target="#formula_9">3</ref>) for ϕ(s u ) is unsatisfiable. In this case, Ivy computes the minimal UNSAT core out of the literals of ϕ(s u ) and uses it to define a most general ( -smallest) s m such that ϕ(s m ) is still k-invariant. The partial structure s m obtained by the UNSAT core is displayed to the user as a candidate generalization (the user can also see the corresponding conjecture).</p><p>The partial structures, s m , obtained in this stage are depicted in Figures <ref type="figure" target="#fig_4">7</ref> and<ref type="figure" target="#fig_6">9 (c</ref>). For the CTI of Figure <ref type="figure" target="#fig_5">8</ref>, s u , depicted in (b), is already minimal, and the UNSAT core is not able to remove any literals (so in this case s u = s m ).</p><p>User investigates the suggested generalization After the automatic generalization found a stronger conjecture ϕ(s m ) that is still k-invariant, the user must decide whether to add this conjecture to the candidate inductive invariant I. In order to make this decision, the user can check additional properties of the generalization (and the conjecture associated with it). For example, the user may check if it is k -invariant for some k &gt; k. The user can also examine both the graphical visualization of s m and a textual representation of ϕ(s m ) and judge it according to their intuition about the system.</p><p>If the obtained conjecture does not seem correct, the user can choose to increase k and try again. If a conjecture that appears bogus remains k-invariant even for large k, it may indicate a bug in the RML program that causes the behaviors of the program to be too restricted (e.g. an axiom or an assume that are too strong). The user may also choose to manually fine-tune the conjecture by re-introducing interpretations that became undefined. The user can also choose to change the generalization upper bound s u or even ask Ivy for a new CTI, and start over. Eventually, the user must decide on a conjecture to add to I for the process to make progress.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Initial Experience</head><p>In this section we provide an empirical evaluation of the approach presented above. Ivy is implemented in Python and uses Z3 <ref type="bibr" target="#b3">[4]</ref> for satisfiability testing. Ivy supports both the procedure for symbolic bounded verification described in Section 4.1 and the procedures for interactive construction of inductive invariants described in Sections 4.2 to 4.5. Ivy provides a graphical user interface implemented using JavaScript in an IPython <ref type="bibr" target="#b24">[25]</ref> notebook.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Protocols</head><p>Lock server We consider a simple lock server example taken from Verdi <ref type="bibr" target="#b27">[28,</ref><ref type="bibr">Fig. 3]</ref>. The system contains an unbounded number of clients and a single server. Each client has a flag that denotes whether it thinks it holds the lock or not. The server maintains a list of clients that requested the lock, with the intent of always granting the lock to the client at the head of the list. A client can send a lock request to the server. When this request is received the server adds the client to the end of the list. If the list was previously empty, the server will also immediately send back a grant message to the client. A client that holds the lock can send an unlock message that, when received, will cause the server to remove the client from the waiting list, and send a grant message to the new head of the list. In this protocol, messages cannot be duplicated by the network, but they can be reordered. Consequently, the same client can appear multiple time in the server's waiting list. The safety property to verify is that no two clients can simultaneously think they hold the lock.</p><p>Distributed lock protocol Next, we consider a simple distributed lock protocol taken from <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b11">12]</ref> that allows an unbounded set of nodes to transfer a lock between each other without a central server. Each node maintains an integer denoting its current epoch and a flag that denotes if it currently holds the lock. A node at epoch e that holds the lock, can transfer the lock to another node by sending a transfer message with epoch e + 1. A node at epoch e that receives a transfer message with epoch e ignores it if e ≤ e, and otherwise it moves to epoch e , takes the lock, and sends a locked message with epoch e . In this protocol, messages can be duplicated and reordered by the network. The safety property to verify is that all locked messages within the same epoch come from a single node.</p><p>Learning switch Learning switches are a basic component in networking. A learning switch maintains a table, used to route incoming packets. On receiving a packet, the learning switch adds a table entry indicating that the source address can be reached by forwarding out the incoming port. It then checks to see if the destination address has an entry in the table, and if so forwards the packet using this entry. If no entry exists it floods the packet out all of its ports with the exception of the incoming port. For this protocol we check whether the routing tables for all switches could contain a forwarding loops. We consider a model with an unbounded number of switches and an unbounded forwarding table. routing table of each switch contains an unbounded number of entries.</p><p>We model the network using a binary relation link describing the topology of the network and a 4-arity relation pending of the set of all packets pending in the network; pending(s, d, sw 1 , sw 2 ) implies a packet with source s and destination d is pending to be received along the sw 1 -sw 2 link. We store the routing tables using relations learned, and route. For verification we use route * a relation which mod-els the reflexive transitive closure of route. The modeling maintains route * using the standard technique for updating transitive closure (e.g. <ref type="bibr" target="#b13">[14]</ref>). The safety property is specified by an assertion that whenever a switch learns a new route, it does not introduce a cycle in the forwarding graph.</p><p>Database chain consistency Transaction processing is a common task performed by database engines. These engines ensure that (a) all operations (reads or writes) within a transaction appear to have been executed at a single point in time (atomicity), (b) a total order can be established between the committed transactions for a database (serializability), and (c) no transaction can read partial results from another transaction (isolation). Recent work (e.g., <ref type="bibr" target="#b29">[30]</ref>) has provided a chain based mechanism to provide these guarantees in multi-node databases. In this model the database is sharded, i.e., each row lives on a single node, and we wish to allow transactions to operate across rows in different nodes.</p><p>Chain based mechanisms work by splitting each transaction into a sequence of subtransactions, where each subtransaction only accesses rows on a single node. These subtransactions are executed sequentially, and traditional techniques are used to ensure that subtransaction execution does not violate safety conditions. Once a subtransaction has successfully executed, we say it has precommitted, i.e., the transaction cannot be aborted due to command in the subtransaction. Once all subtransactions in a transaction have precommitted, the transaction itself commits, if any subtransaction aborts the entire transaction is aborted. We used Ivy to show that one such chain transaction mechanism provides all of the safety guarantees provided by traditional databases.</p><p>The transaction protocol was modeled in RML using a sort for transaction, node, key (row) and subtransaction. Commit times are implicitly modeled by transactions (since each transaction has a unique commit time), and unary relations are used to indicate that a transaction has committed or aborted. We modeled the sequence of subtransactions in a transaction using the binary relation opOrder and tracked a transactions dependencies using the binary relation writeTx (indicating a transaction t wrote to a row) and a ternary relation dependsTx (indicating transaction t read a given row, and observed writes from transaction t ). To this model we added assertions ensuring that (a) a transaction reading row r reads the last committed value for that row, and (b) uncommitted values are not read. For our protocol this is sufficient to ensure atomicity.</p><p>Chord ring maintenance Chord is a peer-to-peer protocol implementing a distributed hash table. In <ref type="bibr" target="#b28">[29]</ref>, Zave presented a model of the part of the protocol that implements a selfstabilizing ring. This was proved correct for the case of up to 8 participants, but the parameterized case was left open. We modeled Chord in Ivy and attempted to prove the primary safety property, which is that the ring remains connected under certain assumptions about failures. Our method was similar to Houdini <ref type="bibr" target="#b5">[6]</ref>  to construct the strongest inductive invariant in this class. This was insufficient to prove safety, however. We took the abstract state at the point the safety failure occurred as our attempted inductive invariant, and used Ivy's interaction methods to diagnose the proof failure and correct the invariant. An interesting aspect of this proof is that, while Zave's proof uses the transitive closure operator in the invariant (and thus is outside any known decidable logic) we were able to interactively infer a suitable universally quantified inductive invariant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Results &amp; Discussion</head><p>Next, we evaluate Ivy's effectiveness. We begin, in Figure <ref type="figure" target="#fig_13">14</ref> by quantifying model size, size of the inductive invariant discovered and the number of CTIs generated when modeling the protocols described above. As can be seen, across a range of protocols, modeled with varying numbers of sorts and relation and function symbols, Ivy allowed us to discover inductive invariants in a modest number of interactive steps (as indicated by the number of CTIs generated in column G). However, Ivy is highly interactive and does not cleanly lend itself to performance evaluation (since the human factor is often the primary bottleneck). We therefore present here some observations from our experience using Ivy as an evaluation into its utility.</p><p>Modeling Protocols in Ivy Models in Ivy are written in an extended version of RML. Since, RML and Ivy are restricted to accepting code that can be translated into EPR formulas, they force some approximation on the model. For example, in the database commit protocol, expressing a constraint requiring that every subtransaction reads or writes at least one row is impossible in EPR, and we had to overapproximate to allow empty subtransactions.</p><p>Bounded Verification Writing out models is notoriously error prone. We found Ivy's bounded verification stage to be invaluable while debugging models, even when we bounded ourselves to a relatively small number of steps (typically 3 -9). Ivy displays counterexamples found through bounded verification using the same graphical interface as is used during inductive invariant search. We found this graphical representation of the counterexample made it easier to understand modeling bugs and greatly sped up the process of debugging a model.</p><p>Finding Inductive Invariants In our experience, using a graphical representation to select an upper bound for generalization was simple and the ability to visually see a concrete counterexample allowed us to choose a much smaller partial structure. In many cases we found that once a partial structure had been selected, automatic generalization quickly found the final conjecture accepted by the user. Additionally, in some cases the conjectures suggested by Ivy were too strong, and indicated that our modeling excluded valid system behaviors. For example, when modeling the database example we initially used assume's that were too strong. We detected this when we saw Ivy reporting that a conjecture that seemed bogus is true even for a high number of transitions. After fixing the model, we could reuse work previously done, as many conjectures remained invariant after the fix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Comparing safety verification in Ivy to Coq and Dafny</head><p>The lock server protocol is taken from <ref type="bibr" target="#b27">[28]</ref>, and thus allows some comparison of the safety verification process in Ivy to Coq and the Verdi framework. The size and complexity of the protocol description in Ivy is similar to Verdi, and both comprise of approximately 50 lines of code. When verifying safety with Verdi, the user is required to manually think of the inductive invariant, and then prove its inductiveness using Coq. For this protocol, <ref type="bibr" target="#b27">[28]</ref> reports a proof that is approximately 500 lines long. With Ivy, the inductive invariant was found after 8 iterations of user guided generalizations, which took us less then an hour. Note that with Ivy, there is no need to manually prove that the invariant is inductive, as this stage is fully automated.</p><p>The distributed lock protocol is taken from <ref type="bibr" target="#b7">[8]</ref>, which allows a comparison with Dafny and the IronFleet framework. This protocol took us a few hours to verify with Ivy. Verifying this protocol with Dafny took the authors of <ref type="bibr" target="#b7">[8]</ref> a few days, when a major part of the effort was manually coming up with the inductive invariant <ref type="bibr" target="#b23">[24]</ref>. Thus, for this protocol, the help Ivy provides in finding the inductive invariant significantly reduces the verification effort.</p><p>In both cases we are comparing the substantial part of the proof, which is finding and proving the inductive invariant. There are some differences in the encoding of this problem, however. For example, we use a totally ordered set where the Coq version of the lock server example uses a list. From the Coq version, executable code can be extracted, whereas we cannot currently do this from the Ivy version.</p><p>Overall Thoughts We believe Ivy makes it easier for users to find inductive invariants, and provides a guided experience through this process. This is in contrast to the existing model for finding inductive invariants, where users must come up with the inductive invariant by manual reasoning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Related Work</head><p>The idea of using decidable logics for program verification is quite old. For example, Klarlund et al. used monadic second order (MSO) logic for verification in the Mona system <ref type="bibr" target="#b8">[9]</ref>. This approach has been generalized in the STRAND logic <ref type="bibr" target="#b21">[22]</ref>. Similar logics could be used in the methodology we propose. However, EPR has the advantage that it does not restrict models to have a particular structure (for example a tree or list structure). Moreover as we have seen there are simple and effective heuristics for generalizing a counterexample model to an EPR formula. Finally, the complexity of EPR is relatively low (exponential compared to non-elementary) and it is implemented in efficient provers such as Z3.</p><p>Various techniques have been proposed for solving the parameterized model checking problem (PMCP). Some achieve decidability by restricting the process model to specialized classes that have cutoff results <ref type="bibr" target="#b6">[7]</ref> or can be reduced to wellstructured transition systems (such as Petri nets) <ref type="bibr" target="#b0">[1]</ref>. Such approaches have the advantages of being fully automated when they apply. However, they have high complexity and do not fail visibly. This and the restricted model classes make it difficult to apply these methods in practice.</p><p>There are also various approach to the PMCP based on abstract interpretation. A good example is the Invisible Invariants approach <ref type="bibr" target="#b26">[27]</ref>. This approach attempts to produce an inductive invariant by generalizing from an invariant of a finite-state system. However, like other abstract interpretation methods, it has the disadvantage of not failing visibly.</p><p>The kind of generalization heuristic we use here is also used in various model checking techniques, such IC3 <ref type="bibr" target="#b1">[2]</ref>. A generalization of this approach called UPDR can automatically synthesize universal invariants <ref type="bibr" target="#b16">[17]</ref>. The method is fragile, however, and we were not successful in applying it to the examples verified here. Our goal in this work is to make this kind of technique interactive, so that user intuition can be applied to the problem.</p><p>There are also many approaches based on undecidable logics that provide varying levels of automation. Some examples are proof assistants such as Coq that are powerful enough to encode all of mathematics but provide little automation, and tools such as Dafny <ref type="bibr" target="#b18">[19]</ref> that provide incomplete verification condition checking. The latter class of tools provide greater automation but do not fail visibly. Because of incompleteness they can produce incorrect counterexample models, and in the case of a true counterexample to induction they provide little feedback as to the root cause of the proof failure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusion</head><p>We have presented Ivy -a tool for interactively verifying safety of infinite-state systems. Ivy is based on two key insights. First, the modeling language should be designed to permit effective abstract specification and yet allow decidable invariant checking using satisfiability solvers. Second, invariant generation is fundamentally based on generalization, which should be a collaborative process between the human user and automated mechanisms. Ivy has many other features not discussed here, including abstract interpretation, support for modular refinement proofs, test generation and extraction of executable implementations.</p><p>We hope that Ivy will become a useful tool for system builders and designers. We are encouraged by our initial experience in protocols like chain replication, where the designer did not initially know what safety properties should be satisfied or how to formally model the protocol. We found the graphical interface to be extremely valuable as a proof interaction tool. In the case of the Chord protocol, it also led us to a simplified proof in the unbounded setting.</p><p>Although we focused on EPR in this paper, the methodology of generating inductive invariants by interactive generalization from CTIs is more general. It depends only on the following three properties of the modeling language and the class of conjectures: (i) decidability of bounded verification -checking if a conjecture is true after k transitions, (ii) decidability of checking inductiveness of a candidate conjecture set, and (iii) the ability to graphically represent conjectures in a way that is intuitive for system developers, and allows them to graphically define generalizations. RML together with universal conjectures satisfy these properties. We hope that our methodology will also be applied in other verification settings where these properties can be satisfied.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>17 assert ∀n 1 Figure 1 .</head><label>1711</label><figDesc>Figure 1. An RML model of the leader election protocol. unique ids, le total order, ring topology, and next(a, b) denote a universally quantified formulas given in Figure 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Flowchart of bounded verification.</figDesc><graphic coords="3,354.57,72.00,164.00,88.25" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. An error trace found by BMC for the leader protocol, when omitting the fact that node IDs are unique. (a) an initial state; (b) node1 sent a message to node2; (c) node2 sent a message to node1; (d) node1 processed a pending message and became leader; (e) node2 processed a pending message and became leader, there are now two leaders and the safety property is violated.</figDesc><graphic coords="4,329.07,233.02,215.00,148.75" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Flowchart of the interactive search for an inductive invariant.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. The 1st CTI generalization step for the leader protocol, leading to C 1 . (a1) The CTI state that has one leader, but makes a transition to a state (a2) with two leaders. The root cause is that a node with non-maximal ID is a leader. (b) A generalization created by the user by removing the topology information and the pnd relation (c) Further generalization obtained by BMC + Auto Generalize, which removed the fact that node2 is not a leader.</figDesc><graphic coords="6,125.13,279.31,96.85,77.68" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. The 2nd CTI generalization step for the leader protocol, leading to C 2 . (a1) The CTI state and its successor (a2) violating C 1 . The root cause is that a node with non-maximal ID has a pending message with its own ID. (b) A generalization created by the user by removing the topology information and the leader relation. This generalization was validated but not further generalized by BMC + Auto Generalize.</figDesc><graphic coords="6,388.14,180.04,96.85,77.68" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. The 3rd CTI generalization step for the leader protocol, leading to C 3 . (a1) The CTI state and its successor (a2) which violates C 2 . The root cause is that node1 has a pending message with the ID of node2, even though node3 is on the path from node2 to node1 and has an ID higher than node2's ID (equivalently, node2 is between node1 and node3 and has a lower ID than node3's ID). (b) A generalization created by the user by removing the leader relation. The generalization does not contain next, only btw. (c) Further generalization obtained by BMC + Auto Generalize, which eliminated id1.</figDesc><graphic coords="7,123.99,310.51,99.13,92.63" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figures 10 and 11</head><label>11</label><figDesc>Figures 10 and 11 show the abstract syntax of RML. RML imposes two main programming limitations: (i) the only data structures are uninterpreted finite relations and stratified functions, and (ii) program conditions and update formulas have restricted quantifier structure.RML further restricts programs to consist of a single nondeterministic loop, with possible initialization and finalization commands. Thus, RML commands are loop-free. While this restriction simplifies the presentation of our approach, note that it does not reduce RML's expressive power as nested loops can always be converted to a flat loop.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 10 .</head><label>10</label><figDesc>Figure10. Syntax of RML. s denotes a sort identifier and s denotes a vector of sort identifiers separated by commas. r denotes a relation identifier. f denotes a function identifier. v denotes an identifier of a zero-arity function. x denotes a vector of logical variables. t (x) denotes a term with free logical variables x and ϕ QF (x) denotes a quantifier-free formula with free logical variables x. ϕ EA denotes a closed formula with quantifier prefix ∃ * ∀ * . The syntax of terms and formulas is given in Figure11.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Definition 1 (</head><label>1</label><figDesc>Structures). Given a vocabulary Σ, a structure of Σ is a pair s = (D, I), where D is a finite sorted domain, and I is an interpretation function, mapping each symbol of Σ to its meaning in s. I associates each k-ary relation symbol r ∈ Σ with a function I(r) : D k → {0, 1}, and associates each k-ary function symbol f ∈ Σ with a function I(f ) : D k+1 → {0, 1} such that for any x 1 , . . . , x k ∈ D, I(f )(x 1 , . . . , x k , y) = 1 for exactly one element y ∈ D 1 . I also obeys the sort restrictions. The states of an RML program are (finite) structures of Σ that satisfy all the axioms A declared by the program.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 13 .</head><label>13</label><figDesc>Figure 13. Rules for wp. ϕ [β / α] denotes ϕ with occurrences of α substituted by β. s denotes a vector of terms.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>The considered measures are: • Size of sort S: |D S | where D S is the domain of sort S. • Number of positive tuples of r: |{e | I(r)(e) = 1}|. • Number of negative tuples of r: |{e | I(r)(e) = 0}|.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Formally: Definition 2 (</head><label>2</label><figDesc>Partial Structures). Given a vocabulary Σ and a domain D, a partial interpretation function I of Σ over D associates every k-ary relation symbol r ∈ Σ with a partial function I(r) : D k {0, 1}, and associates every k-ary function symbol f ∈ Σ with a partial function I(f ) : D k+1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Definition 4 (</head><label>4</label><figDesc>Diagram). Let s = (D, I) be a finite partial structure of Σ and let D = {e 1 , . . . , e |D | } ⊆ D denote the set of elements e i for which there exists (at least one) relation or function symbol a ∈ Σ such that e i appears in the domain of definition of I(a). The diagram of s, denoted by Diag(s), is the following formula over Σ: ∃x 1 . . . x |D | . distinct(x 1 . . . x |D | ) ∧ ψ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>1</head><label></label><figDesc>sort node 2 sort id 3 function id : node → id 4 relation le : id,id 5 relation btw : node, node, node 6 relation leader: node 7 relation pnd: id, node 8 variable n : node 9 variable m : node 10 variable i : id 11 axiom unique ids 12 axiom le total order 13 axiom ring topology 14 assume ∀x.¬leader(x) 15 assume ∀x, y.¬pnd(x, y) 16 while * do {</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>in that we described a class of formulas using a template, and used abstract interpretation Figure14. Protocols verified interactively with Ivy. S is the number of sorts in the model. RF is the number of relations and function symbols in the model. C is the size of the initial set of conjectures, measured by the total number of literals that appear in the formulas. I is the size of the final inductive invariant (also measured by total number of literals). G is the number of CTI's and generalizations that took place in the interactive search for the inductive invariant.</figDesc><table><row><cell>Protocol</cell><cell cols="2">S RF C I G</cell></row><row><cell>Leader election in ring</cell><cell>2 5</cell><cell>3 12 3</cell></row><row><cell>Lock server</cell><cell cols="2">5 11 3 21 8</cell></row><row><cell>Distributed lock protocol</cell><cell>2 5</cell><cell>3 26 12</cell></row><row><cell>Learning switch</cell><cell cols="2">2 5 11 18 3</cell></row><row><cell cols="3">Database chain replication 4 13 11 35 7</cell></row><row><cell>Chord ring maintenance</cell><cell cols="2">1 13 35 46 4</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>For uniformity of the presentation of our approach, we treat functions of arity k as "special" relations of arity k + 1 that relate each k-tuple to exactly one element.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Verifying that no execution of C init leads to abort is simple as C init executes only once, and amounts to checking if A ⇒ wp (C init , true).</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank Thomas Ball, Nikolaj Bjørner, Tej Chajed, Constantin Enea, Neil Immerman, Daniel Jackson, Ranjit Jhala, K. Rustan M. Leino, Giuliano Losa, Bryan Parno, Shaz Qadeer, Zachary Tatlock, James R. Wilcox, the anonymous referees, and the anonymous artifact evaluation referees for insightful comments which improved this paper. Padon, Sagiv, and Shoham were supported by the European Research Council under the European Union's Seventh Framework Program (FP7/2007-2013) / ERC grant agreement no. [321174-VSSC], and by a grant from the Israel Science Foundation (652/11). Panda was supported by a grant from Intel Corporation. Parts of this work were done while Padon and Sagiv were visiting Microsoft Research.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Algorithmic analysis of programs with well quasi-ordered domains</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Abdulla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Cerans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Jonsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Tsay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Comput</title>
		<imprint>
			<biblScope unit="volume">160</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="109" to="127" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Sat-based model checking without unrolling</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Bradley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Verification, Model Checking, and Abstract Interpretation -12th International Conference</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="70" to="87" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">An improved algorithm for decentralized extrema-finding in circular configurations of processes</title>
		<author>
			<persName><forename type="first">E</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Roberts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="281" to="283" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Z3: An efficient SMT solver</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>De Moura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Bjørner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="337" to="340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">A Discipline of Programming</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Dijkstra</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1976">1976</date>
			<publisher>Prentice-Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Houdini, an annotation assistant for esc/java</title>
		<author>
			<persName><forename type="first">C</forename><surname>Flanagan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R M</forename><surname>Leino</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FME 2001: Formal Methods for Increasing Software Productivity, International Symposium of Formal Methods Europe</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="500" to="517" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Reasoning about systems with many processes</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>German</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Sistla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="675" to="735" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Ironfleet: proving practical distributed systems correct</title>
		<author>
			<persName><forename type="first">C</forename><surname>Hawblitzel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Howell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kapritsos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Lorch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Parno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Roberts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T V</forename><surname>Setty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Zill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th Symposium on Operating Systems Principles, SOSP</title>
		<meeting>the 25th Symposium on Operating Systems Principles, SOSP</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Monadic second-order logic in practice</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">G</forename><surname>Henriksen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Jørgensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Klarlund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Paige</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Rauhe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sandholm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Tools and Algorithms for Construction and Analysis of Systems, First International Workshop</title>
		<meeting><address><addrLine>Mona</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="89" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">An axiomatic basis for computer programming</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="576" to="580" />
			<date type="published" when="1969">1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The coq proof assistant a tutorial</title>
		<author>
			<persName><forename type="first">G</forename><surname>Huet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Paulin-Mohring</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Rapport Technique</title>
		<imprint>
			<biblScope unit="volume">178</biblScope>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Distributed lock service protocol source code</title>
		<ptr target="6/ironfleet/src/Dafny/Distributed/Protocol/Lock/Node.i.dfy" />
	</analytic>
	<monogr>
		<title level="m">40b281f9f9fa7cfca5a00a7085cb302e6b1a9aa</title>
		<imprint>
			<biblScope unit="page" from="2016" to="2019" />
		</imprint>
		<respStmt>
			<orgName>IronFleet Project</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Modular reasoning about heap paths via effectively propositional formulas</title>
		<author>
			<persName><forename type="first">S</forename><surname>Itzhaky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Banerjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Immerman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Lahav</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Nanevski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sagiv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the 41st Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="385" to="396" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Effectively-propositional reasoning about reachability in linked data structures</title>
		<author>
			<persName><forename type="first">S</forename><surname>Itzhaky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Banerjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Immerman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Nanevski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sagiv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Aided Verification -25th International Conference, CAV</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="756" to="772" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<ptr target="https://www.cs.tau.ac.il/˜odedp/ivy/" />
		<title level="m">Ivy PLDI&apos;16 web page</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Software Abstractions: Resources and Additional Materials</title>
		<author>
			<persName><forename type="first">D</forename><surname>Jackson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Property-directed inference of universal invariants or proving their absence</title>
		<author>
			<persName><forename type="first">A</forename><surname>Karbyshev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Bjørner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Itzhaky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Rinetzky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shoham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Aided Verification -27th International Conference, CAV</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="583" to="602" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">sel4: formal verification of an operating-system kernel</title>
		<author>
			<persName><forename type="first">G</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Andronick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Elphinstone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Heiser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Cock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Derrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Elkaduwe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Engelhardt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kolanski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Norrish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Sewell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Tuch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Winwood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="107" to="115" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Dafny: An automatic program verifier for functional correctness</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R M</forename><surname>Leino</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic for Programming, Artificial Intelligence, and Reasoning -16th International Conference, LPAR-16</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="348" to="370" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Formal verification of a realistic compiler</title>
		<author>
			<persName><forename type="first">X</forename><surname>Leroy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="107" to="115" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Complexity results for classes of quantificational formulas</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">R</forename><surname>Lewis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="317" to="353" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Efficient decision procedures for heaps using STRAND</title>
		<author>
			<persName><forename type="first">P</forename><surname>Madhusudan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Qiu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Static Analysis -18th International Symposium</title>
		<meeting><address><addrLine>Venice, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-09-14">2011. September 14-16, 2011. 2011</date>
			<biblScope unit="page" from="43" to="59" />
		</imprint>
	</monogr>
	<note>Proceedings</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Isabelle/HOL -A Proof Assistant for Higher-Order Logic</title>
		<author>
			<persName><forename type="first">T</forename><surname>Nipkow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Paulson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wenzel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">2283</biblScope>
			<date type="published" when="2002">2002</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">B</forename><surname>Parno</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note>private communication</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">IPython: a system for interactive scientific computing</title>
		<author>
			<persName><forename type="first">F</forename><surname>Pérez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">E</forename><surname>Granger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computing in Science and Engineering</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="21" to="29" />
			<date type="published" when="2007-05">May 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Deciding effectively propositional logic using DPLL and substitution sets</title>
		<author>
			<persName><forename type="first">R</forename><surname>Piskac</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>De Moura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Bjørner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Autom. Reasoning</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="401" to="424" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Automatic deductive verification with invisible invariants</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ruah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">D</forename><surname>Zuck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Tools and Algorithms for the Construction and Analysis of Systems, 7th International Conference</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="82" to="97" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Verdi: a framework for implementing and formally verifying distributed systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Wilcox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Woos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Panchekha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Tatlock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Ernst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">E</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="357" to="368" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">How to make chord correct (using a stable base</title>
		<author>
			<persName><forename type="first">P</forename><surname>Zave</surname></persName>
		</author>
		<idno>CoRR, abs/1502.06461</idno>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Transaction chains: achieving serializability with low latency in geo-distributed storage systems</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Power</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sovran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Aguilera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles</title>
		<meeting>the Twenty-Fourth ACM Symposium on Operating Systems Principles</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="276" to="291" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
