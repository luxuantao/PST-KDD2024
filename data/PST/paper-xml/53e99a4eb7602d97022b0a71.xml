<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A NEW RECURSION-THEORETIC CHARACTERIZATION OF THE POLYTIME FUNCTIONS</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Stephen</forename><surname>Bellantoni</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Stephen</forename><surname>Cook</surname></persName>
						</author>
						<title level="a" type="main">A NEW RECURSION-THEORETIC CHARACTERIZATION OF THE POLYTIME FUNCTIONS</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">7D97686F3D29DF5683D1C72A73F93BB4</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:05+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Recursion theory</term>
					<term>Cobham</term>
					<term>Polynomial Time. Subject classifications. 68Q15</term>
					<term>03D20</term>
					<term>68Q05</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We give a recursion-theoretic characterization of FP which describes polynomial time computation independently of any externally imposed resource bounds. In particular, this syntactic characterization avoids the explicit size bounds on recursion (and the initial function 2 |x|•|y| ) of Cobham.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Cobham <ref type="bibr" target="#b7">[9]</ref> characterized the polytime functions as the least class of functions which includes certain initial functions and which is closed under composition and bounded recursion on notation. His characterization has yielded a number of applications; in particular it serves as the basis for several theories of arithmetic ( <ref type="bibr" target="#b8">[10]</ref>, <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b11">[13]</ref>) which formalize aspects of polytime reasoning.</p><p>Although it has been fruitful, an unsatisfying aspect of Cobham's characterization arises in the recursion on binary notation. The recursion operator is a powerful one which, however, can only be applied when an explicit size bound is satisfied by the resulting function. Additionally, an initial function 2 |x|•|y| is needed solely to provide a large enough bound for making recursive definitions.</p><p>Leivant's recent elegant characterization of polynomial time <ref type="bibr" target="#b15">[17]</ref> suggests that one might be able to dispense with these features controlling the growth rate of functions. Leivant proves that a function is polytime if and only if it can be proved convergent in the logical system L 2 (QF + ) using the function's recursion equations and a "surjective" principle. Here L 2 (QF + ) is second order logic with comprehension (i.e., definability of sets) for positive quantifier-free fomulas. The system has the string successor functions built in, but nothing like 2 |x|•|y| ; and bounded recursion plays no rôle.</p><p>Inspired by Leivant's result and its proof, we present here a direct recursiontheoretic characterization of the polytime functions. The result can be read independently of the results in Leivant's paper <ref type="bibr" target="#b15">[17]</ref>. Our closure operations are essentially composition and recursion on notation, syntactically restricted in ways which have no direct connection to bounds on growth rates. All the initial functions are small, their outputs being no longer than the outputs of the string successors.</p><p>Our results raise the question of how the type of recursion introduced here, "predicative recursion", can be used to define other complexity classes in a "resource free" manner. More generally we may ask whether Leivant's program, using impredicativity to characterize computational complexity, can be carried out directly in a functional setting absent of logic and provability.</p><p>1.1. Background. Immerman <ref type="bibr" target="#b14">[16]</ref> and others have characterized polytime relations in a way which is also resource free in the sense that there are no explicit bounds in the defining expressions. However, these are frequently characterizations of relations rather than functions; for example the exponential relation E(y, x) ≡ (y = 2 x ) is polytime. While there has been some related work using functions, as in <ref type="bibr" target="#b13">[15]</ref>, the finite model theory setting has imposed output size bounds a priori. We approach a different problem, that of controlling the growth rate of functions without introducing explicit bounds.</p><p>The work here also differs substantially from the earlier work of Clote and Takeuti <ref type="bibr" target="#b6">[8]</ref> which uses logical sorts to distinguish the size of terms; there the explicit construction 2 t creates a term whose logical sort is one greater than the logical sort of t. For example the Key Lemma in <ref type="bibr" target="#b6">[8]</ref>, like other contemporary work, uses an explicit bound on the recursively defined function.</p><p>Our notion of Predicative Recursion on Notation, which was developed independently, is comparable to Leivant's "tiered recurrence" <ref type="bibr" target="#b16">[18]</ref>. The functions defined there are the much smaller class of extended polynomials. Following our work <ref type="bibr">([3]</ref>), Leivant and Marion <ref type="bibr" target="#b17">[19]</ref>, <ref type="bibr" target="#b18">[20]</ref> have expanded the results of <ref type="bibr" target="#b16">[18]</ref>. Further results are discussed in the conclusion below.</p><p>In the subject of program synthesis and automatic theorem proving, Fegaras, Sheard and Stemple <ref type="bibr" target="#b12">[14]</ref> have independently formulated a recursion scheme which seems related to the one below. They do not analyze the complexity of the functions computed using their scheme.</p><p>1.2. Motivating Example. As a motivating example, consider the definition of the function (similar to the smash function of Buss and others) in <ref type="bibr" target="#b15">[17]</ref>. The definition uses recursion on binary strings as follows: (w, sv) = ⊕(w, (w, v)) for s ∈ {0, 1}, where ⊕ (concatenation) has been defined by recursion on its first input, not its second. Leivant shows that convergence of the function is provable in L 2 (QF + ). On the other hand, if we take the natural definition of the exponential function, 2 sx = ⊕(2 x , 2 x ), we see that the recursive term 2 x is substituted in the position which was used for recursively defining ⊕. The exponential function is not provable in L 2 (QF + ).</p><p>This suggests the definition below of a class B of functions. In this class, one does not allow recursive terms to be substituted into a position which was used for an earlier definition by recursion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">The class B</head><p>Each input to a function in B will be either a "normal" input or a "safe" input; we write the normal inputs to the left and separate them from the safe inputs using a semicolon: f (x; y).</p><p>We formulate the result using computation on non-negative integers, but the same proof carries over to computation on binary strings as in Leivant <ref type="bibr" target="#b15">[17]</ref>, replacing 0 with . We write |x| for the binary length log 2 (x + 1) of integer x; and the terms "predecessor" and "successor" refer to binary notation. If x is a vector of n integers we write |x| for the vector |x 1 |, . . . , |x n |, and we write f (x) for f 1 (x), . . . , f m (x).</p><p>B is the smallest class of functions containing the initial functions i-v and closed under vi, vii: i. (Constant) 0 (a zero-ary function).</p><p>ii. (Projection) π n,m j (x 1 . . . x n ; x n+1 . . . x n+m ) = x j , for 1 ≤ j ≤ n + m.</p><p>iii. (Successors) s i (; a) = 2a + i = ai, for i ∈ {0, 1}. where h, r, and t are in B.</p><p>The polynomial time functions will be exactly those functions in B which have all normal inputs; i.e. no safe inputs.</p><p>Functions in B can perform any (polytime) operation on their normal inputs, but can only apply a restricted set of operations to their safe inputs. In particular, the operations allowed on safe inputs do not increase the length by more than an additive constant. Adding a function to B which operates on safe inputs would in general be more powerful than adding the same function on normal inputs, because of the asymmetry of the composition scheme.</p><p>To understand Safe Composition, suppose f (x; a) is given by a single expression in x and a. Then f (x; a) can be defined by Safe Composition (and Projection) from the function symbols occurring in the expression, provided that each sub-expression g(s; t) has no a i appearing in the terms s.</p><p>Observe that in defining a function by recursion, the recursive value f (y, x; a) is substituted into a safe position rather than a normal position of h. The predicative composition scheme ensures that this recursive value will stay in a safe position and will not be copied into a normal position. Intuitively, this means that the depth of sub-recursions which h i performs on y or x cannot depend on the value being recursively computed. This mechanism seems to have the effect of preventing the uncontrolled impredicativity which Leivant discussed as the cause of a blowup in complexity.</p><p>In concrete terms, we can think of safe positions as input positions where it is safe to substitute a large value without greatly increasing the output size of the function. In contrast, the output size may increase polynomially in the size of the normal inputs. See Lemma 4.1 below. Intuition relating the safe and normal sorts to computation time is made precise in later work <ref type="bibr" target="#b1">[2]</ref>. In philosophical terms, we can think of safe positions as input positions where it is safe to substitute an "impredicatively defined" value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">B contains PTIME</head><p>To prove that every polytime function is in B, we use the Cobham characterization <ref type="bibr" target="#b7">[9]</ref> of P as the least class of functions containing the Constant, Projection, Successor functions, and the smash function 2 |x|•|y| ; and closed under ordinary composition h(g(x)) and the following rule: Definition 3.1. (Bounded Recursion on Notation) If h i , g, and j are in the class then so is f , where</p><formula xml:id="formula_0">f (0, x) = g(x), f (yi, x) = h i (y, x, f (y, x)) for yi = 0.</formula><p>(i ∈ {0, 1}), provided that f (y, x) ≤ j(y, x) for all y, x.</p><p>See Rose <ref type="bibr" target="#b21">[23]</ref> for a proof that the Cobham functions are all the polynomial time functions, or see <ref type="bibr" target="#b24">[26]</ref> for the same result formulated over binary strings. In particular, for each Cobham function f there is a length-bounding monotone</p><formula xml:id="formula_1">polynomial b f such that |f (x)| ≤ b f (|x|).</formula><p>To prove that B contains every PTIME function f , we first show how to compute the value of f (x) assuming that we already have a value w which is big enough. Intuitively speaking, w has to have a length at least as great as the maximum depth of recursion used in computing f (x). Lemma 3.2. Let f be any polytime function. There is a function f in B and a monotone polynomial p f such that f (a) = f (w; a) for all a and all w with |w| ≥ p f (|a|).</p><p>Proof. The proof is by induction on the length of the derivation of f as a function in the Cobham class. If f is a constant, projection, or successor function then f is trivially defined using the Constant, Projection or Successor functions of B. In these cases, let p f = 0.</p><p>If f is defined by composition, f (x) = h(g(x)), then define f by f (w; x) = h (w; g (w; x)). Since the functions g are in the Cobham class, they have lengthbounding polynomials b g . Define p f such that</p><formula xml:id="formula_2">p f (|x|) = p h (b g (|x|)) + j p g j (|x|).</formula><p>The induction hypothesis can be applied to h and g using the facts implied by |w| ≥ p f (|x|). The desired properties of f and p f then follow easily.</p><p>The next case is when f is 2 |x|•|y| . This function has a definition using recursion on notation with length-bounding polynomials b g (|x|, |y|) = |x| + |y| and b f (|x|, |y|) = |x| • |y| + 1. Namely: g(0, y) = y; g(xi, y) = g(x, y)0; f (0, y) = 1; and f (xi, y) = g(y, f (x, y)) (where xi = 0). In this case one can apply the same method as for bounded recursion on notation.</p><p>The difficult case is when f (y, x) is constructed by bounded recursion on notation as in the Definition above. Then g , h 0 and h 1 in B are given by the induction hypothesis. Of course we cannot define f (w; y, x) by recursion on y, since y is not in normal position. Instead we introduce a parameter z, and use recursion on z to simulate recursion on y. The recursion parameter z is initialized to w, and the part of the recursion on |z| from |w| down to |w| -|y| corresponds to recursion on y.</p><p>To define f first define, using Predicative Recursion on Notation and Predicative Composition, the functions To continue formally, define ĥ(w; i, a, b, c) = C(; i, h 0 (w; a, b, c), h 1 (w; a, b, c)), f (0, w; y, x) = 0, f (zj, w; y, x) = C(; ∨(w; Y (z1, w; y)), g (w; x), ĥ(w; I(z, w; y), Y (z, w; y), x, f (z, w; y, x)), )  This allows us to apply the main induction hypothesis for h i : Proof. Let p f and f be obtained using the preceeding Lemma. We will construct a function b(x; ) in B such that |b(x; )| ≥ p f (|x|). Then setting f (x; ) = f (b(x; ); x) finishes the theorem. First define concatenation of k strings (in reverse order) using one safe position:</p><formula xml:id="formula_3">f (w; y, x) = f (w, w; y, x). Since f is in the Cobham class, there is a monotone polynomial b f such that |f (y, x)| ≤ b f (|y|, |x|). Letting p h = p h 0 + p h 1 , define p f such that p f (|y|, |x|) ≡ p h (|y|, |x|, b f (|y|, |x|)) + p g (|x|) + |y| + 1.</formula><formula xml:id="formula_4">, x) = g (w; x) = f (0, x) = f (Y (</formula><formula xml:id="formula_5">h i (w; Y (z, w; y), x, f (z, w; y, x)) = h i (w; Y (z, w; y), x, f (Y (z, w; y), x)) = h i (Y (z, w; y), x, f (Y (z, w; y), x)).</formula><formula xml:id="formula_6">⊕ 2 (0; y) = y, ⊕ 2 (xi; y) = s i (; ⊕ 2 (x; y)) for xi = 0, ⊕ k (x 1 , . . . , x k-1 ; x k ) = ⊕ 2 (x 1 ; ⊕ k-1 (x 2 , . . . , x k-1 ; x k )).</formula><p>Next define the "declining smash" function using recursion in the safe position of ⊕ 2 as follows, #(0; ) = 0, #(zi; ) = ⊕ 2 (zi; #(z; )) for zi = 0.</p><p>The length of #z is |z|(|z| + 1)/2 = Ω(|z| 2 ).</p><p>Let a, c be such that ( </p><formula xml:id="formula_7">j |x j |) a + c ≥ p f (</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">PTIME contains B</head><p>To prove that all functions in B are polytime, we first derive a bound on the length of the computed value. Then it is easy to observe that the Predicative Recursion on Notation operator preserves polytime if the output is lengthbounded.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 4.1. Let f be a function in B.</head><p>There is a monotone polynomial q f such that |f (x; y)| ≤ q f (|x|) + max i |y i | for all x, y.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof. The proof is by induction on the derivation of f in B.</head><p>If f is a Constant, Projection, Successor, Predecessor, or Conditional function, then |f (x; y)| ≤ 1 + i |x i | + max i |y i | and therefore we can just take q f (|x|</p><formula xml:id="formula_8">) = 1 + i |x i |.</formula><p>If f is defined by Predicative Recursion on Notation then by the induction hypothesis we have q g , q h 0 and q h 1 bounding g, h 0 and h 1 respectively. Letting q h = q h 0 + q h 1 , we have</p><formula xml:id="formula_9">|f (0, x; y)| ≤ q g (|x|) + max i |y i |, |f (zi, x; y)| ≤ q h (|z|, |x|) + max(max i |y i |, |f (z, x; y)|).</formula><p>Define q f such that</p><formula xml:id="formula_10">q f (|z |, |x|) = |z | • q h (|z |, |x|) + q g (|x|).</formula><p>We have trivially |f (0, x; y)| ≤ q f (|0|, |x|)+max i |y i | by the induction hypothesis on g and monotonicity of q h . Now assuming |f (z, x; y)| ≤ q f (|z|, |x|) + max i |y i | and |zi| = 0 (hence |zi| = |z| + 1), we have</p><formula xml:id="formula_11">|f (zi, x; y)| ≤ q h (|z|, |x|) + max(max i |y i |, |f (z, x; y)|) ≤ q h (|z|, |x|) + max(max i |y i |, q f (|z|, |x|) + max i |y i |) ≤ q h (|z|, |x|) + q f (|z|, |x|) + max i |y i | ≤ q h (|z|, |x|) + |z| • q h (|z|, |x|) + q g (|x|) + max i |y i | ≤ |zi| • q h (|z|, |x|) + q g (|x|) + max i |y i | ≤ |zi| • q h (|zi|, |x|) + q g (|x|) + max i |y i | ≤ q f (|zi|, |x|) + max i |y i |.</formula><p>Therefore, a simple induction on |z | shows that |f (z , x; y)| ≤ q f (|z |, |x|) + max i |y i | for all z , as desired. Finally, if f is defined by Safe Composition then using the induction hypothesis on h, r, and t,</p><formula xml:id="formula_12">|f (x; y)| = |h(r(x; ); t(x; y))| ≤ q h (|r(x; )|) + max i |t i (x; y)| ≤ q h (q r (|x|)) + max i |t i (x; y)| ≤ q h (q r (|x|)) + max i q t i (|x|) + max j |y j | ≤ q h (q r (|x|)) + i q t i (|x|) + max i |y i |.</formula><p>Therefore, choosing q f such that q f (|x|) ≡ q h (q r (|x|)) + i q t i (|x|) finishes the result. 2 Theorem 4.2. Let f (x; y) be a function in B. Then f (x, y) is polytime.</p><p>Proof. The initial functions are all clearly computable in polynomial time.</p><p>For Safe Composition observe that the composition of two polynomial time functions is a polynomial time function.</p><p>With regard to Predicative Recursion on Notation, it is well known that a recursion on notation can be executed in polynomial time if the result of the recursion is polynomially length-bounded and the step and base functions are polytime. In our case, the length-bound follows from the preceeding lemma.</p><p>Alternatively we can observe that the bounding polynomials of the Lemma are computable in Cobham's class and that therefore every instance of Predicative Recursion on Notation is an occurrence of Bounded Recursion on Notation; this gives a reduction of derivations in B to derivations in the Cobham class. 2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Further comments</head><p>The presentation in this paper has used a single sort of variable and has classified input positions as safe or normal. A similar class of functions can be defined using two sorts of variables, ascribing safe or normal sort to both the inputs and outputs. Safe Composition is replaced by ordinary composition respecting the sorts of the inputs and outputs. The initial functions all take on safe type outputs, and Predicative Recursion on Notation results in a safevalued function. One further adds the following "Raising" rule: if function f (x; ) of all normal inputs is in the class with safe type output, then the function f ν is in the class with normal type output defined by f ν (x; ) = f (x; ).</p><p>In such a two-sorted presentation we could replace the Predecessor and Conditional functions with the single function N (x; a) = a mod 2 |x| . This gives a class BC which (even ignoring output sorts) differs from B; for example p(; a) is not in BC. But (again ignoring output sorts) BC and B are identical on the subset consisting of functions with all normal inputs. Hence BC is as good as B in characterizing the polynomial time functions. The proof for BC is simpler than the proof for B; however, this is somewhat offset by the fact that N is not a constant-time operation.</p><p>If we take as a base the class BC and develop a higher-type class along the lines used for the definition of P V ω terms in <ref type="bibr" target="#b11">[13]</ref>, we obtain a class apparently equal to the Basic Feasible Functionals discussed in <ref type="bibr" target="#b10">[12]</ref>. Now if we add the initial function λa.|a| of type (safe → normal), the resulting class is still polytime on its type 1 section yet is able to compute the well-quasi-ordering functional which Cook <ref type="bibr" target="#b9">[11]</ref> demonstrated is not Basic Feasible. See <ref type="bibr" target="#b23">[25]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Directions for research</head><p>Philosophically we think of normal values as those which are known in totality, and safe values as those which are "impredicative" in the sense that their definition refers to members of the set N of integers other than those which are immediately known. As Nelson <ref type="bibr" target="#b19">[21]</ref> points out and Leivant <ref type="bibr" target="#b15">[17]</ref> emphasises, definitions of N are impredicative because they are justified by inductive means, which presuppose an understanding of N . In other words, the validity of defining a function by recursion requires an impredicatively defined concept, namely N . The current work projects the idea of an impredicatively defined set down onto specific members of the set -relative to the fact that we have certain values given to us in their totality, references to other members of N are references to "impredicative values". They are values which you only know exist because you assume the existence of an impredicativly defined set, N . We control this impredicativity by isolating such values in safe input positions, and performing only operations on them which are constant-time with respect to their size. Thus we have developed a functional analogue of highly predicative reasoning.</p><p>From this viewpoint, it is interesting to investigate the complexity classes obtained with predicative recursion by allowing various amounts of information to cross over from the safe inputs to the normal inputs; or, by allowing various amounts of computation to be performed on the safe inputs. This project could be stated technically as follows: explain, for various syntactically defined and highly function classes R, the effect of adding to B the composition scheme f (x; y) = h(r(x; y); t(x; y)) where r ∈ R. As mentioned above, the function r(; y) = |y| is permissible without exceeding polytime.</p><p>It appears that the methods of this paper can be used to remove the size bounds from Clote's 'sequential' characterizations <ref type="bibr" target="#b5">[7]</ref> of AC k and N C k , giving resource-independent characterizations of these classes. An alternative approach to characterizing N C 1 is given by Bloch <ref type="bibr" target="#b3">[4]</ref> based on the methods of this paper and the work of Allen <ref type="bibr" target="#b0">[1]</ref>. Recently, Leivant and Marion <ref type="bibr" target="#b17">[19]</ref>, <ref type="bibr" target="#b18">[20]</ref> have used a method similar to ours and <ref type="bibr" target="#b16">[18]</ref> to characterize the Kalmar elementary functions. The class of logspace-decidable problems, the class of linear space functions, and the class of functions computable in polynomial time using Σ p i oracles have now been given similar characterizations ( <ref type="bibr" target="#b1">[2]</ref>).</p><p>The results of this paper can be used <ref type="bibr" target="#b1">[2]</ref> to give a new proof of Leivant's result <ref type="bibr" target="#b15">[17]</ref> that functions provable in L 2 (QF + ) include all the polytime functions.</p><p>The results also bear on the system PV ([10], <ref type="bibr" target="#b11">[13]</ref>), an equational theory with a function symbol for each polytime function together with defining equations for the function based on Cobham's characterization. When f is introduced by bounded recursion on notation, it is necessary to prove in PV that the bounding inequality is satisfied. This requirement contributes significantly to the complication of developing the theory in PV. An alternative development of PV, based on the theorem here rather than Cobham's theorem, should be simpler.</p><p>Finally, a category theory translation of the results in this paper has been given by Otto <ref type="bibr" target="#b20">[22]</ref>.</p><p>pointing out to us that these two can be eliminated in favor of the single predecessor function, p. We would like to thank Toniann Pitassi for her helpful comments. We would like to thank Daniel Leivant for his comments on an earlier draft of this paper.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>iv. (Predecessor) p(; 0) = 0, p(; ai) = a. v. (Conditional) C(; a, b, c) = b if a mod 2 = 0, c otherwise. vi. (Predicative Recursion on Notation) Define the new function f by, for i ∈ {0, 1}, f (0, x; a) = g(x; a), f (yi, x; a) = h i (y, x; a, f (y, x; a)) for yi = 0, where h i and g are in B. vii. (Safe Composition) Define the new function f by f (x; a) = h(r(x; ); t(x; a))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>par(; a) = C(; a, 0, 1), P (0; b) = b, Y (z, w; y) = P (P (z, w; ); y), P (ai; b) = p(; P (a; b)), I(z, w; y) = par(; Y (z1, w; y)). P (a, b; ) = P (a; b). ∨(0; a) = par(; a), ∨(xi; a) = C(; ∨(x; a), par(; P (xi; a)), 1). These are explained as follows. The function P (a; b) takes |a| predecessors of b. The function Y (z, w; y) produces an initial segment of y, namely y with |w|-|z| rightmost (low-order) bits deleted. As z varies in length from |w| down to |w| -|y|, the output of Y varies from y down to the trivial initial segment, 0. Recursion depths with |z| below |w| -|y| will be irrelevant. The function I(z, w; y) satisfies Y (zj, w; y) = s I(z,w;y) Y (z, w; y), for zj = 0. At each step of the recursion on z we use the function I to look into y and see which step function h I should be applied. The function ∨(x; a) computes the logical OR of the rightmost |x| bits of a.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fixing</head><label></label><figDesc>y and x, let w satisfy |w| ≥ p f (|y|, |x|). We prove below by induction on |u| that: for |w| -|y| ≤ |u| ≤ |w|, f (u, w; y, x) = f (Y (u, w; y), x). Since Y (w, w; y) = y, we have f (w; y, x) = f (y, x) as desired for the main induction of the lemma. Consider any u with |w| -|y| ≤ |u| ≤ |w|. Since |w| -|y| ≥ 1 there is z and j ∈ {0, 1} such that u = zj. Also note |zj| = |z1| and Y (z1, w; y) = Y (zj, w; y). Since |w| ≥ |Y (z1, w; y)|, the expression ∨(w; Y (z1, w; y)) is 0 if Y (z1, w; y) = 0 and is 1 if Y (z1, w; y) = 0. First, if |u| = |zj| = |w| -|y| then Y (z1, w; y) = 0. Using the definition of f and the main induction hypothesis on g, we immediately have f (zj, w; y</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>2 Theorem 3 . 3 .</head><label>233</label><figDesc>The condition |w| -|y| &lt; |zj| ≤ |w| implies y = 0 and Y (z1, w; y) = 0, so by the definition of f and the fact Y (zj, w; y) = s I(z,w;y) Y (z, w; y) we have f (zj, w; y, x) = h I(z,w;y) (w; Y (z, w; y), x, f (z, w; y, x)) = h I(z,w;y) (Y (z, w; y), x, f (Y (z, w; y), x)) = f (Y (zj, w; y), x), as desired. Let f (x) be a polytime function. Then f (x; ) is in B.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>|x|) for all x. Composing # onto itself a constant number of times and then concatenating a constant to the end gives a function b 1 (z; ) such that |b 1 (z; )| ≥ (|z|) a + c. Using predicative composition again gives ⊕(x; ) = ⊕ k (x 1 . . . x k-1 ; x k ) and b(x; ) = b 1 (⊕(x; ); ) having length at least p f (|x|) as desired. 2</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Bellantoni &amp; Cook</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>In an earlier draft of this paper we used the functions D(a; b) = P (b, a) and E(a; b) = P (b, P (b, a)) as initial functions. We are grateful to Sam Buss for</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Arithmetizing Uniform NC</title>
		<author>
			<persName><forename type="first">B</forename><surname>Allen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Pure and Applied Logic</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="1" to="50" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Predicative Recursion and Computational Complexity</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bellantoni</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
		<respStmt>
			<orgName>University of Toronto</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD Thesis</note>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A New Recursion-Theoretic Characterization of the Polytime Functions (Extended Abstract)</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bellantoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 24th Symposium on the Theory Of Computing</title>
		<meeting>24th Symposium on the Theory Of Computing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Functional Characterizations of Uniform Log-depth and Polylogdepth Circuit Families</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bloch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc., Structure in Complexity Theory</title>
		<meeting>Structure in Complexity Theory</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Bounded Arithmetic</title>
		<author>
			<persName><forename type="first">S</forename><surname>Buss</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985. 1986</date>
			<pubPlace>Naples</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Princeton University</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. Dissertation. reprinted Bibliopolis</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Sequential, machine-independent characterizations of the parallel complexity classes AlogTIME, AC k , N C k and N C</title>
		<author>
			<persName><forename type="first">P</forename><surname>Clote</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">MSI Workshop on Feasible Mathematics</title>
		<imprint>
			<biblScope unit="page" from="49" to="70" />
			<date type="published" when="1989">1989</date>
			<publisher>Birkhauser</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Exponential Time and Bounded Arithmetic</title>
		<author>
			<persName><forename type="first">P</forename><surname>Clote</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Takeuti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual Conference on Structure in Complexity Theory</title>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="125" to="143" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The intrinsic computational difficulty of functions</title>
		<author>
			<persName><forename type="first">A</forename><surname>Cobham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 1964 International Congress for Logic, Methodology, and the Philosophy of Science</title>
		<editor>
			<persName><forename type="first">Y</forename><surname>Bar-Hillel</surname></persName>
		</editor>
		<meeting>of the 1964 International Congress for Logic, Methodology, and the Philosophy of Science<address><addrLine>North Holland, Amsterdam</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1964">1964</date>
			<biblScope unit="page" from="24" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Feasibly constructive proofs and the propositional calculus</title>
		<author>
			<persName><forename type="first">S</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th Symposium on the Theory Of Computing</title>
		<meeting>7th Symposium on the Theory Of Computing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1975">1975</date>
			<biblScope unit="page" from="83" to="97" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Computability and complexity of higher type functions</title>
		<author>
			<persName><forename type="first">S</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. MSRI Workshop on Logic from Computer Science</title>
		<editor>
			<persName><forename type="first">Y</forename><surname>Moschovakis</surname></persName>
		</editor>
		<meeting>MSRI Workshop on Logic from Computer Science</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="51" to="72" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<author>
			<persName><forename type="first">S</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kapron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Characterizations of the Basic Feasible Functionals of Finite Type</title>
		<title level="s">Feasible Mathematics</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Buss</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Scott Eds</surname></persName>
		</editor>
		<editor>
			<persName><surname>Birkhauser</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="71" to="95" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Functional interpretations of feasibly constructive arithmetic</title>
		<author>
			<persName><forename type="first">S</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Urquhart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Extended abstract appears in Proc. 21st Symposium on the Theory of Computing</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="107" to="112" />
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Uniform Traversal Combinators: Definition, Use and Properties</title>
		<author>
			<persName><forename type="first">L</forename><surname>Fegaras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Sheard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Stemple</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">11th International Conference on Automated Deduction</title>
		<imprint>
			<date type="published" when="1992-06">June 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Algebras of Feasible Functions</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Gurevich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 24th IEEE Conference on Foundations of Computer Science</title>
		<meeting>24th IEEE Conference on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1983">1983</date>
			<biblScope unit="page" from="210" to="214" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Languages That Capture Complexity Classes</title>
		<author>
			<persName><forename type="first">N</forename><surname>Immerman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal of Computing</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="760" to="778" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A foundational delineation of computational feasibility</title>
		<author>
			<persName><forename type="first">D</forename><surname>Leivant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Sixth Annual IEEE Symposium on Logic in Computer Science</title>
		<meeting>Sixth Annual IEEE Symposium on Logic in Computer Science</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="2" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Subrecursion and lambda representation over free algebras (Preliminary summary)</title>
		<author>
			<persName><forename type="first">D</forename><surname>Leivant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Feasible Mathematics</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Buss</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Scott</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="page" from="281" to="292" />
			<date type="published" when="1990">1990</date>
			<publisher>Birkhauser</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Purely applicative characterizations of complexity classes (Extended Abstract)</title>
		<author>
			<persName><forename type="first">D</forename><surname>Leivant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J-Y.</forename><surname>Marion</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992-04">April 1992</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, Indiana University</orgName>
		</respStmt>
	</monogr>
	<note>typescript</note>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Capturing poly-time in a typed λ-calculus</title>
		<author>
			<persName><forename type="first">D</forename><surname>Leivant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J-Y.</forename><surname>Marion</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992-04">April 1992</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, Indiana University</orgName>
		</respStmt>
	</monogr>
	<note>typescript</note>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">E</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Predicative</forename><surname>Arithmetic</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
			<publisher>Princeton University Press</publisher>
			<pubPlace>Princeton</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Categorical Characterization of Ptime I</title>
		<author>
			<persName><forename type="first">J</forename><surname>Otto</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
		<respStmt>
			<orgName>Dept. of Mathematics, McGill University</orgName>
		</respStmt>
	</monogr>
	<note>manuscript</note>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">E</forename><surname>Rose</surname></persName>
		</author>
		<title level="m">Subrecursion: functions and hierarchies, Oxford Logic Guides 9</title>
		<meeting><address><addrLine>Oxford</addrLine></address></meeting>
		<imprint>
			<publisher>Clarendon Press</publisher>
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Classes of Predictably Computable Functions</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Ritchie</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1963">1963</date>
			<publisher>American Mathematical Society</publisher>
			<biblScope unit="volume">106</biblScope>
			<biblScope unit="page" from="139" to="173" />
		</imprint>
	</monogr>
	<note>Transactions of the</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">There is no Recursive Axiomatization for Feasible Functionals of Type</title>
		<author>
			<persName><forename type="first">A</forename><surname>Seth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Seventh Annual IEEE Symposium on Logic in Computer Science</title>
		<meeting>Seventh Annual IEEE Symposium on Logic in Computer Science</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
	<note>to appear, IEEE</note>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Tourlakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Computability</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1984-10-15">1984. 15 October 1991</date>
			<pubPlace>Reston</pubPlace>
		</imprint>
	</monogr>
	<note>Manuscript</note>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Stephen</surname></persName>
		</author>
		<title level="m">Canada M5S 1A4 sjb@theory.utoronto.ca Stephen A</title>
		<meeting><address><addrLine>Ontario, Canada</addrLine></address></meeting>
		<imprint/>
		<respStmt>
			<orgName>Bellantoni Department of Computer Science University of Toronto Toronto, Ontario ; Cook Department of Computer Science University of Toronto Toronto</orgName>
		</respStmt>
	</monogr>
	<note>M5S 1A4 sacook@theory.utoronto.ca</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
