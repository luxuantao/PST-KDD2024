<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Software Model Checking: The VeriSoft Approach</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Patrice</forename><surname>Godefroid</surname></persName>
							<email>god@bell-labs.com</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Bell Laboratories</orgName>
								<orgName type="institution" key="instit2">Lucent Technologies</orgName>
								<address>
									<postCode>2701, 60532</postCode>
									<settlement>Lucent Lane, Lisle</settlement>
									<region>IL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Software Model Checking: The VeriSoft Approach</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">9F954E7124457EB042241ED82B51D853</idno>
					<note type="submission">Received March 2002; Revised March 2003; Accepted July 2003</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:22+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>software model checking</term>
					<term>systematic testing</term>
					<term>program verification</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Verification by state-space exploration, also often referred to as model checking, is an effective method for analyzing the correctness of concurrent reactive systems (for instance, communication protocols). Unfortunately, traditional model checking is restricted to the verification of properties of models, i.e., abstractions, of concurrent systems.</p><p>We discuss in this paper how model checking can be extended to analyze arbitrary software, such as implementations of communication protocols written in programming languages like C or C++. We then introduce a search technique that is suitable for exploring the state spaces of such systems. This algorithm has been implemented in VeriSoft, a tool for systematically exploring the state spaces of systems composed of several concurrent processes executing arbitrary code.</p><p>During the past five years, VeriSoft has been applied successfully for analyzing several software products developed in Lucent Technologies, and has also been licensed to hundreds of users in industry and academia. We discuss applications, strengths and limitations of VeriSoft, and compare it to other approaches to software model checking, analysis and testing.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Concurrent systems are systems composed of elements that can operate concurrently and communicate with each other. Each component can be viewed as a reactive system, i.e., a system that continuously interacts with its environment. Concurrent reactive systems are notably hard to design and test because their components may interact in many unexpected ways. Traditional testing techniques are of limited help since test coverage is bound to be only a minute fraction of the possible behaviors of the system. Furthermore, scenarios leading to errors are often extremely difficult to reproduce.</p><p>An effective approach for analyzing the correctness of a concurrent reactive system consists of systematically exploring its state space. The state space of a concurrent system is a directed graph that represents the combined behavior of all concurrent components in the system. Such a state space can be computed automatically from an abstract description of the concurrent system specified in a (essentially finite-state) modeling language. Many properties of a model of a system can be checked by exploring its state space: deadlocks, dead code, violations of user-specified assertions, etc. Moreover, the range of properties that state-space exploration techniques can verify has been substantially broadened during the last decade thanks to the development of model-checking methods for various temporal logics (e.g., <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b47">48,</ref><ref type="bibr" target="#b54">55,</ref><ref type="bibr" target="#b60">61]</ref>). In what follows, we will use the term "model checking" in a broad sense, to denote any automatic state-space exploration technique that can be used for verification purposes. 1  Examples of tools that follow the above paradigm are CAESAR <ref type="bibr" target="#b23">[24]</ref>, COSPAN <ref type="bibr" target="#b36">[37]</ref>, CWB <ref type="bibr" target="#b13">[14]</ref>, MURPHI <ref type="bibr" target="#b19">[20]</ref>, SMV <ref type="bibr" target="#b51">[52]</ref> and SPIN <ref type="bibr" target="#b38">[39]</ref>, among others. These tools differ by the modeling languages they use for representing systems and properties. But all of them are based on state-space exploration algorithms, in one form or another, for performing the verification itself.</p><p>The effectiveness of model checking for analyzing the correctness of concurrent reactive systems is becoming increasingly well-established. A large variety of complex reactive systems, ranging from circuit designs to communication protocols, have been modeled and then analyzed using state-space exploration techniques. In many cases, these analyzes were able to reveal quite subtle design errors (e.g., <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b56">57]</ref>). Once the model of a new software application has been thoroughly analyzed, it can also be used as the core of the implementation of the application (e.g., <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b39">40]</ref>).</p><p>It is worth emphasizing that the practical interest of systematic state-space exploration (and of "verification" in general) is mainly to find errors that would be hard to detect and reproduce otherwise, and not necessarily to prove the absence of errors. While mathematically proving that a model of a system conforms to a specific set of properties does increase the confidence that the actual system is "correct", it does not provide a proof of this fact. Therefore, although model checking is a verification framework, it is closer to testing in practice since any verification process is inherently incomplete: only some abstract models or system configurations can be checked against some properties in some environment, and verification results can also be approximate when an exact answer is too expensive to compute.</p><p>In this paper, we discuss how model checking can be extended to deal directly with "actual" descriptions of concurrent systems, such as implementations of communication protocols written in general-purpose programming languages like C or C++. We show that existing search techniques for state-space exploration are fundamentally limited to the analysis of systems for which each state of the system can be readily represented by a unique identifier. We then introduce an efficient search technique that does not rely on this assumption. This search algorithm can therefore be applied to systems composed of several concurrent processes executing arbitrary code written in full-fledged programming languages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Concurrent systems and dynamic semantics</head><p>We consider a concurrent system composed of a finite set P of processes and a finite set O of communication objects. Each process P ∈ P executes a sequence of operations described in a sequential program written in a full-fledged programming language such as C or C++. Such sequential programs are deterministic: every execution of the program on the same input data performs the same sequence of operations. We assume that processes communicate with each other by performing atomic operations on communication objects. A communication object O ∈ O is defined by a pair (V, OP), where V is the set of all possible values for the object (its domain), and OP is the set of operations that can be performed on the object. Examples of communication objects are shared variables, semaphores, and FIFO buffers. Since we assume operations on communication objects are atomic, at most one operation can be performed on a given communication object at any time. Operations on communication objects are called visible operations, while other operations are by default called invisible. The execution of an operation is said to be blocking if it cannot currently be completed; for instance, waiting for the reception of a message blocks until a message is received. We assume that only executions of visible operations may be blocking.</p><p>At any time, the concurrent system is said to be in a state. The system is said to be in a global state when the next operation to be executed by every process in the system is a visible operation. Every process in the system is always expected to eventually attempt executing a visible operation. (If a process does not attempt to execute a visible operation within a given amount of time, an error, called divergence, is reported at run-time.) This assumption implies that initially, after the creation of all the processes of the system, the system can reach a first and unique global state s 0 , called the initial global state of the system. A process transition, or transition for short, is defined as one visible operation followed by a finite sequence of invisible operations performed by a single process and ending just before a visible operation. Let T denote the set of all transitions of the system.</p><p>A transition is said to be disabled in a global state s when the execution of its visible operation is blocking in s. Otherwise, the transition is said to be enabled in s. A transition t that is enabled in a global state s can be executed from s. Since the number of invisible operations in a transition is finite, the execution of an enabled transition always terminates. When the execution of t from s is completed, the system reaches a global state s , called the successor of s by t. 2 We write s t → s to mean that the execution of the transition t leads from the global state s to the global state s , while s w ⇒ s means that the execution of the finite sequence w of transitions leads from s to s .</p><p>We now define a formal semantics for the concurrent systems that satisfy our assumptions. A concurrent system as defined here is a closed system: from its initial global state, it can evolve and change its state by executing enabled transitions. Therefore, a natural way to describe the possible behaviors of such a system is to consider its set of reachable global states and the transitions that are possible between these.</p><p>Formally, the joint global behavior of all processes P i in a concurrent system can be represented by a transition system A G = (S, , s 0 ) such that • S is the set of global states of the system, • ⊆ S × S is the transition relation defined as follows:</p><formula xml:id="formula_0">(s, s ) ∈ iff ∃t ∈ T : s t → s ,</formula><p>• s 0 is the initial global state of the system.</p><p>An element of corresponds to the execution of a single transition t ∈ T of the system. The elements of will be referred to as global transitions. As usual, we restrict A G to its global states and transitions that are reachable from s 0 , since the other global states and transitions play no role in the behavior of the system. In what follows, a "state in A G " denotes a state that is reachable from s 0 . By definition, states in A G are global. We call A G the global state space of the system. Example 1. Consider the concurrent C program shown in figure <ref type="figure" target="#fig_0">1</ref>. This program represents a concurrent system composed of two processes that communicate using UNIX semaphores.</p><p>The program describes the behavior of these processes as well as the initialization of the system. This example is inspired by the well-known dining-philosophers problem, with two philosophers. The two processes communicate by executing the (visible) operations semwait and semsignal on two semaphores that are identified by the integers 0 and 1 respectively. The operations semwait and semsignal take 3 arguments: the first argument is an identifier for an array of semaphores, the second is the index of a particular semaphore in that array, and the third argument is a value by which the counter associated with the semaphore identified by the first two arguments must be decremented (in the case of semwait) or incremented (in the case of semsignal). The value of both semaphores is initialized to 1 with the operation semsetval. By implementing these operations using actual UNIX semaphores (the exact UNIX system calls to do this are similar), the program above can be compiled and run on any UNIX machine. The state space A G of this system is shown in figure <ref type="figure" target="#fig_1">2</ref>, where the two processes are denoted by P1 and P2, and global transitions are labeled with the visible operation of the corresponding process transition. The operation exit is a visible operation whose execution is always blocking. Since all the processes are deterministic, nondeterminism in A G is caused only by concurrency.</p><p>Since we consider here closed concurrent systems, the environment of one process is formed by the other processes in the system. This implies that, in the case of a single "open" reactive system, the environment in which this system operates has to be represented, possibly using other processes. In practice, a complete representation of such an environment may not be available, or may be very complex. It is then convenient to use a simplified representation of the environment to simulate its behavior. For this purpose, we introduce a special operation "VS toss" to express a valuable feature of modeling languages, not found in programming languages: nondeterminism. This operation takes as argument a positive integer n, and returns an integer in [0, n]. The operation is visible and nondeterministic: the execution of a transition starting with VS toss(n) may yield up to n + 1 different successor states, corresponding to different values returned by VS toss.</p><p>Which properties of a concurrent system is it possible to check by examining its state space A G as defined above? Here, we focus mainly on two verification problems (other properties will be discussed later in Section 5): the detection of deadlocks and assertion violations. Deadlocks are states where the execution of the next operation of every process in the system is blocking. Deadlocks are a notorious problem in concurrent systems, and are extremely difficult to detect through conventional testing. Assertions can be specified by the user with the special operation "VS assert". This operation can be inserted in the code of any process, and is considered visible. It takes as its argument a boolean expression that can test and compare the value of variables and data structures local to the process. When "VS assert(expression)" is executed, the expression is evaluated. If the expression evaluates to false, the assertion is said to be violated. Many undesirable system properties, such as unexpected message receptions, buffer overflows and application-specific error conditions, can easily be expressed as assertion violations.</p><p>The following theorem states that deadlocks and assertion violations can be detected by exploring only the global states of a concurrent system. Theorem 1. Consider a concurrent system as defined above, and let A G denote its state space. Then, all the deadlocks that are reachable after the initialization of the system are global states, and are therefore in A G . Moreover, if there exists a state reachable after the initialization of the system where an assertion is violated, then there exists a global state in A G where the same assertion is violated.</p><p>Proof: See Appendix. This theorem justifies our choice for the "dynamic" semantics described in this section.</p><p>In the next section, we discuss how to build a representation of the state space of a concurrent system as defined above. We briefly review standard state-space exploration techniques, and show why they are not appropriate for exploring state spaces of concurrent systems whose processes are described by arbitrary programs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Existing state-space exploration techniques</head><p>In the case of models of concurrent systems, a state space A G is usually computed by performing a search of all the states that are reachable from the initial state s 0 of the model of the system. An algorithm for performing such a search is shown in figure <ref type="figure" target="#fig_2">3</ref>. This algorithm recursively explores all successor states of all states encountered during the search, starting from the initial state, by executing all enabled transitions in each state (lines 7-8). The main data structures used are a set Unexplored to store the states whose successors still have to be explored, and a set Explored (often implemented as a hash-table) to store all the states that have already been visited during the search. The set of all transitions enabled in a state s is denoted by enabled(s). The state reached from a state s after the execution of a transition t is denoted "succ(s) after t". It is easy to prove that, if A G is finite, all the states of A G are visited during the search performed by the algorithm of figure 3 <ref type="bibr" target="#b0">[1]</ref>. The order in which the search is performed (depth-first, breadth-first, etc.) depends on how the operations "add" and "take" are implemented.</p><p>It is important to note that the algorithm of figure <ref type="figure" target="#fig_2">3</ref> assumes that each state s can be represented by a unique identifier, that can be stored in the data structures Unexplored and Explored during the search. Although other search algorithms for modeling languages, such as symbolic verification methods <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b51">52]</ref>, may use other types of data structures (e.g., Binary Decision Diagrams <ref type="bibr" target="#b5">[6]</ref>) for representing state spaces, they all rely on the assumption that each state of the system has a unique representation (typically a string of bits) that is easy to compute and manipulate.</p><p>When dealing with processes described by arbitrary programs written in full-fledged programming languages, this assumption is not valid anymore. Indeed, the state of each process is determined by the values of all the memory locations that can be accessed by the process and influence its behavior (including activation records associated with procedure calls). This information is typically far too large and complex to be efficiently and unambiguously encoded by a string of bits, which could then be saved in memory at each step of the state-space exploration.</p><p>However, nothing prevents us from systematically searching the state space of a concurrent system without storing any intermediate states in memory, by successively enumerating and exploring all possible sequences of transitions in the state space. Let us call such a search a state-less search. Of course, if the state space A G contains cycles, a state-less search through it will not terminate, even if A G is finite (unless an upper bound on the number of states of A G is known). Even state-less searches of "small" finite acyclic state spaces (e.g., composed of only a few thousand states) may not terminate in a reasonable amount of time. To illustrate this phenomenon, let us consider the dining-philosophers example again. (The state space of this system does not contain any cycles.) The number of transitions explored by a classical search (Algorithm 1) and by a state-less search are compared in figure <ref type="figure" target="#fig_4">5</ref>,for various numbers N of processes. The run-time of both algorithms is proportional to the number of explored transitions. One clearly sees that the state-less search is much slower than the classical one. In the case of four processes, the state-less search explores 386,816 transitions, while they are only 708 transitions in A G . While every transition of A G is executed exactly once during a classical search, every transition of A G is executed on average about 546 times during a state-less search! This tremendous difference is due to the numerous re-explorations of unstored parts of the state space during the state-less search.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">An efficient state-less search algorithm</head><p>The state-less search technique can be viewed as a particular case of state-space caching <ref type="bibr" target="#b31">[32,</ref><ref type="bibr" target="#b37">38,</ref><ref type="bibr" target="#b42">43]</ref>, a memory management technique for storing the states encountered during a classical search performed in depth-first order. State-space caching consists of storing all the states of the current explored path plus as many other states as possible given the remaining amount of available memory. It thus creates a restricted cache of selected states that have already been visited. This method never tries to store more states than possible in the cache. A state-less search corresponds to the extreme case where the cache does not contain any state at all.</p><p>State-space caching suffers the same drawback as the state-less search: multiple redundant explorations of large unstored parts of the state space yield an unacceptable blow-up of the run-time. Indeed, almost all states in the state spaces of concurrent systems are typically reached several times during the search. There are two causes for this:</p><p>1. From the initial state, the exploration of any interleaving of a single finite partial ordering of transitions of the system always leads to the same state. This state will thus be visited several times because of all these interleavings. 2. From the initial state, explorations of different finite partial orderings of transitions may lead to the same state.</p><p>In <ref type="bibr" target="#b31">[32]</ref>, it is shown that most of the effects of the first cause given above can be avoided when using a search algorithm based on the notion of sleep sets <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b35">36]</ref>. Such an algorithm dynamically prunes the state space of a concurrent system without incurring the risk of any incompleteness in the verification results. Empirical results <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b31">32]</ref> show that, in many cases, most of the states are visited only once during a state-space exploration performed with this search technique. This makes it possible not to store most of the states previously visited during the search without incurring much redundant exploration of parts of the state space.</p><p>Sleep sets belong to a broader family of algorithms, referred to as partial-order methods <ref type="bibr" target="#b26">[27]</ref>, that were developed to tackle the "state explosion" phenomenon that limits the efficiency and applicability of verification by state-space exploration. In <ref type="bibr" target="#b26">[27]</ref>, it is shown that sleep sets can be combined with another pruning technique based on the notion of persistent sets. Using both techniques simultaneously preserves the beneficial properties of sleep sets outlined in the previous paragraph while substantially reducing the number of states and transitions that have to be visited.</p><p>In this section, we present a new state-space exploration algorithm that combines a stateless search with the persistent-set and sleep-set techniques. Before turning to the presentation of this algorithm, we briefly recall some basic principles of partial-order methods.</p><p>The basic idea behind partial-order methods that enables them to check properties of A G without constructing the whole of A G is the following: A G contains many paths that correspond simply to different execution orders of the same process transitions. If these transitions are "independent", for instance because they are executed by noninteracting processes, then changing their order will not modify their combined effect.</p><p>This notion of independency between transitions and its complementary notion, the notion of dependency, can be formalized by the following definition (adapted from <ref type="bibr" target="#b44">[45]</ref>). Definition 1. Let T be the set of system transitions and D ⊆ T × T be a binary, reflexive, and symmetric relation. The relation D is a valid dependency relation for the system iff for all t 1 , t 2 ∈ T , (t 1 , t 2 ) ∈ D (t 1 and t 2 are independent) implies that the two following properties hold for all global states s in the global state space A G of the system: This definition characterizes the properties of possible "valid" dependency relations for the transitions of a given system. In practice, it is possible to give easily checkable syntactic conditions that are sufficient for transitions to be independent. In a concurrent system as defined in Section 2, dependency can arise between transitions of different processes that perform (visible) operations on the same communication objects. For instance, two wait operations on a binary semaphore are dependent when they are enabled, while two signal operations on a same non-binary semaphore are independent. Carefully defining dependencies between operations on communication objects is by no means a trivial task. We refer the reader to <ref type="bibr" target="#b26">[27]</ref> for a detailed presentation of that topic.</p><p>All partial-order algorithms follow the same basic pattern: they operate as classical statespace searches except that, at each state s reached during the search, they compute a subset T of the set of transitions enabled at s, and explore only the transitions in T , the other enabled transitions are not explored. Such a search is called a selective search. It is easy to see that a selective search through A G only reaches a subset (not necessarily proper) of the states and transitions of A G .</p><p>Two main techniques for computing such sets T have been proposed in the literature: the persistent-set and sleep-set techniques. The first technique actually corresponds to a whole family of algorithms <ref type="bibr" target="#b34">[35,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b52">53,</ref><ref type="bibr" target="#b53">54,</ref><ref type="bibr" target="#b59">60]</ref>. In <ref type="bibr" target="#b26">[27]</ref>, it is shown that all these algorithms compute "persistent sets". Intuitively, a subset T of the set of transitions enabled in a state s of A G is called persistent in s if all transitions not in T that are enabled in s, or in a state reachable from s through transitions not in T , are independent with all transitions in T . In other words, whatever one does from s, while remaining outside of T , does not interact with or affect T . Formally, we have the following <ref type="bibr" target="#b34">[35]</ref>. Definition 2. Aset T of transitions enabled in a state s is persistent in s iff, for all nonempty sequences of transitions</p><formula xml:id="formula_1">s = s 1 t 1 → s 2 t 2 → s 3 • • • t n-1 → s n t n → s n+1 from s in A G and including only transitions t i ∈ T , 1 ≤ i ≤ n, t n is independent with all transitions in T .</formula><p>Note that the set of all enabled transitions in a state s is trivially persistent since nothing is reachable from s by transitions that are not in this set. It is beyond the scope of this paper to present algorithms for computing persistent sets. In a nutshell, these algorithms infer persistent sets from the static structure of the system being verified (such as "process x can perform operation y on communication object z ). They differ by the type of information about the system that they use. The aim of these algorithms is to obtain the smallest possible nonempty persistent sets. See <ref type="bibr" target="#b26">[27]</ref> for several such algorithms and a comparison of their complexity.</p><p>The second technique for computing the set of transitions T to consider in a selective search is the sleep set technique <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b35">36]</ref>. This technique does not exploit information about the static structure of the system, but rather about the past of the search. Used in conjunction with a persistent set algorithm, sleep sets can further reduce the number of explored states and transitions.</p><p>An algorithm that combines persistent sets and sleep sets with a state-less search is shown in figure <ref type="figure" target="#fig_3">4</ref>. This algorithm performs a selective depth-first search (DFS) in the state space of a concurrent system. The data structure Stack contains the sequence of transitions that leads from the initial global state s 0 to the current global state being explored. A set denoted by Sleep is associated with each global state reached during the search, i.e., with each call to the procedure DFS. The sleep set associated with a global state s is a set of transitions that are enabled in s but will not be explored from s. The sleep set associated with the initial global state s 0 is the empty set. Each time a new global state s is encountered during the search, a call to DFS is executed. The sleep set that is associated with s is passed as argument. In line 6, a new set of transitions is selected to be explored from s. Persistent Set() returns a persistent set in the current global state s that is nonempty if there exist transitions enabled in s. Lines 11 and 14 describe how to compute the sleep sets associated with the successor global states of s from the value of its sleep set Sleep. In line 10, a transition t is executed from s. The procedure Execute(t) returns after a new global state has been reached by the concurrent system. Then all the transitions of Sleep that are independent with t are passed into the sleep set associated with that new global state (line 11). Once the search from that new state (and hence the corresponding call to DFS) is completed, the exploration of the other transitions selected to be explored from s may proceed. The concurrent system is then brought back to the global state s in line 13. (This can be done by reinitializing the system and reexecuting the sequence of transitions in Stack, for instance.) Next, transition t, i.e., the last transition explored from s, is added to Sleep in line 14.</p><p>The correctness of Algorithm 2 is established by the following theorem.</p><p>Theorem 2. Consider a concurrent system as defined in Section 2, and let A G denote its state space. Assume A G is finite and acyclic. Then, all the deadlocks in A G are visited by Algorithm 2. Moreover, if there exists a global state in A G where an assertion is violated, then there exists a global state visited by Algorithm 2 where the same assertion is violated.</p><p>Proof: See Appendix.</p><p>In other words, deadlocks and assertion violations can be detected using Algorithm 2. As discussed in the previous section, the termination of Algorithm 2 is guaranteed only when the state space A G is finite and does not contain any cycles. In practice, Algorithm 2 can be used to efficiently explore the state space of any concurrent system, whether its state space is acyclic or not. Finally note that Algorithm 2 is different from the algorithms combining persistent sets and sleep sets that appeared in <ref type="bibr" target="#b26">[27]</ref>. Indeed, with a state-less search, different sleep sets associated with the same global state (corresponding to different visits of that state via different paths from s 0 ) cannot interfere with each other during the search. Moreover, cycles cannot be detected in the context of a state-less search, which makes the use of the provisos discussed in <ref type="bibr" target="#b26">[27]</ref> impossible.</p><p>Results of experiments with Algorithm 2 for the dining-philosophers example are presented in figure <ref type="figure" target="#fig_4">5</ref>. Thanks to the use of persistent sets and sleep sets, the run-time explosion of the state-less search is now avoided. Moreover, they yield a significant reduction in the number of transitions that need be explored. Although Algorithm 2 does not store any state in memory, it explores fewer transitions than Algorithm 1!</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">VeriSoft</head><p>VeriSoft is a tool for systematically exploring the state space of a concurrent system as defined in Section 2. Systematic state-space exploration is performed by controlling and observing the execution of all the visible operations of the concurrent processes of the system. Every process of the concurrent system to be analyzed is mapped to a UNIX process. The execution of the system processes is controlled by an external process, called the scheduler (see figure <ref type="figure" target="#fig_5">6</ref>). This process observes the visible operations performed by processes inside the system, and can suspend their execution. By resuming the execution of (the next visible operation of) one selected system process in a global state, the scheduler can explore one transition in the state space A G of the concurrent system. The scheduler also contains an implementation of a state-less search using persistent sets and sleep sets similar to Algorithm 2. In order to prevent the state-less search from looping forever in cycles of the state space being explored, the depth of the search is limited. When this maximum depth is reached, the scheduler reinitializes the system in order to explore alternative paths in the state space.</p><p>When a deadlock or an assertion violation is detected, the search is stopped, and a scenario formed by all the transitions currently stored in Stack (see figure <ref type="figure" target="#fig_3">4</ref>) is exhibited to the user. An interactive graphical simulator/debugger is also available for replaying scenarios and following their executions at the instruction or procedure/function level (see figure <ref type="figure" target="#fig_6">7</ref>).Values of variables of each process can be examined interactively. Using the VeriSoft simulator, the user can also explore any path in the state space of the system with the same set of debugging tools.</p><p>It is thus assumed that there are exactly two sources of nondeterminism in the concurrent systems considered here: concurrency and calls to the special visible operation VS toss used to model nondeterminism as described in Section 2. When this assumption is satisfied, the VeriSoft scheduler has complete control over nondeterminism. It can thus reproduce  any scenario leading to an error found during a state-space search and can also guarantee, from a given initial state, complete coverage of the state space up to some depth.</p><p>In addition to deadlocks and assertion violations, VeriSoft also checks for divergences and livelocks. A "divergence" occurs when a process does not attempt to execute any visible operation within a given (user-specified) amount of time. Divergences may be caused by segmentation faults, non-terminating loops, etc. A "livelock" occurs when the execution of the next visible operation of some process is blocking during a sequence of more than a given (user-specified) number of successive states in the state space. Note that these definitions of divergence and livelock differ from the standard definitions for these notions, which correspond to liveness properties, i.e., properties that can only be violated by infinite sequences of operations or transitions <ref type="bibr" target="#b45">[46,</ref><ref type="bibr" target="#b48">49]</ref>. In contrast, our notions of divergence and livelock can be violated by finite sequences of operations or transitions, and therefore are actually safety properties. Indeed, a state-less search cannot detect cycles, and is thus restricted to the verification of safety properties.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Applications</head><p>During the last five years, VeriSoft has been applied successfully for analyzing several software products developed in Lucent Technologies. Some of these projects have been documented in published papers. For instance, <ref type="bibr" target="#b29">[30]</ref> describes the analysis of the "Heart-Beat Monitor" of a 4ESS switch, a critical component of a telephone switch, while <ref type="bibr" target="#b8">[9]</ref> reports on the analysis of several releases of the call-processing software running on Lucent's CDMA base-stations, a multi-billion dollar product line. These projects range from so-called "whitebox" unit testing of small critical applications described by at most a few thousands of lines of code, as in the case of <ref type="bibr" target="#b29">[30]</ref>, to "black-box" system testing of huge applications involving many concurrent components implemented by millions of lines of code, as in the case of <ref type="bibr" target="#b8">[9]</ref>. In each case, significant previously-unknown bugs were revealed through the use of VeriSoft.</p><p>The fact that VeriSoft detected errors that escaped traditional testing is not surprising, considering the following factors:</p><p>• Complex concurrent reactive systems are notorious for exhibiting a very large number of different behaviors. • Traditional testing is of limited help since test coverage is bound to be only a minute fraction of all possible behaviors of the system. • Systematic state-space exploration can expose previously unknown bugs by exercising the system under test in enormously more possible ways.</p><p>A key strength of the VeriSoft approach compared to other types of model checking is that it is extremely versatile: VeriSoft does not rely on any specific assumption about the code representing the behavior of processes, which can be written in any language and does not even need to be available. 3 Applying VeriSoft to a program written in a new language merely requires integrating VeriSoft into a test environment for that language, as described later in this section.</p><p>A second key strength of the VeriSoft approach is that it is scalable, in the following sense: the applicability of VeriSoft depends on the amount of nondeterminism in the system being analyzed, not on the size of the code describing the application itself. Nondeterminism comes from either concurrency or explicit nondeterminism introduced by the user using the special VS toss operation. In the case of tens of concurrent processes, the amount of nondeterminism due to concurrency in the system is typically too large for VeriSoft to be very effective. An alternative is then to deliberately "hide" some system processes and communication objects from VeriSoft in order to reduce the amount of nondeterminism visible to the tool and hence reduce the size of the state space being explored. Since the user has the responsibility of declaring what operations are visible to VeriSoft anyway, omitting some processes or communication objects is easy. For instance, an entire communication switch can be be viewed as a huge black-box and multiple concurrent test-drivers controlled by VeriSoft can simulate various sequences of external events occurring at different interfaces of the switch (simulating other switches, user traffic and hardware failures, for example); even though VeriSoft does not control the nondeterminism (if any) inside the black-box itself with this approach, this can still be a very challenging test for the application. This type of approximation is necessary for analyzing applications of the size and complexity of the CDMA call-processing software <ref type="bibr" target="#b8">[9]</ref>. Obviously, if all the sources of nondeterminism are not under the control of VeriSoft, completeness of verification results and reproducibility of error traces cannot be guaranteed anymore.</p><p>We now discuss other practical considerations associated with this approach to software model checking.</p><p>Test automation. Using VeriSoft for testing the correctness of a software product requires test automation, i.e., the ability to run and evaluate tests automatically. As testers know, developing a testing infrastructure that provides test automation can be in itself a significant effort. When test automation is already available, starting to take advantage of VeriSoft to significantly increase test coverage is usually easy since it may just involve modifying existing test scripts into nondeterministic ones and/or running multiple test scripts in parallel under the control of the VeriSoft scheduler. Integration into testing environment. VeriSoft needs to be integrated into the execution environment of the system under test so that it can control at run-time the execution of system processes. The primary task involved here is to declare which system calls of which processes are to be intercepted by VeriSoft and viewed as visible operations. Minimally, visible operations may simply include operations such as VS toss and VS assert for "black-box" testing of large applications. In the case of unit testing of applications containing only a handful of processes, system calls related to communication can also be declared as visible by mapping these to corresponding operations included in built-in VeriSoft libraries; for instance, sending a message (using whatever protocol is used by the application) can be mapped to a VeriSoft send-to-queue operation. Note that the actual system/protocol call need not be replaced by send to queue, it can just be annotated with the occurrence of that event. Mapping system calls related to communication to operations understood by VeriSoft can be tricky when complicated and unusual communication objects are used. Instrumenting the execution itself can be done by overriding system calls at compile/link time, or via a binary-code or OS-kernel instrumentation, or through the use of wrap-up functions intercepting events going in and out of the application being tested. Test drivers. Like most model checkers, VeriSoft requires an executable representation of the environment of the system being analyzed in order to drive its executions. Thanks to the VS toss operation supported by VeriSoft, nondeterministic programs can be used as environment models (test drivers). Nondeterminism makes it possible to write very compact and elegant programs for generating large numbers of sequences of input events (test scenarios). Since the size of the state space depends on the amount of nondeterminism in the system, VS toss should be used with care. Specifying properties. Although VeriSoft can simply be used to detect standard errors such as deadlocks and segmentation faults, it is preferable to specify application-specific properties by means of assertions in test drivers in order to check the functional correctness of the software application. Obviously, assertions previously inserted in the code itself by application developers can also be tested. Another possibility is to use tools (like Purify) that automatically insert assertions to check for standard programming errors such as memory leaks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>State explosion. The main practical limitation of VeriSoft, and of model checking in general,</head><p>is the state-explosion problem: it is very easy for the user to define a state space that is too large to be explored exhaustively. State explosion can be controlled by limiting the amount of nondeterminism visible to VeriSoft, as discussed above. However, hiding nondeterminism due to concurrency inside the application being tested may result in errors being missed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Comparison with related work</head><p>Essentially two approaches to software model checking have been proposed and are still actively being investigated. The first approach is the one presented in the previous sections and originally introduced in <ref type="bibr" target="#b27">[28]</ref>. The second approach consists of automatically extracting a model out of a software application by statically analyzing its code and abstracting away details, applying traditional model checking to analyze this abstract model, and then mapping abstract counter-examples (if any) back to the code. The investigation of this second approach can be traced back to early attempts to analyze concurrent programs written in concurrent programming languages such as Ada (e.g., <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b46">47,</ref><ref type="bibr" target="#b49">50,</ref><ref type="bibr" target="#b58">59]</ref>). Other relevant work includes static analyses geared towards analyzing communication patterns in concurrent programs (e.g., <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b61">62]</ref>). Recently, several efforts have started aiming at providing model-checking tools based on source-code abstraction for mainstream popular programming languages such as C and Java. For instance, Bandera <ref type="bibr" target="#b17">[18]</ref> can translate Java programs to the (finite-state) input languages of existing model checkers like SMV and SPIN, using user-guided abstraction, slicing and abstract interpretation techniques. SLAM <ref type="bibr" target="#b1">[2]</ref> can translate sequential C programs to "boolean programs", which are essentially inter-procedural control-flow graphs extended with boolean variables, using an iterative automatic abstraction-refinement process based on the use of predicate abstraction and a specialized model-checking procedure. Feaver <ref type="bibr" target="#b41">[42]</ref> can translate C programs into Promela, the input language of the SPIN model checker, using user-specified abstraction rules. Java PathFinder <ref type="bibr" target="#b62">[63]</ref> can perform model checking of multi-threaded Java programs using a blend of static and dynamic program-analysis techniques. For the specific classes of concurrent programs that these tools can handle, the use of abstraction techniques can produce a "conservative" model of a program that preserves basic information about the execution and communication patterns taking place in the system executing the program. Analyzing such a model using standard model-checking techniques can then prove the absence of certain types of errors in the system, without ever executing the program itself. In contrast, VeriSoft is based on the dynamic observation of the "actual" processes of the concurrent system. This makes possible a much closer examination of the behaviors of the system, and the detection of subtle implementation errors that would typically be missed in practice using abstraction techniques, because either the abstraction does not preserve all the details relevant to that particular error, or because it would be hidden in a multitude of higher-level warnings. Moreover, VeriSoft does not rely on any specific assumption about the static structure of the programs used to represent the behavior of processes, which can actually be written in any language, or even be unavailable. In summary, the dynamic (VeriSoft) and static (abstraction-based) approaches to software model checking inherit the well-known advantages and limitations of, respectively, dynamic and static program analysis, and are therefore complementary. The closest alternative to the type of software model checking developed in our work is perhaps specification-based testing frameworks for reactive programs (e.g., <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b55">56,</ref><ref type="bibr" target="#b63">64]</ref>). Given a specification of the input/output behavior of the system being tested represented by a finite-state machine (or a product of finite-state machines <ref type="bibr" target="#b24">[25]</ref>) expressed in some modeling language, these techniques and tools can automatically generate a set of test sequences that cover the specification according to various coverage criteria. In contrast, VeriSoft generates test scenarios dynamically at run-time: state-space exploration is performed while the system is executing, and the outcome of previous test sequences (i.e., paths in the state space) typically influences the generation of following test sequences (by the use of partial-order reduction methods). Moreover, using VeriSoft does not require a specification of the input/output behavior of the system under test written in some specific FSM modeling language; instead, the environment of an open system can be represented by one or several processes executing arbitrary code, and the joint behavior of all these processes is then checked for "global" properties when exploring the resulting state space, in the style of what is usually done with model checking.</p><p>Another related and complementary area of research concerns the design of debuggers for distributed and parallel programs (e.g., <ref type="bibr" target="#b9">[10]</ref>). These tools are used to monitor the execution of concurrent processes running in their actual environment. Work in this area discuss techniques for, among others, (1) instrumenting the execution of processes while minimizing the impact of the instrumentation on the timing (scheduling) between the different processes, (2) storing a minimum amount of information for faithfully replaying ("roll-back") very long scenarios leading to errors, and (3) obtaining a consistent representation of a state ("snapshot") of a distributed/concurrent system. These problems are avoided with our approach since (1) all the sources of nondeterminism are fully controlled by the VeriSoft scheduler, (2) the purpose of our approach is to make possible the systematic analysis of short executions of a concurrent system, rather than analyzing very long ones (e.g., containing millions of process transitions), and (3) our analysis is performed by examining only the global states of the concurrent system, which the scheduler can easily re-create. Note that VeriSoft does not generally preserve quantitative properties (related to timing, performance, etc.) of the whole concurrent system.</p><p>Other complementary work includes tools (like Purify) that automatically instrument code or executable files for monitoring program executions and detecting at run-time standard programming and memory-management errors such as array out-of-bounds and memory leaks. Also, several tools for monitoring at run-time the behavior of a reactive program and comparing this behavior against an application-specific high-level specification (typically a finite-state automaton or a temporal-logic formula) have recently been developed (e.g., <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b40">41]</ref>). These tools can be used in conjunction with VeriSoft in order to increase the likelihood of errors being detected.</p><p>We conclude this section by mentioning other work that either makes use of VeriSoft or was directly inspired by it. Boigelot and Godefroid <ref type="bibr" target="#b4">[5]</ref> describes how to automatically synthesize a finite-state machine that simulates all the sequences of visible operations of a given process that were observed during a state-space exploration performed by VeriSoft. Colby et al. <ref type="bibr" target="#b10">[11]</ref> discusses algorithms for automatically closing an open concurrent reactive C program with its most general environment, i.e., the environment that can provide any input at any time to the program; the result is a nondeterministic closed (i.e., self-executable)</p><p>program that can exhibit all the possible behaviors of the original program and can be analyzed with VeriSoft. Godefroid <ref type="bibr" target="#b33">[34]</ref> studies how to adapt model-checking symmetry reduction methods to make these compatible with a state-less search, i.e., without relying on explicit encodings of system states. Stoller <ref type="bibr" target="#b57">[58]</ref> discusses how to optimize a (state-less) search in the state space of a multi-threaded program whose threads use locks to protect access to shared data structures. Applications of VeriSoft to analyze programs specified using domain-specific primitives implemented as Java libraries are described in <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b32">33]</ref>. Godefroid and Khurshid <ref type="bibr" target="#b29">[30]</ref> discusses how to exploit heuristics using genetic algorithms to guide a search towards error states in very large state spaces; this framework has been implemented in conjunction with VeriSoft and evaluated with several examples of C programs. Benedikt et al. <ref type="bibr" target="#b36">[37]</ref> presents an overview of a tool for automatically discovering and systematically exploring Web-site execution paths; this tool includes VeriSoft as one of its components.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Conclusions</head><p>We have presented a new search technique for efficiently exploring the state space of a concurrent system composed of processes described by programs written in full-fledged programming languages such as C or C++. For finite acyclic state spaces, we showed that our algorithm can be used for detecting deadlocks and assertion violations without incurring the risk of any incompleteness in the verification results. In practice, our algorithm can be used for systematically and efficiently testing the correctness of any concurrent system, whether its state space is acyclic or not. This algorithm is built upon existing state-space pruning techniques known as partial-order methods <ref type="bibr" target="#b26">[27]</ref>. It extends the scope of verification by state-space exploration from modeling languages to programming languages.</p><p>This algorithm has been implemented in VeriSoft. Like a traditional model checker explores the state space of a system modeled as the product of concurrent finite-state components, VeriSoft systematically explores the "product" of concurrent (Unix-like) processes by using a run-time scheduler for driving the entire application through the states and transitions of its state space. It thus adapts model checking into a form of systematic testing that simulates the effect of model checking while being applicable to concurrent processes executing arbitrary code.</p><p>Two features distinguish VeriSoft from every other "model checker" (i.e., systematic state-space exploration tool) we are aware of: (1) VeriSoft is the first model checker that does not require the use of any specific modeling or programming language; (2) VeriSoft is the first model checker that does not compute and store representations of visited system states and performs a state-less search instead.</p><p>Since made publicly available in 1999, VeriSoft has been licensed to hundreds of users in industry and academia. Inside Lucent Technologies, it was applied successfully to analyze several software products in various business units and application domains (switch maintenance, call processing, network management, etc.). Because VeriSoft can automatically generate, execute and evaluate thousands of tests per minute, it can quickly reveal behaviors that are virtually impossible to detect using conventional testing techniques.</p><p>We will also make use of the two following lemmas from <ref type="bibr" target="#b26">[27]</ref>. These two lemmas state basic properties of persistent sets. Lemma 4.2 of <ref type="bibr" target="#b26">[27]</ref>. Let s be a state in A G , and let d be a deadlock reachable from s in A G by a nonempty sequence w of transitions. For all w i ∈ [w], let t i denote the first transition of w i . Let Persistent Set(s) be a nonempty persistent set in s. Then, at least one of the transitions t i is in Persistent Set(s). Lemma 6.8 of <ref type="bibr" target="#b26">[27]</ref>. Let s be a state in A G , and let w be a nonempty sequence of transitions from s in A G . For all w i ∈ [w] from s in A G , let t i denote the first transition of w i . Let Persistent Set(s) be a nonempty persistent set in s. If none of the t i are in Persistent Set(s), then all the transitions in Persistent Set(s) are independent with all the transitions in w.</p><p>To establish the correctness of Algorithm 2, we first prove the following lemma. Assume that all that concerns sleep sets in Algorithm 2 is not implemented (or equivalently that the sleep set associated with every global state reached during the search is empty). We now prove that, under this assumption, if there exists a sequence of transitions in A G from s 0 to a deadlock or to a state s where an assertion a is violated, then Algorithm 2 without using sleep sets will eventually visit this deadlock or a state where the assertion a is violated, provided that A G is finite and acyclic. Lemma 1. Consider a concurrent system as defined in Section 2, and let A G denote its state space. Assume A G is finite and acyclic. Let A R be the state space explored by Algorithm 2 without using sleep sets. Let s be a state in A R . Let d be a deadlock reachable from s in A G by a sequence w of transitions. Then, d is also reachable from s in A R . Moreover, if s is a state where an assertion a is violated that is reachable from s in A G by a sequence w of transitions, then there exists a state (not necessarily s ) reachable from s in A R where the assertion a is violated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof:</head><p>The proof proceeds by induction on the length of w and w . For |w| = 0 and |w | = 0, the result is immediate. Now, assume the theorem holds for paths (sequences of transitions) of length n ≥ 0 and let us prove that it holds for paths of length n + 1.</p><p>Assume a deadlock d can be reached from s by a path w of length n + 1 in A G . For all w i ∈ [w], let t i denote the first transition of w i . By Theorem 3.10 of <ref type="bibr" target="#b26">[27]</ref>, we know that, for all w i ∈ [w], s w i ⇒ d. Let Persistent Set(s) be the nonempty persistent set that is selected in s by Algorithm 2, i.e., the set of transitions that are explored from s in A R . By Lemma 4.2 of <ref type="bibr" target="#b26">[27]</ref>, we know that at least one of the transitions t i is in Persistent Set(s). Since t i is in Persistent Set(s), it is explored from state s, and thus a state is reached in A R from which a path of length n leads to the deadlock d. This together with the inductive hypothesis proves the lemma for the deadlock case.</p><p>We now consider the case of an assertion violation. Assume that a state s where an assertion a is violated can be reached from s by a path w of length n + 1 in A G . Let Persistent Set(s) be the nonempty persistent set that is selected in s by Algorithm 2, i.e., the set of transitions that are explored from s in A R . For all w i ∈ [w ], let t i denote the first transition of w i . By Theorem 3.10 of <ref type="bibr" target="#b26">[27]</ref>, we know that, for all w i ∈ [w ], s w i ⇒ s . If at least one of the transitions t i is in Persistent Set(s), it is explored from state s, and thus a state is reached in A R from which a path of length n leads to s .</p><p>Otherwise, by applying Lemma 6.8 of <ref type="bibr" target="#b26">[27]</ref> to s and w , we know that all the transitions in Persistent Set(s) are independent with all the transitions in w . Consequently, for every state s j reached after executing one transition in Persistent Set(s) in A R , the sequence of transition w is still executable from s j in A G and leads to a state s j where the assertion a is violated (this follows from Definition 1). By applying the same reasoning to any state s j and since all the executions of the system are finite (since its state space is finite and acyclic), one concludes that a transition t i is eventually executed from a successor state s k of s such that all the transitions from s to s k are independent with all the transitions in w . After the execution of t i from s k , a state s l is reached in A R from which a path of length n in A G leads to a state where the assertion a is violated. This together with the inductive hypothesis proves the lemma for the case of an assertion violation.</p><p>From Lemma 1 it is then immediate to conclude that a state-less search using only persistent sets and started in the initial state of A G will detect all the deadlocks and assertion violations in A G . We now show that the use of sleep sets as described in Algorithm 2 preserves this result.</p><p>Theorem 2. Consider a concurrent system as defined in Section 2, and let A G denote its state space. Assume A G is finite and acyclic. Then, all the deadlocks in A G are visited by Algorithm 2. Moreover, if there exists a global state in A G where an assertion is violated, then there exists a global state visited by Algorithm 2 where the same assertion is violated.</p><p>Proof: Consider a deadlock d or a state s where an assertion is violated that is reachable from the initial global state s 0 . Imagine that we fix the order in which transitions selected in a given state are explored and that we first run Algorithm 2 without sleep sets. Let A R be the state space explored during this run. Assume that, for every state s in A R , the transitions explored from s are sorted from left to right following the order in which they are explored: t 1 is to the left of t 2 if t 1 is explored before t 2 . Then, we run Algorithm 2 with sleep sets while still exploring transitions in the same order. The important point is that the order used in both runs is the same, the exact order used is irrelevant. By Lemma 1, we know that, if d is a deadlock, d is visited by Algorithm 2 without sleep sets, while if an assertion a is violated in s , a state s where the same assertion is violated is visited by Algorithm 2 without sleep sets. We now prove that the leftmost path in A R leading to d or to a state where the assertion a is violated is still explored in the second run when using Algorithm 2 with sleep sets.</p><p>Let p = s 0</p><formula xml:id="formula_2">t 0 → s 1 t 1 → s 2 . . . s n-1 t n-1</formula><p>→ s be this path. The only reason why it might not be fully explored (i.e., until s is reached) by the algorithm using sleep sets is that some transition t i of p is not taken because it is in the sleep set associated with s i . This means that t i has been added to the sleep set associated with some previous state of the path p and then passed along p until s i . Let us prove that this is impossible.</p><p>Assume that t i is in the sleep set associated with state s i , denoted s i .Sleep, during the exploration of the path p. Hence, t i has been added to the sleep set associated with some previous state s j , j &lt; i, of the path p and passed in the sleep set associated with the successor states of s j along the path p until s i . Formally, t i ∈ s j .Sleep when s j is visited along this path and t i ∈ s k .Sleep for all states s k , j &lt; k ≤ i. This implies that t i has been explored before t j from s j since a transition is introduced in the sleep set after it has been explored (line 14 of Algorithm 2). Moreover, all transitions that occur between t j and t i in p, i.e., all t k such that j ≤ k &lt; i, are independent with respect to t i . Indeed, if this was not the case, t i would not be in s i .Sleep since transitions that are dependent with the transition taken are removed from the sleep set (line 11 of Algorithm 2).</p><p>Consequently, t i t j . . . ⇒ s i+1 from s j , and since t i is explored before t j in s j , the application of Lemma 1 to the state reached after the execution of t i from s j implies that the path p is not the leftmost path in A R leading to d or to a state where the assertion a is violated. A contradiction.</p><formula xml:id="formula_3">t</formula><p>Finally, it is worth noticing that all the above results also hold when a valid conditional dependency relation is used. Moreover, in that case, the above results hold without requiring the valid conditional dependency relation to be weakly uniform <ref type="bibr" target="#b26">[27]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Example of concurrent C program simulating dining philosophers.</figDesc><graphic coords="4,176.86,148.43,240.00,360.48" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Global state space for the two-dining-philosophers system.</figDesc><graphic coords="5,120.36,148.95,352.68,108.96" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Algorithm 1-classical search.</figDesc><graphic coords="6,188.86,490.78,216.00,168.48" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Algorithm 2-state-less depth-first search using persistent sets and sleep sets.</figDesc><graphic coords="10,188.86,148.75,216.00,200.16" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Comparison of performances for the dining-philosophers system.</figDesc><graphic coords="11,142.36,149.15,309.24,176.76" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Overall architecture of VeriSoft (in automatic state-space exploration mode).</figDesc><graphic coords="12,182.69,558.82,227.91,104.43" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. Screenshot of VeriSoft in interactive simulation mode.</figDesc><graphic coords="13,124.06,148.64,345.60,270.03" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>1. if t 1 is enabled in s and s t 1 → s , then t 2 is enabled in s iff t 2 is enabled in s (independent transitions can neither disable nor enable each other); and 2. if t 1 and t 2 are enabled in s, then there is a unique state s such that s</figDesc><table><row><cell>t 1 t 2 ⇒ s and s</cell><cell>t 2 t 1 ⇒ s</cell></row><row><cell>(commutativity of enabled independent transitions).</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>i-1 (the sequence t j . . . t i-1 t i where t i has been moved to the first position) is in [t j . . . t i-1 t i ]. Thus, t i t j . . . t i-1 and t j . . . t i-1 t i are two interleavings of a single trace, and hence lead to the same state: s j t i t j ...t i-1 ⇒ s i+1 . Since there is a path s j t i t j ...t i-1</figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>I wish to warmly thank all the persons-current and former Bell Labs colleagues, VeriSoft users inside and outside Lucent Technologies, and fellow researchers-who contributed to this project by their valuable comments and suggestions. I also thank Scott Stoller and Willem Visser for encouraging me to write this paper, and the anonymous reviewers for helpful comments. VeriSoft can be downloaded from http://www.bell-labs.com/projects/verisoft.</p><p>A previous version of this paper appeared in the proceeding of the 24th ACM Symposium on Principles of Programming Languages (POPL'97) <ref type="bibr" target="#b27">[28]</ref>.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Appendix A: Correctness proofs Theorem 1. Consider a concurrent system as defined in Section 2, and let A G denote its state space. Then, all the deadlocks that are reachable after the initialization of the system are global states, and are therefore in A G . Moreover, if there exists a state reachable after the initialization of the system where an assertion is violated, then there exists a global state in A G where the same assertion is violated.</p><p>Proof: By definition, a deadlock is a state where the execution of the next operation of every process in the system is blocking. Since we assumed that only executions of visible operations may be blocking, all deadlocks are global states.</p><p>Let s be a reachable state where an assertion a is violated. Let P i be the process containing the assertion a. We know that the next operation to be executed by P i in s is the assertion a, which is a visible operation. For every process P j other than P i , let o j denote the next visible operation that process P j will eventually execute from s. Consider the global state s where, for all processes P j , j = i, the next operation to be executed by P j is the visible operation o j , and the next operation of process P i is the assertion a. Clearly, the global state s is reachable from state s. Moreover, since only invisible operations may have been executed from s to s , assertion a is still violated in s . (The execution of invisible operations in a process may not change the value of any variable or data structure local to another process.) Finally, since s is reachable from s which is itself reachable after the initialization of the system, there exists a concurrent execution of the system that reaches the global state s after the initialization of the system. Any sequence w of process transitions such that the sequence of visible operations in w can be observed during the concurrent execution leading to s defines a path from s 0 to s in the global state space A G of the system. Therefore, s is in A G .</p><p>Let us now turn to the proof of Theorem 2. To establish this result, we use the notion of Mazurkiewicz's traces <ref type="bibr" target="#b50">[51]</ref>. Traces are defined as equivalence classes of sequences of transitions. Given a set T and a valid dependency relation D ⊆ T × T as defined in Definition 1, two sequences over T belong to the same trace with respect to D (are in the same equivalence class) if they can be obtained from each other by successively exchanging adjacent transitions which are independent according to D. For instance, if t 1 and t 2 are two transitions of T which are independent according to D, the sequences t 1 t 2 and t 2 t 1 belong to the same trace. A trace is represented by one of its elements enclosed within brackets and, when necessary, subscripted by the alphabet T and the dependency relation. Thus the trace containing both t 1 t 2 and t 2 t 1 could be represented by [t 1 t 2 ] (T ,D) . A trace corresponds to a partial ordering of symbol occurrences and contains all linearizations of this partial order. If two independent symbols occur next to each other in a sequence of a trace, the order of their occurrence is irrelevant since they occur concurrently in the partial order corresponding to that trace. Moreover, all sequences of transitions in a trace lead to the same state if executed from the same starting state. The latter property is formalized as follows.</p><p>Theorem 3.10 of <ref type="bibr" target="#b26">[27]</ref>. Let s be a state in A G . If s</p><p>Traditionally, the term "model checking" means "to check whether a system is a model of a temporal logic formula", in the classic logical sense. This definition does not imply that a "model", i.e., an abstraction, of a system is checked. 2. Operations on objects (and hence transitions) are deterministic: the execution of a transition t in a state s leads to a unique successor state. 3. In this general discussion, the term VeriSoft is meant to denote both the current implementation of the tool and the VeriSoft approach in general, eventhough the former is obviously more limited than the latter.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">The Design and Analysis of Computer Algorithms</title>
		<author>
			<persName><forename type="first">A</forename><surname>Aho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hopcroft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ullman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1974">1974</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The SLAM Toolkit</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CAV&apos;2001 (13th Conference on Computer Aided Verification)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>CAV&apos;2001 (13th Conference on Computer Aided Verification)<address><addrLine>Paris</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001-07">July 2001</date>
			<biblScope unit="volume">2102</biblScope>
			<biblScope unit="page" from="260" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">VeriWeb: Automatically Testing Dynamic Web Sites</title>
		<author>
			<persName><forename type="first">M</forename><surname>Benedikt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Freire</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of WWW&apos;2002 (11th International World Wide Web Conference</title>
		<meeting>WWW&apos;2002 (11th International World Wide Web Conference<address><addrLine>Honolulu</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-05">May 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Model checking in practice: An analysis of the ACCESS.bus protocol using SPIN</title>
		<author>
			<persName><forename type="first">B</forename><surname>Boigelot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Formal Methods Europe&apos;96</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>Formal Methods Europe&apos;96<address><addrLine>Oxford</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1996-03">March 1996</date>
			<biblScope unit="volume">1051</biblScope>
			<biblScope unit="page" from="465" to="478" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Automatic synthesis of specifications from the dynamic observation of reactive programs</title>
		<author>
			<persName><forename type="first">B</forename><surname>Boigelot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third International Workshop on Tools and Algorithms for the Construction and Analysis of Systems (TACAS&apos;97)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the Third International Workshop on Tools and Algorithms for the Construction and Analysis of Systems (TACAS&apos;97)</meeting>
		<imprint>
			<publisher>Twente</publisher>
			<date type="published" when="1997-04">April 1997</date>
			<biblScope unit="volume">1217</biblScope>
			<biblScope unit="page" from="321" to="333" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Symbolic boolean manipulation with ordered binary-decision diagrams</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Bryant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="293" to="318" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Symbolic model checking: 10 20 states and beyond</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Burch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">J</forename><surname>Hwang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th Symposium on Logic in Computer Science</title>
		<meeting>the 5th Symposium on Logic in Computer Science<address><addrLine>Philadelphia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990-06">June 1990</date>
			<biblScope unit="page" from="428" to="439" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Structural Specification-based Testing with ADL</title>
		<author>
			<persName><forename type="first">J</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Richardson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sankar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ISSTA&apos;96 (International Symposium on Software Testing and Analysis)</title>
		<meeting>ISSTA&apos;96 (International Symposium on Software Testing and Analysis)<address><addrLine>San Diego</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-01">January 1996</date>
			<biblScope unit="page" from="62" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Software Model Checking in Practice: An Industrial Case Study</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chandra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Palm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ICSE&apos;2002 (24th International Conference on Software Engineering)</title>
		<meeting>ICSE&apos;2002 (24th International Conference on Software Engineering)</meeting>
		<imprint>
			<publisher>Orlando</publisher>
			<date type="published" when="2002-05">May 2002</date>
			<biblScope unit="page" from="431" to="441" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Techniques for debugging parallel programs with flowback analysis</title>
		<author>
			<persName><forename type="first">J.-D</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H B</forename><surname>Netzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="page" from="491" to="530" />
			<date type="published" when="1991-10">October 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Automatic verification of finite-state concurrent systems using temporal logic specifications</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Sistla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="244" to="263" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Verification of the Futurebus+ cache coherence protocol</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Hiraishi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Ness</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eleventh International Symposium on Computer Hardware Description Languages and Their Apllications</title>
		<meeting>the Eleventh International Symposium on Computer Hardware Description Languages and Their Apllications<address><addrLine>North-Holland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Model checking and abstraction</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Long</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th Annual ACM Symposium on Principles of Programming Languages</title>
		<meeting>the 19th Annual ACM Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1992-01">January 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The concurrency workbench: A semantics based tool for the verification of concurrent systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cleaveland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Parrow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Steffen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">15</biblScope>
			<biblScope unit="page" from="36" to="72" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Analyzing the communication topology of concurrent programs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Colby</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Partial Evaluation and Semantics-Based Program Manipulation</title>
		<meeting>the Symposium on Partial Evaluation and Semantics-Based Program Manipulation<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1995-06">June 1995</date>
			<biblScope unit="page" from="202" to="213" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Automatically closing open reactive programs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Colby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">J</forename><surname>Jagadeesan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 1998 ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>1998 ACM SIGPLAN Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<publisher>Montreal</publisher>
			<date type="published" when="1998-06">June 1998</date>
			<biblScope unit="page" from="345" to="357" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Constructing abstract models of concurrent real-time software</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Corbett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ISSTA&apos;96 (International Symposium on Software Testing and Analysis)</title>
		<meeting>ISSTA&apos;96 (International Symposium on Software Testing and Analysis)<address><addrLine>San Diego</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-01">January 1996</date>
			<biblScope unit="page" from="250" to="260" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Bandera: Extracting Finite-State Models from Java Source Code</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Corbett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">B</forename><surname>Dwyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hatcliff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Laubach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Pasareanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Robby</surname></persName>
		</author>
		<author>
			<persName><surname>Zheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd International Conference on Software Engineering</title>
		<meeting>the 22nd International Conference on Software Engineering</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Semantic analysis of shared-memory concurrent languages using abstract model-checking</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cridlig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Partial Evaluation and Semantics-Based Program Manipulation</title>
		<meeting>the Symposium on Partial Evaluation and Semantics-Based Program Manipulation<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1995-06">June 1995</date>
			<biblScope unit="page" from="214" to="225" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Protocol verification as a hardware design aid</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Drexler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">1992 IEEE International Conference on Computer Design: VLSI in Computers and Processors</title>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1992-10">October 1992</date>
			<biblScope unit="page" from="522" to="525" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Oracles for checking temporal properties of concurrent systems</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">K</forename><surname>Dillon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd ACM SIGSOFT Symposium on Foundations of Software Engineering</title>
		<title level="s">Software Engineering Notes</title>
		<meeting>the 2nd ACM SIGSOFT Symposium on Foundations of Software Engineering</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="140" to="153" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The temporal rover and the ATG rover</title>
		<author>
			<persName><forename type="first">D</forename><surname>Drusinsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2000 SPIN Workshop</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 2000 SPIN Workshop</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1885</biblScope>
			<biblScope unit="page" from="323" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Formal validation of virtual finite state machines</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Flora-Holmquist</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Staskauskas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Workshop on Industrial-Strength Formal Specification Techniques (WIFT&apos;95)</title>
		<meeting>Workshop on Industrial-Strength Formal Specification Techniques (WIFT&apos;95)<address><addrLine>Boca Raton</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995-04">April 1995</date>
			<biblScope unit="page" from="122" to="129" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A toolbox for the verification of LOTOS programs</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Fernandez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Garavel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Mounier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rasse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rodriguez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sifakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 14th International Conference on Software Engineering ICSE&apos;14</title>
		<meeting>of the 14th International Conference on Software Engineering ICSE&apos;14<address><addrLine>Melbourne, Australia</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1992-05">May 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Using on-the-fly verification techniques for the generation of test suites</title>
		<author>
			<persName><forename type="first">J.-C</forename><surname>Fernandez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Jard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Th</forename><surname>Jeron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Viho</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 8th Conference on Computer Aided Verification</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>8th Conference on Computer Aided Verification<address><addrLine>New Brunswick</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1996-08">August 1996</date>
			<biblScope unit="volume">1102</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Using partial orders to improve automatic verification methods</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2nd Workshop on Computer Aided Verification</title>
		<title level="s">Lecture Notes in Computer Science, Rutgers</title>
		<meeting>2nd Workshop on Computer Aided Verification</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1990-06">June 1990. 1991</date>
			<biblScope unit="volume">531</biblScope>
			<biblScope unit="page" from="321" to="340" />
		</imprint>
	</monogr>
	<note>ACM/AMS DIMACS Series</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Partial-Order Methods for the Verification of Concurrent Systems -An Approach to the State-Explosion Problem</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">1032</biblScope>
			<date type="published" when="1996-01">January 1996</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Model Checking for Programming Languages using VeriSoft</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th ACM Symposium on Principles of Programming Languages</title>
		<meeting>the 24th ACM Symposium on Principles of Programming Languages<address><addrLine>Paris</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-01">January 1997</date>
			<biblScope unit="page" from="174" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Exploiting symmetry when model-checking software</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of FORTE/PSTV&apos;99 (Formal Description Techniques and Protocol Specification, Testing and Verification)</title>
		<meeting>FORTE/PSTV&apos;99 (Formal Description Techniques and Protocol Specification, Testing and Verification)<address><addrLine>Beijing</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999-10">October 1999</date>
			<biblScope unit="page" from="257" to="275" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Model Checking Without a Model: An Analysis of the Heart-Beat Monitor of a Telephone Switch using VeriSoft</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Hanmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">J</forename><surname>Jagadeesan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGSOFT ISSTA&apos;98 (International Symposium on Software Testing and Analysis)</title>
		<meeting>ACM SIGSOFT ISSTA&apos;98 (International Symposium on Software Testing and Analysis)</meeting>
		<imprint>
			<publisher>Clearwater Beach</publisher>
			<date type="published" when="1998-03">March 1998</date>
			<biblScope unit="page" from="124" to="133" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Ensuring Privacy in Presence Awareness Systems: An Automated Verification Approach</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Herbsleb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Jagadeesan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CSCW&apos;2000 (ACM Conference on Computer Supported Cooperative Work)</title>
		<meeting>CSCW&apos;2000 (ACM Conference on Computer Supported Cooperative Work)<address><addrLine>Philadelphia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-12">December 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">State-Space Caching Revisited</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Holzmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pirottin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Methods in System Design</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1" to="15" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Automated Systematic Testing for Constraint-Based Interactive Services</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Jagadeesan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jagadeesan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Laufer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of FSE&apos;2000 (8th International Symposium on the Foundations of Software Engineering)</title>
		<meeting>FSE&apos;2000 (8th International Symposium on the Foundations of Software Engineering)<address><addrLine>San Diego</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-11">November 2000</date>
			<biblScope unit="page" from="40" to="49" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Exploring Very Large State Spaces Using Genetic Algorithms</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Khurshid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of TACAS&apos;2002 (8th Conference on Tools and Algorithms for the Construction and Analysis of Systems</title>
		<meeting>TACAS&apos;2002 (8th Conference on Tools and Algorithms for the Construction and Analysis of Systems<address><addrLine>Grenoble</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-04">April 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Refining dependencies improves partial-order verification methods</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pirottin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 5th Conference on Computer Aided Verification</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>5th Conference on Computer Aided Verification<address><addrLine>Elounda</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1993-06">June 1993</date>
			<biblScope unit="volume">697</biblScope>
			<biblScope unit="page" from="438" to="449" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Using partial orders for the efficient verification of deadlock freedom and safety properties</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wolper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Methods in System Design</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="149" to="164" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Software for analytical development of communication protocols</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Har</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>El</surname></persName>
		</author>
		<author>
			<persName><surname>Kurshan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AT&amp;T Technical Journal</title>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Tracing protocols</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Holzmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AT&amp;T Technical Journal</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2413" to="2434" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">Design and Validation of Computer Protocols</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Holzmann</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Validating SDL specifications: An experiment</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Holzmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Patti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 9th IFIP WG 6.1 International Symposium on Protocol Specification, Testing, and Verification</title>
		<meeting>9th IFIP WG 6.1 International Symposium on Protocol Specification, Testing, and Verification<address><addrLine>North-Holland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Monitoring java programs with java pathExplorer</title>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rosu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of RV&apos;</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<meeting>RV&apos;<address><addrLine>Paris</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-07">2001. July 2001</date>
			<biblScope unit="volume">55</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">A Practical Method for Verifying Event-Driven Software</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Holzmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st International Conference on Software Engineering</title>
		<meeting>the 21st International Conference on Software Engineering</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="597" to="607" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Bounded-memory algorithms for verification on-the-fly</title>
		<author>
			<persName><forename type="first">C</forename><surname>Jard</surname></persName>
		</author>
		<author>
			<persName><surname>Th</surname></persName>
		</author>
		<author>
			<persName><surname>Jeron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd Workshop on Computer Aided Verification</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>3rd Workshop on Computer Aided Verification</meeting>
		<imprint>
			<publisher>Aalborg Springer-Verlag</publisher>
			<date type="published" when="1991-07">July 1991</date>
			<biblScope unit="volume">575</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Specification-based testing of reactive software: Tools and experiments</title>
		<author>
			<persName><forename type="first">L</forename><surname>Jagadeesan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Puchol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Ramming</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Votta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th IEEE International Conference on Software Engineering</title>
		<meeting>the 19th IEEE International Conference on Software Engineering</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Defining conditional independence using collapses</title>
		<author>
			<persName><forename type="first">S</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Peled</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">101</biblScope>
			<biblScope unit="page" from="337" to="359" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Proving the correctness of multiprocess programs</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="125" to="143" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Data flow analysis of concurrent systems that use the rendezvous model of synchronization</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Clarke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Symposium on Testing, Analysis, and verification (TAV4)</title>
		<meeting>ACM Symposium on Testing, Analysis, and verification (TAV4)<address><addrLine>Vancouver</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991-10">October 1991</date>
			<biblScope unit="page" from="21" to="35" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Checking that finite state concurrent programs satisfy their linear specification</title>
		<author>
			<persName><forename type="first">O</forename><surname>Lichtenstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twelfth ACM Symposium on Principles of Programming Languages</title>
		<meeting>the Twelfth ACM Symposium on Principles of Programming Languages<address><addrLine>New Orleans</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985-01">January 1985</date>
			<biblScope unit="page" from="97" to="107" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">The Temporal Logic of Reactive and Concurrent Systems: Specification</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Non-concurrency analysis</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Masticola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">G</forename><surname>Ryder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Fourth ACM SIGPLAN Symposium on Principles &amp; Practice of Parallel programming</title>
		<meeting>Fourth ACM SIGPLAN Symposium on Principles &amp; Practice of Parallel programming<address><addrLine>San Diego</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993-05">May 1993</date>
			<biblScope unit="page" from="129" to="138" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">in Petri Nets: Applications and Relationships to Other Models of Concurrency, Advances in Petri Nets 1986</title>
		<author>
			<persName><forename type="first">A</forename><surname>Mazurkiewicz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Part II; Proceedings of an Advanced Course</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">255</biblScope>
			<biblScope unit="page" from="279" to="324" />
		</imprint>
	</monogr>
	<note>Trace theory</note>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
		<title level="m">Symbolic Model Checking</title>
		<imprint>
			<publisher>Kluwer Academic Publishers</publisher>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<title level="m" type="main">Verification of Concurrent Systems: Function and Timing</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">T</forename><surname>Overman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1981">1981</date>
		</imprint>
		<respStmt>
			<orgName>University of California Los Angeles</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">All from one, one for all: on model checking using representatives</title>
		<author>
			<persName><forename type="first">D</forename><surname>Peled</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 5th Conference on Computer Aided Verification</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>5th Conference on Computer Aided Verification<address><addrLine>Elounda</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1993-06">June 1993</date>
			<biblScope unit="volume">697</biblScope>
			<biblScope unit="page" from="409" to="423" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Specification and verification of concurrent systems in CESAR</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Quielle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sifakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 5th Int&apos;l Symp. on Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>5th Int&apos;l Symp. on Programming</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1981">1981</date>
			<biblScope unit="volume">137</biblScope>
			<biblScope unit="page" from="337" to="351" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">TAOS: Testing with analysis and oracle support</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Richardson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1994 International Symposium on Software Testing and Analysis</title>
		<meeting>the 1994 International Symposium on Software Testing and Analysis</meeting>
		<imprint>
			<date type="published" when="1994-08">August 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Protocol development success stories: Part I</title>
		<author>
			<persName><forename type="first">H</forename><surname>Rudin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 12th IFIP WG 6.1 International Symposium on Protocol Specification, Testing, and Verification</title>
		<meeting>12th IFIP WG 6.1 International Symposium on Protocol Specification, Testing, and Verification<address><addrLine>Lake Buena Vista, Florida, North-Holland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992-06">June 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Model Checking Multi-Threaded Distributed Java Programs</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Stoller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SPIN&apos;2000 (7th SPIN Workshop</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>SPIN&apos;2000 (7th SPIN Workshop</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1885</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">A general-purpose algorithm for analyzing concurrent programs</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">N</forename><surname>Taylor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="page" from="362" to="376" />
			<date type="published" when="1983-05">May 1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Stubborn sets for reduced state space generation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Valmari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Petri Nets</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1990">1990. 1991</date>
			<biblScope unit="volume">483</biblScope>
			<biblScope unit="page" from="491" to="515" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">An automata-theoretic approach to automatic program verification</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wolper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First Symposium on Logic in Computer Science</title>
		<meeting>the First Symposium on Logic in Computer Science<address><addrLine>Cambridge</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986-06">June 1986</date>
			<biblScope unit="page" from="322" to="331" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Abstract interpretation of the π -calculus</title>
		<author>
			<persName><forename type="first">A</forename><surname>Venet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Analysis and Verification of Multiple-Agent Languages (Proceedings of the Fifth LOMAPS Workshop</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Mads</forename><surname>Dam</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1192</biblScope>
			<biblScope unit="page" from="51" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Model checking programs</title>
		<author>
			<persName><forename type="first">W</forename><surname>Visser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Brat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ASE&apos;2000 (15th International Conference on Automated Software Engineering)</title>
		<meeting>ASE&apos;2000 (15th International Conference on Automated Software Engineering)<address><addrLine>Grenoble</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-09">September 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Testing Finite-State Machines</title>
		<author>
			<persName><forename type="first">M</forename><surname>Yannakakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd Annual ACM Symposium on the Theory of Computing</title>
		<meeting>the 23rd Annual ACM Symposium on the Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="476" to="485" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
