<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Chosen-Ciphertext Security of Multiple Encryption</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Yevgeniy</forename><surname>Dodis</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer Science</orgName>
								<address>
									<country>New York University</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jonathan</forename><surname>Katz</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Dept. of Computer Science</orgName>
								<orgName type="institution">University of Maryland</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Chosen-Ciphertext Security of Multiple Encryption</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">5B2E0B94CBB19DA2983A2C11AB2482F2</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:47+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Encryption of data using multiple, independent encryption schemes ("multiple encryption") has been suggested in a variety of contexts, and can be used, for example, to protect against partial key exposure or cryptanalysis, or to enforce threshold access to data. Most prior work on this subject has focused on the security of multiple encryption against chosen-plaintext attacks, and has shown constructions secure in this sense based on the chosen-plaintext security of the component schemes. Subsequent work has sometimes assumed that these solutions are also secure against chosen-ciphertext attacks when component schemes with stronger security properties are used. Unfortunately, this intuition is false for all existing multiple encryption schemes.</p><p>Here, in addition to formalizing the problem of chosen-ciphertext security for multiple encryption, we give simple, efficient, and generic constructions of multiple encryption schemes secure against chosen-ciphertext attacks (based on any component schemes secure against such attacks) in the standard model. We also give a more efficient construction from any (hierarchical) identity-based encryption scheme secure against selectiveidentity chosen plaintext attacks. Finally, we discuss a wide range of applications for our proposed schemes.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Encrypting data using multiple, independent instantiations of a basic encryption scheme (or schemes) is a simple -yet powerful -approach which can be used both to improve security as well as to provide additional functionality not present in any of the underlying schemes. The security implications of multiple encryption (as we refer to it here) were noted as early as Shannon <ref type="bibr" target="#b37">[38]</ref>, who proposed using "product ciphers" to enhance the security of symmetrickey primitives. This idea was further explored and rigorously formalized in a number of subsequent works (e.g., <ref type="bibr" target="#b31">[32,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b30">31]</ref>) analyzing the security of cascade ciphers (in which a message m is encrypted via E k1 (E k2 (m)), where k 1 , k 2 are two independent keys and E, E are symmetric-key encryption schemes) in the symmetric-key setting. The approach can be applied to public-key encryption as well; for example, "cascaded encryption" (which we will call sequential encryption) was advocated as part of the NESSIE recommendation <ref type="bibr" target="#b33">[34]</ref>: "[f]or very high level security we note that double encryption. . . gives a good range of security".</p><p>Multiple encryption, of which sequential encryption is but one example, offers at least two potential security advantages: First, the resulting scheme may be secure as long as any one of the component schemes is secure (indeed, sequential encryption is secure against chosen-plaintext attacks as long as either of the component schemes are). Thus, multiple encryption offers a way to "hedge one's bets" about the security of any particular scheme (see also the recent work of Herzberg <ref type="bibr" target="#b27">[28]</ref>). This is especially important when the security of different schemes depends upon different, and incomparable, cryptographic assumptions. A second potential advantage of multiple encryption is that the resulting encryption scheme may in fact be more secure than any of the component schemes; this is the rationale, for example, behind using triple-DES (see also <ref type="bibr" target="#b0">[1]</ref>).</p><p>Beyond the security-oriented advantages listed above, multiple encryption schemes potentially offer functionality not present in any of the component schemes. We briefly highlight two applications of multiple encryption, and defer a more detailed discussion of these and other applications to Section 6: Threshold Encryption. In a threshold encryption scheme <ref type="bibr" target="#b15">[16]</ref>, the data is encrypted in such a way that only particular sets of users can recover it; typically, a scheme requires any t-out-of-n users in order to decrypt, but more general access structures can also be considered. Multiple encryption gives generic constructions of threshold encryption in either the private-or public-key settings. For example, to enforce n-out-of-n decryption in the private-key setting, one may provide each user i with an independent key k i and encrypt a message M via E 1 k1 (M 1 ), . . . , E i ki (M i ), where the M i are chosen at random subject to ⊕ n i=1 M i = M (and the E i may, in general, be different schemes). Let J (with |J| &lt; n) represent the set of corrupted players; i.e., if j ∈ J then the adversary has the key k j . The above scheme, which we will refer to as parallel encryption, informally satisfies the following level of security against chosen-plaintext attacks: as long as any encryption scheme E i with i ∈ J is secure, the message remains secret. Thus, in addition to enabling threshold access to the data, this scheme also allows one again to "hedge one's bets" about the security of any particular scheme (as in the case of sequential encryption, discussed earlier).</p><p>(Strong) Key-Insulated Encryption. Multiple encryption has also been used to give a generic construction of a key-insulated public-key encryption scheme secure against chosen-plaintext attacks <ref type="bibr" target="#b19">[20]</ref>. Without going into the full detailsand omitting some details unimportant for the present discussion -in this case a message M is encrypted by first splitting the message into shares M 1 , . . . , M i and then encrypting each share M i with respect to a particular public key P K i . (This general technique is similar to the parallel encryption discussed above; indeed, parallel encryption is obtained if the shares constitute an n-out-of-n sharing of M .) If the message is "split" a second time (before the sharing described above), and one of these shares is encrypted with a public key whose secret key is known only to the user, it is possible to obtain a generic construction of strong key-insulated encryption <ref type="bibr" target="#b19">[20]</ref>.</p><p>Other Applications. We remark that multiple encryption is applicable to many other domains as well, including anonymous routing <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b25">26]</ref>, broadcast encryption <ref type="bibr" target="#b21">[22]</ref>, proxy encryption (see <ref type="bibr" target="#b18">[19]</ref>), and certificate-based encryption <ref type="bibr" target="#b23">[24]</ref>. We defer a more detailed discussion to Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Motivation for Our Work</head><p>Chosen-ciphertext security ("CCA security") is as much of a concern in each of the above settings as it is in the case of standard encryption. One might hope to achieve CCA security for any of the above settings by simply "plugging in" an appropriate CCA-secure multiple encryption scheme. However (with one recent exception; see below), we are unaware of any previous work which considers chosen-ciphertext security for multiple encryption. To be clear: there has been much work aimed at giving solutions for specific applications using specific number-theoretic assumptions: for example, in the context of CCA-secure threshold encryption <ref type="bibr" target="#b39">[40,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b29">30]</ref>, broadcast encryption <ref type="bibr" target="#b19">[20]</ref>, and key-insulated encryption <ref type="bibr" target="#b17">[18]</ref>. However, this type of approach suffers from at least two drawbacks: first, it does not provide generic solutions, but instead only provides solutions based on very specific assumptions. Second, the derived solutions are application-dependent, and must be constantly "re-invented" and modified each time one wants to apply the techniques to a new domain. Although solutions based on specific assumptions are often more efficient than generic solutions, it is important to at least be aware that a generic solution exists so that its efficiency can be directly compared with a solution based on specific assumptions. Indeed, we argue in Section 6 that for some applications, a generic solution may be roughly as efficient as (or may offer reasonable efficiency tradeoffs as compared to) the best currently-known solutions based on specific assumptions.</p><p>Making the problem even more acute is that currently-known schemes for multiple encryption are demonstrably insecure against chosen-ciphertext attacks (this holds even with respect to the weakest definition considered here; see Section 3.1). Zhang, et al. <ref type="bibr" target="#b40">[41]</ref> have also recently noticed this problem, and appear to be the first to have considered chosen-ciphertext security for multiple encryption. We compare our work to theirs in the following section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Our Contributions</head><p>Our results may be summarized as follows:</p><p>Definitions of Security. We provide formal definitions of chosen-ciphertext security for multiple encryption. Interestingly, multiple definitions make sense in this context, and we introduce three such definitions and briefly comment on the relationships between them. We also which of these definitions is the "right" one for a number of different applications.</p><p>CCA-Secure Multiple Encryption. We show two constructions of CCAsecure multiple encryption schemes which are generic (i.e., they may be constructed based on any CCA-secure standard encryption scheme) and are proven secure in the standard model. Our first construction achieves a "basic" level of security which suffices for many (but not all!) applications of multiple encryption.</p><p>Our second construction satisfies the strongest notion of security proposed here, and suffices for all applications we consider. We also show a more efficient construction based on any (hierarchical) identity-based encryption scheme secure against selective-identity chosen plaintext attacks.</p><p>Applications. As mentioned earlier, our work was motivated by the applications of CCA-secure multiple encryption to a variety of settings; we therefore conclude the paper by sketching a number of applications of the constructions given here. Our resulting schemes are, for most cases, the first known generic constructions achieving CCA security in the given setting. Furthermore, in some cases the solutions we give are roughly as efficient as (or even more efficient than) previous solutions which were based on very specific assumptions. As one example, we show a CCA-secure threshold encryption scheme with completely non-interactive decryption (and a proof of security in the standard model); for the two-party case, our solution is roughly as efficient as the only previous solution <ref type="bibr" target="#b29">[30]</ref>.</p><p>Comparison to Previous Work. Our definitions differ from those given by Zhang, et al. <ref type="bibr" target="#b40">[41]</ref>, and the definitions given in their work are weaker than those given here. In fact, the best construction given by Zhang, et al. only satisfies the weakest of our definitions; therefore, their constructions are not sufficient for certain applications such as threshold encryption. (Indeed, they concentrate primarily on the application to key-insulated encryption, while we consider a much wider range of applications.) Finally, their constructions require the random oracle model whereas our results all hold in the standard model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>We begin by introducing some notation. A (standard) public-key encryption scheme E = (Gen, Enc, Dec) consists of three ppt algorithms: the key-generation algorithm Gen takes as input security parameter 1 k and outputs a encryption key EK and a decryption key DK. The randomized encryption algorithm Enc takes as input EK, a label , and a message m, and outputs a ciphertext C; for brevity, we sometimes omit EK and write this as C ← Enc (m). The decryption algorithm Dec takes as input DK, a ciphertext C, and a label ; it outputs a message m, or ⊥ if C is "invalid". We write this as m ← Dec (C) (where we again sometimes omit DK). We assume Dec (Enc (m)) = m for any message m and label . Security for encryption is defined following <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b38">39]</ref>. In particular, we use "CPA-secure" to refer to what is called IND-CPA security in <ref type="bibr" target="#b2">[3]</ref>, and "CCAsecure" to refer to what is called IND-CCA2 in <ref type="bibr" target="#b2">[3]</ref> (modified to take labels into account as in <ref type="bibr" target="#b38">[39]</ref>).</p><p>A signature scheme Σ = (Sig-Gen, Sig, Ver) consists of three ppt algorithms: the key-generation algorithm Sig-Gen takes as input a security parameter 1 k and outputs a signing key SK and a verification key VK. The signing algorithm Sig takes as input SK and a message m, and outputs a signature σ; we will sometimes omit SK and write σ ← Sig(m). The verification algorithm Ver takes as input VK, a message m, and a signature σ; it outputs 1 iff the signature is valid. We write this as a ← Ver(m, σ) (again, sometimes omitting VK). We require that Ver(m, Sig(m)) = 1, for all m.</p><p>Unless specified otherwise, the notion of security we consider for signature schemes is that of strong unforgeability under adaptive chosen-message attacks, following <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b3">4]</ref>. We also use the notion of one-time signature schemes which satisfy an analogous definition of security except that an adversary is only allowed to request a signature on a single message.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Secret Sharing Schemes.</head><p>A secret sharing scheme is a pair of transformations SSS = (Share, Rec).<ref type="foot" target="#foot_0">1</ref> Share(•) is a probabilistic transformation which takes a message M and outputs n secret shares s 1 , . . . , s n and possibly one public share pub. Rec is a deterministic transformation which takes n shares s 1 , . . . , s n (some of which might be ⊥) and (if present) the public share pub, and outputs some message M (possibly ⊥). The basic correctness property states that Rec(Share(M )) = M . Security may be quantified by the following thresholds:</p><p>t p -the privacy threshold. Determines the maximum number of shares which (together with pub) reveal "no information" about the message. -t f -the fault-tolerance threshold. Determines the minimum number of correct shares which (together with pub) suffice to recover the message, when the other shares are missing. -t r -the robustness threshold. Determines the minimum number of correct shares which (together with pub) suffice to recover the message, when the other shares are adversarially set. -t s -the soundness threshold. Determines the minimum number of correct shares which (together with pub) ensure that it is impossible to recover an incorrect message M ∈ {M, ⊥}, when the other shares are adversarially set.</p><p>The above must satisfy t p + 1 ≤ t f ≤ t r ≤ n and t s ≤ t r . The security properties corresponding to the thresholds above can all be formalized in a straightforward way, so we omit them. In a basic secret sharing scheme, only privacy and fault-tolerance are addressed. This is useful when all the parties holding the corresponding shares are trustworthy, but some shares may have been leaked to an adversary and/or some parties may be (temporarily) unavailable. Shamir's scheme <ref type="bibr" target="#b36">[37]</ref> is the classical example; this scheme achieves information-theoretic privacy, has no public share, and achieves t f = t p + 1 and |M | = |s i |. Generalizing this idea <ref type="bibr" target="#b22">[23]</ref>, one can achieve arbitrary t f &gt; t p . Krawczyk <ref type="bibr" target="#b28">[29]</ref> extended Shamir's scheme to the computational setting by using the scheme to share a short symmetric key k, and then encrypting the message M using k. The resulting ciphertext can either be stored publicly, or shared among the servers using an information dispersal scheme <ref type="bibr" target="#b34">[35]</ref> (i.e., a secret sharing scheme which achieves fault-tolerance and/or robustness, but has t p = 0). In fact, this approach can be applied to any information-theoretic secret sharing scheme to obtain a computational scheme with share size proportional to the security parameter and public part proportional to the message length. When fault-tolerance is not needed, one can also use computational all-or-nothing transforms (AONTs) <ref type="bibr" target="#b35">[36,</ref><ref type="bibr" target="#b10">11]</ref> to achieve extremely short shares.</p><p>Sometimes, basic secret sharing schemes already enjoy certain robustness properties. For example, Shamir's scheme achieves t r = (n + t f )/2. Moreover, there are several simple methodstotransform any(t p , t f , n)-secret sharing scheme into a robust (t p , t f , t r , t s , n)-secret sharing scheme (in a computational sense), achieving optimal values t s = 0 and t r = t f . We describe two such methods now. In both methods, the dealer first computes the regular sharing (s 1 , . . . , s n , pub) of M . In the first method, the dealer then generates signing/verification keys (SK, VK) for a signature scheme, and sets s i = (s i , Sig SK (i, s i )), pub = (pub, VK). To reconstruct, users apply the original reconstruction algorithm only to shares whose signatures are correct. In the second method, the dealer uses a commitment scheme to commit to (i, s i ); let c i (resp., d i ) be the corresponding commitment (resp., decommitment). The dealer then sets s i = (s i , d i ), pub = (pub, c 1 , . . . , c n ). As before, users will only use those shares whose proper decommitment is revealed. In this second method the size of the public information is O(n), but using, e.g., Merkle trees this storage can be reduced considerably at the expense of slightly increasing the share size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Multiple Encryption</head><p>We now define a multiple encryption scheme. Definition 1. A (non-interactive) public-key multiple encryption scheme is a tuple of ppt algorithms T E = (TGen, TEnc, Split, TDec, Combine) such that:</p><p>-TGen, the key generation algorithm, is a probabilistic algorithm which takes as input a security parameter 1 k and outputs a public key TEK along with n secret keys TDK = (TDK 1 , . . . , TDK n ). -TEnc, the encryption algorithm, is a probabilistic algorithm which takes as input a public key TEK, a message M , and a label L. It outputs a ciphertext C ← TEnc L (M ). -Split, the splitting algorithm, is a deterministic algorithm which takes as input a public key TEK, a ciphertext C and a label L. It either outputs ⊥, or n ciphertext shares C = (C 1 , . . . , C n ) and some auxiliary info aux. -TDec, the partial decryption algorithm, takes as input i ∈ {1, . . . , n}, a secret key TDK i , and a ciphertext share C i ; it outputs the message share M i or the distinguished symbol ⊥. We denote the output of this algorithm by TDec i (C i ). We also let DEC(C, aux)</p><formula xml:id="formula_0">def = (TDec 1 (C 1 ), . . . , TDec n (C n ), aux). -Combine, the combining algorithm, takes as input shares M = (M 1 , . . . , M n )</formula><p>and the auxiliary info aux, and outputs a message M or ⊥.</p><p>Correctness (refined later) requires that for all TEK, TDK output by TGen, all messages M and labels L, we have:</p><formula xml:id="formula_1">Combine(DEC(Split L (TEnc L (M )))) = M .</formula><p>Before discussing security, a few remarks are in place. It is important to recognize that multiple encryption might be used in a number of different scenarios. In one scenario, the set of decryption keys TDK (or some subset of these keys) are co-located, so a single user receiving a ciphertext C would perform the splitting, partial decryption, and combining by itself. In another scenario, there are a set of n servers and server i stores TDK i . Here, a user receiving a ciphertext C would perform the splitting himself to obtain C, aux, would keep aux, and would send the ciphertext share C i to server i for decryption. Server i would respond with M i and the various message shares would be combined by the user to recover the original message. These different ways of thinking about the decryption process are each appropriate for different applications of multiple encryption.</p><p>When decryption keys TDK i are stored at different locations (i.e., on different servers), the above definition implies that servers do not communicate with each other and do not keep any intermediate state. Also, we remark that we could have ignored the splitting algorithm altogether and simply have TDK i operate on the entire ciphertext C (performing any splitting itself, as necessary). The reason for not doing so is that C might contain information which is not "relevant" to server i, and thus sending the entire ciphertext to each server might be wasteful. In fact, our solutions achieve</p><formula xml:id="formula_2">|C i | = O(|C|)</formula><p>, so the total communication between the user and all servers is proportional to the size of the original ciphertext.</p><p>In either of the above scenarios (i.e., whether the decryption keys are colocated or stored at different servers), it is possible for some of the decryption keys to be compromised by an adversary. This raises the first security issue, which is that of message privacy. When keys are stored on separate servers, there is also the possibility that some servers may be compromised in their entirety; this raises the additional issue of decryption robustness. Since the security issues in the latter case are stronger than those in the former case, for the remainder of this section we will speak in terms of a central user running the splitting/combining algorithm and n servers performing the partial decryption of each share.</p><p>Message Privacy. We assume that the adversary may learn t p &lt; n decryption keys, where t p is the privacy threshold. Formally, given a set I = i 1 , . . . , i tp , an adversary is given a randomly-generated public key TEK, the set of secret keys TDK I = TDK i1 , . . . , TDK it p , and oracle access to some oracle O whose meaning will be clarified shortly. B outputs two messages M 0 , M 1 (along with some label L), and receives a challenge ciphertext C ← TEnc(M b ) for a randomly-chosen b. The adversary succeeds if it correctly guesses b, and the adversary's advantage is defined as the absolute value of the difference between its success probability and 1/2. If the oracle O is "empty", we say that B is performing a (multiple) chosen-plaintext attack (MCPA). As for the (multiple) chosen-ciphertext attack, there are several meaningful flavors described below in the order of increasing adversarial power.</p><p>In the weakest such attack, denoted wMCCA ("weak MCCA"), we have O = Combine(DEC(Split (•) (•))) (where the adversary is prohibited from submitting (C, L) to this oracle). Namely, B only gets access to the entire decryption process without seeing any partial decryption results and without being able to ask questions to the decryption servers directly. While this notion already suffices for some applications, it assumes that the adversary can never see the intermediate decryption shares. In a (regular) MCCA attack, we let O = DEC(Split (•) (•)) (as before, we forbid the adversary from submitting (C, L) to this oracle). Namely, we still assume that the ciphertext gets passed through a proper splitting procedure but B also learns the intermediate decryption results M 1 , . . . , M n . As we shall see, this attack is sufficient for most applications of multiple encryption.</p><p>However, sometimes we need to consider an even stronger attack denoted sMCCA (for "strong MCCA"), where we have O = TDec (•) (•). Namely, we allow B to ask arbitrary and questions to the individual decryption servers. Of course, to make sense of this attack, we need to add some restrictions. First and most obvious, for a challenge ciphertext C (with label L) we disallow questions (i, C i ), where C i is the ciphertext share for server i that results from "splitting" C using label L. Second and less obvious, we assume (for all i) that the mapping Split i from (C, L) to C i is weakly collision-resistant. This means that no ppt adversary A can succeed with non-negligible probability in the following game: A(TDK) supplies some pair (M, L) to the encryption oracle, and gets back a ciphertext C ← TEnc L (M ). A succeeds if it can output a pair (C , L ) = (C, L) and an index i such that Split i (C, L) = Split i (C , L ). Indeed, without this latter condition it seems unnecessarily restrictive to prohibit the adversary B in the sMCCA game from asking questions (i, C i = Split i (C, L)). This is because there is a chance such a question might have "legally" come from a different ciphertext (C , L ) = (C, L). We further observe that when the Split procedure does satisfy this condition, the sMCCA attack is at least as strong as the MCCA attack,<ref type="foot" target="#foot_1">2</ref> and it is easy to see that this conclusion does not hold without weak collision resistance. Therefore, we will insist on weak collision-resistance when talking about sMCCA attacks. Definition 2. Let X ∈ {MCPA, wMCCA, MCCA, sMCCA}. We say multiple encryption scheme T E is X-secure with privacy threshold t p , if the advantage of any ppt adversary B performing attack X with any set I of size t p is negligible.</p><p>Decryption Robustness. The correctness property of Definition 1 only ensures correct decryption when all algorithms are honestly and correctly executed. Just as in the case of secret sharing, however, one may often desire fault-tolerance, robustness, and/or soundness. As in the case of secret sharing, these are parameterized by thresholds t f , t r , t s , whose meaning is completely analogous to their meaning in the case of secret sharing (described earlier). Our solutions can achieve optimal t s = 0, t r = t f , and any t p &lt; t f .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Insecurity of Known Multiple Encryption Schemes</head><p>It is instructive to note that known constructions of multiple encryption schemes (even when instantiated with a CCA-secure standard encryption scheme) are insecure under the weakest definition of chosen-ciphertext security considered above. We briefly illustrate this for the simplest case of n = 2.</p><p>In sequential encryption, M is encrypted via C ← Enc EK1 (Enc EK2 (M )). An adversary, when given the decryption key DK 1 and a challenge ciphertext C, can break the encryption scheme as follows: decrypt C using DK 1 to obtain C ∈ Enc EK2 (M ) and then re-encrypt C using EK 1 ; this results in a second, different ciphertext C. Now, by submitting C to its decryption oracle, the adversary will receive in return the original message M .</p><p>Attacks are also possible for the case of parallel encryption. Here, a message M is encrypted as</p><formula xml:id="formula_3">C = C 1 , C 2 , where C 1 ← Enc EK1 (s 1 ), C 2 ← Enc EK2 (s 2 ),</formula><p>and s 1 and s 2 are chosen at random subject to s 1 ⊕ s 2 = M . Now, even without being given any decryption keys, an adversary given a challenge ciphertext C can compute C1 ← Enc EK1 (0) and C2 ← Enc EK2 (0), and then submit the ciphertexts C1 , C 2 and C 1 , C2 . Note that the adversary thus obtains both s 1 and s 2 separately, from which it can recover the original message M = s 1 ⊕ s 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Generic Constructions</head><p>In this section we describe how to build MCCAand sMCCA-secure multiple encryption schemes from any (standard) CCA-secure encryption scheme E. In our schemes, the decryption keys will simply be decryption keys DK i independentlygenerated by E, and partial decryption will essentially require only a single decryption with this key. Our results achieve: (1) ciphertext length linear in the length of the plaintext message; (2) communication with each server independent of the number of servers and the length of the message. We also stress that when the decryption keys are held by several servers, no interaction between servers is required. A drawback is that the ciphertext and public-key lengths in our solutions are proportional to the number of decryption keys n (of course, for small n, such as the important case of n = 2, this is not a problem). We believe that this dependence in unavoidable if we are not willing to assume any algebraic structure on E. Indeed, in the following section we show how this dependence can be avoided when starting from (hierarchical) identity-based encryption.</p><p>For the remainder of this section, let SSS = (Share, Rec) be a (t p , t f , t r , t s , n)secret sharing scheme. All multiple encryption schemes we construct will inherent the same thresholds t p , t f , t r , t s , which elegantly allows us to push all the privacy and robustness constraints onto the much simpler secret sharing primitive.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Achieving Chosen-Ciphertext Security</head><p>Recall that in parallel encryption the message M is first shared using SSS, and then each share is separately encrypted using an independent key. As noted earlier, this folklore scheme is not secure against chosen-ciphertext attacks (even against a weak MCCA attack and with no corrupted keys). We show a simple and elegant way to extend parallel encryption so as to solve this problem, without introducing much extra complexity. In brief, we use a secure one-time signature scheme Σ = (Sig-Gen, Sig, Ver) to bind all the local ciphertexts to each other (and to the label L). The main twist which makes this work is that we also bind the verification key of Σ to each of the ciphertexts. Before giving the formal description of our solution, we illustrate our construction for the case n = 2 (with t f = t r = t s = 2, t p = 1, and no labels). The public key consists of two independently-generated keys EK 1 , EK 2 , and the secret key contains the corresponding decryption keys DK 1 , DK 2 . Let Enc 1 def = Enc EK1 and similarly for Enc 2 . To encrypt M , a sender first "splits" M by choosing random s 1 and setting s 2 = M ⊕ s 1 . The sender then generates a key pair (VK, SK) for a one-time signature scheme, and computes C 1 ← Enc VK 1 (s 1 ) and</p><formula xml:id="formula_4">C 2 ← Enc VK 2 (s 2 ). Finally, the sender computes σ = Sig SK (C 1 , C 2 ); the complete ciphertext is VK, C 1 , C 2 , σ .</formula><p>Decryption is done in the obvious way: if σ is not a valid signature on C 1 , C 2 with respect to VK, the ciphertext is invalid. Otherwise, DK 1 and DK 2 are used to obtain s 1 and s 2 from which the original message M = s 1 ⊕ s 2 can be recovered.</p><p>We now generalize this solution to arbitrary n and using an arbitrary secret sharing scheme SSS = (Share, Rec).</p><p>-TGen(1 k ): For i = 1, . . . , n, let (EK i , DK i ) ← Gen </p><formula xml:id="formula_5">-TDec i (C i , VK): Output s i = Dec VK i (C i ). -Combine(s 1 , . . . , s n , pub): Output Rec(s 1 , . . . s n , pub).</formula><p>As with the folklore scheme, each decryption server simply performs a single regular (now CCA-secure) decryption, but here using a label which is the verification key of a one-time signature scheme (and which is used to bind all the ciphertexts together). We claim: Theorem 1. If E is CCA-secure, SSS is a (t p , t f , t r , t s , n)-secret sharing scheme, and Σ is a secure one-time signature scheme, then T E is MCCA-secure with thresholds t p , t f , t r , t s .</p><p>Proof. Robustness thresholds t f , t r , t s follow immediately from those of the secret sharing scheme, due to the definition of Combine = Rec. We now argue message privacy.</p><p>Assume there exists some ppt adversary B attacking MCCA-security who has some non-negligible advantage. Recall, this B has oracle access to O(•, •) = DEC(Split (•) (•)), chooses some messages M 0 , M 1 and a label L, gets an unknown ciphertext C = (C 1 , . . . , C n , pub, VK, σ), and tries to guess whether this corresponds to the encryption of M 0 or M 1 (with label L). Let X denote the event that B asks O a query (C , L ) = (C, L), where C includes the same verification key VK = VK as the challenge, but σ is a new, valid signature (with respect to VK) of the corresponding "message" (C 1 , . . . , C n , pub , L ). It is immediate that Pr[X] = negl(k), or else an easy argument (omitted) shows that we can use B to construct a ppt adversary breaking the security of the one-time signature scheme Σ with non-negligible advantage.</p><p>We can therefore construct an adversary B who never makes a query to O using the same verification key as in the challenge ciphertext, yet whose advantage is negligibly close to the advantage of B. Let ε 0 denote the advantage of B , and assume w.l.o.g. that B corrupts servers {nt p + 1, . . . , n}. We refer to this game involving B as G 0 , and now gradually change this game into games G 1 , . . . , G n-tp . In general, G i is identical to G 0 , except for one step in the computation of the challenge ciphertext C. Recall, in G 0 we have C j ← Enc VK j (s j ), where s j is the j-th share of the secret sharing scheme. In game G i we instead do this only for j &gt; i, but set C i ← Enc L i (0) for j ≤ i (where 0 is some arbitrary fixed message in our space). In other words, G i-1 and G i are identical except</p><formula xml:id="formula_6">G i-1 sets C i ← Enc VK i (s i ), while G i sets C i ← Enc VK i (0)</formula><p>Denote by ε i the advantage of B in predicting the challenge bit b in game G i . We claim that for every</p><formula xml:id="formula_7">1 ≤ i ≤ n -t p we have |ε i -ε i-1 | = negl(k).</formula><p>To show the claim, using B we construct an adversary A i who succeeds in breaking CCA-security of E with advantage</p><formula xml:id="formula_8">δ i = 1 2 |ε i-1 -ε i |.</formula><p>Since E is assumed to be CCA-secure, the claim follows. A i gets an encryption key EK for E, sets EK i = EK, and generates the remaining (n -1) public/secret keys by himself. These public keys, as well as the last t p secret keys, are given to B . Adversary A i then honestly simulates the run of G i-1 /G i until B submits the challenge (M 0 , M 1 , L). At this point, A i chooses a random bit b, generates (SK, VK), computes the shares (s 1 , . . . , s n , pub) ← Share(M b ), and prepares C j for j = i just as in G i-1 and G i . Furthermore, A outputs the challenge (s i , 0, VK) in its own CCA game. Upon receiving the challenge ciphertext C, it sets C i = C, signs whatever is needed, and passes the resulting challenge ciphertext to B . It only remains to specify how A i deals with oracle queries of B . Notice that A i can decrypt all ciphertexts C j for j = i by himself, since the appropriate decryption keys are known. As for C i , since (by construction) B does not reuse the challenge value VK, this means that A i can always submit C i to its decryption oracle using the label VK = VK. Finally, A i outputs 1 iff B correctly predicts b. This completes the description of A i , and it is not hard to see that A i gives a perfect simulation of either game G i-1 or G i depending on which of s i or 0 was encrypted. The claim regarding |ε i-1ε i | follows easily. Now, since (nt p ) is polynomial in k and ε 0 is assumed to be non-negligible, we get that ε n-tp is non-negligible as well. But let us now examine the game G n-tp more closely. When encrypting the challenge M b , only t = t p shares (and the value pub) are used in creating the ciphertext. But then the privacy of the secret sharing scheme implies that ε n-tp must be negligible, a contradiction. (This is not hard to see, and we omit the obvious details.)</p><p>Replacing Signatures with MACs. At the expense of settling for (weaker) wMCCA-security, we can use the recent technique of Boneh and Katz <ref type="bibr" target="#b9">[10]</ref> to replace the one-time signature scheme by the more efficient combination of a message authentication code (MAC) and a weak form of commitment. The idea is to commit to a MAC key τ , then encrypt both the message M and the decommitment d using the secret sharing technique above, but with the public verification key VK replaced by the commitment c. Finally, τ is used to compute a message authentication code on the entire resulting ciphertext. In brief, the reason this only yields wMCCA-security is that the message authentication code computed over the ciphertext (as opposed to the one-time signature computed above) can only be verified after all the shares are collected. More details are given in Appendix A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Achieving Strong Chosen-Ciphertext Security</head><p>The scheme above does not enjoy sMCCA-security since, in particular, the mapping Split i from (C, L) to C i is not weakly collision-resistant; indeed, it ignores all ciphertexts other than C i . A natural first thought is to simply append a hash α of the entire ciphertext C to each of the local decryption shares C i (and let each server simply ignore α). While this may make each Split i weakly collisionresistant, it will not achieve sMCCA-security: Since the servers ignore α anyway, the adversary can simply replace α by "garbage" while keeping the rest of the C i the same; this will result in a "valid" decryption request to each server, but will result in a proper decryption of C i to the adversary. A natural way to fix this is to let each server check the hash α by sending to the server the entire ciphertext C. In fact, if we are willing to send the entire ciphertext to each server, we no longer need α: each server can just perform the corresponding splitting procedure on C by itself. In fact, doing so will trivially give sMCCA-security. However, sending all of C (and having each server perform the splitting procedure) may be wasteful in some scenarios; it therefore remains interesting to explore improved solutions with lower user-server communication and in which more of the work is shifted to the user rather than the servers.</p><p>For the case of the particular MCCA-secure scheme T E cca of the previous section, sMCCA-security can be achieved at a very small additional cost. Let H = {H} be a family of collision-resistant hash functions. We now describe the modified scheme T E scca .</p><p>-TGen(1 k ). Sample H ← H and for i = 1, . . . , n, let (EK i , DK i ) ← Gen(1 k ).</p><p>Set TEK = (EK 1 , . . . , EK n , H), TDK i = DK i . Below, denote Enc i = Enc EKi , Dec i = Dec DKi . -TEnc L (M ). Let (s 1 , . . . , s n , pub) ← Share(M ), and (VK, SK) ← Sig-Gen(1 k ).</p><p>Set</p><formula xml:id="formula_9">C i = Enc VK i (s i ) for i = 1, . . . , n; then compute α = H(C 1 , . . . , C n , pub, L) and σ = Sig SK (α). Output C = (C 1 , . . . , C n , pub, VK, σ). -Split L (C). Parse C = (C 1 , . . . , C n , pub, VK, σ), set α = H(C 1 , . . . , C n , pub, L),</formula><p>and reject if Ver VK (α, σ) = 0. Otherwise, set the ciphertext share to be Ĉi = (C i , VK, α, σ) and set aux = pub. Thus, the only effective change is to force each server to verify a signature (of a one-time signature scheme) before performing the decryption. The cost of this will typically be small compared to the cost of decryption.</p><formula xml:id="formula_10">-TDec i (C i , VK, α, σ). Output Dec VK i (C i ) if Ver VK (α, σ) = 1,</formula><p>We now consider the security of the above. On an intuitive level, when an adversary makes a decryption query, either: (1) the adversary reuses a previous VK, which implies that it uses a previous α (due to unforgeability of the signature scheme), which in turn implies that the query is illegal (since H is collision-resistant); or (2) the adversary uses a new VK, in which case the chosenciphertext security of the underlying encryption schemes (which use VK as a label) implies that the resulting ciphertexts are unrelated to the challenge. Notice, there is no need for the server to check that α is the correct hash; having a valid signature of α implicitly assures the server that either this decryption query is unrelated to the challenge, or α is indeed correct due to the unforgeability of the one-time signature scheme. Notice also that once again the communication between the user and each server is independent of n. The above intuition can in fact be used to prove the following theorem:</p><formula xml:id="formula_11">Theorem 2. If E is CCA-secure, SSS is a (t p , t f , t r , t s , n)-secret sharing scheme,</formula><p>Σ is a secure one-time signature scheme, and H is collision-resistant, then T E scca is sMCCA-secure with thresholds t p , t f , t r , t s .</p><p>Proof. As before, robustness thresholds t f , t r , t s follow immediately from those of the secret sharing scheme since Combine = Rec. We now argue message privacy. Here we need to argue two things: indistinguishability of the scheme against sMCCA attack and weak collision resistance of the splitting procedure.</p><p>We start with the second part. Take any adversary A attacking weak collision resistance of T E scca . A gets the entire secret key TDK, produces a pair (M, L), gets C ← TEnc L (M ), and outputs (C , L ) = (C, L) and an index i. If it is the case that Split</p><formula xml:id="formula_12">i (C, L) = Split i (C , L ) then (by definition of Split) this means that (C i , VK, α, σ) = (C i , VK , α , σ ). But then H(C 1 . . . C n , pub, L) = α = α = H(C 1 . . . C n , pub , L )</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>and this violates collision-resistance of H.</head><p>Next, we show security against sMCCA attack. Assume there exists some adversary B attacking sMCCA-security who has some non-negligible advantage. Recall, B has oracle access to O(•, •) = TDec (•) (•), chooses some messages M 0 , M 1 and a label L, gets a challenge ciphertext C = (C 1 , . . . , C n , pub, VK, σ), and tries to predict whether this ciphertext corresponds to an encryption of M 0 or of M 1 (with label L). Let X denote the event that B asks O a query (i, (C i , VK, α , σ )), where VK is the same verification key as the one used in the challenge ciphertext but σ is a new, valid signature with respect to VK of the corresponding message α . Namely, σ is a valid signature of α , but (α , σ ) = (α, σ). Clearly, Pr(X) = negl(k) or otherwise B can be used to break the security of the one-time signature scheme Σ.</p><p>We thus assume that X never occurs in the run of B, yet B still has nonnegligible advantage. Since B is forbidden to ask any challenge query of the form (i, (C i , VK, α, σ)), this means that every query (i, (C i , VK , α , σ )) that B makes satisfies one of three conditions: (1) Ver VK (α , σ) = 0, in which case the response is automatically ⊥ (and so we can assume that B never makes such a query);</p><p>(2) (VK , α , σ ) = (VK, α, σ), but C i = C i (recall, we proved that VK = VK implies (α , σ ) = (α, σ), so the only way for this query to be legal while keeping</p><formula xml:id="formula_13">VK = VK is to have C i = C i ); (3) VK = VK.</formula><p>Since we excluded queries of type (1), we combine cases ( <ref type="formula">2</ref>) and ( <ref type="formula">3</ref>) to conclude that every query of B must have</p><formula xml:id="formula_14">(C i , VK ) = (C i , VK).</formula><p>Given this observation, the rest of the proof is almost identical to the proof of Theorem 1 (with obvious syntactic modifications). Namely, we create hybrid games in which encryptions of the shares of M b are gradually replaced by encryptions of 0. As in the proof of the previous theorem, we show that any such change cannot be noticed by B since the corresponding encryption scheme E i is CCA-secure. The only new aspect of this proof is the description of how A i handles B's queries (j, (C j , VK , α , σ )). When j = i, then A i can simply decrypt by itself, as before. For j = i, A i first checks the validity of the signature, and then asks its own decryption oracle to decrypt (C i , VK ). So all we need to argue is that this query is different from A i 's own challenge (C i , VK) (which A i is forbidden to ask). But this is precisely what we argued about B's behavior in the previous paragraph.</p><p>Remark 1. The existence of collision-resistant hash functions does not seem to follow from the existence of CCA-secure encryption schemes. However, by slightly sacrificing the efficiency of our construction, we can rely on universal one-way hash functions (UOWHFs) (which are implied by the existence of CCA-secure encryption) thus making our construction completely generic. Briefly, instead of using a single H ∈ H in the public key, the sender will choose a new H ← H for every encryption. The description of H will then be included as part of the ciphertext, signed together with α, and be included as part of each server's share. Since one can achieve |H| ∼ log n <ref type="bibr" target="#b5">[6]</ref>, this still keeps the user-server communication very low.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Direct Constructions from Selective Identity IBE/HIBE Schemes</head><p>We assume the reader is familiar with the basic terminology of identity-based encryption (IBE) and hierarchical identity-based encryption (HIBE); see <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b24">25]</ref>.</p><p>Recently, Canetti et al. <ref type="bibr" target="#b11">[12]</ref> gave a simple and elegant construction transforming a "weak" (so called selective-identity-secure) IBE scheme secure against CPA attacks into a CCA-secure (standard) public-key encryption scheme. Their transformation uses a secure one-time signature scheme, by first encrypting the message M with the identity VK (for newly chosen keys (SK, VK)), and then signing the resulting ciphertext with SK. The receiver, who stores the master secret key for the IBE scheme, can then decrypt the ciphertext if the signature is valid. We could then use the resulting CCA-secure encryption schemes in our transformations to get CCA-secure multiple encryption schemes, where each server would store a master key for an independent IBE scheme. However, this will result in generating (n + 1) one-time keys and signatures per ciphertext, which is wasteful. Instead, we notice that the same verification key VK can be used as the identity for all n IBE schemes, and then used to sign the concatenation of n ciphertexts (or its hash). This gives a much more efficient direct construction with only a single one-time signature per ciphertext.</p><p>However, just like our original scheme, the public key of the resulting multiple encryption is still proportional to the number of parties n. We now show that using a two-level hierarchical IBE scheme (secure against selective-identity CPA-attack), we can make the first relatively generic multiple encryption scheme whose public key is independent of the number of players (although the ciphertext size still is). Specifically, the public key pk is simply the mater public key of the two-level HIBE. The i-th decryption key TDK i consists of level-1 identity-based secret key corresponding to identity i. To encrypt a message M , the sender (as before) generates a key pair (SK, VK) ← Sig-Gen(1 k ) and applies a secret sharing scheme to the message M resulting in shares s 1 . . . s n (and pub). Now, however, the sender encrypts s i "to" the level-2 identity (i, VK), and then signs the resulting ciphertexts (or their hash) using SK. Each server i can still decrypt its share since it knows the level-1 secret key for the parent identity i, while the collusion-resistance of the HIBE easily implies that no other coalition of servers can get any information from this share. We omit a formal proof in this abstract.</p><p>We remark that Boneh and Boyen <ref type="bibr" target="#b6">[7]</ref> have recently constructed simple and efficient selective-identity IBE/HIBE schemes, which immediately give rise to simple and efficient multiple encryption schemes using our paradigm. In particular, using their HIBE scheme we get an efficient multiple encryption scheme with a constant-size public key. We also notice that the technique of replacing signatures by MACs <ref type="bibr" target="#b9">[10]</ref> also applies here to obtain more efficient wMCCA-secure multiple encryption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Applications</head><p>We outline in brief a number of applications of multiple encryption.</p><p>CCA-Secure Threshold Encryption. In the generally-considered model for threshold encryption, there is a combiner who receives a ciphertext and sends some information to various servers who may then potentially interact, either with each other or with the combiner. The information sent to the servers is typically assumed to be the ciphertext itself, but in general (and in our case in particular) it is possible to transmit a smaller amount of information to each server. In either case, the servers then send decryption shares back to the combiner, who uses these to recover the original message. In a chosen-ciphertext attack on a threshold encryption scheme (see, e.g., <ref type="bibr" target="#b39">[40,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b29">30]</ref>), an adversary can expose the decryption shares stored at some number of servers, observe a ciphertext C, and send ciphertexts C = C to the combiner. When it does so, in addition to receiving the decryption of C , it is also typically assumed that the adversary can observe all communication in the network, both between the servers and the combiner as well as between the servers themselves.</p><p>It is not hard to see that the adversarial model thus described corresponds exactly to a MCCA-attack. Moreover, if the combiner itself is untrusted (and can send what it likes to the servers), we effectively have a sMCCA-attack. Thus, any MCCA/sMCCA-secure multiple encryption scheme with privacy threshold t p immediately gives a threshold encryption scheme with the same privacy threshold. Furthermore, a MCCA/sMCCA-secure multiple encryption scheme with robustness threshold t r immediately gives a threshold encryption scheme in which the ciphertext can be correctly decrypted as long as t r servers remain uncorrupted. Thresholds t f and t s can be interpreted similarly.</p><p>Our techniques thus give the first generic construction for CCA-secure threshold encryption (note that no previous generic solution existed even in the random oracle model). We remark further that for small values of n, our schemes are competitive with previous threshold schemes. For example, when n = 2 and we use the Cramer-Shoup <ref type="bibr" target="#b14">[15]</ref> encryption scheme as our building block, we obtain a CCA-secure two-party public-key encryption scheme (in the standard model) which has more efficient decryption than the scheme recently proposed by MacKenzie <ref type="bibr" target="#b29">[30]</ref>. In fact, although this construction increases the encryption time and ciphertext size by (roughly) a factor of two as compared to <ref type="bibr" target="#b29">[30]</ref>, the time required for decryption (by each server) is actually a factor of 10 more efficient; furthermore decryption in our case is completely non-interactive. As another example, if we use RSA-OAEP as our building block we obtain a very efficient solution for CCA-secure, RSA-based threshold encryption with completely noninteractive decryption (in the random oracle model).</p><p>CCA-Secure Key-Insulated and Strong Key-Insulated Encryption. We assume the reader is somewhat familiar with the key-insulated model, as well as with the generic constructions of <ref type="bibr" target="#b19">[20]</ref> (which achieve only CPA security). In a key-insulated public-key encryption scheme there is a server and a user ; at the beginning of each time period, the user communicates with the server to update the user's secret key. Ciphertexts sent during any time period can be decrypted by the user alone, without any further communication with the server. The main property of such schemes is that exposing the secret information stored by the user during many time periods leaves all non-exposed periods secure.</p><p>At a high level, in the generic solution of <ref type="bibr" target="#b19">[20]</ref> the server stores n secret keys for a standard encryption scheme (and the n corresponding public keys constitute the public key of the key-insulated scheme). At the beginning of each time period, some of these secret keys are given to the user. To encrypt a message during a particular time period, the sender first splits the message into shares using a secret-sharing scheme, and then encrypts each of these shares using one of the keys associated with the current time period. The keys are chosen in such a way so that multiple exposures of the user do not compromise "enough" of the keys associated with any other time periods. (In <ref type="bibr" target="#b19">[20]</ref>, it is shown how to "tune" n and to achieve the desired level of security in a reasonably-efficient way.)</p><p>It is immediately apparent that the above encryption process (namely, splitting the message and then encrypting each share with an independent key) corresponds exactly to multiple encryption. For this particular application, a single user stores all keys that are used to decrypt during a given time period; therefore, a chosen-ciphertext attack against a key-insulated cryptosystem is equivalent to a wMCCA attack on a multiple encryption scheme (that is, an adversary does not get to see the individual shares output by each partial decryption algorithm). Thus, any wMCCA-secure multiple encryption scheme can be used to achieve CCA-secure key-insulated encryption. We remark that robustness is not needed for this particular application since all keys are stored by a single entity (namely, the user).</p><p>Dodis, et al. <ref type="bibr" target="#b19">[20]</ref> also show a generic conversion from any CPA-secure keyinsulated scheme to a CPA-secure strong key-insulated scheme (where in a strong key-insulated scheme, encrypted messages are kept confidential even from the server itself). In their conversion, they split the plaintext message into two shares, encrypt one share using any "basic" key-insulated scheme, and encrypt the second share using a key that is stored (at all times) only by the user. Again, it can be seen that this solution corresponds to "double" encryption; thus, the techniques outlined in this paper suffice to construct generic CCA-secure strong key-insulated schemes from any CCA-secure key insulated scheme (thereby answering a question left open by <ref type="bibr" target="#b4">[5]</ref>).</p><p>CCA-Secure Certificate-Based Encryption. The notion of certificate-based encryption (CBE) was recently introduced by Gentry <ref type="bibr" target="#b23">[24]</ref>. In this model, a certificate -or, more generally, a signature -acts not only as a "certification" of the public key of a particular entity, but serves also as a decryption key. In particular, to decrypt a message a key-holder needs both its secret key and an up-to-date certificate from its certification authority (CA). Certificate-based encryption combines the aspects of identity-based encryption (IBE) and public-key encryption (PKE). Specifically, the sender of the message does not need to check whether the user is properly certified before sending the message, and the user can decrypt the message only if he has been certified (this is called implicit certification, a feature of IBE but not of PKE). Additionally, (1) the certificates from the CA can be sent to the user in the clear (as in PKE but unlike IBE), and (2) the CA cannot decrypt messages sent to to the user since he does not know the user's private key (i.e., there is no escrow, again like PKE but unlike IBE).</p><p>From the above description, one would expect that it should be possible to construct a CBE scheme using a simple combination of any IBE and regular PKE. In fact, this was the intuitive description of CBE as presented by Gentry <ref type="bibr" target="#b23">[24]</ref>, and this approach achieves security against chosen-plaintext attacks. Unfortunately, this does not suffice to achieve security against chosen-ciphertext attacks. As a result, <ref type="bibr" target="#b23">[24]</ref> only constructed a CCA-secure CBE scheme based on specific assumptions, and left open the problem of designing a generic CCA-secure CBE scheme. Using the techniques from this paper with n = 2, but applying them to an IBE and a PKE (instead of two PKEs), we can easily resolve this open question. Note that ones only needs a wMCCA-secure multiple encryption scheme with no robustness in this case, since the user holds both keys and never reveals any intermediate results.</p><p>Our technique also applies to most of the CBE extensions presented by Gentry, such as hierarchical CBE (which combines CCA-secure hierarchical IBE and PKE) and the general technique (based on subset covers) to reduce CA computation in a multi-user environment.</p><p>CCA-Secure Broadcast Encryption. A broadcast encryption scheme allows the sender to securely distribute data to a dynamically changing set of users over an insecure channel, with the possibility of "revoking" users when they are no longer "qualified". One of the most challenging settings for this problem is that of stateless receivers, where each user is given a fixed set of keys which cannot be updated for the lifetime of the system. This setting was considered by Naor, Naor, and Lotspiech <ref type="bibr" target="#b32">[33]</ref>, who also present a general "subset cover framework" for this problem. Although originally used in the symmetric-key setting, Dodis and Fazio <ref type="bibr" target="#b16">[17]</ref> extended the subset cover framework to the public-key setting, where anybody can encrypt the data using a single public key of the system.</p><p>Without getting into technical details, each user (more or less) stores a certain, user-specific subset of secret keys, while all the public keys are freely available to everybody (specifically, are efficiently derived from a single "global public key"; in the case of <ref type="bibr" target="#b16">[17]</ref> this is done by using an appropriate identity-based mechanism whose details are not important for the present discussion). When one wants to revoke a certain subset of users, one cleverly chooses a small subset P of public keys satisfying the following two properties: (1) every non-revoked user possesses at least one secret key corresponding to some key in P ; but (2) every revoked user possesses no secret keys in P . Once this is done, a message is simply encrypted in parallel using every key in P .</p><p>Clearly, the above corresponds exactly to a multiple encryption scheme with t p = 0 and t f = 1. However, as acknowledged in <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b16">17]</ref>, the resulting broadcast encryption scheme is at best secure against "lunch-time" chosen-ciphertext attacks even if the underlying encryption scheme being used is CCA-secure. Using the techniques of this paper, we can resolve this problem and extend the subset-cover framework to achieve CCA-security (provided, of course, that the corresponding basic encryption schemes are CCA-secure). This results in the first generic CCA-secure broadcast encryption scheme. When instantiated with any of the two subset cover methods given in <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b16">17]</ref>, we obtain two "semi-generic" con-structions of CCA-secure broadcast encryption: from any regular (e.g. <ref type="bibr" target="#b7">[8]</ref>) or any hierarchical (e.g. <ref type="bibr" target="#b24">[25]</ref>) identity-based encryption scheme, respectively. Each of these schemes, when properly instantiated, will offer several advantages over the only previously known CCA-secure broadcast encryption scheme <ref type="bibr" target="#b17">[18]</ref> (which was based on specific assumptions), including a fixed public-key size, an unbounded number of revocations, and qualitatively stronger traitor-tracing capabilities.</p><p>We remark that although wMCCA-security is already enough for this application, a more communication-efficient solution can be achieved using our sMCCA-secure scheme (since each user can then simply "ignore" the majority of the ciphertext which is "not relevant" to him).</p><p>Cryptanalysis-Tolerant CCA-Secure Encryption. As discussed in the Introduction, a multiple encryption scheme may be viewed as achieving "cryptanalysis-tolerance" for public-key encryption: namely, a message can be encrypted with respect to multiple encryption schemes (using independent keys) such that the message remains confidential as long as any one of these schemes remains secure (see <ref type="bibr" target="#b27">[28]</ref> for further discussion of this concept). Herzberg <ref type="bibr" target="#b27">[28]</ref> shows constructions of cryptanalysis-tolerant CPA-secure encryption schemes; the techniques outlined here resolve the question of constructing cryptanalysistolerant CCA-secure encryption schemes.</p><p>CCA-Secure Proxy Encryption. Proxy encryption <ref type="bibr" target="#b18">[19]</ref> may be viewed as noninteractive, two-party, threshold encryption, where one server is the end-user and the other server is called the proxy. The proxy receives the ciphertext C, partially decrypts it into some ciphertext C , and forwards C to the end-user. The user stores the second part of the decryption key and can now recover the message M from C . In <ref type="bibr" target="#b18">[19]</ref>, the authors give a formal treatment of proxy encryption but left open the question of constructing a generic, CCA-secure scheme. The generic 2-party multiple encryption scheme presented in this paper resolves this open question in the natural way. We remark that we require MCCA-security for this application, since the attacker (who is one of the servers) has full oracle access to the other server.</p><p>Other Applications. We believe that multiple encryption schemes will find even more uses; we highlight two. One interesting direction is to apply multiple encryption to the construction of "anonymous channels" <ref type="bibr" target="#b13">[14]</ref> using, e.g., "onion routing" <ref type="bibr" target="#b25">[26]</ref>. It would be interesting to see if our methods can be extended to give CCA-secure constructions in this setting. For the second application, we mention recent work of Boneh, et al. <ref type="bibr" target="#b8">[9]</ref> on searchable public-key encryption. Here, one wants to design an encryption scheme for which one can encrypt some keyword W as a ciphertext C such that that: (1) given some trapdoor T W one can test whether C is an encryption of W ; (2) without such trapdoor, one gets no information about W , even when given many other trapdoors T X for X = W (except that W is not one of these X's). It is not hard to see that this concept is also related to anonymous IBE, where the ciphertext should not reveal anything about the identity of the recipient of the message. Alternately, it is also related to key-insulated encryption in which the ciphertext does not reveal the time period for which the ciphertext was encrypted. In all these cases, one can adapt the generic construction of key-insulated encryption from <ref type="bibr" target="#b19">[20]</ref>, discussed earlier in this section, to obtain a CPA-secure version of the corresponding primitive, provided that the regular encryption E is key-indistinguishable <ref type="bibr" target="#b1">[2]</ref>. Indeed, one of the constructions in <ref type="bibr" target="#b8">[9]</ref> exactly follows this route. Using the techniques in this paper, we can obtain generic CCA-secure searchable encryption, recipientanonymous IBE, or time-anonymous key-insulated encryption, provided one uses a CCA-secure, key-indistinguishable encryption scheme (such as the Cramer-Shoup encryption scheme <ref type="bibr" target="#b14">[15]</ref>, shown to be key-indistinguishable by <ref type="bibr" target="#b1">[2]</ref>). a given message M using a secret key τ . In fact, a "one-time" message authentication code (defined analogously to a one-time signature scheme) is sufficient for our purposes. We define a relaxed commitment scheme C = (Setup, Commit, Open) (termed encapsulation in <ref type="bibr" target="#b9">[10]</ref>) as follows: Setup(1 k ) outputs the public commitment key CK, which is always input to both Commit and Open and is omitted for brevity. Commit takes no inputs and produces a triple of values (τ, c, d), where τ is a (random) key, c is the commitment to this key, and d is the corresponding decommitment. Open(c, d) should produce τ under normal circumstances. The hiding property states that τ "looks random" given c (i.e., one cannot efficiently distinguish (CK, c, τ) from (CK, c, r) for random r). The relaxed binding property states that given a random triple (τ, c, d) output by Commit, it is infeasible to produce d = d such that Open(c, d ) ∈ {τ, ⊥}. It is easy to construct simple and efficient MACs and relaxed commitment schemes (see <ref type="bibr" target="#b9">[10]</ref>).</p><p>Given the above, we construct T E wcca as follows:</p><p>- Theorem 3. T E wcca is wMCCA-secure with thresholds t p , t f , t r , t s , provided E is CCA-secure, SSS is (t p , t f , t r , t s , n)-robust, C is a relaxed commitment scheme, and MAC is a one-time message authentication code.</p><p>We give the complete proof in the full version, here only briefly sketching our argument (which is based on <ref type="bibr" target="#b9">[10]</ref>). The problem is the apparent circularity in the usage of the MAC as Tag is applied to data which depends on the MAC key τ . Intuitively, what saves us here is the relaxed binding property which holds even when the adversary knows d. This means that when the attacker is given the challenge ciphertext C, it has to either (1) try to use new value c (which does not help due to the CCA-security of the underlying encryption scheme which uses c as a label); or (2) reuse the same c and cause an invalid d = d to be recovered (which leads to rejection anyway); or (3) reuse the same pair (c, d), which results in the same τ and then also to rejection due to the one-time security of the MAC. The latter argument is the most delicate, and its proof in fact requires several sub-arguments. See <ref type="bibr" target="#b9">[10]</ref> for further details.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>(1 k ) and set TEK = (EK 1 , . . . , EK n ), TDK i = DK i , so that TDK = (DK 1 , . . . , DK n ). Below, letEnc i def = Enc EKi and Dec i def = Dec DKi . -TEnc L (M ): Let (s 1 , . . . , s n , pub) ← Share(M ), and (VK, SK) ← Sig-Gen(1 k ). Set C i = Enc VK i (s i ) (for i = 1, . . . , n) and then compute the signature σ = Sig SK (C 1 , . . . , C n , pub, L). Output C = (C 1 , . . . , C n , pub, VK, σ). -Split L (C): Parse C as (C 1 , . . . , C n , pub, VK, σ),and reject if verification fails; i.e., if Ver VK ((C 1 , . . . , C n , pub, L), σ) = 0. Otherwise, set ciphertext share Ĉi = (C i , VK) and aux = pub.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>TGen(1 k ). Let CK ← Setup(1 k ), and for i = 1 . . . n, let (EK i ,DK i ) ← Gen(1 k ). Set TEK = (EK 1 . . . EK n , CK), TDK i = DK i , so that TDK = (DK 1 . . . DK n ). Below, denote Enc i = Enc EKi , Dec i = Dec DKi . -TEnc L (M ). Let (τ, c, d) ← Commit(1 k ) and (s 1 , . . . , s n , pub) ← Share(M, d).SetC i = Enc c i (s i ) (i = 1 . . . n) and compute σ = Tag τ (C 1 , . . . , C n , pub, L). Output C = (C 1 , . . . , C n , pub, c, σ). -Split L (C). Parse C = (C 1 , . . . , C n , pub, c, σ),and let ciphertext share Ĉi = (C i , c), and aux = (pub, c, L). -TDec i (C i , c). Output s i = Dec c i (C i ). -Combine(s 1 , . . . , s n , (pub, c, L)). Let (M, d) = Rec(s 1 , . . . s n , pub) (if invalid, reject). Let τ = Open(c, d). Reject if σ = Tag τ (C 1 , . . . , C n , pub, L). Otherwise, output M .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>and ⊥ otherwise. -Combine(s 1 , . . . , s n , pub). Output Rec(s 1 , . . . s n , pub).</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Sometimes, we may also have a setup procedure which prepares public parameters. For simplicity, we omit this from our description.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>This is so since one can simulate (with all but negligible probability) any "allowed" call to DEC(Split (•) (•)) by n "allowed" calls to TDec (•) (•).</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This work was supported by the NSF under CAREER Award CCR-0133806 and Trusted Computing Grant CCR-0311095. This work was supported by NSF Trusted Computing Grant CCR-0310751.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Security Amplification by Composition: the Case of Doubly-Iterated, Ideal Ciphers</title>
		<author>
			<persName><forename type="first">B</forename><surname>Aiello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">Di</forename><surname>Crescenzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Venkatesan</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">98</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Key-Privacy in Public-Key Encryption</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Boldyreva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Desai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pointcheval</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Relations among Notions of Security for Public-Key Encryption Schemes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Desai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pointcheval</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">98</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Authenticated Encryption: Relations Among Notions and Analysis of the Generic Composition Paradigm</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Namprempre</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
	<note>Asiacrypt</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Protecting against Key Exposure: Strongly Key-Insulated Encryption with Optimal Threshold</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Palacio</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2002/064" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Collision-Resistant Hashing: Towards Making UOWHFs Practical</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">97</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Efficient Selective-ID Secure Identity Based Encryption Without Random Oracles</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Boyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Eurocrypt</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Identity-Based Encryption From the Weil Pairing</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Franklin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Crypto</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Di Crescenzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Persiano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Eurocrypt</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>Searchable Public Key Encryption</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Improved Efficiency for CCA-Secure Cryptosystems Built Using Identity Based Encryption. RSA -Cryptographers&apos; Track</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Exposure-Resilient Functions and All-or-Nothing Transforms</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Eurocrypt</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Chosen-Ciphertext Security from Identity-Based Encryption</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Eurocrypt</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">An Efficient Threshold Public-Key Cryptosystem Secure Against Adaptive Chosen-Ciphertext Attack</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">99</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Untraceable Electronic Mail, Return Addresses, and Digital Pseudonyms</title>
		<author>
			<persName><forename type="first">D</forename><surname>Chaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="84" to="88" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">A Practical Public Key Cryptosystem Provably Secure Against Chosen Ciphertext Attack</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cramer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">98</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Society and Group-Oriented Cryptography: a New Concept</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Desmedt</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Crypto &apos;87</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Public Key Broadcast Encryption for Stateless Receivers</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Fazio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Workshop on Digital Rights Management</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Public Key Broadcast Encryption Secure Against Adaptive Chosen Ciphertext Attack</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Fazio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PKC</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Proxy Cryptography Revisited</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ivan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">NDSS</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Eurocrypt</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Key-Insulated Public-Key Cryptosystems</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">On the Power of Cascade Ciphers</title>
		<author>
			<persName><forename type="first">S</forename><surname>Even</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comp. Systems</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="108" to="116" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Fiat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<title level="m">Broadcast Encryption. Crypto &apos;93</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
		<title level="m">Communication Complexity of Secure Computation. STOC &apos;92</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Certificate-Based Encryption and the Certificate Revocation Problem</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Eurocrypt</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Hierarchical Id-Based Cryptography</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Silverberg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Onion Routing</title>
		<author>
			<persName><forename type="first">D</forename><surname>Goldschlag</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Syverson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="39" to="41" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A Digital Signature Scheme Secure Against Adaptive Chosen-Message Attacks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rivest</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Computing</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="281" to="308" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">On Tolerant Cryptographic Constructions</title>
		<author>
			<persName><forename type="first">A</forename><surname>Herzberg</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2002/135/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
		<title level="m">Secret Sharing Made Short. Crypto &apos;93</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">An Efficient Two-Party Public Key Cryptosystem Secure Against Adaptive Chosen Ciphertext Attack</title>
		<author>
			<persName><forename type="first">P</forename><surname>Mackenzie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PKC</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Cascade Ciphers: the Importance of Being First</title>
		<author>
			<persName><forename type="first">U</forename><surname>Maurer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Massey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Crypto</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="55" to="61" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">On the Security of Multiple Encryption</title>
		<author>
			<persName><forename type="first">R</forename><surname>Merkle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hellman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="465" to="467" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Revocation and Tracing Schemes for Stateless Receivers</title>
		<author>
			<persName><forename type="first">D</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lotspiech</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Crypto</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Portfolio of Recommended Cryptographic Primitives</title>
		<author>
			<orgName type="collaboration">NESSIE consortium</orgName>
		</author>
		<ptr target="http://www.cosic.esat.kuleuven.ac.be/nessie/deliverables/decision-final.pdf" />
		<imprint>
			<date type="published" when="2003-02">Feb. 2003</date>
		</imprint>
	</monogr>
	<note>Manuscript</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Efficient Dispersal of Information for Security, Load Balancing, and Fault Tolerance</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rabin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="335" to="348" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">All-or-Nothing Encryption and the Package Transform</title>
		<author>
			<persName><forename type="first">R</forename><surname>Rivest</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">97</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">How to Share a Secret</title>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="612" to="613" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Communication Theory of Secrecy Systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Shannon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bell System Technical Journal</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<date type="published" when="1949-10">Oct. 1949</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">A Proposal for an ISO Standard for Public-Key Encryption</title>
		<author>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2001/112/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Securing Threshold Cryptosystems Against Chosen Ciphertext Attack</title>
		<author>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Crypto</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="75" to="96" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">On the Security of Multiple Encryption, or CCA-security+CCA-security=CCA-security? Public Key Cryptography (PKC) 2004</title>
		<author>
			<persName><forename type="first">R</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Hanaoka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Shikata</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Imai</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2003/181" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">A Replacing Signatures by MACs Recall, a message authentication code (MAC) is given by a deterministic algorithm Tag which outputs an</title>
		<imprint/>
	</monogr>
	<note>existentially unforgeable&quot; tag T = Tag τ (M ) for</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
