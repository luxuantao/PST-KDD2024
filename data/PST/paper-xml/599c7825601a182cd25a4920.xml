<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">How Behavior Trees Modularize Hybrid Control Systems and Generalize Sequential Behavior Compositions, the Subsumption Architecture, and Decision Trees</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><roleName>Student Member, IEEE</roleName><forename type="first">Michele</forename><surname>Colledanchise</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Center for Autonomous Systems</orgName>
								<orgName type="department" key="dep2">Department of Computer Vision and Active Perception</orgName>
								<orgName type="institution">KTH-Royal Institute of Technology</orgName>
								<address>
									<postCode>114 28</postCode>
									<settlement>Stockholm</settlement>
									<country key="SE">Sweden</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><roleName>Member, IEEE</roleName><forename type="first">Petter</forename><surname>Ögren</surname></persName>
							<email>petter@kth.se</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Center for Autonomous Systems</orgName>
								<orgName type="department" key="dep2">Department of Computer Vision and Active Perception</orgName>
								<orgName type="institution">KTH-Royal Institute of Technology</orgName>
								<address>
									<postCode>114 28</postCode>
									<settlement>Stockholm</settlement>
									<country key="SE">Sweden</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">How Behavior Trees Modularize Hybrid Control Systems and Generalize Sequential Behavior Compositions, the Subsumption Architecture, and Decision Trees</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">5A6B172DE6BAC9D2F7CD2D0E01BE44CC</idno>
					<idno type="DOI">10.1109/TRO.2016.2633567</idno>
					<note type="submission">received June 30, 2016; accepted October 27, 2016.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:04+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Behavior trees (BTs)</term>
					<term>decision trees</term>
					<term>finite state machines (FSMs)</term>
					<term>hybrid dynamical systems (HDSs)</term>
					<term>modularity</term>
					<term>subsumption architecture</term>
					<term>sequential behavior compositions</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Behavior trees (BTs) are a way of organizing the switching structure of a hybrid dynamical system (HDS), which was originally introduced in the computer game programming community. In this paper, we analyze how the BT representation increases the modularity of an HDS and how key system properties are preserved over compositions of such systems, in terms of combining two BTs into a larger one. We also show how BTs can be seen as a generalization of sequential behavior compositions, the subsumption architecture, and decisions trees. These three tools are powerful but quite different, and the fact that they are unified in a natural way in BTs might be a reason for their popularity in the gaming community. We conclude the paper by giving a set of examples illustrating how the proposed analysis tools can be applied to robot control BTs.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>view of FSMs that emphasize modularity. How BTs modularize HDS will be discussed in Section IV, but here we note that the core difference is that the transitions (one-way control transfers) of the FSM are replaced with function calls (two-way control transfers) up and down the tree structure of the BTs.</p><p>Following the development in the industry, BTs have now also started to receive attention in academia, see, e.g., <ref type="bibr" target="#b6">[7]</ref>- <ref type="bibr" target="#b16">[17]</ref>.</p><p>At Carnegie Mellon University, BTs have been used extensively for robotic manipulation <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b14">[15]</ref>. The fact that modularity is the key reason for using BTs is clear from the following quote: "The main advantage is that individual behaviors can easily be reused in the context of another higher level behavior, without needing to specify how they relate to subsequent behaviors." from <ref type="bibr" target="#b11">[12]</ref>.</p><p>BTs have also been used to enable nonexperts to do robot programming of pick and place operations, due to their "modular, adaptable representation of a robotic task" <ref type="bibr" target="#b16">[17]</ref> and proposed as a key component in brain surgery robotics due to the "flexibility, reusability, and simple syntax" <ref type="bibr" target="#b15">[16]</ref>.</p><p>The advantage of BTs as compared to FSMs was also the reason for extending the JADE agent behavior model with BTs in <ref type="bibr" target="#b9">[10]</ref>, and the benefits of using BTs to control complex multimission UAVs was described in <ref type="bibr" target="#b10">[11]</ref>.</p><p>The modularity and structure of BTs were used to address the formal verification of mission plans in <ref type="bibr" target="#b12">[13]</ref> and the execution times of stochastic BTs were analyzed in <ref type="bibr" target="#b13">[14]</ref>. BTs have also been studied in machine learning applications <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b7">[8]</ref> and details regarding efficient parameter passing was investigated in <ref type="bibr" target="#b8">[9]</ref>. Finally, a Modelica implementation of BTs was presented in <ref type="bibr" target="#b17">[18]</ref>.</p><p>In this paper, we investigate the key property of BTs, modularity, by using standard tools from robot control theory. The benefits of modularity become even clearer when key system properties can be shown to be preserved across compositions of smaller modules into bigger systems. We will try to capture to what extent this holds for BTs. The key properties we investigate is efficiency, in terms of time to successful completion; safety, in terms of avoiding particular parts of the state space; and robustness, in terms of large regions of attraction, as shown in Fig. <ref type="figure" target="#fig_0">1</ref>.</p><p>As noted above, the reason BTs are more modular than FSMs is that they use a two-way control transfer, where behavior switching is defined by the context of the parent behavior. To Performing this analysis, we also show that BTs can be seen as generalizations of three classical concepts from the robot control literature, the subsumption architecture <ref type="bibr" target="#b18">[19]</ref>, sequential behavior compositions <ref type="bibr" target="#b19">[20]</ref>, and decision trees <ref type="bibr" target="#b20">[21]</ref>.</p><p>The subsumption architecture <ref type="bibr" target="#b18">[19]</ref> is a control structure where a number of controllers are executed in parallel, and higher priority controllers subsume (or suppress), the lower priority ones, whenever needed.</p><p>Sequential behavior compositions were introduced in <ref type="bibr" target="#b19">[20</ref>] and built upon in, e.g., <ref type="bibr" target="#b21">[22]</ref>. The key idea is that the region of attraction of a controller can be increased by combining a set of different controllers, where each controller drives the system state into the region of attraction of another controller, closer to the overall goal state.</p><p>Decision trees <ref type="bibr" target="#b20">[21]</ref> is a control structure where the controllers are found at the leaves of the tree, and the interior nodes of the tree represent state-dependent predicates, which determine what branches to follow from the root to one of the leaves.</p><p>The contributions of this paper is that we formally investigate and capture the modularity of BTs, by introducing a functional representation. This formulation enables us to show the results regarding safety, efficiency, and robustness of modular compositions of BTs. We also explore how BTs generalize three classical concepts from the robot control literature, and the connection between BTs and FSMs. This paper extends the conference paper <ref type="bibr" target="#b22">[23]</ref> by adding results on the efficiency of sequence compositions, the analysis of decision trees, a detailed analysis of the relation between BTs and FSMs, and more examples illustrating modularity, and the use of the theoretical results.</p><p>The outline of this paper is as follows. In Section II, we review the classical formulation of BTs. Then, in Section III, we introduce a new compact function call formulation of BTs. In Section IV we describe how the BTs modularize hybrid control systems, both conceptually and in terms of how system properties are preserved under module compositions. Then, the way in which BTs generalize a number of existing control structures is investigated in Section V. Finally, a complex example is given in Section VI, and the conclusion is drawn in Section VII.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. BACKGROUND: CLASSICAL FORMULATION OF BTS</head><p>In this section, we will describe BTs in the classical way that can be found in textbooks, such as <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b4">[5]</ref>, and papers on game AI such as <ref type="bibr" target="#b0">[1]</ref> and <ref type="bibr" target="#b2">[3]</ref>. The following section (III) will then provide a functional description of BTs that will be used for our formal analysis.</p><p>Let BT be a directed tree, with the usual definition of nodes, edges, root, leaves, children, and parents. In a BT, each node belongs to one of the five categories listed in Table <ref type="table" target="#tab_0">I</ref>. Leaf nodes are either Actions or Conditions, while interior nodes are either Fallbacks, Sequences or Parallels. A minimalistic example BT composed of one Fallback node and two Action nodes can be seen in Fig. <ref type="figure">2</ref>.</p><p>When a BT is executed, the root node is ticked with a given frequency, and corresponding timestep Δt. This tick will then progress downwards through the tree, following the rules of the different node types, until it reaches a leaf node. There, some computations are made, often taking both internal states and sensor data into account. If the leaf node is an Action, it might issue some commands to the robot actuators, and it returns either Success, Failure or Running to its parent. The parent node then either returns the same message to its parent, or chooses to tick another child who in turn returns Success/Failure/Running, and so on. We will now describe how this works in more detail. The first node type in Table <ref type="table" target="#tab_0">I</ref> is the Fallback.</p><p>Fallback 1 : Fallbacks are used when a set of actions represent alternative ways of reaching a similar goal. Thus, Fallbacks will try each of its children, from left to right, and return Success as soon as it has found one child that returns Success. It will return Running as long as the ticked child returns Running and Failure only when all children have failed, as shown in Table <ref type="table" target="#tab_0">I</ref> and the pseudocode below.</p><p>Looking at the example BT in Fig. <ref type="figure">2</ref>, the Fallback has two actions, Enter through Front Door and Enter through Back Door, each with the common purpose of Enter Building (the name of the whole BT). The root of the BT is the Fallback, and the Actions are the leaves. According to the pseudocode in Algorithm 1, when the root/Fallback is ticked, it ticks its first child. The Action Enter through Front Door then starts executing the corresponding continuous robot controller, and returns Running. The Fallback/root also returns Running. Then, after the given time step Δt, a new tick is sent from the root, and the whole process is repeated. The return status of the different nodes probably remains the same for a number of time steps. Then, at some point, Enter through Front Door does not return Running anymore, but instead returns either Success if it managed to enter through the door, or Failure if it did not manage. In case of Success, the Fallback also returns Success, but in the case of Failure, the Fallback instead starts ticking Enter through Back Door, which probably returns Running for a number of 1 Fallbacks are sometimes also called selectors.  ticks. Finally, when Enter through Back Door returns either Success or Failure, the fallback will return the corresponding thing, as there are no more options to try in case of Failure, and no more options needed in case of Success.</p><p>The second node type is Sequence, and a minimalistic BT using a Sequence can be found in Fig. <ref type="figure" target="#fig_1">3</ref>.</p><p>Sequence: Sequences are used when some actions are meant to be carried out in sequence, and when the success of one action is needed for the execution of the next. Thus, Sequences find and execute the first child that does not return success. A Sequence will return immediately with a status code failure or running when one of its children returns failure or running, see Table <ref type="table" target="#tab_0">I</ref> and the pseudocode in Algorithm 2. The children are ticked in order, from left to right.</p><p>Looking at the example BT in Fig. <ref type="figure" target="#fig_1">3</ref>, the Sequence has two actions, Open Front Door and Pass through Door. If both succeed, the whole BT, Enter through Front Door, will succeed. But if the first action fails, the overall task has failed, and there is no point in trying the second action.</p><p>Remark 1: The definition above corresponds to so-called memoryless Sequences. Most BT implementations also include a Sequence with memory, where a subtree that returned Succeed is never executed again.</p><p>The third node type is Parallel, and a minimalistic BT using a parallel node can be found in Fig. <ref type="figure" target="#fig_2">4</ref>.</p><p>Parallel: A parallel node ticks all its children simultaneously. If M out of the N children return success, then so does the parallel node. If more than N -M return failure, thus rendering success impossible, it returns failure. If none of the conditions above are met, it returns running.</p><p>We will now define the two types of leaf nodes.</p><p>Action: An Action node performs an action, and returns Success if the action is completed, Failure if it cannot be completed and Running if completion is under way.</p><p>Condition: A Condition node determines if a given condition has been met, therefore, success/failure are often interpreted as true/false. Conditions are technically a subset of the Actions, but are given a separate category and graphical symbol to improve readability of the BT and emphasize the fact that they never return running and do not change any internal states/variables of the BT. Examples of Conditions can be found in Fig. <ref type="figure" target="#fig_3">5</ref>.</p><p>We conclude this section with an illustration of how smaller BTs can be combined into larger ones and a remark on nonreactive BTs.</p><p>The BT in Fig. <ref type="figure" target="#fig_4">6</ref> is a straightforward combination of Figs. <ref type="figure">2</ref> and<ref type="figure" target="#fig_1">3</ref>. If we add the battery power check of Fig. <ref type="figure" target="#fig_3">5</ref>, and some additional actions such as Close Front Door (in Sequence with Pass through Front Door) and Smash Back Door (as a fallback of Open Back Door), we get the BT in Fig. <ref type="figure" target="#fig_5">7</ref>.  Remark 2: Some BT implementations do not include the Running return status <ref type="bibr" target="#b3">[4]</ref>. Instead, they let each action run until it returns Failure or Success. We denote these BTs nonreactive, since they do not allow actions other than the currently active one to react to changes. This is a significant limitation on nonreactive BTs, which was also noted in <ref type="bibr" target="#b3">[4]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. NEW FUNCTIONAL FORMULATION OF BTS</head><p>In this section, we present a new functional formulation of the BTs described above. The new formulation is more formal, and will allow us to analyze how properties are preserved over modular compositions of BTs. In the functional version, the tick is replaced with a recursive function call that include both the return status, the system dynamics and the system state. The details of the formulation are derived from the pseudocode in Algorithms 1-3.</p><p>Definition 1 (Behavior Tree): A BT is a three tuple</p><formula xml:id="formula_0">T i = {f i , r i , Δt}<label>(1)</label></formula><p>where i ∈ N is the index of the tree, f i : R n → R n is the righthand side of an ordinary difference equation, Δt is a time step and r i : R n → {R, S, F} is the return status that can be equal to either Running (R), Success (S), or Failure (F). Let the Running/Activation region (R i ), Success region (S i ), and Failure region (F i ) correspond to a partitioning of the state space, defined as</p><formula xml:id="formula_1">R i = {x : r i (x) = R} (<label>2</label></formula><formula xml:id="formula_2">)</formula><formula xml:id="formula_3">S i = {x : r i (x) = S} (<label>3</label></formula><formula xml:id="formula_4">)</formula><formula xml:id="formula_5">F i = {x : r i (x) = F}. (<label>4</label></formula><formula xml:id="formula_6">)</formula><p>Finally, the execution of a BT T i is a standard ordinary difference equation</p><formula xml:id="formula_7">x k +t (t k +1 ) = f i (x k (t k ))<label>(5)</label></formula><formula xml:id="formula_8">t k +1 = t k + Δt.<label>(6)</label></formula><p>The return status r i will be used when recursively combining BTs, as explained below.</p><p>Assumption 1: From now on we will assume that all BTs evolve in the same continuous space R n using the same time step Δt i .</p><p>Remark 3: It is often the case, that different BTs, controlling different vehicle subsystems evolving in different state spaces, need to be combined into a single BT. Such cases can be accommodated in the assumption above by letting all systems evolve in a larger state space, that is the Cartesian product of the smaller state spaces.</p><p>The five node types of Table <ref type="table" target="#tab_0">I</ref> are given functional representations as follows. BTs that satisfy Definition 1 directly, without calling other subtrees, are called Actions and Conditions, with the later ones never returning Running. The three composition nodes, corresponding to Algorithms 1-3 are defined below.</p><p>Definition 2 (Sequence compositions of BTs): Two or more BTs can be composed into a more complex BT using a Sequence operator</p><formula xml:id="formula_9">T 0 = Sequence (T 1 , T 2 ).</formula><p>Then r 0 , f 0 are defined as</p><formula xml:id="formula_10">If x k ∈ S 1 (7) r 0 (x k ) = r 2 (x k ) (8) f 0 (x k ) = f 2 (x k )<label>(9)</label></formula><p>else</p><formula xml:id="formula_11">r 0 (x k ) = r 1 (x k ) (<label>10</label></formula><formula xml:id="formula_12">)</formula><formula xml:id="formula_13">f 0 (x k ) = f 1 (x k ).<label>(11)</label></formula><p>T 1 and T 2 are called children of T 0 . Note that when executing the new BT, T 0 first keeps executing its first child T 1 as long as it returns Running or Failure. The second child is executed only when the first returns Success, and T 0 returns Success only when all children have succeeded, hence the name Sequence. For notational convenience, we write</p><formula xml:id="formula_14">Sequence (T 1 , Sequence (T 2 , T 3 )) = Sequence (T 1 , T 2 , T 3 )<label>(12</label></formula><p>) and similarly for arbitrarily long compositions.</p><p>Definition 3 (Fallback compositions of BTs): Two or more BTs can be composed into a more complex BT using a Fallback operator</p><formula xml:id="formula_15">T 0 = Fallback (T 1 , T 2 ).</formula><p>Then r 0 , f 0 are defined as</p><formula xml:id="formula_16">If x k ∈ F 1 (13) r 0 (x k ) = r 2 (x k ) (<label>14</label></formula><formula xml:id="formula_17">)</formula><formula xml:id="formula_18">f 0 (x k ) = f 2 (x k )<label>(15)</label></formula><p>else</p><formula xml:id="formula_19">r 0 (x k ) = r 1 (x k )<label>(16)</label></formula><formula xml:id="formula_20">f 0 (x k ) = f 1 (x k ).<label>(17)</label></formula><p>Note that when executing the new BT, T 0 first keeps executing its first child T 1 as long as it returns Running or Success. The second child is executed only when the first returns Failure, and T 0 returns Failure only when all children have tried, but failed, hence the name Fallback.</p><p>For notational convenience, we write</p><formula xml:id="formula_21">Fallback (T 1 , Fallback (T 2 , T 3 )) = Fallback (T 1 , T 2 , T 3 ) (18)</formula><p>and similarly for arbitrarily long compositions. Parallel compositions only make sense if the BTs to be composed control separate parts of the state space, thus we make the following assumption.</p><p>Assumption 2: Whenever two BTs T 1 , T 2 are composed in parallel, we assume that there is a partition of the state space x = (x 1 , x 2 ) such that f 1 (x) = (f 11 (x), f 12 (x)) implies f 12 (x) = 0 and f 2 (x) = (f 21 (x), f 22 (x)) implies f 21 (x) = 0 (i.e., the two BTs control different parts of the system).</p><p>Definition 4 (Parallel compositions of BTs): Two or more BTs can be composed into a more complex BT using a Parallel operator,</p><formula xml:id="formula_22">T 0 = Parallel(T 1 , T 2 ).</formula><p>Let x = (x 1 , x 2 ) be the partitioning of the state space described in Assumption 2, then f 0 (x) = (f 11 (x), f 22 (x)) and r 0 is defined as</p><formula xml:id="formula_23">If M = 1 r 0 (x) = S If r 1 (x) = S ∨ r 2 (x) = S (19) r 0 (x) = F If r 1 (x) = F ∧ r 2 (x) = F (20) r 0 (x) = R else (21) If M = 2 r 0 (x) = S If r 1 (x) = S ∧ r 2 (x) = S (22) r 0 (x) = F If r 1 (x) = F ∨ r 2 (x) = F (23) r 0 (x) = R else. (<label>24</label></formula><formula xml:id="formula_24">)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. HOW BTS MODULARIZE HDSS</head><p>In this section, we will show how BTs modularize the FSMs in HDS. We believe that this modularity is important when designing, testing, and reusing complex task switching structures.</p><p>First we show how FSMs can be given the structure of BTs, then we make an informal argument based on a comparison of function calls with GOTO-statements. Then, we will make a formal argument by showing how some system properties are preserved under modular compositions of BTs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Giving an FSM the Structure of a BT</head><p>As described above, each BT returns Success, Running or Failure. Imagine we have a state in an FSM that has three transitions, corresponding to these three return statements. Adding a Tick source that collect the return transitions and transfer the execution back into the state, as depicted in Fig. <ref type="figure" target="#fig_6">8</ref>, we have a structure that resembles a BT.</p><p>We can now compose such FSM states by using both Fallback and Sequence constructs. The FSM corresponding to the Fallback example in Fig. <ref type="figure">2</ref> would then look like the one shown in Fig. <ref type="figure" target="#fig_7">9</ref>.</p><p>Similarly, the FSM corresponding to the Sequence example in Fig. <ref type="figure" target="#fig_1">3</ref> would then look like the one shown in Fig. <ref type="figure" target="#fig_8">10,</ref> and<ref type="figure">a</ref> two-level BT, such as the one in Fig. <ref type="figure" target="#fig_4">6</ref> would look like Fig. <ref type="figure" target="#fig_9">11</ref>. A few observations can be made from the above examples. First, it is perfectly possible to design FSMs, and therefore HDSs with a structure taken from BTs. Second, considering that a BT with two levels corresponds to the FSM in Fig. <ref type="figure" target="#fig_9">11</ref>, a BT with five levels, such as the one in Fig. <ref type="figure" target="#fig_5">7</ref> would correspond to a somewhat complex FSM.</p><p>Third, and more importantly, the modularity of the BT construct is illustrated in Figs. 8-11. Fig. <ref type="figure" target="#fig_9">11</ref> might be complex, but that complexity is encapsulated in a box with a single intransition and three out-transitions, just as the box in Fig. <ref type="figure" target="#fig_6">8</ref>.</p><p>Fourth, the decision of what to do after a given sub-BT returns is always decided on the parent level of that BT. The sub-BT is ticked, and returns Success, Running or Failure and the parent level decided whether to tick the next child, or return something to its own parent. Thus, the BT ticking and returning of a sub-BT is similar to a function call in a piece of source code. A function call in Java, C++ or Python moves execution to another piece of the source code, but then returns the execution to the line right below the function call. What to do next is decided by the piece of code that made the function call, not the function itself. As we will see below, this is quite different from standard FSMs where the decision of what to do next is decided by the state being transitioned to, in a way that resembles the GOTO statement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Function Calls and GOTO Statements</head><p>In this section, we will argue that the switching structure provided by BTs supports modularity.</p><p>The switching structure of an HDS is given by the transitions of an FSM. These transitions are intuitive, straightforward, and compact. However, they represent control transfers that are socalled one-way and thus share the drawbacks that made the GOTO-statement obsolete.</p><p>Forty years ago, a control flow statement called GOTO was used extensively in computer programming. Today, this feature has been abandoned by most general purpose programming languages, and the reasons for this was formulated in a famous quote by Edsgar Dijkstra in his paper GOTO statement considered harmful <ref type="bibr" target="#b23">[24]</ref>: "The GOTO statement as it stands is just too primitive; it is too much an invitation to make a mess of one's program".</p><p>To understand the rationale behind Dijkstas statement, we note that GOTO statements are one-way control transfers, where the execution is transferred somewhere in a more or less memoryless fashion. The alternative to one-way control transfers is the two-way control transfer embodied in, e.g., function calls. Here, control is transferred back to the place of the function call, together with a result of the computation in the function. Thus, the implementation of the function does not depend on how the results will be used, and the user of the function does not have to know how it is implemented. On the contrary, in one-way control transfers, the implementation of the functionality must also include instructions of what to do next. This fact couples implementation and usage, and makes modular design less straightforward.</p><p>Looking at the state machines in HDSs, we note that the state transitions are indeed one-way control transfers. The called state must also include instructions of what to do next. As above, this fact sometimes makes designing a modular HDS using FSMs quite difficult.</p><p>One final, and smaller, drawback of FSMs lies in the graphical representation. The FSM has arrows for possible transitions, but the actual conditions for the transfers has no graphical representation. For BTs, it is clear from the tree structure and node types what a success/failure will mean for the future execution.</p><p>Note however, that there are no claims that BTs are superior to FSMs from a purely theoretical standpoint. On the contrary, all BTs can most likely be formulated in terms of an FSM, just as most general purpose programming languages are equivalent in the sense of Turing completeness, but still differ in modularity, readability, and reusability of code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. How BTs Modularize Efficiency and Robustness</head><p>In this section, we will show how some aspects of time efficiency and robustness carry across modular compositions of BTs. This result will then enable us to conclude that if two BTs are "efficient," then their composition will also be "efficient," if the right conditions are satisfied. We also show how the Fallback composition can be used to increase the region of attraction of a BT, thereby making it more robust to uncertainties in the initial configuration.</p><p>Note that in this paper, as in <ref type="bibr" target="#b19">[20]</ref>, by robustness we mean large regions of attraction. We do not investigate, e.g., disturbance rejection, or other forms of robustness.</p><p>Many control problems, in particular in robotics, can be formulated in terms of achieving a given goal configuration in a way that is time efficient and robust with respect to the initial configuration. Since all BTs return either Success, Failure or Running, the definitions below will include a finite time, at which Success must be achieved.</p><p>In order to formalize the discussion above, we say that efficiency can be measured by the size of the time bound τ in Definition 5 and robustness can be measured by the size of the region of attraction R in the same definition.</p><p>Definition 5 (Finite Time Successful): A BT is finite time successful (FTS) with region of attraction R , if for all starting points x(0) ∈ R ⊂ R, there is a time τ , and a time τ (x(0)) such that τ (x) ≤ τ for all starting points, and x(t) ∈ R for all t ∈ [0, τ ) and x(t) ∈ S for all t ≥ τ ).</p><p>As noted in the following lemma, exponential stability implies finite time success, given the right choices of the sets S, F, R.</p><p>Lemma 1 (Exponential stability and FTS): A BT for which x s is a globally exponentially stable equilibrium of the execution (5), and S ⊃ {x</p><formula xml:id="formula_25">: ||x -x s || ≤ }, &gt; 0, F = ∅, R = R n \ S, is FTS.</formula><p>Proof: Global exponential stability implies that there exists a &gt; 0 such that ||x(k)x s || ≤ e -ak for all k. Then, for each there is a time τ such that ||x(k)x s || ≤ e -aτ &lt; , which implies that there is a τ &lt; τ such that x(τ ) ∈ S and the BT is FTS.</p><p>We are now ready to look at how these properties extend across compositions of BTs.</p><p>Lemma 2: (Robustness and efficiency of sequence compositions) If T 1 , T 2 are FTS, with</p><formula xml:id="formula_26">S 1 = R 2 ∪ S 2 , then T 0 = Sequence (T 1 , T 2 ) is FTS with τ 0 = τ 1 + τ 2 , R 0 = R 1 ∪ R 2 and S 0 = S 1 ∩ S 2 .</formula><p>Proof: First we consider the case when x(0) ∈ R 1 . Then, as T 1 is FTS, the state will reach S 1 in a time k 1 &lt; τ 1 , without leaving R 1 . Then T 2 starts executing, and will keep the state inside S 1 , since S 1 = R 2 ∪ S 2 . T 2 will then bring the state into S 2 , in a time k 2 &lt; τ 2 , and T 0 will return Success. Thus, we have the combined time</p><formula xml:id="formula_27">k 1 + k 2 &lt; τ 1 + τ 1 .</formula><p>If x(0) ∈ R 2 , T 1 immediately returns Success, and T 2 starts executing as above.</p><p>The lemma above is illustrated in Fig. <ref type="figure" target="#fig_10">12</ref>, and Example 1 below.</p><p>Example 1: Consider the BT in Fig. <ref type="figure" target="#fig_1">3</ref>. If we know that Open Front Door is FTS and will finish in less than τ 1 seconds, and that Pass through Door is FTS and will finish in less than τ 2 seconds. Then, as long as S 1 = R 2 ∪ S 2 , Lemma 2 states that the combined BT in Fig. <ref type="figure" target="#fig_1">3</ref> is also FTS, with an upper bound on the execution time of τ 1 + τ 2 . Note that the condition S 1 = R 2 ∪ S 2 implies that the action Pass through Door will not make the system leave S 1 , by, e.g., accidentally colliding with the door and thereby closing it without having passed through it. IEEE TRANSACTIONS ON ROBOTICS  The result for Fallback compositions is related, but with a slightly different condition on S i and R j .</p><p>Lemma 3: (Robustness and efficiency of fallback compositions)</p><formula xml:id="formula_28">If T 1 , T 2 are FTS, with S 2 ⊂ R 1 , then T 0 = Fallback (T 1 , T 2 ) is FTS with τ 0 = τ 1 + τ 2 , R 0 = R 1 ∪ R 2 and S 0 = S 1 .</formula><p>Proof: First we consider the case when x(0) ∈ R 1 . Then, as T 1 is FTS, the state will reach S 1 before k = τ 1 &lt; τ 0 , without leaving R 1 . If x(0) ∈ R 2 \ R 1 , T 2 will execute, and the state will progress toward S 2 . But as S 2 ⊂ R 1 , x(k 1 ) ∈ R 1 at some time k 1 &lt; τ 2 . Then, we have the case above, reaching</p><formula xml:id="formula_29">x(k 2 ) ∈ S 1 in a total time of k 2 &lt; τ 1 + k 1 &lt; τ 1 + τ 2 .</formula><p>The Lemma above is illustrated in Fig. <ref type="figure" target="#fig_11">13</ref>, and Example 2 below.</p><p>Remark 4: As can be noted, the necessary conditions in Lemma 2, including S 1 = R 2 ∪ S 2 might be harder to satisfy than the conditions of Lemma 3, including S 2 ⊂ R 1 . Therefore, Lemma 3 is often preferable from a practical point of view, e.g., using implicit sequences as shown below.</p><p>Example 2: This example will illustrate a particular way of using Fallbacks that we call Implicit sequences. Consider the BT in Fig. <ref type="figure" target="#fig_12">14</ref>. During execution, if the door is closed, then Pass through Door will fail and Open Front Door will start to execute. Now, right before Open Front Door returns Success, the first action Pass through Door (with higher priority) will realize that the state of the world has now changed enough to enable a possible success and starts to execute, i.e., return Running instead of Failure. The combined action of this BT will thus make the robot open the door (if necessary) and then pass through if.  Thus, even though a Fallback composition is used, the result is sometimes a sequential execution of the children in reverse order (from right to left). Hence the name Implicit sequence.</p><p>The above example illustrates how we can increase the robustness of a BT. If we want to be able to handle more diverse situations, such as a closed door, we do not have to make the door passing action more complex, instead we combine it with another BT that can handle the situation and move the system into a part of the state space that the first BT can handle. The sets S 0 , F 0 , R 0 , and f 0 of the combined BT are shown in Fig. <ref type="figure" target="#fig_13">15</ref>, together with the vector field f 0 (x)x. As can be seen, the combined BT can now move a larger set of initial conditions to the desired region S 0 = S 1 . </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 4: (Robustness and efficiency of parallel compositions)</head><formula xml:id="formula_30">If T 1 , T 2 are FTS, then T 0 = Parallel(T 1 , T 2 ) is FTS with If M = 1 R 0 = {R 1 ∪ R 2 } \ {S 1 ∪ S 2 } (<label>25</label></formula><formula xml:id="formula_31">)</formula><formula xml:id="formula_32">S 0 = S 1 ∪ S 2<label>(26)</label></formula><formula xml:id="formula_33">τ 0 = min(τ 1 , τ 2 ) (27) If M = 2 R 0 = {R 1 ∩ R 2 } \ {S 1 ∩ S 2 } (28) S 0 = S 1 ∩ S 2 (29) τ 0 = max(τ 1 , τ 2 ).<label>(30)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. How BTs Modularize Safety</head><p>Besides being efficient and robust, we also want our robot system to be safe, in the sense that it by design never enters a particular part of the state space, that we for simplicity denote the Obstacle Region. We make the following definition.</p><p>Definition 6 (Safe): A BT is Safe, with respect to the obstacle region O ⊂ R n , and the initialization region I ⊂ R, if for all starting points x(0) ∈ I, we have that x(t) ∈ O, for all t ≥ 0.</p><p>In order to make statements about the safety of composite BTs we also need the following definition.</p><p>Definition 7 (Safeguarding): A BT is Safeguarding, with respect to the step length d, the obstacle region O ⊂ R n , and the initialization region I ⊂ R, if it is safe, and FTS with region of attraction R ⊃ I and a success region S, such that I surrounds S in the following sense:</p><formula xml:id="formula_34">{x ∈ X ⊂ R n : inf s∈S ||x -s|| ≤ d} ⊂ I (<label>31</label></formula><formula xml:id="formula_35">)</formula><p>where X is the reachable part of the state space R n . This implies that the system, under the control of another BT with maximal state space step length d, cannot leave S without entering I, and thus avoiding O, see Lemma 5.</p><p>Example 3: To illustrate how safety can be improved by using a Sequence composition, we consider the UAV control BT in Fig. <ref type="figure" target="#fig_14">16</ref>. The sets S i , F i , R i are shown in Fig. <ref type="figure" target="#fig_15">17</ref>. As T 1 is Guarantee altitude above 1000 ft, its failure region F 1 is small part of the state space (corresponding to a crash) surrounded by the running region R 1 that is supposed to move the UAV away from the ground, guaranteeing a minimum altitude of 1000 ft. The success region S 1 is large, every state sufficiently distant from F 1 . The BT that performs the mission, T 2 , has a smaller success region S 2 , surrounded by a very large running region R 2 , containing a small failure region F 2 . The function f 0 is   governed by ( <ref type="formula" target="#formula_10">9</ref>) and ( <ref type="formula" target="#formula_13">11</ref>) and is depicted in form of the vector field (f 0 (x)x) in Fig. <ref type="figure" target="#fig_17">18</ref> .</p><p>The discussion above is formalized in Lemma 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 5 (Safety of sequence compositions):</head><p>If T 1 is safeguarding, with respect to the obstacle O 1 initial region I 1 , and margin d, and T 2 is an arbitrary BT with max x ||xf 2 (x)|| &lt; d, then the composition T 0 = Sequence (T 1 , T 2 ) is Safe with respect to O 1 and I 1 .</p><p>Proof: T 1 is safeguarding, which implies that T 1 is safe and thus any trajectory starting in I 1 will stay out of O 1 as long as T 1 is executing. But if the trajectory reaches S 1 , T 2 will execute until the trajectory leaves S 1 . We must now show that the trajectory cannot reach O 1 without first entering I 1 . But any trajectory leaving S 1 must immediately enter I 1 , as the first state outside S 1 must lie in the set {x ∈ R n : inf</p><formula xml:id="formula_36">s∈S 1 ||x - s|| ≤ d} ⊂ I 1 due to the fact that for T 2 , ||x(k) -x(k + 1)|| = ||x(k) -f 2 (x(k))|| &lt; d.</formula><p>We conclude this section with a discussion about undesired chattering in switching systems.</p><p>The issue of undesired chattering, i.e., switching back and forth between different subcontrollers, is always an important concern while designing switched control systems, and BTs are no exception. As is suggested by the right part of Fig. <ref type="figure" target="#fig_17">18</ref>, chattering can be a problem when vector fields meet at a switching surface.</p><p>Although the efficiency of some compositions can be computed by using Lemmas 2 and 3 above, the efficiency of others can be significantly reduced by chattering, as noted above. Inspired by Filippov and Arscott <ref type="bibr" target="#b24">[25]</ref>, the following result can give an indication of when chattering is to be expected.</p><p>Let R i and R j be the running region of T i and T j , respectively. We want to study the behavior of the system when a composition of T i and T j is applied. In some cases the execution of a BT will lead to the running region of the other BT and vice-versa. Then, both BTs are alternatively executed and the state trajectory chatters on the boundary between R i and R j . We formalize this discussion in the following lemma.</p><p>Lemma 6: Given a composition T 0 = Sequence (T 1 , T 2 ), where</p><formula xml:id="formula_37">f i depend on Δt such that ||f i (x) -x|| → 0 when Δt → 0. Let s : R n → R be such that s(x) = 0 if x ∈ δS 1 ∩ R 2 , s(x) &lt; 0 if x ∈ interior (S 1 ) ∩ R 2 , s(x) &gt; 0 if x ∈ interior (R n \ S 1 ) ∩ R 2 ,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>and let</head><formula xml:id="formula_38">λ i (x) = ∂s ∂x T (f i (x) -</formula><p>Then, x ∈ δS 1 is chatter free, i.e., avoids switching between T 1 and T 2 at every timestep, for small enough Δt, if λ 1 (x) &lt; 0 or λ 2 (x) &gt; 0.</p><p>Proof: When the condition holds, the vector field is pointing outwards on at least one side of the switching boundary.</p><p>Note that this condition is not satisfied on the right-hand side of Fig. <ref type="figure" target="#fig_17">18</ref>. This concludes our analysis of BT compositions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. HOW BTS GENERALIZE DECISION TREES, THE SUBSUMPTION ARCHITECTURE, AND SEQUENTIAL BEHAVIOR COMPOSITIONS</head><p>In this we will describe decision trees, the subsumption architecture, and sequential behavior compositions, and see how each of these architectures can be seen as a special case of BTs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. How BTs Generalize Decision Trees</head><p>Decision trees are tree structures that aggregate a number of If clauses, that leads to a given decision or prediction. Each leaf of the tree represents a particular decision, prediction, conclusion, or action to be carried out, and each nonleaf represent a predicate to be checked.</p><p>A typical decision tree is shown in Fig. <ref type="figure" target="#fig_18">19</ref>. The predicates, evaluating to True/False are found in the interior nodes of the Tree, while the Actions/Conclusions are found at the leaves. Without loss of generality we consider binary decision trees, the extension to multiple choice nodes is straightforward.</p><p>In the decision tree of Fig. <ref type="figure" target="#fig_18">19</ref>, the robot has to decide whether to perform a given task or recharge its batteries. This decision is taken based upon the urgency of the task and the current battery level. The following Lemma shows how to create an equivalent BT from a given decision tree.</p><p>Lemma 7: A decision tree, can be recursively described as</p><formula xml:id="formula_39">DT i = DT i1 , if predicate P i is true DT i2 , if predicate P i is false (32)</formula><p>where DT i1 , DT i2 are either atomic actions, or sub-DTs with identical structure. Given such a DT i , we can create an equivalent BT by setting</p><formula xml:id="formula_40">T i = Fallback (Sequence (P i , T i1 ), T i2 )<label>(33)</label></formula><p>for nonatomic actions, T i = DT i for atomic actions and requiring all actions to return Running all the time. The original decision tree and the new BT are equivalent in the sense that the same values for P i will always lead to the same atomic action being executed. The lemma is illustrated in Fig. <ref type="figure" target="#fig_19">20</ref>.</p><p>Proof: Informally, first we note that by requiring all actions to return Running, we basically disable the feedback functionality that is built into the BT. Instead whatever action that is ticked will be the one that executes, just as the decision tree. Second the result is a direct consequence of the fact that the predicates of the decision trees are essentially "If ...then ...else ..." statements, which can be captured by BTs as shown in Fig. <ref type="figure" target="#fig_19">20</ref>. More formally, the BT equivalent of the decision tree is given by</p><formula xml:id="formula_41">T i = Fallback (Sequence (P i , T i1 ), T i2 ).</formula><p>For the atomic actions always returning running we have r i = R, for the actions being predicates we have that r i = P i . This, together with Definitions 2 and 3 gives that</p><formula xml:id="formula_42">f i (x) = f i1 , if predicate P i is true f i2 , if predicate P i is false (34)</formula><p>which is equivalent to (32) Note that this observation opens up the possibilities of using the extensive literature on learning decision trees from human operators, see, e.g., <ref type="bibr" target="#b20">[21]</ref>, to create BTs. These learned BTs can Fig. <ref type="figure" target="#fig_0">21</ref>. BT that is equivalent to the decision tree in Fig. <ref type="figure" target="#fig_18">19</ref>. A more compact version of the same tree can be found in Fig. <ref type="figure" target="#fig_20">22</ref>. then be extended safety or robustness features, as described in Section IV.</p><p>We finish this section with an example of how BTs generalize decision trees. Consider the decision tree in Fig. <ref type="figure" target="#fig_18">19</ref>. Applying Lemma 7 we get the equivalent BT of Fig. <ref type="figure" target="#fig_0">21</ref>. However, the direct mapping does not always take full advantage of the features of BTs. Thus a more compact, and still equivalent, BT can be found in Fig. <ref type="figure" target="#fig_20">22</ref>, where again, we assume that all actions always return Running.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. How BTs Generalize the Subsumption Architecture</head><p>In this section, we will see how the subsumption architecture, proposed by Brooks <ref type="bibr" target="#b18">[19]</ref>, can be realized by using a Fallback composition. The basic idea proposed in <ref type="bibr" target="#b18">[19]</ref> was to have a number of controllers' setup in parallel and each controller was allowed to output both actuator commands, and a binary value, signaling if it wanted to control the robot or not. The controllers were then ordered according to some priority, and the highest priority controller, out of the ones signaling for action, was allowed to control the robot. Thus, a higher level controller was able to subsume the actions of a lower level one.</p><p>An example of a subsumption architecture can be found in Fig. <ref type="figure" target="#fig_21">23</ref>. Here, the basic level controller Do Other Tasks is assumed to be controlling the robot for most of the time. However, when the battery level is low enough, the Recharge if Needed controller will signal that it needs to command the robot, subsume the lower level controller, and guide the robot toward the recharging station. Similarly, if there is risk for over-  heating, the top level controller Stop if Overheated will subsume both of the lower level ones, and stop the robot until it has cooled down.</p><p>Lemma 8: Given a subsumption architecture, we can create an equivalent BT by arranging the controllers as actions under a Fallback composition, in order from higher to lower priority. Furthermore, we let the return status of the actions be Failure if they do not need to execute, and Running if they do. They never return Success. Formally, a subsumption architecture composition S i (x) = Sub (S i1 (x), S i2 (x)) can be defined by</p><formula xml:id="formula_43">S i (x) = S i1 (x), if S i1 needs to execute S i2 (x), else.<label>(35)</label></formula><p>Then, we write an equivalent BT as</p><formula xml:id="formula_44">T i = Fallback (T i1 , T i2 )<label>(36)</label></formula><p>where T ij is defined by f ij (x) = S ij (x) and  Proof: By the above arrangement, and Definition 3 we have that</p><formula xml:id="formula_45">r ij (x) = R, if S ij needs to execute F, else.<label>(37)</label></formula><formula xml:id="formula_46">f i (x) = f i1 (x), if S i1 needs to execute f i2 (x), else<label>(38)</label></formula><p>which is equivalent to (35). In other words, actions will be checked in order of priority, until one that returns running is found.</p><p>A BT version of the example in Fig. <ref type="figure" target="#fig_21">23</ref> can be found in Fig. <ref type="figure" target="#fig_22">24</ref>. The fact that the two control structures are equivalent is illustrated in Table <ref type="table" target="#tab_1">II</ref>, where the executing action of all 2 3 possible return status combinations are listed. Note that no action is executed if all actions return Failure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. How BTs Generalize Sequential Behavior Compositions</head><p>In this section, we will see how the Fallback composition, and Lemma 3, can also be used to implement the sequential behavior compositions proposed in <ref type="bibr" target="#b19">[20]</ref>.</p><p>The basic idea proposed by Burridge et al. <ref type="bibr" target="#b19">[20]</ref> is to extend the region of attraction by using a family of controllers, where the asymptotically stable equilibrium of each controller was either the goal state, or inside the region of attraction of another controller, positioned earlier in the sequence.</p><p>We will now describe the construction of <ref type="bibr" target="#b19">[20]</ref> in some detail, and then see how this concept is captured in the BT framework. Given a family of controllers U = {Φ i }, we say that Φ i prepares Φ j if the goal G(Φ i ) is inside the domain D(Φ j ). Assume the overall goal is located at G(Φ 1 ). A set of execution regions C(Φ i ) for each controller was then calculated according to the following scheme:</p><formula xml:id="formula_47">1) Let a queue contain Φ 1 . Let C(Φ 1 ) = D(Φ 1 ), N = 1, D 1 = D(Φ 1 ). 2)</formula><p>Remove the first element of the queue and append all controllers that prepare it to the back of the queue. 3) Remove all elements in the queue that already has a defined C(Φ i ). 4) Let Φ j be the first element in the queue. Let C(Φ j ) = D(Φ j ) \ D N , D N +1 = D N ∪ D(Φ j ), and N ← N + 1. 5) Repeat steps 2-4 until the queue is empty. The combined controller is then executed by finding j such that x ∈ C(Φ j ) and then by invoking controller Φ j .</p><p>Looking at the design of the Fallback operator in BTs, it turns out that it does exactly the job of the Burridge algorithm above, as long as the subtrees of the Fallback are ordered in the same fashion as the queue above. We formalize this in Lemma 9.</p><p>Lemma 9: Given a set of controllers U = {Φ i } we define the corresponding regions</p><formula xml:id="formula_48">S i = G(Φ i ), R i = D(Φ i ), F i = Complement(D(Φ i ))</formula><p>, and consider the controllers as atomic BTs, T i = Φ i . Assume S 1 is the overall goal region. Iteratively create a larger BT T L as 1) Let</p><formula xml:id="formula_49">T L = T 1 . 2) Find a BT T * ∈ U such that S * ⊂ R L 3) Let T L ← Fallback (T L , T * ) 4) Let U ← U \ T * 5) Repeat steps 2, 3 and 4 until U is empty. If all T i are FTS, then so is T L . Proof:</formula><p>The statement is a direct consequence of iteratively applying Lemma 3.</p><p>Thus, we see that BTs generalize the sequential behavior compositions of <ref type="bibr" target="#b19">[20]</ref>, with the execution region computations and controller switching replaced with the Fallback composition, as long as the ordering is given by Lemma 9.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. EXAMPLES</head><p>In this section, we will give three examples of how BTs can be used in robotics. The first example illustrates how the functional representation of Section III can be used to guarantee safety in terms of avoiding empty batteries. The second example illustrates how the functional representation can be used to increase robustness, in terms of increasing the region of attraction for a robot executing a task. Then, the third example illustrates the modularity of a larger BT by combining the two smaller examples with additional subtrees that add some additional robot capabilities.</p><p>All BTs were implemented by using our publicly available ROS BT package. <ref type="foot" target="#foot_0">2</ref> To illustrate the modularity, the leaf nodes are a mix of behaviors from the NAO Software Development Kit, such as Stand Up, Sit Down, and Lie Down and behaviors we developed ourselves, such as Approach Ball, Grasp Ball, and Throw Ball, see below.</p><p>Example 4 (Safety): To illustrate Lemma 5 we choose the BT of Fig. <ref type="figure" target="#fig_23">25</ref>, which is actually a compact version of the BT of Fig. <ref type="figure" target="#fig_3">5</ref>. The idea is that the first BT in the sequence is to guarantee that the combination does not run out of battery, under First we describe the sets S i , F i , R i and the corresponding vector fields of the functional representation. Then, we apply Lemma 5 to see that the combination does indeed guarantee against running out of batteries.</p><p>Let T 1 be Guarantee Power Supply and T 2 be Do other tasks. Let furthermore x k = (x 1k , x 2k ) ∈ R 2 , where x 1k ∈ [0, 100] is the distance from the current position. to the recharging station and x 2k ∈ [0, 100] is the battery level. For this example Δt = 10 s.</p><p>For Guarantee Power Supply, T 1 , we have that</p><formula xml:id="formula_50">S 1 = {x : 100 ≤ x 2 or (0.1 ≤ x 1 , 20 &lt; x 2 )}<label>(39)</label></formula><p>R 1 = {x : x 2 ≤ 20 or (x 2 &lt; 100 and x 1 &lt; 0.1)} (40)</p><formula xml:id="formula_51">F 1 = ∅ (41) f 1 (x) = x 1 x 2 + 1 if x 1 &lt; 0.1, x 2 &lt; 100 (42) = x 1 -1 x 2 -0.1 else (<label>43</label></formula><formula xml:id="formula_52">)</formula><p>that is when running, the robot moves to x 1 &lt; 0.1 and recharges. While moving, the battery level decreases and while charging the battery level increases. If at the recharge position, it returns Success only after reaching x 2 ≥ 100. Outside of the recharge area, it returns Success as long as the battery level is above 20.</p><p>A phase portrait of f 1 (x)x is shown in Fig. <ref type="figure" target="#fig_4">26</ref> For Do Other Task, T 2 , we have that</p><formula xml:id="formula_53">S 2 = ∅ (44) R 2 = R 2<label>(45)</label></formula><formula xml:id="formula_54">F 2 = ∅ (46) f 2 (x) = x 1 + (50 -x 1 )/50 x 2 -0.1<label>(47)</label></formula><p>that is when running, the robot moves toward x 1 = 50 and does some important task, while the battery level keeps on decreasing. A phase portrait of f 2 (x)x is shown in Fig. <ref type="figure" target="#fig_24">27</ref>.</p><p>Given T 1 and T 2 , the composition T 0 = Sequence(T 1 , T 2 ) is created to improve the safety of T 2 , as described below.</p><p>Informally, we can look at the phase portrait in Fig. <ref type="figure" target="#fig_6">28</ref> to get a feeling for what is going on. The obstacle to be avoided is the Empty Battery state O = {x : x 2 = 0}, and T 0 makes sure that this state is never reached, since the Guarantee Power Supply action starts executing as soon as Do Other Task brings the battery level below 20%. The remaining battery level is also enough for the robot to move back to the recharging station, given that the robot position is limited by the reachable space, i.e., x 1k ∈ [0, 100].</p><p>Formally, we state the following Lemma. Lemma 10: Let the obstacle region be O = {x : x 2 = 0} and the initialization region be I = {x :</p><formula xml:id="formula_55">x 1 ∈ [0, 100], x 2 ≥ 15}.</formula><p>Furthermore, let T 1 be given by ( <ref type="formula" target="#formula_50">39</ref>)-( <ref type="formula" target="#formula_51">43</ref>) and T 2 be an arbitrary BT satisfying max x ||xf 2 (x)|| &lt; d = 5, then T 0 = Sequence(T 1 , T 2 ) is Safe with respect to I and O, i.e., if x(0) ∈ I, then x(t) ∈ O, for all t &gt; 0.</p><p>Proof: First we see that T 1 is Safe with respect to O and I. Then, we notice that T 1 is Safeguarding with margin d = 10 for the reachable set = {x : x 1 ∈ [0, 100], x 2 ∈ [0, 100]}. Finally, we conclude that T 0 is Safe, according to Lemma 5.</p><p>Note that if we did not constraint the robot to move in some reachable set X = {x : x 1 ∈ [0, 100], x 2 ∈ [0, 100]}, it would be able to move so far away from the recharging station that the battery would not be sufficient to bring it back again before reaching x 2 = 0.</p><p>Example 5 (Robustness and efficiency): To illustrate Lemma 3 we look at the BT of Fig. <ref type="figure" target="#fig_25">29</ref> controlling an NAO robot. The BT has three actions Walk Home, which is first tried, if that fails (the robot cannot walk if it is not standing up) it tries the action Sit to Stand, and if that fails, it tries Lie down to Sit Up. Thus, each fallback action brings the system into the running region of the action to its left, e.g., the result of Sit to Stand is to enable the execution of Walk Home.</p><p>Let x k = (x 1k , x 2k ) ∈ R 2 , where x 1k ∈ [0, 0.5] is the horizontal position of the robot head and x 2k ∈ [0, 0.55] is vertical position (height above the floor) of the robot head. The objective of the robot is to get to the destination at (0, 0.48).</p><p>First we describe the sets S i , F i , R i and the corresponding vector fields of the functional representation. Then, we apply Lemma 3 to see that the combination does indeed improve robustness. For this example Δt = 1 s.</p><p>For Walk Home, T 4 , we have that that is it runs as long as the vertical position of the robot head, x 2 , is at least 0.48 m above the floor, and moves toward the origin with a speed of 0.1 m/s. If the robot is not standing up x 2 &lt; 0.48 m it returns Failure. A phase portrait of f 4 (x)x is shown in Fig. <ref type="figure" target="#fig_26">30</ref>. Note that T 4 is FTS with the completion time bound τ 4 = 0.5/0.1 = 10 and region of attraction R 4 = R 4 .</p><formula xml:id="formula_56">S 4 = {x : x 1 ≤ 0} (48) R 4 = {x : x 1 = 0, x 2 ≥ 0.48}<label>(49)</label></formula><formula xml:id="formula_57">F 4 = {x : x 1 = 0, x 2 &lt; 0.48} (50) f 4 (x) = x 1 -0.1 x 2<label>(51)</label></formula><p>For Sit to Stand, T 5 , we have that</p><formula xml:id="formula_58">S 5 = {x : 0.48 ≤ x 2 } (52) R 5 = {x : 0.3 ≤ x 2 &lt; 0.48}<label>(53)</label></formula><formula xml:id="formula_59">F 5 = {x : x 2 &lt; 0.3} (54) f 5 (x) = x 1 x 2 + 0.05<label>(55)</label></formula><p>that is it runs as long as the vertical position of the robot head, x 2 , is in between 0. For Lie down to Sit Up, T 6 , we have that</p><formula xml:id="formula_60">S 6 = {x : 0.3 ≤ x 2 } (56) R 6 = {x : 0 ≤ x 2 &lt; 0.3}<label>(57)</label></formula><formula xml:id="formula_61">F 6 = ∅ (58) f 6 (x) = x 1 x 2 + 0.03<label>(59)</label></formula><p>that is it runs as long as the vertical position of the robot head, x 2 , is below 0.  the completion time bound τ 6 = 0.3/0.03 = 10 and region of attraction R 6 = R 6 . Informally, we can look at the phase portrait in Fig. <ref type="figure" target="#fig_29">33</ref> to get a feeling for what is going on. As can be seen the fallbacks make sure that the robot gets on its feet and walks back, independently of where it started in {x : 0 &lt; x 1 ≤ 0.5, 0 ≤ x 2 ≤ 0.55}.</p><p>Formally, we can use Lemma 3 to compute robustness in terms of the region of attraction R 3 , and efficiency in terms of bounds on completion time τ 3 . The results are described in the following Lemma.</p><p>Lemma 11: Given T 4 , T 5 , T 6 defined in (48)-(59). The combined BT T 3 = Fallback (T 4 , T 5 , T 6 ) is FTS, with region of attraction R 3 = {x : 0 &lt; x 1 ≤ 0.5, 0 ≤ x 2 ≤ 0.55}, completion time bound τ 3 = 24.</p><p>Proof: We note that T 4 , T 5 , T 6 are FTS with τ 4 = 10, τ 5 = 4, τ 6 = 10 and regions of attractions equal to the running regions R i = R i . Thus, we have that S 6 ⊂ R 5 = R 5 and S 5 ⊂ R 4 = R 4 . Applying Lemma 3 twice now gives the desired results,</p><formula xml:id="formula_62">R 3 = R 4 ∪ R 5 ∪ R 6 = {x : 0 ≤ x 1 ≤ 0.5, 0 ≤ x 2 ≤ 0.55} and τ 3 = τ 4 + τ 5 + τ 6 = 10 + 4 + 10 = 24.</formula><p>We will use a larger BT below to illustrate modularity, as well as the applicability of the proposed analysis tools to more complex problems.</p><p>Example 6 (Big BT): The BT in Fig. <ref type="figure" target="#fig_30">34</ref> was designed for controlling an NAO humanoid robot in an interactive capability demo, and includes the BTs of Figs. <ref type="bibr" target="#b24">25</ref> and 29 as subtrees, as discussed below.</p><p>The top left part of the tree includes some exception handling, in terms of battery management, and backing up and complaining in case the toe bumpers are pressed. The top right part of the tree is a parallel node, listening for new user commands, along with a request for such commands if none are given and an execution of the corresponding activities if a command has been received.</p><p>The subtree Perform Activities is composed of checking of what activity to do, and execution of the corresponding command. Since the activities are mutually exclusive, we let the Current Activity hold only the latest command and no ambiguities of control commands will occur.</p><p>The subtree Play Ball Game runs the ball tracker, in parallel with moving closer to the ball, grasping it, and throwing it.</p><p>As can be seen, the design is quite modular. An HDS implementation of the same functionality would need an extensive amount of transition arrows going in between the different actions.</p><p>We will now apply the analysis tools of the paper to the example, initially assuming that all atomic actions are FTS, as described in Definition 5.</p><p>Comparing Figs. <ref type="bibr" target="#b24">25</ref> and 34 we see that they are identical, if we let Do Other Task correspond to the whole right part of the larger BT. Thus, according to Lemma 10, the complete BT is safe, i.e., it will not run out of batteries, as long as the reachable state space is bounded by 100 distance units from the The parallel composition at the top of Play Ball Game combines Ball Tracker which always returns Running, with the subtree discussed above. The parallel node has M = 1, i.e., it only needs the Success of one child to return Success. Thus, it is clear from Definition 4 that the whole BT Play Ball Game has the same properties regarding FTS as the right subtree.</p><p>Finally, we note that Play Ball Game fails if the robot is not standing up. Therefore, we improve the robustness of that subtree in a way similar to Example 5 in Fig. <ref type="figure" target="#fig_25">29</ref>. Thus we create the composition Fallback(Play Ball Game, T 5 , T 6 ), with T 5 = Sit to Stand, T 6 = Lie Down to Sit Up.</p><p>Assuming that that high dimensional dynamics of Play Ball Game is somehow captured in the x 1 dimension we can apply an argument similar to Lemma 11 to conclude that the combined BT is indeed also FTS with completion time bound τ 1 + τ 2 + τ 3 + τ 5 + τ 6 , region of attraction R 1 ∪ R 2 ∪ R 3 ∪ R 5 ∪ R 6 and success region S 1 ∩ S 2 ∩ S 3 .</p><p>The rest of the BT concerns user interaction and is thus not suitable for doing performance analysis.</p><p>Note that the assumption on all atomic actions being FTS is fairly strong. For example, the NAO grasping capabilities are somewhat unreliable. But we believe that a deterministic analysis such as this one is still useful for making good design choices. An analysis by using a stochastic approach, modeling the probabilities of success and failure, is also conceivable, but outside the scope of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. CONCLUSION</head><p>In this paper, we have provided a theoretical description of how properties such as efficiency, robustness, and safety are preserved in modular compositions of BTs, enabled by a new functional formulation of BTs.</p><p>It was shown that under certain circumstances, the composition of a particular class of BTs with a very general class can still be guaranteed to be safe. A result that is potentially useful in areas where there is a need to both guarantee key properties of a piece of software, and continuously adding functionality to that same software. Regarding robustness, it was shown how the region of attraction of a controller can be extended by the compositions of controllers.</p><p>The proposed analysis tools were illustrated by using two smaller and one more complex example, where safety and robustness of different action combinations were analyzed.</p><p>We have also shown how BTs generalize the important, but quite different concepts of decision trees, the subsumption architecture, and sequential behavioral compositions. As decision trees are an important tool in machine learning, this opens up the possibilities of learning BTs, while the results for the subsumption architecture and sequential behavior compositions are more useful for designing and analyzing robust robot controllers.</p><p>All examples were implemented by using our publicly available ROS BT implementation, <ref type="foot" target="#foot_1">3</ref> and a combination of atomic actions created by others and ourselves.</p><p>To conclude, we believe that the strength of BTs lie in their modularity, and that BTs can complement FSM in robotic software development, much like one programming language can complement another.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Minimalist BT composition (a) and the corresponding vector field (b). The second subtree increases the robustness of the composition by increasing the combined region of attraction.</figDesc><graphic coords="2,45.59,118.25,83.05,67.22" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Sequence is used to create an Enter Through Front Door BT. Passing the door is only tried if the opening action succeeds. Sequences are denoted by a white box with an arrow.</figDesc><graphic coords="3,84.35,372.65,157.80,117.02" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Two actions Ball Tracker (sensing) and Approach Ball (actuator control) are ticked and executed in parallel. Parallel nodes are denoted by a white box with two arrows.</figDesc><graphic coords="3,365.39,188.21,121.86,98.66" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 5 .</head><label>5</label><figDesc>Fig.5. Condition is used to decide when to recharge the batteries. In each tick of the tree, the battery levels are checked, and the Do Other Task Action is stopped whenever the battery level is getting too low.</figDesc><graphic coords="4,76.55,68.21,181.58,133.10" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Two BTs in Figs. 2 and 3 are combined to larger BT. If, e.g., the robot opens the front door, but does not manage to pass through it, it will try the back door.</figDesc><graphic coords="4,70.55,256.73,193.58,123.14" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Combining the BTs above and some additional Actions, we get a flexible BT for entering a building and performing some task.</figDesc><graphic coords="4,307.55,68.81,246.38,239.54" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. FSM behaving like a BT, made up of a single normal state, three out transitions Success (S), Running (R), Failure (F), and a Tick source.</figDesc><graphic coords="5,362.63,68.93,125.70,137.42" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. FSM corresponding to the Fallback BT in Fig. 2. Note how the second state is executed only if the first fails.</figDesc><graphic coords="6,49.55,68.33,237.74,85.94" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. FSM corresponding to the Sequence BT in Fig. 3. Note how the second state is executed only if the first succeeds.</figDesc><graphic coords="6,312.59,68.33,237.74,85.94" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. FSM corresponding to the BT in Fig. 6.</figDesc><graphic coords="7,65.15,68.81,460.46,101.54" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 12 .</head><label>12</label><figDesc>Fig. 12. Sets R 1 , S 1 , R 2 , S 2 of Example 1 and Lemma 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 13 .</head><label>13</label><figDesc>Fig. 13. Sets S 1 , F 1 , R 1 (solid boundaries) and S 2 , F 2 , R 2 (dashed boundaries) of Example 2 and Lemma 3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 14 .</head><label>14</label><figDesc>Fig. 14. Implicit sequence created using a Fallback, as described in Example 2 and Lemma 3.</figDesc><graphic coords="8,344.15,68.21,172.73,122.66" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 15 .</head><label>15</label><figDesc>Fig. 15. Sets S 0 , F 0 , R 0 and the vector field (f 0 (x)x) of Example 2 and Lemma 3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig. 16 .</head><label>16</label><figDesc>Fig. 16. Safety of the UAV control BT is guaranteed by the first Action.</figDesc><graphic coords="9,90.35,68.93,146.30,118.34" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Fig. 17</head><label>17</label><figDesc>Fig. 17. Sets S 1 , F 1 , R 1 (solid boundaries) and S 2 , F 2 , R 2 (dashed boundaries) of Example 3 and Lemma 5.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head></head><label></label><figDesc>Fig. 17. Sets S 1 , F 1 , R 1 (solid boundaries) and S 2 , F 2 , R 2 (dashed boundaries) of Example 3 and Lemma 5.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Fig. 18 .</head><label>18</label><figDesc>Fig.<ref type="bibr" target="#b17">18</ref>. Sets S 0 , F 0 , R 0 and the vector field (f 0 (x)x) of Example 3 and Lemma 5.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Fig. 19 .</head><label>19</label><figDesc>Fig. 19. Decision tree of a robot control system. The decisions are interior nodes, and the actions are leaves.</figDesc><graphic coords="10,76.55,68.45,181.58,153.86" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>Fig. 20 .</head><label>20</label><figDesc>Fig. 20. Basic building blocks of decision trees are "If ...then ...else ..." statements (left), and those can be created in BTs as illustrated above (right).</figDesc><graphic coords="10,307.07,68.57,246.38,110.78" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>Fig. 22 .</head><label>22</label><figDesc>Fig. 22. More compact formulation of the BT in Fig. 21.</figDesc><graphic coords="11,329.39,68.33,193.58,214.94" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head>Fig. 23 .</head><label>23</label><figDesc>Fig. 23. Subsumption architecture. A higher level behavior can subsume (or suppress) a lower level one.</figDesc><graphic coords="11,317.39,321.77,217.58,113.78" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head>Fig. 24 .</head><label>24</label><figDesc>Fig. 24. BT version of the subsumption example in Fig. 23.</figDesc><graphic coords="12,70.55,69.05,193.58,100.22" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head>Fig. 25 .</head><label>25</label><figDesc>Fig. 25. BT where the first action guarantees that the combination does not run out of battery.</figDesc><graphic coords="13,102.35,68.69,121.86,98.66" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head>Fig. 27 .</head><label>27</label><figDesc>Fig. 27. Do Other Task Action.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_25"><head>Fig. 29 .</head><label>29</label><figDesc>Fig. 29. Combination T 3 = Fallback(T 4 , T 5 , T 6 ) increases robustness by increasing the region of attraction.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_26"><head>Fig. 30 .</head><label>30</label><figDesc>Fig. 30. Action Walk Home, keeps the head around x 2 = 0.5 and moves it toward the destination x 1 = 0.</figDesc><graphic coords="14,107.03,68.81,121.38,64.58" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_27"><head></head><label></label><figDesc>3 and 0.48 m above the floor. If 0.48 ≤ x 2 the robot is standing up, and it returns Success. If x 2 ≤ 0.3 the robot is lying down, and it returns Failure. A phase portrait of f 5 (x)x is shown in Fig. 31. Note that T 5 is FTS with the completion time bound τ 5 = ceil (0.18/0.05) = ceil (3.6) = 4 and region of attraction R 5 = R 5 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_28"><head>Fig. 31 .</head><label>31</label><figDesc>Fig. 31. Action Sit to Stand moves the head upwards in the vertical direction toward standing.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_29"><head>Fig. 33 .</head><label>33</label><figDesc>Fig. 33. Combination Fallback(T 4 , T 5 , T 6 ) first gets up, and then walks home.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_30"><head>Fig. 34 .</head><label>34</label><figDesc>Fig.34. BT that combines some capabilities of the NAO robot in an interactive and modular way. Note how atomic actions can easily be replaced by more complex sub-BTs.</figDesc><graphic coords="16,56.15,68.93,486.26,471.38" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>TABLE I FIVE</head><label>I</label><figDesc>NODE TYPES OF A BT</figDesc><table><row><cell>Node type</cell><cell>Succeeds</cell><cell>Fails</cell><cell>Running</cell></row><row><cell>Fallback</cell><cell>If one child succeeds</cell><cell>If all children fail</cell><cell>If one child returns running</cell></row><row><cell>Sequence</cell><cell>If all children succeed</cell><cell>If one child fails</cell><cell>If one child returns running</cell></row><row><cell>Parallel</cell><cell>If ≥ M children succeed</cell><cell>If &gt; N -M children fail</cell><cell>else</cell></row><row><cell>Action</cell><cell>Upon completion</cell><cell>When impossible to complete</cell><cell>During completion</cell></row><row><cell>Condition</cell><cell>If true</cell><cell>If false</cell><cell>Never</cell></row></table><note><p>Fig. 2. Fallback is used to create an Enter Building BT. The back door option is only tried if the front door option fails. Fallbacks are denoted by a white box with a question mark and actions are denoted by a green box.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE II POSSIBLE</head><label>II</label><figDesc>OUTCOMES OF SUBSUMPTION-BT EXAMPLE</figDesc><table><row><cell>Stop if over heated</cell><cell>Recharge if Needed</cell><cell>Do Other Tasks</cell><cell>Executed Action</cell></row><row><cell>Running</cell><cell>Running</cell><cell>Running</cell><cell>Stop ...</cell></row><row><cell>Running</cell><cell>Running</cell><cell>Failure</cell><cell>Stop ...</cell></row><row><cell>Running</cell><cell>Failure</cell><cell>Running</cell><cell>Stop ...</cell></row><row><cell></cell><cell>Failure</cell><cell>Failure</cell><cell>Stop ...</cell></row><row><cell>Failure</cell><cell>Running</cell><cell>Running</cell><cell>Recharge ...</cell></row><row><cell>Failure</cell><cell>Running</cell><cell>Failure</cell><cell>Recharge ...</cell></row><row><cell>Failure</cell><cell>Failure</cell><cell>Running</cell><cell>Do other ...</cell></row><row><cell>Failure</cell><cell>Failure</cell><cell>Failure</cell><cell>-</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>Library available at http://wiki.ros.org/behavior_tree.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>Library available at http://wiki.ros.org/behavior_tree.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>The authors would like to thank Prof. M. Egerstedt for his valuable input into this paper.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper was recommended for publication by Associate Editor H. Kress-Gazit and Editor C. Torras upon evaluation of the reviewers' comments. This work was supported by the SARAFun project, partially funded by the EU within H2020 (H2020-ICT-2014/H2020-ICT-2014-1) under Grant 644938.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Handling complexity in the Halo 2 AI</title>
		<author>
			<persName><forename type="first">D</forename><surname>Isla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Game Developers Conf</title>
		<meeting>Game Developers Conf</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Understanding behavior trees</title>
		<author>
			<persName><forename type="first">A</forename><surname>Champandard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Available: AiGameDev.com</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Halo 3-building a better battle</title>
		<author>
			<persName><forename type="first">D</forename><surname>Isla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Game Developers Conf</title>
		<meeting>Game Developers Conf</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Artificial Intelligence for Games</title>
		<author>
			<persName><forename type="first">I</forename><surname>Millington</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Funge</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>CRC Press</publisher>
			<pubPlace>Boca Raton, FL, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The behavior tree starter kit</title>
		<author>
			<persName><forename type="first">S</forename><surname>Rabin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Game AI Pro</title>
		<meeting><address><addrLine>Boca Raton, FL, USA</addrLine></address></meeting>
		<imprint>
			<publisher>CRC Press</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="73" to="91" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Petri nets: Properties, analysis and applications</title>
		<author>
			<persName><forename type="first">T</forename><surname>Murata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE</title>
		<meeting>IEEE</meeting>
		<imprint>
			<date type="published" when="1989-04">Apr. 1989</date>
			<biblScope unit="volume">77</biblScope>
			<biblScope unit="page" from="541" to="580" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Evolving behaviour trees for the commercial game DEFCON</title>
		<author>
			<persName><forename type="first">C</forename><surname>Lim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Baumgarten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Colton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Applications of Evolutionary Computation</title>
		<meeting><address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="100" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Evolutionary behavior tree approaches for navigating platform games</title>
		<author>
			<persName><forename type="first">M</forename><surname>Nicolau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Perez-Liebana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>O'neill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Brabazon</surname></persName>
		</author>
		<ptr target="http://ieeexplore.ieee.org/document/7435292/" />
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput. Intell. AI Games</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Parameterizing behavior trees</title>
		<author>
			<persName><forename type="first">A</forename><surname>Shoulson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">M</forename><surname>Garcia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mead</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">I</forename><surname>Badler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Motion in Games</title>
		<meeting><address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="144" to="155" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Extending the JADE agent behaviour model with JBehaviourtrees framework</title>
		<author>
			<persName><forename type="first">I</forename><surname>Bojic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lipic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kusek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Jezic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Agent and Multi-Agent Systems: Technologies and Applications</title>
		<meeting><address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="159" to="168" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Increasing modularity of UAV control systems using computer game behavior trees</title>
		<author>
			<persName><forename type="first">P</forename><surname>Ögren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. AIAA Guid</title>
		<meeting>AIAA Guid<address><addrLine>Minneapolis, MN, USA</addrLine></address></meeting>
		<imprint>
			<biblScope unit="page" from="2012" to="4458" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">An integrated system for autonomous robotics manipulation</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A D</forename><surname>Bagnell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE/RSJ Int. Conf. Intell. Robots Syst</title>
		<meeting>IEEE/RSJ Int. Conf. Intell. Robots Syst</meeting>
		<imprint>
			<date type="published" when="2012-10">Oct. 2012</date>
			<biblScope unit="page" from="2955" to="2962" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Interfacing behavior trees with the world using description logic</title>
		<author>
			<persName><forename type="first">A</forename><surname>Klökner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. AIAA Conf. Guid. Navig. Control</title>
		<meeting>AIAA Conf. Guid. Navig. Control<address><addrLine>Boston, MA, USA</addrLine></address></meeting>
		<imprint>
			<biblScope unit="page" from="2013" to="4636" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Performance analysis of stochastic behavior trees</title>
		<author>
			<persName><forename type="first">M</forename><surname>Colledanchise</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Marzinotto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ögren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc</title>
		<meeting>null</meeting>
		<imprint>
			<date type="published" when="2014-06">Jun. 2014</date>
			<biblScope unit="page" from="3265" to="3272" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Bart-behavior architecture for robotic tasks</title>
		<author>
			<persName><forename type="first">T</forename><surname>Galluzzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kazemi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-S</forename><surname>Valois</surname></persName>
		</author>
		<ptr target="https://code.google.com/archive/p/bart" />
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Semi-autonomous simulated brain tumor ablation with Raven II surgical robot using behavior tree</title>
		<author>
			<persName><forename type="first">D</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Gong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hannaford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">J</forename><surname>Seibel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Conf. Robot. Autom</title>
		<meeting>IEEE Int. Conf. Robot. Autom</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="3868" to="3875" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A framework for end-user instruction of a robot assistant for manufacturing</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R</forename><surname>Guerin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Paxton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Hager</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Conf. Robot. Autom</title>
		<meeting>IEEE Int. Conf. Robot. Autom</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="6167" to="6174" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The modelica behaviortrees library: Mission planning in continuous-time for unmanned aircraft</title>
		<author>
			<persName><forename type="first">A</forename><surname>Klöckner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Van Der Linden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zimmer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 10th Int. Modelica Conf</title>
		<meeting>10th Int. Modelica Conf</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="727" to="736" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A robust layered control system for a mobile robot</title>
		<author>
			<persName><forename type="first">R</forename><surname>Brooks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE J. Robot. Autom</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="14" to="23" />
			<date type="published" when="1986-03">Mar. 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Sequential composition of dynamically dexterous robot behaviors</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Burridge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Rizzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Koditschek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Robot. Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="534" to="555" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Learning to fly</title>
		<author>
			<persName><forename type="first">C</forename><surname>Sammut</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hurst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kedzier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Michie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Imitation in Animals and Artifacts</title>
		<meeting><address><addrLine>Cambridge, MA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="171" to="190" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Sequential composition of robust controller specifications</title>
		<author>
			<persName><forename type="first">J</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Le</forename><surname>Ny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Pappas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Int. Conf. Robot. Autom</title>
		<imprint>
			<biblScope unit="page" from="5190" to="5195" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">How behavior trees modularize robustness and safety in hybrid systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Colledanchise</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ögren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE/RSJ Int. Conf. Intell. Robots Syst</title>
		<meeting>IEEE/RSJ Int. Conf. Intell. Robots Syst</meeting>
		<imprint>
			<date type="published" when="2014-06">Jun. 2014</date>
			<biblScope unit="page" from="1482" to="1488" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Letters to the editor: Go to statement considered harmful</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Dijkstra</surname></persName>
		</author>
		<idno type="DOI">10.1145/362929.362947</idno>
		<ptr target="http://doi.acm.org/10.1145/362929.362947" />
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="147" to="148" />
			<date type="published" when="1968-03">Mar. 1968</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Filippov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Arscott</surname></persName>
		</author>
		<ptr target="http://books.google.se/books?id=KBDyZSwpQpQC" />
		<title level="m">Differential Equations With Discontinuous Righthand Sides: Control Systems (Mathematics and its Applications Series)</title>
		<meeting><address><addrLine>Norwell, MA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Kluwer</publisher>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
