<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Towards a Scalable Resource-driven Approach for Detecting Repackaged Android Applications</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Yuru</forename><surname>Shao</surname></persName>
							<email>shaoyuru@gmail.com</email>
							<affiliation key="aff1">
								<orgName type="institution">The Hong Kong Polytechnic University Shenzhen Research Institute</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Xiapu</forename><surname>Luo</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">The Hong Kong Polytechnic University Shenzhen Research Institute</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Chenxiong</forename><surname>Qian</surname></persName>
							<email>cscqian@comp.polyu.edu.hk</email>
							<affiliation key="aff1">
								<orgName type="institution">The Hong Kong Polytechnic University Shenzhen Research Institute</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Pengfei</forename><surname>Zhu</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">The Hong Kong Polytechnic University Shenzhen Research Institute</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Lei</forename><surname>Zhang</surname></persName>
							<email>cslzhang@comp.polyu.edu.hk</email>
							<affiliation key="aff1">
								<orgName type="institution">The Hong Kong Polytechnic University Shenzhen Research Institute</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Computing</orgName>
								<orgName type="institution">The Hong Kong Polytechnic University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Towards a Scalable Resource-driven Approach for Detecting Repackaged Android Applications</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">78C997D38551AB8270017F5B6F007B21</idno>
					<idno type="DOI">10.1145/2664243.2664275</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:49+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Repackaged Android applications (or simply apps) are one of the major sources of mobile malware and also an important cause of severe revenue loss to app developers. Although a number of solutions have been proposed to detect repackaged apps, the majority of them heavily rely on code analysis, thus suffering from two limitations: (1) poor scalability due to the billion opcode problem; (2) unreliability to code obfuscation/app hardening techniques. In this paper, we explore an alternative approach that exploits core resources, which have close relationships with codes, to detect repackaged apps. More precisely, we define new features for characterizing apps, investigate two kinds of algorithms for searching similar apps, and propose a two-stage methodology to speed up the detection. We realize our approach in a system named ResDroid and conduct large scale evaluation on it. The results show that ResDroid can identify repackaged apps efficiently and effectively even if they are protected by obfuscation or hardening systems.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Repackaged apps have been one of the major sources of mobile malware on Android for many years <ref type="bibr">[16,</ref><ref type="bibr">18]</ref>. A recent study showed that 86% malware samples were repackaged version of legitimate apps <ref type="bibr" target="#b44">[48]</ref>. BitDefender even found that 1.2% of apps on Google Play have been repackaged to deliver ads and collect information <ref type="bibr">[2]</ref>. Apps repackaging has also become a major threat to app economy <ref type="bibr" target="#b7">[9]</ref>. By modifying the embedded ad's client ID or replacing it with new ad libraries, an attacker can make profits through apps developed by others <ref type="bibr" target="#b20">[24]</ref>. As another example, repackaging paid apps and uploading the modified versions to third-party markets will result in revenue losses to developers. Moreover, repackaged financial apps not only cause financial loss to customers <ref type="bibr" target="#b27">[31]</ref>, but also compromise companies' reputation and users' experiences <ref type="bibr" target="#b7">[9]</ref>.</p><p>Although a number of systems have been proposed to identify repackaged apps, how to effectively and efficiently detect them remains a challenging problem. One possible reason is that the majority of existing systems heavily rely on codes' features to quantify the similarity between apps, such as diverse hash values <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b23">27,</ref><ref type="bibr" target="#b43">47]</ref>, abstract syntax trees (AST) <ref type="bibr" target="#b33">[37]</ref>, control flow graph (CFG) and its variants <ref type="bibr" target="#b11">[13,</ref><ref type="bibr" target="#b18">22,</ref><ref type="bibr" target="#b39">43]</ref>, program dependency graph (PDG) <ref type="bibr" target="#b15">[19,</ref><ref type="bibr" target="#b16">20]</ref>, etc., thus suffering from two limitations: Poor scalability due to the billion opcode problem. <ref type="bibr">Hanna et al.</ref> estimated that the total amount of opcodes in all apps is around 1.45 billion <ref type="bibr" target="#b23">[27]</ref> not to mention the rapid increase in the number of new apps. Therefore, processing millions of apps in many Android markets demands scalable and efficient solutions. Unreliability to code obfuscation/app hardening techniques. Since most of existing solutions borrowed methods from the area of code clone detection that has been studied for 20 years <ref type="bibr" target="#b9">[11,</ref><ref type="bibr" target="#b35">39,</ref><ref type="bibr" target="#b37">41]</ref>, evasion solutions are available to dedicated attackers, let alone new obfuscation and hardening techniques <ref type="bibr" target="#b14">[17,</ref><ref type="bibr" target="#b25">29,</ref><ref type="bibr" target="#b39">43,</ref><ref type="bibr" target="#b40">44]</ref>.</p><p>We explore an alternative scheme, a novel resource-driven approach, to detect repackaged apps. Our approach is motivated by two observations. First, Android apps usually contain various resources, such as layout and style resources for graphical user interface (GUI). Although these resources are separated from the executable .dex file, there are close relationships between resources and codes. Second, attackers seldom modify original resources in order to let the repackaged apps work properly and have the same lookand-feel. Moreover, existing obfuscation/hardening systems rarely handle resources. Although not all resources are critical to an app, some core resources cannot be easily modified by attackers without affecting the app's functionality or quality-of-experience (QoE). Therefore, we exploit core resources and the related codes to quantify apps' similarity.</p><p>To scale up this approach, we propose a two-stage methodology for grouping similar apps. More precisely, statistical features are used in the first stage to quickly divide apps into groups and then at the second stage structural features are employed to further cluster apps in each group. Note that the second stage can be performed in parallel. Since the methodology is general, we investigate the performance of two kinds of algorithms to search for similar apps: nearest neighbor search (NNS) <ref type="bibr" target="#b6">[8]</ref> and clustering <ref type="bibr" target="#b5">[7]</ref>. The former may quickly locate apps that are very similar to a target app but may miss other similar apps. The latter can partition apps into different clusters from a global view but has higher computational complexity.</p><p>We have realized our approach in a system named Res-Droid and conducted extensive evaluation on it. The experimental results not only validate its effectiveness and efficiency but also reveal interesting observations. In summary, this paper makes the following contributions:</p><p>1. We propose a novel resource-driven approach to detect repackaged apps. To our best knowledge, it is the first systematic examination on leveraging resources for repackaged apps detection.</p><p>2. We propose a two-stage methodology to scale up the approach and investigate the performance of two kinds of algorithms for searching similar apps: nearest neighbor searching and clustering.</p><p>3. We realize our approach in a system named ResDroid with 2770 lines of Python code, 1157 lines of Java code, and 309 lines of C code. Although a simultaneous research, ViewDroid <ref type="bibr" target="#b41">[45]</ref>, also adopts GUI-related features, there are significant differences between it and ResDroid in terms of feature selection, comparison algorithms, and scalability, as detailed in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.</head><p>We conduct the first study on the effect of commercial app hardening systems on detecting repackaged apps. We also develop DexDumper for dynamically dumping hardened apps from memory for detection.</p><p>5. We conduct extensive evaluation on ResDroid with 169,352 apps crawled from 10 markets and 200 real repackaged apps. The results show that ResDroid can detect repackaged apps effectively and efficiently.</p><p>The rest of this paper is organized as follows. Section 2 introduces the problem and background knowledge. Section 3 and Section 4 detail our methodology and the implementation of ResDroid, respectively. The experimental results are reported in Section 5. Section 6 discusses ResDroid's limitations and future work. After introducing the related work in Section 7, we conclude the paper in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">BACKGROUND</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Problem Statement</head><p>The majority of existing approaches heavily depend on code-level features, thus suffering from two limitations: (1) poor scalability to process billions of opcodes; (2) unreliability to code obfuscation/app hardening techniques. The goal of this paper is to explore an alternative scheme, a resource-driven approach, to detect repackaged apps. Motivated by the observation that existing attacks and code obfuscation/app hardening techniques seldom handle resources, we investigate how to employ resources to detect repackaged apps from four aspects, including, feature selection, feature extraction, scalable approaches for searching similar apps, and limitations. Note that the new approach complements the existing code-level systems instead of replacing them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Application Resources</head><p>Android developers are recommended to externalize resources from the codes so that they can be maintained independently <ref type="bibr">[6]</ref>. Figure <ref type="figure" target="#fig_0">1</ref> shows an example of app codes and resources. MainActivity.java defines an activity that provides users a GUI for interaction. When an activity is launched, the Android runtime creates an activity object and invokes the onCreate method defined at lines 3-7.</p><p>An activity may contain other GUI components, which can be added to its View dynamically or defined by a layout file (in XML format). Lines 27-31 define the layout used by MainActivity. Line 5 indicates that MainActivity loads its view from main act layout.xml.</p><p>Fragment is a special component that represents a behavior or a portion of user interface within an activity. It can be considered as a modular section of an activity, which has its own layout. main act layout.xml defines a fragment associated with the class com.example.TextFramgment, whose content is shown in lines 10-19. When MainActivity is started, its layout file main act layout.xml will be loaded and the activity will present users the fragment, whose layout is defined in text fragment.xml and loaded in line 14 via the inflate method. In this example, the final GUI presented to users is actually the view of the fragment defined in text fragment.xml. When interacting with an app, users can navigate between (i.e., transition between) different activities <ref type="bibr" target="#b8">[10]</ref>. We define the transition among activities as activity transition graph (ATG), where each vertex represents an activity and an edge indicates the existence of transitions through Android methods startActivity() or startActivityForResult().</p><p>App resources are referenced through IDs. For example, after main act layout.xml is parsed, an ID will be signed to it. The auto-generated file R.java records all resources and their IDs. App codes access the resources through their IDs. For example, MainActivity sets its view defined in main act layout.xml by referencing R.layout.main_act_lay out. Moreover, developers can use the scheme @type/name to reference other resources. For instance, line 38 references a string resource named "tv text" using @string/tv_text.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Event Handlers</head><p>There are two kinds of event handlers in Android apps. GUI event handlers. GUI objects can be associated with event handlers. For example, given a button, the execution will reach its onClick function, defined in the interface android.view.View.OnClickListener, after a user clicks it. Lifecycle event handers. An activity instance may transition among different states in its lifecycle <ref type="bibr" target="#b4">[5]</ref>. Developers can define how an activity behaves when it transitions from one state to another in callback methods. For example, when an activity is started, its onCreate and onStart callback methods will be invoked successively.</p><p>For apps without GUI/activities, we consider callbacks in their Services and Broadcast Receivers as event handlers. The feature extraction module first identifies an app's major packages according to their importance measured by the PageRank algorithm <ref type="bibr" target="#b30">[34]</ref> (Section 3.3). Then, core resources along with their statistical features and structural features will be determined according to major packages and the app's manifest file. The statistical features (Section 3.4) are lightweight in terms of computation and comparison but may not provide precise information about an app. In contrast, structural features (Section 3.5) can better characterize an app at the cost of the complexity of computation and comparison.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">METHODOLOGY</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Overview</head><p>To scale up the detection for millions of apps, we propose a two-stage methodology that employs the divide-and-conquer strategy to identify similar apps within small groups of apps. More precisely, ResDroid first uses statistical features to divide apps into small classes in the coarse-grained processing module and then employs structural features to identify similar apps within each group in the fine-grained processing module. The output is a set of potential repackaging groups (PR-Groups) containing suspicious repackaged apps. Our approach is rational because repackaged apps are usually similar to original apps and the process of clustering apps in different groups can be parallelled.</p><p>Finally, ResDroid verifies whether those similar apps are repackaged apps according to their signatures. Since the percentage of suspicious apps is usually small, they could be further inspected by in-depth code analysis systems <ref type="bibr" target="#b15">[19]</ref>, dynamic analysis systems <ref type="bibr" target="#b19">[23,</ref><ref type="bibr" target="#b34">38]</ref>, malware detection systems <ref type="bibr" target="#b21">[25]</ref>, or even manual verification if necessary.</p><p>Based on the selected features, our solution can adopt different algorithms to find similar apps. Here, we examine the performance of two kinds of popular algorithms: clustering algorithms and nearest neighbor search (NNS) algorithms in Section 3.6 and Section 3.7, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Hardening Detection</head><p>To secure Android apps, hardening techniques and services have emerged <ref type="bibr" target="#b2">[3]</ref> (e.g., Bangcle<ref type="foot" target="#foot_0">1</ref> , iJiaMi<ref type="foot" target="#foot_1">2</ref> ). Typically, they encrypt an app's classes.dex and load it into memory through java native interfaces (JNI). Hardening not only raises the bar for attackers to repackage apps, but also thwarts ResDroid to extract apps' features. To tackle this problem, we design and implement DexDumper (Section 4.1) to dynamically restore the classes.dex.</p><p>Before extracting features, ResDroid will check whether the app is hardened or not by looking for patterns of hardening services. For example, since Bangcle inserts a shared library libsecexe.so into hardened apps, an app containing such file is considered as a hardened app. Moreover, Res-Droid will invoke DexDumper to dump the original classes.dex from a hardened app for feature extraction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Major Packages and Core Resources</head><p>Not all resources are critical to an app and/or have close relationship with major codes. To raise the bar for an attacker to evade the detection by modifying features, we define core resources, which are used by major packages, with the following requirements: (1) it should be difficult for an attacker to manipulate these resources. In particular, random manipulations by an attacker will impair an app's functionality and/or QoE, or such manipulations can be easily filtered out; (2) they are representative.</p><p>Major packages refer to important codes in an app excluding imported libraries. We created a blacklist to filter out frequently-used ad and third-party libraries. Motivated by the module decoupling technique in <ref type="bibr" target="#b42">[46]</ref>, ResDroid first constructs a package dependency graph, an undirected and weighted graph, where each vertex represents a package, and an edge between two vertexes indicates the existence of method invocations between them. The weight of an edge is increased by one if it spots a method invocation between the two packages. Then, ResDroid ranks the packages using the PageRank algorithm <ref type="bibr" target="#b30">[34]</ref> and selects the top 5 packages as major packages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Statistical Features</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.1">Definition</head><p>We define 15 statistical features, which can be easily retrieved, and use them in the coarse-gained processing module. Let A = {a (i) }i=1...N be a set of apps. The statistical features of each sample a (i) is represented as a vector</p><formula xml:id="formula_0">!" ! !"" ! !"" " ! #" !# !# !# ##"# #$!" #!$#$! #$!" #$! %#!# #&amp; ! " %#!# ##"# #$!" %#!# #!$#$! #$!" ! "$!" !# ## !$ " !"" ! " Figure 2:</formula><p>The procedure of our resource-driven approach.</p><formula xml:id="formula_1">v (i) = (f (i) 1 , ..., f (i)<label>15</label></formula><p>). The first five dimensions (f </p><formula xml:id="formula_2">(i) 1 , ..., f (i) (i) 6 , ..., f (i) # Type</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.2">Comparison</head><p>Since the features' ranges are quite different, we normalize v (i) and get a new vector v</p><formula xml:id="formula_3">(i) n = (F (i) 1 , ..., F (i) 15 )</formula><p>, where each dimension ranges in [0, 1]. We calculate F (i) j using the following function:</p><formula xml:id="formula_4">F (i) j = norm(f (i) j ) = f (i) j -min(f (1...N ) j ) max(f (1...N ) j ) -min(f (1...N ) j )<label>(1)</label></formula><p>Note that min(f</p><formula xml:id="formula_5">(1...N ) j</formula><p>) and max(f</p><formula xml:id="formula_6">(1...N ) j</formula><p>) are the minimal and maximal values of the jth feature for all apps in A. The similarity between two apps a (k) and a (h) according to the statistical features is defined as:</p><formula xml:id="formula_7">s (k,h) = e -Dc(v (k) n ,v (h) n ) ,<label>(2)</label></formula><p>where Dc(v</p><formula xml:id="formula_8">(k) n , v (h)</formula><p>n ) is the Euclidean distance of the two normalized feature vectors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Structural Features</head><p>The structural features cover two types of information: (1) activity layout; (2) event handler. These features are reliable and representative because: (1) repackaged apps usually have the same GUI as the original apps to avoid affecting their functionality and QoE; (2) although an dedicated attacker can re-implement an existing layout, it takes time to achieve the completely same appearance and it is difficult to apply this process to all apps automatically; (3) since GUI objects and the associated event handlers determine the functionality of an app, attackers usually keep existing event handlers to avoid impairing the original app's functionality. Therefore, ResDroid compares two apps' event handlers instead of all codes.</p><p>As an app may have multiple activity layouts and different kinds of event handlers, features extracted from a single layout or event handlers should be well organized to form the final structural features. To achieve this goal, for each app a (i) ∈ A, we first perform static analysis to construct its ATG and then traverse the ATG using depth-first search algorithm starting from the main activity of a (i) . If an app has no main activity, we choose the first activity defined in its AndroidManifest.xml. We remove the activities that do not belong to core resources from the generated activity sequence AS(a (i) ). The following layout features (Section 3.5.1) and event handler features (Section 3.5.2) are arranged with the order defined in AS(a (i) ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.1">Activity Layout Feature</head><p>For an activity act, we denote its layout as L(act). We traverse L(act) using the pre-order traversing algorithm and obtain an element sequence e1, ..., em , where ei (i = 1, ..., m) stands for a GUI object, such as Button, EditText. We define a function α for mapping ei to an English letter ('a' to 'z', 'A' to 'Z') according to its type. For example, Button is labelled as 'b', EditText as 'e', and View as 'v', etc. Since customized components are usually derived from existing components and their names may be obfuscated, we use their ancestors' type to label them. For instance, a Pho-toView extending View is also labeled as 'v'.</p><p>Following this rule, L(act) is converted into a sequence LS(act) = α(e1), ..., α(em) . For an app a (i) ∈ A and AS(a (i) ) = act1, ..., actn , its layout feature will be:</p><formula xml:id="formula_9">LF (a (i) ) = LS(act1), ..</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>., LS(actn)</head><p>(3)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.2">Event Handler Feature</head><p>Event handler feature refers to the corresponding callback methods. We perform static analysis on each event handler and extract their method signatures <ref type="bibr">[21]</ref>. Let σ(m) denote the signature of an event handler m. Since an activity act may have several event handlers, we represent its event handler feature as a sequence that consists of method signatures in lexicographical order : EH(act) = σ(m1), ..., σ(m k ) . Given an app a (i) ∈ A and AS(a (i) ) = act1, ..., actn , its event handler feature EF (a (i) ) is:</p><formula xml:id="formula_10">EF (a (i) ) = EH(act1), ..</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>., EH(actn)</head><p>(4)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.3">Comparison</head><p>When quantifying the similarity between two apps a (k) and a (h) using the structure features, we define the distance between a (k) and a (h) as:</p><formula xml:id="formula_11">D f (a (k) , a (h) ) = w l * ds LF (a (k) ), LF (a (h) )</formula><p>+ w e * ds EF (a (k) ), EF (a (h) ) , <ref type="bibr" target="#b4">(5)</ref> where w l and we are pre-defined weights (the actual values assigned to w l and we are discussed in Section 5). ds(s1, s2) measures the distance between two sequence s1 and s2, which is defined as:</p><formula xml:id="formula_12">ds(s1, s2) = 1 - length(LCS(s1, s2)) min(length(s1), length(s2)) , (<label>6</label></formula><formula xml:id="formula_13">)</formula><p>where LCS(s1, s2) is the longest common sequence of s1 and s2, and length(s) is the length of sequence s. The advantage of LCS is that even if noise is inserted into one sequence the final output of ds may remain unchanged. Therefore, even though an attacker may insert junk resources to change an app's structural features, ResDroid will not be affected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Clustering-based Processing</head><p>We adopt the spectral clustering <ref type="bibr" target="#b5">[7]</ref> algorithm to cluster apps according to the normalized statistical features. Spectral clustering techniques leverage the spectrum (eigenvalues) of the similarity matrix of the input data to perform dimensionality reduction before performing the clustering. It allows us to add more features for further improving the performance in future work.</p><p>We apply the complete-linkage hierarchical clustering algorithm and the DB cluster validity index <ref type="bibr" target="#b22">[26]</ref> to split each coarse-grained cluster into fine-grained clusters (i.e., PR-Groups). In hierarchical clustering, the linkage criterion determines the distance between sets of observations. We chose the complete-linkage criterion because it usually results in compact clusters with small diameters. Although it may be sensitive to outliers, we can filter out outliers before conducting the hierarchical clustering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7">NNS-based Processing</head><p>Clustering algorithms may compare every pair of apps, thus leading to high computation complexity. NNS algorithms allow us to only compare apps that are likely to be similar and therefore dramatically reduce the comparisons. When applying NNS algorithms, we adopt the k-d tree technique <ref type="bibr" target="#b31">[35]</ref>. In the coarse-grained processing, we select candidate app pairs with the help of k-d tree. In the fine-grained processing we compare apps in pair to obtain PR-Groups.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7.1">Selecting Candidate Pairs</head><p>We first build a k-d tree and insert statistical feature vectors v (i) (i = 1, ..., N ) to this tree (k = 15 because of the 15 dimensions). Since different apps may have identical statistical features, we cannot insert both of them into the k-d tree for the sake of avoiding duplicated nodes. For example, given two apps a (i) and a (j) with the same feature vectors (i.e., v (i) and v (j) ), if a (i) is in the k-d tree, we cannot insert a (j) . To solve this problem, we sort the statistical feature vectors of all apps according to the lexicographical order and then group apps having identical feature vectors. As shown in Figure <ref type="figure" target="#fig_2">3</ref>, v (5635) and v (9440) are identical, and therefore we group a (5635) and a (9440) into the same cluster cn. Then, we insert clusters containing one or more apps into the k-d tree, where each node represents a cluster. When we query n nearest neighbors for each cluster Ci, we regard Ci and its neighbors as candidate cluster pairs. For two clusters Ci and Cj, the candidate app pairs include: (1) app pairs in Ci;</p><p>(2) app pairs in Cj; and (3) app pairs between Ci and Cj. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7.2">Pair-wise Comparison</head><p>The distance between two apps a (k) and a (h) is measured by D f in Eqn. <ref type="bibr" target="#b4">(5)</ref>. Given a threshold θ, if D f (a (k) , a (h) ) is smaller than θ, they are in the same PR-Group.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.8">Repackaging Verification</head><p>Apps in PR-Groups have similar appearance and functionalities. However, since developers may create a bunch of similar apps that cannot be considered as repackaged apps, we perform a verification on apps in each RP-Groups. More precisely, we extract developer certificates from apps and distinguish each certificate with their MD5 checksum. If all apps in a PR-Group share the same certificate, they are not repackaged. Otherwise, apps repackaging is detected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">IMPLEMENTATION</head><p>We have implemented Resdroid with 2770 lines of Python code, 1157 lines of Java code, and 309 lines of C code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">DexDumper</head><p>To handle hardened apps whose original classes.dex is encrypted or hidden in shared libraries, we design and implement DexDumper that dumps the original classes.dex of a hardened app from memory during runtime. It is motivated by the observation that the Dalvik virtual machine (DVM) cannot run encrypted classes.dex and therefore the original classes.dex will be restored before being executed.</p><p>DexDumper first invokes the ptrace system call to attach to the process of a running hardened app, and then reads the app's memory and searchs for the dex files. As the memory space of a process is very large, DexDumper manages to narrow the searching scope to efficiently locate the target dex code. More precisely, it reads the process mapping file of the hardened app, namely /proc/PID/maps (PID stands for the app's process ID), where we can get the start address, the end address, and the attributes of each memory piece. Note that the memory where dex files are mapped into has attributes "r-xp", meaning that the area is readable (r), executable (x) and private (p). From memory pieces with such attributes, we can dump a set of dex format files since some pre-loaded runtime libraries (e.g., ext.jar@classes.dex) are also located.</p><p>For each dumped dex files, DexDumper looks for the app's package name (defined in the app's manifest) in their string constants pool. If found, it is considered as the original classes.dex. Since hardening will not alter the app's resources, ResDroid takes in the dumped dex file and the resources from the hardened apps for further process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Feature Extraction</head><p>We employ apktool to decompile apps. Apktool can restore an app's resources and translate its dex code into smali format simultaneously. However, we found that apktool may crash when processing some apps. For such apps, we use aapt and baksmali to obtain their resources and smali code separately. To construct ATG, we use A3E <ref type="bibr" target="#b8">[10]</ref> to perform static analysis on apps. It took around 22 hours to generate ATGs for all apps in our data set. Then we run PageRank to pick 5 major packages, which took another 3 hours. In total, the extraction of statistical features consumed 25 hours. Such a long period is not unexpected because both A3E and the PageRank algorithm are time-consuming. It is acceptable as we only need to do this computation once.</p><p>When extracting layout features of apps, we observed that 93.7% apps define their layouts in XML under the res/layout directory. Therefore, we can obtain their layout structures by traversing the XML files. Since some apps generate their layouts dynamically, we use GATOR (v1.0) <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b36">40]</ref> to process them, which can construct an app's layouts from the codes by conducting static reference analysis for GUI objects. We further enhanced GATOR from two aspects. First, it does not handle certain GUI components (i.e., fragments and dialogs). As fragment is widely used to realize components reuse in different layouts, we added functions to handle it. Second, as GATOR only takes in source codes, we empowered it to accept dex files.</p><p>Similar to activities, layouts of fragments can be defined in static XML files or dynamically created at runtime. There-fore, we first identify fragment objects in activities, and then examine the fragment and check whether its layout is defined in resource file. If so, we directly parse the XML file to obtain its structure. Otherwise, we construct its layout structure by re-using the code logic designed for processing dynamically-generated activity layouts. The extraction of structural features took 49.7 hours.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Clustering and NNS</head><p>In coarse-grained clustering, we use a parallel implementation of spectral clustering <ref type="bibr" target="#b12">[14]</ref>, which can effectively handle large-scale data. Since the last step of spectral clustering is actually running k-means, the number of clusters should be specified. We use x-means <ref type="bibr" target="#b32">[36]</ref> to estimate a proper number, instead of choosing it arbitrarily.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EXPERIMENTS</head><p>Our data set contains 169,352 apps crawled from 10 Android markets, including the offical market Google Play and 9 other third-party markets. Our experiments were conducted on a PC running Ubuntu Linux 12.04LTS with an 8-core Intel i7 3.50GHz CPU and 32GB memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Ground Truth</head><p>We use 200 pairs (400 apps) of repackaged and original apps as ground truth to evaluate ResDroid. All the repackaged apps are real malware or adware (121 from SandDroid<ref type="foot" target="#foot_2">3</ref> and other 79 from ContagioMobile<ref type="foot" target="#foot_3">4</ref> ). The original apps were downloaded from Google Play. There are chances that different versions of the same app present dissimilar GUIs. Therefore, to make the ground truth more reliable, we only select original apps that have the nearest (or the same) version codes with the repackaged ones.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Clustering-based Approach</head><p>During the coarse-grained processing, the x-means algorithm <ref type="bibr" target="#b32">[36]</ref> was used to estimate the number of clusters (denoted as C). The recommended value was 291. We also tried other values close to 291 (i.e., 200, 250, 350, and 400) when performing the spectral clustering. Figure <ref type="figure" target="#fig_3">4</ref> shows the CDFs of the sizes of clusters. With the increment of C, the average cluster size decreases. Figure <ref type="figure" target="#fig_3">4(b)</ref> shows that when C = 291 nearly 10% clusters (around 20% groud truth clusters) contain more than 1,500 apps. As shown in Figure <ref type="figure" target="#fig_3">4(c)</ref>, when C = 400, all clusters contain less than 1,500 apps.</p><p>It is obvious that the smaller a cluster is, the more quickly (and hopefully more accurate) the hierarchy clustering will be finished. Furthermore, although we need to perform more clustering, it is easy to parallelize the tasks as they are independent. So a large C may be expected. However, as shown in Figure <ref type="figure" target="#fig_3">4(d)</ref>, more false negatives appear along with the increment of C. The false negative is 0 when C = 291, but it increases to 3 when C = 400. Moreover, a larger C requires longer time to perform the spectral clustering. Considering both cluster sizes and false negative rate, we finally chose 291 as the number of clusters in coarse-grained clustering.</p><p>We apply hierarchical clustering to each cluster produced by coarse-grained clustering to generate PR-Groups. In hierarchical clustering, we set the cutoff value to 0.1. That 1,605 PR-Groups are obtained and they include 6,906 apps in total. Figure <ref type="figure" target="#fig_5">5</ref> shows the distribution of the sizes of PR-Groups. Over 98% of PR-Groups have sizes smaller than 50. The average size of PR-Groups is 4.03, which is small enough for manually checking if need. Among all of our ground truth pairs, the repackaged app and the original app fell into the same PR-Groups, meaning that the false negative rate is 0.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">NNS-based Approach</head><p>We first build a k-d tree according to statistical features and query nearest neighbors of each tree node for selecting candidate app pairs. More precisely, we set the number of neighbors (n) to 10. Then, we compare their structural features and calculate their distance following Eqn. <ref type="bibr" target="#b4">(5)</ref>. Note that w l and we can be adjusted to support different criteria. For example, if w l &gt; we, more emphasis is paid to the layout features. Otherwise, the event handler features may be regarded as more important. In our experiments, w l = we = 0.5. The distance threshold θ was set to 0.15, meaning that if the distance between two apps is smaller than 0.15 they will be classified into the same PR-Group.</p><p>The total number of PR-Groups produced by NNS-based approach is 2,070, including 20,867 apps. The average size of PR-Groups is 9.9. Figure <ref type="figure" target="#fig_6">6</ref> illustrates the distribution of the sizes of PR-Groups. Similar to the clustering-based approach, most of PR-Groups (over 90%) are smaller than 50. However, there are several PR-Groups whose sizes are larger than 500 and the largest size is 997. Only two pairs of repackaged and original apps are not grouped into the same PR-Groups, and therefore the false negative rate of NNS-based approach is 1%. Section 5.2 and Section 5.3 show that both clusteringbased approach and NNS-based approach can effectively detect repackaged apps with very low false negative. To evaluate the false postive rate of our approaches, we randomly selected 100 groups from the PR-Groups produced by clustering-based approach, and manually checked their resources and smali codes. We also executed these apps in Android emulator to check whether they have similar GUI and functionality. We did the same thing to the PR-Groups produced by NNS-based approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Accuracy</head><p>In the results of clustering-based approach, we found three PR-Groups that contain false positives. So the false positive rate this approach is 3%. But not surprisingly, the sizes of these three PR-Groups (i.e., 80, 84 and 127) are larger than the average value. Our analysis reveals two major reasons for these false positives. First, those apps have only a few activities and their simple functionalities lead to similar statistical features and structural features. Second, apps created by some online tools (e.g., App Makr<ref type="foot" target="#foot_4">5</ref> ) may use the same template, and therefore these apps have similar appearance and event handlers. We discuss how to handle them in Section 6.</p><p>In the results of NNS-based approach, we found 5 PR-Groups containing false positives, and hence the false positive rate is 5%. Similar to the results of clustering-based approach, these false positives were all found from groups with large size (i.e., 520, 548, 641, 885 and 991). It shows that NNS-based approach is not as accurate as clusteringbased approach. The reason may be that when querying nearest neighbors, k-d tree (or other NNS algorithms) only considers most similar ones "locally" whereas in clusteringbased approach each sample will be compared with others (i.e., construct a global view). It demonstrates a tradeoff be-tween efficiency and effectiveness. That is, clustering-based approach suffers from high computational complexity but is more accurate. In contrast, NNS-based approach is much more efficient but less accurate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Complexity</head><p>Since the time complexity of both spectral clustering and hierarchical clustering are O(N 3 ), the overall complexity of clutering-based approach is O(N 3 ). Although the computational cost of clustering-based approach is high, we may leverage parallel computing to speed up the process. For NNS-based approach, we sort feature vectors in lexicographical order before building k-d tree. This step can be accomplished within O(NlogN). Moreover, the complexity of building k-d tree and that of querying nearest neighbors are also O(NlogN). Therefore, the overall time complexity of NNS-based solution is O(NlogN).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Code Obfuscation/App Hardening</head><p>We implement DexDumper to extract the original classes.dex from apps protected by typical hardening systems. Therefore, attackers could not employ such hardening techniques to evade ResDroid.</p><p>We also tested ResDroid's ability to confront obfuscation techniques. We first employed Proguard to obfuscate apps from source codes. The results showed that both statistical features and structural features were not affected. Then we used SandMark 6 to generate obfuscated code from bytecode. However, since SandMark does not support Android's dex format, we converted dex files into jar files through dex2jar and then fed jar files to SandMark. Unfortunately, although SandMark provides 39 kinds of obfuscation methods, only three of them (static method bodies, method merger and class encrypter) could successfully process these jar files. After converting the obfuscated jar files back to dex through dx, we found that static method boides and method merger had no influence on ResDroid. However, ResDroid failed to extract structural features when the jar was encrypted by the class encrypter, and we propose possible solutions in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.7">Observations</head><p>Apart from the ground truth, ResDroid identified 64 repackaged apps. We examined some of them manually and report the observations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.7.1">App Plagiarism</head><p>We found that some plagiarizers repackaged apps and republished these apps as their own. For example, an app (package name: com.bluedog1893.android.translate) has identical structural features with another app (package name: com.dollars.translate). However, they have completely different icons. After manual examination, we found that the former one contains most of the resources and the whole codes from the latter one, but the string resources have been converted from English to Chinese. Moreover, while the original app does not have ads, the plagiarizer added ad libraries to make profits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.7.2">Massively-produced Apps</head><p>We found a set of apps from the same developer having the same structural features. Figure <ref type="figure">7</ref> shows three of them. To create these apps, the developer just wrote the codes once and then applied the same codes to different resources for quickly producing "new" apps.</p><p>Another example comes from a PR-Group where the package names of all 83 apps follow the pattern: com.lvping.mobi le.cityguide.*. These apps provide guidance for travellers, and the last piece of their package names represents the city's name. For example, the app with package name com. lvping.mobile.cityguide.sydney236 offers a travelling guide for Sydeny. However, these 83 apps were signed with two different certificates. Specifically, 4 of them are signed by the certificate whose MD5 fingerprint is '246DA3F3F52830A9E3 FD04111BA4C1D4', while other 79 apps are signed by the certificate whose MD5 is '76439FA93B09D3FA51874769C74 486AB'. We examined the owners and issuers of the two certificates. The first one is "Android Debug" used for signing debugging version of apps. The second one is the company's domain (i.e., lvping.com). We are not sure whether the ones signed by the debugging certificate are repackaged apps created by attackers or it is just because the developer forgot to export release version and sign them using official certificates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.7.3">Misusing Certificates</head><p>We found a pair of repackaged apps that have the same package name (i.e., a5game.leidian2) but different certificate fingerprints. One was signed by 'EE1C7585428F65BAC 2D156B0792D2358', and the other app was signed by '86544 D775DCBA00275CD304C5C37BCC7'. We investigated the two certificates and found the former is owned by "5agame. com", but the latter's owner is in Chinese characters, which is the name of the website http://www.5agame.com. After careful examination of their codes, we did not find anything abnormal. It is likely that both the two apps were actually published by the same developer "5agame.com", but they chose different certificates for the same app for some unknown reasons. This may result in failures of updates, because the Android system does not allow the newer app and the older one have different certificates. Therefore, it is an example of misusing app certificates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">DISCUSSION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Attack Analysis</head><p>Zhang et al. described the behaviors of three kinds of repackaging attacks <ref type="bibr" target="#b41">[45]</ref>, including (1) lazy attacks that use automatic code obfuscation tools to repackage apps without modifying the functionality of original apps; (2) malware that embeds malicious payload into original apps without changing them; (3) amateur attacks that may make some changes to original apps besides employing the automatic code obfuscation tools. Since none of them will modify the resources and the related codes, ResDroid can detect them.</p><p>Advanced attackers who know ResDroid may change features to evade detection. For example, they can insert many junk resources into the repackaged app for affecting the statistical features. However, we consider the relations between resources and codes (e.g., references from XML files, loading from code) and identify core resources, from which statistical features are extracted. Therefore, junk resources that are not carefully crafted will be filtered out. Dedicated attackers may change statistical features by inserting resources and altering the dex file simultaneously at a cost of increased app size and degraded performance. We may apply dead-code detection techniques <ref type="bibr" target="#b10">[12]</ref> to identify such junk functions and remove them along with the corresponding resources when computing the features.</p><p>As explained in Section 3.5, it is difficult for attackers to re-implement a new layout while keeping the same looks and feels. Moreover, to retain the normal functionality and QoE of the repackaged app, attackers will not remove event handlers. Although attackers can add new event handlers, they cannot modified the result of normalized LCS as explained in Section 3.5.3. Therefore, the structural features are robust and can raise the bar for attackers to evade detection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Limitations and Future Work</head><p>We notice that apps created by automatic building tools will cause false positives, because these tools provide developers a set of templates to create apps. Apps using the same template will shared similar appearance and the event handlers, therefore, their statistical features and structural feature are alike. ResDroid cannot differentiate them. In future work, we will use components' attributes to differentiate them. Another possible approach is to use code-level detection systems such as DNADroid <ref type="bibr" target="#b15">[19]</ref> to handle them.</p><p>If code obfuscation/app hardening systems employ various dynamic loading techniques and encryption methods to prevent static analysis, ResDroid may not be able to handle such apps through static analysis. However, since these techniques will eventually load codes and resources into memory, we will design a kernel-based dynamic approach like <ref type="bibr" target="#b38">[42]</ref>, which keeps monitoring the behavior of a hardened app and dumps selected codes and resources after they are loaded. Moreover, we will examine how to fingerprint apps protected by different code obfuscation/app hardening systems. <ref type="bibr" target="#b9">[11,</ref><ref type="bibr" target="#b35">39,</ref><ref type="bibr" target="#b37">41]</ref>. Existing approaches can be roughly classified into four groups <ref type="bibr" target="#b37">[41]</ref>:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">RELATED WORK</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Code clone detection. Considerable research has been conducted on code clone detection</head><p>(1) textual analysis that extracts fingerprints from code directly; (2) lexical analysis that converts codes into lexical tokens and then detects duplicated token sequences (e.g., CP-Miner <ref type="bibr" target="#b28">[32]</ref>, etc.); (3) syntactic analysis that first turns codes into abstract syntax trees (AST) and then applies tree matching or structural metrics to detect clones (e.g., Deckard <ref type="bibr" target="#b26">[30]</ref>, etc.); (4) semantic analysis that employs static program analysis to extract more precise information about the code, such as program dependency graph, for detection (e.g., GPLAG <ref type="bibr" target="#b29">[33]</ref>, etc.). Some of these methods have been used to detect repackaged apps by analyzing dex files, or the converted Java class files, or the disassembled smali codes. Repackaged apps detection. Assuming apps from the official market are original, DroidMOSS applies fuzzy hashing to each app's opcodes and then compares it to original apps' fingerprint for detecting repackaged apps <ref type="bibr" target="#b43">[47]</ref>. Similarly, Androguard <ref type="bibr" target="#b0">[1]</ref> uses several standard similarity metrics to hash methods and basic blocks for comparison. Juxtapp characterizes apps through k-grams of opcodes and feature hashing and then clusters the corresponding bitvectors to identify app clones <ref type="bibr" target="#b23">[27]</ref>. PiggyApp was designed to detect piggybacked apps, a special kind of repackaged apps, which contain injected code <ref type="bibr" target="#b42">[46]</ref>. It first decouples modules according to their dependency relationship and then construct fingerprint for the primary module by collecting various features, such as requested permissions, Android API calls used, etc. <ref type="bibr" target="#b42">[46]</ref>. These methods are vulnerable to simple obfuscation techniques because they consider few semantic information about codes <ref type="bibr" target="#b25">[29,</ref><ref type="bibr" target="#b39">43,</ref><ref type="bibr" target="#b40">44]</ref>.</p><p>Dresnos used normalized compression distance (NCD) <ref type="bibr" target="#b13">[15]</ref> to compare the similarity of apps according to their method signatures, including external API used, exceptions, and control flow graph (CFG) <ref type="bibr" target="#b18">[22]</ref>. Potharaju et al. proposed an approach to detect plagiarized apps according to symbol tables and method-level AST fingerprints. This approach can handle two kinds of obfuscation techniques that mangles symbol table or inserts random methods with no functionality <ref type="bibr" target="#b33">[37]</ref>. DroidSim utilizes component-based control flow graph (CB-CFG) to quantify the similarity between apps <ref type="bibr" target="#b39">[43]</ref>. DNADroid constructs a program dependency graph (PDG) for each method and then performs subgraph isomorphism comparison on PDGs after filtering out unnecessary methods <ref type="bibr" target="#b15">[19]</ref>. To speed up DNADroid, AnDarwin splits PDGs into connected components (i.e., semantic blocks), each of which will be represented by a semantic vector containing the number of specific types. After that, it employs locality sensitive hashing (LSH) to identify code clones that have similar semantic vectors <ref type="bibr" target="#b16">[20]</ref>. Chen et al. proposed a novel approach that uses the centroid of control dependency graph to measure the similarity between methods for detecting cross-market app clones <ref type="bibr" target="#b11">[13]</ref>. Although these methods are better than the previous ones, they could still be easily evaded by obfuscation techniques (e.g., inserting dummy codes or adding data related variables) <ref type="bibr" target="#b39">[43,</ref><ref type="bibr" target="#b41">45]</ref>.</p><p>Recently, Hao et al. showed that it is possible to detect app clones using UI state transition graphs <ref type="bibr" target="#b24">[28]</ref>. In a simultaneous research, Zhang et al. proposed ViewDroid that first constructs feature view graph and then applies subgraph isomorphism algorithm to measure the similarity between two apps <ref type="bibr" target="#b41">[45]</ref>. Although both ViewDroid and ResDroid exploit UI for detecting repackaged apps, there are three major difference between them. First, ViewDroid only uses the relationship among activities while ResDroid employs both the layout of activities and the relationship among activities. Moreover, we take into account Android's fragment component that provides similar functionality as an activity. However, ViewDroid does not handle such component. Second, by only examining core resources, ResDroid would be more efficient and more robust to third-party libraries than View-Droid that considers all views. Third, whereas ViewDroid targets on comparison between a pair of apps, ResDroid is built on top of a two-stage methodology and equipped with two kinds of algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUSION</head><p>We propose a novel approach that leverages new features extracted from core resources and codes to detect repackaged apps. These features do not require processing all opcodes and are resilient to code obfuscation/app hardening techniques. To speed up the detection, we adopt the divideand-conquer strategy to reduce the comparison and support parallel processing. Our solution have been realized in Res-Droid and the extensive evaluation using real repackaged apps has demonstrated its effectiveness and efficiency.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Example of the interaction between app code and resources.</figDesc><graphic coords="2,316.67,53.69,241.22,412.94" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure. 2</head><label>2</label><figDesc>Figure. 2 depicts our resource-driven solution for detecting repackaged apps, which is realized in ResDroid and the implementation is detailed in Section 4.The feature extraction module first identifies an app's major packages according to their importance measured by the PageRank algorithm<ref type="bibr" target="#b30">[34]</ref> (Section 3.3). Then, core resources along with their statistical features and structural features will be determined according to major packages and the app's manifest file. The statistical features (Section 3.4) are lightweight in terms of computation and comparison but may not provide precise information about an app. In contrast, structural features (Section 3.5) can better characterize an app at the cost of the complexity of computation and comparison.To scale up the detection for millions of apps, we propose a two-stage methodology that employs the divide-and-conquer strategy to identify similar apps within small groups of apps. More precisely, ResDroid first uses statistical features to divide apps into small classes in the coarse-grained processing module and then employs structural features to identify similar apps within each group in the fine-grained processing module. The output is a set of potential repackaging groups (PR-Groups) containing suspicious repackaged apps. Our approach is rational because repackaged apps are usually similar to original apps and the process of clustering apps</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Statistical feature vectors are sorted in Lexicographical order. Apps that have identical feature vectors are grouped in the same cluster.</figDesc><graphic coords="5,355.43,431.21,143.78,65.30" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: CDFs of sizes of clusters produced by spectral (coarse-grained) clustering with different numbers of cluters</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Distribution of the sizes of PR-Groups that are produced by hierarchical clustering with cutoff value 0.1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Distribution of the sizes of PR-Groups when NNS-based approach is employed, with distance threshold 0.15.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>6 3 Figure 7 :</head><label>37</label><figDesc>Figure 7: Three apps have exactly the same layout</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>The GUI component text fragment (lines 40-42) is a customized component com.example.MyEditText. It is defined in my editor.xml (lines<ref type="bibr" target="#b42">[46]</ref><ref type="bibr" target="#b43">[47]</ref><ref type="bibr" target="#b44">[48]</ref>, and the corresponding codes are in com.example.MyEditText.java, as specified in line 47.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>10 most referenced resource types in 24,810 apps randomly selected from our dataset.</figDesc><table><row><cell></cell><cell></cell><cell>Total</cell><cell>Average</cell></row><row><cell>1</cell><cell>id</cell><cell>6,631,598</cell><cell>267</cell></row><row><cell>2</cell><cell cols="2">drawable 3,616,963</cell><cell>146</cell></row><row><cell>3</cell><cell>string</cell><cell>1,964,378</cell><cell>79</cell></row><row><cell>4</cell><cell>color</cell><cell>1,024,896</cell><cell>41</cell></row><row><cell>5</cell><cell>style</cell><cell>823,848</cell><cell>33</cell></row><row><cell>6</cell><cell>dimen</cell><cell>623,906</cell><cell>25</cell></row><row><cell>7</cell><cell>layout</cell><cell>248,097</cell><cell>10</cell></row><row><cell>8</cell><cell>xml</cell><cell>136,730</cell><cell>6</cell></row><row><cell>9</cell><cell>integer</cell><cell>88,130</cell><cell>4</cell></row><row><cell>10</cell><cell>array</cell><cell>76,670</cell><cell>3</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>http://www.bangcle.com</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>http://www.ijiami.cn</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>http://sanddroid.xjtu.edu.cn</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>http://contagiominidump.blogspot.com</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>http://www.appmakr.com</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">ACKNOWLEDGMENT</head><p>We thank reviewers for their comments, and thank Wenjun Hu and Kai Chen for providing us samples. This work is supported in part by the Hong Kong GRF (No. PolyU 5389/13E), the National Natural Science Foundation of China (No. 61202396), the PolyU Research Grant(G-UA3X), and the Open Fund of Key Lab of Digital Signal and Image Processing of Guangdong Province(2013GDDSIPL-04).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>Androguard</surname></persName>
		</author>
		<ptr target="https://code.google.com/p/androguard/" />
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">2% of apps on google play are repackaged to deliver ads</title>
		<ptr target="http://www.net-security.org/secworld.php?id=15976" />
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page">2013</biblScope>
		</imprint>
	</monogr>
	<note>collect info</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<ptr target="http://betanews.com/2013/12/03/app-hardening-emerges-as-a-key-component-of-mobile-security-strategies" />
		<title level="m">App hardening emerges as a key component of mobile security strategies</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<ptr target="http://dacongy.github.io/gator/" />
		<title level="m">Gator: Program analysis toolkit for android</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<ptr target="http://developer.android.com/training/basics/activity-lifecycle/index.html" />
		<title level="m">Managing the activity lifecycle</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Data Clustering: Algorithms and Applications</title>
		<author>
			<persName><forename type="first">C</forename><surname>Aggarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Reddy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>Chapman and Hall/CRC</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Near-optimal hashing algorithms for approximate nearest neighbor in high dimensions</title>
		<author>
			<persName><forename type="first">A</forename><surname>Andoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Indyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<ptr target="http://www.arxan.com/resources/state-of-security-in-the-app-economy/" />
		<title level="m">State of security in the app economy</title>
		<imprint>
			<publisher>Arxan Technologies Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Targeted and depth-first exploration for systematic testing of android apps</title>
		<author>
			<persName><forename type="first">T</forename><surname>Azim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Neamtiu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGPLAN</title>
		<meeting>ACM SIGPLAN</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Comparison and evaluation of clone detection tools</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bellon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Koschke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Antoniol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Krinke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Merlo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">9</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Efficient relational calculation for software analysis</title>
		<author>
			<persName><forename type="first">D</forename><surname>Beyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Noack</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lewerentz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Achieving accuracy and scalability simultaneously in detecting application clones on android markets</title>
		<author>
			<persName><forename type="first">K</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM ICSE</title>
		<meeting>ACM ICSE</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Parallel spectral clustering in distributed systems</title>
		<author>
			<persName><forename type="first">W.-Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Bai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-J</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">Y</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Pattern Anal. Mach. Intell</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Clustering by compression</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cilibrasi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Vitanyi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Surreptitious Software: Obfuscation, Watermarking, and Tamperproofing for Software Protection</title>
		<author>
			<persName><forename type="first">C</forename><surname>Collberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Nagra</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Attack of the clones: Detecting cloned applications on android markets</title>
		<author>
			<persName><forename type="first">J</forename><surname>Crussell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gibler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ESORICS</title>
		<meeting>ESORICS</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Scalable semantics-based detection of similar android applications</title>
		<author>
			<persName><forename type="first">J</forename><surname>Crussell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gibler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ESORICS</title>
		<meeting>ESORICS</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">J</forename><surname>Davies</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>German</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W</forename><surname>Godfrey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hindle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software bertillonage. Empirical Software Engineering</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">6</biblScope>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Android: Static analysis using similarity distance</title>
		<author>
			<persName><forename type="first">A</forename><surname>Dresnos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. HICSS</title>
		<meeting>HICSS</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Taintdroid: An information-flow tracking system for realtime privacy monitoring on smartphones</title>
		<author>
			<persName><forename type="first">W</forename><surname>Enck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Gilbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Chun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">P</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mcdaniel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sheth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. OSDI</title>
		<meeting>OSDI</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Adrob: examining the landscape and impact of android application plagiarism</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gibler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Stevens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Crussell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Choi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM MobiSys</title>
		<meeting>ACM MobiSys</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Riskranker: scalable and accurate zero-day android malware detection</title>
		<author>
			<persName><forename type="first">M</forename><surname>Grace</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Jiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM MobiSys</title>
		<meeting>ACM MobiSys</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">On clustering validation techniques</title>
		<author>
			<persName><forename type="first">M</forename><surname>Halkidi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Batistakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vazirgiannis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Intelligent Information Systems</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2-3</biblScope>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Juxtapp: a scalable system for detecting code reuse among android applications</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hanna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DIMVA</title>
		<meeting>DIMVA</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">PUMA: Programmable ui-automation for large scale dynamic analysis of mobile apps</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Nath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Halfond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Govindan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM MobiSys</title>
		<meeting>ACM MobiSys</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A framework for evaluating mobile app repackaging detection algorithms</title>
		<author>
			<persName><forename type="first">H</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. TRUST</title>
		<meeting>TRUST</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Deckard: Scalable and accurate tree-based detection of code clones</title>
		<author>
			<persName><forename type="first">L</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Misherghi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Glondu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE ICSE</title>
		<meeting>IEEE ICSE</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Repackaging attack on android banking applications and its countermeasures</title>
		<author>
			<persName><forename type="first">J.-H</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Y</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-C</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Yi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Wireless Personal Comm</title>
		<imprint>
			<biblScope unit="volume">73</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Cp-miner: Finding copy-paste and related bugs in large-scale software code</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Myagmar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Gplag: Detection of software plagiarism by program dependence graph analysis</title>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM KDD</title>
		<meeting>ACM KDD</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Networks: An Introduction</title>
		<author>
			<persName><forename type="first">M</forename><surname>Newman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
			<publisher>Oxford University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Nearest Neighbor Search: A Database Perspective</title>
		<author>
			<persName><forename type="first">A</forename><surname>Papadopoulos</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">X-means: Extending k-means with efficient estimation of the number of clusters</title>
		<author>
			<persName><forename type="first">D</forename><surname>Pelleg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Moore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICML</title>
		<meeting>ICML</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Plagiarizing smartphone applications: Attack strategies and defense techniques</title>
		<author>
			<persName><forename type="first">R</forename><surname>Potharaju</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Newell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Nita-Rotaru</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ESSoS</title>
		<meeting>ESSoS</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">On tracking information flows through JNI in android apps</title>
		<author>
			<persName><forename type="first">C</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Chan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE/IFIP DSN</title>
		<meeting>IEEE/IFIP DSN</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Software clone detection: A systematic review</title>
		<author>
			<persName><forename type="first">D</forename><surname>Rattan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bhatia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Singh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Software Technology</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="issue">7</biblScope>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Static reference analysis for gui objects in android software</title>
		<author>
			<persName><forename type="first">A</forename><surname>Rountev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Yan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE/ACM CGO</title>
		<meeting>IEEE/ACM CGO</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Comparison and evaluation of code clone detection techniques and tools: A qualitative approach</title>
		<author>
			<persName><forename type="first">C</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cordy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Koschke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sci. Comput. Program</title>
		<imprint>
			<biblScope unit="volume">74</biblScope>
			<biblScope unit="issue">7</biblScope>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Rootguard: Protecting rooted android phones</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Qian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<date type="published" when="2014-06">June 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Detecting code reuse in android applications using component-based control flow graph</title>
		<author>
			<persName><forename type="first">X</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhongyang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Xin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Xie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IFIP SEC</title>
		<meeting>IFIP SEC</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Revisiting android reuse studies in the context of code obfuscation and library usages</title>
		<author>
			<persName><forename type="first">M</forename><surname>Vasquez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Holtzhauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bernal-Cardenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Poshyvanyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE MSR</title>
		<meeting>IEEE MSR</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Viewdroid: Towards obfuscation-resilient mobile application repackaging detection</title>
		<author>
			<persName><forename type="first">F</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM WiSec</title>
		<meeting>ACM WiSec</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Fast, scalable detection of piggybacked mobile applications</title>
		<author>
			<persName><forename type="first">W</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Grace</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM CODASPY</title>
		<meeting>ACM CODASPY</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Detecting repackaged smartphone applications in third-party android marketplaces</title>
		<author>
			<persName><forename type="first">W</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM CODASPY</title>
		<meeting>ACM CODASPY</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Dissecting android malware: Characterization and evolution</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Jiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. Security and Privacy</title>
		<meeting>IEEE Symp. Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
