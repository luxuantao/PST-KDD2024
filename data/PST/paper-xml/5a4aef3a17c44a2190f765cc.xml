<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Malware Detection in Adversarial Seings: Exploiting Feature Evolutions and Confusions in Android Apps</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Wei</forename><surname>Yang</surname></persName>
							<email>weiyang3@illinois.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Deguang</forename><surname>Kong</surname></persName>
							<email>doogkong@gmail.com</email>
							<affiliation key="aff1">
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Tao</forename><surname>Xie</surname></persName>
							<email>taoxie@illinois.edu</email>
							<affiliation key="aff2">
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Carl</forename><forename type="middle">A</forename><surname>Gunter</surname></persName>
							<email>cgunter@illinois.edu</email>
							<affiliation key="aff3">
								<address>
									<postCode>2017</postCode>
									<settlement>Orlando</settlement>
									<region>FL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Malware Detection in Adversarial Seings: Exploiting Feature Evolutions and Confusions in Android Apps</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">8A65BA8BE139884959E526A2B42170CD</idno>
					<idno type="DOI">10.1145/3134600.3134642</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:39+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Malware detection, Adversarial classication</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Existing techniques on adversarial malware generation employ feature mutations based on feature vectors extracted from malware. However, most (if not all) of these techniques suer from a common limitation: feasibility of these aacks is unknown. e synthesized mutations may break the inherent constraints posed by code structures of the malware, causing either crashes or malfunctioning of malicious payloads. To address the limitation, we present Malware Recomposition Variation (MRV), an approach that conducts semantic analysis of existing malware to systematically construct new malware variants for malware detectors to test and strengthen their detection signatures/models. In particular, we use two variation strategies (i.e., malware evolution aack and malware confusion aack) following structures of existing malware to enhance feasibility of the aacks. Upon the given malware, we conduct semantic-feature mutation analysis and phylogenetic analysis to synthesize mutation strategies. Based on these strategies, we perform program transplantation to automatically mutate malware bytecode to generate new malware variants. We evaluate our MRV approach on actual malware variants, and our empirical evaluation on 1,935 Android benign apps and 1,917 malware shows that MRV produces malware variants that can have high likelihood to evade detection while still retaining their malicious behaviors. We also propose and evaluate three defense mechanisms to counter MRV.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>malware. According to the McAfee Security Report <ref type="bibr" target="#b26">[27]</ref>, more than 37 million mobile malware samples were detected over the six months preceding the report-writing time. To ght against malware, a signature-based technique extracts malicious behaviors as signatures (such as bytecode or regular expression) while a more complicated machine-learning-based technique <ref type="bibr" target="#b22">[23]</ref> learns discriminant features from analyzing semantics of malware.</p><p>To defeat these detection techniques, malware authors constantly produce new variants of existing malware families. Recent studies <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b40">41,</ref><ref type="bibr" target="#b33">34]</ref> show that performance of both signature-based and learning-based malware detection techniques can be degraded by carefully-craed malware variants. To increase the robustness of malware detectors against malware variants, we need to be proactive and take potential adversarial scenarios into account in designing malware detectors. To enable the proactive design of malware detectors, existing work <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b12">13]</ref> has been proposed to evaluate malware detectors in adversarial seings. Such work envisions potential aack scenarios and manipulates (adds, changes, or removes) features <ref type="foot" target="#foot_0">1</ref> extracted from malware according to the envisioned aacks. e malware detectors are then used to identify malware variants through the manipulated features. e performance of the malware detection on manipulated features is expected to be lower than the original detection. e robustness of the malware detectors are further evaluated based on performance degradation.</p><p>However, the validity of these evaluations is questionable due to impracticality of the aacks. e aacks used in the prior work manipulate the feature vectors of a malware sample without considering feasibility and impact of the mutation. In other words, when applying the changes made in feature vectors to the malware's code, the changes may cause the malware to crash, cause undesired behaviors, or disable malicious functionalities (sometimes the modied code cannot even be compiled).</p><p>ere are three practical constraints to cra a realistic aack: Preserving Malicious Behaviors. e mutated malware should maintain the original malicious purposes, and therefore simply converting the malware's feature values to another app's feature values is likely to break the maliciousness. For example, malicious behaviors are usually designed to be triggered under certain contexts (to avoid user aention and gain maximum prots <ref type="bibr" target="#b42">[43]</ref>), and the controlling logic of the malware is too sophisticated (e.g., via logic bombs and specic events) to be changed.</p><p>Maintaining the Robustness of Apps. e mutated malware should be robust enough to be installed and executed in mobile devices. Automatically mutating an app's feature values is likely to break the code structures and therefore cause the app to crash at runtime.</p><p>Evading Malware Detectors. To evade a malware-detection model, an adversary needs to identify the features and compute the feature values that can evade detection without breaking the malware. Doing so usually requires an adversary to possess internal knowledge and understanding of the malware detectors. Unfortunately, generally an adversary may have lile (or even no) knowledge about the malware-detection model (such as features and algorithms). Moreover, the particular knowledge to a single malware-detection model is too specic to successfully produce evasive variants, especially if the malware detector (e.g., VirusTotal <ref type="bibr" target="#b4">[5]</ref>) is based on combining multiple models or techniques.</p><p>To create an aack satisfying these three constraints, we employ Malware Recomposition Variation (MRV) consisting of two mutation strategies, Malware Evolution Aack and Malware Confusion Aack (Section 3). e advantage of our mutation strategies is that the strategies can produce high percentages of feasible feature mutations (suggested in our evaluation), thus greatly enhancing the feasibility of the aacks. e insight is that feature mutations are less likely to break the apps when the mutations follow feature paerns <ref type="foot" target="#foot_1">2</ref> of existing malware. To mutate app features in black-box scenarios, we create a substitute model named as RTLD (Section 2) approximating the models of malware detectors. Such methodology has been widely used to launch successful black-box aacks in prior work <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b25">26]</ref>. RTLD generally reects the susceptibility of a detection technique to the mutations of malware feature values.</p><p>To apply the mutation strategies without breaking dependencies and functionalities in an app, we develop a new technique, inspired by program transplantation <ref type="bibr" target="#b35">[36]</ref>, to reuse the existing implementations instead of randomly mutating or synthesizing the code. In particular, we develop a transplantation framework capable of inter-method, inter-component, and inter-app transplantation (transplanting a feature in one app/component/method, i.e., donor, to a dierent app/component/method, i.e., host). By leveraging the existing implementations, this technique enables systematic and automatic mutations on malware samples while aiming to produce well-functioning apps.</p><p>We also propose and evaluate three defense mechanisms to strengthen the robustness of malware detectors against MRV attacks. (i) Adversarial Training. Training a new model with the combination of the generated malware variants and original training data. (ii)Variant Detector. Developing a detector in addition to the original malware detector to detect whether an app is a variant derived from existing malware. (iii)Weight Bounding. Bounding the feature weights in the original malware detector to make feature weights more evenly distributed <ref type="foot" target="#foot_2">3</ref> .</p><p>Main Contributions. is paper makes the following main contributions.</p><p>• Aacks. We propose two practical aacks (feature evolution aack and feature confusion aack) to eectively mutate existing malware for evading detection (Section 3).</p><p>• Observation. We evaluate the robustness of detection models and the dierentiability of selected features of malware detectors by systematically and automatically applying proposed aacks to existing malware detectors (Section 7).</p><p>• Characterization. We propose an RTLD feature model that characterizes and dierentiates contextual and essential features of malicious behaviors (Section 2).</p><p>• Framework. We develop a transplantation framework capable of inter-method, inter-component, and inter-app transplantation to automatically mutate app features (Section 4).</p><p>Related Work. Smutz et al. <ref type="bibr" target="#b37">[38]</ref> propose mutual agreement analysis to detect classier evasions in malware detectors. To evaluate the improvement over the Drebin malware detector, Smutz et al. withhold some malware families from the training set and use malware samples from these families to check the performance of malware detectors. Our work diers from their work in two aspects. First, their approach works for only ensemble classiers, while our approach works for any type of malware detectors. Second, they use existing malware samples to mimic the aack of unknown malware families, while we generate previously unknown malware variants to test the robustness of malware detectors.</p><p>Grosse et al. <ref type="bibr" target="#b18">[19]</ref> investigate how adversarial perturbation would aect malware detectors based on deep neural networks. Grosse et al. mutate malware features based on the forward derivative <ref type="bibr" target="#b30">[31]</ref> of the neural network to evade detection. Grosse et al. do not apply the computed feature mutations to the malware bytecode. Instead, they choose a conservative mutation strategy by adding only manifest features (i.e., features extracted from the manifest le, AndroidManifest.xml). In comparison, our proposed aacks are more comprehensive (adding, removing, or changing features) and more practical (changing both the manifest le and dex code).</p><p>Demontis et al. <ref type="bibr" target="#b15">[16]</ref> investigate performance of malware detectors by applying a few previous aacks <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b21">22]</ref>. <ref type="bibr">Demontis et al.</ref> propose to perform feature mutations and obfuscations to evade malware detection. However, their work does not apply feature mutations on malware bytecode. It is possible that the computed feature mutations are infeasible aacks. Hu et al. <ref type="bibr" target="#b20">[21]</ref> propose to leverage generative adversarial network <ref type="bibr" target="#b17">[18]</ref> to generate adversarial malware samples. ey also do not apply feature mutations on malware bytecode, thus leading potential infeasible aacks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RTLD FEATURE MODEL</head><p>We characterize semantic features of mobile apps using the RTLD <ref type="foot" target="#foot_3">4</ref>feature model, which aims to reect the essential malicious behaviors while balancing between the computational eciency and accuracy. e RTLD feature model is a general model summarizing the essential features (i.e., security-sensitive resources) and contextual features (e.g., when, where, how the security-sensitive resources are obtained and used) commonly used in malware detection. e RTLD features cover four main aspects: Resource (what security-sensitive resources malicious behaviors obtain), Temporal (when the malicious behaviors are triggered), Locale (where the malicious behaviors occur), and Dependency (how the malicious behaviors are controlled). e advantages of using the RTLD features are two-fold. First, we can learn a substitute model approximating the targeted detector using the RTLD features. Based on the transferability property <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b38">39]</ref>, some adversarial samples generated based on the substitute model can also evade the original detectors. e second advantage of the RTLD features is the separation of essential features and contextual features. To form an informative feature set for signature or detection model, existing malware detection tends to include as many features as possible. For example, Drebin, a recently published approach of malware detection <ref type="bibr" target="#b6">[7]</ref>, uses the feature set containing 545,334 features. A recent study <ref type="bibr" target="#b34">[35]</ref> shows that such large feature set has numerous non-informative or even misleading features. Two of our observations conrm this nding. (i) Malware detectors oen confuse non-essential features in code clones as discriminative features. Copy-paste practice is prevalent in the malware industry, resulting in many code clones in malware samples <ref type="bibr" target="#b14">[15]</ref>. Because the same code has appeared in many malware instances, learning-based detectors may regard non-essential features (e.g., minor implementation detail) in code clones as major discriminant factors (because the same pieces of code appear in many malware samples but not in benign apps). (ii) Using a universal set of features for all malware families would result in a large number of non-essential features to characterize each malware family, because the features essential to malicious behaviors are dierent for each family. e separation of essential features and contextual features in the RTLD model enables our generated aacks to pinpoint the features that are not critical to the malicious behaviors but confusing to the classiers.</p><p>We use the simplied code snippet of the DougaLeaker malware 5 shown in Figure <ref type="figure" target="#fig_2">1</ref> to illustrate the feature model. e code snippet shows two malicious behaviors of the DougaLeaker malware. First, the code snippet saves the Android ID and telephone number of the victim device to global class User when the app starts (Lines 5-7 in Figure <ref type="figure" target="#fig_2">1b</ref>). en the code snippet reads contacts on the victim device (Lines 8-13 in Figure <ref type="figure" target="#fig_2">1b</ref>) and sends the contacts to a malicious server (Line 20 in Figure <ref type="figure" target="#fig_2">1b</ref>). e code snippet also starts a service that sends the Android ID and telephone number to the malicious server through text messages between 11PM and 5AM. e resource features describe the security-sensitive resources exploited by malicious behaviors while the dependency features further represent how the malicious behaviors are controlled. We locate resource features by constructing call graphs and identifying call-graph nodes of the security-sensitive methods (including methods for accessing permission-protected resources and methods for executing external binaries/commands). We compile the list of security-sensitive methods based on PScout <ref type="bibr" target="#b7">[8]</ref> and construct the call graphs using the SPARK call-graph algorithm implemented in Soot <ref type="bibr" target="#b39">[40]</ref>. e call graphs represent the invocation relationships between the app's entrypoints and permission invocations. We save the entrypoints of the call graphs in this step to trace back to the other features in later steps. For the DougaLeaker example, we can locate the HttpPost method invocation (not shown in Figure <ref type="figure" target="#fig_2">1</ref>) in exec post along with the sendTextMessage method invocation  <ref type="figure" target="#fig_2">1c</ref>) in onStartCommand in the call graph. Due to space limit, we omit many details here. e temporal features describe the contexts when the malicious behaviors are triggered. To extract the temporal features, we identify three categories of temporal features based on the aributes of their entrypoints. (i) For system events handled by intent lters, their entrypoints are lifecycle methods. e components of the lifecycle methods should have intent lters specied. (ii) For both system events captured by event-handling methods and UI events, their entrypoints should be event-handling methods. (iii) For lifecycle events, their entrypoints are lifecycle methods, and these lifecycle methods have not been invoked by other events (due to inter-component communications). e locale features describe the program locations where the malicious behaviors occur. e location of a malicious behavior is either an Android component (i.e., Service, Activity, and Broadcast Receiver) or concurrency constructs (e.g., AsyncTask and Handler). Malicious behaviors get executed when these components are activated. Due to the inter-component communication (ICC) in an Android app, the entrypoint component of a malicious behavior could be dierent from the component where the behavior resides in. e locale features in general reect the visibility of a task (i.e., whether the execution of the task is in the foreground or background) and continuity (i.e., whether the task is once-o execution or a continuous execution, even aer exiting the app). For example, if a permission is used in a Service component (that has not been terminated by stopService), the permission use is running in the background, and it is also a continuous task (even aer exiting the app). e dependency features describe the control dependencies of invocations of malicious behaviors. A control dependency between two statements exists if the truth value of the rst statement controls whether the second statement gets executed. Malware frequently leverage external events or aributes to control malicious behaviors. For example, a DroidDream malware sample leverages the current system time to control the execution of its malicious payload. It suppresses its malicious payload during the day but allows the payload's executions at late night when users are likely sleeping.</p><p>We construct inter-procedure control-ow graph (ICFG) to extract the dependency features. Based on the ICFG, we construct the subgraphs from each entrypoint to a resource feature (i.e., security-sensitive method call). For each subgraph, we traverse the subgraph to identify the conditional statements that the securitysensitive method invocation is control-dependent on. e value of a conditional statement is used to decide which program branch to take in runtime executions, and thus decide whether a securitysensitive method invocation on one of the program branches can be executed or not. We say that such conditional statement controls the invocation of the method. Finally, we save the set of extracted conditional statements as dependency features with the resource features and the corresponding location/temporal features. Figure <ref type="figure" target="#fig_9">8</ref> shows the ICFG of the onCreate and onStartCommand methods. As shown in the gure, the sendTextMessage method on Line 7 in onStartCommand (Figure <ref type="figure" target="#fig_2">1c</ref>) is controlled by the conditional statement on Line 6 in onStartCommand and the conditional statement on Line 8 in onCreate (Figure <ref type="figure" target="#fig_2">1b</ref>). On the other hand, the exec post method in onCreate is not controlled by any conditional statement, and thus the security-sensitive behavior in exec post does not have any dependency feature.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">MUTATION STRATEGY SYNTHESIS</head><p>In this section, we present our techniques of synthesizing strategies to mutate app features in black-box scenarios. To address the challenge that adversaries have no knowledge about malware detection techniques (e.g., features, models, algorithms) in black-box scenarios, we develop two aacks: evolution aack and confusion aack.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Evolution Attack</head><p>In evolution aack, instead of developing targeted malware to evade specic detection techniques, we come up with a more general defeating mechanism: mimicking and automating the evolution of malware. Such defeating mechanism is based on the insight that the evolution process of malware reects the strategies employed by malware authors to achieve a malicious purpose while evading detection. Although existing anti-virus techniques have already been updated to detect the "blind spot" exploited by evolved malware samples, those malware samples are merely a few instances being manually mutated by malware authors. e mutation strategies, if automated, can be systematically employed on a large set of malware samples, enabling the exploitation to identify much more blind spots of existing detection. e main insight for malware evolution aack is that malware creation is similar to biological evolution process (i.e., copy and edit of the paerns). To interpret how malware evolve and understand the dierences among variants of a malware family, we conduct a phylogenetic analysis for each family of malware <ref type="foot" target="#foot_4">6</ref> . We believe that capturing the subtle dierences among evolving malware paerns can help mimick new malware.</p><p>Phylogenetic analysis on each family of malware. A phylogenetic evolutionary tree <ref type="bibr" target="#b9">[10]</ref> is a branching diagram (a.k.a evolution tree) that shows the inferred evolution relations among dierent samples based on the similarities and dierences in their feature representations. In the context of malware phylogenetic analysis, we aim to understand how each family of malware evolves.</p><p>We perform our study using the aforementioned RTLD feature type due to its competitive performance for classifying malicious apps. We conduct malware phylogenetic analysis from searching the common shared feature set and divergent feature set. e pairwise distance between malware samples is dened based on the ratio of the number of features in the common shared feature set to the number of features in the total feature set (including the divergent feature set).</p><p>Pairwise distance computation. Note that in the RTLD feature type, each mobile app actually corresponds to multiple lines of feature vectors. erefore, we align the feature vectors from any two mobile apps, using the (permission, API) key. In other words, if the (Permission, API) values of two feature vectors are the same, we further study similarities between the two feature vectors. Otherwise, we stop comparing the two feature vectors since comparing two feature vectors with dierent API methods is not worthwhile. Let p i be the API set carried by app i, p j be the API set carried by app j, and then the similarity between apps i and j is dened as:</p><formula xml:id="formula_0">S i j = p i \ p j p i [ p j , (<label>1</label></formula><formula xml:id="formula_1">)</formula><p>where \ is the intersection operation of the two sets and [ is the union operator of the two sets. We say that Eq.( <ref type="formula" target="#formula_0">1</ref>) captures the coarse-grained dierence between two apps since it considers only the API method information. </p><formula xml:id="formula_2">k i k i k i m f f f 1 2 ( ) ( ) ( ) k j k j k j n g g g Figure 2: Illustration of ne-grained matching of feature vectors [( f k i ) 1 , ( f k i ) 2 , ..., ( f k i ) m ] and [( k j ) 1 , ( k j ) 2 , ..., ( k j</formula><p>) n ] regarding API method k from two apps i and j.</p><p>If S i j is far below a threshold, this fact suggests that the two apps share very few similar behaviors dened by API methods. erefore, we stop ne-grained comparisons of other feature vectors due to the large behavior gap.</p><p>If S i j is above a certain threshold, this fact indicates that the two apps share many common behaviors dened by API methods. en we study each API method in a ner-grained way, and check how the two apps are aligned regarding each API method. is technique invokes a more thorough treatment and diversity comparisons of feature vectors abstracted from both apps. We name such technique as ne-grained app behavior analysis.</p><p>In the ne-grained app behavior analysis, for the API method k, let the corresponding m feature vectors involving API method k in app i be (</p><formula xml:id="formula_3">f k i ) 1 , ( f k i ) 2 , ..., ( f k i ) m</formula><p>, and the corresponding n feature vectors involving API method k in app j be ( k j ) 1 , ( k j ) 2 , ..., ( k j ) n , where feature vectors ( f k i ) `and ( k j ) `are both d-dimensional feature vectors. We need to nd the best alignment of two groups of feature vectors with respect to API method k. Note that in fact this problem can be abstracted as a maximum matching problem in a bipartite graph, where the rst disjoint set is [(</p><formula xml:id="formula_4">f k i ) 1 , ( f k i ) 2 , ..., ( f k i ) m ], and the second disjoint set is [( k j ) 1 , ( k j ) 2 , ..., ( k j ) n ]</formula><p>, and the edges between the two sets nd the maximum matching. Figure <ref type="figure">2</ref> illustrates the feature vector matching process between two apps. Note that each bit in the feature vector ( f k i ) r is a binary value, where 1 denotes the existence of this feature. erefore, for each pair of feature vectors, we dene its distance W as the number of equivalent bits vs. the number of all feature bits, i.e.,</p><formula xml:id="formula_5">W ((f k i ) r , ( k j ) t ) = #shared feature bits by( f k i ) r and( k j ) t #feature vector length .<label>(2)</label></formula><p>Given the pairwise feature distance, we can refer to a Hungariantype Algorithm <ref type="bibr" target="#b23">[24]</ref> to nd the best matching of two groups of feature vectors and also get the subtle dierence regarding each API method. To this end, we have obtained all pairwise distances among dierent apps via coarse-grained and ne-grained app analyses. Generation of phylogentic tree. We then feed the pairwise distances of mobile apps to the phylogenetic tree generation algorithm, namely, Unweighted Pair Group Method Average algorithm (UPGMA) <ref type="bibr" target="#b24">[25]</ref>. e UPGMA algorithm is a simple boom-up hierarchical clustering algorithm that is most popularly used for creating phenetic trees. UPGMA builds a rooted tree (a.k.a dendrogram) that reects the structure present in the similarity matrix. In each step, the nearest two clusters are merged into the higher-level cluster by averaging all pairwise sample distances. Please refer to the appendix of this paper for examples of phylogentic tree for the AdDisplay family and Droid_Kunfu family.</p><p>ere are two key insights obtained from the phylogentic analysis:</p><p>• Even for the malware samples in the same sub-family, their distances may not be as small as those from dierent subfamilies if only API methods are considered as "features". • ere are many subtle dierences that cannot be captured by API methods alone, such as those dierences in UI types and entry points, which actually provide complementary sources to understand how malware evolve.</p><p>Generation of candidate feature mutation set. Although phylogentic analysis provides similarities between dierent malware samples, in practice, we are more interested in knowing how each feature type evolves in the same family because the evolution analysis provides much information about the feasibility and statistical frequency regarding dierent feature types.</p><p>• Feasibility (F): as long as this feature value corresponding to a particular feature type has been mutated, we view it as feasible. In particular, if mutation of the i-th type feature exists, then F (i) = 1; otherwise, F (i) = 0<ref type="foot" target="#foot_5">7</ref> . • Statistical Frequency (Sf): we count the number of feature mutations given an API method. In particular, if mutation of the i-th type feature appears for n times, then S f</p><formula xml:id="formula_6">(i) = n; otherwise, S f (i) = 0.</formula><p>en we rank dierent feature mutations corresponding to each API method in a principled way, i.e., making a balance between the feasibility and statistical frequency. Let the ranking function R(.) be</p><formula xml:id="formula_7">R(i) = F (i) + (1 )S f (i);<label>(3)</label></formula><p>where = 0.1 in our seing, and i denotes mutation of the i-th type feature. We sort R(.) in the descending order, and select the top x features for mutations <ref type="foot" target="#foot_6">8</ref> as our candidate feature-mutation type, and feed them to the program mutation engine for generating new malware mutants.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Confusion Attack</head><p>We propose Malware Confusion Aack to mutate the malware features from the original feature values to the ones that are less dierentiable for malware detection. is aack complements the Malware Evolution Aack because learning-based malware detectors can be robust to malware evolution <ref type="bibr" target="#b36">[37]</ref>. Such defeating mechanism is based on the observation that malware detectors (based on a classier) could be easily misled by feature omissions and substitutions. In confusion aack, the main idea is to mimic the malware that can evade detection, i.e., confusing the malware detectors by modifying the feature values that can be shared by malware samples and benign apps. In particular, we mutate dierentiating feature values (i.e., feature values that exist in only malware samples) to confusing feature values (i.e., feature values that exist in both malware samples <ref type="foot" target="#foot_7">9</ref> and benign apps) so that malware detection techniques may fail to identify the mutated malware sample based on the features. Because the confusing feature values exist in both a malware sample and a benign app, the malware detector cannot dierentiate the two apps. erefore, the detector may mark both apps in the same category, producing false positives if the label is malware while producing false negatives if it is benign.</p><p>To nd a malware feature that can actually cause confusion, we rst extract RTLD features from all benign apps and malware samples in our dataset (i.e., project all apps to the RTLD vector space). en, we identify a set of (sub-) feature vectors <ref type="foot" target="#foot_8">10</ref> that can be projected from both benign apps and malware samples as the confusion vector set. For each feature vector in the confusion vector set, we count the number of benign apps that can be projected to the vector as the confusion weight of the vector. e rationale is that if more benign apps are projected to the vector, it is harder for the malware detector to mark the apps with this vector as malicious.</p><p>For each malware sample that we try to mutate, we rst check whether its resource features appear in any vectors in the confusion vector set. If a resource feature R appears in a vector V in the confusion vector set, we then try to mutate the original feature vector of R to be the same as the vector V by mutating the contextual features. A resource feature could appear in many vectors in the confusion vector set. In our approach, we try to mutate only top 10 matching vectors ranked by the confusion weight.</p><p>If a resource feature R does not appear in any vectors in the confusion vector set, we leverage a similarity metric to nd another resource feature (in the confusion vector set) R 0 that is most likely to be executed in the same context as R. en we select top 10 vectors (ranked based on confusion weights) matching R 0 as the target vectors for mutation.</p><p>Note that there could be multiple mutated malware samples produced from mutating a single malware sample. If any of the mutated malware samples passes the validation test (Section 5) and evades the malware detection, we claim that malware confusion aack successfully produces a malware variant.</p><p>Similarity-metric computation. e aforementioned aack requires a similarity metric to nd a resource feature that is most likely to be executed in the same context as another resource feature. We compute the similarity metric by the likelihood that two security-sensitive methods (i.e., resource features) reside in the same program basic block. To construct the similarity metric, for each resource feature (i.e., security-sensitive method m) appearing in the confusion vector set, we count its number of occurrences O m in all apps. For each other security-sensitive method n that appears in at least one same basic block as m, we also count the number of the co-occurrences of m and n (in the same basic block) O mn . en the likelyhood that method n is invoked under the same context as method m is computed as a similarity score: S mn = O mn O m ; S mn also indicates the likelihood of m's context to be compatible with n. us, for any security-sensitive method n that does not appear in the confusion vector set, we can check for all security-sensitive methods appearing in the confusion vector set, and among these methods, pick m i that has the highest similarity score S m i n as the method that is most likely to be executed in the same context as n.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">PROGRAM MUTATION</head><p>In this section, we present how MRV mutates existing malware based on synthesized mutation strategies. e mutation process is essentially a program transformation that keeps malicious behaviors (i.e., resource features) while mutating context features. To mutate context features, we develop a program transplantation framework that satises two needs: (a) transplanting a malicious behavior to dierent contexts in the same app; (b) transplanting contextual features from other apps into the existing contexts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Transplantation framework</head><p>Transplantation is the process that transplants the implementation of a feature (i.e., organ) from one app (i.e., donor app) to another app (i.e., host app) <ref type="bibr" target="#b8">[9]</ref>. We broaden the concept of transplantation to components and methods. Transplantation takes four steps: identication of the organ (i.e., code area that needs to be transplanted), extraction of the organ, identication of the insertion point in the host, and adaption of the organ to the host's environment.</p><p>In our transplantation framework, we take dierent strategies based on the type of features that need to be mutated. On one hand, to mutate temporal features or locale features of a malicious behavior (i.e., resource feature), we identify (or construct) a suitable context (that satises the targeted value of temporal features or locale features) in the same app, and then move the malicious behavior to the identied or constructed location. On the other hand, to alter dependency features that usually require sophisticated ways (i.e., specic method sequences) to achieve the desired control, we nd and migrate an existing implementation of such control (i.e., organ) from a donor app to the host app.</p><p>Such two-strategy design aims to simplify the existing problem of soware transplantation. In the rst strategy, the transplantation is intra-app. We simply save and pass the unresolved dependency and contextual information (e.g., values of parameters) in the app via seing the variables and elds global. In the second strategy, although the transplantation is inter-app, we just need to transplant a program slice that contains a few dependencies. Such transplantation is lightweight compared to transplanting the whole implementation of a functional feature in previous work <ref type="bibr" target="#b8">[9]</ref>. Intraapp transplantation is feasible for temporal and locale features because synthesizing a new entrypoint or a new component within an existing Android app results in lile or no impact to other areas of the app. Mutation of dependency features requires inter-app transplantation because synthesizing new dependencies in the app is challenging. e tight coupling of dependencies brings huge impact to other program behaviors and likely causes the mutated app to crash.</p><p>Note that although temporal features and locale features all require the transplantation of malicious behaviors, the donor (i.e., area of code) that requires transplantation is dierent. e related code of a malicious behavior can be separated as the triggering part and the execution part. ese two parts may not be in the same component. For example, in Figure <ref type="figure" target="#fig_9">8</ref>, the malicious behavior of sending text message can be separated as the triggering part in the OnCreate method of the activity component and execution part in the OnStartCommand method of the service component. To mutate temporal features, the donor to be transplanted is the triggering part. To mutate locale features, the donor to be transplanted is the execution part.</p><p>We categorize the transplantation based on the locality into three levels: inter-method, inter-component, and inter-app transplantation, which are illustrated next.  u.tel = getSystemService("phone").getLine1Number();</p><formula xml:id="formula_8">5 if(!isRegisterd(u.androidid)){<label>6</label></formula><p>String text = "android id = " + u.androidid + "; tel =" + u.tel; Listing 1 shows the mutated code related to the SMS-sending behavior in Figure <ref type="figure" target="#fig_2">1</ref>. e mutation strategy consists of two mutations: (i) to mutate the temporal feature from lifecycle event "entering the app" (i.e., onCreate of MainActivity) to UI event "clicking the buon" (i.e., onClick of a buon's event listener), (ii) to mutate the locale feature from Service to Activity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Inter-method transplantation</head><p>Inter-method translation refers to the migration of malicious behaviors (i.e., resource features) from one method to another in the same component. Such transplantation is commonly performed to mutate the temporal features. For example, the mutation of the temporal feature in Listing 1 is inter-method transplantation (Lines 2-5 of the onClick method in Listing 1 are transplanted from Lines 5-8 of the onCreate method in Figure <ref type="figure" target="#fig_2">1b</ref>). In the case of temporal features, the organ that needs to be transplanted is the entry of the malicious behavior and its dependencies.</p><p>First, we locate the entry of the malicious behavior. e entry of the malicious behavior is the rst node on the call-graph path leading to the malicious behavior. For example, startService in Figure <ref type="figure" target="#fig_2">1b</ref> is the entry of the SMS-sending behavior. In order to locate the entry of the malicious behavior, we construct the call graph from the entrypoint of the app (corresponding to the feature to be mutated) to the malicious method call. e entry of the malicious behavior is the rst node on a call path from the entrypoint to the malicious method call (a malicious behavior could have multiple entries).</p><p>en, we extract all dependencies related to the entry. To ensure the entry method to be invoked under the same context (e.g., parameter values) , we perform a backward slicing from the entry method until we reach the entrypoint of the app. For example, in Figure <ref type="figure" target="#fig_9">8</ref>, nodes 3-7 and 8 are all dependencies related to the entry (i.e., node 17, startService). e corresponding statements are the code snippet to be transplanted.</p><p>Next, we create an entrypoint method that can provide temporal features that we need. e entrypoint creation is done by either registering an event handler for system or UI events or creating a lifecycle method in the component. We also edit the manifest le to register receiver components for some of system events. For example, in Listing 1, we create an event listener and an onClick method to provide the temporal feature that the mutation needs.</p><p>Finally, we need to remove the organ from donor methods. If some of statements are dependent on the organ, the removal can cause the donor method to crash. To avoid the side-eects of the removal, we initialize a set of global variables with the local variables in the organ. We then replace the original dependencies on the organ by making the statements dependent on the new set of global variables. Note that in some instances, the host method is invoked aer the donor method, so the set of global variables may not be initialized when the donor method is invoked. So when replacing the dependencies, we add conditional statements to check for null to avoid NullPointerException in the donor method. For example, aer transplanting Lines 5-8 in Figure <ref type="figure" target="#fig_2">1b</ref>, we need to remove Line 7 while keeping other lines because Lines 9-13 are control-dependent on Lines 5-6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Inter-component transplantation</head><p>e inter-component transplantation migrates malicious behaviors from one component to another component in the same app. Intercomponent transplantation can be used to mutate the values of temporal features and locale features. For example, the mutation of the locale feature in Listing 1 is inter-component transplantation (Lines 6-9 in the Activity component in Listing 1 are transplanted from Lines 4-7 in the Service component in Figure <ref type="figure" target="#fig_2">1c</ref>).</p><p>Inter-component transplantation follows the same process as inter-method transplantation except for two dierences. First, in addition to temporal features, inter-component transplantation is also used to mutate locale features. As previously mentioned, when locale features are mutated, the organ to be transplanted is the execution part of the code. To extract such organ, we nd the call-graph node directly linked by the entrypoint of the execution part. Note that the entrypoint of the execution part can be dierent from the entrypoint of the malicious behavior. For example, in Figure <ref type="figure" target="#fig_9">8</ref>, the entrypoint of the execution part is onStart, while the entrypoint of the malicious behavior is onClick. Aer we locate the call-graph node, the rest of the extraction process is the same. e other dierence of inter-component transplantation is when mutating the locale feature while maintaining the temporal feature, the regenerator needs to create ICCs to invoke the host method. To avoid crash caused by unmatching intent messages, the regenerator also adds conditional statements to avoid executing the existing code in the host method when such ICCs occur.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Inter-app transplantation</head><p>e inter-app transplantation is used to migrate the dependency feature a malicious behavior in the donor app to the host app with an identical malicious behavior. e extraction of the dependency feature is dierent from migration of the triggering/execution part of the malicious code. e organ consists of two parts. e rst part is the implementation of the controlling behavior. We rst construct the inter-component control ow graph of the app. en we compute the subgraph containing all paths from the controlling statement (i.e., the statement whose value determines the invocation of the malicious behavior) to the controlled statement (i.e., malicious behavior). Such subgraph essentially represents the controlling behavior. e second part of the organ is the dependencies of the controlling statement. To extract these necessary dependencies, we slice backward from the controlling statement until we reach entrypoints of the app. We then migrate both parts of the organ into the host app.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">PRACTICABILITY OF ATTACKS</head><p>We take two measurements in examining the practicability of the generated aacks and lter out the impractical mutations. (a) We perform impact analysis and targeted testing to check whether the malicious behaviors have been preserved; (b) We perform robustness testing to check whether the robustness of the app has been compromised.</p><p>Impact Analysis. Our impact analysis is based on the insight that the component-based nature of Android constrains the impact of mutations within certain components. We analyze the impact propagation among components by computing the intercomponent communication graph (ICCG). We nd three types of components that can 'constrain' the impact of the mutations within the components themselves. If any mutations are performed in components other than these three types of components, we discard such mutations.</p><p>(i) Isolated Component. We dene an isolated component as a component with no predecessor node or successor node in the ICCG. We can constrain the impact of mutations in an isolated component within the component for two main reasons. On one hand, because an isolated component has no successor node in the ICCG, it is guaranteed that changes in the isolated component will not break any dependencies in other components of the app (assuming no ICC through global states or variables). On the other hand, because an isolated component has no predecessor node in the ICCG, no executions of other components will lead to the isolated component. e lack of incoming edges in the ICCG suggests that the component can be invoked by only the components of other apps or system events through broadcasting intent messages that match intent-lters of the component.</p><p>(ii) Receiving-Only Component. We dene a receiving-only component as a component with no successor node but with at least one predecessor node in the ICCG. Similar to an isolated component, changes in a receiving-only component will not break dependencies of other components. However, mutating a receiving-only component may result in crashes when other components aempt to invoke the mutated receiving-only component. MRV further performs targeted testing to ensure that the malicious behaviors are still preserved within the receiving-only component.</p><p>(iii) Sending-Only Component. We dene a sending-only component as a component with no predecessor but with at least one successor in the ICCG. Note that we exclude the main activity component from this denition because the main activity is essential to a mobile app. A sending-only component can be mutated with manageable impacts for two main reasons. First, there is no danger of crash due to the invocation of a mutated component because sending-only components do not have incoming ICCs. Second, most components serving for the main functionality of the app should not be aected because these components can still be invoked through the main activity of the app. It is worth noting that a mutation in a sending-only component could aect the invocation of another component that has only one single incoming edge (and that edge origins from the sending-only component) in the ICCG. ere are some rare cases of apps without the main activity but with services as entrypoints of the apps, and MRV would compute those services as sending-only components. For those cases, we cannot mutate the sending-only components because these components are the entrypoints of the apps.</p><p>Targeted Testing. We then perform targeted testing to further ensure that the executions are expected within these three types of components. We develop two techniques to assist the targeted testing. First, to simulate the environment where the malicious behaviors are invoked, we create environmental dependencies by changing emulator seings or using mock objects/events. By simulating the environment, we can directly invoke the malicious behaviors to speed up the validation process. Second, to further validate the consistency of malicious behaviors when the triggering conditions are satised, we apply the instrumentation technique to insert logging functions at the locations of malicious method invocations. e logging functions print out detailed information about the variables, functions, and events invoked aer the triggering events. We therefore aain the log les before and aer the mutation under the same context (e.g., the same UI or system events and same inputs). en, we automatically compare the two log les to check the consistency of malicious behaviors.</p><p>Checking robustness of mutated apps. We leverage random testing to check the robustness of a mutated app. In particular, we use Monkey <ref type="bibr" target="#b27">[28]</ref>, a random user-event-stream generator for Android, to generate UI test sequences for mutated apps. Each mutated app is tested against 5,000 events randomly generated by Monkey to ensure that the app does not crash <ref type="foot" target="#foot_9">11</ref> .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">EXPERIMENT</head><p>Malware Detection Dataset. Our subject set consists of a malware dataset and a benign app dataset. Our malware dataset starts with 3,000 malware randomly selected from Genome <ref type="bibr" target="#b43">[44]</ref>, Contagio <ref type="bibr" target="#b2">[3]</ref>, VirusShare <ref type="bibr" target="#b3">[4]</ref>, and Drebin <ref type="bibr" target="#b6">[7]</ref>. We use VirusTotal <ref type="bibr" target="#b4">[5]</ref> to perform sanity checking on the malware dataset (descriptions about signature-based detectors are provided later in this paper). We exclude the apps identied as benign by VirusTotal from the malware dataset. We also exclude any duplicate apps by comparing SHA1 hashes. For benign apps, we download the most popular 120 apps from each category of apps in the Google Play store as of February 2015 and collect 3,240 apps in total. We implement the process of extracting RTLD features using third-party static analyframeworks, including Soot <ref type="bibr" target="#b39">[40]</ref> and FlowDroid <ref type="bibr" target="#b35">[36]</ref>. To isolate and remove the eects of potential limitations of these frameworks, we run feature-extraction analysis on the complete subject set and remove any apps that cause a third-party tool to fail. e ltering gives us a nal analyzable dataset of 1,917 malware and 1,935 benign apps to perform malware detection. Our nal malware dataset consists of 529 malware samples from Genome, 25 samples from Contagio, 287 samples from VirusShare, and 1,076 samples from Drebin dataset. Our nal benign app dataset retains 63 to 96 apps from the original 120 apps in each Google Play category. All runs of our process of extracting RTLD features, the transplantation framework, and learning-based detection tools <ref type="bibr" target="#b42">[43,</ref><ref type="bibr" target="#b6">7]</ref> are performed on a server with Intel(R) Xeon(R) CPU 2.80GH with 38 processors and 80 GB of memory with a timeout of 80 minutes for each app.</p><p>Baseline Approaches. We implement two baseline approaches for comparison with MRV: Random MRV and OCTOPUS. We rst develop a random transformation strategy (Random MRV) to compare against confusion and evolution aacks. Instead of following the evolution rules and similarity metrics to mutate the RTLD features, we randomly mutate RTLD features (i.e., mutate the original feature value to the same-level feature value randomly selected from the available dataset) and transform the malware samples based on such mutation. Note that for Random MRV and evolution MRV, we follow the sequence of temporal feature, locale feature, and dependency feature to apply the transformation at dierent levels (Figure <ref type="figure" target="#fig_1">3</ref>). We choose such sequence because the transplantation goes from inter-method to inter-app as the level increases in this sequence, likely leading to a higher success rate in the program transplantation. We leave the exploration on other possible mutation sequences to our future work.</p><p>We also implement a syntactic app obfuscation tool called OCTOPUS similar to DroidChameleon <ref type="bibr" target="#b32">[33]</ref>. Specically, OCTOPUS contains four levels of obfuscation: bytecode-sequence obfuscation (i.e., repacking, reassembling), identier obfuscation (i.e., renaming), call-sequence obfuscation (i.e., inserting junk code, call reordering, and call indirection), and encryption obfuscation (i.e., string encryption). en, we apply each level of obfuscation in OCTOPUS to each malware sample at a time, and perform testing on the sample le (Section 5) aer each obfuscation. If the testing passes, we apply the next obfuscation to the obfuscated sample (resulted from applying the current obfuscation). If the testing fails, we apply the next obfuscation to the the sample before the current obfuscation (i.e., skipping the current obfuscation). In our experiment, all semantic mutations including Random MRV and evolution/confusion aacks are performed aer the syntactic obfuscation of OCTOPUS.</p><p>Malware detectors. We use a number of learning-based and signature-based malware detectors to evaluate the eectiveness of MRV. For learning-based malware detectors, we adopt App-Context <ref type="bibr" target="#b42">[43]</ref> and Drebin <ref type="bibr" target="#b6">[7]</ref>. AppContext leverages contextual features (e.g., the events and conditions that cause the securitysensitive behaviors to occur) to identify malicious behaviors. In our experiment, AppContext generates around 400,000 behavior rows on our dataset <ref type="bibr">(3,852 apps)</ref>, where each row is a 679-dimensional behavior vector. We conservatively label these behaviors (i.e., marking a behavior as malicious only when the behavior is mentioned by existing malware diagnosis). e labeled behaviors are then used as training data to construct a classier. Drebin uses eight features that reside either in the manifest le or in the disassembled code to capture the malware behaviors. Since Drebin is not open source, we develop our own version of Drebin according to its description <ref type="bibr" target="#b6">[7]</ref>. Although Drebin extracts only eight features from an app, Drebin covers almost every possible combination of feature values resulting in a very large feature vector space. In fact, Drebin produces over 50,000 distinct feature values on our dataset (3852 apps). We perform ten-fold cross-validations to assess the eectiveness of AppContext and Drebin. Figure <ref type="figure" target="#fig_3">4</ref> shows the performance of AppContext and Drebin on all subjects in our dataset.</p><p>For signature-based malware detectors, we leverage the existing anti-virus service provided by VirusTotal <ref type="bibr" target="#b4">[5]</ref>. Specically, we follow the evaluation conducted for Apposcopy <ref type="bibr" target="#b16">[17]</ref> to pick the results of seven well-known anti-virus vendors (i.e., AVG, Symantec, ESET, Dr. Web, Kaspersky, Trend Micro, and McAfee) and label an app as malicious if more than half of the seven suggest that the app is malicious. Following such procedure, only malware labeled as malicious are selected into our malware dataset, and thus all malware in our dataset can be detected by VirusTotal.</p><p>Learning algorithms. In our experiment, we leverage k-Nearest Neighbors (kNN), Decision Tree (DT), and Support Vector Machine (SVM) for malware detection in AppContext and Drebin. For confusion aack, we leverage Random Forest (RF) as the algorithm to train the substitute model <ref type="foot" target="#foot_10">12</ref> . e reason for us to use RF is that we want to use a dierent algorithm from the ones used in malware detection to validate our assumption in transferability <ref type="bibr" target="#b28">[29]</ref>.</p><p>Malware variants generation. We focus on generating malware variants by detected/known malware samples. Among all 1,917 malware samples, 1,739 samples can be detected by all three detection tools that we used. Because many malicious servers of malware are blocked, causing malware to crash even before the mutations, we test the 1,739 malware with 5,000 events randomly generated by Monkey and discard the crashed apps. is step gives us a nal set of 409 valid malware samples to generate malware variants. We then systematically apply OCTOPUS, evolution/confusion aacks, and Random MRV to all 409 valid malware samples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">RESULTS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Defeating existing malware detection</head><p>Table <ref type="table" target="#tab_2">1</ref> shows the malware variants generated through transformation of OCTOPUS, Random MRV, malware evolution aack and confusion aack, and the detection results of VirusTotal on the variants. We also show the result of the full version of MRV (the combination of confusion and evolution aack) in the last column (F). erefore, the full version includes all malware variants produced by confusion aack and evolution aack. e row "Transformable malware" refers to the number of malware samples that can be mutated to a valid malware variant (i.e., of all malware variants generated at dierent levels of an evasive technique, at least one of the malware variants can pass the testing). e row "Generated variants" shows the number of generated variants that pass the impact analysis and testing 13 , and the last three rows 14 show the number of variants that can evade the detection of VirusTotal, AppContext, and Drebin, respectively. As shown in Table <ref type="table" target="#tab_2">1</ref>, although the full MRV generates fewer malware variants than OCTOPUS (696 vs. 1,008), the full MRV produces much more evasive variants than both OCTOPUS and Random MRV for all three tools, especially the learning-based tools. is result indicates that the full MRV is much more eective in producing evasive malware variants than syntactic obfuscation and random transformation.</p><p>We investigate the malware variants produced by the full MRV that can still be detected by anti-virus soware. We nd that most variants of this kind contain extra payloads (e.g., rootkit, another apk). e anti-virus soware can detect them by identifying the extra payloads because our mutation transforms only the main program.</p><p>Although originally Drebin detects more malware samples than AppContext (Figure <ref type="figure" target="#fig_3">4</ref>), Drebin performs worse on the full MRV dataset. Given dierent training malware samples, the full MRV can consistently make over 60% testing variants undetected by Drebin. One potential reason could be that AppContext leverages huge human eorts in labeling each security-sensitive behavior, while Drebin is a fully automatic approach, so overing is likely to occur in Drebin's model.</p><p>We also notice that Random MRV becomes much more eective in evading Drebin than evading AppContext (AppContext detects 13 e variants are generated at each level, and one malware sample may result in multiple malware variants. 14 For AppContext and Drebin, we show the number of variants that cannot be detected by models based on all training algorithms. One noteworthy result is that confusion aack can successfully mutate only 58 malware samples into working malware variants. e reason is that confusion aack usually requires mutating more contextual features than evolution features. We observe in our experimental data that the likelihood of an aack to break the app increases as the number of mutations in the aack increases. Actually, confusion aack synthesizes more than 1,000 variants, and most of the variants are unable to run. However, such conversion rate is already high compared to Random MRV. Random MRV generates more than 320,000 variants, but only 212 of them can run without crashing (and only 2 can evade the detection of App-Context). Such result suggests that considering the feasibility of an aack is essential in generating adversarial malware samples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Eectiveness of attacks at each level</head><p>For evolution aack, we also investigate the eectiveness of mutation at each RTLD level. Table <ref type="table" target="#tab_3">2</ref> shows the detailed detection results of evolution aack at each mutation level.</p><p>Table <ref type="table" target="#tab_3">2</ref> shows some interesting observations. For example, for anti-virus soware and Drebin, the level that produces the largest number of evasive variants is on the locale-feature level, while for AppContext, the level that produces the largest number of evasive variants is on the dependency-feature level. is result indicates that mutating at the locale-feature level is more eective for the detectors using syntactic features (e.g., VirusTotal, Drebin), while mutating at the dependency-feature level is more eective for semantics-based detectors (e.g., AppContext). Such result also indicates that the transformation sequence used in the experiment (i.e., temporal-locale-dependency) might not be the most optimal choice to evade some detectors. Ideally, we can explore dierent combinations of the mutation levels to maximize the number of undetected malware samples for each malware detector.</p><p>We also observe that most of unsuccessful variants produced at the dependency-feature level are due to the fact that a malicious behavior cannot be triggered in the simulated testing environment. e reason of lacking triggering is that by transplanting conditional statements from one component/method to another component/method, the internal logic of the original malware sample is broken. Some of the transplanted conditional statements may be mutually exclusive with the existing conditions in the code, thus making the malicious behavior infeasible to be triggered. As an ongoing eort, we plan to leverage a constraint solver to identify the potential UNSAT conditions when synthesizing mutation strategies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Strengthening the robustness of detection</head><p>We also investigate the possibility of leveraging variants produced by MRV to strengthen the robustness of detection. We propose the following three techniques.</p><p>Adversarial Training. We randomly choose half of our generated malware variants into the training set to train the model, and put the other half of generated variants into the testing set to evaluate the model <ref type="foot" target="#foot_11">15</ref> .</p><p>Variant Detector. We create a new classier called variant detector to detect whether an app is a variant derived from existing malware. e variant detector leverages mutation features that are generated from each pair of apps' RTLD features to reect the feature dierences between the two apps. e number of mutation features is the same as the number of RTLD features. e dierence is that for any RTLD feature that the two apps disagree on, the mutation feature (corresponding to the RTLD feature) is the (bidirectional) mutation between the apps on the RTLD feature. If the pair of apps are derived from same malware, we label the feature vector as "variant". Otherwise, we label the feature vector as "unrelated". Because only a small portion of all pairs of apps would have a "variant" relation, the trained model would be biased to the majority class (i.e., the "unrelated" class). To resolve such issue, we use SMOTE <ref type="bibr" target="#b13">[14]</ref> to make both classes to have an equal number of instances by creating synthetic instances. We then use the trained model on each app labeled (by malware detectors) as benign. For each of the apps, we create pairs to produce mutation features by grouping the app with each malware sample in our training set. en the trained model determines whether the app is a variant of malware in the training set based on the mutation features.</p><p>Weight Bounding. We constrain the weight on a few dominant features to make feature weights more evenly distributed. For example, in the case of SVM, we constrain w in the cost function of SVM:</p><formula xml:id="formula_9">min w 2R d k w k 2 +C N X i max(0, 1 i f (x i ))</formula><p>We observe that adversaries can produce evasive malware variants by applying just a few mutations on dominant features in contrast to many more mutations on other non-dominant features. erefore, to locate dominant features, we select all 44 malware variants produced by fewer than three mutations, and summarize 17 dominant features that enable the production of the variants. To compute the specic range of the weight, we put only 44 malware variants and their original malware samples as malicious samples in the training set, and record the range value of the weight of the 17 dominant features under dierent parameters. We then summarize the constraints in reasonable seings (TPR 0.80 and FPR  0.10) and put the hard constraints in the training phase. Figure <ref type="figure" target="#fig_5">5</ref> presents the detection results of AppContext's malware detection <ref type="foot" target="#foot_12">16</ref> . e red line represents the detection performance on the original dataset, and the purple triangles represent the detection performance on the dataset with malware variants produced by MRV. e other three curves represent the detection performance of  To alleviate the concerns that our proposed defenses are overing to MRV aacks, we also investigate whether the trained models can assist detecting not only malware variants but also unknown malware samples in general. We choose to investigate the malware samples evading the detection of the original AppContext and Drebin (178 and 38 malware samples evade the detection, respectively) <ref type="foot" target="#foot_13">17</ref> . As shown in Table <ref type="table" target="#tab_4">3</ref>, all the protection mechanisms can help detect evasive malware samples, and only eight of the samples can evade the detection of the variant detector technique.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSION</head><p>In this paper, we have proposed practical aacks that mutate malware variants to evade detection. e core idea is to leverage existing malware program structures to change the features that are non-essential to malware but important to malware detectors. To achieve this goal, we have presented the MRV approach including static analysis, phylogenetic analysis, machine learning, and program transplantation to systematically produce new malware mutations. To the best of our knowledge, our work is the rst eort toward solving the malware-evasion problem by altering malware bytecode without any knowledge of the underlying detection models.</p><p>MRV opens up intriguing, valuable venues of applications. First, the proposed aacks can be used to evaluate the robustness of malware detectors and quantify the dierentiability of features. Second, MRV can help discover potential aack surfaces to assist the iterative design of malware detectors. Finally, the program transplantation framework (capable of changing malware features) can be wrien as a malicious payload within malware and such adaptive malware are valuable for the community to investigate.  Each leaf in the graph denotes a malware sample in DroidKungFu family, where leaf nodes (1-4) belong to droidkungfu.ab, <ref type="bibr" target="#b4">(5)</ref><ref type="bibr" target="#b5">(6)</ref><ref type="bibr" target="#b6">(7)</ref><ref type="bibr" target="#b7">(8)</ref><ref type="bibr" target="#b8">(9)</ref> belong to droidkungfu.aw, <ref type="bibr" target="#b9">(10)</ref> belongs to droidkungfu.bb, <ref type="bibr" target="#b10">(11)</ref><ref type="bibr" target="#b11">(12)</ref> belong to droidkungfu.bl, <ref type="bibr" target="#b12">(13)</ref><ref type="bibr" target="#b13">(14)</ref><ref type="bibr" target="#b14">(15)</ref> belong to droidkungfu.c, <ref type="bibr" target="#b15">(16)</ref><ref type="bibr" target="#b16">(17)</ref><ref type="bibr" target="#b17">(18)</ref><ref type="bibr" target="#b18">(19)</ref><ref type="bibr" target="#b19">(20)</ref><ref type="bibr" target="#b20">(21)</ref><ref type="bibr" target="#b21">(22)</ref> belong to droidkungfu.g, <ref type="bibr" target="#b22">(23)</ref><ref type="bibr" target="#b23">(24)</ref><ref type="bibr" target="#b24">(25)</ref><ref type="bibr" target="#b25">(26)</ref><ref type="bibr" target="#b26">(27)</ref><ref type="bibr" target="#b27">(28)</ref>   adswo, <ref type="bibr" target="#b9">(10)</ref><ref type="bibr" target="#b10">(11)</ref><ref type="bibr" target="#b11">(12)</ref><ref type="bibr" target="#b12">(13)</ref><ref type="bibr" target="#b13">(14)</ref><ref type="bibr" target="#b14">(15)</ref><ref type="bibr" target="#b15">(16)</ref><ref type="bibr" target="#b16">(17)</ref><ref type="bibr" target="#b17">(18)</ref><ref type="bibr" target="#b18">(19)</ref><ref type="bibr" target="#b19">(20)</ref><ref type="bibr" target="#b20">(21)</ref><ref type="bibr" target="#b21">(22)</ref><ref type="bibr" target="#b22">(23)</ref> belong to addisplay.airpush, <ref type="bibr" target="#b23">(24)</ref><ref type="bibr" target="#b24">(25)</ref> belong to addisplay.dowgin, <ref type="bibr" target="#b25">(26)</ref> belongs to addisplay.kuguo, <ref type="bibr" target="#b26">(27)</ref><ref type="bibr" target="#b27">(28)</ref> belong to addisplay.waps, <ref type="bibr" target="#b28">(29)</ref><ref type="bibr" target="#b29">(30)</ref><ref type="bibr" target="#b30">(31)</ref><ref type="bibr" target="#b31">(32)</ref> belong to addisplay.wooboo.</p><p>Locale features. We observe that locale features oen evolve with temporal features. e reason is that when malware authors mutate an entrypoint of a malicious behavior from one component to another, instead of adding another ICC from the new component to invoke the code in the original component, the malware authors tend to directly migrate the code to the new component. Most of such evolutions occur for malicious behaviors with fewer (e.g., one or two) entrypoints, and the corresponding security-sensitive methods are usually directly invoked in the entrypoint methods. We nd that the most frequent change of locale features is migration from an activity or receiver component to a service component. However, we observe fewer evolutions the other way around (i.e., evolutions from a service component to an activity or receiver  . Such paern is due to that malicious behaviors in service components tend to be continuous (e.g., downloading, monitoring) while activity or receiver components cannot support such continuity (unless starting another thread).</p><p>Dependency features. e most common evolution for dependency features is adding controls of a security-sensitive method (i.e., a resource feature) through ICCs. Such evolution can confuse malware detection techniques because the generated program dependence graphs can reect only the control dependencies between a malicious behavior and values stored in Intent messages (of ICCs). Connecting the control dependencies between the malicious behavior and the original value (e.g., the current system time) requires precise analysis of ICC. However, the current use of such analysis is absent or limited. e other frequent evolution is making malicious behaviors dependent on aributes of external entities (including Internet connection and telephony manager). e Internet connection reects the command &amp; control behaviors through network servers. e package manager and telephony manager suggest that malware control malicious behaviors based on the installed apps on the phone and the IMEI number or network server of the phone. Such evolution does not aim to evade detection, but to update the malicious logic of the malware.</p><p>Composite Evolution. We have observed a number of interesting cases that combine the mutations of all three types of features. One representative case is a malicious app trying to obtain NetworkInfo on the phone to launch malicious behaviors based on dierent types of network connection. e original malware sample leverages the system event android.net.conn. CONNECTIVITY_CHANGE to get notied when the network connection changes so the malware sample can obtain the NetworkInfo from the system Intent message for new network connections. To evade detection, the malware sample evolves to leverage the system event android.intent.action.USER_PRESENT. Such event gets the malware sample notied when a user is present aer unlocking the screen. en the malware sample starts a service and uses a timer in the service to repetitively invoke getNetworkInfo every 20 minutes. In this way, the malware author mutates the original value of the temporal feature (CONNECTIVITY_CHANGE) to a value (USER_PRESENT) completely unrelated to network connection. Meanwhile, the locale feature value is mutated from receiver to service, and the control dependency with a timer is also added. Malware variants produced by MRV can be especially helpful in detecting such sophisticated evolution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX B IDEAS BEHIND OUR ATTACKS</head><p>An illustration. e goal of malware detection is to classify an app as "malware" or "benign". In MRV, we achieve the goal by mutating the feature vector V i of a particular malicious app i (e.g., changing feature values ha, b, ci of malicious app M 1 in Table <ref type="table" target="#tab_7">4</ref>). In order to evade detection, we can mutate feature values V i in three strategies:</p><p>(i) look-alike-benign-app: mutating V i to be exactly the same as the feature vector of a benign app, e.g., ha, b, c 0 i of B 1 in Table <ref type="table" target="#tab_7">4</ref>;</p><p>(ii) look-alike-misclassied-malware: mutating V i to be exactly the same as the feature vector of a malware being misclassied as benign, e.g., ha, b, c 0 i of M 2 ;</p><p>(iii) look-alike-unclassiable-app: mutating V i to the feature vector of an app that the malware detector cannot draw any classication conclusion (either malware or benign), e.g., ha 0 , b 0 , c 0 i of M .</p><p>Malware Evolution Aack: we can follow the feature mutations from M 1 to M 2 (i.e., c ! c 0 in f 3 ) to derive a new malware variant M from M 3 (shown in Table <ref type="table" target="#tab_7">4</ref>). Such aack follows the idea of the aforementioned strategy of look-alike-unclassiable-app (iii), but as the aack is derived from existing mutations, the likelihood of the mutations to break the malicious behaviors decreases (as conrmed by our empirical evaluation). Note that we do not come up with any aack that conforms to the aforementioned strategy of look-alike-benign-app (i). e main reason is that, based on our empirical results, using features (e.g., program structure) that exist in only benign apps has a high likelihood to break malicious behaviors and eliminate the maliciousness.</p><p>Malware Confusion Aack: In Table <ref type="table" target="#tab_7">4</ref>, malware sample M 2 shares the same feature vector with benign app B 1 , and the malware detector cannot tell the dierence and therefore marks both apps in the same category (producing false positives if the label is malware while producing false negatives if it is benign). is aack follows the idea of the strategy look-alike-misclassied-malware (ii) but does not rely on the detection result from any particular detection algorithm. </p><formula xml:id="formula_10">Ground-truth f 1 f 2 f 3 Detection result M 1 Malware a b c Malware M 2 Malware a b c 0 Benign B 1 Benign a b c 0 Benign B 3 Malware a 0 b 0 c Malware M Malware a 0 b 0 c 0 Benign</formula><p>Columns f 1 to f 3 are three feature columns.</p><p>Attacking Weak Spots of Malware Detection. MRV leverages two fundamental limitations of malware detection: dierentiability of selected features and robustness of detection model. To beer illustrate the limitations, we model the vector space of features used by any given malware-detection technique as V (shown in the Venn diagram in Figure <ref type="figure" target="#fig_10">9</ref>). e dierentiability of selected features can be represented by the intersection of the vector space (denoted as B) for the existing benign apps and that (denoted as M) of the existing malware. In an ideal case, if the selected features are perfect (i.e., all dierences between benign apps and malware are captured by features), no malware and benign apps should be projected to the same feature space, i.e., B \ M = ?. Such perfect feature set, however, is dicult or even impossible to get in practice. For example, to detect a malware sample that loads a malicious payload at runtime, a malware detector could use the name of the payload le as a feature for the detection. Unfortunately, the name of the payload le can be easily changed to a common le name used by benign apps to evade the detection, therefore resulting in false negatives. If the detector removes such a feature in ghting malware, the detector produces false positives by incorrectly catching benign apps that may have behaviors of dynamic code loading. In either way, the selected feature set is imperfect to dierentiate such malware and benign apps. Feature evolution aack is based on the insight that reapplying the feature mutations in malware evolution can create new malware variants that may evade detection (i.e., the feature vectors of the variants fall into the area of M 0 \ D). Feature evolution aack mutates RTLD feature values iteratively at each level (following the sequence of temporal feature, locale feature, and dependency feature). e robustness of a detection model can be represented by the dierence between the feature vectors (denoted as M 0 ) of all potential malware and the feature vectors (denoted as D) that can be detected by the detection model 19 . Such dierence can be denoted as M 0 \ D. A perfect detection model should detect all possible malicious feature vectors (i.e., M 0 ). In practice, detection models are limited to detecting only existing malware because it is hard to predict the form of potential malware (including zero-day aacks). In this work, we argue that a robust malware-detection model should aim to detect new malware variants produced through known mutations. Such mutations may employ not only syntactic and semantic obfuscation techniques, but also feature mutations based on analyzing the evolutions of malware families.</p><p>Feature confusion aack is based on the insight that malware detection usually performs poorly in dierentiating malware and benign apps with the same feature vector. As discussed earlier, if we simply mutate malware feature vectors to benign feature vectors (i.e., feature vectors in space B), such mutation would 19 We safely assume that for a reasonable malware-detection model, D ✓ M 0 . A reasonable malware-detection model produces false positives on a benign app only because the feature vector of the benign app is the same as some malware samples. generally break or weaken the malicious behaviors (i.e., turning malware into benign apps). So, our design decision is making malware with unique malicious feature vectors (i.e., M \ (B \ M )) to possess the feature vectors same as benign apps (i.e., B \ M). Because some apps already possess such feature vectors, we could leverage the program transplantation technique to transplant the existing implementation to the host malware. Using program transplantation greatly decreases the likelihood of breaking the original malicious behaviors in the host malware.</p><p>reat Model &amp; Use Cases. We assume that an aacker has only black-box access to the malware detector under consideration. Under such assumption, the aacker can feed any malware sample as the input to the detector and know whether the sample can be detected or not, but the aacker has no internal knowledge (e.g., detection model, signature, feature set, condence score) about the detector. e aacker is capable of manipulating the malware's binary code, but has no access to the malware's source code. We assume that the aacker has access to the existing malware samples (i.e., samples that are correctly detected by the malware detector), and the goal of the aacker is to create malware variants with the same malicious behaviors, but can evade the detection.</p><p>Although we present our techniques as aacks to malware detection, the techniques can also be used in assisting the assessment or testing of existing malware-detection techniques, to enable the iterative design of a detection system. e main idea is to launch feature evolution aack and feature confusion aack on each revision of the detection system, so that security analysts can further prune their selection of features in the next revision. Feature evolution aack can be used to evaluate the robustness of a detection model. e more robust a detector model is (i.e., the larger D is), the more dicult for a mutated malware to evade the detection (i.e., the smaller M 0 \ D can be). Feature confusion aack can be used to evaluate the dierentiability of selected features. e more dierentiable a feature is, the less the opportunity is for a malware sample to confuse the detector (i.e., smaller B \ M is desirable).</p><p>Discussion. Limitations of app testing. In testing processes for transformed apps, the testing checks only two main things: whether the app crashes or not and whether the malicious statements get invoked or not. Due to the unavailability of systematic functional test cases in regression tests, the testing cannot cover all the cases. Such issue could be addressed by manually creating regression tests for the malicious behaviors. Additionally, it is infeasible to test whether malware become less protable or easier to be detected by manual inspection.</p><p>Adware threat in the experiment. In our experiment, we view one family of adware (i.e., AdsDisplay) as a malware family due to the fact that both malware and adware are "unwanted soware", and they both dier signicantly from benign apps according to a recent study <ref type="bibr" target="#b34">[35]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Illustration of mutant construction in evolution MRV. Key steps: (1) mutation-strategy synthesis; (2) program mutation/feature mutation; (3) program testing.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Listing 1 :</head><label>1</label><figDesc>Code snippet of mutated DougaLeaker malware 1 public void onClick(View v) { 2 User u = (User) getApplication(); 3 u.androidid = Seings.Secure.getString(getContentResolver(), " android id");</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>4</head><label>4</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Detection results of AppContext vs. Drebin on the original dataset (ORI) and dataset with adversarial samples (MRV) produced by MRV</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Detection results of AppContext (SVM) when dierent defense mechanisms are applied</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Phylogentic tree generated for the DroidKungFu family.Each leaf in the graph denotes a malware sample in DroidKungFu family, where leaf nodes (1-4) belong to droidkungfu.ab,<ref type="bibr" target="#b4">(5)</ref><ref type="bibr" target="#b5">(6)</ref><ref type="bibr" target="#b6">(7)</ref><ref type="bibr" target="#b7">(8)</ref><ref type="bibr" target="#b8">(9)</ref> belong to droidkungfu.aw,<ref type="bibr" target="#b9">(10)</ref> belongs to droidkungfu.bb,(11- 12)  belong to droidkungfu.bl,<ref type="bibr" target="#b12">(13)</ref><ref type="bibr" target="#b13">(14)</ref><ref type="bibr" target="#b14">(15)</ref> belong to droidkungfu.c,<ref type="bibr" target="#b15">(16)</ref><ref type="bibr" target="#b16">(17)</ref><ref type="bibr" target="#b17">(18)</ref><ref type="bibr" target="#b18">(19)</ref><ref type="bibr" target="#b19">(20)</ref><ref type="bibr" target="#b20">(21)</ref><ref type="bibr" target="#b21">(22)</ref> belong to droidkungfu.g,<ref type="bibr" target="#b22">(23)</ref><ref type="bibr" target="#b23">(24)</ref><ref type="bibr" target="#b24">(25)</ref><ref type="bibr" target="#b25">(26)</ref><ref type="bibr" target="#b26">(27)</ref><ref type="bibr" target="#b27">(28)</ref> belong to droidkungfu. m.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Phylogentic tree generated for the addisplay family. Each leaf in the graph denotes a malware sample in the addisplay family, where leaf nodes (1-9) belong to addisplay. adswo,<ref type="bibr" target="#b9">(10)</ref><ref type="bibr" target="#b10">(11)</ref><ref type="bibr" target="#b11">(12)</ref><ref type="bibr" target="#b12">(13)</ref><ref type="bibr" target="#b13">(14)</ref><ref type="bibr" target="#b14">(15)</ref><ref type="bibr" target="#b15">(16)</ref><ref type="bibr" target="#b16">(17)</ref><ref type="bibr" target="#b17">(18)</ref><ref type="bibr" target="#b18">(19)</ref><ref type="bibr" target="#b19">(20)</ref><ref type="bibr" target="#b20">(21)</ref><ref type="bibr" target="#b21">(22)</ref><ref type="bibr" target="#b22">(23)</ref> belong to addisplay.airpush,<ref type="bibr" target="#b23">(24)</ref><ref type="bibr" target="#b24">(25)</ref> belong to addisplay.dowgin,<ref type="bibr" target="#b25">(26)</ref> belongs to addisplay.kuguo,<ref type="bibr" target="#b26">(27)</ref><ref type="bibr" target="#b27">(28)</ref> belong to addisplay.waps,<ref type="bibr" target="#b28">(29)</ref><ref type="bibr" target="#b29">(30)</ref><ref type="bibr" target="#b30">(31)</ref><ref type="bibr" target="#b31">(32)</ref> belong to addisplay.wooboo.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Inter-Procedural Control Flow Graph of DougaLeaker component). Such paern is due to that malicious behaviors in service components tend to be continuous (e.g., downloading, monitoring) while activity or receiver components cannot support such continuity (unless starting another thread).Dependency features. e most common evolution for dependency features is adding controls of a security-sensitive method (i.e., a resource feature) through ICCs. Such evolution can confuse malware detection techniques because the generated program dependence graphs can reect only the control dependencies between a malicious behavior and values stored in Intent messages (of ICCs). Connecting the control dependencies between the malicious behavior and the original value (e.g., the current system time) requires precise analysis of ICC. However, the current use of such analysis is absent or limited. e other frequent evolution is making malicious behaviors dependent on aributes of external entities (including Internet connection and telephony manager). e Internet connection reects the command &amp; control behaviors through network servers. e package manager and telephony manager suggest that malware control malicious behaviors based on the installed apps on the phone and the IMEI number or network server of the phone. Such evolution does not aim to evade detection, but to update the malicious logic of the malware.Composite Evolution. We have observed a number of interesting cases that combine the mutations of all three types of features. One representative case is a malicious app trying to obtain NetworkInfo on the phone to launch malicious behaviors based on dierent types of network connection. e original malware sample leverages the system event android.net.conn. CONNECTIVITY_CHANGE to get notied when the network connection changes so the malware sample can obtain the NetworkInfo from the system Intent message for new network connections. To evade detection, the malware sample evolves to leverage the system event android.intent.action.USER_PRESENT. Such event gets the malware sample notied when a user is present aer unlocking the screen. en the malware sample starts a service and uses a timer in the service to repetitively invoke getNetworkInfo every 20 minutes. In this way, the malware author mutates the original value of the temporal feature (CONNECTIVITY_CHANGE) to a value (USER_PRESENT) completely unrelated to network connection. Meanwhile, the locale feature value is mutated from receiver to service, and the control dependency with a timer is also added. Malware variants produced by MRV can be especially helpful in detecting such sophisticated evolution.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 9 :</head><label>9</label><figDesc>Figure9: A feature vector space V , the feature vectors of existing benign apps B, the feature vectors of existing malware M , the feature vectors that can be detected by detection model D, the feature vectors of all potential malware M 0 , and their relationships.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: e detailed (ind, apk name, and its corresponding subfamily) items in the AdDisplay family phylogenetic analysis.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: e detailed (ind, apk name, and its corresponding subfamily) items in the DroidKungFu family phylogenetic analysis.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 :</head><label>1</label><figDesc>Number of transformable malware samples and generated malware variants by dierent evasive techniques and the detection results</figDesc><table><row><cell></cell><cell>O.</cell><cell>R.</cell><cell>E.</cell><cell>C.</cell><cell>F.</cell></row><row><cell>Transformable malware</cell><cell>409</cell><cell>121</cell><cell>314</cell><cell>58</cell><cell>341</cell></row><row><cell>Generated variants</cell><cell>1008</cell><cell>212</cell><cell>638</cell><cell>58</cell><cell>696</cell></row><row><cell>Variants undetected by VirusTotal</cell><cell>125</cell><cell>113</cell><cell>512</cell><cell>53</cell><cell>565</cell></row><row><cell>Variants Undetected by AppContext</cell><cell>0</cell><cell>2</cell><cell>97</cell><cell>56</cell><cell>153</cell></row><row><cell>Variants Undetected by Drebin</cell><cell>0</cell><cell>111</cell><cell>460</cell><cell>58</cell><cell>518</cell></row><row><cell cols="6">O. = OCTOPUS, R. = Random MRV, E. = Malware Evolution Attack, C. = Malware Confusion</cell></row><row><cell>Attack, F. = Full Version of MRV</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 :</head><label>2</label><figDesc>Details of Evolution Attack at each level (undetected vs. Random MRV). e reason lies in the large number of syntactic features used in Drebin. Such result indicates that although Random MRV is eective in befuddling the syntactic-based detection (e.g., anti-virus soware), it is not eective in evading semantics-based detection techniques.</figDesc><table><row><cell>all)</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Results</cell><cell>T.</cell><cell>L.</cell><cell>D.</cell></row><row><cell>Robust variants</cell><cell>178</cell><cell>316</cell><cell>144</cell></row><row><cell>Undetected by VirusTotal</cell><cell>77/178</cell><cell>296/316</cell><cell>139/144</cell></row><row><cell>Undetected by AppContext</cell><cell>21/178</cell><cell>15/316</cell><cell>61/144</cell></row><row><cell>Undetected by Drebin</cell><cell>73/178</cell><cell>272/316</cell><cell>115/144</cell></row><row><cell cols="3">T. = Temporal Features L. = Locale Features D. = Dependency Features</cell><cell></cell></row><row><cell cols="2">almost all variants produced by</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3 :</head><label>3</label><figDesc>Number of malware samples evading detection of AppContext or Drebin under dierent algorithms Variant detection, WB. = Weight bounding three proposed protection techniques on the dataset with malware variants. As shown in Figure 5, all three proposed techniques can alleviate the MRV aacks. e variant detector technique can reach almost the same performance as the original malware detector (while being more secure/robust to malware variants).</figDesc><table><row><cell>Detector</cell><cell>ORI.</cell><cell>AT.</cell><cell>VD.</cell><cell>WB.</cell></row><row><cell>AppContext</cell><cell>178</cell><cell>125</cell><cell>106</cell><cell>152</cell></row><row><cell>Drebin</cell><cell>38</cell><cell>19</cell><cell>8</cell><cell>23</cell></row><row><cell cols="3">ORI. = Original detection, AT. = Adversarial training</cell><cell></cell><cell></cell></row><row><cell>VD. =</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 4 :</head><label>4</label><figDesc>Examples of feature values for malware detection</figDesc><table><row><cell>App</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Malware detectors use feature sets for signatures or detection models.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>In our mutation strategies, the feature paerns are extracted from malware evolution histories and existing evasive malware.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>Such defense mechanism forces the increasing number of mutations to cra adver- sarial samples; therefore, the aack will likely become infeasible (our empirical result suggests that the number of working adversarial samples dramatically decreases as the number of mutations increases).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>RTLD is short for Resource, Temporal, Locale, and Dependency.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_4"><p>We investigate malware evolution by family due to the fact that most of new malware variants come from within existing families. A recent study<ref type="bibr" target="#b36">[37]</ref> suggests that the number of malware families has remained relatively constant over the years whereas the number of variants within a family has been growing rapidly.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_5"><p>Here we take a very conservative way, because we are not sure whether this type of feature mutation works in practice.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_6"><p>Empirically we iteratively increase x till 10; as indicated in our experiment, the program under mutation oen breaks aer more than 10 features are mutated.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_7"><p>Malware samples here refer to other malware samples (likely to be evasive malware samples) instead of the one to be mutated.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_8"><p>If a benign app and a malware sample share over 50% of their feature values, we select their common subset of feature vectors into the confusion vector set.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11" xml:id="foot_9"><p>Due to the limited coverage of random testing, a mutated app that passes the testing step can still be invalid. As future work, we plan to incorporate intelligent testing techniques<ref type="bibr" target="#b41">[42,</ref><ref type="bibr" target="#b19">20]</ref> for MRV.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="12" xml:id="foot_10"><p>We optimize the parameter for SVM and DT (we use C4.5 DT<ref type="bibr" target="#b31">[32]</ref>) using CVParameterSelection of Weka<ref type="bibr" target="#b5">[6]</ref>. For RF and kNN, we tune the parameters by testing on a sample set (100 malware and 100 benign apps). We set the benign/malware ratio in each subset (of an individual tree) for RF as 3 and K value for kNN as 7.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="15" xml:id="foot_11"><p>We perform ten-fold cross-validation in our experiment to report TP and FP.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="16" xml:id="foot_12"><p>We present only SVM-based model here due to the limited space. Other learn- ing algorithms present similar paerns as SVM. We leave investigation of specic dierences across models as future work.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="17" xml:id="foot_13"><p>All the numbers are counted when the false positive is within 0.06.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="18" xml:id="foot_14"><p>Such evolution is due to that the emerging Adblock apps (e.g., Airpush Detector<ref type="bibr" target="#b0">[1]</ref>, Airpush Opt-out<ref type="bibr" target="#b1">[2]</ref>) force Adware authors to implement malicious behaviors by themselves instead of leveraging third-party libraries such as Airpush.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>is work is supported in part by NSF grants CNS-1223967, CNS-1513939, CNS-1330491, CNS-1434582, CNS-1564274, and CCF-1409423.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX A MALWARE EVOLUTIONS</head><p>To further assist the improvement of existing detection, we summarize the evolution paerns of malware for contextual features (Section 3). We infer malware evolution paerns from phylogenetic trees. Figure <ref type="figure">7</ref> demonstrates how 32 samples are evolved in the AdDisplay family, and Figure <ref type="figure">6</ref> demonstrates how 28 samples are evolved in the Droid_Kunfu family, where the number labeled in the boom of each phylogenetic tree denotes the distance between two nodes. A node in a phylogenetic tree could be a leaf node that denotes a malware sample, and also could be an internal node that denotes a cluster grouped from its children nodes. Figures <ref type="figure">10</ref> and<ref type="figure">11</ref> show detailed introduction of each malware sample in the families.</p><p>Temporal features. Among all temporal features, lifecycle events are most likely to evolve. Such evolution can be intracomponent (i.e., the entrypoint is mutated to another method in the same Android component) or inter-component (i.e., the entrypoint is mutated to a method in a dierent Android component). For inter-component evolution, the corresponding ICCs have been added to incorporate the evolution.</p><p>Malware also frequently evolve temporal features of malicious behaviors triggered by system events. Except some system events commonly observed in benign apps (e.g., android.intent.action .PACKAGE_ADDED, android.intent.action.BOOT_COMPLETED), most temporal features such as system events have evolved to UI events or lifecycle events. e behaviors triggered by third-party ad-network intents (e.g., com.airpush.android. PushServiceStart) also evolve 18 .</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Airpush</forename><surname>Detector</surname></persName>
		</author>
		<ptr target="hps://goo.gl/QVn82" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title/>
		<ptr target="hp://www.airpush.com/optout/" />
	</analytic>
	<monogr>
		<title level="j">Airpush Opt-out</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName><surname>Contagio</surname></persName>
		</author>
		<ptr target="hp://contagiominidump.blogspot.com/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName><surname>Virusshare</surname></persName>
		</author>
		<ptr target="hp://virusshare.com/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName><surname>Virustotal</surname></persName>
		</author>
		<ptr target="hps://www.virustotal.com/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Weka 3: Data mining soware in Java</title>
		<ptr target="hp://www.cs.waikato.ac.nz/ml/weka/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">DREBIN: eective and explainable detection of Android malware in your pocket</title>
		<author>
			<persName><forename type="first">D</forename><surname>Arp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Spreitzenbarth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hubner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Gascon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Rieck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NDSS</title>
		<meeting>NDSS</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">PScout: Analyzing the Android permission specication</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">W Y</forename><surname>Au</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">F</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CCS</title>
		<meeting>CCS</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="217" to="228" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Automated soware transplantation</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">T</forename><surname>Barr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Marginean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Petke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ISSTA</title>
		<meeting>ISSTA</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Bioinformatics: A Practical Guide to the Analysis of Genes and Proteins</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Baxevanis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">F F</forename><surname>Ouellee</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>John WileySons</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Evasion aacks against machine learning at test time</title>
		<author>
			<persName><forename type="first">B</forename><surname>Biggio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Corona</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Maiorca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Šrndić</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Laskov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Giacinto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Roli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. KDD</title>
		<meeting>KDD</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="387" to="402" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Security evaluation of paern classiers under aack</title>
		<author>
			<persName><forename type="first">B</forename><surname>Biggio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Fumera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Roli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. TKDE</title>
		<imprint>
			<biblScope unit="page" from="984" to="996" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Evaluation of classiers: Practical considerations for security applications</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Cárdenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Baras</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. AAAI Workshop Evaluation Methods for Machine Learning</title>
		<meeting>AAAI Workshop Evaluation Methods for Machine Learning</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="777" to="780" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Smote: Synthetic minority over-sampling technique</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">V</forename><surname>Chawla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">W</forename><surname>Bowyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">O</forename><surname>Hall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">P</forename><surname>Kegelmeyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of articial intelligence research</title>
		<imprint>
			<biblScope unit="page" from="321" to="357" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Finding unknown malice in 10 seconds: Mass veing for new threats at the Google-play scale</title>
		<author>
			<persName><forename type="first">K</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX Security</title>
		<meeting>USENIX Security</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="659" to="674" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Yes, machine learning can be more secure! a case study on Android malware detection</title>
		<author>
			<persName><forename type="first">A</forename><surname>Demontis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Melis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Biggio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Maiorca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Arp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Rieck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Corona</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Giacinto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Roli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. TDSC</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Apposcopy: Semantics-based detection of Android malware through static analysis</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Dillig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. FSE</title>
		<meeting>FSE</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="576" to="587" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Generative adversarial nets</title>
		<author>
			<persName><forename type="first">I</forename><surname>Goodfellow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pouget-Abadie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mirza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Warde-Farley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ozair</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Courville</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NIPS</title>
		<meeting>NIPS</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="2672" to="2680" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Adversarial perturbations against deep neural networks for malware classication</title>
		<author>
			<persName><forename type="first">K</forename><surname>Grosse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Papernot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Manoharan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Backes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mcdaniel</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1606.04435</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">PUMA: Programmable UI-automation for large-scale analysis of mobile apps</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Nath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Govindan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Mobisys</title>
		<meeting>Mobisys</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="204" to="217" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Generating adversarial malware examples for black-box aacks based on GAN</title>
		<author>
			<persName><forename type="first">W</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Tan</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1702.05983</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Adversarial machine learning</title>
		<author>
			<persName><forename type="first">L</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Joseph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">I</forename><surname>Rubinstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tygar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. AISec</title>
		<meeting>AISec</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Discriminant malware distance learning on structural information for automated malware classication</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Yan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KDD</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1357" to="1365" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">e hungarian method for the assignment problem</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">W</forename><surname>Kuhn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Yaw</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Naval Research Logistics arterly</title>
		<imprint>
			<biblScope unit="page" from="83" to="97" />
			<date type="published" when="1955">1955</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Legendre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Legendre</surname></persName>
		</author>
		<title level="m">Numerical Ecology: Developments in Environmental Modelling</title>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Delving into transferable adversarial examples and black-box aacks</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICLR</title>
		<meeting>ICLR</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<ptr target="hps://www.mcafee.com/us/resources/reports/rp-mobile-threat-report-2017.pdf" />
		<title level="m">Montrojans, ghosts, and more mean bumps ahead for mobile and connected thingskey</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title/>
		<author>
			<persName><surname>Monkey</surname></persName>
		</author>
		<ptr target="hp://developer.Android.com/tools/help/monkey.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Transferability in machine learning: from phenomena to black-box aacks using adversarial samples</title>
		<author>
			<persName><forename type="first">N</forename><surname>Papernot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mcdaniel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Goodfellow</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1605.07277</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Practical black-box aacks against deep learning systems using adversarial examples</title>
		<author>
			<persName><forename type="first">N</forename><surname>Papernot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mcdaniel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Goodfellow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">B</forename><surname>Celik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Swami</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ASIACCS</title>
		<meeting>ASIACCS</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">e limitations of deep learning in adversarial seings</title>
		<author>
			<persName><forename type="first">N</forename><surname>Papernot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mcdaniel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fredrikson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">B</forename><surname>Celik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Swami</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Euro S&amp;P</title>
		<meeting>Euro S&amp;P</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="372" to="387" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Induction of decision trees</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Inlan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Machine learning</title>
		<imprint>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">DroidChameleon: Evaluating Android antimalware against transformation aacks</title>
		<author>
			<persName><forename type="first">V</forename><surname>Rastogi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Jiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ASIACCS</title>
		<meeting>ASIACCS</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="329" to="334" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Practical evasion of a learning-based classier: A case study</title>
		<author>
			<persName><forename type="first">N</forename><surname>Rndic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Laskov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE S &amp; P</title>
		<meeting>IEEE S &amp; P</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="197" to="211" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Experimental study with real-world data for Android app security analysis using machine learning</title>
		<author>
			<persName><forename type="first">S</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Deloach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Herndon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Caragea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Ou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">P</forename><surname>Ranganath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Guevara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACSAC</title>
		<meeting>ACSAC</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="81" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Automatic error elimination by horizontal code transfer across multiple applications</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sidiroglou-Douskos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Lahtinen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. PLDI</title>
		<meeting>PLDI</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="43" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Tracking concept dri in malware families</title>
		<author>
			<persName><forename type="first">A</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Walenstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lakhotia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. AISec</title>
		<meeting>AISec</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="81" to="92" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">When a tree falls: Using diversity in ensemble classiers to identify evasion in malware detectors</title>
		<author>
			<persName><forename type="first">C</forename><surname>Smutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Stavrou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NDSS</title>
		<meeting>NDSS</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Szegedy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zaremba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bruna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Erhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Goodfellow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fergus</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1312.6199</idno>
		<title level="m">Intriguing properties of neural networks</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Soot: A Java bytecode optimization framework</title>
		<author>
			<persName><forename type="first">R</forename><surname>Vallée-Rai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Co</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Gagnon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Hendren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Sundaresan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CASON</title>
		<meeting>CASON</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Automatically evading classiers</title>
		<author>
			<persName><forename type="first">W</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Qi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Evans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NDSS</title>
		<meeting>NDSS</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">A grey-box approach for automated GUI-model generation of mobile applications</title>
		<author>
			<persName><forename type="first">W</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Prasad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Xie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. FASE</title>
		<meeting>FASE</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="250" to="265" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">AppContext: Dierentiating malicious and benign mobile app behaviors using context</title>
		<author>
			<persName><forename type="first">W</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Andow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Enck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICSE</title>
		<meeting>ICSE</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="303" to="313" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">8c32a989e1f5eed4ef6ed4a0dc3fd6ae -&gt; AdDisplay.AirPush.G 14: 1dadc9e17be6aaaeefd070d4ea827a53 -&gt; AdDisplay.AirPush.G 15: 832eeac91b6e0a334417f986b79b4229 -&gt; AdDisplay.AirPush.G 16: ad8f0ea0860f71ac6e450333f3b13cd8 -&gt; AdDisplay.AirPush.G 17: dea28ed03914b4009401f4ef82613dd7 -&gt; AdDisplay.AirPush.G 18: 0cd5a09a403c2edf29b4add947b95d2a -&gt; AdDisplay</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Jiang</surname></persName>
		</author>
		<idno>AdDisplay.Wooboo.A 30: 885d67ba8bcafc92090284baad55ac02 -&gt; AdDisplay.Wooboo.C 31: 4c944782253e2c3227391722d066a151</idno>
	</analytic>
	<monogr>
		<title level="m">dd0b9a43518de68d5591f74fa2ac -&gt; AdDisplay.AirPush.K 22: f11942551c4eaf67c6a73aabaa5dbf5f -&gt; AdDisplay.AirPush.K 23: 9232049eb7072b5b610a328673bedb01 -&gt; AdDisplay.AirPush.K 24: d9da808860b27973c80f39e820b6e7f5 -&gt; AdDisplay</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">4</biblScope>
		</imprint>
	</monogr>
	<note>C. d3b9cdf559443db567113585b40eef459307c94 -&gt; DroidKungFu.G 17: 537db43883f55b112a4206fb. a221e5bf872c5e593de22bb9a6 -&gt; DroidKungFu.G 19: 92888228c556f94b8be3d8bf747a2427481f32d1 -&gt; DroidKungFu.G 20: 0657a70a655dc439b4222c8161b1f5a9667e84e3 -&gt; DroidKungFu.G 21: 8c841b25102569be4a1a5f407108482473fad43e -&gt; DroidKungFu.G 22: e3f0de8ad898f0b5a7c9d327ffc266635b8af32b -&gt; DroidKungFu.G 23: 03ddb783e7ab88c838b1888b38eba992 -&gt; DroidKungFu.M.Gen 24: 00b89bcb196a138f9f20a6853c41673a18a2575f -&gt; DroidKungFu.M.Gen 25: 584f8a2801a8e7590dc466a6ebc58ea01a2d1758 -&gt; DroidKungFu.M.Gen 26: 8edb188204c6ad79006e555b50e63705b68ea65d -&gt; DroidKungFu.M.Gen 27: bd249c0843df2f8acfe7615feba505ead30e5bbc -&gt; DroidKungFu.M.Gen 28: 2cfa26bb22bbdc4e310728736328bde16a69d6b4 -&gt; DroidKungFu.M.Gen</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
