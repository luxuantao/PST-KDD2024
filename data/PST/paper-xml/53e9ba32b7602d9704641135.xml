<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Probabilistic symbolic model checking with PRISM: a hybrid approach</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2004-04-06">6 April 2004</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Marta</forename><surname>Kwiatkowska</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computer Science</orgName>
								<orgName type="institution">University of Birmingham</orgName>
								<address>
									<postCode>B15 2TT</postCode>
									<settlement>Birmingham</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Gethin</forename><surname>Norman</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computer Science</orgName>
								<orgName type="institution">University of Birmingham</orgName>
								<address>
									<postCode>B15 2TT</postCode>
									<settlement>Birmingham</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">David</forename><surname>Parker</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computer Science</orgName>
								<orgName type="institution">University of Birmingham</orgName>
								<address>
									<postCode>B15 2TT</postCode>
									<settlement>Birmingham</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Probabilistic symbolic model checking with PRISM: a hybrid approach</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2004-04-06">6 April 2004</date>
						</imprint>
					</monogr>
					<idno type="MD5">A904973174DC96CC3CCC8DF83BF04D9A</idno>
					<idno type="DOI">10.1007/s10009-004-0140-2</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T17:34+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Probabilistic model checking -Symbolic model checking -Binary decision diagrams</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper we present efficient symbolic techniques for probabilistic model checking. These have been implemented in PRISM, a tool for the analysis of probabilistic models such as discrete-time Markov chains, continuous-time Markov chains and Markov decision processes using specifications in the probabilistic temporal logics PCTL and CSL. Motivated by the success of model checkers such as SMV which use BDDs (binary decision diagrams), we have developed an implementation of PCTL and CSL model checking based on MTB-DDs (multi-terminal BDDs) and BDDs. Existing work in this direction has been hindered by the generally poor performance of MTBDD-based numerical computation, which is often substantially slower than explicit methods using sparse matrices. The focus of this paper is a novel hybrid technique which combines aspects of symbolic and explicit approaches to overcome these performance problems. For typical examples, we achieve a dramatic improvement over the purely symbolic approach. In addition, thanks to the compact model representation using MTBDDs, we can verify systems an order of magnitude larger than with sparse matrices, while almost matching or even beating them for speed.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In the design and analysis of software and hardware systems it is often desirable or even necessary to include probabilistic aspects of a system's behaviour. Examples include representing unreliable or unpredictable Supported in part by EPSRC grants GR/M04617, GR/N22960 and GR/S11107 and MathFIT studentship for David <ref type="bibr">Parker.</ref> behaviour in fault-tolerant systems, deriving efficient algorithms by using electronic coin flipping in decision making, and modelling the arrivals and departures of calls in a wireless cell.</p><p>Probabilistic model checking refers to a range of techniques for calculating the likelihood of the occurrence of certain events during the execution of systems which exhibit such behaviour. One first constructs a model of the system, defining the set of possible states that it can be in and the likelihood that transitions will occur between these states. Desirable or required properties of the system such as "shutdown occurs with probability 0.01 or less" and "the video frame will be delivered within 5 ms with probability 0.97 or greater" can be expressed in probabilistic temporal logics. These specifications can then be automatically verified by a probabilistic model checker.</p><p>Motivated by the success of symbolic model checkers such as SMV <ref type="bibr" target="#b54">[55]</ref> which use BDDs (binary decision diagrams) <ref type="bibr" target="#b14">[15]</ref>, we have developed a symbolic probabilistic model checker, PRISM <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b52">53]</ref>. In the non-probabilistic setting, model checking involves manipulation of state transition systems and sets of states, both of which can be represented naturally as BDDs, often very compactly <ref type="bibr" target="#b17">[18]</ref>. In the probabilistic case, since realvalued matrices and vectors are required, BDDs alone are insufficient, and hence we also use MTBDDs (multiterminal binary decision diagrams) <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b22">23]</ref>, a natural extension of BDDs for representing real-valued functions.</p><p>The use of MTBDDs for the analysis of probabilistic models has been studied extensively in the literature <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b42">43,</ref><ref type="bibr" target="#b45">46,</ref><ref type="bibr" target="#b49">50,</ref><ref type="bibr" target="#b50">51,</ref><ref type="bibr" target="#b62">63]</ref>, and it has been demonstrated that it is feasible to construct and compute the reachable state space of extremely large, structured, probabilistic models in this way. In these cases, it is often also possible to verify qualitative properties, where model checking reduces to reachability-based analysis. For example, in <ref type="bibr" target="#b30">[31]</ref> systems with over 10 30 states have been verified.</p><p>Model checking quantitative properties, on the other hand, involves numerical computation. In some cases, such as in <ref type="bibr" target="#b50">[51]</ref>, MTBDDs have been very successful, being applied to systems with over 10 10 states. Often, however, it turns out that such computation is slow or infeasible. By way of comparison, the equivalent numerical computation routines implemented explicitly using sparse matrices are often orders of magnitude faster.</p><p>Here we present a novel hybrid approach which uses an extension of the MTBDD data structure and borrows ideas from explicit techniques to overcome these performance problems. We include experimental data which demonstrate that, using this hybrid approach, we can achieve speeds which are orders of magnitude faster than MTBDDs. It is possible, in general, to almost match the speed of sparse matrices and, in some cases, outperform them, while maintaining considerable space savings.</p><p>The outline of this paper is as follows. Section 2 gives an overview of probabilistic model checking, introducing the probabilistic models and temporal logics we consider. In Sect. 3, we describe our tool, PRISM, which implements the model checking of these models and logics. We then move on to discuss the tool's implementation. Section 4 introduces the MTBDD data structure and explains how it can be used to represent and analyse probabilistic models. We identify a number of performance problems in this implementation and, in Sect. 5, describe how we overcome these limitations. In Sect. <ref type="bibr" target="#b5">6</ref>, we present experimental results to judge the performance of our technique, and in Sect. <ref type="bibr" target="#b6">7</ref> we discuss how it relates to existing work. Section 8 concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Probabilistic model checking</head><p>In this section we briefly summarise the models and temporal logics that our implementation of probabilistic model checking supports. The simplest probabilistic model is the discrete-time Markov chain (DTMC), defined by a set of states S and a transition probability matrix P : S × S → [0, 1], where P(s, s ) is the probability of making a transition from one state s to another state s . The probabilities from state s must sum up to 1, i.e., s P(s, s ) = 1.</p><p>Markov decision processes (MDPs) extend DTMCs by allowing both probabilistic and nondeterministic behaviour. More formally, in any state there is a nondeterministic choice between a number of discrete probability distributions over states. Nondeterminism enables the modelling of asynchronous parallel composition of probabilistic systems. It also permits under-specification of certain aspects of a system.</p><p>A continuous-time Markov chain (CTMC), on the other hand, is defined by a set of states S and a transition rate matrix R : S × S → IR ≥0 , where R(s, s ) is the rate of making a transition from state s to s . The interpretation is that the probability of moving from s to s within t time units (for positive, real-valued t) is 1e -R(s,s )•t .</p><p>As specification formalisms, we use probabilistic extensions of the temporal logic CTL. In particular, we use PCTL <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b36">37]</ref> in the context of DTMCs and MDPs and CSL <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b8">9]</ref> in the context of CTMCs.</p><p>PCTL allows us to express properties of the form "under any scheduling of processes, the probability that event A occurs is at least p (at most p)". By way of illustration, we consider the asynchronous randomised leader election protocol of Itai and Rodeh <ref type="bibr" target="#b44">[45]</ref>, which gives rise to an MDP. In this algorithm, the processors of an asynchronous ring make random choices based on coin tosses in an attempt to elect a leader. We use the atomic proposition leader to label states in which a leader has been elected. Examples of properties we would wish to verify can be expressed in PCTL as follows:</p><p>-P ≥1 [ leader ] -"under any scheduling, a leader is eventually elected with probability 1". -P ≤0.5 [ ≤k leader ] -"under any scheduling, the probability of electing a leader within k discrete time steps is at most 0.5". In <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b27">28]</ref> an extension of PCTL, called pTL, is introduced which additionally allows the specification of expected time and average time properties. Returning to the leader election protocol given above, an example of such a property is:</p><p>-D ≤10 [leader ] -"under any scheduling, the expected number of steps until leader election is at most 10". The logic CSL includes the means to express both transient and steady-state performance measures of CTMCs. Transient properties describe the system at a fixed, realvalued time instant t, whereas steady-state properties refer to the behaviour of a system in the "long run". For example, consider a queueing system where the atomic proposition full labels states where the queue is full. CSL then allows us to express properties such as:</p><p>-P ≤0.01 [ ≤t full ] -"the probability that the queue becomes full within t time units is at most 0.01". -S ≥0.98 [¬full ] -"in the long run, the probability that the queue is not full is at least 0.98". Model checking algorithms for PCTL have been introduced in <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b36">37]</ref> and extended in <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b9">10]</ref> to include fairness. The case for pTL is dealt with in <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b29">30</ref>]. An algorithm for CSL was first proposed in <ref type="bibr" target="#b8">[9]</ref> and has since been improved in <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b45">46]</ref>. The model checking algorithms for all logics reduce to a combination of reachabilitybased computation and numerical calculation. The former may be used, for example, to determine states which satisfy a temporal logic formula with probability exactly 0 or 1. The latter is needed where exact probabilities must be determined. Here, the computation required varies. For DTMCs, this usually entails solution of a linear equation system, whereas for MDPs a linear optimisation problem must be solved. For CTMCs, either solution of a linear equation system or an iterative technique known as uniformisation is performed. Since the size of the problem to be solved is often large, direct methods, such as Gaussian elimination (for linear equation systems) or Simplex (for linear optimisation problems), are usually impractical. Instead, we opt to use iterative methods which approximate the solution up to some specified accuracy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">PRISM</head><p>PRISM <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b52">53]</ref> is a model checking tool developed at the University of Birmingham which supports verification of the models and logics described in the previous section. The tool takes as input a description of a probabilistic system written in the PRISM language, a variant of the Reactive Modules formalism of Alur and Henzinger <ref type="bibr" target="#b1">[2]</ref>. It first constructs the model from this description (a DTMC, an MDP or a CTMC), computes the set of reachable states, and identifies any deadlock states. PRISM accepts specifications in either the logic PCTL or CSL depending on the model type. It then performs model checking to determine which states of the model satisfy each specification. Figure <ref type="figure">1</ref> illustrates the structure of the tool and Fig. <ref type="figure">2</ref> shows a screen shot of the graphical user interface. A text-based, command line version is also available.</p><p>The underlying data structures in PRISM are BDDs and MTBDDs. For numerical computation, however, the Fig. <ref type="figure">1</ref>. PRISM system architecture Fig. <ref type="figure">2</ref>. PRISM graphical user interface tool provides three distinct engines which can be used interchangeably. The first is a pure MTBDD-based implementation, as described in Sect. 4; the second is a conventional explicit version using sparse matrices, implemented for comparison purposes; the third uses the hybrid approach presented in this paper.</p><p>PRISM is written in a combination of Java and C++ and uses CUDD <ref type="bibr" target="#b59">[60]</ref>, a publicly available BDD/MTBDD library developed at the University of Colorado at Boulder. The high-level parts of the tool, such as the user interface and parsers, are written in Java. The low-level libraries are written in C++. The tool and its source code are available for download from the PRISM web site <ref type="bibr" target="#b0">[1]</ref>. Further information about the tool and a large number of case studies to which it has been applied are also available here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">An MTBDD implementation</head><p>This section describes how probabilistic model checking can be implemented using MTBDDs. We begin by introducing the data structure, then explain how it can be used to produce a compact representation for probabilistic models, and finally show how techniques to analyse these models can be implemented. We also summarise the performance of these symbolic techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Introduction to MTBDDs</head><p>An MTBDD M is a rooted, directed acyclic graph associated with a set of ordered, Boolean variables x 1 &lt; . . . &lt; x n . It represents a function f M (x 1 , . . . , x n ) : IB n → IR over these variables. The graph contains two types of nodes: non-terminal and terminal . A non-terminal node m is labelled by a variable var (m) ∈ {x 1 , . . . , x n } and has two children, then(m) and else(m). A terminal node m is labelled by a real number val (m).</p><p>We impose the Boolean variable ordering &lt; onto the graph by requiring that a child m of a non-terminal node m is either terminal or non-terminal and satisfies var (m) &lt; var (m ). The value of f M (x 1 , . . . , x n ), the function which the MTBDD represents, is determined by traversing M from the root node and at each subsequent node m taking the edge to then(m) or else(m) if var (m) is 1 or 0, respectively. Note that a BDD is merely an MTBDD with the restriction that the labels on terminal nodes can only be 1 or 0.</p><p>MTBDDs are efficient because they are stored in reduced form. If nodes m and m are identical (that is, var (m) = var (m ), then(m) = then(m ) and else(m) = else(m ) for non-terminals or val (m) = val (m ) for terminals), then only one copy is stored. Furthermore, if a node m is redundant , i.e., satisfies then(m) = else(m), it is removed and any incoming edges are redirected to its unique child. These reductions mean that MTBDD representations of functions which exhibit regularity or redundancy can be extremely compact. There is, however, another important advantage. With these two rules in place, MTBDDs can be shown to be canonical , meaning that for a given variable ordering there is a one-to-one correspondence between MTBDDs and the functions which they represent. One important implication of this is that it is very efficient to compare two MTBDDs for equality. This is useful, for example, when implementing a cache of previously performed MTBDD operations.</p><p>Another important characteristic of MTBDDs, from a practical point of view, is that their size (number of nodes) is heavily dependent on the ordering of their Boolean variables. Although in the worst case the size of an MTBDD representation is exponential and the problem of deriving the optimal ordering for a given MTBDD is an NP-hard problem <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b61">62]</ref>, through application of heuristics, MTBDDs can provide extremely compact storage for structured, real-valued functions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">MTBDD representation of probabilistic models</head><p>From their inception in <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b22">23]</ref> MTBDDs have been used to encode real-valued vectors and matrices. An MTBDD v over variables (x 1 , . . . , x n ) represents a function f v : IB n → IR. Observe that a real vector v of length 2 n is simply a mapping from {1, . . . , 2 n } to the reals IR. Hence, if we decide upon an encoding of {1, . . . , 2 n } in terms of {x 1 , . . . , x n } (for example, the standard binary encoding), then an MTBDD v can represent v.</p><p>In a similar fashion, we can consider a square matrix M of size 2 n by 2 n to be a mapping from {1, . . . , 2 n } × {1, . . . , 2 n } to IR. Taking Boolean variables {x 1 , . . . , x n } to range over row indices and {y 1 , . . . , y n } to range over column indices, we can represent M by an MTBDD over {x 1 , . . . , x n , y 1 , . . . , y n }. DTMCs and CTMCs are</p><formula xml:id="formula_0">x 1 y 1 x 2 y 2 f R Entry of R 0 0 0 0 2 (0, 0) = 2 0 0 0 1 5 (0, 1) = 5 0 0 1 0 2 (1, 0) = 2 0 0 1 1 5</formula><p>(1, 1) = 5 0 1 1 1 7</p><p>(1, 3) = 7 1 0 1 1 7</p><p>(3, 1) = 7 described by such matrices and hence are also straightforward to represent as MTBDDs. Figure <ref type="figure" target="#fig_0">3</ref> gives an example of an MTBDD R over four Boolean variables, x 1 , y 1 , x 2 and y 2 . In our notation, nonterminal nodes are drawn as circles and terminal nodes as squares. Non-terminal nodes are grouped into levels according to their variable labelling, which is displayed at the left-hand end of each level. The downward then and else edges from each node are drawn as solid and dashed lines, respectively. For clarity, we omit the zero terminal node and any edges which lead directly to it. Figure <ref type="figure" target="#fig_0">3</ref> also includes a table showing the function f R which the MTBDD R represents. Consider, for example, the valuation (x 1 , y 1 , x 2 , y 2 ) = (0, 1, 1, 1). Tracing the appropriate path through the MTBDD, we can see that the resulting value is 7.</p><p>In fact, the MTBDD R in Fig. <ref type="figure" target="#fig_0">3</ref> represents the transition rate matrix R of a CTMC. This matrix and the associated CTMC are shown in Fig. <ref type="figure">4</ref>. Note that the CTMC includes one state which is unreachable. This will be important when we reuse the example later in the paper. The corresponding row and column of R are filled with zeros, but to emphasise that these are unreachable, the entries are marked as '-' rather than '0'.</p><p>The right-most column of the table in Fig. <ref type="figure" target="#fig_0">3</ref> illustrates exactly how R corresponds to R. As described above, we use variables x 1 and x 2 to encode row indices and y 1 and y 2 to encode column indices. In both cases, we use the standard binary representation of integers. By way of example, for entry (1, 3) of R, the row index 1 is encoded as (x 1 , x 2 ) = (0, 1) and the column index 3 is encoded as (y 1 , y 2 ) = (1, 1). Tracing a path down the MTBDD using these values leads to the terminal node 7 which is the value of the entry. <ref type="figure">4</ref>. A CTMC and its rate matrix R Observe that in R the variables for rows and columns are ordered alternately. This is a common variable ordering heuristic for minimising the size of the MTBDD representation of a transition matrix. Note also that the MTBDD is an inherently recursive data structure: each node of the data structure is itself an MTBDD. In terms of matrices, this means that each node of an MTBDD represents a sub-matrix of the overall matrix being represented. Intuitively, this is how MTBDDs can provide a compact representation: in cases where sub-matrices are repeated, this can be exploited by the reduced nature of the data structure.</p><formula xml:id="formula_1">R =     2 5 -0 2 5 -7 ---- 0 7 -0     Fig.</formula><p>The process for the representation of MDPs is more complex since the nondeterminism must also be encoded. However, if the maximum number of nondeterministic choices in any state is bounded by 2 k for some integer k, we can view the MDP as a function from {1, . . . , 2 n } × {1, . . . , 2 k } × {1, . . . , 2 n } to IR. By adding k extra Boolean variables to encode this third index, we can represent the MDP as an MTBDD. In this way, an MTBDD can be considered to be represented by a set of matrices.</p><p>In order to produce compact MTBDD representations of probabilistic models, it is important to consider how they are encoded. This issue was first addressed by Hermanns et al. in <ref type="bibr" target="#b42">[43]</ref>, which presents a number of heuristics for this purpose. The most important conclusion is that it is essential to exploit structure and regularity in the model, which typically derived from its high-level description. For example, if the formalism used describes the model in a compositional fashion, it is advisable to first encode individual components of the model as MTB-DDs and then combine them in a structured fashion. In practice, this can be accomplished by performing a direct translation from the high-level description of the model into an MTBDD.</p><p>Examples of this for queueing network and process algebra descriptions can be found in <ref type="bibr" target="#b41">[42,</ref><ref type="bibr" target="#b42">43,</ref><ref type="bibr" target="#b47">48]</ref>. The translation of the PRISM language, used to describe models in our tool, is considered in <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b56">57]</ref>. Heuristics have also been developed to select efficient variable orderings in these cases <ref type="bibr" target="#b41">[42,</ref><ref type="bibr" target="#b42">43,</ref><ref type="bibr" target="#b56">57]</ref>. In practice, these techniques have been used to construct and represent extremely large probabilistic models, e.g., <ref type="bibr" target="#b42">[43,</ref><ref type="bibr" target="#b50">51,</ref><ref type="bibr" target="#b53">54]</ref>. We include some experimental data in Sect. 6 which illustrate this. Often, a direct translation from a high-level formalism also results in a relatively fast construction process. It should be noted, though, that it also often introduces unreachable states. These must be determined through reachability analysis (via a simple BDD fixpoint calculation) and then removed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Probabilistic model checking with MTBDDs</head><p>Once a model's MTBDD representation has been constructed, it can be analysed, for example using PCTL or CSL model checking. This analysis can be carried out symbolically, using MTBDDs. As described in Sect. 2, the process usually comprises two types of computation: graph-based analysis using reachability techniques and numerical calculation. The former can be performed with BDDs and is at the heart of non-probabilistic symbolic model checking, which has been proven to be very successful <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b54">55]</ref>. The latter can be implemented with MTBDDs, as we will now see.</p><p>Fortunately, all the numerical problems we need to solve can be implemented as iterative methods. For the solution of a linear equation system, standard techniques such as the Jacobi and Gauss-Seidel methods are available. For the linear optimisation problems required for PCTL model checking of MDPs, iterative methods based on dynamic programming can be used. Other techniques needed for transient analysis of CTMCs and the computation of expected costs or rewards can also be performed through iterative methods.</p><p>The typical structure of an iterative solution method is as follows. A solution vector, containing an approximation to the values being computed, is repeatedly updated until it is judged to have converged. An example of a check for convergence is to note when the maximum difference between vector elements of successive iterations falls below some threshold. At each iteration, the operations performed to compute the updated vector use both the vector from the previous iteration and the matrix representing the probabilistic model. In the majority of cases, the bulk of this work reduces to performing a matrix-vector multiplication. As seen above, MTBDDs can easily represent both matrices and vectors. Furthermore, efficient algorithms to perform matrix multiplications using the MTBDD data structure have been developed <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b23">24]</ref>. This constitutes the basis for a wide range of MTBDD implementations of numerical iterative methods <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b42">43,</ref><ref type="bibr" target="#b45">46,</ref><ref type="bibr" target="#b50">51,</ref><ref type="bibr" target="#b62">63]</ref>.</p><p>Although we have already dismissed the use of direct methods because they do not scale well to large problems, it is interesting to note that they are poorly suited to symbolic implementation anyway. MTBDD-based versions of Gaussian elimination and Simplex have been presented in <ref type="bibr" target="#b4">[5]</ref> and <ref type="bibr" target="#b49">[50]</ref>, respectively, and found to perform badly. The reason for this is that they rely on modifying the model representation through operations on individual rows, columns or elements. This is not only slow but leads to a loss in regularity and a subsequent explosion in MTBDD size.</p><p>The results of the implementation of probabilistic model checking with MTBDDs can be summarised as follows. Firstly, there is a clear distinction between the two different types of computations required for the process. Those based on reachability, which are sufficient for model checking qualitative properties, can be implemented efficiently with BDDs, as shown, for example, in <ref type="bibr" target="#b30">[31]</ref>. On the other hand, numerical computation, which is required for checking of quantitative properties, is more unpredictable. This is the problem we focus on in this paper.</p><p>There have been instances where MTBDD-based numerical computation proves to be extremely efficient. For example, <ref type="bibr" target="#b50">[51]</ref> presents results for the analysis of the coin protocol from Aspnes and Herlihy's randomised consensus algorithm <ref type="bibr" target="#b2">[3]</ref>. This includes model checking of MDPs with more than 10 10 states. In <ref type="bibr" target="#b53">[54]</ref>, an analysis of the IEEE 1394 FireWire root contention protocol involved MDPs with more than 170 million states. In both cases, it would be impossible even to construct and store an explicit representation of the models, given the same hardware constraints.</p><p>In general, though, the symbolic implementation of numerical iterative methods is far from efficient. The problem is that, despite a compact MTBDD representation of the model, the MTBDD representation of the solution vector tends to grow extremely large. This is due to a lack of regularity in the vector as the computation progresses and is worsened by an accompanying increase in the number of distinct values it contains. These results have been observed in, e.g., <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b45">46]</ref>. By contrast, in explicit implementations, such as those based on sparse matrices, solution vectors are stored in arrays. These remain a fixed size, and it is quick and easy to access and modify their contents. Hence, sparse-matrix-based techniques are usually much faster than their symbolic counterparts. However, since the probabilistic model is also stored explicitly, application to large examples is often limited by memory constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">A hybrid approach</head><p>We now present a method to overcome the inefficiencies with MTBDDs outlined in the previous section. The approach taken here is to use a hybrid of the two techniques: symbolic and explicit. We store the transition matrix in an MTBDD but use a full array for the iteration vector. We will consider the problem of performing a matrixvector multiplication using these two contrasting data structures. As seen previously, this is then sufficient to allow us to implement a range of numerical computation techniques, as required for probabilistic model checking. In particular, this is directly applicable to PCTL model checking of DTMCs and CSL model checking of CTMCs, provided that linear equation systems are solved using the Jacobi or JOR (Jacobi with over-relaxation) methods. In fact, the techniques can also be extended to MDP-based model checking <ref type="bibr" target="#b56">[57]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">The basic algorithm</head><p>In the remainder of this section, we will describe how a matrix-vector multiplication can be carried out when the matrix is stored in an MTBDD and the vector in an array. Essentially, we will emulate the operations that would be carried out in an explicit approach, e.g., using a sparse matrix data structure. The overall process reduces to the extraction of all the entries of the matrix, each of which is needed exactly once to compute the multiplication. The key difference in our approach is that we need to extract them from an MTBDD rather than a sparse matrix. Crucially, we note that, for matrix-vector multiplication, the order in which the entries are extracted is not important. This means that we can proceed via a recursive traversal of the MTBDD: it does not matter that the entries will be in an essentially random order, rather than row-by-row (or column-by-column) as with a sparse matrix.</p><p>A single matrix entry comprises three pieces of information: its row index, column index and value. A recursive traversal of an MTBDD essentially enumerates every possible path from the root node of the data structure to a terminal node. Each of these paths corresponds to a matrix entry. The value of this entry is equal to the labelling of the terminal node at the end of the path. The row and column index can be determined as follows. Let us assume that the matrix indices were encoded using the standard binary representation of integers. Since we know the path that was taken, i.e., whether the then or else edge was taken at each step, we can deduce the binary representation of the indices and hence convert them to decimal.</p><p>In terms of the recursive traversal algorithm, this is achieved by maintaining a running total for both the row and column indices. At each recursive call, if the then edge is taken from the current node m, the appropriate power of 2 is added to the corresponding index: the row index if var (m) is an x i variable and the column index if var (m) is a y i variable. Alternatively, we can view this as a truly recursive problem. Each call to the algorithm computes the local entries for the sub-matrix which that node represents. The actual indices are computed correctly by adding the appropriate offsets at each level. This offset will be a power of 2 corresponding to the size of the submatrices at the level of recursion below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Offset-labelled MTBDDs</head><p>Unfortunately, there is a drawback to using the simple algorithm outlined in the previous section. Recall from Sect. 4.2 that generating an efficient, structured MTBDD representation of a probabilistic model typically results in the inclusion of a number of unreachable states in the encoding. Performing matrix-vector multiplication as just described on such an MTBDD would require the vector array to store entries for all states, including those which are unreachable. The number of unreachable states is potentially very large, in some cases orders of magnitude larger than the reachable portion. This puts unacceptable limits on the size of problem which we can handle.</p><p>The solution we adopt is to compute the row and column index in terms of reachable states only. This can be integrated into our existing recursive MTBDD traversal algorithm described above. As before, we will keep track of the indices during traversal by adding offsets at each node. Here, though, the offset will be equal to the number of rows or columns in the next level of recursion's submatrix which correspond to reachable states, rather than the total number (a power of 2) as before. To facilitate this process, we use a modified version of the MTBDD data structure, which we call offset-labelled MTBDDs.</p><p>An offset-labelled MTBDD is essentially an MTBDD, but with two important differences. Firstly, each node of the data structure is labelled with an integer offset. These will be the values added to the row and column indices during traversal. Secondly, we modify the reduction rules that are applied to the data structure. Recall from Sect. 4.1 that there are two types of reduction: merging of identical nodes and removal of redundant nodes. In an offset-labelled MTBDD, the second type of reduction is not performed. In the context of BDDs, of which MTBDDs are an extension, this variant is known as a quasi-reduced BDD. The reason we do this is that, during the computation of indices, offsets may need to be added at any level of the MTBDD. Since the offsets are stored on the nodes, we need nodes to be present at every level. The exception to this rule is that we do allow edges to skip levels if they lead directly to the zero terminal node. This is because we are only ever interested in extracting the non-zero entries of the matrix.</p><p>We also relax the constraints on the first type of reduction (merging of identical nodes), making it optional. In most cases, this reduction will still be used to minimise the size of the data structure. There are some cases, though, as we will see, where it is important not to do this. Removing instances of this type of reduction means that the data structure is no longer canonical. Fortunately, for our usage of offset-labelled MTBDDs, this is not a problem. Usually, the reason for maintaining canonicity is for the efficient implementation of look-ups in a cache of previously performed operations. This is crucial for efficient manipulation of MTBDDs. Here, though, we will never actually need to manipulate the data structure: we will construct an instance of it (from an existing MTBDD), use it for numerical computations (via traversals which do not involve manipulating the graph), and then discard it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Path</head><p>Offsets Entry of R</p><formula xml:id="formula_2">x 1 y 1 x 2 y 2 f R x 1 y 1 x 2 y 2 0 0 0 0 2 ----(0, 0) = 2 0 0 0 1 5 ---1 (0, 1) = 5 0 0 1 0 2 --1 -(1, 0) = 2 0 0 1 1 5 --1 1 (1, 1) = 5 0 1 1 1 7 -2 1 0 (1, 2) = 7 1 0 1 1 7 2 -0 1 (2, 1) = 7</formula><p>Fig. <ref type="figure">6</ref>. The offset-labelled MTBDD representing the CTMC in Fig. <ref type="figure">4</ref> TraverseRec(m, row , col ) if (m is the zero terminal node) then return elseif (m is a non-zero terminal node) then found matrix element (row , col ) = val (m) elseif (m is a row node) then TraverseRec(else(m), row , col ) TraverseRec(then(m), row + offset(m), col ) elseif (m is a column node) then TraverseRec(else(m), row , col ) TraverseRec(then(m), row , col + offset(m)) endif TraverseRec(root, 0, 0), where root is the root node of the MTBDD. The base cases are when the current MTBDD node m is a terminal node. If m is the zero terminal, there are no more non-zero entries in this portion of the matrix. If m is a non-zero terminal, a matrix entry has been identified. The variables row and col are used to keep track of row and column indices. The offset label on each node m, used to compute these indices, is denoted offset (m). The row and column index of an entry are computed (independently) by summing the offsets on x i and y i labelled nodes, respectively, from which the then edge was taken.</p><p>To illustrate the whole process more clearly, we now present a simple example. Figure <ref type="figure">6</ref> shows the offsetlabelled MTBDD representing the CTMC from Fig. <ref type="figure">4</ref>. The table to its right explains how the information is encoded. Each row corresponds to a single matrix entry (i.e., a transition of the CTMC). These are given in the order that they would be extracted by the recursive traversal algorithm. The first five columns describe the path taken through the MTBDD. The next four columns give the node offsets along this path. The last column gives the resulting matrix entry. For example, the path 0111, i.e., where (x 1 , y 1 , x 2 , y 2 ) = (0, 1, 1, 1), leads to the 7 terminal node. Since the then edge was taken at the x 2 level but not the x 1 level, the row index is equal to the offset on the x 2 node, 1. For the y 1 and y 2 levels, the then edge was taken in both cases. Hence, the column index is the sum of the two offsets, 2 + 0 = 2. The matrix entry is therefore (1, 2) = 7. Note how in the previous case, in Fig. <ref type="figure" target="#fig_0">3</ref>, this entry was computed as <ref type="bibr" target="#b0">(1,</ref><ref type="bibr" target="#b2">3)</ref>. Here, the unreachable state has been taken into account.</p><p>A closer comparison of the offset-labelled MTBDD in Fig. <ref type="figure">6</ref> and the MTBDD in Fig. <ref type="figure" target="#fig_0">3</ref> highlights the other differences between the two data structures. Note the extra x 2 node on the left-hand side in Fig. <ref type="figure">6</ref>. This is because we do not allow skipped levels in offset-labelled MTBDDs. Secondly, observe that the bottom two nodes of the two paths to the 7 terminal node in Fig. <ref type="figure">6</ref> are identical, except for the offset labelling. Hence, in the original MTBDD, these nodes were merged together. This is why we are less stringent about the first reduction rule.</p><p>The explanation is that some nodes in an MTBDD can be reached along several different paths. These shared nodes correspond to repeated sub-matrices in the overall matrix. Consider the matrix in Fig. <ref type="figure">4</ref> and its MTBDD representation in Fig. <ref type="figure" target="#fig_0">3</ref>. The bottom-left and top-right quadrants of the matrix are identical (since rows and columns of unreachable states are filled with zeros). This is reflected by the fact that the x 2 node in the MTBDD has two incoming edges. The two identical sub-matrices do not, however, share the same pattern of reachable states. This means that there is a clash as which offset should label the node. In Fig. <ref type="figure">6</ref>, this has been resolved by duplicating the node, labelling each copy with a different offset.</p><p>Finally, we briefly describe how offset-labelled MTBDDs are constructed. A more detailed presentation of the process, including full algorithms, can be found in <ref type="bibr" target="#b56">[57]</ref>. An offset-labelled MTBDD is only needed for the numerical solution phase of model checking. It is constructed from an existing MTBDD before this phase begins. The first step is to remove instances of skipped levels in the original MTBDD. This is done simply by traversing the data structure, comparing the variables on consecutive pairs of nodes and inserting additional nodes where required. Secondly, we traverse the new MTBDD and add offset labels onto the nodes. These offsets are computed beforehand using a BDD representation of the reachable state space. During the labelling process, possible clashes of label are checked for and, where necessary, additional nodes with the correct offset are inserted. In Sect. 6, we include empirical results giving the time required for the construction process and the amount of additional memory usage which it incurs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Optimising the hybrid approach</head><p>We can optimise the method described in the previous section considerably via a form of caching. MTBDDs ex-ploit structure and regularity in the probabilistic model being analysed, often resulting in a significant space saving. This is achieved by merging identical nodes, representing identical sub-matrices. During a single traversal of the data structure, however, each of these shared nodes will be visited several times (as many times as the submatrix occurs in the overall matrix) and the entries of the sub-matrix will be extracted separately every time. Furthermore, a typical instance of numerical computation will comprise many iterations, each of which requires one such traversal. Hence, by storing and reusing the results of the traversal process, we can achieve a significant speed-up in traversal time.</p><p>Rather than store these results in a cache, which would need to be searched through frequently, we simply attach the information directly to MTBDD nodes. We select some subset of the nodes, build explicit (sparse matrix) representations of their associated sub-matrices and attach them to the MTBDD. When these nodes are reached during each traversal, the entries of their associated sub-matrices can be extracted extremely quickly.</p><p>There is an obvious trade-off here between the additional space required to store the data and the resulting improvement in speed. The space required and time improvement both depend on how many nodes (and which ones) we attach matrices to. A simple yet effective policy is to select a single layer of the MTBDD and compute matrices for all nodes on this level.</p><p>In Fig. <ref type="figure" target="#fig_2">7</ref>, we demonstrate this technique on the running example, replacing all nodes on the x 2 level with the matrices they represent. The table illustrates how the recursive traversal process now functions. At the bottom of the recursion, small, explicit sub-matrices are obtained. The local entries of these matrices are converted to global entries of the overall matrix by adding row and column index offsets as before.</p><p>In general, selecting a higher level of the MTBDD for which to compute sub-matrices means that entries of the whole matrix can be extracted in less time but that more memory is required for storage. Our approach is to precompute, for each level, the amount of storage that would be required and then select the highest level possible for which some given memory threshold is not exceeded. In this work, we take this threshold to be 1024 KB. In practice, we find that this optimisation technique produces a marked improvement in traversal speed. In Sect. 6, we give experimental results to illustrate this.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Additional extensions</head><p>More detailed information about the techniques given in this paper can be found in <ref type="bibr" target="#b56">[57]</ref>. In addition, two extensions of the basic algorithms described here are included. Firstly, the process is extended to cover model checking of MDPs. In the sections above, we have focused on the problem of extracting entries from a real-valued matrix. This is directly applicable to the numerical computa-</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Path Offsets</head><p>Local Global However, as explained in Sect. 4.2, an MDP can actually be considered as a set of matrices. Each iteration of the numerical solution required for model checking can then be performed using several matrix-vector multiplications, as opposed to just one for DTMCs and CTMCs.</p><formula xml:id="formula_3">x 1 y 1 x 1 y 1 entry entry 0 0 --(0, 0) = 2 (0, 0) = 2 (0, 1) = 5 (0, 1) = 5 (1, 0) = 2 (1, 0) = 2 (1, 1) = 5 (1, 1) = 5 0 1 -2 (1, 0) = 7 (1, 2) = 7 1 0 2 -(0, 1) = 7 (2, 1) = 7</formula><p>Secondly, <ref type="bibr" target="#b56">[57]</ref> addresses an important limitation of our approach: that the algorithms we have given can only be used for iterative methods based on matrix-vector multiplication. For some tasks, such as transient analysis of CTMCs and PCTL model checking of MDPs, this is not restrictive. In cases where solution of a linear equation system is required, though, iterative numerical methods such as Gauss-Seidel, which generally converge faster, cannot be used. This is because such methods require access to individual rows or columns of the matrix. Our approach of recursively traversing the MTBDD in a single pass does not allow this kind of access. One way this situation can be improved is to use a block-based variant of Gauss-Seidel which also provides an improvement in convergence speed but which is amenable to implementation with MTBDDs. Intuitively, this is because blocks of a matrix which is represented by an MTBDD are easy to access, unlike individual rows or columns.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Results</head><p>In this section, we present experimental results to compare the performance of the three implementations discussed in this paper: the purely MTBDD-based approach described in Sect. 4, an equivalent explicit implementation using sparse matrices, and the hybrid approach described in Sect. 5. All three are available in the PRISM model checker. We also made use of a prototype extension of PRISM which is being developed for the analysis of expected-time properties. All experiments were run on a 450 MHz workstation with 1 GB of main memory.</p><p>We focus on the problem of iterative numerical computation, as required for quantitative probabilistic model checking. The results are for three case studies: a CTMC model of a Kanban manufacturing system <ref type="bibr" target="#b21">[22]</ref>, a DTMC model of a randomised self-stabilising algorithm due to Herman <ref type="bibr" target="#b38">[39]</ref> and an MDP model of the coin protocol from Aspnes and Herlihy's randomised consensus algorithm <ref type="bibr" target="#b2">[3]</ref>. In each case, we construct models of different sizes by varying a parameter N . This equals the maximum number of jobs in the Kanban system and the number of processes in the other two examples. Table <ref type="table" target="#tab_0">1</ref> shows, for each of the above examples, the model size in terms of number of states and number of transitions as the parameter N varies.</p><p>Table <ref type="table" target="#tab_1">2</ref> gives the memory requirements for storing these models, using four different implementations: MTBDDs, sparse matrices and the hybrid approach, with and without the optimisation described in Sect. 5.3. An MTBDD requires 20 bytes for each node of the data structure. A sparse matrix requires 4a + 12b bytes, where a is the number of states and b is the number of transitions. For an MDP, extra memory is required to store information about nondeterministic choices. See <ref type="bibr" target="#b56">[57]</ref> for more details. Note that entries with an asterisk in the sparse matrix column were not actually generated because of physical memory limitations. In our implementation, an offset-labelled MTBDD can  * Not actually constructed due to memory limitations also be stored using 20 bytes per node. This is because certain information normally present in MTBDDs can be omitted since the data structure is never modified.</p><p>In the optimised case, we require an extra 4 bytes per node to store pointers to the explicit sub-matrices. Furthermore, memory for the matrices themselves is needed. As described earlier, this is capped at 1024 KB. It is easy to see that, by exploiting the structure in these examples, MTBDDs can result in a colossal saving in memory. Furthermore, the memory overhead associated with our hybrid approach remains relatively low. This is despite the fact that we potentially add more nodes to the data structure and store some of the sub-matrices explicitly. In Table <ref type="table" target="#tab_2">3</ref>, we present timing statistics for model checking on the same three case studies. For the Kanban system, we model check a quantitative CSL property which requires computation of steady-state probabilities. This is done via the solution of a linear equation system using the JOR (Jacobi with over-relaxation) iterative method. For the self-stabilisation protocol, we verify an expected-time property, computing the solution iteratively. For the coin protocol, we verify a quantitative PCTL property which requires solution of a linear optimisation problem. In each case the times presented in the table are the average time per iteration of the numerical method. We also give the time required for construction of the offset-labelled MTBDD for the hybrid approach, with and without optimisation.</p><p>The relative performances of the four implementations can be summarised as follows. Concentrating first on the DTMC and CTMC examples, we see that our hybrid approach represents a significant improvement over the conventional MTBDD-based approach. We note also that applying the optimisation described in Sect. 5.3 makes our approach far more efficient. In comparison to the explicit approach using sparse matrices, we find that we can in one case almost match and in another case beat the time per iteration using our approach. More importantly, thanks to the memory savings afforded by the MTBDD-based model representation we can also handle models an order of magnitude larger.</p><p>For the coin protocol model, it is the pure MTBDD approach which is most effective, successfully coping with state spaces of 5 billion states. For the other three implementations, storing even the solution vector is impossible here. In this case, both the model and vectors to be stored exhibit a large amount of structure which can be exploited. This is helped by the fact that the model, like many taken from randomised distributed algorithms, contains only a small number of distinct probabilities.</p><p>Finally, we note that the time required to construct offset-labelled MTBDDs is small in all cases and is negligible in comparison to the overall solution process. For details of further case studies to which these techniques have been applied, see the PRISM web site <ref type="bibr" target="#b0">[1]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related work</head><p>We are aware of three other probabilistic model checkers: ProbVerus <ref type="bibr" target="#b37">[38]</ref>, a prototype tool which supports model checking of DTMCs using a subset of PCTL; E T MC 2 <ref type="bibr" target="#b40">[41]</ref>, which allows verification of CTMCs and DTMCs against CSL and PCTL specifications, respectively; and RAPTURE <ref type="bibr" target="#b25">[26]</ref>, which uses abstraction and refinement to perform model checking for a subset of PCTL over MDPs. Similarly to PRISM, both ProbVerus and RAPTURE use MTBDDs. E T MC 2 , on the other hand, is an explicit implementation based on sparse matrices. The APNN-Toolbox <ref type="bibr" target="#b10">[11]</ref>, a Petri-net-based tool which supports analysis of CTMCs, has recently added support for CSL model checking. There are also a wide range of other CTMC-based tools available which, despite not offering probabilistic model checking explicitly, typically perform steady-state and transient analysis of CTMCs, the numerical computation for which is very similar. These include GreatSPN <ref type="bibr" target="#b18">[19]</ref>, MARCA <ref type="bibr" target="#b60">[61]</ref>, Möbius <ref type="bibr" target="#b24">[25]</ref>, the PEPA workbench <ref type="bibr" target="#b33">[34]</ref>, SMART <ref type="bibr" target="#b19">[20]</ref>, TIPP-tool <ref type="bibr" target="#b39">[40]</ref> and UltraSAN <ref type="bibr" target="#b58">[59]</ref>.</p><p>Of the implementations described above, SMART and the APNN-Toolbox are of particular interest because, like PRISM, they incorporate sophisticated data structures designed to exploit large, structured models. Both tools include support for Kronecker representations, the basic idea of which is that the transition matrix of a CTMC is defined as a Kronecker (tensor) algebraic expression of smaller matrices, corresponding to sub-components of the model. Like MTBDD-based approaches, the goal is to derive a compact representation of large models by exploiting high-level structure and regularity. Methods have been developed which allow numerical solution of a CTMC to be performed directly on its Kronecker representation (see, for example, <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b57">58]</ref>). This process is very similar to the techniques described in this paper in that a compact, symbolic representation of the CTMC is used alongside explicit (array-based) storage of the solution vector.</p><p>Furthermore, SMART uses a variety of BDD-based data structures. Most relevant to this paper are matrix diagrams <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b55">56]</ref>, a data structure developed as an efficient implementation of the Kronecker techniques. There are several further similarities between this approach and ours. Firstly, it uses decision diagrams, i.e., reduced directed acyclic graphs, like BDDs and MTBDDs. In the case of matrix diagrams, the nodes of these graphs are the small matrices which make up the model's Kronecker representation. In fact, SMART uses a combination of matrix diagrams, to represent and manipulate CTMC transition rate matrices, and MDDs (multi-valued decision diagrams), to generate and store the CTMC's reachable state space. This is analogous with the way we use MTB-DDs and BDDs, respectively. Furthermore, matrix diagrams and MDDs are labelled with offsets which are used to compute row and column offsets. These serve the same purpose as the values added to offset-labelled MTBDDs. Finally, the implementations of both MTBDD and matrix diagram based numerical computation require consideration of a number of factors common to the majority of BDD-based data structures. These include the encoding of the model's state space into variables, the ordering chosen for these variables, and the use of caches to minimise duplicated operations.</p><p>There are also important differences between the matrix diagram approach, used in SMART, and the offsetlabelled MTBDD approach, described in this paper and implemented in PRISM. Below we outline these differences and consider the effect that they have on the time and space efficiency of the two techniques. In this respect, we are chiefly interested in two main aspects of the implementation: the amount of memory taken up by the data structure and the speed with which information can be extracted from it for numerical solution.</p><p>The most obvious difference is that matrix diagrams are based on the Kronecker representation. This means that to extract a single matrix entry from a matrix diagram, it is necessary not only to trace a path through the data structure (such as with offset-labelled MTB-DDs) but also to perform a number of numerical operations (multiplications and possibly additions). In practice, when all matrix entries are extracted at once, a reduction in the number of operations performed is pos-sible, in the same way that all matrix entries are extracted from an offset-labelled MTBDD via a single traversal of the data structure, as opposed to tracing a separate path for each matrix entry. The advantage of the Kronecker approach, however, is that it will often result in a more compact representation. In particular, in cases where the matrix contains many distinct values, MTBDDs will generally be more expensive by comparison since this results in a larger number of terminal nodes, reducing the capacity for sharing between nodes, and hence increasing the size of the data structure.</p><p>Another important factor to consider is the encoding of row and column indices. For MTBDDs the encoding is into Boolean variables, while for matrix diagrams it is into integer-valued variables. This makes the implementation of MTBDDs simpler and reduces the storage required for each node. However, the number of levels in a matrix diagram (i.e., its height) will generally be smaller. Of course, this makes traversing the data structure during numerical solution faster. Integer-valued variables may also result in a more intuitive encoding of a model in terms of its high-level description.</p><p>All in all, a comparison of the relative merits of the two structures is fairly complex, and it is likely that each approach will fare better in some circumstances. In Table <ref type="table" target="#tab_3">4</ref>, we present some preliminary, empirical results which compare the two. We performed computation of the steady-state probabilities for two CTMC case studies: the Kanban manufacturing system, as used earlier in the paper, and the cyclic server polling system of <ref type="bibr" target="#b43">[44]</ref>. We used the JOR and Jacobi methods, respectively, and ran experiments on a 2 GHz PC with 512 KB of main memory. Equivalent computations were performed for offsetlabelled MTBDDs ("Hybrid"), matrix diagrams ("MDs") and sparse matrices ("Sparse"). For matrix diagrams, we used SMART (version 1.1); for the other two approaches, we used PRISM (version 1.3.1). For all three implementations, the table gives the average time per iteration of numerical computation and the memory required to store the CTMC transition rate matrix. The statistics in Table <ref type="table" target="#tab_3">4</ref> back up our discussion of the various points above. Considering first memory usage, we see that matrix diagrams do indeed provide a more compact representation than offset-labelled MTBDDs on these examples. However, both are negligible compared to the storage requirements of a sparse matrix. In addition, as we will discuss shortly, they are insignificant with respect to the amount of memory needed to store the solution vector. In terms of speed for numerical solution, we observe that offset-labelled MTBDDs and matrix diagrams are essentially comparable, each outperforming the other on one of the examples. Both approaches are slightly slower than sparse but are still competitive in this respect.</p><p>Another issue to bear in mind which is not included in the above discussion or experimental results is the choice of numerical solution method. For solution of linear equation systems, it is often preferable to use the Gauss-Seidel method, rather than the Jacobi method, since it generally converges faster and can be implemented with a single solution vector. An efficient implementation of Gauss-Seidel has been developed for matrix diagrams. A version for offset-labelled MTBDDs, while certainly possible in principle, has yet to be realised in practice. See <ref type="bibr" target="#b56">[57]</ref> for an alternative, where offset-labelled MTBDDs are applied to a block-based variant of Gauss-Seidel. Note also that, for several numerical solution problems, including transient analysis of CTMCs and PCTL model checking of MDPs, this issue does not arise.</p><p>We conclude our discussion of related work by observing that there is one vital issue which unites offsetlabelled MTBDDs, matrix diagrams and other implementations of the Kronecker approach, namely, the storage of solution vectors. While all these techniques typically achieve compact matrix representation, they also require explicit storage of at least one vector of size proportional to the number of states in the model being analysed. This constitutes the limiting factor in terms of the size of model which can be handled.</p><p>Removal of this bottleneck remains an important challenge for the development of these techniques. Attempts to harness any regularity in the solution vectors by storing them symbolically, either with MTBDDs or PDGs (Probabilistic Decision Graphs) <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b16">17]</ref>, have generally failed to resolve the problem. An alternative direction which we are investigating <ref type="bibr" target="#b48">[49,</ref><ref type="bibr" target="#b51">52]</ref> is the development of parallel or distributed techniques, where storage and workload is split across several computers or processors, and out-of-core techniques, where some data structures are stored on disk instead of in main memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>In this paper, we have presented a novel approach to the symbolic implementation of probabilistic model checking for three types of models (DTMCs, MDPs and CTMCs) and two probabilistic logics (PCTL and CSL). In particular, we have focused on the problem of numerical computation. Our techniques overcome the limitations of existing MTBDD implementations by using explicit storage for solution vectors. This has increased the range of models to which MTBDD-based model checking can be applied and significantly improved the speed of the implementation. We also find that we can come close to, and in some cases beat, explicit sparse-matrix-based approaches in terms of solution speed. Furthermore, thanks to the compact model storage provided by MTBDDs, we can handle models an order of magnitude larger.</p><p>Our techniques have been implemented in the probabilistic model checker PRISM <ref type="bibr" target="#b52">[53]</ref>. The tool, its source code and information for a range of case studies to which it has been applied can be found on the PRISM web site <ref type="bibr" target="#b0">[1]</ref>. More detailed information about the techniques presented in this paper can be found in <ref type="bibr" target="#b56">[57]</ref>.</p><p>The development of PRISM is an ongoing project. Research directions to improve its implementation include, as described in the previous chapter, development of parallel, distributed or out-of-core implementations and investigation into more in-depth comparisons between our techniques and Kronecker-based implementations such as matrix diagrams. It would also be interesting to compare the effectiveness of our symbolic approach with that of alternative ideas for handling large probabilistic models, such as using disk-based storage <ref type="bibr" target="#b31">[32,</ref><ref type="bibr" target="#b46">47]</ref> or "on-the-fly" techniques <ref type="bibr" target="#b32">[33]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. An MTBDD R and the function it represents</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 5 .Figure 5</head><label>55</label><figDesc>Fig. 5. Offset-labelled MTBDD traversal algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. The modified MTBDD labelled with explicit sub-matrices</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="3,317.94,58.03,242.86,207.57" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Model statistics</figDesc><table><row><cell>Model</cell><cell>N</cell><cell>States</cell><cell>Transitions</cell></row><row><cell></cell><cell>3</cell><cell>58 400</cell><cell>446 400</cell></row><row><cell>Kanban</cell><cell>4</cell><cell>454 475</cell><cell>3 979 850</cell></row><row><cell>system</cell><cell>5</cell><cell>2 546 432</cell><cell>24 460 016</cell></row><row><cell>(CTMC)</cell><cell>6</cell><cell>11 261 376</cell><cell>115 708 992</cell></row><row><cell></cell><cell>7</cell><cell>41 644 800</cell><cell>450 455 040</cell></row><row><cell></cell><cell>13</cell><cell>8192</cell><cell>1 594 324</cell></row><row><cell>Herman's</cell><cell>15</cell><cell>32 768</cell><cell>14 348 908</cell></row><row><cell>self-</cell><cell>17</cell><cell>131 072</cell><cell>129 140 164</cell></row><row><cell>stabilisation</cell><cell>19</cell><cell>524 288</cell><cell>1 162 261 468</cell></row><row><cell>(DTMC)</cell><cell>21</cell><cell>2 097 152</cell><cell>10 460 353 204</cell></row><row><cell></cell><cell>23</cell><cell>8 388 608</cell><cell>125 524 238 436</cell></row><row><cell>Coin</cell><cell>4</cell><cell>43 136</cell><cell>201 056</cell></row><row><cell>protocol</cell><cell>6</cell><cell>2 376 448</cell><cell>16 607 040</cell></row><row><cell>(MDP)</cell><cell>8</cell><cell>114 757 632</cell><cell>1 069 599 744</cell></row><row><cell></cell><cell>10</cell><cell>5 179 854 848</cell><cell>60 364 590 080</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 .</head><label>2</label><figDesc>Memory requirements</figDesc><table><row><cell>Model</cell><cell>N</cell><cell></cell><cell cols="2">Matrix storage (KB)</cell><cell></cell></row><row><cell></cell><cell></cell><cell>MTBDD</cell><cell>Sparse</cell><cell cols="2">Hybrid Hybrid (optimised)</cell></row><row><cell></cell><cell>3</cell><cell>48.3</cell><cell>5459</cell><cell>58.0</cell><cell>866</cell></row><row><cell>Kanban</cell><cell>4</cell><cell>95.7</cell><cell>48 414</cell><cell>115</cell><cell>858</cell></row><row><cell>system</cell><cell>5</cell><cell>123</cell><cell>296 588</cell><cell>148</cell><cell>671</cell></row><row><cell>(CTMC)</cell><cell>6</cell><cell>154</cell><cell>1 399 955*</cell><cell>185</cell><cell>944</cell></row><row><cell></cell><cell>7</cell><cell>186</cell><cell>5 441 445*</cell><cell>223</cell><cell>1033</cell></row><row><cell></cell><cell>13</cell><cell>11.7</cell><cell>18 715</cell><cell>19.9</cell><cell>493</cell></row><row><cell>Herman's</cell><cell>15</cell><cell>15.8</cell><cell>168 279</cell><cell>27.2</cell><cell>658</cell></row><row><cell>self-</cell><cell>17</cell><cell>20.6</cell><cell>1 513 873*</cell><cell>35.6</cell><cell>825</cell></row><row><cell cols="2">stabilisation 19</cell><cell>25.9</cell><cell>13 622 300*</cell><cell>45.2</cell><cell>992</cell></row><row><cell>(DTMC)</cell><cell>21</cell><cell>31.9</cell><cell>122 590 456*</cell><cell>55.9</cell><cell>456</cell></row><row><cell></cell><cell>23</cell><cell>34.6</cell><cell>1 471 019 937*</cell><cell>63.3</cell><cell>577</cell></row><row><cell>Coin</cell><cell>4</cell><cell>32.7</cell><cell>1651</cell><cell>97.0</cell><cell>695</cell></row><row><cell>protocol</cell><cell>6</cell><cell>84.2</cell><cell>93 948</cell><cell>348</cell><cell>933</cell></row><row><cell>(MDP)</cell><cell>8</cell><cell>168</cell><cell>4 236 739*</cell><cell>902</cell><cell>1276</cell></row><row><cell></cell><cell>10</cell><cell>291</cell><cell>37 011 024*</cell><cell>1922</cell><cell>2387</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 .</head><label>3</label><figDesc>Timing statistics</figDesc><table><row><cell>Model</cell><cell>N</cell><cell cols="2">Construction time (s)</cell><cell></cell><cell cols="3">Average time per iteration (s)</cell></row><row><cell></cell><cell></cell><cell>Hybrid</cell><cell>Hybrid (optimised)</cell><cell cols="2">MTBDD Sparse</cell><cell>Hybrid</cell><cell>Hybrid (optimised)</cell></row><row><cell></cell><cell>3</cell><cell>0.01</cell><cell>0.03</cell><cell>45.5</cell><cell>0.04</cell><cell>0.33</cell><cell>0.04</cell></row><row><cell>Kanban</cell><cell>4</cell><cell>0.01</cell><cell>0.10</cell><cell>-</cell><cell>0.44</cell><cell>4.32</cell><cell>0.48</cell></row><row><cell>system</cell><cell>5</cell><cell>0.02</cell><cell>0.21</cell><cell>-</cell><cell>2.85</cell><cell>24.41</cell><cell>3.09</cell></row><row><cell>(CTMC)</cell><cell>6</cell><cell>0.04</cell><cell>0.49</cell><cell>-</cell><cell>-</cell><cell>113</cell><cell>15.6</cell></row><row><cell></cell><cell>7</cell><cell>0.06</cell><cell>0.88</cell><cell>-</cell><cell>-</cell><cell>437</cell><cell>61.9</cell></row><row><cell></cell><cell>13</cell><cell>0.01</cell><cell>0.03</cell><cell>2.02</cell><cell>0.15</cell><cell>0.25</cell><cell>0.09</cell></row><row><cell>Herman's</cell><cell>15</cell><cell>0.01</cell><cell>0.05</cell><cell>13.2</cell><cell>1.40</cell><cell>2.22</cell><cell>0.80</cell></row><row><cell>self-</cell><cell>17</cell><cell>0.05</cell><cell>0.10</cell><cell>78.1</cell><cell>-</cell><cell>20.6</cell><cell>7.26</cell></row><row><cell>stabilisation</cell><cell>19</cell><cell>0.18</cell><cell>0.33</cell><cell>803</cell><cell>-</cell><cell>187</cell><cell>66.2</cell></row><row><cell>(DTMC)</cell><cell>21</cell><cell>0.71</cell><cell>3.27</cell><cell>-</cell><cell>-</cell><cell>1644</cell><cell>525</cell></row><row><cell></cell><cell>23</cell><cell>2.68</cell><cell>35.1</cell><cell>-</cell><cell>-</cell><cell>20 751</cell><cell>7161</cell></row><row><cell>Coin</cell><cell>4</cell><cell>0.05</cell><cell>0.08</cell><cell>0.17</cell><cell>0.03</cell><cell>0.07</cell><cell>0.04</cell></row><row><cell>protocol</cell><cell>6</cell><cell>1.10</cell><cell>1.16</cell><cell>1.01</cell><cell>1.04</cell><cell>5.58</cell><cell>3.02</cell></row><row><cell>(MDP)</cell><cell>8</cell><cell>-</cell><cell>-</cell><cell>3.17</cell><cell>-</cell><cell>-</cell><cell>-</cell></row><row><cell></cell><cell>10</cell><cell>-</cell><cell>-</cell><cell>8.38</cell><cell>-</cell><cell>-</cell><cell>-</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 4 .</head><label>4</label><figDesc>Comparison of offset-labelled MTBDDs, matrix diagrams and sparse matrices</figDesc><table><row><cell>Model</cell><cell>N</cell><cell>States</cell><cell cols="3">Average time/iter (s)</cell><cell cols="3">Matrix storage (KB)</cell></row><row><cell></cell><cell></cell><cell></cell><cell>Hybrid</cell><cell>MDs</cell><cell cols="3">Sparse Hybrid MDs</cell><cell>Sparse</cell></row><row><cell></cell><cell>2</cell><cell>4600</cell><cell>0.0004</cell><cell cols="2">0.0004 0.0002</cell><cell>39.5</cell><cell>1.2</cell><cell>348</cell></row><row><cell>Kanban</cell><cell>3</cell><cell>58 400</cell><cell>0.01</cell><cell>0.007</cell><cell>0.005</cell><cell>58.0</cell><cell>2.6</cell><cell>5459</cell></row><row><cell>system</cell><cell>4</cell><cell>454 475</cell><cell>0.08</cell><cell>0.07</cell><cell>0.05</cell><cell>115</cell><cell>4.9</cell><cell>48 414</cell></row><row><cell>(CTMC)</cell><cell>5</cell><cell>2 546 432</cell><cell>0.46</cell><cell>0.45</cell><cell>0.32</cell><cell>148</cell><cell>8.3</cell><cell>296 588</cell></row><row><cell></cell><cell>6</cell><cell>11 261 376</cell><cell>2.28</cell><cell>2.00</cell><cell>-</cell><cell>185</cell><cell>12.9</cell><cell>-</cell></row><row><cell></cell><cell>10</cell><cell>15 360</cell><cell>0.002</cell><cell>0.002</cell><cell>0.001</cell><cell>22.2</cell><cell>1.4</cell><cell>1110</cell></row><row><cell>Cyclic</cell><cell>12</cell><cell>73 728</cell><cell>0.01</cell><cell>0.01</cell><cell>0.007</cell><cell>30.8</cell><cell>1.7</cell><cell>6192</cell></row><row><cell>server</cell><cell>14</cell><cell>344 064</cell><cell>0.04</cell><cell>0.08</cell><cell>0.04</cell><cell>40.9</cell><cell>2.0</cell><cell>32 928</cell></row><row><cell>polling</cell><cell>15</cell><cell>737 280</cell><cell>0.10</cell><cell>0.16</cell><cell>0.08</cell><cell>46.5</cell><cell>2.2</cell><cell>74 880</cell></row><row><cell>system</cell><cell>16</cell><cell>1 572 864</cell><cell>0.24</cell><cell>0.35</cell><cell>0.19</cell><cell>52.3</cell><cell>2.3</cell><cell>168 960</cell></row><row><cell cols="2">(CTMC) 17</cell><cell>3 342 336</cell><cell>0.52</cell><cell>0.79</cell><cell>-</cell><cell>59.0</cell><cell>2.5</cell><cell>-</cell></row><row><cell></cell><cell>18</cell><cell>7 077 888</cell><cell>1.16</cell><cell>1.66</cell><cell>-</cell><cell>65.5</cell><cell>2.6</cell><cell>-</cell></row></table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<ptr target="www.cs.bham.ac.uk/∼dxp/prism" />
		<title level="m">PRISM web site</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Reactive modules</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Henzinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th annual IEEE symposium on logic in computer science (LICS&apos;96)</title>
		<meeting>the 11th annual IEEE symposium on logic in computer science (LICS&apos;96)<address><addrLine>New Brunswick, NJ; New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="1996-07">1996. July 1996</date>
			<biblScope unit="page" from="207" to="218" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Fast randomized consensus using shared memory</title>
		<author>
			<persName><forename type="first">J</forename><surname>Aspnes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Herlihy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J Algorithms</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="441" to="460" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Verifying continuous time Markov chains</title>
		<author>
			<persName><forename type="first">A</forename><surname>Aziz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sanwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Singhal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Brayton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th international conference on computer aided verification (CAV&apos;96)</title>
		<title level="s">Lecture notes in computer science</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Henzinger</surname></persName>
		</editor>
		<meeting>the 8th international conference on computer aided verification (CAV&apos;96)<address><addrLine>New Brunswick, NJ; Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996-07">1996. July-August 1996</date>
			<biblScope unit="page" from="269" to="276" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Algebraic decision diagrams and their applications</title>
		<author>
			<persName><forename type="first">I</forename><surname>Bahar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Frohm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gaona</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Hachtel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Macii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Somenzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the international conference on computer-aided design (ICCAD&apos;93)</title>
		<meeting>the international conference on computer-aided design (ICCAD&apos;93)<address><addrLine>Santa Clara, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993-11">1993. November 1993. 1997</date>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="171" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">On algorithmic verification methods for probabilistic systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Baier</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<pubPlace>Mannheim, Germany</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Fakultät für Mathematik &amp; Informatik, Universität Mannheim</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Habilitation thesis</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Symbolic model checking for probabilistic processes</title>
		<author>
			<persName><forename type="first">C</forename><surname>Baier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Hartonas-Garmhausen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kwiatkowska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ryan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th international colloquium on automata, languages and programming (ICALP&apos;97)</title>
		<title level="s">Lecture notes in computer science</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Degano</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Gorrieri</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Marchetti-Spaccamela</surname></persName>
		</editor>
		<meeting>the 24th international colloquium on automata, languages and programming (ICALP&apos;97)<address><addrLine>Bologna, Italy; Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997-07">1997. July 1997</date>
			<biblScope unit="page" from="430" to="440" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Model checking continuous-time Markov chains by transient analysis</title>
		<author>
			<persName><forename type="first">C</forename><surname>Baier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Haverkort</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Hermanns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J-P</forename><surname>Katoen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th international conference on computer aided verification (CAV&apos;00)</title>
		<title level="s">Lecture notes in computer science</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Emerson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Sistla</surname></persName>
		</editor>
		<meeting>the 12th international conference on computer aided verification (CAV&apos;00)<address><addrLine>Chicago; Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000-07">2000. July 2000</date>
			<biblScope unit="page" from="358" to="372" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Approximate symbolic model checking of continuous-time Markov chains</title>
		<author>
			<persName><forename type="first">C</forename><surname>Baier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J-P</forename><surname>Katoen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Hermanns</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th international conference on concurrency theory (CONCUR&apos;99)</title>
		<title level="s">Lecture notes in computer science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Baeten</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Mauw</surname></persName>
		</editor>
		<meeting>the 10th international conference on concurrency theory (CONCUR&apos;99)<address><addrLine>Eindhoven, The Netherlands; Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999-08">1999. August 1999</date>
			<biblScope unit="page" from="146" to="161" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Model checking for a probabilistic branching time logic with fairness</title>
		<author>
			<persName><forename type="first">C</forename><surname>Baier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kwiatkowska</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Distrib Comput</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="125" to="155" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A toolbox for functional and quantitative analysis of DEDS</title>
		<author>
			<persName><forename type="first">F</forename><surname>Bause</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Buchholz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kemper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Computer Performance Evaluation (TOOLS&apos;98)</title>
		<title level="s">Lecture notes in computer science</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Puigjaner</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">N</forename><surname>Savino</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Serra</surname></persName>
		</editor>
		<meeting>Computer Performance Evaluation (TOOLS&apos;98)<address><addrLine>Palma de Mallorca, Spain; Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998-09">1998. September 1998</date>
			<biblScope unit="page" from="356" to="359" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Model checking of probabilistic and nondeterministic systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bianco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>De Alfaro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th conference on foundations of software technology and theoretical computer science</title>
		<title level="s">Lecture notes in computer science</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Thiagarajan</surname></persName>
		</editor>
		<meeting>the 15th conference on foundations of software technology and theoretical computer science<address><addrLine>Bangalore, India; Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1995-12">1995. December 1995</date>
			<biblScope unit="page" from="499" to="513" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Improving the variable ordering of OBDDs is NP-complete</title>
		<author>
			<persName><forename type="first">B</forename><surname>Bollig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Wegner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Comput</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="993" to="1006" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">On the representation of probabilities over structured domains</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bozga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Maler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th international conference on computer aided verification (CAV&apos;99)</title>
		<title level="s">Lecture notes in computer science</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Halbwachs</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Peled</surname></persName>
		</editor>
		<meeting>the 11th international conference on computer aided verification (CAV&apos;99)<address><addrLine>Trento, Italy; Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999-07">1999. July 1999</date>
			<biblScope unit="page" from="261" to="273" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Graph-based algorithms for Boolean function manipulation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bryant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Comput C</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="677" to="691" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Complexity of Kronecker operations on sparse matrices with applications to the solution of Markov models</title>
		<author>
			<persName><forename type="first">P</forename><surname>Buchholz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ciardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Donatelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kemper</surname></persName>
		</author>
		<idno>97-66</idno>
		<imprint>
			<date type="published" when="1997">1997</date>
			<pubPlace>Hampton, VA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Institute for Computer Applications in Science and Engineering</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">ICASE Report</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Compact representations of probability distributions in the analysis of superposed GSPNs</title>
		<author>
			<persName><forename type="first">P</forename><surname>Buchholz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kemper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th international workshop on Petri nets and performance models (PNPM&apos;01)</title>
		<editor>
			<persName><forename type="first">R</forename><surname>German</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Haverkort</surname></persName>
		</editor>
		<meeting>the 9th international workshop on Petri nets and performance models (PNPM&apos;01)<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="81" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Symbolic model checking: 10 20 states and beyond</title>
		<author>
			<persName><forename type="first">J</forename><surname>Burch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Mcmillan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hwang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th annual IEEE symposium on logic in computer science (LICS&apos;90)</title>
		<meeting>the 5th annual IEEE symposium on logic in computer science (LICS&apos;90)<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="428" to="439" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Great-SPN 1.7: Graphical editor and analyzer for timed and stochastic Petri nets</title>
		<author>
			<persName><forename type="first">G</forename><surname>Chiola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Franceschinis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gaeta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ribaudo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Perform Eval</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="47" to="68" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">SMART: simulation and Markovian analyser for reliability and timing</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ciardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Miner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd international computer performance and dependability symposium (IPDS&apos;96)</title>
		<meeting>the 2nd international computer performance and dependability symposium (IPDS&apos;96)<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page">60</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A data structure for the efficient Kronecker solution of GSPNs</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ciardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Miner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th international workshop on Petri nets and performance models (PNPM&apos;99)</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Buchholz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Silva</surname></persName>
		</editor>
		<meeting>the 8th international workshop on Petri nets and performance models (PNPM&apos;99)<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="22" to="31" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">On the use of Kronecker operators for the solution of generalized stocastic Petri nets</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ciardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tilgner</surname></persName>
		</author>
		<idno>96-35</idno>
		<imprint>
			<date type="published" when="1996">1996</date>
			<pubPlace>Hampton, VA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Institute for Computer Applications in Science and Engineering</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">ICASE Report</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Multi-terminal binary decision diagrams: an efficient data structure for matrix representation</title>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fujita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mcgeer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Mcmillan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the international workshop on logic synthesis (IWLS&apos;93)</title>
		<meeting>the international workshop on logic synthesis (IWLS&apos;93)<address><addrLine>Tahoe City, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993-05">1993. May 1993. 1997</date>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="149" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Spectral transforms for large Boolean functions with applications to technology mapping</title>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Mcmillan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fujita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th design automation conference (DAC&apos;93)</title>
		<meeting>the 30th design automation conference (DAC&apos;93)<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1993">1993. 1997</date>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="137" to="148" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Möbius: An extensible tool for performance and dependability modeling</title>
		<author>
			<persName><forename type="first">D</forename><surname>Daly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Deavours</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Doyle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Webster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Sanders</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th international conference on modelling techniques and tools for computer performance evaluation (TOOLS&apos;00)</title>
		<title level="s">Lecture notes in computer science</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Haverkort</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Bohnenkamp</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Smith</surname></persName>
		</editor>
		<meeting>the 11th international conference on modelling techniques and tools for computer performance evaluation (TOOLS&apos;00)<address><addrLine>Schaumburg, IL; Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000-03">2000. March 2000</date>
			<biblScope unit="page" from="332" to="336" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Reachability analysis of probabilistic systems by successive refinements</title>
		<author>
			<persName><forename type="first">P</forename><surname>D'argenio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Jeannet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Larsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st joint international workshop on process algebra and probabilistic methods, performance modeling and verification (PAPM/PROBMIV&apos;01)</title>
		<title level="s">Lecture notes in computer science</title>
		<editor>
			<persName><forename type="first">De</forename><surname>Alfaro</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><surname>Gilmore</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename></persName>
		</editor>
		<meeting>the 1st joint international workshop on process algebra and probabilistic methods, performance modeling and verification (PAPM/PROBMIV&apos;01)<address><addrLine>Aachen, Germany; Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001-09">2001. September 2001</date>
			<biblScope unit="page" from="39" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Formal verification of probabilistic systems</title>
		<author>
			<persName><forename type="first">De</forename><surname>Alfaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<pubPlace>Stanford, CA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Stanford University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Temporal logics for the specification of performance and reliability</title>
		<author>
			<persName><forename type="first">De</forename><surname>Alfaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the symposium on theoretical aspects of computer science (STACS&apos;97)</title>
		<title level="s">Lecture notes in computer science</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Reischuk</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Morvan</surname></persName>
		</editor>
		<meeting>the symposium on theoretical aspects of computer science (STACS&apos;97)<address><addrLine>Lübeck, Germany; Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997-02">1997. February-March 1997</date>
			<biblScope unit="page" from="165" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">How to specify and verify the long-run average behavior of probabilistic systems</title>
		<author>
			<persName><forename type="first">De</forename><surname>Alfaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th annual IEEE symposium on logic in computer science (LICS&apos;98)</title>
		<meeting>the 13th annual IEEE symposium on logic in computer science (LICS&apos;98)<address><addrLine>Indianapolis, IN</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998-06">1998. June 1998</date>
			<biblScope unit="page" from="454" to="465" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Computing minimum and maximum reachability times in probabilistic systems</title>
		<author>
			<persName><forename type="first">De</forename><surname>Alfaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th international conference on concurrency theory (CONCUR&apos;99)</title>
		<title level="s">Lecture notes in computer science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Baeten</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Mauw</surname></persName>
		</editor>
		<meeting>the 10th international conference on concurrency theory (CONCUR&apos;99)<address><addrLine>Eindhoven, The Netherlands; Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999-08">1999. August 1999</date>
			<biblScope unit="page" from="66" to="81" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Symbolic model checking of concurrent probabilistic processes using MTBDDs and the Kronecker representation</title>
		<author>
			<persName><forename type="first">De</forename><surname>Alfaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Kwiatkowska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Norman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Parker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Segala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th international conference on tools and algorithms for the construction and analysis of systems (TACAS&apos;00)</title>
		<title level="s">Lecture notes in computer science</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Graf</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Schwartzbach</surname></persName>
		</editor>
		<meeting>the 6th international conference on tools and algorithms for the construction and analysis of systems (TACAS&apos;00)<address><addrLine>Berlin; Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000-03">2000. March-April 2000</date>
			<biblScope unit="page" from="395" to="410" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">An efficient disk-based tool for solving very large Markov models</title>
		<author>
			<persName><forename type="first">D</forename><surname>Deavours</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Sanders</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th international conference on modelling techniques and tools (TOOLS&apos;97)</title>
		<title level="s">Lecture notes in computer science</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Marie</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Plateau</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Calzarossa</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Rubino</surname></persName>
		</editor>
		<meeting>the 9th international conference on modelling techniques and tools (TOOLS&apos;97)<address><addrLine>St Malo, France; Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997-06">1997. June 1997</date>
			<biblScope unit="page" from="58" to="71" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">On-the-fly&quot; solution techniques for stochastic Petri nets and extensions</title>
		<author>
			<persName><forename type="first">D</forename><surname>Deavours</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Sanders</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Softw Eng</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="889" to="902" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">The PEPA workbench: a tool to support a process algebra-based approach to performance modelling</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gilmore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hillston</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th international conference on modelling techniques and tools for computer performance evaluation</title>
		<title level="s">Lecture notes in computer science</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Haring</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Kotsis</surname></persName>
		</editor>
		<meeting>the 7th international conference on modelling techniques and tools for computer performance evaluation<address><addrLine>Vienna; Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1994-05">1994. May 1994</date>
			<biblScope unit="volume">794</biblScope>
			<biblScope unit="page" from="353" to="368" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Probabilistic analysis of large finite state machines</title>
		<author>
			<persName><forename type="first">G</forename><surname>Hachtel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Macii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Somenzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31st design automation conference (DAC&apos;94)</title>
		<meeting>the 31st design automation conference (DAC&apos;94)<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="270" to="275" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Markovian analysis of large finite state machines</title>
		<author>
			<persName><forename type="first">G</forename><surname>Hachtel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Macii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Somenzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans CAD</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1479" to="1493" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">A logic for reasoning about time and probability</title>
		<author>
			<persName><forename type="first">H</forename><surname>Hansson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Jonsson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Aspects Comput</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="512" to="535" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Prob-Verus: probabilistic symbolic model checking</title>
		<author>
			<persName><forename type="first">V</forename><surname>Hartonas-Garmhausen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Campos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Clarke</forename><forename type="middle">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th international AMAST workshop on real-time and probabilistic systems (ARTS&apos;99)</title>
		<title level="s">Lecture notes in computer science</title>
		<editor>
			<persName><forename type="first">J-P</forename><surname>Katoen</surname></persName>
		</editor>
		<meeting>the 5th international AMAST workshop on real-time and probabilistic systems (ARTS&apos;99)<address><addrLine>Bamburg, Germany; Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999-05">1999. May 1999</date>
			<biblScope unit="page" from="96" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Probabilistic self-stabilization</title>
		<author>
			<persName><forename type="first">T</forename><surname>Herman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf Process Lett</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="63" to="67" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Compositional performance modelling with the TIPPtool</title>
		<author>
			<persName><forename type="first">H</forename><surname>Hermanns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Herzog</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Klehmet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Mertsiotakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Siegle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Perform Eval</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">1-4</biblScope>
			<biblScope unit="page" from="5" to="35" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">A Markov chain model checker</title>
		<author>
			<persName><forename type="first">H</forename><surname>Hermanns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J-P</forename><surname>Katoen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meyer-Kayser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Siegle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th international conference on tools and algorithms for the construction and analysis of systems (TACAS&apos;00)</title>
		<title level="s">Lecture notes in computer science</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Graf</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Schwartzbach</surname></persName>
		</editor>
		<meeting>the 6th international conference on tools and algorithms for the construction and analysis of systems (TACAS&apos;00)<address><addrLine>Berlin; Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000-03">2000. March-April 2000</date>
			<biblScope unit="page" from="347" to="362" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">On the use of MTBDDs for performability analysis and verification of stochastic systems</title>
		<author>
			<persName><forename type="first">H</forename><surname>Hermanns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kwiatkowska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Norman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Parker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Siegle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J Logic Algebr Programm</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="23" to="67" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Multi terminal binary decision diagrams to represent and analyse continuous time Markov chains</title>
		<author>
			<persName><forename type="first">H</forename><surname>Hermanns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meyer-Kayser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Siegle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd international workshop on numerical solution of Markov chains (NSMC&apos;99)</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Plateau</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><surname>Stewart</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Silva</surname></persName>
		</editor>
		<meeting>the 3rd international workshop on numerical solution of Markov chains (NSMC&apos;99)</meeting>
		<imprint>
			<publisher>Spain</publisher>
			<date type="published" when="1999-09">1999. September</date>
			<biblScope unit="page" from="188" to="207" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Stochastic Petri net models of polling systems</title>
		<author>
			<persName><forename type="first">O</forename><surname>Ibe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Trivedi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE J Select Areas Commun</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1649" to="1657" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Symmetry breaking in distributed networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Itai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rodeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf Comput</title>
		<imprint>
			<biblScope unit="volume">88</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="60" to="87" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Faster and symbolic CTMC model checking</title>
		<author>
			<persName><forename type="first">J-P</forename><surname>Katoen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kwiatkowska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Norman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Parker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st joint international workshop on process algebra and probabilistic methods, performance modeling and verification (PAPM/PROBMIV&apos;01)</title>
		<title level="s">Lecture notes in computer science</title>
		<editor>
			<persName><forename type="first">L</forename><surname>De Alfaro</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Gilmore</surname></persName>
		</editor>
		<meeting>the 1st joint international workshop on process algebra and probabilistic methods, performance modeling and verification (PAPM/PROBMIV&apos;01)<address><addrLine>Aachen, Germany; Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001-09">2001. September 2001</date>
			<biblScope unit="page" from="23" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Distributed disk-based solution techniques for large Markov models</title>
		<author>
			<persName><forename type="first">W</forename><surname>Knottenbelt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Harrison</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd international workshop on numerical solution of Markov chains (NSMC&apos;99)</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Plateau</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><surname>Stewart</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Silva</surname></persName>
		</editor>
		<meeting>the 3rd international workshop on numerical solution of Markov chains (NSMC&apos;99)<address><addrLine>Spain</addrLine></address></meeting>
		<imprint>
			<publisher>Prensas Universitarias de Zaragoza</publisher>
			<date type="published" when="1999-09">1999. September 1999</date>
			<biblScope unit="page" from="58" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Deriving symbolic representations from stochastic process algebras</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kuntz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Siegle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd joint international workshop on process algebra and probabilistic methods, performance modeling and verification (PAPM/PROBMIV&apos;02)</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Hermanns</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Segala</surname></persName>
		</editor>
		<meeting>the 2nd joint international workshop on process algebra and probabilistic methods, performance modeling and verification (PAPM/PROBMIV&apos;02)<address><addrLine>Copenhagen; Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002-07">2002. July 2002</date>
			<biblScope unit="page" from="188" to="206" />
		</imprint>
	</monogr>
	<note>Lecture notes in computer science</note>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Out-of-core solution of large linear systems of equations arising from stochastic modelling</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kwiatkowska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mehmood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd joint international workshop on process algebra and probabilistic methods, performance modeling and verification (PAPM/PROBMIV&apos;02)</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Hermanns</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Segala</surname></persName>
		</editor>
		<meeting>the 2nd joint international workshop on process algebra and probabilistic methods, performance modeling and verification (PAPM/PROBMIV&apos;02)<address><addrLine>Copenhagen; Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002-07">2002. July 2002</date>
			<biblScope unit="page" from="135" to="151" />
		</imprint>
	</monogr>
	<note>Lecture notes in computer science</note>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<title level="m" type="main">Symbolic model checking of concurrent probabilistic systems using MTBDDs and Simplex</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kwiatkowska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Norman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Parker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Segala</surname></persName>
		</author>
		<idno>CSR-99-1</idno>
		<imprint>
			<date type="published" when="1999">1999</date>
			<pubPlace>Birmingham, UK</pubPlace>
		</imprint>
		<respStmt>
			<orgName>School of Computer Science, University of Birmingham</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Automated verification of a randomized distributed consensus protocol using Cadence SMV and PRISM</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kwiatkowska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Norman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Segala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th international conference on computer aided verification (CAV&apos;01)</title>
		<title level="s">Lecture notes in computer science</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Berry</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Comon</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Finkel</surname></persName>
		</editor>
		<meeting>the 13th international conference on computer aided verification (CAV&apos;01)<address><addrLine>Paris; Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001-07">2001. July 2001</date>
			<biblScope unit="page" from="194" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">A symbolic out-of-core solution method for Markov models</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kwiatkowska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mehmood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Norman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Parker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the workshop on parallel and distributed model checking (PDMC&apos;02)</title>
		<meeting>the workshop on parallel and distributed model checking (PDMC&apos;02)<address><addrLine>Brno, Czech Republic; Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2002-08">2002a. August 2002</date>
		</imprint>
	</monogr>
	<note>Electronic notes in theoretical computer science</note>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">PRISM: Probabilistic symbolic model checker</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kwiatkowska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Norman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Parker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th international conference on modelling techniques and tools for computer performance evaluation (TOOLS&apos;02)</title>
		<title level="s">Lecture notes in computer science</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Field</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Harrison</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Bradley</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">U</forename><surname>Harder</surname></persName>
		</editor>
		<meeting>the 12th international conference on modelling techniques and tools for computer performance evaluation (TOOLS&apos;02)<address><addrLine>London; Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002-04">2002b. April 2002</date>
			<biblScope unit="page" from="200" to="204" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Probabilistic model checking of deadline properties in the IEEE 1394 FireWire root contention protocol</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kwiatkowska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Norman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sproston</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Aspects Comput</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="295" to="318" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<title level="m" type="main">Symbolic model checking</title>
		<author>
			<persName><forename type="first">K</forename><surname>Mcmillan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>Kluwer</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Dordrecht</note>
</biblStruct>

<biblStruct xml:id="b55">
	<monogr>
		<title level="m" type="main">Data structures for the analysis of large structured Markov chains</title>
		<author>
			<persName><forename type="first">A</forename><surname>Miner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<pubPlace>Williamsburg, VA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, College of William &amp; Mary</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b56">
	<monogr>
		<title level="m" type="main">Implementation of symbolic model checking for probabilistic systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Parker</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<pubPlace>Birmingham, UK</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of Birmingham</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">On the stochastic structure of parallelism and synchronisation models for distributed algorithms</title>
		<author>
			<persName><forename type="first">B</forename><surname>Plateau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1985 ACM SIGMETRICS conference on measurement and modeling of computer systems</title>
		<meeting>the 1985 ACM SIGMETRICS conference on measurement and modeling of computer systems<address><addrLine>Austin, TX</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985-08">1985. August 1985</date>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="147" to="153" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">The UltraSAN modeling environment</title>
		<author>
			<persName><forename type="first">W</forename><surname>Sanders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Obal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Qureshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Widjanarko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Perform Eval</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="89" to="115" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<monogr>
		<title level="m" type="main">CUDD: Colorado University decision diagram package. Public software</title>
		<author>
			<persName><forename type="first">F</forename><surname>Somenzi</surname></persName>
		</author>
		<ptr target="http://vlsi.colorado.edu/∼fabio/" />
		<imprint>
			<date type="published" when="1997">1997</date>
			<pubPlace>Colorado Univeristy, Boulder</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">MARCA: Markov chain analyser, a software package for Markov modelling</title>
		<author>
			<persName><forename type="first">W</forename><surname>Stewart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of NSMC&apos;91</title>
		<editor>
			<persName><forename type="first">W</forename><surname>Stewart</surname></persName>
		</editor>
		<meeting>NSMC&apos;91<address><addrLine>Raleigh, NC; New York</addrLine></address></meeting>
		<imprint>
			<publisher>Marcel Dekker</publisher>
			<date type="published" when="1990">1991. January 1990</date>
			<biblScope unit="page" from="37" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">The complexity of the optimal variable ordering problems of shared binary decision diagrams</title>
		<author>
			<persName><forename type="first">S</forename><surname>Tani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hamaguchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yajima</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th international symposium on algorithms and computation (ISAAC&apos;93)</title>
		<title level="s">Lecture notes in computer science</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Ng</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Raghavan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">N</forename><surname>Balasubramanian</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Chin</surname></persName>
		</editor>
		<meeting>the 4th international symposium on algorithms and computation (ISAAC&apos;93)<address><addrLine>Hong Kong; Berlin Heidelberg New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1993">1993. 1993</date>
			<biblScope unit="volume">762</biblScope>
			<biblScope unit="page" from="389" to="398" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Symbolic techniques for performance analysis of timed circuits based on average time separation of events</title>
		<author>
			<persName><forename type="first">A</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Beerel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd international symposium on advanced research in asynchronous circuits and systems (ASYNC&apos;97)</title>
		<meeting>the 3rd international symposium on advanced research in asynchronous circuits and systems (ASYNC&apos;97)<address><addrLine>Eindhoven, The Netherlands; New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="1997-04">1997. April 1997</date>
			<biblScope unit="page" from="64" to="75" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
