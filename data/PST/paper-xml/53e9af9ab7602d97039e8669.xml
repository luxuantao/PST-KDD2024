<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Approximating operators and semantics for abstract dialectical frameworks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2013-09-23">23 September 2013</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Hannes</forename><surname>Strass</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Institute</orgName>
								<orgName type="institution">Leipzig University</orgName>
								<address>
									<addrLine>Augustusplatz 10</addrLine>
									<postCode>04109</postCode>
									<settlement>Leipzig</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Approximating operators and semantics for abstract dialectical frameworks</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2013-09-23">23 September 2013</date>
						</imprint>
					</monogr>
					<idno type="MD5">7C106A4EA2BA26E5F3ACAD23E9FEC9B6</idno>
					<idno type="DOI">10.1016/j.artint.2013.09.004</idno>
					<note type="submission">Received 9 October 2012 Received in revised form 10 September 2013 Accepted 17 September 2013</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:57+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Abstract dialectical frameworks Abstract argumentation frameworks Logic programming Fixpoint semantics Approximations Nonmonotonic reasoning</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We provide a systematic in-depth study of the semantics of abstract dialectical frameworks (ADFs), a recent generalisation of Dung's abstract argumentation frameworks. This is done by associating with an ADF its characteristic one-step consequence operator and defining various semantics for ADFs as different fixpoints of this operator. We first show that several existing semantical notions are faithfully captured by our definition, then proceed to define new ADF semantics and show that they are proper generalisations of existing argumentation semantics from the literature. Most remarkably, this operatorbased approach allows us to compare ADFs to related nonmonotonic formalisms like Dung argumentation frameworks and propositional logic programs. We use polynomial, faithful and modular translations to relate the formalisms, and our results show that both abstract argumentation frameworks and abstract dialectical frameworks are at most as expressive as propositional normal logic programs.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>In recent years, abstract argumentation frameworks (AFs) <ref type="bibr" target="#b13">[14]</ref> have become increasingly popular in the artificial intelligence community. An AF can be seen as a directed graph where the nodes are arguments whose internal structure is abstracted away, and where the edges encode a notion of attack between arguments. Part of the reason for the interest in AFs may be that in spite of their conceptual simplicity, there exist many different semantics with different properties in terms of characterisation, existence and uniqueness. Notwithstanding their success, their expressive capabilities are somewhat limited, as has been recognised many times in the literature: often it is inadequate to model argumentation scenarios having as only means of expression arguments attacking each other. There have been several proposals towards generalising AFs. To cite only a few examples, Prakken and Sartor <ref type="bibr" target="#b33">[34]</ref> add priorities amongst arguments that are constructed from prioritised logic programming rules; Nielsen and Parsons <ref type="bibr" target="#b29">[30]</ref> introduced attacks from sets of arguments; Cayrol and Lagasquie-Schiex <ref type="bibr" target="#b8">[9]</ref> presented bipolar argumentation frameworks, in which arguments can also support each other; and Modgil <ref type="bibr" target="#b27">[28]</ref> proposed attacks on attacks with the aim of reasoning about preferences on the object level.</p><p>As a general way to overcome the restrictions of Dung's AFs while staying on the abstract level, Brewka and Woltran <ref type="bibr" target="#b2">[3]</ref> introduced abstract dialectical frameworks (ADFs). Just like AFs, these ADFs treat arguments (called statements there) as abstract, atomic entities whose contents are not further analysed. But instead of expressing for an argument only its attackers, ADFs associate with each statement an acceptance condition that determines the acceptance status of a statement given the acceptance status of its parent statements. These parents are the statements which have a say on whether the statement in question can or must (not) be accepted. In this way, AFs are recovered in the language of ADFs by specifying for each statement the acceptance condition "accept if and only if none of the attackers is accepted."</p><p>The abstract nature of Dung's AFs makes them well-suited as a target language for translations from more expressive formalisms. To be more precise, it is common to use expressive languages to model more concrete (argumentation) scenarios, and to provide these original expressive languages with semantics by translating them into Dung AFs <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b39">40]</ref>. However, Caminada and Amgoud <ref type="bibr" target="#b7">[8]</ref> observed that it is not always immediately clear how such translations into AFs should be defined, even for a fairly simple source formalism. A major problem that they encountered were unintended conclusions that indirectly led to inconsistency. In the same paper, Caminada and Amgoud also proposed solutions to these problems, where during translation additional precautions have to be taken to avoid undesired anomalies. Let us explain in more detail what this means in general for abstractions among knowledge representation (KR) languages.</p><p>First of all, by an abstraction we mean a translation between languages that may disregard some information. Instantiating an abstract language is then the process of translating a more concrete, more expressive language into the abstract, less expressive language. This entails that there is no dichotomy "knowledge representation language vs. abstraction formalism" -any KR language abstracts to a greater or lesser extent, and can thus be used for abstraction purposes. Whether any specific language is to be used for direct, concrete representation or for abstraction of another language depends entirely on the application domain at hand.</p><p>Naturally, we are interested in those abstractions that preserve the meaning of translated language elements in some sense. As an example, consider the language {yes, no}. It is very simple and can abstract from any decision problem whatsoever. Furthermore it is trivial to devise an intuitively correct semantics for it. But to faithfully instantiate this language to a particular decision problem -say, the satisfiability problem of propositional logic -, the problem must be solved during translation, for otherwise the abstraction would not be meaningful at all. At the other end of the spectrum, for any language L, an "abstraction" is provided by L itself. In contrast to the two-element target language {yes, no}, using L as target language makes it trivial to translate L into the abstraction, but the target language does in fact not abstract at all and devising a semantics for the abstraction is as hard as devising a semantics for the original language. Thus abstraction proper should indeed disregard some information, but not too much of it. In the example above, the fact that the language {yes, no} can abstract away from any decision problem is no argument for its usefulness as an abstraction formalism, since its expressive power is clearly too poor to model real problems (meaning problems that are syntactically different from their solutions). Consequently the expressiveness of a language is important when using it as a target language for abstraction. More specifically, a suitable target language for abstraction must be expressive enough to model important problem aspects, while being sufficiently abstract to ignore irrelevant details.</p><p>So to be able to use a formalism for abstraction, we obviously need a clear picture of its capabilities as a KR language, especially its expressive power in comparison to other languages, and about the properties of its semantics. It is the main objective of this paper to provide this information for abstract dialectical frameworks. For this purpose, we technically view ADFs as KR languages -but of course our work has ramifications for ADFs as abstraction formalisms. In the same way as there is no single intended semantics for argumentation frameworks, there is also no single perfect formalism for abstraction. But to be able to make an informed choice, it is of great importance to understand the inherent relationships between different available options. Our results will facilitate this choice and be an aid to anyone wishing to abstract from concrete argumentation languages; especially, our results will help them decide if they want to translate into AFs or into ADFs.</p><p>But why, after all, should there be a choice to be made between AFs and ADFs? Here, the additional expressiveness of ADFs in comparison to AFs comes into play. As we will see throughout the paper, the well-known distinction between supported and stable models from logic programming is present in ADFs but is missing in AFs. In a different disguise, this same distinction also materialises as Moore expansions vs. Reiter extensions in nonmonotonic logics <ref type="bibr" target="#b11">[12]</ref>. To summarise it in a nutshell, there are basically two ways in which the major nonmonotonic KR formalisms deal with cyclic positive dependencies between pieces of knowledge. To explain what such cyclic support dependencies are and why they can be problematic, let us look at a study from the literature where researchers applied several logic-based knowledge representation techniques in a medium-sized practical application.</p><p>Nogueira et al. <ref type="bibr" target="#b31">[32]</ref> describe a declarative rule-based system that controls some of the functions of a space shuttle. More specifically, the system operates the space shuttle's reaction control system, whose primary responsibility is to manoeuvre the shuttle through space. Part of the rule-based specification represents the plumbing system of this reaction control system. The plumbing system consists of a collection of tanks, jets and pipe junctions, which are connected through pipes. The flow of fluids through pipes is controlled by valves. The purpose of the plumbing system is to deliver fuel and oxidiser from tanks to the jets needed to perform a manoeuvre. The structure of the plumbing system is described by a directed graph whose nodes are tanks, jets and pipe junctions, and whose edges are labelled by valves. The description of the plumbing system should predict how the positions of valves affect the pressure of tanks, jets and junctions. For tanks themselves, the pressure resulting from pressurising certain (other) tanks is easy to specify. For all other nodes in the graph the definition is recursive: roughly, any non-tank node is pressurised by a tank if the node is connected by an open valve to a node which is pressurised by the tank. Nogueira et al. <ref type="bibr" target="#b31">[32]</ref> explicitly recognise that modelling this is non-trivial because the connection graph of the plumbing system can contain cycles. That is, there may be nodes in the graph that are mutually connected to each other, and accurately modelling this is not straightforward: Example 1.1 (Under pressure). Consider the following easy setup where two nodes n 1 , n 2 with associated tanks are connected to each other. The connection between a node n i and its tank is controlled by the valve v i in between.</p><p>For the purpose of this example, we assume that the tanks are pressurised. Then obviously, opening v 1 pressurises n 1 ; likewise, opening v 2 pressurises n 2 . But due to the connection in between, it is also the case that pressurising n 1 indirectly pressurises n 2 , and pressurising n 2 indirectly pressurises n 1 . The easiest way to express all of this in logic programming is via the four rules</p><formula xml:id="formula_0">n 1 ← v 1 n 2 ← v 2 n 1 ← n 2 n 2 ← n 1</formula><p>• Cyclic support is disallowed by stable semantics for logic programs <ref type="bibr" target="#b19">[20]</ref> and in extensions of default logic <ref type="bibr" target="#b34">[35]</ref>. <ref type="foot" target="#foot_0">1</ref>The fact that this distinction is not present in AFs means that anyone translating their modelling language into AFs has to take care of the issue of cyclic support themselves and thus has to solve part of the problem by hardwiring it into the translation. (Just like a decision problem has to be solved when it is "translated" into the language {yes, no}.) When ADFs are used as a target language, ADF semantics will simply take care of cyclic supports, thereby considerably simplifying the translation. Generally speaking, it is at the heart of an abstraction to remove information; it is at the heart of a good abstraction to remove irrelevant information. If some removed information afterwards turns out to have been relevant, it either has to be (however costly) recomputed or is simply lost. And if the target language cannot natively express some concept, then information about this concept is bound to get lost. An example, again, is the support relation between atoms in a logic program, which is hardly translated into an AF and easily translated into an ADF as this paper will show.</p><p>More concrete empirical evidence for the usefulness of abstract dialectical frameworks has already been provided in the literature. For one, Brewka and Gordon <ref type="bibr" target="#b1">[2]</ref> translated argument evaluation structures of the Carneades framework <ref type="bibr" target="#b20">[21]</ref> into ADFs. <ref type="foot" target="#foot_1">2</ref> It is especially remarkable that their work allowed cyclic dependencies among arguments, which was previously not possible in Carneades. Meanwhile, Van Gijzel and Prakken <ref type="bibr" target="#b39">[40]</ref> also translated Carneades into AFs via ASPIC+ <ref type="bibr" target="#b32">[33]</ref>. They can deal with cycles, but even with cycles there is only one unique stable, preferred, complete, grounded extension. Thus the semantic richness of abstract argumentation is not used, and more importantly the user cannot choose whether they want to accept or reject positive cyclic dependencies between arguments. In contrast, in the ADF approach of Brewka and Gordon <ref type="bibr" target="#b1">[2]</ref>, the user can choose whether support cycles should be accepted or rejected, by choosing models or stable models as intended ADF semantics. For another, we <ref type="bibr" target="#b36">[37]</ref> have shown how ADFs can be used to provide an argumentation-based semantics for the defeasible theories of Caminada and Amgoud <ref type="bibr" target="#b7">[8]</ref>. Our translated ADFs treat the problematic examples from the literature <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b43">44]</ref> in the right way, and we proved that the translated frameworks satisfy the rationality postulates proposed by Caminada and Amgoud <ref type="bibr" target="#b7">[8]</ref>. The translation is efficiently computable, since it involves only a quadratic blowup and creates a number of arguments that is linear in the size of the defeasible theory. Furthermore, the frameworks can detect cyclic supports amongst literals via ADFs' stable semantics.</p><p>To summarise, our main arguments for using abstract dialectical frameworks as abstraction language are the following conclusions of this paper:</p><p>• ADFs are at least as expressive as AFs, and thus can represent all important problem aspects that AFs can represent. On top of that, ADFs offer a built-in treatment of positive cyclic dependencies which is derived from decades of research into nonmonotonic knowledge representation languages.</p><p>• ADFs are at most as expressive as normal logic programs, and therefore still sufficiently simple to be suited as an abstraction formalism.</p><p>• ADFs provide all of Dung's standard semantics for AFs, so there is no loss in semantical richness. On the contrary, each of the standard AF semantics (stable, preferred, complete, grounded) has at least two ADF generalisations.</p><p>To go about our main task of analysing the expressiveness of abstract dialectical frameworks, we do not have to start from scratch. Brewka and Woltran <ref type="bibr" target="#b2">[3]</ref> already showed that ADFs are at least as general as AFs and also provided a (nonmodular) translation from normal logic programs to ADFs that preserves stable models. However, the exact location of ADFs in the realm of nonmonotonic knowledge representation formalisms remained unclear. Later, Brewka et al. <ref type="bibr" target="#b3">[4]</ref> were able to give a polynomial translation from ADFs into AFs, suggesting on complexity-theoretical grounds that ADFs are not substantially more expressive than AFs. That translation is technically remarkable since it works irrespective of the specific chosen representation of acceptance conditions, provided the chosen representation is reasonable in a complexity-theoretic sense. However, the translation depends on the particular ADF semantics that is used: one does not simply translate ADFs into AFs with a fixed translation and then gets nice correspondences between the ADF and AF semantics (which is exactly how it works the other way around). Rather, to faithfully map ADFs into AFs one has to decide for a semantics beforehand and then apply a semantics-specific translation. Furthermore, the translation introduced by Brewka et al. <ref type="bibr" target="#b3">[4]</ref> for the stable semantics is again not modular, so when something is added to the input ADF, one cannot simply add the translation of the addendum, but has to retranslate the whole updated ADF. In contrast, as we will show, there are translations from AFs and ADFs into normal logic programs (LPs) which are modular, polynomial (in fact linear) and faithful with respect to a whole range of semantics.</p><p>These and similar results provide us with a more fine-grained view on the location of AFs and ADFs in the bigger picture of nonmonotonic knowledge representation languages. Technically, we achieve this by a principled and uniform reconstruction of the semantics of abstract dialectical frameworks by embedding them into the approximation operator framework of Denecker, Marek and Truszczy ński (henceforth DMT) <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12]</ref>. In seminal work, DMT developed a powerful algebraic framework in which the semantics of logic programs, default logic and autoepistemic logic can be treated in an entirely uniform and purely algebraic way. The approach works by defining operators, and then their fixpoints according to an abstract and principled method. In this paper, we extend their work by adding abstract dialectical frameworks (and by corollary abstract argumentation frameworks) to their approach.</p><p>We do this by defining the so-called characteristic operator of an ADF and then deriving new operators following abstract principles <ref type="bibr" target="#b10">[11]</ref>. For the special case of a Dung argumentation framework, for instance, the characteristic ADF operator fully captures Dung's characteristic function of the AF. Our investigation generalises the most important semantics known from abstract argumentation to the case of ADFs and relates them to the respective logic programming semantics. It will turn out that when generalising AF semantics, there are typically two different possibilities for generalisations: a "supported" and a "stable" version of the respective semantics. Brewka and Woltran <ref type="bibr" target="#b2">[3]</ref> already recognised this in the case of stable extensions for argumentation frameworks: stable AF extensions can be generalised to ADFs in two ways, namely to models and stable models for ADFs.</p><p>In addition to our usage of operators to clarify the relation of different semantics for single formalisms, we will employ another technique to illuminate the relationship between different formalisms. This role will be played by investigating polynomial, faithful, modular (PFM) translations between languages as has been done by <ref type="bibr">Gottlob [22]</ref> and Janhunen <ref type="bibr" target="#b24">[25]</ref> for the relationship between nonmonotonic logics. In our case, we even need a stronger kind of translation: "faithful" usually refers to a translation mapping models of one specific semantics of the source formalism to models of another specific semantics for the target formalism. In our case, faithful refers to the translation providing a perfect alignment with respect to any fixpoint semantics or at least a range of fixpoint semantics. Of course, this requires all of the involved semantics to be defined for both source and target formalism, which is however the case for our operator-based approach.</p><p>The picture that emerges from our work sheds new light on the underlying connections between the major nonmonotonic knowledge representation formalisms, since we study AFs, ADFs and logic programs all in a unified semantical framework. In particular, it conclusively shows that Dung's abstract argumentation frameworks can be seen as special cases of propositional normal logic programs. Now all normal logic programs are default theories, which are in turn theories of autoepistemic logic <ref type="bibr" target="#b11">[12]</ref>. Thus as a byproduct, our work yields generalisations of argumentation semantics for a general lattice-based setting, from which the existing semantics for logic programming and argumentation can be derived as special cases. Among the semantics generalised are conflict-free and admissible sets, and naive, stage, preferred and semi-stable semantics. As a corollary and another new contribution, this also defines these semantics for default logic and autoepistemic logic <ref type="bibr" target="#b11">[12]</ref>. This is a considerable improvement upon a result by Dung <ref type="bibr" target="#b13">[14]</ref>, who already argued for a preferred semantics for default logic, but only defined it through a translation to infinite argumentation frameworks. We show that our generalisations of argumentation semantics are well-defined by showing that well-known relationships between the semantics generalise accordingly: for example, any preferred ADF model is also complete.</p><p>In the last part of the paper, we instantiate the general ADF-based operator to the special case of AFs and present new semantical correspondence results between argumentation frameworks and their translated logic programs: preferred and semi-stable extensions correspond one-to-one to M-stable and L-stable models <ref type="bibr" target="#b35">[36]</ref>, respectively. Additionally, we show that our lattice-theoretical account of argumentation yields easier proofs for existing results in this area. As our final result, we prove equivalence (in four-valued Belnap logic) of two different translations from AFs to logic programs: a folklore translation from the literature (we call it the standard translation) that encodes attack by negation as failure, and the original translation of Dung <ref type="bibr" target="#b13">[14]</ref>, where attack and defeat of arguments is explicitly recorded.</p><p>Structure of the paper. We next recall the necessary background, that is to say, the relevant aspects of the DMT latticetheoretic framework <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b12">13]</ref>, logic programming and argumentation -in particular Dung-style argumentation frameworks and their generalisation to ADFs. Afterwards, we define the characteristic operator of an abstract dialectical framework, whose fixpoints then serve to define ADF semantics in a novel way. The operator will also be used to determine the relationship between propositional normal logic programs and abstract dialectical frameworks: we prove that ADFs can be faithfully and modularly mapped into LPs. We finally show the importance of our general results by illuminating the ramifications for the special case of Dung frameworks. Specifically, we prove several new semantical correspondence results for argumentation and logic programming, and finally prove the equivalence of two different translations from argumentation frameworks into logic programs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Background</head><p>Let us first recall some basic concepts from lattice theory. A complete lattice is a partially ordered set (L, ) where every subset of L has a least upper and a greatest lower bound. In particular, a complete lattice has a least and a greatest element. An operator O : L → L is monotone if for all x y we find O (x) O (y); it is antimonotone if for all x y we find O (y</p><formula xml:id="formula_1">) O (x). An x ∈ L is a fixpoint of O if O (x) = x; an x ∈ L is a prefixpoint of O if O (x) x and a postfixpoint of O if x O (x).</formula><p>Due to a fundamental result by Tarski and Knaster, for any monotone operator O on a complete lattice, the set of its fixpoints forms a complete lattice itself <ref type="bibr" target="#b37">[38]</ref>. In particular, its least fixpoint lfp(O ) exists; additionally, the least prefixpoint of O is also its least fixpoint.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">The algebraic framework of Denecker et al. [11]</head><p>Building upon the fundamental result by Tarski and Knaster, Denecker et al. <ref type="bibr" target="#b10">[11]</ref> introduce the important concept of an approximation of an operator. In the study of semantics of nonmonotonic knowledge representation formalisms, elements of lattices represent objects of interest. Operators on lattices transform such objects into others according to the contents of some knowledge base. Consequently, fixpoints of such operators are then objects that cannot be updated any moreinformally speaking, the knowledge base can neither add information to a fixpoint nor remove information from it.</p><p>To study fixpoints of operators O , DMT study fixpoints of their approximating operators O. <ref type="foot" target="#foot_2">3</ref> When O operates on a set L, its approximation O operates on pairs (x, y) ∈ L 2 where L 2 denotes L × L. Such a pair can be seen as representing a set of lattice elements by providing a lower bound x and an upper bound y. Consequently, the pair (x, y) approximates all z ∈ L such that x z y. Of special interest are consistent pairs -those where x y, that is, the set of approximated elements is nonempty. A pair (x, y) with x = y is called exact -it "approximates" a single element of the original lattice. <ref type="foot" target="#foot_3">4</ref>There are two natural orderings on approximating pairs: first, the information ordering i , that intuitively orders pairs according to their information content. Formally, for x 1 , x 2 , y 1 , y 2 ∈ L define (x 1 , y 1 ) i (x 2 , y 2 ) iff x 1 x 2 and y 2 y 1 . This ordering leads to a complete lattice (L 2 , i ), the product of L with itself, its bilattice. For example, the pair (⊥, ) consisting of -least ⊥ and -greatest lattice element approximates all lattice elements and thus contains no information -it is the least element of the bilattice (L 2 , i ); exact pairs (x, x) are those that are maximally informative while still being consistent. The second natural ordering is the truth ordering t , which orders elements of the bilattice according to their degree of truth. Formally, for x 1 , x 2 , y 1 , y 2 ∈ L it is defined by (x 1 , y 1 ) t (x 2 , y 2 ) iff x 1 x 2 and y 1 y 2 . The pair (⊥, ⊥) is the least element of t -in a truth-based setting, it assigns the truth value false to all elements of L; the pair ( , )</p><p>consequently is the t -greatest element -here, all elements of L are assigned value true.</p><p>To define an approximation operator O : L 2 → L 2 , one essentially has to define two functions: a function O : L 2 → L that yields a new lower bound (first component) for a given pair; and a function O : L 2 → L that yields a new upper bound (second component) for a given pair. Accordingly, the overall approximation is then given by O(x, y) = (O (x, y), O (x, y)) for (x, y) ∈ L 2 . Conversely, in case O is considered given, the notations O (x, y) and O (x, y) are read as the projection of O(x, y) to the first and second component, respectively.</p><p>Denecker et al. <ref type="bibr" target="#b10">[11]</ref> identify an important subclass of operators on bilattices, namely those that are symmetric, that is, for which O (x, y) = O (y, x). For these, O(x, y) = (O (x, y), O (y, x)), and to define O it suffices to specify O . An operator is approximating if it is symmetric and i -monotone. For an antimonotone operator O , its canonical approximation O is given by O (x, y) = (O (y), O (x)).</p><p>The main contribution of Denecker et al. <ref type="bibr" target="#b10">[11]</ref> was the association of the stable operator SO to an approximating operator O. Below, the expression O (•, y) : L → L denotes the operator given by x → O (x, y) for x ∈ L. Definition 2.1. For a complete lattice (L, ) and an approximating operator O : L 2 → L 2 , define the</p><formula xml:id="formula_2">• complete stable operator for O as cO : L → L by cO( y) def = lfp(O (•, y));</formula><p>• stable operator for O as SO :</p><formula xml:id="formula_3">L 2 → L 2 by SO(x, y) def = (cO(y), cO(x)).</formula><p>This general, lattice-theoretic definition by DMT yields a uniform treatment of the standard semantics of the major nonmonotonic knowledge representation formalisms -logic programming, default logic and autoepistemic logic <ref type="bibr" target="#b11">[12]</ref>. Definition 2.2. Let (L, ) be a complete lattice and O : L 2 → L 2 be an approximating operator. Furthermore, let x, y ∈ L with x y. Define the following semantical notions for O:</p><formula xml:id="formula_4">Kripke-Kleene semantics lfp(O) three-valued supported model (x, y) O(x, y) = (x, y) two-valued supported model (x, x) O(x, x) = (x, x) well-founded semantics lfp(SO) three-valued stable model (x, y) SO(x, y) = (x, y) two-valued stable model (x, x) SO(x, x) = (x, x)</formula><p>It is clear that each two-valued supported/stable model is a three-valued supported/stable model; furthermore the Kripke-Kleene semantics of an operator is a three-valued supported model and the well-founded semantics is a threevalued stable model. Also, each three-valued/two-valued stable model is a three-valued/two-valued supported model, which is easily seen: if (x, y) is a three-valued stable model, we have (x, y) = SO(x, y). Now (x, y) = SO(x, y) = (cO(y), cO(x)) = (lfp(O (•, y)), lfp(O (•, x))) implies x = O (x, y) and y = O (y, x), whence (x, y) = (O (x, y), O (y, x)) = O(x, y) and (x, y) is a three-valued supported model. This holds in particular if x = y, and each two-valued stable model is a two-valued supported model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Ultimate approximations.</head><p>In subsequent work, Denecker et al. <ref type="bibr" target="#b12">[13]</ref> presented a general, abstract way to define the most precise approximation of a given operator O in a lattice (L, ). Most precise here refers to a generalisation of i to operators, where for O 1 , O 2 : L 2 → L 2 , they define O 1 i O 2 iff for all x y ∈ L it holds that O 1 (x, y) i O 2 (x, y). For consistent pairs (x, y) of the bilattice (L 2 , i ), they show that the most precise -called the ultimate -approximation of O is given by</p><formula xml:id="formula_5">U O (x, y) def = (U O (x, y), U O (x, y)) with U O (x, y) def = O (z) x z y U O (x, y) def = O (z) x z y</formula><p>Note that the ultimate approximation works only for consistent pairs and is not symmetric. Still, this definition is remarkable since previously, approximating operators O for lattice operators O had to be devised by hand rather than automatically derived. We next illustrate the workings of the operator-based framework for the case of logic programming.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Logic programming</head><p>For technical convenience, we use definitions along the lines of Fitting <ref type="bibr" target="#b17">[18]</ref>, whose fixpoint-theoretic approach to logic programming was extended by Denecker et al. <ref type="bibr" target="#b10">[11]</ref> For singleton M = {m} we denote the rule just by a ← m. A logic program (LP) Π over A is a set of logic program rules over A, and it is definite if all rules in it are definite. The perhaps most prominent example for an operator is the one-step consequence operator T Π associated with a definite logic program Π <ref type="bibr" target="#b17">[18]</ref>. For a signature A, it operates on subsets of A and assigns to a set of atoms S those atoms which are implied by S according to the rules in Π . The underlying lattice is therefore (2 A , ⊆) consisting of the set of A's subsets ordered by ⊆.</p><p>This operator was later generalised to four-valued Belnap logic <ref type="bibr" target="#b17">[18]</ref> and can be recast in a bilattice-based setting as follows. A pair (X, Y ) ∈ 2 A × 2 A can be read as a four-valued assignment by evaluating all atoms in X ∩ Y as true, those in A \ (X ∪ Y ) as false, the ones in Y \ X as undefined and the atoms in X \ Y as inconsistent.</p><p>Definition 2.3. For a logic program Π over A, define an (approximating) operator T Π :</p><formula xml:id="formula_6">2 A × 2 A → 2 A × 2 A as follows: for X, Y ⊆ A, T Π (X, Y ) def = T Π (X, Y ), T Π (Y , X) T Π (X, Y ) def = a ∈ A a ← M ∈ Π, M + ⊆ X, M -∩ Y = ∅</formula><p>Roughly, to construct a new lower bound, the operator T Π returns all those atoms for which a rule exists whose positive body is implied by the current lower bound and whose negative body does not share an atom with the current upper bound. This first of all means that the operator allows to infer an atom via a program rule if -according to the input estimatethe positive body is true and the negative body is false. The fixpoints of T Π are the four-valued supported models of Π ; its consistent fixpoints are the three-valued supported models of Π . The two-valued supported models of Π are computed by the abovementioned operator T Π , that -in this setting -is defined by</p><formula xml:id="formula_7">T Π (M) = T Π (M, M) [11].</formula><p>The abstract principles of Denecker et al. <ref type="bibr" target="#b10">[11]</ref> outlined above also yield the corresponding stable operator ST Π . This operator in turn immediately yields the Gelfond-Lifschitz operator GL Π (M) = ST Π (M, M) for computing two-valued stable models of Π . The stable operator ST Π also gives rise to the well-founded model of Π , which is the least fixpoint of ST Π . Additionally, three-valued stable models are the consistent fixpoints of ST Π . These are further refined into two additional semantics: M-stable models are three-valued stable models (X, Y ) where X is ⊆-maximal -M-stable is for "maximal stable" <ref type="bibr" target="#b35">[36]</ref>; L-stable models are three-valued stable models (X, Y ) where Y \ X is ⊆-minimal -L-stable is for "least undefined" <ref type="bibr" target="#b35">[36]</ref>. It is clear that these same maximisation/minimisation criteria can be applied to consistent fixpoints of T Π -the three-valued supported models. This leads to M-supported models and L-supported models. In a table much like the one from Definition 2.2, this looks thus:</p><formula xml:id="formula_8">M-supported model (X, Y ) T Π (X, Y ) = (X, Y ) and (X, Y ) is i -maximal L-supported model (X, Y ) T Π (X, Y ) = (X, Y ) and Y \ X is ⊆-minimal M-stable model (X, Y ) ST Π (X, Y ) = (X, Y ) and (X, Y ) is i -maximal L-stable model (X, Y ) ST Π (X, Y ) = (X, Y ) and Y \ X is ⊆-minimal</formula><p>It follows that each two-valued supported/stable model is an L-supported/L-stable model is an M-supported/M-stable model is a three-valued supported/stable model.</p><p>As an example, consider the logic program π 1 = {a ← ∅, b ← a}. It is a definite LP, thus we can iterate its two-valued one-step consequence operator T π 1 on the empty set, the least element of the relevant lattice: we have T π 1 (∅) = {a} and T π 1 ({a}) = {a, b} = T π 1 ({a, b}) as a fixpoint and thus the least (two-valued supported) model of program π 1 . Now we add another rule to this program and set π 2 def = π 1 ∪ {c ← {b, not d}}, a logic program over A = {a, b, c, d} that is not definite. To compute its well-founded model, we iterate the associated stable four-valued one-step consequence operator ST π 2 on the least element (∅, A) of the relevant bilattice. We see that ST π 2 (∅, A) = ({a}, {a, b, c}): intuitively, a is added to the lower bound since its body is satisfied, d is removed from the upper bound because there is no program rule to derive d. Applying ST π 2 again leads to the pair ({a, b, c}, {a, b, c}) which is an exact fixpoint and thus the only two-valued stable model of π 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Abstract argumentation frameworks</head><p>Dung <ref type="bibr" target="#b13">[14]</ref> introduced a way to study the fundamental mechanisms that humans use in argumentation. His argumentation frameworks (AFs) Θ are pairs (A, R) where A is a set and R ⊆ A × A. The intended reading of an AF Θ is that the elements of A are arguments whose internal structure is abstracted away. The only information about the arguments is given by the relation R encoding a notion of attack: for a, b ∈ A a pair (a, b) ∈ R expresses that argument a attacks argument b in some sense. This seemingly lightweight formalism allows for a rich semantical theory, whose most important notions we subsequently recall.</p><p>The purpose of semantics for argumentation frameworks is to determine sets of arguments which are acceptable according to various standards. As an intuitive example, a set of arguments could be accepted if it is internally consistent and can defend itself against attacks from the outside. More formally, a set S ⊆ A of arguments is conflict-free iff there are no a, b ∈ S with (a, b) ∈ R. For an argument a ∈ A, the set of its attackers is Attackers Θ (a)</p><formula xml:id="formula_9">def = {b ∈ A | (b, a) ∈ R}. An AF is finitary iff Attackers Θ (a) is finite for all a ∈ A. For S ⊆ A, the set of arguments it attacks is Attacked Θ (S) def = {b ∈ A | (a, b) ∈ R for some a ∈ S}.</formula><p>Finally, for S ⊆ A and a ∈ A, the set S defends a iff Attackers Θ (a) ⊆ Attacked Θ (S), that is, all attackers of a are attacked by S.</p><p>The major semantics for argumentation frameworks can be formulated using two operators that Dung <ref type="bibr" target="#b13">[14]</ref> already studied. The first is the characteristic function of an AF Θ = (A, R): for S ⊆ A, define F Θ (S) def = {a ∈ A | S defends a}. This operator F Θ is ⊆-monotone and therefore has a least fixpoint in the lattice (2 A , ⊆). This least fixpoint of F Θ is defined as the grounded extension of Θ. The second relevant operator U Θ takes as input a set S of arguments, and returns the arguments which are not attacked by any argument in S (U is for "unattacked") -formally U Θ (S)</p><formula xml:id="formula_10">def = A \ Attacked Θ (S).</formula><p>It is an antimonotone operator, and its fixpoints are the stable extensions of Θ. Additionally, U Θ can characterise conflict-freeness: a set S ⊆ A is conflict-free iff S ⊆ U Θ (S). Further semantics are defined as follows. A set E ⊆ A is a complete extension iff it is a conflict-free fixpoint of F Θ . More generally, a set S ⊆ A is admissible iff S is conflict-free and S ⊆ F Θ (S). Finally, preferred extensions are ⊆-maximal complete extensions; and semi-stable extensions are those complete extensions E where the set E ∪ Attacked Θ (E) (the range of the extension E) is ⊆-maximal. The same maximisation criteria that lead from admissible sets to preferred and semi-stable extensions can also be applied to conflict-free sets: a naive extension of an AF is a ⊆-maximal conflict-free set; a stage extension of an AF is a conflict-free set with ⊆-maximal range. For two argumentation</p><formula xml:id="formula_11">frameworks Θ 1 = (A 1 , R 1 ) and Θ 2 = (A 2 , R 2 ), their union is defined as Θ 1 ∪ Θ 2 def = (A 1 ∪ A 2 , R 1 ∪ R 2 ).</formula><p>As an example, let the argumentation framework θ = (A, R) be given by A = {a, b, c, d} and R = {(a, b), <ref type="bibr">(c, d)</ref> <ref type="figure">,</ref><ref type="figure">(d,</ref><ref type="figure">c</ref>)}. It is depicted by the following directed graph: Its grounded extension is the set G = {a}; it possesses two stable extensions, E 1 = {a, c} and E 2 = {a, d}. The three sets G, E 1 , E 2 form the only complete extensions of θ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.">Abstract dialectical frameworks</head><p>Brewka and Woltran <ref type="bibr" target="#b2">[3]</ref> introduced abstract dialectical frameworks as a powerful generalisation of abstract argumentation frameworks that are able to capture not only attack and support, but also more general notions such as joint attack and joint support.</p><formula xml:id="formula_12">Definition 2.4. An abstract dialectical framework (ADF) is a triple Ξ = (S, L, C ) where • S is a set of statements, • L ⊆ S × S is a set of links, where par(s) def = {r ∈ S | (r, s) ∈ L}, • C = {C s } s∈S is a set of total functions C s : 2 par(s) → {in, out}.</formula><p>Intuitively, the function C s for a statement s determines the acceptance status of s, which naturally depends on the status of its parent nodes par(s). Alternatively, any such function C s can be represented by the set of all parent subsets leading to acceptance, C in s def = {M ⊆ par(s) | C s (M) = in}. We will use both representations in this paper and indicate the alternative one by writing an ADF as (S, L, C in ).</p><p>Many more specific representations of acceptance conditions are possible, Brewka and Woltran <ref type="bibr" target="#b2">[3]</ref> even introduce two of these additional representations: For one, an acceptance condition C a can be described via a propositional formula ϕ a over the vocabulary par(a), which is straightforward to use whenever each statement has only finitely many relevant parents. The understanding there is that C in a is given by the two-valued models of ϕ a , where an interpretation is identified with the set of atoms that are evaluated to true. For another, Brewka and Woltran <ref type="bibr" target="#b2">[3]</ref> also demonstrated how assigning weights to links and combining these weights with proof standards can give rise to acceptance conditions. • Statement a has no parents, par(a) = ∅, thus 2 par(a) = {∅}. The acceptance function specifies that ∅ → in, whence a is always in.</p><p>• Statement b is its own parent. According to its acceptance function, it is in</p><formula xml:id="formula_13">only if it is in. Statement b is thus (cyclicly)</formula><p>self-supporting.</p><p>• Statement c has parents par(c) = {a, b}. They jointly support c, as is witnessed by C in c = {par(c)}. Note that joint support here indeed means that the support only becomes effective if both parents are in.</p><p>• Statement d is attacked by its only parent b.</p><p>Brewka and Woltran <ref type="bibr" target="#b2">[3]</ref> introduced several semantical notions for ADFs. For an</p><formula xml:id="formula_14">ADF Ξ = (S, L, C in ), a set M ⊆ S is conflict-free iff for all s ∈ M we have M ∩ par(s) ∈ C in s . A set M ⊆ S is a model for Ξ iff for each s ∈ S we have s ∈ M iff M ∩ par(s) ∈ C in s .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 2.1 (Continued).</head><p>A conflict in a set of statements intuitively means that there is either an attack within the set or a lack of support for some statement. The running example ADF D has the following conflict-free sets: ∅, {a}, {b}, {d}, {a, b}, {a, d}, {a, b, c} This is easy to understand: from all subsets of S = {a, b, c, d}, we have to remove those that ( <ref type="formula">1</ref> The two models of D are M 1 = {a, b, c} and M 2 = {a, d}. Intuitively, a is always in and thus contained in both models.</p><p>For the self-supporting b, the model semantics has a choice whether or not to accept it, and this choice determines the two models. In M 1 , statement b is accepted along with a, their joint support of c becomes relevant and c is also accepted. (Statement d is not accepted by M 1 since b is accepted and attacks d.) In M 2 , statement b is not accepted whence c is not accepted due to a lack of support; statement d behaves like an AF argument and so is accepted because its only attacker b is not accepted. Some semantics were only defined for a subclass of ADFs called bipolar. Intuitively, in bipolar ADFs (BADFs) each link is supporting or attacking (or both); that is, there is nothing such as joint support or attack and the like. Formally, a link</p><formula xml:id="formula_15">(r, s) ∈ L is supporting in Ξ iff for all R ⊆ par(s), we have that R ∈ C in s implies R ∪ {r} ∈ C in s ; symmetrically, a link (r, s) ∈ L is attacking in Ξ iff for all R ⊆ par(s), we have that R ∪ {r} ∈ C in s implies R ∈ C in s . An ADF Ξ = (S, L, C</formula><p>) is bipolar iff all links in L are supporting or attacking; we use L + to denote all supporting and L -to denote all attacking links of For a bipolar ADF Ξ = (S, L, C ), a set M ⊆ S is BW-admissible in Ξ iff there is some R ⊆ S with</p><formula xml:id="formula_16">L in Ξ . A model M of a bipolar ADF Ξ is a BW-stable model of Ξ iff it is the least model of the reduced ADF Ξ M defined as Ξ M = (S M , L M , C M ) with • S M = S ∩ M (nodes are restricted to those in the model), • L M = {(r, s) | r, s ∈ S M , (r, s) ∈ L + } (</formula><formula xml:id="formula_17">• L -∩ (R × M) = ∅ (there are no attacks from R to M) and • M is a stable model of Ξ -R.</formula><p>A set M ⊆ S is a BW-preferred model of Ξ iff it is ⊆-maximal among the sets BW-admissible in Ξ . Finally, Brewka and Woltran <ref type="bibr" target="#b2">[3]</ref> also generalise the grounded semantics: for Ξ = (S, L, C ) they define a monotone operator Γ Ξ :</p><formula xml:id="formula_18">2 S × 2 S → 2 S × 2 S by (X, Y ) → (Γ Ξ (X, Y ), Γ Ξ (X, Y )), where 5 Γ Ξ (X, Y ) def = s ∈ S for all X ⊆ Z ⊆ Y , we have Z ∩ par(s) ∈ C in s Γ Ξ (X, Y ) def = s ∈ S there exists X ⊆ Z ⊆ Y with Z ∩ par(s) ∈ C in s</formula><p>The i -least fixpoint of Γ Ξ gives rise to the BW-well-founded model of Ξ . It is especially notable that models and stable models coincide for AF-based ADFs, a fact that we will illuminate further and for which we will provide an intuitive explanation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 2.1 (Continued</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Approximating semantics of abstract dialectical frameworks</head><p>Abstract dialectical frameworks are nonmonotonic knowledge representation formalisms. As such, they allow to express knowledge and provide formal semantics for such expressions. In this respect, nonmonotonic means that extending a knowledge base (that is, an ADF) may invalidate conclusions drawn from it. One approach to define semantics for knowledge bases is the one championed by van Emden, Kowalski and others: there, a revision operator is associated with a knowledge base <ref type="bibr" target="#b17">[18]</ref>. The operator revises interpretations for the knowledge base K in the sense that the revision of an interpretation is somehow "more in accord" with the knowledge contained in K . Extending the metaphor, fixpoints of the revision operator then correspond to models since they exactly "hit the spot" in that they represent stationary interpretations that cannot be revised further. In this section, we will apply this operator-based approach to semantics to abstract dialectical frameworks.</p><p>From the definition of a model of an ADF by Brewka and Woltran <ref type="bibr" target="#b2">[3]</ref>, it is straightforward to devise a two-valued one-step consequence operator for a given ADF: given a two-valued interpretation, we evaluate the acceptance condition of each statement; the resulting evaluation determines the revised interpretation. To generalise this to an approximating operator, we generalise the evaluation from the two-valued {in, out} to four-valued Belnap logic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">The characteristic operator of an ADF</head><p>For an abstract dialectical framework Ξ = (S, L, C in ), four-valued interpretations can be represented by pairs (X, Y ) with X, Y ⊆ S. Such pairs can equivalently be interpreted as approximations to two-valued interpretations where X represents a lower bound and Y an upper bound of the approximation. Given such an approximating pair (X, Y ) and an ADF Ξ , to revise the pair we do the following for each statement s ∈ S: we check if there is some subset B of the parents of s (which are exactly the statements that determine the acceptance status of s) such that (1) all statements in B being in causes s to be in; <ref type="bibr" target="#b1">(2)</ref> all statements in B are indeed in according to the conservative estimate X ; (3) the remaining parents of s are indeed out, that is, not contained in the liberal estimate Y . The definition below, the most important definition of the paper, makes this formally precise. Definition 3.1. Let Ξ = (S, L, C in ) be an abstract dialectical framework. Define an operator G Ξ :</p><formula xml:id="formula_19">2 S × 2 S → 2 S × 2 S by G Ξ (X, Y ) def = G Ξ (X, Y ), G Ξ (Y , X) G Ξ (X, Y ) def = s ∈ S B ∈ C in s , B ⊆ X, par(s) \ B ∩ Y = ∅</formula><p>The last condition (par(s) \ B) ∩ Y = ∅ can be equivalently reformulated as par(s) \ B ⊆ S \ Y . By B ⊆ X this means that all parents of s which are not in must be out -there must not be undecided parents of s.</p><p>A two-valued immediate consequence operator for ADFs (the equivalent of logic programs' two-valued van Emden-</p><formula xml:id="formula_20">Kowalski operator T Π ) is now given by G Ξ (X) def = G Ξ (X, X).</formula><p>The next lemma about this two-valued operator relates to ADF models and will prove useful on various occasions.</p><p>Lemma 3.1. For any abstract dialectical framework Ξ = (S, L, C ), s ∈ S and X ⊆ S we have s</p><formula xml:id="formula_21">∈ G Ξ (X) iff X ∩ par(s) ∈ C in s . Proof. s ∈ G Ξ (X) iff s ∈ G Ξ (X, X) iff X ∈ C in s , X ⊆ X, par(s) \ X ∩ X = ∅, X ∩ par(s) = X iff X ∩ par(s) ∈ C in s 2</formula><p>Our definition of the approximating operator of an ADF immediately defines quite a number of semantics for ADFs, among them all the semantics of Definition 2.2. In the following, we will show how some of the standard operator-based semantics coincide with existing ADF semantics. Operator-based semantics without a corresponding ADF semantics accordingly define new semantical notions for abstract dialectical frameworks, for example three-valued stable models. Similarly, there are ADF semantics which have no operator-based counterpart -BW-stable, BW-admissible and BW-preferred -, we will provide alternative, operator-based definitions for these semantics.</p><p>But first, we do the obviously necessary and show that G Ξ is indeed an approximating operator. From Definition 3.1 it is immediate that G Ξ is symmetric. It is easy to prove that the operator is also i -monotone.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 3.2. For any ADF</head><formula xml:id="formula_22">Ξ = (S, L, C ), the operator G Ξ is i -monotone. Proof. Let (X 1 , Y 1 ) i (X 2 , Y 2 ), that is, X 1 ⊆ X 2 and Y 2 ⊆ Y 1 . We have to show G Ξ (X 1 , Y 1 ) i G Ξ (X 2 , Y 2 ), that is, (1) G Ξ (X 1 , Y 1 ) ⊆ G Ξ (X 2 , Y 2 ) and (2) G Ξ (Y 2 , X 2 ) ⊆ G Ξ (Y 1 , X 1 ). 1. Let s ∈ G Ξ (X 1 , Y 1 ). Then there is an M ∈ C in s with M ⊆ X 1 and (par(s) \ M) ∩ Y 1 = ∅. Now M ⊆ X 1 ⊆ X 2 ; furthermore Y 2 ⊆ Y 1 implies (par(s) \ M) ∩ Y 2 = ∅, whence s ∈ G Ξ (X 2 , Y 2 ). 2. Analogous. 2</formula><p>Hence the fixpoints of this operator form a complete lattice <ref type="bibr" target="#b37">[38]</ref>. From G Ξ being approximating it follows that it maps consistent pairs to consistent pairs <ref type="bibr" target="#b10">[11,</ref><ref type="bibr">Proposition 14]</ref>; in particular its least fixpoint is consistent. Finally, we can construct its associated stable operator SG Ξ as defined by Denecker et al. <ref type="bibr" target="#b10">[11]</ref>. We will now use our newly defined approximating ADF operator to systematically reconstruct semantical notions for abstract dialectical frameworks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1.">Conflict-free sets</head><p>First of all, we find a nice characterisation of conflict-freeness: a set M is conflict-free for an ADF Ξ iff application of the two-valued immediate consequence operator G Ξ leads to a superset of M, that is, M is a postfixpoint of G Ξ . Intuitively speaking, each statement that is contained in a conflict-free set M has a reason to be contained in M.</p><formula xml:id="formula_23">Proposition 3.3. For any abstract dialectical framework Ξ = (S, L, C ), a set M ⊆ S is conflict-free for Ξ iff M ⊆ G Ξ (M). Proof. M is conflict-free iff for all s ∈ M we have M ∩ par(s) ∈ C in s iff M ⊆ s ∈ S M ∩ par(s) ∈ C in s iff M ⊆ G Ξ (M) (by Lemma 3.1)<label>2</label></formula><p>Notice that this characterisation only uses conflict-free sets and is thus inherently two-valued. We will later generalise "conflict-free" to three-valued interpretations represented by consistent pairs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2.">Model semantics</head><p>Much in accordance with logic programming, a model of an ADF is simply a two-valued fixpoint of its associated consequence operator:</p><formula xml:id="formula_24">Proposition 3.4. For any abstract dialectical framework Ξ = (S, L, C ), a set M ⊆ S is a model of Ξ iff G Ξ (M, M) = (M, M). Proof. M is a model for Ξ iff for each s ∈ S we have s ∈ M iff M ∩ par(s) ∈ C in s iff M = s ∈ S M ∩ par(s) ∈ C in s iff M = G Ξ (M, M) iff G Ξ (M, M) = (M, M) 2</formula><p>Since the correspondence with logic programming is striking, we will use the more specific term "two-valued supported model" from now on.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.3.">Stable model semantics</head><p>Motivated by the same notion of logic programming, Brewka and Woltran <ref type="bibr" target="#b2">[3]</ref> defined stable models for bipolar ADFs. When we compare their definition to the general operator-based notion of two-valued stable models, we have to acknowledge a slight mismatch. is not in the reduct because it is attacking in ξ .) However, the operator G ξ does not have a two-valued stable model: when trying to reconstruct the upper bound {b}, we get G ξ (∅, {b}) = ∅ since b attacks itself and thus its containment in the upper bound prevents its inclusion in the new lower bound, as witnessed by par(b) ∩ {b} = {b} = ∅. (Interestingly, this example also shows that M-stable models are not necessarily M-supported: ξ has the single M-stable model (∅, {b}) and the two M-supported models ({a}, {a, b}) and ({b}, {b}).)</p><p>So while there are ADFs with BW-stable models which are not two-valued stable models of the ADF's approximating operator, we can establish an inclusion relation for the converse direction: any operator-based two-valued stable model of an ADF is also a BW-stable model of the ADF. To show this, we first need a lemma that relates the operators G Ξ (•, M) and G Ξ M whenever M is a model of Ξ . Lemma 3.5. Let Ξ = (S, L, C ) be a bipolar ADF and (M, M) be a two-valued supported model for Ξ . For any X ⊆ M we find</p><formula xml:id="formula_25">G Ξ (X, M) ⊆ G Ξ M (X). Proof. Recall that the reduct of Ξ with M is defined by Ξ M = (M, L M , C M ) with reduced links L M = {(r, s) | r, s ∈ M, (r, s) ∈ L + } and for each s ∈ M and B ⊆ M, we have C M s (B) = in iff C s (B)</formula><p>= in. Now for each s ∈ S denote by P s the parent nodes of s with respect to L and for s ∈ M by P M s the parent nodes of s with respect to L M . It follows that</p><formula xml:id="formula_26">P M s = (M ∩ P s ) \ {r ∈ P s | (r, s) / ∈ L + }. Let s ∈ G Ξ (X, M). (Observe that X ⊆ M means G Ξ (X, M) ⊆ G Ξ (M, M) = M and thus s ∈ M.) Then there is a B ⊆ P s with C s (B) = in, B ⊆ X and (P s \ B) ∩ M = ∅. Now P M s ⊆ P s and X ⊆ M yield (P M s \ B) ∩ X = ∅, whence X ∩ P M s ⊆ B. Define B = B \ {r ∈ P s | (r, s) / ∈ L + }. By definition B ⊆ P M s , whence by B ⊆ B ⊆ X we get B ⊆ X ∩ P M</formula><p>s . Since all the removed parents r were attackers (Ξ is bipolar), we still have C s (B ) = in. Now all links from P M s to s are supporting and thus still</p><formula xml:id="formula_27">C s (X ∩ P M s ) = in. Hence C s (X ∩ P M s ) = C M s (X ∩ P M s ) = in and s ∈ G Ξ M (X). 2</formula><p>This shows that G Ξ M -the two-valued operator associated to the reduced ADF Ξ M -is in some sense "complete" with respect to the result of G Ξ (•, M) -the operator for checking whether M is a two-valued stable model of Ξ . The next lemma will show that this "completeness" carries over to the least fixpoints of these operators. Lemma 3.6. Let Ξ = (S, L, C ) be a bipolar ADF and (M, M) be a two-valued supported model for</p><formula xml:id="formula_28">Ξ . If M is the least fixpoint of G Ξ (•, M), then it is the least fixpoint of G Ξ M .</formula><p>Proof. We use the notation from the proof of Lemma 3.5. Let s ∈ M and observe that we have C s (M ∩ P s ) = in since M is a model of Ξ . By the definition of the reduct, we get</p><formula xml:id="formula_29">P M s = (M ∩ P s ) \ {r ∈ P s | (r, s) / ∈ L + }. Since Ξ is bipolar, any link from (M ∩ P s ) \ P M s is attacking and thus C s (P M s ) = in. • M is a fixpoint of G Ξ M : G Ξ M (M) = s ∈ M C M s M ∩ P M s = in (by definition of G Ξ M ) = s ∈ M C M s P M s = in P M s ⊆ M = s ∈ M C s P M s = in by definition of C M s = s ∈ M C s (M ∩ P s ) = in (see above) = s ∈ S C s (M ∩ P s ) = in s ∈ S \ M iff C s (M ∩ P s ) = out = G Ξ (M) ( by definition of G Ξ ) = M (M is a model of Ξ) • M is the least fixpoint of G Ξ M : Let X ⊆ M be a fixpoint of G Ξ M . By Lemma 3.5, G Ξ (X, M) ⊆ G Ξ M (X) = X and X is a prefixpoint of G Ξ (•, M).</formula><p>Since M is the least fixpoint and thus also the least prefixpoint of G Ξ (•, M), we get M ⊆ X . 2</p><p>Using the lemma, it is easy to show that the set of BW-stable models contains all operator-based two-valued stable models.</p><formula xml:id="formula_30">Proposition 3.7. Let Ξ = (S, L, C ) bipolar abstract dialectical framework and M ⊆ S. If (M, M) is a two-valued stable model of Ξ , then M is a BW-stable model of Ξ . Proof. Let SG Ξ (M, M) = (M, M). By definition M = cG Ξ (M) = lfp(G Ξ (•, M)), that is, M is the least fixpoint of G Ξ (•, M). By Lemma 3.6, M is the least fixpoint of G Ξ M . Therefore, M is the least model of Ξ M (and a model of Ξ ), thus it is a BW-stable model of Ξ . 2</formula><p>The mismatch noticed in Example 3.1 does not depend on our definition of the four-valued approximating operator: the ADF presented there also does not allow for ultimate two-valued stable models, although the model notion of Brewka and Woltran <ref type="bibr" target="#b2">[3]</ref> is perfectly captured by the two-valued one-step ADF consequence operator, which also gives rise to ADF's ultimate family of semantics. Put another way, if we take the model notion from Brewka and Woltran <ref type="bibr" target="#b2">[3]</ref> and apply to it the transformations of Denecker et al. <ref type="bibr" target="#b12">[13]</ref>, we arrive at an ultimate stable model semantics which is demonstrably different from BW-stable models.</p><p>Thus at the current point, we have two different stable model semantics at our disposal -operator-based two-valued stable models and BW-stable models. The following example shows that the BW-stable semantics admits too many models, since there are ADFs which admit for BW-stable models where one is a proper subset of another. In words, a is always in and attacks b, which however can support itself. The ADF ξ has two BW-stable models, M 1 = {a} and M 2 = {a, b}: The reduct of ξ with M 1 is given by ξ</p><formula xml:id="formula_31">M 1 = ({a}, ∅, C M 1 ) with C M 1 a = {∅}, thus its least model is {a} = M 1 . For the second BW-stable model M 2 = {a, b}, the reduct of ξ with M 2 is given by ξ M 2 = (S, {(b, b)}, C M 2 ) with C M 2 a = {∅} and C M 2 b</formula><p>= {∅, {b}}. (Note that the link (b, b) is both supporting and attacking, thus in fact irrelevant.) It is easy to see that {a, b} = M 2 is the least model of this ADF. In contrast, the approximating operator G ξ associated with ξ admits only the single two-valued stable model ({a}, {a}). The problem with this example is that the ADF ξ allows for the BW-stable model M 2 in which statement b cyclicly supports itself. This violates the intuitive requirement of stable semantics that whatever it takes to be true must have a non-cyclic justification. Furthermore, in logic programming, two distinct stable models of normal logic programs cannot be in a subset-relationship; likewise in Reiter's default logic, two distinct extensions of a default theory cannot be in a subset-relationship. With our operator-based definition of two-valued stable models for ADFs, this property comes for free: Proposition 3.8. Let (L, ) be a complete lattice and O an approximating operator on the bilattice (L 2 , i ). For any x, y ∈ L with SO(x, x) = (x, x) and SO(y, y) = (y, y), we have that x y implies x = y.</p><p>Proof. Let x, y ∈ L with SO(x, x) = (x, x), SO(y, y) = (y, y) and x y. Since O is antimonotone in the second component, we have O(x, y) O(x, x) = x and x is a prefixpoint of O(•, y). Now y is the least prefixpoint of O(•, y) and thus y x. 2</p><p>Together with Example 3.2, this result means that there is no approximating operator for which Definition 2.1 can reconstruct BW-stable models. However, our operator-based definition of two-valued stable models easily gives rise to an equivalent reduct-based definition of the same concept: in operator terms, M is a two-valued stable model of G Ξ iff M is the least fixpoint of the operator G Ξ (•, M). To define a reduct, we have to find the ADF associated to this consequence operator defined for X ⊆ S by</p><formula xml:id="formula_32">G Ξ (X, M) = s ∈ S B ∈ C in s , B ⊆ X, par(s) \ B ∩ M = ∅</formula><p>Our new operator-inspired reduct now just has to mimic the way the operator enforces the upper bound M. This is achieved by the definition below, which notably works for all ADFs, bipolar or not.</p><formula xml:id="formula_33">Definition 3.2. Let Ξ = (S, L, C in ) be an abstract dialectical framework. A set M ⊆ S is a stable model of Ξ iff it is the unique least model of the reduced ADF Ξ M = (S, L, C in M ) with B ∈ C in M,s iff B ∈ C in s , par(s) \ B ∩ M = ∅</formula><p>Intuitively, the reduct only changes the acceptance functions of statements such that accepting parent configurations that rely on some statement from M being out are discarded (since the statements in M are by virtue in). If the reduced ADF has a unique least model, and this least model coincides with M, then M is a stable model of the original ADF. It is easy to show that this new reduct-based definition of a stable model coincides with our operator-based definition of two-valued stable models. Proposition 3.9. Let Ξ = (S, L, C in ) be an abstract dialectical framework and M ⊆ S. (M, M) is a two-valued stable model of G Ξ iff M is a stable model of Ξ .</p><p>Proof. First observe that we find the two-valued consequence operator of the reduct Ξ M given for any X ⊆ S by </p><formula xml:id="formula_34">G Ξ M (X) = s ∈ S B ∈ C in s , par(s) \ B ∩ M = ∅, B ⊆ X, par(s) \ B ∩ X = ∅ Hence X ⊆ M implies G Ξ M (X) = G Ξ (X, M) and the two operators G Ξ M and G Ξ (•, M) coincide on all subsets of M. In particular, M is the least fixpoint of G Ξ (•, M) iff M is the least fixpoint of G Ξ M . (The least fixpoint of G Ξ (•, M) always exists since the operator is monotone in (2 S , ⊆).) Now (M, M) is a two-valued stable model of G Ξ iff M is the least fixpoint of G Ξ (•, M) iff M is the least fixpoint of G Ξ M iff M is the least model of Ξ M iff M is a stable model of Ξ 2</formula><formula xml:id="formula_35">M 2 = (S, L, C M 2 ) with C in M 2 ,a = {∅} and C in M 2 ,b = {{a, b}}.</formula><p>It is easy to see that {a} = M 2 is the least model of this ADF and M 2 is not a stable model of ξ .</p><p>The (new) reduct of ξ with M 1 = {a} is given by ξ</p><formula xml:id="formula_36">M 1 = (S, L, C in M 1 ) with C in M 1 ,a = {∅} and C in M 1 ,b = {{a, b}}.</formula><p>Its least model is {a} = M 1 and M 1 is thus a stable model of ξ , just as expected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.4.">Admissible sets</head><p>For the generalisation of admissibility provided by Brewka and Woltran <ref type="bibr" target="#b2">[3]</ref>, the picture is not quite as clear. Firstly, for the special case of Dung argumentation frameworks, any stable extension of an AF is admissible. So we should naturally expect that all ADF generalisations of stable AF extensions are also (the ADF generalisation of) admissible; more specifically, since for AF-based ADFs we have that stable extensions coincide with two-valued supported models of the ADF, for an ADF generalisation of admissibility we should expect that all two-valued supported models of the ADF are also admissible. But this is not the case for the generalisation of admissibility of Brewka and Woltran <ref type="bibr" target="#b2">[3]</ref>. Recall that a set M is BW-admissible iff there exists an R ⊆ S such that M is a stable model of Ξ -R. In other words, the links between a and b are both supporting. Hence the set {a, b} is a (two-valued supported) model of ξ , but it is not BW-admissible: {a, b} is not a stable model of ξ or any subframework of ξ .</p><p>It might seem that BW-admissibility is just too restrictive and could be fixed by weakening the definition. One possibility may be to replace "stable" in the definition of BW-admissibility by "supported." But, as the following example shows, already the current, stable-based definition of BW-admissibility considers too many sets to be admissible. in, so no reasonable semantics could ever label it out, and consequently the condition upon which BW-admissibility of {a, b} hinges can never become true. 6   There is an alternative characterisation of admissibility which satisfies all of our abovementioned criteria. That is, all two-valued supported models of an ADF are admissible in our new sense; and for the ADF from Example 3.5, the undesired BW-admissible set from above is not admissible according to this new definition. As a much more important property, it is defined for all ADFs and not only bipolar ones. It is also a generalisation of AF admissibility, as will be shown in Section 4.</p><p>Intuitively, we require that an admissible pair is first of all consistent and satisfies a further criterion: for any statement that is labelled with either in or out, the pair must provide sufficient justification for this choice. For a pair (M, N), this means that any statement that is labelled in (contained in M) must indeed be accepted by this pair; conversely, any statement that is labelled out (not contained in N) must indeed be rejected by the pair. Acceptance and rejection is expressed using the approximating operator, so for (M, N) we require M ⊆ G Ξ (M, N) (justified lower bound) and G Ξ (M, N) ⊆ N (justified upper bound). This combination is easily expressed using the information ordering.</p><formula xml:id="formula_37">Definition 3.3. For any ADF Ξ = (S, L, C ), a consistent pair (M, N) is admissible in Ξ iff (M, N) i G Ξ (M, N).</formula><p>It is clear that the lower bound of an admissible pair (M, N) is a conflict-free set since</p><formula xml:id="formula_38">M ⊆ G Ξ (M, N) ⊆ G Ξ (M, M) = G Ξ (M).</formula><p>Since for any two-valued supported model M we have (M, M) = G Ξ (M, M) it is also immediate that all twovalued supported models of an ADF are (three-valued supported models and in turn) admissible pairs. Interestingly, i -postfixpoints of operators O were also important for Denecker et al. <ref type="bibr" target="#b12">[13]</ref> -they called them O-reliable pairs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.5.">Preferred semantics</head><p>In principle, there could be different ways to define the preferred semantics for ADFs: (1) the argumentation way of taking all model candidates that are maximally admissible; (2) the logic-programming way of maximising over three-valued supported models. It is clear that any preferred pair derived according to (2) is also preferred in the sense of (1) since any three-valued supported model is admissible. But -as we will show next -the converse also holds, so it is inessential which of these two definitions we pick. This even holds for any approximating operator on a complete lattice, as is shown by the theorem below; in AF-speak, it expresses the operator generalisation of "all preferred extensions are complete." Theorem 3.10. Let (L, ) be a complete lattice and O be an approximating operator on (L 2 , i ). Any i -maximal admissible pair for O is a three-valued supported model for O.</p><p>Proof. Let (x, y) be an i -maximal admissible pair, that is, (x, y) i O(x, y) and there is no admissible pair (x, ŷ) with (x, y) &lt; i (x, ŷ). We have to show O(x, y) = (x, y), so assume to the contrary that O(x, y) i (x, y), that is, (x, y) &lt; i O(x, y). Since O is approximating, it is in particular i -monotone and from (</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>x, y) i O(x, y) we can infer O(x, y) i O(O(x, y)).</head><p>Thus O(x, y) is itself admissible and (x, y) &lt; i O(x, y), in contradiction to (x, y) being i -maximal admissible. 2</p><p>As an immediate consequence, we have the result that all maximal admissible ADF models are three-valued supported (as we will see, "complete") models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary 3.11. Let Ξ be an abstract dialectical framework. Any i -maximal admissible pair is a three-valued supported model.</head><p>This leads to the generalisation of AF preferred semantics for abstract dialectical frameworks (including non-bipolar ones): they are simply M-supported models of G Ξ , that is, i -maximal fixpoints of G Ξ . Since supported and stable semantics coincide for argumentation frameworks, another suitable candidate for generalising preferred semantics is the M-stable semantics for ADFs, that is, i -maximal fixpoints of SG Ξ . 6 Incidentally, {a, b} is also a BW-preferred model which does not contain the BW-well-founded model {b, c, d}. Since the grounded AF extension is always contained in any preferred AF extension, Example 3.5 also hints at another unexpected (non-)relation between the generalised ADF semantics of Brewka and Woltran <ref type="bibr" target="#b2">[3]</ref>.</p><p>Well-founded semantics. In order to generalise the grounded semantics from AFs to ADFs, Brewka and Woltran <ref type="bibr" target="#b2">[3]</ref> introduced -for an ADF Ξ = (S, L, C ) -the operator Γ Ξ on the bilattice (2 S × 2 S , i ). Motivated by naming conventions from logic programming, they decided to call (the lower bound of) the least fixpoint of Γ Ξ the "well-founded model" of an ADF. As our next result shows, their intuition of defining the operator was on the spot -they defined the most precise approximation of the two-valued ADF consequence operator G Ξ .<ref type="foot" target="#foot_5">7</ref> Lemma 3.12. For any abstract dialectical framework Ξ , the operator Γ Ξ is the ultimate approximation of G Ξ .</p><p>Proof. Recall that for Ξ = (S, L, C ) the operator Γ Ξ :</p><formula xml:id="formula_39">2 S × 2 S → 2 S × 2 S is given by (X, Y ) → (Γ Ξ (X, Y ), Γ Ξ (X, Y )), where Γ Ξ (X, Y ) = s ∈ S for all X ⊆ Z ⊆ Y , we have Z ∩ par(s) ∈ C in s Γ Ξ (X, Y ) = s ∈ S there exists X ⊆ Z ⊆ Y with Z ∩ par(s) ∈ C in s Now by [13, Theorem 5.6], for X ⊆ Y ⊆ S, the ultimate approximation U Ξ of the operator G Ξ is characterised by U Ξ (X, Y ) = (U Ξ (X, Y ), U Ξ (X, Y )) with U Ξ (X, Y ) = G Ξ (Z ) X ⊆ Z ⊆ Y U Ξ (X, Y ) = G Ξ (Z ) X ⊆ Z ⊆ Y</formula><p>By Lemma 3.1, we know that for any s ∈ S and Z ⊆ S we find Z ∩ par(s) ∈ C in s iff s ∈ G Ξ (Z ), which leads to the equalities</p><formula xml:id="formula_40">U Ξ (X, Y ) = G Ξ (Z ) X ⊆ Z ⊆ Y = s ∈ S for all X ⊆ Z ⊆ Y , we have s ∈ G Ξ (Z ) = s ∈ S for all X ⊆ Z ⊆ Y , we have Z ∩ par(s) ∈ C in s = Γ Ξ (X, Y )</formula><p>and, likewise for the upper bound,</p><formula xml:id="formula_41">U Ξ (X, Y ) = G Ξ (Z ) X ⊆ Z ⊆ Y = s ∈ S there exists X ⊆ Z ⊆ Y with s ∈ G Ξ (Z ) = s ∈ S there exists X ⊆ Z ⊆ Y with Z ∩ par(s) ∈ C in s = Γ Ξ (X, Y )</formula><p>which proves the claim. 2</p><p>This lemma immediately entails that what Brewka and Woltran <ref type="bibr" target="#b2">[3]</ref> called "well-founded" is what DMT call the ultimate Kripke-Kleene semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary 3.13. For any ADF Ξ , its BW-well-founded semantics coincides with its ultimate Kripke-Kleene semantics.</head><p>The well-founded semantics of Ξ in the usual sense (the least fixpoint of the stable operator SG Ξ ) hence may differ from the BW-well-founded semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 2.1 (Continued).</head><p>Recall that the ultimate Kripke-Kleene semantics of D is given by the pair ({a}, {a, b, c, d}) (the least model of the operator U D = Γ D ). The well-founded semantics of D in the logic-programming sense is given by the pair ({a, d}, {a, d}). Since this pair is exact, it also represents the unique two-valued stable model of D. (Recall that M 2 = {a, d} is the supported model of D where the self-support of b was rejected.)</p><p>We have seen how the characteristic operator of an ADF can be used to redefine several existing ADF semantics. The remaining operator-based semantics that we did not yet talk about therefore present new semantics for ADFs. Among them, we generalised complete AF extensions to ADFs (three-valued supported/stable models) which will be explored in more detail in the AF section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">From ADFs to logic programs</head><p>We now use the four-valued one-step ADF consequence operator to determine the relationship between ADFs and logic programs. As it turns out, there is a straightforward polynomial and modular translation from ADFs to logic programs which is additionally faithful with respect to all operator-based semantics. The translation creates logic program rules for each statement of a given ADF Ξ . The body of a rule for statement s is satisfied whenever for some M ⊆ par(s), the statements in M are in and the remaining parents are out. Definition 3.4. Let Ξ = (S, L, C in ) be an ADF. Define its standard logic program as follows. The next lemma shows that the term "standard logic program" is well-chosen, since the translation is faithful with respect to all operator-based semantics: the associated approximating operators of an ADF and its standard logic program are identical. The term B below denotes the complement of B with respect to the parents of s, that is, B = par(s) \ B. Lemma 3.14. For any ADF Ξ = (S, L, C in ), we find that G Ξ = T Π(Ξ) .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Π(Ξ)</head><formula xml:id="formula_42">def = s ← M ∪ not par(s) \ M s ∈ S, M ∈ C in</formula><formula xml:id="formula_43">Proof. Let X, Y ⊆ S. We show G Ξ (X, Y ) = T Π(Ξ) (X, Y ). G Ξ (X, Y ) = s ∈ S B ∈ C in s , B ⊆ X, B ∩ Y = ∅ = s ∈ S s ← (B ∪ not B) ∈ Π(Ξ), B ⊆ X, B ∩ Y = ∅ = s ∈ S s ← M ∈ Π(Ξ), B = M + ⊆ X, B = M -, M -∩ Y = ∅ = T Π(Ξ) (X, Y ) 2</formula><p>This result yields immediate correspondence of all operator-based semantics of an ADF Ξ with the respective semantics of its standard logic program Π(Ξ). In particular, G Ξ = T Π(Ξ) and an ADF and its standard logic program also agree on all semantics derived from the ultimate approximation of their two-valued operators. These results obviate that propositional normal logic programs are at least as expressive as abstract dialectical frameworks in a very strong sense: there exists a single translation that preserves models in a whole type of semantics. Furthermore, the translation can be computed in polynomial time and is modular with respect to statements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>More precisely, let</head><formula xml:id="formula_44">Ξ 1 = (S 1 , L 1 , C in 1 ) and Ξ 2 = (S 2 , L 2 , C in 2 ) be ADFs such that S 1 ∩ S 2 = ∅.</formula><p>Then the union of the two ADFs is defined as</p><formula xml:id="formula_45">Ξ 1 ∪ Ξ 2 def = (S 1 ∪ S 2 , L 1 ∪ L 2 , C in 1 ∪ C in 2 )</formula><p>. For such pairs of ADFs we indeed observe that the translation is modular: In both frameworks, the common statement a is supported by a statement which is always in. Consequently, a is always in for every model of every semantics in both ADFs. However, the union of the acceptance functions' characteristic sets is C in 1,a ∪ C in 2,a = {{b}, {c}}, and thus in the union ADF, statement a is always out since both parents are always in. The undesired result in this case is that a is always accepted in the two constituent ADFs but not accepted in their union, although this union should be expected to exhibit some kind of disjunctive acceptance with respect to its constituents. (For comparison, note that Π(ξ 1 ) = {a ← b, b ← ∅} and Π(ξ 2 ) = {a ← c, c ← ∅}, whence a is contained in the single (two-valued) stable model {a, b, c} of Π(ξ 1 ) ∪ Π(ξ 2 ).) Of course, the example above would work if we represented acceptance conditions by formulas ϕ 1,a = b and ϕ 2,a = c: then in the union of the two ADFs the acceptance formula is given by the disjunction ϕ 1,a ∨ ϕ 2,a = b ∨ c which has the desired set of models {{b}, {c}, {b, c}}. However, this is dependent on the specific chosen representation of acceptance conditions, namely propositional formulas. For the general case of overlapping sets of statements and an abstract stance with regard to the representation of acceptance conditions, it seems that a more sophisticated procedure for ADF merging is required. This makes it hard to assess a more general type of modularity concerning translations from ADF into logic programs.</p><formula xml:id="formula_46">Π(Ξ 1 ∪ Ξ 2 ) = Π(Ξ 1 ) ∪ Π(Ξ 2 ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">From logic programs to ADFs</head><p>To translate ADFs into logic programs, we essentially had to take the acceptance formulas, transform them into disjunctive normal form and write an LP rule for each disjunct. To translate logic programs into ADFs, this process is reversed: to devise an acceptance function for statement s, we take the disjunction of all bodies (read as conjunctions of literals) of rules with head s. Definition 3.5. (See Brewka and Woltran <ref type="bibr" target="#b2">[3]</ref>.) Let Π be a normal logic program over a set A of atoms. Define an ADF Ξ(Π) = (A, L, C in ) as follows.</p><formula xml:id="formula_47">• L def = {(b, a) | a ← M ∈ Π, b ∈ M + ∪ M -}. • For a ∈ A, set C in a def = {B ⊆ par(a) | a ← M ∈ Π, M + ⊆ B, M -∩ B = ∅}.</formula><p>Alternatively, we could define the acceptance condition of each a ∈ A by</p><formula xml:id="formula_48">ϕ a def = a←M∈Π m∈M + m ∧ m∈M - ¬m</formula><p>Although straightforward, the translation is obviously not modular, since all logic program rules with head a are needed to devise the acceptance condition for statement a. Furthermore, the translation is not faithful with respect to three-valued semantics defined by the approximating operator G Ξ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 3.8 (Lost in translation)</head><p>. Consider the following two logic programs over the signature A = {a, b, c} that have a common subprogram π = {c ← ∅, b ← not b}:</p><formula xml:id="formula_49">1. π 1 = π ∪ {a ← b, a ← c}. 2. π 2 = π ∪ {a ← {b, not c}, a ← {c, not b}, a ← {b, c}}.</formula><p>The ADF translations of the two programs are identical: we have Ξ(π However, the original logic programs π 1 and π 2 do not have the same three-valued models: While the only (three-valued supported) model of π 1 is ({a, c}, {a, b, c}), the only (three-valued supported) model of π 2 is ({c}, {a, b, c}). That is, when we force the truth values of c to be true and b to be undefined (in the common subprogram π ), the result is that a is true in π 1 (the disjunction b ∨ c evaluates to true) but undefined in π 2 (all the conjuncts b ∧ ¬c, c ∧ ¬b and b ∧ c evaluate to undefined).</p><formula xml:id="formula_50">1 ) = Ξ(π 2 ) = (A, L, C in</formula><p>However, the translation is faithful for two-valued supported semantics, as we will show next. Technically, this is proved by establishing a correspondence between the two-valued one-step consequence operators T Π for a logic program Π and G Ξ(Π) for the logic program's ADF Ξ(Π) in the following lemma.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 3.16. For any normal logic program Π , we have T Π = G Ξ(Π) .</head><p>Proof. Abbreviate Ξ(Π) = Ξ , let A be the signature of Π and let X, Y ⊆ A. We show something slightly more general than</p><formula xml:id="formula_51">G Ξ (X) = G Ξ (X, X) = T Π (X, X) = T Π (X). 1. G Ξ (X, Y ) ⊆ T Π (X, Y ): Let a ∈ G Ξ (X, Y ). Then there is a B ∈ C in a with B ⊆ X and B ∩ Y = ∅.</formula><p>By definition of Ξ(Π), there is a B ⊆ par(a) and a rule a ← M ∈ Π with M + ⊆ B and M -∩ B = ∅. We have to show that M + ⊆ X (this is immediate) and M -∩ Y = ∅. Assume to the contrary that there is a</p><formula xml:id="formula_52">b ∈ M -∩ Y . Then M -∩ B = ∅ implies b / ∈ B. Similarly, B ∩ Y = ∅ implies that b / ∈ B. Thus b / ∈ B ∪ B = par(a), which is a contradiction to b ∈ M -, a ← M ∈ Π and the definition of Ξ(Π). 2. T Π (X, X) ⊆ G Ξ (X, X): Let a ∈ T Π (X, X). Then there is a rule a ← M ∈ Π with M + ⊆ X and M -∩ X = ∅. Define B def = par(a) ∩ X . We have to show that B ∈ C in a , B ⊆ X (obvious) and B ∩ X = ∅. For the last item, we have that B = par(a) \ B = par(a) \ (par(a) ∩ X) = par(a) \ X , whence B ∩ X = ∅. Finally, a ← M ∈ Π means M + ⊆ par(a) and together with M + ⊆ X we get M + ⊆ B = par(a) ∩ X . Since B ⊆ X , we have M -∩ B = ∅. By definition B ⊆ par(a) and thus B ∈ C in a .</formula><p>2</p><p>From the proof we can read off that Π can derive anything that Ξ(Π) can derive, for any three-valued pair; in the converse direction, this only works for two-valued pairs. As an immediate consequence, we get correspondence of two-valued supported models.</p><p>Corollary 3.17. Let Π be a normal logic program over a set A of atoms and Ξ = Ξ(Π) be its associated abstract dialectical framework.</p><p>For any set X ⊆ A,</p><formula xml:id="formula_53">G Ξ (X, X) = (X, X) iff T Π (X, X) = (X, X).</formula><p>As another consequence of the proof of Lemma 3.16, we can also show that LP-based ADFs are sound with respect to two-valued stable models of the LP, that is, any stable model of Ξ(Π) is a stable model of Π .</p><p>Lemma 3.18. Let Π be a normal logic program over a set A of atoms and Ξ = Ξ(Π) be its associated abstract dialectical framework. For any set X ⊆ A,</p><formula xml:id="formula_54">SG Ξ (X, X) = (X, X) implies ST Π (X, X) = (X, X). Proof. Let SG Ξ (X, X) = (X, X). Then X is the least fixpoint of G Ξ (•, X) and in particular G Ξ (X, X) = X . Now by Lemma 3.16 above, we get T Π (X, X) = X and X is a fixpoint of T Π (•, X). It remains to show that X is the least fix- point of T Π (•, X). Let Y be a prefixpoint of T Π (•, X), that is, T Π (Y , X) ⊆ Y . By Item 1 in the proof of Lemma 3.16 we have G Ξ (Y , X) ⊆ T Π (Y , X), whence G Ξ (Y , X) ⊆ Y and Y is a prefixpoint of G Ξ (•, X). Since X is the least fixpoint of G Ξ (•, X)</formula><p>and thus also its least prefixpoint, we get X ⊆ Y and thus X is the least (pre)fixpoint of T Π (•, X). 2</p><p>The converse of the lemma does not hold:</p><p>Example 3.9. Let π = {a ← ∅, a ← a}. This program has the two-valued stable model {a}.</p><formula xml:id="formula_55">Its resulting ADF is ξ = Ξ(π ) = ({a}, {(a, a)}, {C in a }) with C in a = {∅, {a}}.</formula><p>Interestingly, the link (a, a) is both supporting and attacking -that is, it contains no information. When trying to reconstruct the (LP) stable model {a}, we observe that G ξ (∅, {a}) = ∅ and {a} is not a (ADF) stable model for ξ .</p><p>As much more interesting consequence of Lemma 3.16, it follows that the ultimate approximations of T Π and G Ξ(Π) are identical, thus Π and Ξ(Π) also coincide on all ultimate semantics, including ultimate stable models. This means that whatever "goes missing" in the translation from Π to Ξ(Π) can be recovered by the construction of the ultimate approximation. This should however be taken with a grain of salt, since the ultimate versions of approximation semantics are generally accompanied by higher computational costs <ref type="bibr" target="#b12">[13]</ref>. So while information thrown away through translation can be recovered, it seems much more economic to keep the information during translation instead of paying for a subsequent reconstruction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">A special case: Argumentation frameworks</head><p>In this section we look at the subset of ADFs which corresponds to AFs. Recall that for AFs, the original lattice of interest (2 A , ⊆) considers sets of arguments and the subset relation. The corresponding bilattice (2 A × 2 A , i ) is concerned with pairs of sets of arguments and ordered by the information ordering. The elements of this bilattice generalise three-valued labellings <ref type="bibr" target="#b5">[6]</ref> to the four-valued case: for a pair (S, P ), the arguments in S ∩ P are in, those in S ∪ P are out, those in P \ S are undecided and those in S \ P get the new label inconsistent. Consistent pairs (those (S, P ) with S ⊆ P ) obviously are three-valued labellings, where exactly all arguments in S are in.</p><p>As our first observation, we note that the approximating operator that Definition 3.1 assigns to the ADF of an AF Θ is also a special case of an operator: it is the canonical approximation of U Θ , the operator assigning to a set S of arguments all the arguments from A which are not attacked by S. </p><formula xml:id="formula_56">G Ξ(Θ) (X, Y ) = (U Θ (Y ), U Θ (X)). Proof. We have to show G Ξ(Θ) (X, Y ) = U Θ (Y ). Recall that Ξ(Θ) = (A, R, C in ), where C in a = {∅} for each a ∈ A. Thus for any argument a ∈ A, we find that par(a) = Attackers Θ (a). Now a ∈ G Ξ(Θ) (X, Y ) iff B ∈ C in a , B ⊆ X, par(a) \ B ∩ Y = ∅ iff B = ∅, B ⊆ X, par(a) \ B ∩ Y = ∅ iff par(a) ∩ Y = ∅ iff Attackers Θ (a) ∩ Y = ∅ iff a ∈ U Θ (Y ) 2</formula><p>In the remainder, we will denote the four-valued approximation operator of an argumentation framework Θ by F Θ ; we</p><formula xml:id="formula_57">formally define F Θ def = G Ξ(Θ)</formula><p>. It follows by definition that the characteristic operator F Θ of an AF is its own stable operator: Lemma 4.2. For any argumentation framework Θ, we have SF Θ = F Θ .</p><formula xml:id="formula_58">Proof. Let Θ = (A, R) and X, Y ⊆ A. We have to show SF Θ (X, Y ) = F Θ (X, Y ). Now SF Θ (X, Y ) = lfp(F Θ (•, Y )) = lfp(U Θ (Y )) = U Θ (Y ) = F Θ (X, Y ). 2</formula><p>This means informally that (in a sense) there are fewer semantics for Dung frameworks than there are for ADFs, logic programming, default logic and autoepistemic logic. Translated into logic programming language, we have that in Dung-style argumentation, supported and stable models coincide, and well-founded semantics equals Kripke-Kleene semantics. Put in different terms of default and autoepistemic logics: for argumentation frameworks, Moore expansions and Reiter extensions coincide!</p><p>In principle, this collapsing picture could be due to a mistake in our definition of the characteristic operator. In the following section, it will become clear that this is not the case and the characteristic operator of an argumentation framework is well-designed: we show next how the major semantics of argumentation frameworks can be redefined in terms of fixpoints of the characteristic operator.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Fixpoint semantics for abstract argumentation frameworks</head><p>As a first illustration of universality of the characteristic operator of an AF, we recapitulate a result that is well-known in the argumentation community: the operator U Θ (which is at the heart of F Θ ) can emulate the characteristic function F Θ of an argumentation framework: F Θ is the same as twofold application of U Θ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 4.3. (See [14, Lemma 45].) For any AF Θ, we have F</head><formula xml:id="formula_59">Θ = U 2 Θ .</formula><p>For our operator F Θ , this means that for any X, Y ⊆ A we have</p><formula xml:id="formula_60">F 2 Θ (X, Y ) = F Θ U Θ (Y ), U Θ (X) = U 2 Θ (X), U 2 Θ (Y ) = F Θ (X), F Θ (Y )</formula><p>There are several works in the literature that redefine argumentation semantics in terms of (pre-/post-)fixpoints of the two operators F Θ and U Θ <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b22">23]</ref>. Since the two operators are closely related and the characteristic approximating operator F Θ can express them both, we can reconstruct argumentation semantics based entirely on this single operator.</p><p>We begin with the simplest semantics: recall that for Θ = (A, R) a set E of arguments is a stable extension iff E = U Θ (E), so the following is immediate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 4.4. Let Θ = (A, R) be an argumentation framework and E</head><formula xml:id="formula_61">⊆ A. Then E is a stable extension of Θ iff F Θ (E, E) = (E, E).</formula><p>It is almost as easy to characterise the class of complete extensions: Proposition 4.5. Let Θ = (A, R) be an argumentation framework and E ⊆ A. Then E is a complete extension of Θ iff for some E ⊆ A the pair (E, E ) is a consistent fixpoint of F Θ .</p><p>Proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>There is an</head><formula xml:id="formula_62">E ⊆ A with E ⊆ E and F Θ E, E = E, E iff E ⊆ E and E = U Θ (E) and E = U Θ E iff E ⊆ U Θ (E) and E = U 2 Θ (E) iff E is conflict-free and E = F Θ (E) iff E is a complete extension.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>As an easy corollary, we get the grounded semantics as the i -least fixpoint of the characteristic operator. This fixpoint exists since F Θ is i -monotone.</p><p>Corollary 4.6. Let Θ = (A, R) be an argumentation framework and E ⊆ A. Then E is the grounded extension of Θ iff for some E ⊆ A the pair (E, E ) is the i -least fixpoint of F Θ .</p><p>In the sequel, we use the term "complete extension" for the set E and the pair (E, E ) interchangeably. It follows by definition that preferred extensions are exactly those consistent fixpoints where E is ⊆-maximal -the M-supported models of F Θ . Proposition 4.7. Let Θ = (A, R) be an argumentation framework and E ⊆ A. Then E is a preferred extension of Θ iff for some E ⊆ A the pair (E, E ) is a consistent fixpoint of F Θ where E is ⊆-maximal.</p><p>Alternatively, we can say that for a consistent pair (E, E ) the lower bound E is a preferred extension if and only if the pair is M-supported/M-stable for F Θ . This immediately yields a "preferred" semantics for default logic, which is an improvement upon a result by Dung <ref type="bibr" target="#b13">[14,</ref><ref type="bibr">Theorem 43]</ref>, who defined preferred semantics for default logic only through a translation to infinite AFs.</p><p>Semi-stable extensions are those complete ones where the set of arguments in the upper but not in the lower bound (the undecided arguments) is minimal -L-supported/L-stable models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 4.8. Let Θ = (A, R) be an argumentation framework and E ⊆ A. Then E is a semi-stable extension of Θ iff for some</head><formula xml:id="formula_63">E ⊆ A the pair (E, E ) is a consistent fixpoint of F Θ where E \ E is ⊆-minimal. Proof. E ∪ Attacked Θ (E) is ⊆-maximal iff E ∪ E is ⊆-maximal iff E ∪ E is ⊆-minimal iff E ∩ E is ⊆-minimal iff E \ E is ⊆-minimal. 2</formula><p>Finally, we show that the ADF version of "admissible" (Definition 3.3) is a proper generalisation of the respective AF notion. This is easily shown using the respective associated approximating operators. Proposition 4.9. Let Θ = (A, R) be an argumentation framework and X ⊆ A. Then X is an admissible set for Θ iff (X, U Θ (X)) is an admissible pair for F Θ .</p><p>Proof. Abbreviate Y def = U Θ (X). We have the following equivalences:</p><formula xml:id="formula_64">X is an admissible set for Θ iff X is conflict-free and X ⊆ F Θ (X) iff X ⊆ U Θ (X) and X ⊆ U 2 Θ (X) iff X ⊆ Y and X ⊆ U Θ (Y ) and U Θ (X) ⊆ Y iff X ⊆ Y and (X, Y ) i U Θ (Y ), U Θ (X) iff (X, Y ) is consistent and (X, Y ) i F Θ (X, Y ) iff (X, Y ) is an admissible pair for F Θ 2</formula><p>Jakobovits and Vermeir <ref type="bibr" target="#b23">[24]</ref> introduced four-valued labellings for argumentation frameworks. Using indicators for acceptance (+) and rejection (-), they define the labels in = {+}, out = {-}, undec = {+, -} and irrelevant = ∅. It is possible to adapt our intuition behind pairs (X, Y ) of sets of arguments in the sense that those in X \ Y are irrelevant (instead of inconsistent); in this case, their labels can be seen as indicating which of the two possible statuses + andare still logic program can be simplified to the following:</p><formula xml:id="formula_65">Π(Θ) def = a ← not Attackers Θ (a) a ∈ A</formula><p>Note that the positive body is empty in general since there is no notion of support in classical Dung-style AFs. Also, the negative bodies of the rules are finite if and only if the framework is finitary.</p><p>It should be noted that the standard translation from AFs to LPs is not modular, since the LP rule for an atom a depends on all attackers of a. This might seem paradoxical at first, since the standard translation from ADFs to LPs is modular with respect to statements. But recall that the union of two ADFs is defined whenever the two have disjoint statements, so for AFs with disjoint sets of arguments the standard translation is again modular with respect to arguments.</p><p>It is immediate from Lemma 3.14 that the associated operators of AFs Θ and their translated logic program Π(Θ) are the same.</p><p>Corollary 4.11. For any argumentation framework Θ, we have F Θ = T Π(Θ) . Now we know from Lemma 4.2 that the approximation operator of any AF Θ is its own stable operator -in symbols F Θ = SF Θ . Combining these two results about F Θ leads to the following lemma, which nicely pictures the special role of argumentation frameworks in the realm of nonmonotonic reasoning formalisms. Lemma 4.12. For any AF Θ, we have T Π</p><formula xml:id="formula_66">(Θ) = F Θ = SF Θ = ST Π(Θ) .</formula><p>Since the consequence operator of a logic program yields its Kripke-Kleene and well-founded models as well as its twovalued and three-valued supported and stable models, this lemma immediately gives rise to several important coincidence results, accumulated in the first main result of this section below. Its first and last items are obvious. The second item contains the conclusion of Wu et al. <ref type="bibr" target="#b42">[43,</ref><ref type="bibr">Theorem 17]</ref> (they did not look at supported semantics), while the third and fourth items imply new results that solve open problems posed there. Theorem 4.13. Let Θ be an AF. The following are identical:</p><p>1. the grounded extension of Θ, the Kripke-Kleene model of Π(Θ) and the well-founded model of Π(Θ); 2. complete extensions of Θ, three-valued supported models of Π(Θ) and three-valued stable models of Π(Θ); 3. preferred extensions of Θ, M-supported models of Π(Θ) and M-stable models of Π(Θ); 4. semi-stable extensions of Θ, L-supported models of Π(Θ) and L-stable models of Π(Θ); 5. stable extensions of Θ, two-valued supported models of Π(Θ) and two-valued stable models of Π(Θ).</p><p>Proof. The first item is obvious, since they are the least fixpoint of the same operator; the rest follows from Lemma 4.12 and Propositions 4.5, 4.7, 4.8 and 4.4. 2</p><p>As witnessed by Lemma 3.14, for the standard translation the correspondence between AFs and LPs is immediate. We will next consider a different translation where this correspondence is less obvious, albeit still present. Most importantly, that translation will be modular for all argumentation frameworks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2.">Dung's translation</head><p>Dung duplicates the arguments, thereby explicitly keeping track of their being in or out: for a ∈ A, a new propositional variable -a expresses defeat of a by some counterargument. Note that this translation is modular with respect to both arguments and attacks, and furthermore rule bodies are always finite.<ref type="foot" target="#foot_6">9</ref>  Π D (Θ)</p><formula xml:id="formula_67">def = {a ← not -a | a ∈ A} ∪ -a ← b (b, a) ∈ R</formula><p>Intuitively, an argument a is accepted (signified by atom a) unless it is defeated (signified by atom -a). An argument is defeated if it is attacked by an accepted argument. We show next that the four-valued one-step consequence operator for the logic program resulting from Dung's translation essentially does the same as the characteristic operator of the original argumentation framework. It only needs twice as many steps due to the syntactical duplication of arguments.</p><p>To show this result, we need the technical notion of coherence: in words, a pair is coherent if it respects the intuition of -a for a ∈ A, in the sense that a is true iff -a is false and vice versa. A pair (S, P ) of sets of arguments can be extended to matching pairs (S * , P * ) of logic program atoms over A ± in a straightforward way. Definition 4.3. Let A be a set of arguments and S * , P * ⊆ A ± . The pair (S * , P * ) is coherent iff for all a ∈ A, we find a ∈ S * iff -a / ∈ P * and a ∈ P * iff -a / ∈ S * . For S, P ⊆ A, define co(S, P ) def = (S ∪ -P , P ∪ -S). <ref type="foot" target="#foot_7">10</ref>Observe that -X = {-a | a / ∈ X}, so it is clear that the pair co(S, P ) is coherent. What the function does, intuitively, is simple: if a is not in the upper bound P , that is, cannot become true any more, then it can be considered false, which is expressed by adding -a to the lower bound; likewise, if a is not in the lower bound S, that is, is not yet considered true, then its falsity must be considered an option, which leads to -a being added to the upper bound. These manipulations are entirely syntactic and do not mention attacks.</p><p>We are now ready to show that for an AF Θ = (A, R), its standard translation Π(Θ) and Dung translation Π D (Θ) have the same four-valued supported models with respect to the original signature A. Technically, we show that the fixpoints of their four-valued one-step consequence operators coincide. T Π (S, P ) = (S, P ) iff T Π D co(S, P ) = co(S, P )</p><p>Proof. We first observe that for any X, Y ⊆ A and a ∈ A, by definition of  1. the grounded extension of Θ, the Kripke-Kleene model of Π D (Θ) and the well-founded model of Π D (Θ); 2. complete extensions of Θ, three-valued supported models of Π D (Θ) and three-valued stable models of Π D (Θ); 3. preferred extensions of Θ, M-supported models of Π D (Θ) and M-stable models of Π D (Θ); 4. semi-stable extensions of Θ, L-supported models of Π D (Θ) and L-stable models of Π D (Θ); 5. stable extensions of Θ, two-valued supported models of Π D (Θ) and two-valued stable models of Π D (Θ).</p><formula xml:id="formula_68">Π D we have a ∈ T Π D (X, Y ) iff -a / ∈ Y and -a ∈ T Π D (X, Y ) iff a / ∈ U Θ (X), whence T Π D (X, Y ) = {a | -a / ∈ Y } ∪ -U Θ (X) and T Π D (X, -Y ) = Y ∪ -U Θ (X). Now</formula><p>Proof. Follows from Theorem 4.14, Proposition 4.15 and Propositions 4. 5, 4.7, 4.8 and 4.4. 2   This theorem conclusively shows that Dung's modular translation from AFs to LPs is faithful with respect to all operatorbased semantics. We infer that propositional normal logic programs are at least as expressive as abstract argumentation frameworks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">From logic programs to argumentation frameworks</head><p>For ADFs, we have seen how the standard translation into logic programs could straightforwardly be reversed into a translation from normal logic programs to ADFs that was sound with respect to both two-valued supported and stable model semantics. In the case of AFs, however, things are different.</p><p>Dung <ref type="bibr" target="#b13">[14]</ref> defined two semantics-independent translations from normal logic programs into argumentation frameworks. When restricted to propositional programs, his first translation (Section 4.3.2) is polynomial and faithful with respect to two-valued supported models and the Kripke-Kleene semantics, but not modular. Furthermore it is not faithful with respect to two-valued stable models: the logic program {a ← a} has the only two-valued stable model ∅, but its associated argumentation framework <ref type="foot" target="#foot_8">11</ref> ({a, ¬a}, {(a, ¬a), (¬a, a)}) has two stable extensions (corresponding to the logic program's two-valued supported models). For Dung's second translation (Section 4.3.1), the size of the resulting argumentation framework mayin the worst case -be at least exponential in the number of atoms in the vocabulary of the logic program.</p><p>Although it is certainly possible to devise polynomial, semantics-dependent translations from logic programs into argumentation frameworks (as a start, consider translating a logic program into an ADF to which in turn the translation from Brewka et al. <ref type="bibr" target="#b3">[4]</ref> is applied), we consider it unlikely that any such translation is polynomial, faithful and modular. In particular, it is highly unlikely that a polynomial and modular translation is faithful with respect to both supported and stable semantics, as these two semantics are not equal in general but coincide for abstract argumentation frameworks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">General semantics for approximating operators</head><p>We have seen how the characteristic operator of an ADF can be used to redefine the existing ADF semantics. In addition, this introduced the admissible, preferred and stable semantics for all ADFs -they were previously only defined for bipolar ADFs. We have also seen that an ADF Ξ and its standard logic program Π(Ξ) correspond on all semantics which are defined for both ADFs and LPs. Finally, we have seen how the characteristic operator of Dung-style argumentation frameworks (given by AF-based ADFs) allows to redefine AF semantics for operators. This allows us to easily transfer definitions of semantics from abstract argumentation to abstract dialectical frameworks, logic programming and beyond -to the general case of approximating operators.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Admissible</head><p>In Dung argumentation frameworks, a set of arguments is admissible if it is conflict-free and defends itself against all attacks. For abstract dialectical frameworks, we have seen in Definition 3.3 and Proposition 4.9 that a suitable ADF generalisation of AF admissibility is given by consistent pairs that are postfixpoints with respect to the information ordering i . These pairs have the property that applying the revision operator increases (or preserves) their information content. For the sake of completeness we have included the following formal definition. Definition 5.1. Let (L, ) be a complete lattice and O an approximating operator on the bilattice (L 2 , i ). A consistent pair (x, y) ∈ L 2 is admissible for O iff (x, y) i O(x, y).</p><p>Denecker et al. <ref type="bibr" target="#b12">[13]</ref> already took special note of admissible pairs and called them O-reliable. They point out that O-reliable pairs -consistent pairs whose O-revisions are at least as accurate -are especially useful for studying fixpoints of O , the original operator that O approximates. In particular, the i -least element (⊥, ) is O-reliable; iterating O on it leads to the Kripke-Kleene semantics, which provides a more precise approximation to all fixpoints of the approximated operator O .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Semi-stable</head><p>Theorem 4.13 and Proposition 4.8 immediately yield a definition of L-stable/semi-stable semantics for default and autoepistemic logics. Complete semantics for the two are given by consistent fixpoints (those (x, y) with x y) of an approximating operator. To generalise semi-stable to operators we simply have to generalise the minimality criterion of L-stable models for logic programming. Since this involves algebraic operations on lattice elements, we have to make some more restricting assumptions on the underlying lattice.</p><p>In the sequel, for a complete lattice (L, ) with join and meet , we assume the existence of a function • -1 : L → L such that for any x, y ∈ L,</p><formula xml:id="formula_69">• (x -1 ) -1 = x (• -1 is involutive),</formula><p>• (x y) -1 = x -1 y -1 and (x y) -1 = x -1 y -1 (de Morgan's laws).</p><p>In the special cases we have seen so far, the role of this "negation" is played by set complement with respect to the underlying vocabulary.</p><p>Definition 5.2. Let (L, ) be a complete lattice and O an approximating operator on its corresponding bilattice (L 2 , i ).</p><p>A consistent pair (x, y) is L-supported iff it is a fixpoint of O and y x -1 is -minimal. A consistent pair (x, y) is L-stable iff it is a fixpoint of SO and y x -1 is -minimal.</p><p>For the special case of argumentation, these general definitions of L-supported and L-stable reduce to a consistent fixpoint (S, P ) of F Θ = SF Θ such that P ∩ S = P \ S (the set of undecided arguments) is ⊆-minimal -a semi-stable extension.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Conflict-free</head><p>In classical abstract argumentation, a set of arguments is conflict-free if there are no attacks amongst its members. For abstract dialectical frameworks, a set of statements is conflict-free if each statement -informally speaking -has a reason to be in the set. This reason for one entails absence of any attackers as well as presence of supporters in case the statement's acceptance conditions so requires.</p><p>To generalise this notion to three-valued pairs (X, Y ), we require two things:</p><p>• any in statement (in X ) must have a reason not to be out, and • any out statement (not in Y ) must have a reason to be out.</p><p>Notice the asymmetry, which resurfaces in the following operator-based definition. For a consistent pair to be conflictfree, we stipulate that applying the approximating operator improves the upper bound of the pair. Definition 5.3. Let (L, ) be a complete lattice and O an approximating operator on the bilattice (L 2 , i ). A consistent pair (x, y) ∈ L 2 is conflict-free for O iff x O (x, y) y.</p><p>Let us illustrate this notion on a standard example AF. It shows that conflict-free pairs allow to set arguments to undec that attack in arguments.  Let us again take note of the asymmetry in the definition of conflict-free pairs. If admissible pairs ensure that during revision, both lower and upper bounds are improved, why should conflict-free pairs be defined such that only the upper bound must improve? Why not improve the lower bound? Another possibility to define conflict-free pairs would have been to say a pair (x, y) is conflict-free for an operator O iff x O (x, y) y. In AF terms, this alternative notion allows to set arguments to undec that are attacked by in arguments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 5.1 (Continued).</head><p>In the odd attack cycle between three arguments, the alternative conflict-free pairs (improving the lower bound) are </p><formula xml:id="formula_70">⊆ A such that X ⊆ U θ (Y ) ⊆ Y . It follows that b ∈ U θ (Y ), that is, Y does not attack b. Thus Y does not contain a and Y ⊆ {b} = X . From X ⊆ Y we conclude X = Y = {b}. But we find that U θ (Y ) = {a, b} Y . Contradiction.</formula><p>We want to stress that these two different generalisations of conflict-free sets are not an artefact of using approximating operators. Rather, they occur in the step from two-valued to three-valued semantics. As opposed to the alternative, the version requiring improvement of the upper bound generalises conflict-free sets. Proposition 5.2. Let Θ = (A, R) be an AF and X ⊆ A. X is conflict-free iff (X, U Θ (X)) is a conflict-free pair.</p><formula xml:id="formula_71">Proof. X is conflict-free iff X ⊆ U Θ (X) iff X, U Θ (X) is consistent and X ⊆ F Θ (X, Y ) ⊆ U Θ (X) iff X, U Θ (X) is a conflict-free pair<label>2</label></formula><p>Indeed, this notion of conflict-free pairs for AFs coincides with Caminada's definition of conflict-free labellings <ref type="bibr" target="#b6">[7]</ref>.</p><formula xml:id="formula_72">Proposition 5.3. For any AF Θ = (A, R) and X ⊆ Y ⊆ A, the pair (X, Y ) is conflict-free iff the labelling l : A → {in, out, undec} with X → in, Y \ X → undec, A \ Y → out is conflict-free in the sense of [7, Definition 3].</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.">Naive</head><p>It is clear that conflict-free pairs are amenable to the usual maximisation criteria that lead from admissible to preferred and semi-stable semantics. We begin with naive semantics, which for AFs are just ⊆-maximal conflict-free sets.</p><p>Definition 5.4. Let (L, ) be a complete lattice and O an approximating operator on its corresponding bilattice (L 2 , i ).</p><p>A consistent pair (x, y) ∈ L 2 is an M-conflict-free pair for O iff it is i -maximal among the conflict-free pairs for O.</p><p>We keep our uniform naming conventions for recording maximisation criteria. It is straightforward that this definition generalises naive semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 1</head><p>Operator-based semantical notions. All of them are defined for x, y ∈ L with x y for complete lattices (L, ) and approximating operators O on their corresponding bilattice, in some cases (L-stage, L-supported, L-stable) with additional restrictions on join, meet and involution operations on the lattice. conflict-free pair (x, y)</p><p>x O (x, y) y M-conflict-free pair (x, y)</p><p>x O (x, y) y and (x, y) is i -maximal L-conflict-free pair (x, y)</p><p>x O (x, y) y and y x SO(x, y) = (x, y) and y x -1 is -minimal two-valued stable model (x, x) SO(x, x) = (x, x) Fig. <ref type="figure">1</ref>. Inclusion relations between operator-based semantics. Nodes depict semantical notions for elements of a bilattice, where the names in parentheses are argumentation versions of these notions. Directed edges indicate subset relationships between the sets of all bilattice elements which satisfy the respective semantical notion. For example, the arrow from admissible to conflict-free in the lower right corner means that all admissible pairs are conflict-free.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusion</head><p>We embedded abstract dialectical frameworks into Denecker et al.'s lattice-theoretical formalism for the abstract study of nonmonotonic logical languages. This provides useful insights into the relationship of abstract argumentation frameworks and abstract dialectical frameworks with other nonmonotonic knowledge representation formalisms.</p><p>In this last section, we will provide a concise overview over the results of our investigation. First, for reference and as a completion of the table in Definition 2.2, we review the definitions of operator-based semantics in Table <ref type="table">1</ref>.</p><p>Fig. <ref type="figure">1</ref> then depicts the relationship between the different semantical notions explored in this paper. If a semantics σ is seen as a function assigning to a knowledge base κ a set of models, then a partial order on semantics is given by σ 1 σ 2 iff σ 1 (κ) ⊆ σ 2 (κ) for all κ. In the figure, an arrow from σ 1 to σ 2 expresses σ 1 σ 2 -in words, all σ 1 -models are also σ 2 -models.</p><p>Next, Table <ref type="table">2</ref> shows the correspondences between different argumentation semantics and operator-based semantics. The operator-based semantics lead to new semantics for default logic and autoepistemic logics via their respective consequence operators <ref type="bibr" target="#b11">[12]</ref>. A discussion of these semantics is however out of the scope of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 2</head><p>Overview over semantics for approximating operators, argumentation frameworks and abstract dialectical frameworks. Semantics newly defined in this paper are written in bold font. Most extension semantics for AFs have at least two generalisations, a supported and a stable one. While most argumentation semantics already had a corresponding operator semantics, we found that conflict-free and admissible sets and stage extensions lead to new semantical notions for approximating operators. The operator-based versions of argumentation semantics then directly lead to the ADF generalisations of these semantics, most of which are newly defined in this paper. M/L-stable/supported models for operators are straightforwardly generalised notions from logic programming. Operator-based semantics then immediately lead to semantics for default logic and autoepistemic logic (not included in this presentation).  Finally, Fig. <ref type="figure" target="#fig_17">2</ref> on p. 68 shows the location of abstract dialectical frameworks with respect to different approaches in the area of nonmonotonic reasoning. We use a very strong notion of one formalism being at least as expressive as another: the existence of a polynomial and modular translation that is faithful with respect to all operator-based semantics. Such results existed previously for the translation from logic programs into default theories of Marek and Truszczy ński <ref type="bibr" target="#b26">[27]</ref>, and the translation from default logic into autoepistemic logic of Konolige <ref type="bibr" target="#b25">[26]</ref> -for details see Denecker et al. <ref type="bibr" target="#b10">[11]</ref>. In this paper, we added argumentation frameworks and abstract dialectical frameworks to the picture.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Operator</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related work.</head><p>The several new correspondence results for AFs and logic programs we proved extended results of Wu et al. <ref type="bibr" target="#b42">[43]</ref>, who showed correspondence of complete extensions and three-valued stable models. While the results of Wu et al. <ref type="bibr" target="#b42">[43]</ref> use the translation of Gabbay and d'Avila Garcez <ref type="bibr" target="#b18">[19]</ref>, they do not motivate the use of this -we call it standard -translation nor provide a comparison to the much older Dung translation. In this paper we showed that using the standard translation is justified; what is more, we even proved that the standard translation and Dung's translation produce equivalent programs.</p><p>Concerning translations from AFs into LPs, related work has also been done by a number of authors, albeit with different goals: Both Wakaki and Nitta <ref type="bibr" target="#b41">[42]</ref> and Egly et al. <ref type="bibr" target="#b14">[15]</ref> want to efficiently implement different argumentation semantics using the stable model semantics for logic programming. Furthermore they employ meta-programming and answer set programming with variables to allow for modular translations. Toni and Sergot <ref type="bibr" target="#b38">[39]</ref> survey these and other uses of (forms of) answer set programming to implement abstract argumentation semantics. Nieves et al. <ref type="bibr" target="#b30">[31]</ref> define new argumentation semantics that possess certain desired properties. They do this by first providing a general recursive schema for obtaining new logic programming semantics and then defining the argumentation semantics via the AFs' translated logic programs. The translation from AFs into LPs they use is very similar to the one of Dung <ref type="bibr" target="#b13">[14]</ref>.</p><p>Besnard and Doutre <ref type="bibr" target="#b0">[1]</ref> redefined argumentation semantics in terms of fixpoints, but they do not look at grounded or semi-stable semantics and do not use their insights to embed argumentation frameworks into the larger picture. Very recently, Grossi <ref type="bibr" target="#b22">[23]</ref> investigated fixpoint-based definitions of argumentation semantics to study the connection between argumentation and dynamic epistemic logic. Ellmauthaler and Wallner <ref type="bibr" target="#b16">[17]</ref> most recently provided an implementation of ADFs which is based on answer set programming.</p><p>In general, we are not aware of any works that address the relationship of abstract dialectical frameworks with other nonmonotonic knowledge representation formalisms, attempt a principled reconstruction of ADF semantics or generalise argumentation semantics to an abstract operator-based setting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Future work.</head><p>As we observed in Example 3.7, it is not entirely clear how to define the union of two ADFs that share statements. Although for specific representations of acceptance conditions such a union should be straightforward to define, we want to devote some future work into abstracting from specific representations and develop a general method for combining ADFs.</p><p>Corollary 3.13 has shown that Brewka and Woltran <ref type="bibr" target="#b2">[3]</ref> defined not only the notion of an ADF model, but also the ultimate three-valued approximation of this notion. In recent related work, Brewka et al. <ref type="bibr" target="#b4">[5]</ref> introduced several new ultimate semantics for abstract dialectical frameworks. In future research we will compare the different semantics defined by their work and in this paper. Furthermore, Denecker et al. <ref type="bibr" target="#b12">[13]</ref> study several other ultimate semantics. It is an important aspect of future work to investigate these ultimate semantics in detail and to compare them with the ones investigated here and by Brewka et al. <ref type="bibr" target="#b4">[5]</ref>.</p><p>We remarked on several occasions throughout the paper that we defined new semantics for default and autoepistemic logics (admissible, preferred, semi-stable, stage). We plan to study these semantics in greater detail, especially their strengths and weaknesses in comparison to the standard semantics of these two nonmonotonic KR formalisms. Additionally, in the same way we defined several semantics for normal logic programs (conflict-free, admissible, naive, stage). In order to determine whether these semantics are new, it might be a good starting point to compare them to the semantics discussed by Eiter et al. <ref type="bibr" target="#b15">[16]</ref>. Finally, it is of course in order to perform an analysis of the computational complexity of the newly introduced ADF semantics.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Example 2 . 1 .</head><label>21</label><figDesc>The following is a simple ADF: D = (S, L, C in ) with statements S = {a, b, c, d}, links L = {(a, c), (b, b), (b, c), (b, d)} and acceptance functions given by C in a = {∅}, C in b = {{b}}, C in c = {{a, b}} and C in d = {∅}. These acceptance functions can intuitively be interpreted as follows:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>) contain both b and d, since b attacks d; or (2) contain c without containing both a and b, because c depends on joint support of a and b. The remaining ones above are conflict-free.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>links are restricted to supporting links among nodes in the model) and • for each s ∈ S M and B ⊆ S M , we set C M s (B) = in iff C s (B) = in (likewise the acceptance functions are restricted to the remaining parent nodes). Stable models then serve to define further notions; but first let us define how to remove a set R of statements from an ADF Ξ = (S, L, C in ) as follows: Ξ -R def = (S , L , C ), where • S = S \ R (the nodes in R are removed), • L = L ∩ (S × S ) (links are restricted to the remaining nodes) and • C = {{B ∩ S | B ∈ C in s }} s∈S (likewise, acceptance conditions are restricted to the remaining parents).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Example 3 . 1 .</head><label>31</label><figDesc>Consider the following (bipolar) ADF ξ = (S, L, C ) with components S = {a, b}, L = {(a, a), (a, b), (b, b)} and C in a = {{a}} and C in b = {∅, {a}, {b}}. In words, a supports itself while a and b jointly attack b. The set M = {b} is a BW-stable model of ξ : The reduct ξ M is given by the triple ({b}, ∅, {C in b }) with C in b = {∅}, an ADF where b is always in. (The link (b, b)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Example 3 . 2 .</head><label>32</label><figDesc>Consider the following (bipolar) ADF ξ = (S, L, C ) with components S = {a, b}, L = {(a, b), (b, b)} and C in a = {∅} and C in b = {∅, {b}, {a, b}}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Example 3 . 3 .</head><label>33</label><figDesc>Let us reconsider the problematic ADF from Example 3.2, that is, ξ = (S, L, C ) with components S = {a, b}, L = {(a, b), (b, b)} and C in a = {∅} and C in b = {∅, {b}, {a, b}}. The (new) reduct of ξ with M 2 = {a, b} is given by ξ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Example 3 . 4 .</head><label>34</label><figDesc>Consider the simplest abstract dialectical framework with a self-supporting cycle between two arguments, ξ = (S, L, C ) with S = {a, b}, L = {(a, b), (b, a)} and C in a = {{b}}, C in b = {{a}}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Example 3 . 5 .</head><label>35</label><figDesc>Consider the (bipolar) ADF ξ = (S, L, C ) with statements S = {a, b, c, d}, links L = {(b, a), (c, a), (d, c)} and acceptance conditions C in a = {∅, {b}, {c}}, C in b = {∅}, C in c = {{d}} and C in d = {∅}. In words, there is a joint attack of b and c on a -a is out if both b and c are in, and a is in otherwise. Statements b and d are always in, and c is in if d is. This ADF ξ has the BW-admissible set M = {a, b}: Taking R = {d}, we see that there are no attacks from R to M. Furthermore, the ADF ξ -R = ξ = (S , L , C ) is given by S = {a, b, c}, L = {(b, a), (c, a)} and C a = {∅, {b}, {c}}, C b = {∅} and C c = {}.This ADF ξ has the stable model {a, b}, which is easily verified when looking at the reduct ξ M = ({a, b}, ∅, C M ) where So in a sense, the set {a, b} being admissible depends on the removal of {d}, in which case the only support of c is removed and the joint attack on a cannot happen. But d is by definition of its acceptance condition always</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Theorem 3 . 15 .</head><label>315</label><figDesc>Let Ξ = (S, L, C in ) be an abstract dialectical framework and Π(Ξ) its standard logic program. Then Ξ and Π(Ξ) coincide on all semantics based on their approximation operators.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Example 3 . 7 .</head><label>37</label><figDesc>But it is not straightforward to define the union of two ADFs when they share statements: Consider the ADFs ξ 1 = (S 1 , L 1 , C in 1 ) with S 1 = {a, b}, L 1 = {(b, a)}, C in 1,a = {{b}} and C in 1,b = {∅} (in words, b is always in and supports a); and ξ 2 = (S 2 , L 2 , C in 2 ) with S 2 = {a, c}, L 2 = {(c, a)}, C in 2,a = {{c}} and C in 2,c = {∅} (in words, c is always in and supports a).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>) with the obvious links from body atoms to head atoms, L = {(b, b), (b, a), (c, a)}, statement b being self-attacking, C in b = {∅}, statement c being always in, C in c = {∅} and statement a being in if b is in, c is in, or both, C in a = {{b}, {c}, {b, c}}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Proposition 4 . 1 .</head><label>41</label><figDesc>For any argumentation framework Θ = (A, R) and sets X, Y ⊆ A, we have</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Definition 4 . 2 .</head><label>42</label><figDesc>Let Θ = (A, R) be an argumentation framework. Define -A def = {-a | a ∈ A}, A ± def= A ∪-A and a logic program over A ± as follows.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Theorem 4 . 14 .</head><label>414</label><figDesc>Let Θ = (A, R) be an argumentation framework with standard translation Π and Dung translation Π D and let S, P ⊆ A.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>TProposition 4 . 15 .</head><label>415</label><figDesc>Π (S, P ) = (S, P ) iff F Θ (S, P ) = (S, P ) iff U Θ (P ), U Θ (S) = (S, P ) iff S = U Θ (P ) and P = U Θ(S)    iff S = U Θ (P ) and P = U Θ (S) and -U Θ (P ) = -S and -U Θ (S) = -P iff S ∪ -U Θ (S) = S ∪ -P and P ∪ -U Θ (P ) = P ∪ -S iff S ∪ -U Θ (S), P ∪ -U Θ (P ) = (S ∪ -P , P ∪ -S)iff T Π D (S, -S), T Π D (P , -P ) = (S ∪ -P , P ∪ -S) iff T Π D (S ∪ -P , P ∪ -S), T Π D (P ∪ -S, S ∪ -P ) = (S ∪ -P , P ∪ -S) iff T Π D (S ∪ -P , P ∪ -S) = (S ∪ -P , P ∪ -S) iff T Π D co(S, P ) = co(S, P ) 2Furthermore, coherent pairs are also the only fixpoints of T Π D . Let Θ = (A, R) be an AF, Π D be its Dung translation over A ± and let S * ,P * ⊆ A ± . If T Π D (S * , P * ) = (S * , P * ), then (S * , P * ) is coherent. Proof. Let T Π D (S * , P * ) = (S * , P * ). Now S * = {a | -a / ∈ P * } ∪ -U Θ (S * ) and P * = {a | -a / ∈ S * } ∪ -U Θ (P * ). For a ∈ A, it immediately follows that a ∈ S * iff -a / ∈ P * and a ∈ P * iff -a / ∈ S * , thus (S * , P * ) is coherent. 2Hence for any semantics derived from the operator T Π D which is only "interested" in atoms from A, the choice between standard translation and Dung translation is semantically inessential. We remark that Dung's translation has the advantage of producing a logic program where each rule has a finite body. Theorem 4.14 and Proposition 4.15 immediately yield the same nice correspondence picture from the standard translation (Theorem 4.13) for Dung's translation. The first and last items below are again obvious for our setting, parts of them were also proved by Dung<ref type="bibr" target="#b13">[14,</ref> Theorem 62]. Correspondence results 2, 3 and 4 are completely new.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Theorem 4 . 16 .</head><label>416</label><figDesc>Let Θ = (A, R) be an argumentation framework. The following are in one-to-one correspondence:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Example 5 . 1 (</head><label>51</label><figDesc>Odd cycle). Consider an attack cycle between three arguments, the AF θ = ({a, b, c}, {(a, b), (b, c), (c, a)}). Its conflict-free pairs are given by</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2.Relative expressiveness of NMR formalisms. Nodes depict nonmonotonic knowledge representation formalisms; argumentation frameworks (AFs), abstract dialectical frameworks (ADFs), logic programs (LPs), default logic (DL) and autoepistemic logic (AEL), respectively. A solid directed edge expresses that there exists a polynomial, faithful and modular translation from source to target formalism, where faithful means the exact correspondence of associated approximating operators. Dotted edges denote non-modular translations which are polynomial, but only faithful with respect to two-valued (BW-)stable semantics.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>∪ not A. A logic program rule over A is then of the form a ← M where a ∈ A and M ⊆ Lit( A). The rule can be read as logical consequence, "a is true if all literals in M are true." We denote by M + def</figDesc><table /><note><p>. For a nonempty set A -the signature, or set of atoms -, define not A def = {not a | a ∈ A} and the set of literals over A as Lit( A) def = A = M ∩ A and M -def = {a ∈ A | not a ∈ M} the positive and negative body atoms, respectively. A rule is definite if M -= ∅.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Statement c is not contained because it needs joint support by a and b, of which b is missing. For d, it cannot be guaranteed that its attacker b is necessarily out, since it is still contained in the upper bound of Γ D 's least fixpoint.It is clear that ADFs are a generalisation of AFs: for an argumentation framework Θ = (A, R), its associated abstract dialectical framework is Ξ(Θ) = (A, R, C in ), where C in a = {∅} for each a ∈ A. But this is not just syntactical; Brewka and Woltran<ref type="bibr" target="#b2">[3]</ref> showed that their semantical notions for ADFs are generalisations of Dung's respective AF notions: . conflict-free sets of Θ and conflict-free sets of Ξ(Θ); 3. stable extensions of Θ and models of Ξ(Θ); 4. stable extensions of Θ and BW-stable models of Ξ(Θ); 5. preferred extensions of Θ and BW-preferred models of Ξ(Θ).</figDesc><table><row><cell>Proof. Propositions 3, 1, 7 and 12 of [3]. 2</cell></row></table><note><p><p>). The i -least fixpoint of Γ D is the pair ({a}, {a, b, c, d}), therefore the BW-well-founded model of D is the set {a}. Intuitively, statement a is in there because it is always in. Statement b is not contained in the BW-well-founded model since it is only self-supporting. Proposition 2.1. Let Θ = (A, R) be an argumentation framework and Ξ(Θ) = (A, R, C in ) its associated abstract dialectical framework. The following are in one-to-one correspondence:</p>1. the grounded extension of Θ and the BW-well-founded model of Ξ(Θ); 2</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>The standard logic program Π(D) of our running example ADF D is given by As another illustrative example, we look at the ADF where we observed a mismatch between BW-stable models and operator-based two-valued stable models. The ADF ξ from Example 3.1 is translated into the logic program consisting of the following rules:</figDesc><table><row><cell>a ← ∅</cell><cell>b ← b</cell><cell>c← {a, b}</cell><cell>d ← not b</cell></row><row><cell>Example 3.6. a ← a</cell><cell cols="2">b← {not a, not b}</cell><cell>b ← {a, not b}</cell><cell>b ← {b, not a}</cell></row></table><note><p><p>s Example 2.1 (Continued).</p>This somewhat obviates why there is no two-valued stable model for ξ : the only candidate for deriving b in some reduct program is the last rule, which however circularly requires b itself.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>In particular, x O (x, y) = O (y, x) y and (x, y) is conflict-free. 2</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell>O (x, x)</cell></row><row><cell></cell><cell>x</cell><cell>O (x, y)</cell><cell>O (y, x)</cell><cell>y</cell></row><row><cell></cell><cell></cell><cell></cell><cell>O (y, y)</cell></row><row><cell>∅, {a, b, c}</cell><cell>{a}, {a, b, c}</cell><cell>{b}, {a, b, c}</cell><cell>{c}, {a, b, c}</cell></row><row><cell>{a}, {c, a}</cell><cell>{b}, {a, b}</cell><cell>{c}, {b, c}</cell><cell></cell></row><row><cell cols="4">Notice that the single admissible pair (∅, {a, b, c}) is among the conflict-free pairs.</cell></row><row><cell cols="4">It is not hard to show that any admissible pair is conflict-free.</cell></row></table><note><p><p>Proposition 5.1. Let (L, ) be a complete lattice and O an approximating operator on the bilattice (L 2 , i ). Any consistent pair (x, y) ∈ L 2 that is admissible for O is also conflict-free for O. Proof. The pair (x, y) is admissible if and only if x O (x, y) and O (x, y) y. Since O (•, y) is -monotone and O (x, •)</p>is -antimonotone, we obtain the following picture:</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>Unfortunately, this possible alternative version of conflict-freeness is not a suitable generalisation of the set-based AF notion, since there are argumentation frameworks with conflict-free sets that are not the lower bound of any such pair. Consider the argumentation framework θ = ({a, b}, {(a, b)}) where a attacks b. The set X = {b} is conflict-free. Assume to the contrary that there is a Y</figDesc><table><row><cell>∅, {a, b, c}</cell><cell>∅, {a, b}</cell><cell>∅, {a, c}</cell><cell>∅, {b, c}</cell></row><row><cell>{a}, {a, b}</cell><cell>{b}, {b, c}</cell><cell>{c}, {c, a}</cell><cell></cell></row><row><cell>Example 5.2.</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>-1 is -minimal admissible/reliable pair (x, y) ( x, y) i O(x, y) = (x, y) and (x, y) is i -maximal L-supported model (x, y) O(x, y) = (x, y) and y x -1 is -minimal two-valued supported model (x, x) O(x, x) = (x, x) well-founded semantics lfp(SO) three-valued stable model (x, y) SO(x, y) = (x, y) M-stable model (x, y) SO(x, y) = (x, y) and (x, y) is i -maximal L-stable model (x, y)</figDesc><table><row><cell>Kripke-Kleene semantics</cell><cell>lfp(O)</cell></row><row><cell>three-valued supported model (x, y)</cell><cell>O(x, y) = (x, y)</cell></row><row><cell>M-supported model (x, y)</cell><cell>O(x, y)</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>But this is not inherent to these formalisms -both strong expansions for autoepistemic logic that reject cyclic support, and weak extensions for default logic that accept cyclic support can be defined<ref type="bibr" target="#b11">[12]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Note that in their approach, an ADF statement corresponds to an argument evaluation structure of Carneades and is hence on the same abstraction level.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>The approximation of an operator O is typographically indicated by a calligraphic O.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>Denecker et al.<ref type="bibr" target="#b10">[11]</ref> call such pairs "complete," we however use that term for argumentation in a different meaning and want to avoid confusion.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>The representation of the operator and the lattice it operates on given by Brewka and Woltran<ref type="bibr" target="#b2">[3]</ref> is slightly different: both representations use pairs of sets of statements to describe the current acceptance status of statements. Their pairs explicitly represent the statements that are in in the first component and the ones that are out in the second component. Since our second component explicitly represents the statements that are not out, we adjusted the definition of the operator Γ Ξ for computing the second component.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_5"><p>According to personal communication this was conjectured by Mirosław Truszczy ński.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_6"><p>Dung's original translation is slightly different; he uses a first-order signature and logic program atoms with variables<ref type="bibr" target="#b13">[14]</ref>. Definition 4.2 above is merely a syntactical variant that already incorporates ground instantiation.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_7"><p>The notation is entirely unambiguous since for any S ⊆ A we have -S = -S.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11" xml:id="foot_8"><p>Actually, applying the translation yields an argumentation framework that looks slightly more complicated: ({({a}, a), ({¬a}, ¬a)}, {(({a}, a), ({¬a}, ¬a)), (({¬a}, ¬a), ({a}, a))}). We chose to simplify notation for the sake of readability.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>The author wishes to thank Gerhard Brewka, Stefan Ellmauthaler and Johannes Peter Wallner for useful discussions and providing several (counter-)examples. He is also grateful to several anonymous referees for providing valuable feedback. This work was partially supported by DFG under project BR-1817/7-1.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>considered possible for the argument in question. Under this assumption, it is straightforward to adapt the definitions of <ref type="bibr" target="#b23">[24]</ref> to our setting. To this end, we first recall their original definition of four-valued labellings. Definition 4.1. (See [24, Definition 3.1].) Let Θ = (A, R) be an AF. A JV-labelling is a function l : A → 2 {+,-} such that for all a ∈ A:</p><p>1. If -∈ l(a), then there is a b ∈ A with (b, a) ∈ R and + ∈ l(b). 2. If + ∈ l(a), then (b, a) ∈ R implies -∈ l(b). 3. If + ∈ l(a), then (a, c) ∈ R implies -∈ l(c).</p><p>A JV-labelling is total iff l(a) = ∅ for all a ∈ A. 8   It is easy to establish a correspondence between pairs (X, Y ) and functions l : A → 2 {+,-} . It only remains to reformulate the three conditions in terms of AF operators, which results in the proposition below. Proposition 4.10. Let Θ = (A, R) be an AF and X, Y ⊆ A.</p><p>We first observe that for any argument a ∈ A, we have -∈ l(a) iff a / ∈ X , and + ∈ l(a) iff a ∈ Y . The conditions of Definition 4.1 are now readily formulated thus:</p><p>Using the truth and information orderings, pairs (X, Y ) that correspond to JV-labellings could be characterised by (X, Y ) t F Θ (X, Y ) and F Θ (X, Y ) i (X, Y ). While this may suggest a possible intuitive reading of such pairs, we have to be cautious as the intuitions underlying these orderings are slightly different. Anyway, when applying the revision operator F Θ , the result must be "at least as true" and "at most as informative" as the input pair.</p><p>We have seen how all of the semantical notions for AFs considered in this paper can be recast in terms of the approximating operator of an AF, as fixpoints or pre-/postfixpoints with respect to the information ordering i and truth ordering t . This tells us that operators associated with an argumentation framework are useful tools to study the semantics of the AF. This technique of associating operators with a knowledge base and then studying the operators to study the knowledge base is successfully and widely used in logic programming. In the next section, we will see that this enables us to elegantly build a bridge from abstract argumentation to logic programming via the approximation operators associated with the respective objects of study.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">From argumentation frameworks to logic programs</head><p>There are different translations from AFs into LPs in the literature: the one we call the standard translation, and the one devised by Dung <ref type="bibr" target="#b13">[14]</ref> to demonstrate how logic programs could be used to implement abstract argumentation. We consider each of the translations in turn and lastly show that they produce equivalent logic programs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1.">Standard translation</head><p>The translation we refine below was introduced as "well-known" in Gabbay and d'Avila Garcez [19, Example 1.2]. They do not provide a definition or motivation for that translation, but our subsequent results will show that the intuition behind it is sound and the name "standard translation" is justified. The standard logic program resulting from an AF uses the set of arguments as its underlying signature. A rule is created for each argument a, and the rule basically says "a is accepted if none of its attackers is accepted." Since AFs are in particular ADFs, the standard logic program of an AF Θ is given by Π(Ξ(Θ)), that is, translating the AF Θ into an ADF Ξ(Θ) and that further into the standard LP of the ADF. For AFs Θ = (A, R), the definition of its standard 8 Jakobovits and Vermeir <ref type="bibr" target="#b23">[24]</ref> call such labellings complete, which we however use with a different meaning.</p><p>Proposition 5.4. Let Θ = (A, R) be an AF. A set X ⊆ A is a naive extension of Θ iff the pair (X, U Θ (X)) is an M-conflict-free pair of Θ.</p><p>Proof. First note that for any X ⊆ A, the set U Θ (X) is fixed. Furthermore U Θ is a ⊆-antimonotone operator and thus X ⊆ Y iff (X, U Θ (X)) i (Y , U Θ (Y )). Consequently for maximisation there is no difference whether we ⊆-maximise the set X or we i -maximise the pair (X, U Θ (X)). It follows that</p><p>Verheij <ref type="bibr" target="#b40">[41]</ref> defined the notion argumentation stage for an argumentation framework, in turn based on three-valued status assignments. Such an assignment represents not only the arguments that are accepted (as extensions do), but also those which are not accepted. (Hence each assignment gives rise to a unique extension, but not necessarily vice versa.) An argumentation stage is a three-valued status assignment to arguments with the restriction that the arguments that are not accepted must be exactly the ones that have an attacker that is accepted. It follows that the set of arguments which are accepted in an argumentation stage (its associated extension) is conflict-free. It is easy to find out how (argumentation) stages can be captured in our setting:</p><p>While an argumentation stage is always a conflict-free pair, and any conflict-free set gives rise to an argumentation stage (and thus to a conflict-free pair), there are conflict-free pairs which are not argumentation stages. (Consider Example 5.2 and the pair ({a}, {a, b}).) Still, we can apply the range maximisation criterion to conflict-free pairs in order to generalise stage extension semantics. Definition 5.5. Let (L, ) be a complete lattice and O an approximating operator on its corresponding bilattice (L 2 , i ). A consistent pair (x, y) ∈ L 2 is an L-conflict-free pair for O iff y x -1 is -minimal among the conflict-free pairs for O.</p><p>For AFs, L-conflict-free pairs coincide with stage extensions. Proposition 5.6. Let Θ = (A, R) be an AF. A set X ⊆ A is a stage extension of Θ iff the pair (X, U Θ (X)) is an L-stage pair of F Θ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof.</head><p>X is a stage extension for Θ iff X is conflict-free and X ∪ Attacked Θ (X) is ⊆ -maximal iff X is conflict-free and X ∪ U Θ (X) is ⊆ -maximal iff X ⊆ U Θ (X) and X ∩ U Θ (X) is ⊆ -minimal iff X ⊆ U Θ (X) = F Θ X, U Θ (X) and X ∩ U Θ (X) is ⊆ -minimal iff X, U Θ (X) is an L-stage pair of F Θ 2</p><p>When trying to define two-valued conflict-free pairs we end up with pairs (x, x) where x O (x, x) = O (x, x) x, that is, two-valued supported models.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Characterization of semantics for argument systems</title>
		<author>
			<persName><forename type="first">Philippe</forename><surname>Besnard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sylvie</forename><surname>Doutre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Ninth International Conference on Principles of Knowledge Representation and Reasoning</title>
		<editor>
			<persName><forename type="first">Didier</forename><surname>Dubois</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Christopher</forename><forename type="middle">A</forename><surname>Welty</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Mary-Anne</forename><surname>Williams</surname></persName>
		</editor>
		<meeting>the Ninth International Conference on Principles of Knowledge Representation and Reasoning</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2004">2004. 2004</date>
			<biblScope unit="page" from="183" to="193" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<author>
			<persName><forename type="first">Gerhard</forename><surname>Brewka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">F</forename><surname>Gordon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Carneades and abstract dialectical frameworks: a reconstruction</title>
		<title level="s">Frontiers in Artificial Intelligence and Applications</title>
		<imprint>
			<publisher>IOS Press</publisher>
			<date type="published" when="2010-09">September 2010</date>
			<biblScope unit="volume">216</biblScope>
			<biblScope unit="page" from="3" to="12" />
		</imprint>
	</monogr>
	<note>Computational Models of Argument: Proceedings of COMMA 2010</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Abstract dialectical frameworks</title>
		<author>
			<persName><forename type="first">Gerhard</forename><surname>Brewka</surname></persName>
			<affiliation>
				<orgName type="collaboration">KR</orgName>
			</affiliation>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Woltran</surname></persName>
			<affiliation>
				<orgName type="collaboration">KR</orgName>
			</affiliation>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twelfth International Conference on the Principles of Knowledge Representation and Reasoning</title>
		<meeting>the Twelfth International Conference on the Principles of Knowledge Representation and Reasoning</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="102" to="111" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Relating the semantics of abstract dialectical frameworks and standard AFs</title>
		<author>
			<persName><forename type="first">Gerhard</forename><surname>Brewka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><forename type="middle">E</forename><surname>Dunne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Woltran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Second International Joint Conference on Artificial Intelligence</title>
		<meeting>the Twenty-Second International Joint Conference on Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="780" to="785" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Abstract dialectical frameworks revisited</title>
		<author>
			<persName><forename type="first">Gerhard</forename><surname>Brewka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Ellmauthaler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hannes</forename><surname>Strass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Johannes</forename><surname>Peter Wallner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Woltran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Third International Joint Conference on Artificial Intelligence</title>
		<meeting>the Twenty-Third International Joint Conference on Artificial Intelligence</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2013-08">August 2013</date>
			<biblScope unit="page" from="803" to="809" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">On the issue of reinstatement in argumentation</title>
		<author>
			<persName><forename type="first">Martin</forename><surname>Caminada</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Tenth European Conference on Logics in Artificial Intelligence</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the Tenth European Conference on Logics in Artificial Intelligence</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006-09">September 2006</date>
			<biblScope unit="volume">4160</biblScope>
			<biblScope unit="page" from="111" to="123" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">An algorithm for stage semantics</title>
		<author>
			<persName><forename type="first">Martin</forename><surname>Caminada</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computational Models of Argument: Proceedings of COMMA 2010</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="147" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On the evaluation of argumentation formalisms</title>
		<author>
			<persName><forename type="first">Martin</forename><surname>Caminada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leila</forename><surname>Amgoud</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">171</biblScope>
			<biblScope unit="issue">5-6</biblScope>
			<biblScope unit="page" from="286" to="310" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Bipolar abstract argumentation systems</title>
		<author>
			<persName><forename type="first">Claudette</forename><surname>Cayrol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Christine</forename><surname>Lagasquie-Schiex</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Argumentation in Artificial Intelligence</title>
		<editor>
			<persName><forename type="first">Guillermo</forename><surname>Simari</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Iyad</forename><surname>Rahwan</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="65" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName><forename type="first">Keith</forename><forename type="middle">L</forename><surname>Clark</surname></persName>
		</author>
		<title level="m">Logic and Data Bases</title>
		<editor>
			<persName><forename type="first">Hervé</forename><surname>Gallaire</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Jack</forename><surname>Minker</surname></persName>
		</editor>
		<imprint>
			<publisher>Plenum Press</publisher>
			<date type="published" when="1978">1978</date>
			<biblScope unit="page" from="293" to="322" />
		</imprint>
	</monogr>
	<note>Negation as failure</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Miroslaw Truszczy ński, Approximations, stable operators, well-founded fixpoints and applications in nonmonotonic reasoning, in: Logic-Based Artificial Intelligence</title>
		<author>
			<persName><forename type="first">Marc</forename><surname>Denecker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Marek</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Kluwer Academic Publishers</publisher>
			<biblScope unit="page" from="127" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Miroslaw Truszczy ński, Uniform semantic treatment of default and autoepistemic logics</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">Wiktor</forename><surname>Marc Denecker</surname></persName>
		</author>
		<author>
			<persName><surname>Marek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">143</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="79" to="122" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Miroslaw Truszczy ński, Ultimate approximation and its application in nonmonotonic knowledge representation systems</title>
		<author>
			<persName><forename type="first">Marc</forename><surname>Denecker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><forename type="middle">W</forename><surname>Marek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Comput</title>
		<imprint>
			<biblScope unit="volume">192</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="84" to="121" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming and n-person games</title>
		<author>
			<persName><forename type="first">Minh</forename><surname>Phan</surname></persName>
		</author>
		<author>
			<persName><surname>Dung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">77</biblScope>
			<biblScope unit="page" from="321" to="358" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Answer-set programming encodings for argumentation frameworks</title>
		<author>
			<persName><forename type="first">Uwe</forename><surname>Egly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alice</forename><surname>Sarah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Gaggl</surname></persName>
		</author>
		<author>
			<persName><surname>Woltran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Argument Comput</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="147" to="177" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Paracoherent answer set programming</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Eiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Fink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">João</forename><surname>Moura</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twelfth International Conference on Principles of Knowledge Representation and Reasoning</title>
		<meeting>the Twelfth International Conference on Principles of Knowledge Representation and Reasoning</meeting>
		<imprint>
			<date type="published" when="2010-05">May 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Evaluating abstract dialectical frameworks with ASP, in: Computational Models of Argument: Proceedings of COMMA 2012</title>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Ellmauthaler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Johannes</forename><surname>Peter Wallner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="505" to="506" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Fixpoint semantics for logic programming: a survey</title>
		<author>
			<persName><forename type="first">Melvin</forename><surname>Fitting</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">278</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="25" to="51" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Logical modes of attack in argumentation networks</title>
		<author>
			<persName><forename type="first">Dov</forename><forename type="middle">M</forename><surname>Gabbay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Artur</forename><forename type="middle">S</forename><surname>Garcez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Stud. Log</title>
		<imprint>
			<biblScope unit="volume">93</biblScope>
			<biblScope unit="issue">2-3</biblScope>
			<biblScope unit="page" from="199" to="230" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The stable model semantics for logic programming</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Gelfond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vladimir</forename><surname>Lifschitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Logic Programming, ICLP</title>
		<meeting>the International Conference on Logic Programming, ICLP</meeting>
		<imprint>
			<publisher>The MIT Press</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="1070" to="1080" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The Carneades model of argument and burden of proof</title>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">F</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Henry</forename><surname>Prakken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Douglas</forename><surname>Walton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">171</biblScope>
			<biblScope unit="issue">10-15</biblScope>
			<biblScope unit="page" from="875" to="896" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Translating default logic into standard autoepistemic logic</title>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="711" to="740" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Fixpoints and iterated updates in abstract argumentation</title>
		<author>
			<persName><forename type="first">Davide</forename><surname>Grossi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Thirteenth International Conference on the Principles of Knowledge Representation and Reasoning (KR)</title>
		<meeting>the Thirteenth International Conference on the Principles of Knowledge Representation and Reasoning (KR)</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="65" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Robust semantics for argumentation frameworks</title>
		<author>
			<persName><forename type="first">Hadassa</forename><surname>Jakobovits</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dirk</forename><surname>Vermeir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Log. Comput</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="215" to="261" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">On the intertranslatability of non-monotonic logics</title>
		<author>
			<persName><forename type="first">Tomi</forename><surname>Janhunen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ann. Math. Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">1-4</biblScope>
			<biblScope unit="page" from="79" to="128" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">On the relation between default and autoepistemic logic</title>
		<author>
			<persName><forename type="first">Kurt</forename><surname>Konolige</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="343" to="382" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Miroslaw Truszczy ński, Stable semantics for logic programs and default theories</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">Wiktor</forename><surname>Marek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">North American Conference on Logic Programming</title>
		<imprint>
			<publisher>The MIT Press</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="243" to="256" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Reasoning about preferences in argumentation frameworks</title>
		<author>
			<persName><forename type="first">Sanjay</forename><surname>Modgil</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">173</biblScope>
			<biblScope unit="issue">9-10</biblScope>
			<biblScope unit="page" from="901" to="934" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Semantical considerations of nonmonotonic logic</title>
		<author>
			<persName><forename type="first">Robert</forename><surname>Moore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="75" to="94" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A generalization of Dung&apos;s abstract framework for argumentation: Arguing with sets of attacking arguments</title>
		<author>
			<persName><forename type="first">H</forename><surname>Søren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simon</forename><surname>Nielsen</surname></persName>
		</author>
		<author>
			<persName><surname>Parsons</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Argumentation in Multi-Agent Systems</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4766</biblScope>
			<biblScope unit="page" from="54" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">A schema for generating relevant logic programming semantics and its applications in argumentation theory</title>
		<author>
			<persName><forename type="first">Juan</forename><surname>Carlos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nieves</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Mauricio</forename><surname>Osorio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Claudia</forename><surname>Zepeda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Fundam. Inform</title>
		<imprint>
			<biblScope unit="volume">106</biblScope>
			<biblScope unit="issue">2-4</biblScope>
			<biblScope unit="page" from="295" to="319" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">An A-Prolog decision support system for the Space Shuttle</title>
		<author>
			<persName><forename type="first">Monica</forename><surname>Nogueira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marcello</forename><surname>Balduccini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Gelfond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Watson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><surname>Barry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Answer Set Programming</title>
		<editor>
			<persName><forename type="first">Alessandro</forename><surname>Provetti</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Tran</forename><surname>Cao</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Son</forename></persName>
		</editor>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">An abstract framework for argumentation with structured arguments</title>
		<author>
			<persName><forename type="first">Henry</forename><surname>Prakken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Argument Comput</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="93" to="124" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">A system for defeasible argumentation</title>
		<author>
			<persName><forename type="first">Giovanni</forename><surname>Henry Prakken</surname></persName>
		</author>
		<author>
			<persName><surname>Sartor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence Today</title>
		<imprint>
			<biblScope unit="page" from="365" to="379" />
			<date type="published" when="1999">1999</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>Berlin Heidelberg</pubPlace>
		</imprint>
	</monogr>
	<note>with defeasible priorities</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">A logic for default reasoning</title>
		<author>
			<persName><forename type="first">Raymond</forename><surname>Reiter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="81" to="132" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Deterministic and non-deterministic stable models</title>
		<author>
			<persName><forename type="first">Domenico</forename><surname>Saccà</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carlo</forename><surname>Zaniolo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Log. Comput</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="555" to="579" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Instantiating knowledge bases in Abstract Dialectical Frameworks</title>
		<author>
			<persName><forename type="first">Hannes</forename><surname>Strass</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourteenth International Workshop on Computational Logic in Multi-Agent Systems, CLIMA XIV</title>
		<meeting>the Fourteenth International Workshop on Computational Logic in Multi-Agent Systems, CLIMA XIV</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013-09">September 2013</date>
			<biblScope unit="volume">8143</biblScope>
			<biblScope unit="page" from="86" to="101" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">A lattice-theoretical fixpoint theorem and its applications</title>
		<author>
			<persName><forename type="first">Alfred</forename><surname>Tarski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pac. J. Math</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="285" to="309" />
			<date type="published" when="1955">1955</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Argumentation and answer set programming</title>
		<author>
			<persName><forename type="first">Francesca</forename><surname>Toni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marek</forename><surname>Sergot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic Programming, Knowledge Representation, and Nonmonotonic Reasoning: Essays in Honor of Michael Gelfond</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Balduccini</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Son</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6565</biblScope>
			<biblScope unit="page" from="164" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Relating Carneades with abstract argumentation</title>
		<author>
			<persName><forename type="first">Bas</forename><surname>Van Gijzel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Henry</forename><surname>Prakken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Second International Joint Conference on Artificial Intelligence</title>
		<meeting>the Twenty-Second International Joint Conference on Artificial Intelligence</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="1113" to="1119" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Two approaches to dialectical argumentation: admissible sets and argumentation stages</title>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eighth Dutch Conference on Artificial Intelligence, NAIC&apos;96</title>
		<editor>
			<persName><forename type="first">J.-J</forename><surname>Ch</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Meyer</surname></persName>
		</editor>
		<editor>
			<persName><surname>Van Der Gaag</surname></persName>
		</editor>
		<meeting>the Eighth Dutch Conference on Artificial Intelligence, NAIC&apos;96</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="357" to="368" />
		</imprint>
		<respStmt>
			<orgName>Bart Verheij</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Computing argumentation semantics in answer set programming</title>
		<author>
			<persName><forename type="first">Toshiko</forename><surname>Wakaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Katsumi</forename><surname>Nitta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Annual Conference of Japanese Society for Artificial Intelligence (JSAI)</title>
		<meeting>the Annual Conference of Japanese Society for Artificial Intelligence (JSAI)</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="254" to="269" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Complete extensions in argumentation coincide with 3-valued stable models in logic programming</title>
		<author>
			<persName><forename type="first">Yining</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Caminada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dov</forename><forename type="middle">M</forename><surname>Gabbay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Stud. Log</title>
		<imprint>
			<biblScope unit="volume">93</biblScope>
			<biblScope unit="issue">2-3</biblScope>
			<biblScope unit="page" from="383" to="403" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Instantiating knowledge bases in abstract argumentation frameworks</title>
		<author>
			<persName><forename type="first">Adam</forename><surname>Wyner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Trevor</forename><surname>Bench-Capon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><surname>Dunne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the AAAI Fall Symposium -The Uses of Computational Argumentation</title>
		<meeting>the AAAI Fall Symposium -The Uses of Computational Argumentation</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
