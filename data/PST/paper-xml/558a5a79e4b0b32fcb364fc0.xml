<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Multicast Scheduling for Input-Queued Switches</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Balaji</forename><surname>Prabhakar</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Nick</forename><surname>Mckeown</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Ritesh</forename><surname>Ahuja</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>1994</postCode>
									<settlement>Los Angeles</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Department of Electrical Engineering and Computer Science</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>1995</postCode>
									<settlement>Berkeley</settlement>
									<region>in</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Multicast Scheduling for Input-Queued Switches</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">A0D5B0A8AE81C10170022BACEA2B1CB5</idno>
					<note type="submission">received the Ph.D. degree from the</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:48+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>ATM</term>
					<term>high-speed routing</term>
					<term>high-speed switching</term>
					<term>input-queued switches</term>
					<term>multicast</term>
					<term>scheduling</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper presents the design of a scheduler for an M 2 N input-queued multicast switch. It is assumed that: 1) each input maintains a single queue for arriving multicast cells and 2) only the cell at the head of line (HOL) can be observed and scheduled at one time. The scheduler is required to be: 1) workconserving, which means that no output port may be idle as long as there is an input cell destined to it and 2) fair, which means that no input cell may be held at HOL for more than a fixed number of cell times. The aim of our work is to find a work-conserving, fair policy that delivers maximum throughput and minimizes input queue latency, and yet is simple to implement in hardware. When a scheduling policy decides which cells to schedule, contention may require that it leave a residue of cells to be scheduled in the next cell time. The selection of where to place the residue uniquely defines the scheduling policy. Subject to a fairness constraint, we argue that a policy which always concentrates the residue on as few inputs as possible generally outperforms all other policies. We find that there is a tradeoff among concentration of residue (for high throughput), strictness of fairness (to prevent starvation), and implementational simplicity (for the design of high-speed switches). By mapping the general multicast switching problem onto a variation of the popular block-packing game Tetris, we are able to analyze, in an intuitive and geometric fashion, various scheduling policies which possess these attributes in different proportions. We present a novel scheduling policy, called TATRA, which performs extremely well and is strict in fairness. We also present a simple weight-based algorithm, called WBA, that is simple to implement in hardware, fair, and performs well when compared to a concentrating algorithm.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>D UE TO an exponential growth in the number of users of the Internet, the demand for network bandwidth has been growing at an enormous rate. As a result, recent years have witnessed an increasing interest in high-speed, switched networks. In order to build such networks, a high-performance switch is required to quickly deliver cells arriving on input links to the desired output links. A switch consists of three parts: 1) input queues to buffer cells arriving on input links; 2) output queues to buffer the cells going out on output links; and 3) a switch fabric to transfer cells from the inputs to the desired outputs. The switch fabric operates under a scheduling algorithm which arbitrates among cells from different inputs destined to the same output. A number of approaches have Manuscript received <ref type="bibr">May 1, 1996;</ref><ref type="bibr"></ref>  been taken in designing these three parts of a switch <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b19">[20]</ref>, <ref type="bibr" target="#b18">[19]</ref>, <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b15">[16]</ref>, each with its own set of advantages and disadvantages.</p><p>It is well known that when FIFO queues are used, the throughput of an input-queued switch with unicast traffic can be limited due to (head of line) HOL blocking <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b4">[5]</ref>. So the standard approach has been to abandon input queueing and instead to use output queueing-by increasing the bandwidth of the fabric, multiple cells can be forwarded at the same time to the same output, and queued there for transmission on the output link. However, this approach requires that the output queues and the internal interconnect have a bandwidth equal to times (for an switch) the line rate. Since memory bandwidth is not increasing as fast as the demand for network bandwidth, this architecture becomes impractical for very high-speed switches. Moreover, numerous papers have indicated that by using non-FIFO input queues and good scheduling policies, much higher throughputs are possible <ref type="bibr" target="#b8">[9]</ref>- <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b15">[16]</ref>, <ref type="bibr" target="#b16">[17]</ref>. Therefore, input-queued switches are finding a growing interest in the research and development community.</p><p>An increasing proportion of traffic on the Internet is multicast, with users distributing a wide variety of audio and video material. This dramatic change in the use of the Internet has been facilitated by the MBONE <ref type="bibr" target="#b0">[1]</ref>- <ref type="bibr" target="#b2">[3]</ref>. A number of different architectures and implementations have been proposed for multicast switches <ref type="bibr" target="#b5">[6]</ref>- <ref type="bibr" target="#b7">[8]</ref>. However, since we are interested in the design of very high-speed networks switches, we restrict our attention to input-queued architectures. This input-queued switch should schedule multicast cells so as to maximize throughput and minimize latency. It is important that it be simple to implement in hardware. For example, a switch running at a line rate of 2.4 Gbit/s (OC48c) must make 6 million scheduling decisions every second.</p><p>In this paper, we consider the performance of different multicast scheduling policies for input-queued switches. Several researchers have studied the random scheduling policy <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b21">[22]</ref> in which each output selects an input at random from among those subscribing to it. But, as may be expected, we find that the random scheduling policy is not the optimum policy. We introduce three new scheduling algorithms: the Concentrate algorithm, TATRA, and WBA (a weight-based algorithm). We show that the Concentrate algorithm leads to high throughput and low delay. It achieves this by concentrating the cells that it leaves behind on as few inputs as possible. Unfortunately, Concentrate has two drawbacks that make it unsuitable for use in a network switch; it can starve input queues indefinitely, and it is difficult to implement in hardware. But Concentrate serves as a useful upper bound on throughput performance against which we can compare heuristic approximations. One such approximation, TATRA, is motivated by Tetris, the popular block-packing game. TATRA avoids starvation by using a strict definition of fairness, while comparing well to the performance of Concentrate. The second algorithm, WBA, is designed to be very simple to implement in hardware, and allows the designer to balance the tradeoff between fairness and throughput.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. BACKGROUND</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Assumed Architecture</head><p>It is assumed that the switch has input and output ports, and that each input maintains a single FIFO queue for arriving multicast cells. The input cells are assumed to contain a vector indicating to which outputs the cell is to be sent. For an switch, the destination vector of a multicast cell can be any one of possible vectors. We assume that each input has a single queue, and that the scheduler only observes the first cell in the queue.</p><p>As a simple example of our architecture, consider the twoinput and -output switch shown in Fig. <ref type="figure" target="#fig_0">1</ref>. Queue has an input cell destined for outputs 1, 2, 3, 4 , and queue has an input cell destined for outputs 3, 4, 5, 6 . The set of outputs to which an input cell wishes to be copied will be referred to as the fan-out of that input cell. <ref type="foot" target="#foot_0">1</ref> For clarity, we distinguish an arriving input cell from its corresponding output cells. In the figure, the single-input cell at the head of queue will generate four output cells. We assume that an input cell must wait in line until all of the cells ahead of it have departed. A simple way to service the input queues is to replicate the input cell over multiple cell times, generating one output cell per cell time. However, this approach has two disadvantages. First, each input must be copied multiple times, increasing the required memory bandwidth. Second, input cells contend for access to the switch multiple times, reducing the bandwidth available to other traffic at the same input. Higher throughput can be attained if we take advantage of the natural multicast properties of a crossbar switch. So, instead, we assume that one input cell can be copied to any number of outputs in a single cell time for which there is no conflict.</p><p>There are two different service disciplines that can be used. Following the description in <ref type="bibr" target="#b17">[18]</ref>, the first is no fan-out splitting, in which all of the copies of a cell must be sent in the same cell time. If any of the output cells loses contention for an output port, none of the output cells is transmitted, and the cell must try again in the next cell time. The second discipline is fan-out splitting, in which output cells may be delivered to output ports over any number of cell times. Only those output cells that are unsuccessful in one cell time continue to contend for output ports in the next cell time. <ref type="foot" target="#foot_1">2</ref>Because fan-out splitting is work conserving, it enables a higher switch throughput <ref type="bibr" target="#b20">[21]</ref> for little increase in implementation complexity. For example, Fig. <ref type="figure" target="#fig_1">2</ref> compares the average cell latency (via simulations) with and without fan-out splitting of the random scheduling policy for an <ref type="bibr" target="#b7">8</ref> 8 switch under uniform loading on all inputs and an average fan-out of four. The figure demonstrates that fan-out splitting can lead to approximately 40% higher throughput.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Definition of Terms</head><p>Here, we make precise some of the terminology used throughout the paper. Some terms have already been loosely defined, but a few new ones are introduced.</p><p>Definition 1 (Residue): The residue is the set of all output cells that lose contention for output ports and remain at the HOL of the input queues at the end of each cell time.</p><p>It is important to note that, given a set of requests, every work-conserving policy will leave the same residue. However, it is up to the policy to determine how the residue is distributed over the inputs.</p><p>Definition 2 (Concentrating Policy): A multicast scheduling policy is said to be concentrating if, at the end of every cell time, it leaves the residue on the smallest possible number of input ports.</p><p>Definition 3 (Distributing Policy): A multicast scheduling policy is said to be distributing if, at the end of every cell time, it leaves the residue on the largest possible number of input ports.</p><p>Definition 4 (A Nonconcentrating Policy): A multicast scheduling policy is said to be nonconcentrating if it does not always concentrate the residue.</p><p>Definition 5 (Fairness Constraint): A multicast scheduling policy is said to be fair if each input cell is held at the HOL for no more than a fixed number of cell times (this number can be different for different inputs). This fairness constraint can also be thought of as a starvation constraint.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Requirements of an Algorithm</head><p>Before describing the details of various scheduling algorithms, we first look at some requirements. 1) Work Conservation: The algorithm must be workconserving, which means that no output port may be idle as long as it can serve some input cell destined to it. This property is necessary for an algorithm to provide maximum throughput. 2) Fairness: The algorithm must meet the fairness constraint defined above, i.e., it must not lead to the starvation of any input.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. THE HEURISTIC OF RESIDUE CONCENTRATION</head><p>In this section, we describe two algorithms-the Concentrate algorithm and the Distribute algorithm-which represent the two extremes of residue placement. We present an intutive explanation for why it is best to concentrate residue in order to achieve a high throughput.</p><p>Algorithm-(Concentrate): Concentrate always concentrates the residue onto as few inputs as possible. This is achieved by performing the following steps at the beginning of each cell time.</p><p>1) Determine the residue.</p><p>2) Find the input with the most in common with the residue. If there is a choice of inputs, select the one with the input cell that has been at the HOL for the shortest time. This ensures some fairness, although not in the sense of the definition in Section II-B (see remark below). 3) Concentrate as much residue onto this input as possible. 4) Remove the input from further consideration. 5) Repeat steps 2)-4) until no residue remains. Remark: Since an input cell can remain at HOL indefinitely, this algorithm does not meet the fairness constraint. The purpose of this algorithm is to provide us with a basis for comparing the performance of other algorithms since it achieves the highest throughput. This is demonstrated by our simulation results in Section VII.</p><p>Algorithm-(Distribute): Distribute always distributes the residue onto as many inputs as possible.</p><p>1) Determine the residue.</p><p>2) Find the input with at least one cell, but otherwise, with the least in common with the residue. If there is a choice of inputs, select the one with the input cell that has been at the HOL for the shortest time. 3) Place one output cell of residue onto that input. 4) Remove the input from further consideration. 5) Repeat steps 2)-4) until no inputs remain. 6) If residue remains, consider all the inputs again and start at step 2). Let us look at an example to see how these two algorithms work. Referring to Fig. <ref type="figure" target="#fig_0">1</ref>, consider the options faced by a work-conserving scheduling algorithm at this time . Note that whatever decision the algorithm makes, the residue will be the same. The scheduling algorithm just determines where to place the residue. If at time the algorithm concentrates the residue on , then all of 's (also see Fig. <ref type="figure" target="#fig_9">12</ref>) output cells will be sent, and cell will be brought forward at time . At time , the algorithm selects between and the residue left over from . If, on the other hand, the algorithm distributes the residue over both input queues at , then at , the algorithm can only schedule the residue left over from . No new cells can be brought forward.</p><p>From the example above, we can make the following intuitive argument: it is more likely that Concentrate will bring new work forward sooner, thus increasing the diversity of its choice. This enables more output cells to be scheduled in the following cell time. For the case of a 2 switch, the following theorem is true.</p><p>Theorem 1: A scheduling policy for a 2 multicast switch that always concentrates residue at every possible instant, subject to the fairness condition of Definition 12, performs better than any other fair policy when subjected to static inputs.</p><p>Proof: See Appendix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. TETRIS MODELS FOR SWITCHES</head><p>This section presents a unified approach to the design and analysis of schedulers for an multicast switch. It is shown that the general multicast scheduling problem can be mapped onto a variation of the popular block-packing game Tetris. Within this common framework, one is able to describe and analyze any multicast scheduling policy in an intuitive and geometric fashion. The presentation in this section follows earlier work presented in <ref type="bibr" target="#b23">[24]</ref> and <ref type="bibr" target="#b24">[25]</ref>.</p><p>We first describe the class of scheduling policies to be considered in this section, all of which are required to satisfy the following fairness constraint. Definition 6 (Fairness Constraint for Switches): A scheduling policy for an switch is said to be fair if no cell, from any input, is held at HOL for more than cell times.</p><p>Class of Policies Considered: In addition to requiring that policies be fair and work conserving, we also require that they assign departure dates to input cells once the cells advance to HOL. This departure date (DD) is some number between 1 and specifying how long, from the current cell time, the input cell will be held at HOL before being discharged. The DD of a cell is decremented by one at the end of each cell time. Clearly, this class of policies is smaller than the class of fair and work-conserving policies since fairness allows one to reassign departure dates to input cells at HOL (but not beyond cell times). We use the "static input assumption" to describe the Tetris models. As will become clear, this description holds equally well for "dynamic inputs" since scheduling is based only on cells at HOL without look-ahead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Tetris Models: A Sketch</head><p>Every input cell is mapped onto a Tetris block, each of which is an amalgamation of smaller blocks, one per output cell. Upon assignment of DD's, the input cells at HOL are dropped into a compartmentalized box of size ; see Fig. <ref type="figure" target="#fig_2">3</ref>. Each of the columns of the box holds cells destined to a specific output, i.e., column holds cells destined to output . The label on a cell denotes the input port from which it has arrived; all output cells with the same label result from the same input cell. The cells in the bottommost row of the box in Fig. <ref type="figure" target="#fig_2">3</ref> at columns 1, 3, and 5 are all identical copies of a cell from input 1 destined to outputs 1, 3, and 5. Similarly, the cell at the HOL of input 2 will be delivered to outputs 2, 3, 4, and 5.</p><p>Suppose that, at time , the switch is to schedule input cells which have advanced to HOL. After the scheduler has assigned DD's to these input cells, they are dropped into the box which currently holds the cells or residues at the HOL of the other inputs. 3 Each new output cell may occupy any position in its appropriate output slot as long as: 1) it does not alter the DD of any other cell, and 2) it does not leave any slots beneath it unoccupied. Note that there are no unoccupied slots between cells in any output column.</p><p>At the end of time , all output cells at the bottom-most layer of the box are discharged and are assumed to be served. For the example in Fig. <ref type="figure" target="#fig_2">3</ref>, input 1 is completely served and can advance a new cell to HOL at time 2. Input 2 discharges cells to outputs 2 and 4, and is left with a residue for outputs 3 and 5. Note that the discharge at any time is the set of output cells in the bottommost layer, and the residue is everything that is left behind. It should now be clear that we do not allow unoccupied slots in output columns because of the restriction to policies which are work-conserving.</p><p>At the beginning of time , all residue cells drop down one level, and their DD's are decremented by one. Those inputs which have been completely served in the previous cell time advance a new cell to the HOL. These cells are assigned DD's, and the cycle continues. This is reminiscent of Tetris where blocks are dropped into a bin and the aim is to achieve maximum packing. The main difference here is that Tetris blocks are rigid and cannot be decomposed. Note also that there are never more than input cells in the box. Thus, when an input cell is dropped into the box, it is guaranteed to depart within cell times since input cells arriving in the future do not alter its departure date. This automatically ensures fairness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Tetris Models: The Details</head><p>We now make the description of Tetris models mathematically precise. If a plurality of cells advance to HOL at the beginning of a cell time, we choose, for simplicity, the following fixed ordering: for , the new cell at input will 3 The order in which the scheduler assigns DD's to the k new cells is important because, if the cells contend for the same outputs, it may not be possible to assign them DD's in parallel. For example, suppose that two of the new cells have a fan-out of one and are the only cells contending for a specific output. Then, deciding who goes first is important since no two cells in an output column can have the same DD. In general, the order of assignment of DD's can either be prefixed or made to depend upon some criterion (e.g., size of fan-out). However, for ease of exposition, we will assume a prefixed ordering.</p><p>be assigned its DD before the new cell at input . Before proceeding to define a scheduling algorithm, we make the following definitions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 7 (Tetris Box):</head><p>The Tetris box is specified by a matrix</p><p>, where the rows are numbered from bottom to top and the columns are numbered from left to right. Thus, is the bottom-left slot of the box and is the top-right slot. Definition 8 (Occupancy Set): The occupancy set of the cell or residue at the HOL of input at time is given by : an output cell of resides at at time . Definition 9 (Peak Cell and Departure Date): An output cell belonging to input is said to be a peak cell at time if it occupies a slot in the row whose number is given by . The corresponding row number is the departure date (DD) of the input cell at time .</p><p>That is, the peak cell of an input is one which is furthest from the bottom of the box, and the distance from the bottom is its departure date. Note that there may be more than one peak cell for a given input.</p><p>Definition 10 (Scheduling Policy): Given new cells at the HOL of inputs at time , a scheduling policy is given by a sequence of decisions , where associates to each of (in that order) the corresponding occupancy sets subject to the following rules.</p><p>1) No cell should change the DD of a cell that is already scheduled. This means that no peak cells should be raised or lowered. 2) For every and , if any of is occupied, then so are , i.e., there should be no gaps in the output columns. Algorithm for : Given the above definitions, the algorithm for implementing a policy just requires a specification for transitioning from one cell time to the next. The following steps enumerate the procedure.</p><p>1) At the end of time , all output cells occupying slots in the set are discharged. In particular, input cells (or residues thereof) with DD's 1 are completely served.</p><p>2) Each output cell occupying slot for and in the set is assigned to the slot . The occupancy set, peak cell(s), and the departure dates of the residue are recomputed. For example, the occupancy set of the residue at input is given by . From this peak, cells and DD's are easily computed.</p><p>3) New cells advancing to HOL are then scheduled according to . Consider the example of Fig. <ref type="figure" target="#fig_2">3</ref> again. The input cells are scheduled in the order 1, 2, 3, 4, and 5. The occupancy sets, peak cells, and departure dates at time 1 are given in Table <ref type="table" target="#tab_1">I</ref>.</p><p>As a final remark, the discussion in this section presents a unified framework for thinking about multicast scheduling policies. We have seen how constraints like fairness and work conservation translate into rules for placing Tetris blocks in the  <ref type="figure" target="#fig_2">3</ref> box. This general framework allows us to design and evaluate the performance of specific scheduling algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. TATRA: A MULTICAST SCHEDULING ALGORITHM</head><p>Motivated by the Tetris models of the previous section, we now describe a specific multicast scheduling algorithm, TATRA, first introduced in <ref type="bibr" target="#b23">[24]</ref>, and discuss some of its salient features.</p><p>Again, we assume that the switch has been idle prior to time 0, and that the "static input assumption" holds. We denote by the policy TATRA. Since TATRA schedules input cells solely based on their DD's, we assume that this number is stamped upon all of the output cells belonging to a specific input cell (both peak and nonpeak cells).</p><p>For time , the algorithm is specified by the following steps.</p><p>1) At the beginning of time assigns a DD to each new cell at HOL according to the formula given in (1) below. The order in which the DD is assigned when there is a plurality of new cells is in increasing order of their input port numbers.</p><p>2) Each new output cell is dropped to the lowest possible level in the appropriate output slot, without getting ahead of another cell whose DD is less than or equal to its own. Remark: It follows that a nonpeak cell cannot be ahead of a peak cell unless it has the same DD as the peak cell. If such a nonpeak cell exists, we call it a pseudopeak cell (an example of a pseudopeak cell is given below). Corresponding to each output slot, there is thus a (possibly empty) column of peak/pseudopeak cells. This column is called the peak column.</p><p>3) Cells in the bottommost row are discharged. New DD's are computed for the residue cells. Time is advanced to . Using the terminology introduced in the remark above, and from the constitution of a new input cell, its DD is computed as height of peak columns across fan-out (1)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. An Example</head><p>By applying the above algorithm to the example of Fig. <ref type="figure" target="#fig_2">3</ref>, it is easy to see that TATRA schedules the cells as shown in Fig. <ref type="figure" target="#fig_3">4(a)</ref>. Assuming that at the end of time 1 the two new cells at inputs 1 and 5 wish to access ouputs 1, 5 and 2 , respectively, Fig. <ref type="figure" target="#fig_3">4</ref> DD equal to two, which is the same as the cell from input 1. Therefore, the height of the peak column corresponding to output 1 in Fig. <ref type="figure" target="#fig_3">4</ref>(b) is equal to two.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Properties of TATRA</head><p>In this subsection, we discuss some desirable properties of TATRA. For brevity, the properties are stated and only briefly explored.</p><p>Property 1: Under TATRA, an input cell is guaranteed to be discharged every cell time. This is equivalent to the statement that there is a peak cell in every row of the Tetris box. To see this, merely observe that: 1) under every peak cell, there is a column of peak (or pseudopeak) cells, and 2) the cell furthest from the bottom of the box must be a peak cell.</p><p>Property 2: Residue concentration. Suppose that we are given the occupancy sets and of two input cells and . If and for some and for some , then it is impossible that there exists an output such that and , where . That is occupancy sets cannot "criss-cross." This follows from the fact that output cells are arranged in output columns according to a monotonic increase of DD's. The "no criss-crossing" property corresponds to residue concentration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI.</head><p>Although it performs well and is simple to describe, there are two disadvantages to TATRA. First, it is difficult to implement since the assignment of DD's at inputs requires a collective effort, and this process cannot be parallelized. Second, the definition of fairness is both rigid (i.e., no input cell should be held at HOL for more than cell times) and uniformly the same for all inputs. Treating all inputs uniformly does not help when the inputs are nonuniformly loaded or when some inputs request a higher priority.</p><p>These issues motivate us to look for an algorithm that: 1) is simple to implement in hardware, 2) is fair and achieves a high throughput, and 3) is able to cope with nonuniform loading and/or to provide different priorities to inputs. A weight-based algorithm, called WBA, is introduced in this section, and is shown to meet the above requirements.</p><p>It is worth mentioning that if one merely wishes to achieve a high throughput without regard to fairness, then it is best to always achieve the highest residue concentration. But this can lead to the starvation of some inputs. For example, in the Concentrate algorithm, an input cell with maximum fanout may wait forever without being served. Conversely, if an algorithm aims to be fair, it may not achieve the best possible residue concentration, and therefore sacrifices throughput.</p><p>WBA-The Weight-Based Algorithm: This algorithm works by assigning weights to input cells based on their age and fanout at the beginning of every cell time. Once the weights are assigned, each output chooses the heaviest input from among those subscribing to it. It is clear that a positive weight should be given to age in order to achieve fairness. We claim that to maximize throughput, fan-out should be weighted negatively. To see this, recall that at the end of each cell time, the output cells in the bottommost row of the Tetris box are discharged, and all other cells are left behind as residue. To improve residue concentration, we must therefore ensure that as many input cells as possible can be placed in the bottommost row at every cell time. This automatically ensures that the residue is concentrated on fewer inputs. Since the bottommost row can only take output cells, one has to choose input cells with the smallest fan-out to place on this row. Thus, the weight of an input cell should vary inversely as its fan-out.</p><p>Algorithm-WBA: 1) At the beginning of every cell time, each input calculates the weight of the new cell/residue at its HOL based on a) the age of the cell/residue: the older, the heavier; b) the fan-out of the cell/residue: the larger, the lighter. 2) Each input then submits this weight to all of the outputs that the cell/residue at its HOL wishes to access. 3) Each output grants to the input with the highest weight, independently of other outputs, ties being broken randomly. By making a suitable choice of weights based on these two quantities (age and fan-out), one arrives at a compromise between the extremes of pure residue concentration and of strict fairness. Simple calculations show that if we give weight to the age of the cell and weight to the fan-out, the bound on the time for which a cell has to wait at HOL is simply ( ) cell times. In particular, if we give equal weight to age and to fan-out, no cell waits at the HOL for longer than cell times. And if the negative weight of fan-out is twice the weight of the age, then one increases residue concentration and decreases fairness, allowing a cell to wait at the HOL up to cell times. Many variations of the WBA are possible. In particular, one can use other features to assign weights to the cells. For example, one can take into account input queue occupancy while computing weights, or keep track of the utilization of each output link and use negative weight to discourage inputs subscibing to heavily loaded outputs. When dealing with nonuniform loading or when offering different priorities to different inputs, one can use different formulas to compute weights at different inputs. However, these weights should be within the proper range to ensure stability, i.e., the range of possible values for the weights should be the same on all of the inputs. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. SIMULATION RESULTS</head><p>In order to validate our claims in the previous sections, we compare different scheduling policies through simulation. The switch behavior is simulated by using a discrete-event simulator written for the purpose. Our simulated switch is assumed to have infinite buffers at the inputs so that no cells are dropped due to lack of buffer space. In each simulation run, there is a sufficient warm-up period (typically half of the total simulation time) to allow the input buffers to be filled up with cells before statistics about the queue lengths and cell latencies are collected. The simulation continues for a fixed amount of simulation time (typically 1 million cell times) unless the switch becomes unstable (i.e., it reaches a stage where it is unable to sustain the offered load).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Traffic Types</head><p>We assume that the stream of arrivals at the inputs are independent of each other. We compare each scheduling policy for two different arrival processes.</p><p>Uncorrelated Arrivals: At the beginning of each cell time, a cell arrives at each input with probability (the "arrival rate") independently of whether a cell arrived during the previous cell time.</p><p>Correlated Arrivals: Cells are generated using a two-state Markov process which alternates between BUSY and IDLE states. The process remains in the busy and idle states for a geometrically distributed number of cell times, with expected duration and , respectively. is fixed at 16 cells for all the simulations. <ref type="foot" target="#foot_2">4</ref> When in this state, cells arrive at the beginning of every cell time and all with the same set of destinations. The arrival rate . For both types of traffic, each arriving multicast cell has a multicast vector that is uniformly distributed over all possible multicast vectors. However, the destination vector of all zeros is not allowed. As a result, for an switch, the average fan-out is . The offered load is the fraction of link bandwidth used at each input by the incoming traffic. Since the average fan-out is on each of the inputs, the total traffic load of all outputs combined is . Since this traffic is uniformly divided among all the outputs, the load as seen on each of the output links is . Thus, for a 2 switch, the offered load shown in the graphs is the actual load, whereas for an 8 8 switch, the total switch load is approximately four times the offered load shown in the graphs.</p><p>For comparison, we also show the performance of an algorithm, Random, in which each output randomly selects one input from among those that request it. This algorithm is motivated by the work of Hayes et al. in <ref type="bibr" target="#b17">[18]</ref>, which is the multicast version of the unicast algorithm described in <ref type="bibr" target="#b3">[4]</ref>. The WBA plots are obtained by using a fan-out weight equal to twice the weight for cell age.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. 2 8 Switch</head><p>Figs. 5 and 6 compare the different scheduling policies for a 2 8 switch, with uncorrelated and correlated arrivals, respectively. As predicted by Theorem 1, the Concentrate algorithm leads to an average cell latency that is lower than for the Distribute algorithm.</p><p>The algorithms also differ in the maximum possible throughput sustainable by the switch. As expected, the  algorithm that leads to lower cell latency through the switch also provides higher throughput.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. 8 8 Switch</head><p>Figs. 7 and 8 compare the different scheduling policies for an <ref type="bibr" target="#b7">8</ref> 8 switch, with uncorrelated and correlated arrivals, respectively. Once again, the Concentrate algorithm leads to an average cell latency that is much lower than for the Distribute algorithm.</p><p>Note that for an 8 8 switch, TATRA performs than Concentrate. This is because it does not necessarily concentrate the residue on the minimum number of inputs. WBA performs a little worse than TATRA for uncorrelated arrivals, even though TATRA provides a stricter bound on the HOL latency. The reason for this relatively poor performance of WBA is that the outputs make their decision independently. So, if two or more inputs have the same weight, different outputs will not concentrate the residue onto the same input. As a result, WBA is not as effective in concentrating residue as TATRA. Thus, WBA sacrifices some residue concentration for simplicity. Note that for correlated arrivals, the performance of WBA is almost indistinguishable from TATRA (as seen in Fig. <ref type="figure" target="#fig_7">8</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. IMPLEMENTATION COMPLEXITY</head><p>Since input-queueing architectures are interesting only at very high bandwidths, it is very important that the scheduling algorithm for an input-queued switch be simple enough to implement in hardware. Here, we compare the implementation complexity of the various scheduling algorithms we have considered.</p><p>Concentrate: Even though the Concentrate algorithm provides the best throughput performance, it is not a practicable algorithm. First of all, it could lead to the starvation of some inputs; and second, the algorithm requires up to iterations per cell time to complete. This makes the algorithm difficult to implement at high speed.</p><p>TATRA: The TATRA algorithm is simpler to implement than the Concentrate algorithm, but still has a time complexity . To understand why this is so, consider a newly arriving HOL input cell. Scheduling the cell is equivalent to determining the position of its peak cell(s) and its nonpeak cells. If only one input cell is scheduled per cell time, the scheduling decision can be broken down into two simple stages: 1) the peak cell is scheduled by examining the current profile, and 2) the nonpeak cells are scheduled independently by each output. Unfortunately, up to new input cells may need to be scheduled in a cell time where the positions of their nonpeak cells are dependent on the nonpeak cells at other outputs. This results in an algorithm of complexity .<ref type="foot" target="#foot_3">5</ref> WBA: This algorithm can be divided into two main parts: 1) every input computes a request weight, and 2) every output chooses the input making a request with the highest weight. Since calculating an input's weight does not depend on the weight of any other input, this may be performed in parallel. Similarly, each output may choose the input with the highest weight independently, and may be performed in parallel. Hence, the complexity of WBA is . Not only is WBA well suited for parallel implementation, but the logic required is relatively simple. To compute its weight, each input subtracts the fan-out of the cell at HOL from its age; see Fig. <ref type="figure">9</ref>. Each output employs an input magnitude comparator to select the input with the highest weight; see Fig. <ref type="figure" target="#fig_0">10</ref>. A WBA scheduler for an switch can be constructed by using input blocks and output blocks as shown in Fig. <ref type="figure" target="#fig_8">11</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IX. CONCLUSION</head><p>The increase in demand for network bandwidth creates a need for high-speed input-queued multicast switches. To help the designer of such switches, we have studied a variety of multicast scheduling policies, searching for algorithms that achieve high throughput, avoid starvation, and yet are simple to implement in hardware.</p><p>In particular, we have observed that when designing a multicast scheduler, it is important to determine the placement of residue. This leads to the development of the following "residue-concentration heuristic": to achieve a high throughput, a scheduler should always concentrate the residue onto Fig. <ref type="figure">9</ref>. The hardware required in WBA for computation of weight at each input. The age counter is reset when a new multicast cell comes to HOL, and is incremented every cell time thereafter. The bits corresponding to the outputs, which grant to this input, are selectively reset in every cell time until the entire destination vector (the register dests) becomes zero. At this point, the input port is signaled that the transmission of the cell is over, so a new cell can come to HOL. Since the maximum age of a cell at HOL is 2N 0 1 for an N 2 N switch, the age counter needs to be 1 + log(N ) bits wide. Subtracting the fan-out (which spans from 1 to N) from the age makes the total range of weights to be 3N 0 1, which can be represented by using 2 + log(N ) bits. Fig. <ref type="figure" target="#fig_0">10</ref>. The hardware required in WBA for determining the input to grant to at each output. The input requesting with the highest weight is selected.</p><p>as few inputs as possible. The heuristic was supported by simulations and, for 2 switches, a proof established the optimality of the residue-concentrating policy. However, concentrating residue at all times can be unfair and can lead to the starvation of some inputs. We therefore concluded that designing a simple, fast, and efficient multicast scheduler is an exercise in balancing the conflicting requirements of throughput maximization, ensuring fairness, and implementational simplicity.</p><p>We imposed a fairness constraint on our scheduling policies, and used Tetris models to study the general multicast scheduling problem. This led to the development of a fair and efficient scheduling policy-TATRA, and some salient features of TATRA were explored. Although fair and efficient (in terms of high throughput and low latency), TATRA was found to be implementationally complex. To remedy this, we developed and studied a weight-based algorithm called WBA which is easily implemented in hardware, ensures fairness, and achieves good throughput.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX PROOF OF OPTIMALITY FOR 2 SWITCHES</head><p>We now present a proof to show that for a 2 switch, a residue concentrating algorithm, subject to a fairness constraint, outperforms all other fair algorithms. We use the following class of inputs for comparing scheduling policies.</p><p>Definition 11 (Static Input Assumption): Following <ref type="bibr" target="#b22">[23]</ref>, we make the "static input assumption" for switches. That is, it is assumed that at time 0, an infinity of cells has been placed in each input buffer according to some (possibly random) configuration.  The next two definitions give a fairness constraint for 2 switches and a criterion used to judge the performance of scheduling policies.</p><p>Definition 12 (Fairness Constraint for 2 Switches): A scheduling policy for a 2 switch is said to be fair if no cell, from either of the two inputs, is held at HOL for more than one cell time.</p><p>Definition 13 (Performance Criterion): A fair scheduling policy for a 2 multicast switch is said to perform better than another fair policy if every input cell, belonging to either input, departs no later under than under . Under the above conditions, a proof of Theorem 1 was given in <ref type="bibr" target="#b22">[23]</ref>. For the sake of completeness, a brief sketch of the proof is included here.</p><p>Sketch of the Proof of Theorem 1: At time 0, we are given an infinity of packets in each input queue, placed according to some configuration. Fix one such configuration and label the cells at inputs 1 and 2 as and , respectively (Fig. <ref type="figure" target="#fig_9">12</ref>).</p><p>As a consequence of Definition 12, every fair scheduling policy discharges the cell (or residue) at the HOL of each input buffer alternately. This orders all input cells according to their departure times as follows: 1) if is the first cell to depart, and 2) if is the first cell to depart. Here, is to be read as " departs no later than ."</p><p>Without loss of generality, we assume the first ordering for cells, and link them in a vertical or oblique fashion as shown in Fig. <ref type="figure" target="#fig_9">12</ref>. The directions of the arrows on the links denote where the residue is to be concentrated should a policy choose to concentrate residue at some time. The vertical link between and is labeled , and the oblique link between and is labeled . The following facts now follow easily. Fact 1: All scheduling policies work their way through links in that order. In one cell time, the policies release no links when there is contention between cells at HOL and residue is distributed, one link when there is contention between cells at HOL and residue is concentrated, or two links when there is no contention between cells at HOL in one cell time.</p><p>Fact 2: The time at which an input cell is completely served is exactly equal to the time at which the link emanating from it is released.</p><p>In light of Fact 2, Theorem 1 is proved if we show that the fair concentrating policy releases each link no later than any other fair policy . To this end, consider the plots in Fig. <ref type="figure" target="#fig_10">13</ref>. Each plot is a "time-link graph" showing the time a policy releases a certain link. Thus, proving Theorem 1 is equivalent to showing that the time-link graph of the residue concentrating policy lies below that of any nonconcentrating policy. In other words, it is sufficient to prove the following assertion.</p><p>Assertion 1: The time-link graph of the optimal scheduling policy is never above that of any other scheduling policy. A proof of the above assertion (and a complete proof of Theorem 1) may be found in <ref type="bibr" target="#b22">[23]</ref>.</p><p>Remark: The above proof sample path proof cannot be adapted to prove an analogous result for switches. This is because cells at different inputs cannot be ordered in such a way that all fair, work-conserving policies release them in that specific order. Thus, the simple performance criterion used above cannot be used to compare policies for switches when . Indeed, counterexamples suggest that by deliberately distributing residue at certain times, it is possible for a nonconcentrating policy to achieve a higher throughput than a concentrating policy (see <ref type="bibr" target="#b24">[25]</ref>).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. 2 2 N multicast crossbar switch with single FIFO queue at each input.</figDesc><graphic coords="2,75.60,59.58,186.00,112.80" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Graph of average cell latency (in number of cell times) as a function of offered load for an 8 2 8 switch (with uniform input traffic and average fan-out of four). The graph compares random scheduling policy with and without fan-out splitting.</figDesc><graphic coords="3,123.60,55.02,353.04,252.24" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. An example. Cells from inputs 1, 2, 3, 4 are assigned DD's 1, 2, 3, 4, respectively, while the cell from input 5 is assigned a DD of 4.</figDesc><graphic coords="4,389.76,59.58,83.76,130.56" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. TATRA schedules. (a) Cells of Fig. 3. (b) New cells from inputs 1 and 5 at time 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Graph of average cell latency (in number of cell times) as a function of offered load for a 2 2 8 switch (uncorrelated arrivals with an average fan-out of four).</figDesc><graphic coords="7,124.20,55.02,351.84,250.32" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Graph of average cell latency (in number of cell times) as a function of offered load for a 2 2 8 switch (correlated arrivals with an average fan-out of four).</figDesc><graphic coords="8,123.00,54.96,354.24,249.12" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Graph of average cell latency (in number of cell times) as a function of offered load for an 8 2 8 switch (uncorrelated arrivals with an average fan-out of four). Note that the total load on the switch is four times the offered load at the inputs.</figDesc><graphic coords="8,123.90,347.40,352.32,251.04" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Graph of average cell latency (in number of cell times) as a function of offered load for an 8 2 8 switch (correlated arrivals with an average fan-out of four).</figDesc><graphic coords="9,123.60,55.02,353.04,250.32" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. Connecting N input blocks and N output blocks to form an N 2N WBA scheduler.</figDesc><graphic coords="11,44.64,59.58,247.92,212.88" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 12 .</head><label>12</label><figDesc>Fig. 12. 2 2 N multicast crossbar switch. The links show the order in which cells are released.</figDesc><graphic coords="11,67.50,315.66,202.08,106.08" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 13 .</head><label>13</label><figDesc>Fig. 13. Time-link graphs of a nonconcentrating policy and the concentrating policy 3 .</figDesc><graphic coords="11,353.76,59.58,155.76,152.40" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="10,128.64,55.02,342.96,265.92" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>revised December 1, 1996. B. Prabhakar is with BRIMS, Hewlett-Packard Laboratories, Bristol, U.K. N. McKeown is with the Department of Electrical Engineering and Computer Science, Stanford University, Stanford, CA 94305-9030 USA. R. Ahuja is with Torrent Network Technologies, Beltsville, MD 20705 USA, on leave from the Department of Electrical Engineering and Computer Science, Stanford University, Stanford, CA 94305-9030 USA.</figDesc><table /><note><p>Publisher Item Identifier S 0733-8716(97)03377-5.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE I OCCUPANCY</head><label>I</label><figDesc>SET, PEAK CELLS, AND DEPARTURE DATE (DD) OF INPUT CELLS FOR TETRIS BOX SHOWN IN FIG.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>We use the term fan-out throughout this paper to denote both the constitution and the cardinality of the input vector. For example, in Fig.1, the input cell at the head of each queue is said to have a fan-out of four.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>It might appear that fan-out splitting is much more difficult to implement than no fan-out splitting. However, this is not the case. In order to support fan-out splitting, we need one extra signal from the scheduler to inform each input port when a cell at its HOL is completely served.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>The choice of an expected duration of 16 cells per burst is arbitrary, but is representative. The same qualitative results are obtained for different burst lengths.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_3"><p>However, we have designed an approximation to TATRA, in which the input cells can be dropped in parallel, leading to O(1) complexity.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Since October 1995, he has been with Hewlett-Packard's Basic Research Institute in the Mathematical Sciences (BRIMS), Bristol, U.K. His From 1986 to 1989, he worked for Hewlett-Packard Laboratories, in their Network and Communications Research Group in Bristol, U.K. During the Spring of 1995, he worked briefly for Cisco Systems. He is now an Assistant Professor of Electrical Engineering at Stanford University, Stanford, CA. His research interests are in techniques for high-speed networks, including high-speed Internet routing and architectures for high-speed switches. More recently, he has worked on the analysis and design of cell scheduling algorithms and the economics of the Internet. Ritesh Ahuja received the B.Tech. degree from the Indian Institute of Technology, Delhi, in 1994. Since Fall 1995, he has been working toward the Ph.D. degree in the Department of Computer Science, Stanford University, Stanford, CA.</p><p>After that, he worked for one year in the Networking Research Department of AT&amp;T Bell Laboratories, Murray Hill, NJ, implementing the Native Mode ATM protocol stack on PC's running the Brazil operating system. Currently he is on leave from Stanford, working at Torrent Network Technologies. His research interests are in the areas of network protocol design, high-speed switching architectures, VLSI, and CAD.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Growth trends in wide-area TCP connections</title>
		<author>
			<persName><forename type="first">V</forename><surname>Paxson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Network</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="8" to="17" />
			<date type="published" when="1994-08">July-Aug. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">MBone: The multicast backbone</title>
		<author>
			<persName><forename type="first">H</forename><surname>Eriksson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="54" to="60" />
			<date type="published" when="1994-08">Aug. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Multicast routing in datagram internetworks and extended LAN&apos;s</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">E</forename><surname>Deering</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Cheriton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="85" to="110" />
			<date type="published" when="1990-05">May 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Input versus output queueing on a space division switch</title>
		<author>
			<persName><forename type="first">M</forename><surname>Karol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hluchyj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Morgan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Commun</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="1347" to="1356" />
			<date type="published" when="1987-12">Dec. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Performance of a nonblocking space-division packet switch with correlated input traffic</title>
		<author>
			<persName><forename type="first">S.-Q</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Commun</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="97" to="108" />
			<date type="published" when="1992-01">Jan. 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Nonblocking copy networks for multicast packet switching</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">T</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE J. Select. Areas Commun</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="1455" to="1467" />
			<date type="published" when="1988-12">Dec. 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Design of a broadcast switching network</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE INFOCOM&apos;86</title>
		<meeting>IEEE INFOCOM&apos;86</meeting>
		<imprint>
			<biblScope unit="page" from="667" to="675" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Starlite: A wideband digital switch</title>
		<author>
			<persName><forename type="first">A</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE GLOBE-COM&apos;84</title>
		<meeting>IEEE GLOBE-COM&apos;84</meeting>
		<imprint>
			<biblScope unit="page" from="121" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">High speed switch scheduling for local area networks</title>
		<author>
			<persName><forename type="first">T</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Owicki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Saxe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Thacker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 5th Int. Conf. Architectural Support for Programming Languages and Operating Syst</title>
		<meeting>5th Int. Conf. Architectural Support for Programming Languages and Operating Syst</meeting>
		<imprint>
			<date type="published" when="1992-10">Oct. 1992</date>
			<biblScope unit="page" from="98" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Scheduling cells in an input-queued switch</title>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Varaiya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Walrand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Electron. Lett</title>
		<imprint>
			<biblScope unit="page" from="2174" to="2175" />
			<date type="published" when="1993-09">Dec. 9, 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Scheduling algorithms for input-queued cell switches</title>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995-05">May 1995</date>
			<pubPlace>Berkeley</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Univ. California</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. dissertation</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A fast algorithm for multi-channel/port traffic scheduling</title>
		<author>
			<persName><forename type="first">M</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">D</forename><surname>Georganas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Supercomm/ICC&apos;94</title>
		<meeting>IEEE Supercomm/ICC&apos;94</meeting>
		<imprint>
			<biblScope unit="page" from="96" to="100" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">An efficient contention resolution algorithm for input queueing ATM switches</title>
		<author>
			<persName><forename type="first">H</forename><surname>Obara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Digital and Analog Cabled Syst</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="261" to="267" />
			<date type="published" when="1989-12">Oct.-Dec. 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Optimum architecture for input queueing ATM switches</title>
	</analytic>
	<monogr>
		<title level="j">Electron. Lett</title>
		<imprint>
			<biblScope unit="page" from="555" to="557" />
			<date type="published" when="1991-03-28">Mar. 28, 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Scheduling multicast cells in an input-queued switch</title>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Prabhakar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Tech. Rep., Comput. Syst. Lab</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Input and output queueing ATM switch architecture with spatial and temporal slot reservation control</title>
		<author>
			<persName><forename type="first">H</forename><surname>Obara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Okamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Hamazumi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Electron. Lett</title>
		<imprint>
			<biblScope unit="page" from="22" to="24" />
			<date type="published" when="1992-02">Jan. 2, 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Improving the performance of input-queued ATM packet switches</title>
		<author>
			<persName><forename type="first">M</forename><surname>Karol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Eng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Obara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE INFOCOM&apos;92</title>
		<meeting>IEEE INFOCOM&apos;92</meeting>
		<imprint>
			<biblScope unit="page" from="110" to="115" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Performance analysis of a multicast switch</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Hayes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Breault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mehmet-Ali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Commun</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="581" to="587" />
			<date type="published" when="1991-04">Apr. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Multicast and broadcast services in a knockout packet switch</title>
		<author>
			<persName><forename type="first">K</forename><surname>Eng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hluchyj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE INFOCOM&apos;88</title>
		<meeting>IEEE INFOCOM&apos;88</meeting>
		<imprint>
			<biblScope unit="page" from="29" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Sunshine: A high-performance self-routing broadband packet switch architecture</title>
		<author>
			<persName><forename type="first">J</forename><surname>Giacopelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hickey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Marcus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sincoskie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Littlewood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE J. Select. Areas Commun</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="1289" to="1298" />
			<date type="published" when="1991-10">Oct. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Queueing analysis for multicast packet switching</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Y</forename><surname>Hui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Renner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Commun</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="723" to="731" />
			<date type="published" when="1994-04">Feb./Mar./Apr. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Performance analysis of a random packet selection policy for multicast switching</title>
		<author>
			<persName><forename type="first">M</forename><surname>Mehmet-Ali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Commun</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page" from="388" to="398" />
			<date type="published" when="1996-03">Mar. 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Scheduling multicast cells in an input-queued switch</title>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Prabhakar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE INFOCOM&apos;96</title>
		<meeting>IEEE INFOCOM&apos;96</meeting>
		<imprint>
			<biblScope unit="page" from="271" to="278" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Designing a multicast switch scheduler</title>
		<author>
			<persName><forename type="first">B</forename><surname>Prabhakar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 33rd Annu. Allerton Conf</title>
		<meeting>33rd Annu. Allerton Conf<address><addrLine>Urbana-Champaign, IL</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Tetris models for multicast switches</title>
		<author>
			<persName><forename type="first">B</forename><surname>Prabhakar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mairesse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 30th Annu</title>
		<meeting>30th Annu<address><addrLine>Princeton, NJ</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
