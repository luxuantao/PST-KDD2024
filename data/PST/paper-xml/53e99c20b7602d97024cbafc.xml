<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Proof Rules for Automated Compositional Verification through Learning</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Howard</forename><surname>Barringer</surname></persName>
							<email>howard@cs.man.ac.uk</email>
						</author>
						<author>
							<persName><forename type="first">Dimitra</forename><surname>Giannakopoulou</surname></persName>
							<email>dimitra@email.arc.nasa.gov</email>
						</author>
						<author>
							<persName><forename type="first">Corina</forename><forename type="middle">S P</forename><surname>Ȃs Ȃreanu</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Manchester</orgName>
								<address>
									<addrLine>Oxford Road</addrLine>
									<postCode>M13 9PL</postCode>
									<settlement>Manchester</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">RIACS</orgName>
								<address>
									<country>USRA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">NASA Ames Research Center Moffett Field</orgName>
								<address>
									<postCode>94035-1000</postCode>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="department">Kestrel Technology LLC NASA Ames Research Center Moffett Field</orgName>
								<address>
									<postCode>94035-1000</postCode>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Proof Rules for Automated Compositional Verification through Learning</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">F9032BB3602E81873622D8688D6E420C</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:32+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Parallel Composition</term>
					<term>Automated Verification</term>
					<term>Assumption Generation</term>
					<term>Learning</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Compositional proof systems not only enable the stepwise development of concurrent processes but also provide a basis to alleviate the state explosion problem associated with model checking. An assume-guarantee style of specification and reasoning has long been advocated to achieve compositionality. However, this style of reasoning is often nontrivial, typically requiring human input to determine appropriate assumptions. In this paper, we present novel assumeguarantee rules in the setting of finite labelled transition systems with blocking communication. We show how these rules can be applied in an iterative and fully automated fashion within a framework based on learning.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Our work is motivated by an ongoing project at NASA Ames Research Center on the application of model checking to the verification of autonomous software. Autonomous software involves complex concurrent behaviors for reacting to external stimuli without human intervention. Extensive verification is a pre-requisite for the deployment of missions that involve autonomy. Given a finite model of a system and of a required property, model checking can be used to determine automatically whether the property is satisfied by the system. The limitation of this approach, commonly referred to as the "stateexplosion" problem <ref type="bibr" target="#b7">[7]</ref>, is that it needs to store the explored Assume-guarantee<ref type="foot" target="#foot_0">1</ref> reasoning first checks whether a component M guarantees a property P , when it is part of a system that satisfies an assumption A. Intuitively, A characterizes all contexts in which the component is expected to operate correctly. To complete the proof, it must also be shown that the remaining components in the system, i.e., M 's environment, satisfy A. Several frameworks have been proposed <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b21">21,</ref><ref type="bibr" target="#b6">6,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b24">24,</ref><ref type="bibr" target="#b15">15]</ref> to support this style of reasoning. However, their practical impact has been limited because they require non-trivial human input in defining assumptions that are strong enough to eliminate false violations, but that also reflect appropriately the remaining system.</p><p>In previous work <ref type="bibr" target="#b8">[8]</ref>, we developed a novel framework to perform assume-guarantee reasoning in an iterative and fully automatic fashion; the approach uses learning and modelchecking. To check that a system made up of components M1 and M2 satisfies a property P , our framework automatically learns and refines assumptions for one of the components to satisfy P , which it then tries to discharge on the other component. Our approach is guaranteed to terminate, stating that the property holds for the system, or returning a counterexample if the property is violated. This work introduces a variety of sound and complete assumeguarantee rules in the setting of Labeled Transition Systems with blocking communication. The rules are motivated by the need for automating assume-guarantee reasoning. How-ever, in contrast to our previous work, they are symmetric, meaning that they are based on establishing and discharging assumptions for both components at the same time. The remainder of this paper is organized as follows. We first provide some background in Section 2, followed by some basic compositional proof rules in Section 3. The framework that automates these rules is presented in Section 4. Section 5 introduces rules that optimize and extend the basic rules. Finally, Section 6 presents related work and Section 7 concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">BACKGROUND</head><p>We use Labeled Transition Systems (LTSs) to model the behavior of communicating components in a concurrent system. In this section, we provide background on LTSs and their associated operators, and also present how properties are expressed and checked in our framework. We also summarize the learning algorithm that is used to automate our compositional verification approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Labeled Transition Systems</head><p>Let Act be the universal set of observable actions and let τ denote a local action unobservable to a component's environment. An LTS M is a quadruple Q, αM, δ, q0 where:</p><formula xml:id="formula_0">• Q is a non-empty finite set of states • αM ⊆ Act is a finite set of observable actions called the alphabet of M • δ ⊆ Q × αM ∪ {τ } × Q is a transition relation • q0 ∈ Q is the initial state</formula><p>An LTS M = Q, αM, δ, q0 is non-deterministic if it contains τ -transitions or if ∃(q, a, q ), (q, a, q ) ∈ δ such that q = q . Otherwise, M is deterministic.</p><p>Traces. A trace t of an LTS M is a sequence of observable actions that M can perform starting at its initial state. For Σ ⊆ Act, we use t Σ to denote the trace obtained by removing from t all occurrences of actions a / ∈ Σ. The set of all traces of M is called the language of M , denoted L (M ). We will freely use the expression "a word t is accepted by M " to mean that t ∈ L (M ). Note that the empty word is accepted by any LTS.</p><p>Parallel Composition. Let M = Q, αM, δ, q0 and M = Q , αM , δ , q0 . We say that M transits into M with action a, denoted M a -→ M , if and only if (q0, a, q0 ) ∈ δ and αM = αM and δ = δ .</p><p>The parallel composition operator is a commutative and associative operator that combines the behavior of two components by synchronizing the actions common to their alphabets and interleaving the remaining actions.</p><p>Let M1 = Q1, αM1, δ1, q01 and M2 = Q2, αM2, δ2, q02 be two LTSs. Then M1 M2 is an LTS M = Q, αM, δ, q0 , where Q = Q1 × Q2, q0 = (q01, q02), αM = αM1 ∪ αM2, and δ is defined as follows, where a is either an observable action or τ (note that the symmetric rules are implied by the fact that the operator is commutative):</p><formula xml:id="formula_1">M1 a -→ M 1 , a / ∈ αM2 M1 M2 a -→ M 1 M2 M1 a -→ M 1 , M2 a -→ M 2 , a = τ M1 M2 a -→ M 1 M 2 Note. L (M1 M2) = {t | t αM1 ∈ L (M1) ∧ t αM2 ∈ L (M2) ∧ t ∈ (αM1 ∪ αM2) * }</formula><p>Properties and Satisfiability. A property is also defined as an LTS P , whose language L (P ) defines the set of acceptable behaviors over αP . An LTS M satisfies P , denoted as M |= P , if and only if ∀t ∈ L (M ).t αP ∈ L (P ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">LTSs and Finite-State Machines</head><p>As will be described in section 4, our proof-rules require the use of the "complement" of an LTS. LTSs are not closed under complementation (their languages are prefix-closed), so we need to define here a more general class of finite-state machines (FSMs) and associated operators for our framework.</p><p>An FSM M is a five tuple Q, αM, δ, q0, F where Q, αM, δ, and q0 are defined as for LTSs, and F ⊆ Q is a set of accepting states.</p><p>For an FSM M and a word t, we use δ(q, t) to denote the set of states that M can reach after reading t starting at state q. A word t is said to be accepted by an FSM M = Q, αM, δ, q0, F if δ(q0, t) ∩ F = ∅. Note that in the following sections, the term trace is often used to denote a word. The language accepted by M , denoted L (M ) is the set {t | δ(q0, t) ∩ F = ∅}.</p><p>For an FSM M = Q, αM, δ, q0, F , we use LTS(M) to denote the LTS Q, αM, δ, q0 defined by its first four fields. Note that this transformation does not preserve the language of the FSM. On the other hand, an LTS is in fact a special instance of an FSM, since it can be viewed as an FSM for which all states are accepting. From now on, whenever we apply operators between FSMs and LTSs, it is implied that the LTS is treated as its corresponding FSM.</p><p>We call an FSM M deterministic iff LTS(M) is deterministic.</p><p>Parallel Composition. Let M1 = Q1, αM1, δ1, q01, F1 and M2 = Q2, αM2, δ2, q02, F2 be two FSMs. Then M1 M2 is an FSM M = Q, αM, δ, q0, F , where:</p><p>• Q, αM, δ, q0 = LT S(M1) LT S(M2), and</p><formula xml:id="formula_2">• F = {(s1, s2) ∈ Q1 × Q2 | s1 ∈ F1 ∧ s2 ∈ F2}. Note. L (M1 M2) = {t | t αM1 ∈ L (M1) ∧ t αM2 ∈ L (M2) ∧ t ∈ (αM1 ∪ αM2) * }</formula><p>Satisfiability. For FSMs M and P where αP ⊆ αM , M |= P if and only if ∀t ∈ L (M ).t αP ∈ L (P ).</p><p>Complementation. The complement of an FSM (or an LTS) M , denoted coM , is an FSM that accepts the complement of M 's language. It is constructed by first making M deterministic, subsequently completing it with respect to αM , and finally turning all accepting states into nonaccepting ones, and vice-versa. An automaton is complete with respect to some alphabet if every state has an outgoing transition for each action in the alphabet. Completion typically introduces a non-accepting state and appropriate transitions to that state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">The L* Algorithm</head><p>In Section 4, we present a framework that automates compositional reasoning using a learning algorithm.</p><p>The learning algorithm (L*) used by our approach was developed by Angluin <ref type="bibr" target="#b2">[2]</ref> and later improved by Rivest and Schapire <ref type="bibr" target="#b22">[22]</ref>. L* learns an unknown regular language (U over an alphabet Σ) and produces a deterministic FSM C such that L(C) = U . L* works by incrementally producing a sequence of candidate deterministic FSMs C1, C2, ... converging to C. In order to learn U , L* needs a Teacher to answer two type of questions. The first type is a membership query, consisting of a string σ ∈ Σ * ; the answer is true if σ ∈ U , and false otherwise. The second type of question is a conjecture, i.e. a candidate deterministic FSM C whose language the algorithm believes to be identical to U . The answer is true if L (C) = U . Otherwise the Teacher returns a counterexample, which is a string σ in the symmetric difference of L (C) and U . At a higher level, L* creates a table where it incrementally records whether strings in Σ * belong to U . It does this by making membership queries to the Teacher. At various stages L* decides to make a conjecture. It constructs a candidate automaton C based on the information contained in the table and asks the Teacher whether the conjecture is correct. If it is, the algorithm terminates. Otherwise, L* uses the counterexample returned by the Teacher to extend the table with strings that witness differences between L (C) and U . L* is guaranteed to terminate with a minimal automaton C for the unknown language U . Moreover, each candidate deterministic FSM Ci that L* constructs is smallest, in the sense that any other deterministic FSM consistent with the table has at least as many states as Ci. The candidates conjectured by L* strictly increase in size; each candidate is smaller than the next one, and all incorrect candidates are smaller than C. Therefore, if C has n states, L* makes at most n -1 incorrect conjectures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">COMPOSITIONAL PROOF RULES 3.1 Motivation</head><p>In our previous work on assumption generation and learning <ref type="bibr" target="#b12">[12,</ref><ref type="bibr" target="#b8">8]</ref>, we used the following basic rule for establishing that a property P holds for a (closed) parallel composition of two software components M1 and M2.</p><p>Rule 0.</p><formula xml:id="formula_3">1 : M1 AM 1 |= P 2 : M2 |= AM 1 M1 M2 |= P AM 1</formula><p>denotes an assumption about the environment in which M1 is placed.</p><p>In <ref type="bibr" target="#b12">[12]</ref>, we present an approach to synthesizing the assumption that a component needs to make about its environment for a given property to be satisfied. The assumption produced is the weakest, that is, it restricts the environment no more and no less than is necessary for the component to satisfy the property. The automatic generation of weakest assumptions has direct application to the assume-guarantee proof. More specifically, it removes the burden of specifying assumptions manually thus automating this type of reasoning.</p><p>The algorithm presented in <ref type="bibr" target="#b12">[12]</ref> does not compute partial results, meaning no assumption is obtained if the computation runs out of memory, which may happen if the state-space of the component is too large. We address this problem in <ref type="bibr" target="#b8">[8]</ref>, where we present a novel framework for performing assume-guarantee reasoning using the above rule in an incremental and fully automatic fashion. The framework iterates a process based on gradually learning assumptions. The learning process is based on queries to component M1 and on counterexamples obtained by model checking M1 and its environment, i.e. component M2, alternately. Each iteration may conclude that the required property is satisfied or violated in the system analyzed. This process is guaranteed to terminate; in fact, it converges to an assumption that is necessary and sufficient for the property to hold in the specific system.</p><p>Although sound and complete, Rule 0 is unsatisfactory from an automation point of view<ref type="foot" target="#foot_1">2</ref> since it is not symmetric. We thus considered whether some form of "circular", assumeguarantee like, rule could be developed. For our framework the obvious rule for the parallel composition of two processes, where the assumption of each process is discharged by the commitment (or guarantee) of the other, however, is unsound. Indeed, we demonstrate the unsoundness of the following rule.</p><p>Rule 0m.  first, rather than ensuring a does. The circular reasoning to discharge the assumptions in this case was unsound. The above rule fails for our framework essentially because the two components may have common erroneous behaviour(as far as the property is concerned) which is (mis-)ruled out by assumptions that are overly presumptuous for the particular composition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Basic Proof Rule</head><p>In the following we give a symmetric parallel composition rule and establish its soundness and completeness for our framework. In Section 4 we then outline how the rule can be used for automated compositional verification along similar lines to the approach given in <ref type="bibr" target="#b8">[8]</ref>.</p><p>Rule 1.</p><formula xml:id="formula_4">1 : M1 AM 1 |= P 2 : M2 AM 2 |= P 3 : L (coAM 1 coAM 2 ) = ∅ M1 M2 |= P M1, M2</formula><p>, AM 1 , AM 2 and P are LTSs<ref type="foot" target="#foot_2">3</ref> as defined in the previous section; we require αP ⊆ αM1 ∪ αM2, αAM 1 ⊆ (αM1 ∩ αM2) ∪ αP and αAM 2 ⊆ (αM1 ∩ αM2) ∪ αP . Informally, however, the AM i are postulated environment assumptions for the components Mi to achieve, respectively, property P . coAM 1 denotes the co-assumption for M1, which is the complement of AM 1 . Similarly for coAM 2 .</p><p>The intuition behind premise 3 stems directly from an understanding of the failure of Rule 0m; premise 3 ensures that the assumptions do not both rule out possible, common, violating behaviour from the components. For example, Rule 0m failed in our example above, because both assumptions ruled out common behaviour (ba) * of M1 and M2, which violates property P . Premise 3 in Rule 1 is a remedy for this problem.</p><p>Theorem 1. Rule 1 is sound and complete.</p><p>Proof. To establish soundness, we show that the premises together with the negated conclusion leads to a contradiction. Consider a word t for which the conclusion fails, i.e. . By the definition of parallel composition and the fact that an FSM and its complement have the same alphabet, t (αAM 1 ∪ AM 2 ) will be accepted by coAM 1 coAM 2 . But premise 3 states that there are no common words in the co-sets. Hence we have a contradiction.</p><p>Our argument for the completeness of Rule 1 relies upon the use of weakest environment assumptions that are constructed in a similar way to <ref type="bibr" target="#b12">[12]</ref>. Let WA(M, P ) denote the weakest environment for M that will achieve property P . WA(M, P ) is such that, for any environment A, M A |= P iff A |= WA(M, P ).</p><p>Lemma 1. coW A(M, P ) is the set of all traces over the alphabet of W A(M, P ) in the context of which M violates property P . In other words, this defines the most general violating environment for (M, P ). A violating environment for (M, P ) is one that causes M to violate property P in all circumstances.</p><p>To establish completeness, we assume the conclusion of the rule and show that we can construct assumptions that will satisfy the premises of the rule. In fact, we construct the weakest assumptions WAM 1 <ref type="foot" target="#foot_3">4</ref> , resp. WAM 2 , for M1, resp. M2, to achieve P , and substitute them for AM 1 and AM 2 . Clearly premises 1 and 2 are satisfied. It remains to show that premise 3 holds. Again we proceed by proof by contradiction. Suppose there is a word t in L (coWAM 1 coWAM 2 ). By definition of parallel composition, t is accepted by both coWAM 1 and coWAM 2 . By Lemma 1, t αP violates property P . Furthermore, there will exist t1 ∈ L (M1 coP ) such that t1 αt = t, where αt is the alphabet of the assumptions. Similarly for t2 ∈ L (M2 coP ). t1 and t2 can then be combined to be a trace t3 of M1 M2 such that t3 αt = t. But if that is so, this contradicts the assumed conclusion that M1 M2 |= P , since t violates P . Therefore, there can not be such a common word t and premise 3 holds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">AUTOMATED REASONING 4.1 Framework</head><p>For the use of Rule 1 to be justified, the assumptions AM 1 and AM 2 must be more abstract than the components that they represent, i.e. M2 and M1 respectively, but also strong enough for the three steps of the rule to be satisfied. Developing such assumptions is a non-trivial process. We propose an iterative approach to automate the application of Rule 1. The approach extends the framework of counterexamplebased learning presented in <ref type="bibr" target="#b8">[8]</ref>. As in our previous work and as supported by the LTSA model checking tool <ref type="bibr" target="#b19">[19]</ref>, we assume that both properties and assumptions are described by deterministic FSMs; this is not a serious limitation since any non-deterministic FSM can be transformed to a deterministic one via the subset construction. To obtain appropriate assumptions, our framework applies the compositional rule in an iterative fashion as illustrated in Fig. <ref type="figure" target="#fig_1">2</ref>. We use a learning algorithm to generate incrementally an assumption for each component, each of which is strong enough to establish the property P , i.e. to discharge premises 1 and 2 of Rule 1.</p><p>We have seen in the previous section that Rule 1 is guaranteed to return conclusive results with the weakest assumptions WAM 1 , resp. WAM 2 , for M1, resp. M2, to achieve P . We therefore use L* to iteratively learn the traces of WAM 1 , resp. WAM 2 . Conjectures are intermediate assump-</p><formula xml:id="formula_5">tions A i M 1 , resp. A j M 2 .</formula><p>As in <ref type="bibr" target="#b8">[8]</ref>, we use model checking to implement the Teacher needed by L*.</p><p>At each iteration, L* is used to build approximate assumptions A i M 1 and A j M 2 , based on querying the system and on the results of the previous iteration. The first two premises of the compositional rule are then checked. Premise 1 is checked to determine whether M1 guarantees P in environments that satisfy A i M 1 . If the result is false, it means that this assumption is too weak, i.e. A i M 1 does not restrict the environment enough for P to be satisfied. The assumption therefore needs to be strengthened, which corresponds to removing behaviours from it, with the help of the counterexample produced by checking premise 1. In the context of the next assumption A i+1 M 1 , component M1 should at least not exhibit the violating behaviour reflected by this counterexample. Premise 2 is checked in a similar fashion, to obtain an assumption A j M 2 such that component M2 guarantees P in environments that satisfy A j M 2 .</p><p>If both premise 1 and premise 2 hold, it means that A i M 1</p><p>and A j M 2 are strong enough for the property to be satisfied. To complete the proof, premise 3 must be discharged. If premise 3 holds, then the compositional rule guarantees that P holds in M1 M2. If it doesn't hold, further analysis is required to identify whether P is indeed violated in M1 M2 or whether either A i M 1 or A j M 2 are stronger than necessary. Such analysis is based on the counterexample re-turned by checking premise 3 and is described in more detail below. If an assumption is too strong it must be weakened, i.e. behaviors must be added, in the next iteration. The result of such weakening will be that at least the behavior that the counterexample represents will be allowed by the respective assumption produced at the next iteration. The new assumption may of course be too weak, and therefore the entire process must be repeated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Counterexample analysis</head><p>If premise 3 fails, then we can obtain a counterexample in the form of a trace t. Similar to <ref type="bibr" target="#b8">[8]</ref>, we analyse the trace in order to determine how to proceed. We need to determine whether the trace t indeed corresponds to a violation in M1||M2. This is checked by simulating t on Mi||coP , for i = 1, 2. The following cases arise. (1) If t is a violating trace of both M1 and M2, then M1 and M2 do indeed have a common bad trace and therefore do not compose to achieve P . (2) If t is not a violating trace of M1 or M2 then we use t to weaken the corresponding assumption(s).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Discussion</head><p>A characteristic of L* that makes it particularly attractive for our framework is its monotonicity. This means that the intermediate candidate assumptions that are generated increase in size; each assumption is smaller than the next one, i.e.</p><formula xml:id="formula_6">|A i M 1 | ≤ |A i+1 M 1 | ≤ |WAM 1 | and |A j M 2 | ≤ |A j+1 M 2 | ≤ |WAM 2 |.</formula><p>However, we should note that there is no monotonicity at the semantic level, i.e. it is not necessarily the case that</p><formula xml:id="formula_7">L(A i M 1 ) ⊆ L(A i+1 M 1 ) or L(A j M 2 ) ⊆ L(A j+1 M 2 ) hold.</formula><p>The iterative process performed by our framework terminates for the following reason. At any iteration, our algorithm returns true or false and terminates, or continues by providing a counterexample to L*. By the correctness of L*, we are guaranteed that if it keeps receiving counterexamples, it will eventually, produce WAM 1 and WAM 2 respectively.</p><p>During this last iteration, premises 1 and 2 will hold by definition of the weakest assumptions. The Teacher will therefore check premise 3, which will return either true and terminate, or a counterexample. Since the weakest assumptions are used, by the completeness proof of Rule 1, we know that the counterexample analysis will reveal a true error, and hence the process will terminate.</p><p>It is interesting to note that our algorithm may terminate before the weakest assumptions are constructed via the iterative learning and refinement process. It terminates as soon as two assumptions have been constructed that are strong enough to discharge the first two premises but weak enough for the third premise to produce conclusive results, i.e. to prove the property or produce a real counterexample; these assumptions are smaller (in size) than the weakest assumptions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">VARIATIONS</head><p>In Section 3 we established that Rule 1 is sound and complete for our framework and in Section 4 we showed its applicability for the automated learning approach to compositional verification. However, we need to explore and understand its effectiveness in our automated compositional verifi-cation approach. In this section we introduce some straightforward modifications to the rule, maintaining soundness and completeness of course, that may remove unnecessary assumption refinement steps and therefore result in a probable overall improvement in performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">First Modification</head><p>Our first variation, Rule 1a given below, relaxes the third premise by requiring that any common "bad" trace, as far as the assumptions are concerned, satisfies the property P . The intuition behind this is that the assumptions may well have been overly restrictive and therefore there may be common behaviours of M1 and M2, ruled out by the assumptions, that do indeed satisfy the property P .</p><p>Rule 1a.</p><formula xml:id="formula_8">1 : M1 AM 1 |= P 2 : M2 AM 2 |= P 3 : L (coAM 1 coAM 2 ) ⊆ L (P ) M1 M2 |= P Theorem 2.</formula><p>Rule 1a is sound and complete.</p><p>Proof. Follows easily from the soundness and completeness proofs for Rule 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Rule 1b.</head><formula xml:id="formula_9">1 : M1 AM 1 |= P 2 : M2 AM 2 |= P 3 : M1 coAM 1 |= AM 2 or M2 coAM 2 |= AM 1 M1 M2 |= P</formula><p>In essence, in this variation, premise 3 effectively now checks whether any trace in the intersection of the co-assumptions is an illegal behaviour of either component, rather than it just satisfying the property. Notice that the disjunct</p><formula xml:id="formula_10">M1 coAM 1 |= AM 2 is equivalent to L (coAM 1 coAM 2 ) ⊆ L (M1)</formula><p>, similarly for the other disjunct. We've used this particular form for the disjuncts because of similarity with assumption discharge.</p><p>Theorem 3. Rule 1b is sound and complete.</p><p>Proof. Similar to proofs of Theorems 1 and 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Incorporation of Rules 1a and 1b.</head><p>Rule 1a can easily be incorporated into our incremental compositional verification framework.</p><p>Step 3 of Fig. <ref type="figure" target="#fig_1">2</ref> is followed by an extra step, Step 4, for the case when the intersection of the co-assumptions is not empty.</p><p>Step 4 checks whether the intersection satisfies the given property: if it returns true then we terminate, otherwise continue with counter-example analysis and assumption refinement. In order to incorporate Rule 1b, we simply include a further check to discharge one of the disjuncts of the rule's third premise.</p><p>Clearly these "optimisation"s may result in the verification process terminating after fewer learning iterations. On the other hand there will be some increased overhead in performing the extra checks on each weakening iteration. These issues will be analysed more fully in our future implementation of this incremental approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Further Variation</head><p>Suppose we are now given components, M1 and M2, with associated properties, P1 and P2. The following composition rule can be used to establish that propertyP1 P2 holds for M1 M2.</p><p>Rule 2.</p><formula xml:id="formula_11">1 : M1 AM 1 |= P1 2 : M2 AM 2 |= P2 3 : M1 AM 1 |= AM 2 4 : M2 AM 2 |= AM 1 5 : L (coAM 1 coAM 2 ) = ∅ M1 M2 |= P1 P2</formula><p>where we require αP1 ⊆ αM1, αP2 ⊆ αM2, αAM 1 ⊆ αM1 ∩ αM2 and αAM 2 ⊆ αM1 ∩ αM2.</p><p>Theorem 4. Rule 2 is sound and complete.</p><p>Proof. Soundness is established by contradiction, in a similar way to the soundness results for Rules 1, 1a and 1b. We outline the steps. We also abuse and simplify notation by omitting the projections of traces onto the appropriate alphabets.</p><p>We assume the properties P1 and P2 are not contradictory, i.e. L(P1 P2) is not empty, or all behaviours are not erroneous. Further, assume the conclusion does not hold, i.e. M1 M2 |= P1 P2. There then exists a trace t of M1 M2 s.t. t is in not accepted by P1 P2. There are three subcases to consider. The first case contradicts premise 5. By premise 1, t not in P1 means t is not a trace of M1 AM 1 . But since t is a trace of M1 M2 and hence of M1, then t must be accepted by coAM 1 . Similarly, by premise 2, t must be accepted by coAM 2 . But this now contradicts premise 5.</p><p>For the second case, and similarly for the third case, we will show a contradiction of premise 4, resp. premise 3. As for the first case, by premise 1 if t is not in P1 and t in M1 then t must be accepted by coAM 1 . As t in P2, t is accepted by M2 AM 2 . Hence, by premise 4, t is in AM 1 . But t can't be both in AM 1 and in coAM 1 . The mirror argument follows for the third case.</p><p>Observe that if premises 3 and 4 were not present, as in the case of rule 1, then soundness is not obtained.</p><p>Completeness follows by constructing the weakest assumptions WAM 1 , resp. WAM 2 , for M1, resp. M2, to achieve P1, resp. P2, and substituting them for AM 1 and AM 2 . We can then show that if the rule's conclusion holds, then so do the premises.</p><p>It is interesting to note that if premises 3 and 4 of Rule 2 are modified to be in the more usual form of guarantee discharging assumption, i.e. P1 |= AM 2 and P2 |= AM 1 , then the rule is not complete.</p><p>As was the case with Rule 1, we can weaken premise 5 of Rule 2 to obtain similar rules to Rule 1a and Rule 1b.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">HISTORICAL PERSPECTIVE</head><p>Over two decades ago, the quest for obtaining sound and complete compositional program proof systems, in various frameworks, remained open. The foundational work on proof systems for concurrent programs, for example <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b20">20,</ref><ref type="bibr" target="#b18">18]</ref>, whilst not achieving compositional rules, introduced key notions of meta-level co-operation proofs and non-interference proofs. These meta-level proofs were carried out using program code and intermediate assertions from the proofs of the sequential processes. Assumption-commitment, or relyguarantee, style specifications, in addition to pre-and postconditions, were then introduced to capture the essence of the meta-level co-operation and non-interference proofs, lifting the assumptions that were implicitly made in the sequential proof outlines to be an explicit part of the specification. Program proof systems, built over such extended specifications, were then developed to support the stepwise, or hierarchical, development of concurrent, or distributed, programs, see for example <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b25">25,</ref><ref type="bibr" target="#b4">4,</ref><ref type="bibr" target="#b23">23]</ref>. The development of such compositional proof systems continues to this day and the interested reader should consult <ref type="bibr" target="#b10">[10]</ref> for an extensive and detailed coverage.</p><p>In recent years, there has been a resurgence of interest in formal techniques, and in particular assume-guarantee reasoning, for supporting component-based design: see for example <ref type="bibr" target="#b9">[9]</ref>. Even though various sound and often complete proof systems have been developed for this style of reasoning, more often than not it is a mental challenge to obtain the most appropriate assumptions <ref type="bibr" target="#b15">[15]</ref>. It is even more of a challenge to find automated techniques to support this style of reasoning. The thread modular reasoning underlying the Calvin tool <ref type="bibr" target="#b11">[11]</ref> is one start in this direction. One way of addressing both the design and verification of large systems is to use their natural decomposition into components. Formal techniques for support of component-based design are gaining prominence, see for example <ref type="bibr" target="#b9">[9]</ref>. In order to reason formally about components in isolation, some form of assumption (either implicit or explicit) about the interaction with, or interference from, the environment has to be made. Even though we have sound and complete reasoning systems for assume-guarantee reasoning, see for example <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b21">21,</ref><ref type="bibr" target="#b6">6,</ref><ref type="bibr" target="#b14">14]</ref>, it is always a mental challenge to obtain the most appropriate assumption <ref type="bibr" target="#b15">[15]</ref>.</p><p>It is even more of a challenge to find automated techniques to support this style of reasoning. The thread modular reasoning underlying the Calvin tool <ref type="bibr" target="#b11">[11]</ref> is one start in this direction. The Mocha toolkit <ref type="bibr" target="#b0">[1]</ref> provides support for modular verification of components.</p><p>The problem of generating an assumption for a component is similar to the problem of generating component interfaces to deal with intermediate state explosion in CRA. Several approaches have been defined for automatically abstracting a component's environment to obtain interfaces <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b17">17]</ref>. These approaches do not address the incremental refinement of interfaces.</p><p>Learning in the context of model checking has also been investigated in <ref type="bibr" target="#b13">[13]</ref>, but with a different goal. In that work, the L* Algorithm is used to generate a model of a software system which can then be fed to a model checker. A conformance checker determines if the model accurately describes the system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSIONS AND FUTURE WORK</head><p>Although theoretical frameworks for sound and complete assumption-commitment reasoning have existed for many years, their practical impact has been limited because they involve non-trivial human interaction. In this paper, we have presented a new set of sound and complete proof rules for parallel composition that support a fully automated verification approach based upon such a reasoning style. The automation approach extends and improves upon our previous work that introduced a learning algorithm to generate and refine assumptions based on queries and counterexamples, in an iterative process. The process is guaranteed to terminate, and return true if a property holds in a system, and a counterexample otherwise. If memory is insufficient to reach termination, intermediate assumptions are generated, which may be useful in approximating the requirements that a component places on its environment to satisfy certain properties.</p><p>One advantage of our approach is its generality. It relies on standard features of model checkers, and could therefore easily be introduced in any such tool. For example, we are currently in the process of implementing it in the LTSA. The architecture of our framework is modular, so its components can easily be substituted by more efficient ones.</p><p>We have implemented our framework within the LTSA tool and over the coming months we will conduct a number of experiments to establish the practical effectiveness of our new composition rule and its variations. We need to understand better the various trade-offs between the increased overhead of additional premise testing and the computational savings from earlier termination of the overall process. In addition, we need to investigate known variants of our rules for N -process compositions, again considering various practical tradeoffs in implementation terms. Of course, an interesting challenge will also be to extend the types of properties that our framework can handle to include liveness, fairness, and timed properties.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Example of process M and property P to demonstrate unsoundness of Rule 0m</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Incremental compositional verification</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>t is a trace of M1 M2 that violates property P , in other words t is not accepted by P . Clearly, by definition of parallel composition, t αM1 is accepted by M1. Hence, by premise 1, the trace t αAM 1 can not be accepted by AM 1 , i.e. t αAM 1 is accepted by coAM 1 . Similarly, by premise 2, the trace t αAM 2 is accepted by coAM 2</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>1. t not in P1 and t not in P2 2. t not in P1 and t in P2 3. t in P1 and t not in P2</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The original terminology for this style of reasoning was rely-guarantee or assumption-commitment; it was introduced for enabling top-down development of concurrent systems.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>It is also unsatisfactory from a formal development point of view!</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>except for when AM 1 , AM 2 and P are false, in which case they are represented as FSMs</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>Since the context is clear we abbreviate WA(M, P ) as WAM .</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">MOCHA: Modularity in model checking</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">Y C</forename><surname>Mang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Qadeer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tasiran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Tenth Int. Conf. on</title>
		<meeting>of the Tenth Int. Conf. on</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><surname>Comp</surname></persName>
		</author>
		<title level="m">Aided Verification (CAV)</title>
		<imprint>
			<date type="published" when="1998-07-02">June 28-July 2, 1998</date>
			<biblScope unit="page" from="521" to="525" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Learning regular sets from queries and counterexamples</title>
		<author>
			<persName><forename type="first">D</forename><surname>Angluin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">75</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="87" to="106" />
			<date type="published" when="1987-11">Nov. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A proof system for communicating sequential processes</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R</forename><surname>Apt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Francez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-P</forename><surname>De Roever</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="359" to="385" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Hierarchical development of concurrent systems in a framework</title>
		<author>
			<persName><forename type="first">H</forename><surname>Barringer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kuiper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Seminar in Concurrency</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">B</forename></persName>
		</editor>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="volume">197</biblScope>
			<biblScope unit="page" from="35" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Context constraints for compositional reachability analysis</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kramer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Soft. Eng. and Methodology</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="334" to="377" />
			<date type="published" when="1996-10">Oct. 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Compositional model checking</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Fourth Symp. on Logic in Comp. Sci</title>
		<meeting>of the Fourth Symp. on Logic in Comp. Sci</meeting>
		<imprint>
			<date type="published" when="1989-06">June 1989</date>
			<biblScope unit="page" from="353" to="362" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Model Checking</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Peled</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Learning assumptions for compositional verification</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Cobleigh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Giannakopoulou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Pȃsȃreanu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">9th International Conference for the Construction and Analysis of Systems (TACAS 2003)</title>
		<meeting><address><addrLine>Warsaw, Poland</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2619</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Interface theories for component-based design</title>
		<author>
			<persName><forename type="first">L</forename><surname>Alfaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the First Int. Workshop on Embedded Soft</title>
		<meeting>of the First Int. Workshop on Embedded Soft</meeting>
		<imprint>
			<date type="published" when="2001-10">Oct. 2001</date>
			<biblScope unit="page" from="148" to="165" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">W.-P</forename><surname>De Roever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>De Boer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Hanneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hooman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lakhnech</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Poel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zwiers</surname></persName>
		</author>
		<title level="m">Concurrency Verification: Introduction to Compositional and Non-compositional Methods</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Thread-modular verification for shared-memory programs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Flanagan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">N</forename><surname>Freund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Qadeer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Eleventh European Symp. on Prog</title>
		<meeting>of the Eleventh European Symp. on Prog</meeting>
		<imprint>
			<date type="published" when="2002-04">Apr. 2002</date>
			<biblScope unit="page" from="262" to="277" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Assumption generation for software component verification</title>
		<author>
			<persName><forename type="first">D</forename><surname>Giannakopoulou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Pȃsȃreanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Barringer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Seventeenth IEEE Int. Conf. on Auto</title>
		<meeting>of the Seventeenth IEEE Int. Conf. on Auto</meeting>
		<imprint>
			<date type="published" when="2002-09">Sept. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Adaptive model checking</title>
		<author>
			<persName><forename type="first">A</forename><surname>Groce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Peled</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yannakakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Eighth Int. Conf. on Tools and Alg. for the Construction and Analysis of Sys</title>
		<meeting>of the Eighth Int. Conf. on Tools and Alg. for the Construction and Analysis of Sys</meeting>
		<imprint>
			<date type="published" when="2002-04">Apr. 2002</date>
			<biblScope unit="page" from="357" to="370" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Model checking and modular verification</title>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Long</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Second Int. Conf. on Concurrency Theory</title>
		<meeting>of the Second Int. Conf. on Concurrency Theory</meeting>
		<imprint>
			<date type="published" when="1991-08">Aug. 1991</date>
			<biblScope unit="page" from="250" to="265" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">You assume, we guarantee: Methodology and case studies</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Qadeer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Tenth Int. Conf. on Comp.-Aided Verification (CAV)</title>
		<meeting>of the Tenth Int. Conf. on Comp.-Aided Verification (CAV)</meeting>
		<imprint>
			<date type="published" when="1998-07-02">June 28-July 2, 1998</date>
			<biblScope unit="page" from="440" to="451" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Specification and design of (parallel) programs</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">B</forename><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IFIP 9th World Congress</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Mason</surname></persName>
		</editor>
		<meeting>the IFIP 9th World Congress</meeting>
		<imprint>
			<publisher>IFIP: North Holland</publisher>
			<date type="published" when="1983">1983</date>
			<biblScope unit="volume">83</biblScope>
			<biblScope unit="page" from="321" to="332" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Compositional state space generation from Lotos programs</title>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Krimm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Mounier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Third Int. Workshop on Tools and Alg. for the Construction and Analysis of Sys</title>
		<meeting>of the Third Int. Workshop on Tools and Alg. for the Construction and Analysis of Sys</meeting>
		<imprint>
			<date type="published" when="1997-04">Apr. 1997</date>
			<biblScope unit="page" from="239" to="258" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A proof technique for communicating sequential processe s</title>
		<author>
			<persName><forename type="first">G</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gries</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="281" to="302" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Magee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kramer</surname></persName>
		</author>
		<title level="m">Concurrency: State Models &amp; Java Programs</title>
		<imprint>
			<publisher>John Wiley &amp; Sons</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">An axiomatic proof technique for parallel programs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Owicki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gries</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="319" to="340" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">In transition from global to modular temporal reasoning about programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<editor>K. Apt</editor>
		<imprint>
			<date type="published" when="1984">1984</date>
			<publisher>Springer-Verlag</publisher>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="123" to="144" />
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
	<note>Logic and Models of Concurrent Systems</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Inference of finite automata using homing sequences</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Schapire</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">103</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="299" to="347" />
			<date type="published" when="1993-04">Apr. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A proof technique for rely/guarantee properties</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Stark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fifth Conference on Foundations of Software Technology and Theoretical Computer Science</title>
		<title level="s">Lecture Notes in Theoretical Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1985-12">Dec. 1985</date>
			<biblScope unit="volume">206</biblScope>
			<biblScope unit="page" from="369" to="391" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">The rely-guarantee method for verifying shared variable concurrent programs</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">P</forename><surname>De Roever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>He</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Aspects of Computing</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="149" to="174" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Compositionality and concurrent networks: Soundness and completeness of a proof system</title>
		<author>
			<persName><forename type="first">J</forename><surname>Zwiers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-P</forename><surname>De Roever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Van Emde</surname></persName>
		</author>
		<author>
			<persName><surname>Boas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ICALP &apos;85</title>
		<meeting>ICALP &apos;85</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<biblScope unit="volume">194</biblScope>
			<biblScope unit="page" from="509" to="519" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
