<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Artiiiuai hneilty and Language Processing</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Chris</forename><surname>Montgomery</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Uoyd</forename><surname>Fosdick</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Technische</forename><surname>Universitat</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Munchen</forename><forename type="middle">West</forename><surname>Germany</surname></persName>
						</author>
						<author>
							<persName><roleName>Dr</roleName><forename type="first">Wolfgang</forename><surname>Bibel</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Inslitut fur Informatik</orgName>
								<orgName type="institution">Technischen Universital Munchen</orgName>
								<address>
									<postCode>D-8000</postCode>
									<settlement>Munchen</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<address>
									<addrLine>Postfach 20 24 20</addrLine>
									<country>VVesI Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Artiiiuai hneilty and Language Processing</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">8D4CBB4478391A99E1BE194C29AA899A</idno>
					<note type="submission">Received 3/81; revised 2/83; accepted 4/83</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T06:38+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract/>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>An essential feature of human thinking is the capacity for logical reasoning. Everyone uses it all the time, mostly in an unconscious way. It was this capacity which eventually led to man's scientific activity. Therefore, it is not surprising that since the dawn of history, man has reflected upon the very nature of logical reasoning. He has modeled it within natural language, and isolated general rules operative in the human brain in everyday experience. In the course of time, the rules of logic were abstracted irom natural language and expressed within formal languages, which model natural languages to the extent that they keep the logical structure intact. These formal languages together with the rules are called formal, or logical systems.</p><p>There are many such formal systems to date, each developed according to the purpose it was meant to serve. For instance, one formal system might be developed as a tool to be used by a mathematician to prove theorems within some theory, while another might be of a purely machine-oriented nature. Formal systems developed within non-monotonic logic must account for contingent truths: clearly, such systems, which admit the possibility of contingency, would be inappropriate for proving mathematical theorems.</p><p>Most of these formal systems are based on firsf-order logic (FOL). Its rules are so fundamental that any (existing or future) system of practical importance will probably have incorporated them in some form. This is, for instance, true of systems for both higher-order and modal logic which simply are extensions of FOL. Further, FOL is both natural and powerful enough to model much of our reasoning adequately. We will, therefore, focus our attention on FOL keeping in mind that, while this restriction may be artificial, it is certainly reasonable as a point of depjarture.</p><p>Although this paper is written with a particular formal system for FOL in mind, we will not specify the details here. No trouble should arise for readers familiar v\ith the basic concepts of FOL, As usual, we have the class of [weU-formed] fornriulas which correspond to syntactically correct fragments of text in natural language. dl ABSTRACT: This paper gives an overview of the connection method. developed by the author in Automated Theorem Proving. Its prominent features are illustrated with a number of examples. Welldefined measures of efficiency have shown it to outperform standard proof methods. Some of its features are alsa present in <ref type="bibr">Andrews'</ref> independent approach via matings. The relationship between these two methods is clarified.</p><p>The mast fundamental prnhlcm in FOL, as in any other tnuiI system, is iho doveloptiicnt of a {hopefully efficient] prcx:edure which for a given set of formulas F, Fn. n &gt; 0, decides whether F,, is a consequence of F, F^ according lo the rules in FOL, Such a procedure Is called a decision procedure. According to a well-known result of Church {e.g., see <ref type="bibr" target="#b15">[15]</ref>. p. 170), this problem, in its most general form, has no solution, unless the F.'s are taken from certain subclasses of formulas (which frequently is the case for formulas of interest). For arbitrary F/s. there are only so-called semi-decision or proof procedures, that is, procedures which are guaranteed to give a result in the affirmative case only, and in the negative case may give an answer (the usual case in practice) or run forever. These are the type of procedures we will study.</p><p>If we could develop an ej^ficienl such procedure this would have an enormous practical impact for many kinds of applications in science because of the general nature of FOL discussed before. Some of these applications are described by Nilsson <ref type="bibr" target="#b18">[18]</ref>. It has occasionally been argued against this kind of general approach with reference to results (and conjectures) from complexity theory which seem to indicate that in principle such procedures cannot be efficient for arbitrary formulas. But even were this the case, it would not say very much about the feasibility of proof procedures in practice because of the worst-case nature of such general complexity results [cf.. Sect, rv.3 in <ref type="bibr" target="#b7">[7]</ref>). Therefore, the development of efficient proof procedures does remain a challenging and promising research goal. This is not to say that current proof procedures are completely inefficient. On the contrary, running deductive systems have proved rather deep mathematical theorems automatically; they have even solved a number of open mathematical problems (none of ihe famous ones, of course) for , which a human proof was not found. Further they are in daily use as programming aids, generating or verifying pieces of programming code, (The interested reader is referred to the , Proceedings of the Conferences on Automated Deduction <ref type="bibr">(9, , 14, 17, 21]</ref>, In many respects, these achievements are still modest, however, when compared uith human performance.</p><p>The reasons for their deficiencies seem to be of two different kinds. First, human beings seem to adapt, quickly, powerful strategies which speed up the search. Research is just beginning to study such adaptive mechanisms. Second, the existing systems are based on proof procedures which work in such a redundant way that it is amazing that they are at all successful. Researchers, like all people, tend to a monotheistic attitude in such a situation, expecting the cure by solving one of these two kinds of problems. We believe, however, that bolh kinds of deficiencies necessarily have to be removed in order to substantially enhance the performance of running systems.</p><p>This paper is concerned with only one of these kinds of deficiencies: redundancy. It plagues all the popular proof procedures, in particular those based on the resolution principle introduced by <ref type="bibr">Robinson [19)</ref>, as well as most of those based on a natural deduction-like approach <ref type="bibr" target="#b10">[10]</ref>.</p><p>In the last decade, however, there have been two essentially independent but closely related developments, which provide an improvement in this direction. One is due to Andrews, the other to the author. The results have been published in a number of papers of a rather technical nature (see <ref type="bibr" target="#b1">[1]</ref><ref type="bibr" target="#b2">[2]</ref><ref type="bibr" target="#b3">[3]</ref><ref type="bibr" target="#b4">[4]</ref><ref type="bibr" target="#b5">[5]</ref><ref type="bibr" target="#b6">[6]</ref> for the most recent ones). Therefore, we attempt to provide a more expository overview of this method which is provably less redundant than any other known proof method, in the course of this overview, we clarify the relatioaship between Andrews' and the author's approach. Occasionally. we compare our methnd with standard proof methods. For a comprehensive treatment, the reader is referred to <ref type="bibr" target="#b7">[7]</ref>.</p><p>It is hoped that the; presentation is such Ihal nnt only an expert in Ihe field uill be able to quickly grasp the essence of this method, but also a non-experi unth some familiarity with FOL will get a feeling for the enhancement achieved (a summary of which appears in Section 8), Due to the nature of the exposition and to limitations in space, the examples discussed are necessarily trivial and consequently do not reflect the generality of application. For more complex problems, the many details of a technical nature have to be left to the computer in actual implementations. In fact, the method has heen implemented both by Andrews and the author together uath their associates (e.g., see <ref type="bibr" target="#b17">[17]</ref>, pp, 50-69). A more advanced implementation is currently in progress (project "Beweisverfahren" supported by the Deutsche Forschungsgemeinschaft), 2. THE BASIC CONCEPTS FOR THE CONNECTION METHOD As our first example, we choose a very old syllogism sajing that the man. Socrates, is mortal since every man is mortal. The logic of such a statement in natural language is often ambiguous. For this reason, the formal first-order language has been developed in order to express the statement in the following logically equivalent but unambiguous way (see <ref type="bibr" target="#b15">[15)</ref>, or Chapter 4 in <ref type="bibr" target="#b18">[18]</ref> for an introduction).</p><p>Al: Vx (MANx -» MTLx) : "every man is mortal" A2: MANsocrates TH. MTLsocrates : "Socrates is a man" : "Socrates is mortal" With these partial statements, the whole statement says: from the oxioms, Al and A2, we may infer the theorem, TH. In fact, we may express the whole statement as the single formula Al A A2 ^ TH wherein Al, A2. and TH abbreviate the respective formulas above. Note the usage of the convention that A binds more than -* in order to save parenth^es. (Such conventions uill henceforth be assumed). For purely didactic reasons, in this formula, the implication sign -* is replaced equivalently by negation n and disjunction V and the scope of each occurrence ofn is made to be atomic by applying the well known equivalence rules relating logical connectives {cf, 111,1,4 in <ref type="bibr" target="#b7">[7]</ref>). The resulting formula then reads</p><formula xml:id="formula_0">F:3x(MANx A nMTLx) V nMANsocrales V MTLsocrates</formula><p>The original inference from Al and A2 to TH is a valid one if and only if F is a valid formula or a theorem in the sense of FOL v\ithout non-logical axioms. The problem is how to test the validity of F (and of other theorems) as efficiently as possible.</p><p>For the following, it is illustrative to display such a formula in a two-dimensional format by listing the parts connected by V from left to right, and within each such part connected by A from top down, F represented in this way reads 3x An unordered pair of literals such as IMANx. -tfvlANsocratesi with one and the same predicate symbol-here MAN-one literal unnegatcd, the other negated, and both contained in some path through a matrix, is called a connection in that matrix, A set of connections is called spanning for a matrix if each path through it contains such a connection (as a subset), Ob\iously, there are exactly two connections in F which, in fact, are spanning for F and are illustrated by MTLsocratesj Now, according to the results of Andrews and the author (see Corollary 111,6,4 in <ref type="bibr" target="#b7">[7]</ref>), F is in fact a theorem if, and only if, there is a substitution of some term for the variable x such that after this substitution, each of the two spanning connections consists of two complemenfary literals, i.e,, a literal L and its negated form nL, This obviously is the case if we substitute socrates for x, hence, F, in fact, is a theorem or, in other words, MTLsocrates is a logical consequence of the two axioms Al and A2, lt was pointed out before tbat the elimination of the implication sign serves didactic purposes only. We now can see why it does not affect the essence of the method at all. We need just redefine the crucial notion of a spanning set of connections for arbitrary formulas via the equivalence rules mentioned above, a simple exercise indeed. For our original formula we thus obtain</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MANxl</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Vx(MANx -» MTLx) A MANsocraleSj^i^MTLsocrales</head><p>This demonstrates that it is a negligible technical detail whether we prefer to work with the ori^nally given formula or the equivalent two-dimensional display. In this paper, we mainly use the latter since it displays the paths, the connections, and the spanning properties in a more transparent way.</p><p>Let us be sure that among all these comments and definitions we do not miss the crux of this discussion: For establishing the proof of our theorem, F, all we have to do is: (i) locate the two spanning connections within F; and (ii) test the existence of an appropriate substitution. It is important to note that this does not require any storage for copies of parts of the given formula, which, for this method, holds in general and not only with this trivial example.</p><p>For comparison, it is interesting to have a look at the popular resolution method <ref type="bibr" target="#b19">[19]</ref>. For reasons which today may be regarded as historical the given formula is first negated. The resulting formula is transformed into clausai form similar to what we did with F above. From the resulting set of clauses (or matrix), the empty set (or clause) is derived by two applications of the resolution rule as shown in Figure <ref type="figure" target="#fig_0">1</ref>.</p><p>If we now recall our previous proof, it becomes obvious that each resolution step, resolving upon two literals, corresponds exactly to locating the connection between these two literals in the given formula and vice versa. The empty set is derived as soon as the set of connections thus obtained be- comes spanning and vice versa. We notice that in the clausal form of resolution, the position of the negation in each connection is switched due to negating the original formula. Less trivial is the fact that in the course of the resolution proof a new clause, namely [MTLsocratesj, has been generated. Since, in general, no clauses may be deleted, this not only requires additional memor\' space but also increases the search space since we may resolve any two clauses, old or new. Much research effort has been invested in resolution in order to avoid these drawbacks which may become disastrous in more realistic problems where tens of thousands of generated clauses are not unusual. In our approach, these problems do not arise at all. From this perspective, then, our method appears as a clever representation of resolution avoiding some of its drawbacks. That it is more uill become clear as we proceed uith additional examples. Perhaps at this point it might be appropriate to introduce some name for this new method. Over tbe years, the author used to call it the syslematic method to stress the point that it affects a more systematic proof search than other methods. This is not a very distinctive name, however, since all these methods are more or less systematic. In view of the fact that locating connections in the formula may be regarded as its characteristic activity as we have already seen, connection principle or method uill be used in this paper.</p><p>The connection method as described up to this point is identical with Andrews' general matings method except for the following notational differences. Following the resolution tradition Andrews starts with negating the given formula. Consequently, his paths run top-down rather than left-right in the matrix. Incidentally, he refers to a formula like the one explicitly named F above as in negation norniai form where the scope of each explicit or implicit (e.g., via -•) negation is atomic.</p><p>A set of connections in his terminology^ is a potenfiaJ mating. A set of connections such that there is a substitution making all connected pairs of literals complementary is called a maling. If, additionally, it is sparming, p-acceptable in his terminology, then it is a rejiifalion mating. The literals in a single connection are called potential mates (uith respect to the empty mating). More substantial differences between the two methods than merely these notational ones will emerge as we proceed uith further examples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">GENERATING SPANNING SETS OF CONNECTIONS</head><p>The previous section demonstrated that a pixwf v\ith the connection method requires two things-namely, a spanning set of connections and an appropriate substitution. Although a realistic proof procedure will not perform these two tasks separately, a separate discussion will certainly be helpful for the reader. Therefore, in this section, we shall set aside all aspects related to substitution. This can be achieved by as-suming that the appropriate substitution has been determined in advance. The formula F from the previous section ii trixtorm vvouldlhonread m ma-</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I MANsocralesl , I-iMTLsocrates | (""MANsocrates)|MTLsocrates|</head><p>By abbreviating MANsocrates by L and MTLsocrales by K, and deleting the braces we obtain simply _j[; -iL K.</p><p>In this case, where the literals are simply (possibly negated) propositional variables, our basic question whether F is a theorem is reduced to whether this matrix in propositional logic (sometimes called the ground level) is a tautology. As before, this is the case if, and only if, each of its paths contains 3 connection (see <ref type="bibr">Theorem 11.3,</ref><ref type="bibr">4 in [7]</ref>). We are now going to describe an algorithm which determines exactly that. Let us call it SSC for "spanning set of connections." Since our matrix is a little too simple for illustrating its behavior, we add four more literals, \ielding</p><formula xml:id="formula_1">L nL . . ,. L nk M k</formula><p>Initially, SSC chooses any clause, say the leftmost one, and in it any literal, say L. A data structure for storing the whole matrix is easily designed such that a clause containing the negation of the chosen literal can be found immediately, for instance, by looking it up in a table which contains all occurring literals in a determined order together uith a reference to those clauses in which they occur. Doing this establishes a first connection in our matrix M</p><formula xml:id="formula_2">T L K K.</formula><p>At the same time a pointer is set in the first clause (the little arrow in the picture) noting that L has been processed but the rest of the clause-in this case, just nK-remains to be processed. This completes the first step of SSC in which all paths containing this selected connection IL, "iL!-only two in this particular example, but ob\iously there may be many more in general-have been checked and will never be considered by SSC,</p><p>The paths yet to be processed may be partitioned into those which contain L (but not nL) from the first connection and those which do not, SSC proceeds uith the first ones while the second ones have been stored on a stack simply by the reference depicted by the pointer above. At this stage, the situation is essentially the same as the one after the selection of the first clause, the selected clause now being the second one from the left, marked with a vertical arrow, SSC chooses any member literal except TL, Here, this must be M since this is the only one left. As before, from the remaining clauses (to the right of the vertical arrow), we choose one which contains "&gt;M, thus establishing the second connection as shown</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>K</head><p>If there had been more literals in the second clause, this would have provided a new entry on the stack as illustrated with the second horizontal arrow pointing to nothing in this particular example. After this second step, all paths containing one of the selected connections have been checked. SSC must continue to process those path.s containing L (but not iL, and not both M and iM any more). If there were such paths left, the same partition would be made with res[&gt;ect to M as before with respect to L: Ihus, we would prof^eed wilh the third step as before in the second step, and so forth. Note that such a chain is never longer than the clauses in the whole matrix since new clauses in this process are always selected from those not already involved in the present chain. Due to the particular situation of this example, there is no such third step; however, since all paths containing L also contain one of the selected connections. SSC notices this since the third clause does not contain any literal other than iM. In such a situation, it backs up by considering the topmost (nonempty) entry on the stack which is depicted by the leftmost horizontal arrow, thus starting a new chain from the situation illustrated by K As before, SSC selects any literal in the actual clause marked by the vertical arrow, which has not been processed before, and any clause containing its complement, thus establishing a third connection as shown in where the reordering of the clauses is required for clarity of presentation. The horizontal arrow depicts later processing of further literals in the first clause (none in this case). The new chain after this step has already been completed. Since the stack is empty, SSC terminates uith success. The three selected connections which, incidentally, need not be stored explicitly, are in fact spanning for this matrix. The rightmost clause and any connections containing its literals were redundant for the proof.</p><p>This completes the description of algorithm SSC for testing any matrix for a set of spanning connections. Above, we have already stressed that no extra storage of copies of the parts of the given formula is required. Only the pointers directing the chaining through the formula have to be stored in addition to a single copy of the formula and something like the table (of the size of the formula) mentioned at the beginning of this section. This fact is characteristic for SSC. not only in its simple form just described with a trivial example, but also in its fiiU version applicable to arbitrary formulas, A full version of this has been developed in <ref type="bibr" target="#b4">[4]</ref> (see also pp. 326-341 in <ref type="bibr" target="#b17">[17]</ref>), It is very general and has been designed to avoid certain redundant steps arising in special situations, for which reason its algorithmic details are rather complicated. It has been demonstrated <ref type="bibr" target="#b4">[4]</ref> that this full version may simulate any knouTi refinement of resolution with fewer or equal number of steps (and less storage) in the search for a proof, the amount of processing required for a single step being about the same in both cases. Since there are formulas for which SSC requires strictly feiver steps we see that the connection method provides a real (and provable) advantage over known resolution methods in addition to the representational advantage mentioned several times before, (There is another major advantage to be discussed in later sections.) As a guard against too much optimism we mention that determining a spanning set of connections is known as a hard problem in gonoral (actually co-NP-hard in llic lorminology of complexity theory); hence, no miracles should be expected for the worst case.</p><p>Because of its generality, the full version, in fact, may deal with arhitrnr\-formulas or matrices not only onos in normal form (as our examples have considered thus far). For instance, any literal, e,g,, M in the previous matrix, might be replaced by a whole (non-normal form) matrix; SSC still would be able to process such a matrix as before and without any change of its structure. The reason for this generalization lies in the fact that the characterization of tautologies via connections in each path, which was mentioned before, holds for arbitrary formulas, (See Theorem n.3,4 in <ref type="bibr" target="#b7">[7]</ref>.)</p><p>Andrews has demonstrated the disadvantages of the transformation to clausal form, which is required for resolution, with several examples. For instance, in <ref type="bibr" target="#b1">[1]</ref>, it has been shown that the simple mathematical statement /(S U T) = f(S) U f(T] for a frmction f and two sets S and T after elimination of the defined operations (like U but not *-») leads to a formula uith 12 literals, compared with 104 literals in the corresponding clausal form. Now imagine the effect when the proof process searches among 104 rather than among 12 literals! It might be helpful for the reader to consider SSC as a proof rule rather than an algorithm. Namely, for any given matrix, A, SSC in ech step essentially adds a single connection iv to the set W of those connections obtained in previous steps; hence, the rule is (A, W] h (A, W U |vv|), (For more details, see Sections 11,4 and 11.5 in <ref type="bibr" target="#b7">[7]</ref>,)</p><p>Note that the formula. A, does not change, in contrasi to any other logical rules. Initially, W = 0 and the termination criterion for a successful derivation is the spanning property of VV for A. If the process gets stuck before this criterion is fulfilled, then A is shown to be invalid. Thus, in the sense defined in the Introduction, SSC is actually a decision procedure for the subclass of propositional formulas (of the class of all formulas in FOL], 4. UNIFICATION In Section 2, we have seen that a proof of a theorem involves the problem of (i) determining a spanning set of connections such that (ii) there is a substitution of terms for variables which makes the connected literals complementary.</p><p>In the previous section, we described the basic idea of the algorithm SSC for solving (ij on the ground level. Obviously, such an algorithm is applicable also on the general level, i.e., in FOL, by simply neglecting the terms in the literals. Therefore, we now take the existence of such an algorithm for granted and ask for a solution of the subproblem (ii).</p><p>Since the test for (ii) may be performed by a fast algorithm, and a potential failure might be detected after any step of SSC, it is preferable to check for (ii) after each step. For example, after the first step of SSC is applied to the matrix F of Section 2, we would have to test whether there is a substitution, say (Tl, which makes MANx and TMANsocrates complementary. Of course, a, = jx •-socrates) will do and thus is kept for the following steps, Thus, the situation after this first step may be illustrated as in the previous section with the substitution a, added.</p><p>After having obtained the second connection in the second step, subproblom (ii) now requires a substitution fr^. such thai Ihe two literals iMTLx and MTLsocrates, after application of rr, and aj, becx)me complementary. Obviously CT^ = 0 since o, •lion*! is sufficient in Ihis particular case, thus completing the proot already presented in Section 2,</p><p>In general, we proceed this way considering in the nth step two literals, L, and U, and the composition &lt;T,,_,, a,,.j n, of the substitutions obtained in the previous steps (substituting terms for variables) and test for a substitution a,, such that &lt;T"L^' = CTp-iL^' where L,' = (Tn-i • • • (JJU for i = 1, 2, This problem of determining a,, is known as the unification problem <ref type="bibr" target="#b19">[19]</ref> which ha.s been thoroughly studied with fast solutions (running in linear time) for the general case. We do not discuss any of these unification algonthms in detail (See Sections in.5 and rv.9 in [7j,) assuming that the reader will grasp somewhat of their nature from further examples. But we must point out that their application is subject to an essential restriction.</p><p>Consider any predicate Q with two arguments and the formula Vr 3x (Qcx -*^Qxc]</p><p>Applying the connection method this turns out to be a theorem since the substitution d, = jx -c[ solves subproblem [ii). Let us now exchange the two quantifiers to yield 3x Vc [Qcx -* Qxc)</p><p>Simply by reading the formula as a statement with his natural language, the reader will see that this cannot be a true statement for arbitrary Qs although our method, as described thus far, would result in the same proof with TI = Ix ••-c\. Of course, a, cannot be a correct solution since according to the formula the existence of object x is claimed independent of the choice ofc while 0, would suggest a dependeni solution.</p><p>Standard proof methods take care of that hy introducing socalled Skolem functions for each V quantifier with the dominating 3-quantified variables as arguments. In this example, 3x dominates Vc in the (tree) structure of tbe formula which is expressed briefly by x &lt; c; hence, c is replaced by fx to yield 3x (Q( fx]x -* Qx( fx)] where / is any new function symbol. Obviously, this prevents the two connected literals from being unified since for no substitution can x and fx yield the same term.</p><p>As an alternate solution to this, one may regard c = a-^x as a tree-ordering relation c &lt;• x. Such a substitution is then called acceptable if the transitive closure &lt;] of the union &lt; U &lt; of the relations &lt; and &lt; has no cycles. In this sense, 01 for our example is not acceptable since c &lt;• x &lt; c obviously leads to the cycle c&lt;c. Thus, all we need do is restrict unification to acceptable substitutions; this has several technical advantages over the solution via Skolem functions. Namely, some fast unification methods, after having introduced Skolem functions, construct &lt;l from them-hence, their introduction is in fact redundant-and test for cycles anyway, (See ]\'.*d.\ in <ref type="bibr" target="#b7">[7]</ref>.) Also, our solution fits elegantly uith what will be discussed in later sections.</p><p>We complete the description of the most basic aspects of the connection method by pointing out that it requires (selective) backtracking whenever an acceptable substitution does not exist as in the following example: Here, the dotted connection has no acceptable substitution. Hence, SSC has to back up and consider the alternate (fully lined) connection which yields the proof with the acceptable substitution b.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>/ex I</head><p>At this point, it is appropriate to complete the comparison with Andrews' work. As in the standard resolution methods, he uses Skolem functions. His ground-level procedure is less elaborate than our full version of SSC. Finally, his method lacks the features described in the following two sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5, IMPUCIT AMPUnCATION Consider the formula</head><formula xml:id="formula_3">fac(O) = 1 A V.x&gt;-ifac{x] ^ y fac{K+ l) = (2) = z</formula><p>It claims the existence of a value for the factorial function for the argument 2 which obviously is a valid statement. As before, we prefer the matrix represeniation which is</p><formula xml:id="formula_4">-ifac[O) = 3xv-l^°'=tx) = y 1 -h/ac(x + 1) =y.(x + 1)| 3z fac(2) = z</formula><p>An attempt to prove this theorem uith the connection method as described in the previous sections v\ill fail, however, since this description is still incomplete in an essential detail. Namely, according to the nature of FOL, we must allow for an arbitrary number of independent copies of any 3-quantified part in the matrix (which explains why no decision procedure exists for FOL), Adding further such copies is called amplification by Andrews. For our example, a proof is obtained uith one additional copy of the second clause as shown in Figure <ref type="figure" target="#fig_1">2</ref>.</p><p>Here, the copies are distinguished by indices added to the variables. For instance, x and y from the ori^nal second clause are replaced by x, and y, in its first copy and by x^ and y2 in its second copy, respectively. Although only a single copy of the rightmost clause is needed so that a replacement is not actually required here, z has nevertheless heen replaced by Zi for reasons of uniformity.</p><p>Evidently, the three depicted connections are spanning. The corresponding acceptable substitution is CT = |x, •-0, y, *-1, Xj *-1, y-*-\,Zt*-2\: for instances, a unifies (here in a slighlly generalized sense as the altert reader might notice) the respective pairs of terms corresponding to the second connection, viz., a[x, + 1) = [0 + \] = 1 = ax^ and a[ y,-(x, + 1)) = 1 .(0 -I-1) = 1 = (ry2. Note that for the "answer" variable, z,, this proof yields the expected result of computing the factorial of 2. viz.. az-, = 2, We now encode this proof within a single copy of the original matrix in the following way.</p><formula xml:id="formula_5">3z fac(2) = z 1 n/ac(O) = 1</formula><p>This representation is obtained from the previous one simply by projecting the two copies of the second clause into the single original one, while the information concerning their differences is encoded in the indices now labeling the nodes of the connections (each hy definition, given in Section 1, referring to the adjacent literal). For instance, there are two such nodes adjacent to the literal fac(x] = y. one labeled uith 1, the other with 2, It is obvious, for this example, that all information contained in the previous explicit presentation (with the explicitly added second copy) can be recovered from this implicit encoding; conversely, the implicit representation is also uniquely determined by the explicit one. This one-to-one correspondence between these two kinds of representations in fact holds in general. Hence, the connection method need not explicitly generate such copies of 3-quantified formula parXs, since the illustrated simple indexing technique serves the same purpose. The technical and rather complicated details realizing this intuitively simple idea may be f^ound in the Sections 111, 6 and fV,8 of <ref type="bibr" target="#b7">[7]</ref>, while a version of our algorithm SSC, adapted to the present complication, is spelled out in in.7,2of[7[. This kind of connection proof in implicit representation may easily be generalized to arbitrary input n &gt; 1 for the present example (as well as for others, of course) by introducing schemes of connections. This is illustrated as follows, this time using again the original formula structure (Figure <ref type="figure" target="#fig_2">3</ref>).  It represents both the natural specification of the problem to compute the value of the factorial for input n (viz., the logical formula) and a proof, respectively a program, determining how to compute this value efficiently (viz,, the connection scheme). Note that specification and program are neatly separated, whereas in conventional programs the logical and dynamic structure are mixed together. It is this mixture which causes so many problems in software production. Such a logic program (i.e,, formula + scheme) may be compiled automatically as usual to run as efficiently as any conventional program computing/ac(n). (For a discussion of the close connection between these kind of proofs and programs, and for fijrther information concerning the predicate logic as a suitable programming environment, see <ref type="bibr" target="#b8">[8]</ref>, or Section V.2 in <ref type="bibr" target="#b7">[7]</ref>, and the references given there, such as Reference 3 in <ref type="bibr" target="#b8">[8]</ref>),</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">SPOTTING BY NEED Consider the formula</head><p>Vx iLLx~^LLpat A ILLbob presented together with its proof along the lines of the previous section. This looks like a satisfactory solution but, in fact, has a major drawback. Imagine that the three literals are replaced by matrices of considerable size v\ith many more required connections. Then, the implicit generation of a second copy of the matrix to the left of the implication uill certainly increase the search space for appropriate connections substantially since in particular connections between the two copies have to be taken into consideration as the previous example has demonstrated. The second copy, however, is not actually required (not even implicitly) since the two conclusions are independent from each other because of the separating conjunction; hence, the search for the proof may take advantage of what is called splitting in conventional methods and is applied there in a processing step.</p><p>Here, we briefiy discuss an alternate form of splitting by need which is more fiexible and more general than previous splitting methods, and which elegantly fits into the connection method.</p><p>Recall the relations &lt; (tree structure of formula), &lt; (substitutional structure), and &lt; (transitive closure of &lt; U &lt;), introduced in Section 4. In order to account for splitting, &lt; v\ill now serve an additional purpose. Namely, consider the situation where the proof has located the first connection with a, = jx *-pal| in the above example, and is now considering the second one. still v\ith a single copy of ILLx in mind. The unification fails since CT; = |x«-bob| is apparently not compatible with CTj. At this point, i.e., when the need arises rather than in advance, the process may consider the possibility of splitting (among other possibilities such as alternate connections or fiirther copies) the way to be explained below.</p><p>Splitting means to consider separable subcases separately. This, in turn, requires the separation (represented by A) to be carried out be/ore processing each subcase, in particular before performing the substitutions on x. Instead of carrying out this separation explicitly, this requirement is encoded in our method as a condition on the relation &lt;, hence also on &lt;1 In this example, this condition reads A &lt; x, where A refers to the particular occurrence of conjunction in the formula. With this notation, the definition of an acceptable substitution can be extended in a straightforward way such that it covers this intended meaning of A &lt; x. (For the awkward technical details, see Section rV,10 in <ref type="bibr" target="#b7">[7]</ref>). Thus, both o-, and o-j would be acceptable in the present context, resulting in the following proof with only a single (explicit or implicit] copy of ILLx:</p><formula xml:id="formula_6">Vx ILLx -WlLpot A fLLbob with A &lt;• x</formula><p>The merits of this sophisticated technique become more visible in more complicated problems, the proofs of which yield more than just one such conditions. This is illustrated in Figures <ref type="figure" target="#fig_3">4</ref> and<ref type="figure" target="#fig_4">5</ref> with an example that (for reasons of space) is artificially elaborated but shows the effect as it may weD occur in complicated theorems.</p><p>Figure <ref type="figure" target="#fig_3">4</ref> shows the four-step proof with the connection method involving no search at all. It leads to three such conditions shown in the figure. On their basis, the substitutions determined by the depicted connections, in fact, become acceptable. Even without the formal definition at hand, this can be verified by the reader on the basis of the intended interpretation of these conditions as splittings. Here we have two splits, namely, one on A, and one on A^, The conditions imply that the latter has to precede the former since the condition A: &lt; x together uith x &lt; A, (given by the formula structure) implies A.. O Aj. which expresses exactly that precedence. Performing these splits in that sequence leads to four separate subproblems each of which can be proved immediately (an easy exercise which is left to the reader). But note the essential fX)int thai the method itself does nol carry out any such splits since the test for cycles (present in unification anyway as explained in Section 3), now incorporating the extended relation &lt;, takes care of that in a very efficient way.</p><p>For comparison. Figure <ref type="figure" target="#fig_4">5</ref> shows an optimal eight-step proof with resolution for the same formula. For resolution fans, it is a healthy exercise to attempt it by hand before looking at the picture since in relation to the small size of the problem il involves considerable search. The comparison is fair since, for resolution, further splitting is excluded if a slight change is made in the example which, in contrast, has no effect on the connection method: Remember the proof rule introduced for the connection method in Section 3. Here, and in Section 4, we have seen that each step not only adds a connection, i\', to formula A but possihly also extends the relation &lt; to &lt;' which initially is empty. Hence, its complete form is (A, W, &lt;-} I-(A, W U |iv(, &lt;•'), where A never changes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">NATURAL DEDUCTION PROOFS</head><p>The resulls reported in this paper were inspired by a thorough study of natural deduction proofs <ref type="bibr" target="#b12">[12]</ref>. It is not surprising, then, that the connection proofs we describe are closely related to natural deduction proofs which may even be printed out immediately once the connection proof has been achieved. In this transformation, the relation &lt; provides the sequence of the deduction steps, and the connections encode both the instantiated terms (via unification) and the property qualifying the formulas at the leaves of the deduction tree as logical axioms. This is illustrated in Figure <ref type="figure" target="#fig_5">6</ref> with the natural deduction proof corresponding to the (second) connection proof for the first example of the previous section. Note that the A splitting is performed prior to the instantiation of the terms pat and bob for x due to the information given by A &lt; X which reveals the proper nature of this relation, (For the natural deduction proof obtained from the proof in Figure <ref type="figure" target="#fig_1">2</ref>, see Figure <ref type="figure" target="#fig_2">3</ref> in <ref type="bibr" target="#b5">[5]</ref>,) In Section 2. we already pointed oul the close relation between the connection method and resolution (or its refine- ments) which was studied in detail <ref type="bibr" target="#b4">[4]</ref>, Here, we now see its clasp roliilion with natural doduction proofs. This justifius regarding the connection method as a higher level proof nu'thod; il provides a dcepor insight inlo the characteristic features of theorems (versus fornuiliis) thiin do Iho resolution or the natural deduction proof method.</p><p>8. SUMMARY In this paper, wo have given an overview of a proof method for theorems in first-order logic called the connection melhod. With a number of examples, we have illustrated a number of its prominent features. These and further ones are now summarized.</p><p>A number of them were also obtained by Andrews in an independent approach with mndngs, (See <ref type="bibr" target="#b1">[1]</ref><ref type="bibr" target="#b2">[2]</ref> and their references.) This paper has clarified this relationship.</p><p>Due to its intended nature, this paper has not provided any technical details such as precise; definitions, theorems, proofs or other justifications, and algorithms. For these details, the interested reader is referred to the references mentioned before or to the comprehensive treatment given in <ref type="bibr" target="#b7">[7]</ref>,</p><p>Acknowledgments.</p><p>I thank Peter Haddaway, Alex Kumjian, Bernard Meltzer, and the referee for numerous valuable suggestions for improving this text.</p><p>(i) It may be regarded as a higher level proof method providing deeper insight into the characteristic features of theorems (versus formulas) than do conventional proof methods (see <ref type="bibr">Section 7)</ref>.</p><p>(ji) It operates exclusively on a single copy of the given formula (see Sections 3 and 5. and the proof rule at the end of Section 6).</p><p>(iii) In particular, no transformation into any normal form of the given formula is required which allows the use of any standard logical connectives and the speeding up of search by antiprenexing (see Section 2, and <ref type="bibr" target="#b7">[7]</ref>, p, 209).</p><p>(iv) Not even Skoiem functions need be introduced, i,e,, only the terms in the original formula need be unified (see Section 4).</p><p>(v) Unification is generalized to include an optimal splitting by need (see Section 6), (vi) Amplification is accomplished by a systematic indexing without violating feature (ii) (see Section 5),</p><p>[vii] A connection proof can easily be transformed into a natural, thus immediately comprehensible deduction of the given formula (see Section 7),</p><p>[viii) Special handling of equality and other algebraic relations (extensively studied under the key word "rewrite rules") smoothly fits into the connection method, since from its perspective such specialized rules simply encode a deterministic control for locating connections, possibly a whole scheme of connections within one step (see Sections V,3 and 4 in <ref type="bibr" target="#b7">[7]</ref>), (ix) Induction may appropriately be incorporated following the standard-or a new, in fact promising-line (see Section V,5 in <ref type="bibr" target="#b7">[7]</ref>); the generalization of the method to higher-order logic (or type theory] is similarly straightforward (see Section V,6 in <ref type="bibr" target="#b7">[7]</ref>); the same may be expected for other extensions of FOL such as modal logic.</p><p>(x) Tbe location of connections in a given formula structure has a potential of being realized on the chip level.</p><p>All these features have been developed by the author in a number of technical papers, (See <ref type="bibr" target="#b3">[3]</ref><ref type="bibr" target="#b4">[4]</ref><ref type="bibr" target="#b5">[5]</ref><ref type="bibr" target="#b6">[6]</ref> and their references.)</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>FIGURE 1 .</head><label>1</label><figDesc>FIGURE 1. The Resolution Proof for F.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>FIGURE 2 ,</head><label>2</label><figDesc>FIGURE 2, An Example of Amplification.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>FIGURE 3 .</head><label>3</label><figDesc>FIGURE 3. An Example of a Connection Scheme.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>FIGURE 4 .</head><label>4</label><figDesc>FIGURE 4. A Theorem and its Proof with the Connection Method.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>FIGURE 5 .</head><label>5</label><figDesc>FIGURE 5. The Resolution Derivation of the Theorem in Figure 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>FIGURE 6 .</head><label>6</label><figDesc>FIGURE 6. The Natural Deduction Proof Obtained from the Connection Proof Vx ILLx -• ILLpat A ILLbob, A &lt; x.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>'^ich clause, one obtains a good illustration for what is called a pttlh iJirough the matrix. Doing this with our matrix, also denoted by F, only tho first clause gives us a choice of whothnr to visit thu top or the bottom literal. Hence, there are exactly two paths througli F</figDesc><table><row><cell>literal iu IIMANx, -iMANsocrates, MTLsocrates!</cell><cell></cell></row><row><cell>and</cell><cell></cell></row><row><cell>jnMTLx, nMANsocrates, MTLsocratesj</cell><cell></cell></row><row><cell>-iMTLx</cell><cell>hMANsocratesllMTLsocratesi</cell></row><row><cell cols="2">Without a quantifier, 3x, this structure is called a matrix in</cell></row><row><cell cols="2">normal form which, by definition, is a set of sets of JiteraJs or</cell></row><row><cell cols="2">shortly a set of clauses. In this particular example, we have a</cell></row><row><cell cols="2">set of three clauses listed from left to right, the literals in each</cell></row><row><cell cols="2">clause listed top-down. If one crosses such a matrix in two-</cell></row><row><cell cols="2">dimensional format from left to right, visiting exactly one</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Communicotions of the ACMNovember JSft:) Volume 26 Number II</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>Communicaljons of the ACM November 1083 VOIUTTIO 26 .Vumber M</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>Communicalions of the ACM</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>Research Contrfb</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>/TK)NS 3x(3yPayx A, 3zPbzx) REFERENCES</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Theorem proving via general matings</title>
		<author>
			<persName><forename type="first">P</forename><surname>Andrews</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="193" to="214" />
			<date>April 19B1</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Transforming matings into natural deduction proofs</title>
		<author>
			<persName><forename type="first">P</forename><surname>Andrews</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc 5(h Conf. on Aulom. Deduction, LN in Comp. Sci, 87</title>
		<editor>
			<persName><surname>Vv</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Bibel</surname></persName>
		</editor>
		<editor>
			<persName><surname>Kowalski</surname></persName>
		</editor>
		<meeting>5(h Conf. on Aulom. Deduction, LN in Comp. Sci, 87<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1980">1980</date>
			<biblScope unit="page" from="281" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">On matrices wilh connections</title>
		<author>
			<persName><surname>Bibel</surname></persName>
		</author>
		<author>
			<persName><surname>Vv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="633" to="645" />
			<date type="published" when="1981-10">October 1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A comparative study of several proof procedures</title>
		<author>
			<persName><forename type="first">W</forename><surname>Bibel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Arlif. Inlell</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="269" to="293" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The complete theoretical basis for the systematic proof method, Bericht ATP-6-.\ll-80</title>
		<author>
			<persName><surname>Bibel</surname></persName>
		</author>
		<author>
			<persName><surname>Vv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TUM</title>
		<imprint>
			<date type="published" when="1980">1980</date>
			<publisher>ACM</publisher>
		</imprint>
		<respStmt>
			<orgName>Institut fur Informatik</orgName>
		</respStmt>
	</monogr>
	<note>Submitted to |</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Computationally improved versions of Herbrand&apos;s theorem</title>
		<author>
			<persName><forename type="middle">W</forename><surname>Bibel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc, of the Herbrond Colloquium. North Holland, Amsterdam</title>
		<meeting>of the Herbrond Colloquium. North Holland, Amsterdam</meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="11" to="28" />
		</imprint>
	</monogr>
	<note>Stern</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Automated theorem proving</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">V</forename><surname>Bibel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1982">1982</date>
			<publisher>Vieweg</publisher>
			<pubPlace>Braunschweig</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">VV, Syntax-directed, semantics-supported program synthesis, Artif. (ntell&quot; 14</title>
		<author>
			<persName><surname>Bibel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1980">1980</date>
			<biblScope unit="page" from="243" to="261" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">V</forename><surname>Bibel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kowalski</surname></persName>
		</author>
		<title level="m">Conference on Automated Deduction, LN in Comp</title>
		<meeting><address><addrLine>Sc, 67 Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1980">1980</date>
			<biblScope unit="volume">5</biblScope>
		</imprint>
	</monogr>
	<note>h</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Non-resolution theorem proving</title>
		<author>
			<persName><forename type="middle">W W</forename><surname>Bledsoe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Arlif. InteJI</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="1" to="35" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Symbolic logic and mechanical theorem proving</title>
		<author>
			<persName><forename type="first">C -L</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">-T</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1973">1973</date>
			<publisher>Academic Press</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Untersuchunge uber das logische Schlietien I. Mothemal</title>
		<author>
			<persName><forename type="first">G</forename><surname>Centzen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Zeilschnff</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="176" to="210" />
			<date type="published" when="1935">1935</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Recherches sur la Theorie de la Demonstration</title>
		<author>
			<persName><forename type="first">|</forename><surname>Herbrand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Traveaux de la Societe des Sciences et des Lettres de Varsovie. Classe ill sciences mathematiques et physiques</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<date type="published" when="1930">1930</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m">ed,) 4th Workshop on Automated Deduction</title>
		<editor>
			<persName><forename type="first">(</forename><forename type="middle">W</forename><surname>Loyner</surname></persName>
		</editor>
		<meeting><address><addrLine>Austin, Texas</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title/>
		<author>
			<persName><forename type="middle">D</forename><surname>Kalish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Montague</surname></persName>
		</author>
		<author>
			<persName><surname>Logic</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1964">1964</date>
			<publisher>Harcourt Brace |ova-novich</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">D</forename><surname>Loveland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Automoled</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1978">1978</date>
			<publisher>North Holland</publisher>
			<pubPlace>Amsterdam</pubPlace>
		</imprint>
	</monogr>
	<note>heorem proving</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<author>
			<persName><forename type="first">D</forename><surname>Loveland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">6th Conference on Automated Deduction</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page">138</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Principles of artificial intelligence</title>
		<author>
			<persName><forename type="first">N</forename><surname>Nilsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">|</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1980">1980</date>
			<publisher>Tioga</publisher>
			<pubPlace>Palo Alto</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Logic: torm and function</title>
		<author>
			<persName><forename type="first">Robinson</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1979</date>
			<publisher>Edinburgh University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Informatik Facbberichte</title>
		<editor>
			<persName><forename type="first">)</forename><surname>Siekmann</surname></persName>
		</editor>
		<editor>
			<persName><surname>Gvvat-81</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<date type="published" when="1981">1981</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">CR Calegories and Subject Descriptors: F 4 1 [Mathemalical Logic and Formal Languages|: Mathematical Logic-mechanrcol (heorem proving, logic programming; 1,2,3 lArlificial Inlelligence]: Deduction and Theorem Proving-deducllon. resolution, iogic progromming: 1,2.4 [Artificial Intelligence): Knowledge Representation Formalisms and Methodspredicate logic General Terms: Theory, Algorithms Additional Key Words and Phrases: logic, theorem proving, connection method, matings, resolution, unification, splitting, natural deduction, systematic proof procedure, complementary matrices, spanning sets of connections</title>
		<author>
			<persName><forename type="middle">L</forename><surname>Wos</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Solving open questions with an automated theorem-proving program. structure sharing, refinements of resolution</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
