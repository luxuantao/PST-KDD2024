<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Discriminatively Trained Particle Filters for Complex Multi-Object Tracking</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Rob</forename><surname>Hess</surname></persName>
							<email>hess@eecs.oregonstate.edu</email>
							<affiliation key="aff0">
								<orgName type="department">School of EECS</orgName>
								<orgName type="institution">Oregon State University</orgName>
								<address>
									<postCode>97331</postCode>
									<settlement>Corvallis</settlement>
									<region>OR</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alan</forename><surname>Fern</surname></persName>
							<email>afern@eecs.oregonstate.edu</email>
							<affiliation key="aff0">
								<orgName type="department">School of EECS</orgName>
								<orgName type="institution">Oregon State University</orgName>
								<address>
									<postCode>97331</postCode>
									<settlement>Corvallis</settlement>
									<region>OR</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Discriminatively Trained Particle Filters for Complex Multi-Object Tracking</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">03C69C4D6EFF56F6925A1E92B94AC3D9</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:00+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This work presents a discriminative training method for particle filters in the context of multi-object tracking. We are motivated by the difficulty of hand-tuning the many model parameters for such applications and also by results in many application domains indicating that discriminative training is often superior to generative training methods. Our learning approach is tightly integrated into the actual inference process of the filter and attempts to directly optimize the filter parameters in response to observed errors. We present experimental results in the challenging domain of American football where our filter is trained to track all 22 players throughout football plays. The training method is shown to significantly improve performance of the tracker and to significantly outperform two recent particle-based multi-object tracking methods.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Particle filtering is a widely used framework for visual object tracking that is highly extensible and offers the flexibility to handle non-linearity and non-normality in the object models. In recent years, many new particle filter-based approaches have been proposed to solve difficult multiobject tracking problems <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b18">19]</ref>. However, most of this work has paid little attention to how to best tune the parameters of the proposed models and has instead relied on some combination of manual tuning and simple generative learning to set these parameters. These approaches, though, are often ineffective and/or extremely labor intensive.</p><p>In this work, we describe a conceptually simple particle filtering framework for multi-object tracking (Section 3). This framework is easy to extend and customize because it allows the user to define rich sets of features to capture essential properties of the tracking domain. Our main contribution is an error-driven, discriminative algorithm for training this model's (Section 4). Our training is tightly integrated into the filtering process and attempts to optimize parameters in response to observed tracking errors. In addition, we describe an important practical approximation to this algorithm (Section 5) that can significantly reduce training time for domains where many objects must be tracked.</p><p>Our decision to use a discriminative approach is motivated by several factors. First, there is a growing body of empirical evidence from a number of fields <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b19">20]</ref> along with theoretical results <ref type="bibr" target="#b11">[12]</ref> suggesting that discriminative training outperforms generative training when enough data is available. Second, unlike generative training methods, our discriminative approach does not make strong independence assumptions about the features, which would ignore important dependencies. Third, our discriminative approach is aimed at directly solving the problem we really care about: maximizing the accuracy of the learned filter. In contrast, generative training attempts to achieve this objective indirectly by maximizing the joint likelihood of the training data, which does not always relate well to filtering accuracy when the assumed model is wrong.</p><p>We apply our approach to tracking the 22 players and one referee in low-resolution American football video (Section 6). This problem is extremely challenging due to the erratic movement of players, the complexity of interactions that sometimes involve upwards of five or ten players, and the strong dependence of player behavior on the player's type and the stage of the play. To date, there has been very limited success in tracking for American football, and our experiments show that some state-of-the-art multi-object tracking methods do not work well in this domain. In comparison, we show that filters trained using our method substantially outperform untrained filters and these other methods and, to the best of our knowledge, represent the stateof-the-art in tracking in the American football domain.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Related Work</head><p>Here we discuss related work on particle filter-based multi-object tracking and discriminative filter training.</p><p>Particle Filter-Based Multi-Object Tracking: Since particle filter-based visual object tracking was first proposed, much progress has been made on tracking single objects using particle filters. Tracking multiple objects, however, poses the challenge of dealing with the highdimensionality of the state space, which grows with the 1 240 978-1-4244-3991-1/09/$25.00 Â©2009 IEEE number of objects. A naive solution is to use an independent single-object particle filter for each object, but this can break down when similar objects interact, leading to objects "hijacking" filters from other objects. Some notable, but far from exhaustive, recent attempts to improve upon this naive approach include Okuma et al.'s boosted particle filter <ref type="bibr" target="#b12">[13]</ref>, which attempts to avoid hijacking by using a Haar-style object detector to terminate and resume tracks during and after an interaction; Khan et al.'s MCMC-based particle filter <ref type="bibr" target="#b8">[9]</ref>, which tracks objects in their joint state space and uses a Markov random field (MRF), built at each time step, that helps prevent hijacking by enforcing separation between nearby objects while allowing far apart objects to be tracked independently; and Yu and Wu's mean field Monte Carlo algorithm <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref>, which also uses an MRF to enforce object separation but uses Monte Carlo variational inference.</p><p>While each of the above methods has been shown to outperform the naive approach, there is still much room for further improvement. For example, Okuma et al.'s method does not explicitly reason about object interactions, but rather attempts to improve on the purely naive approach by using more powerful proposal and observation distributions. As such the approach is prone to losing object identities and locations when tracks are terminated. Khan et al.'s method tracks in the objects' joint state space and thus, in our experience, does not scale well when the number of objects is large and more uncertainty exists about objects' locations due, for example, to erratic object motion. Similarly, the joint inference approach employed in Yu and Wu's method suffers from quadratic complexity in the total number of particles used to track all of the objects. For both of these methods, it can be difficult to set the parameters of the interacting MRF model components to maximize accuracy, and they are currently set manually and/or learned generatively.</p><p>Discriminative Filter Training: There has been much recent work on discriminative training of sequential filters. For example, discriminatively trained conditional random fields (CRFs) for sequence data <ref type="bibr" target="#b9">[10]</ref> have been shown to outperform generatively trained hidden Markov models (HMMs) in many domains. Collins has also proposed a generalized perceptron algorithm for sequential data <ref type="bibr" target="#b1">[2]</ref> to train HMMs for natural language problems. This work has been further extended to large-margin discriminative training of HMM-style sequential models <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref>. Unfortunately, all of these methods assume small state spaces where exact, efficient filtering is possible, e.g. via dynamic programming, and hence are not directly applicable to object tracking.</p><p>In more recent work, discriminative training was used to set the noise parameters of continuous state extended Kalman filters (EKFs) for robot localization <ref type="bibr" target="#b0">[1]</ref>. However, it is generally recognized that EKFs are not powerful enough for complex object tracking due to the normality as-sumptions they make. Our work can be seen as extending this approach to a more general class of process models.</p><p>In more closely related work, Limketkai et al. train large state-space CRFs for robot localization using Collins' perceptron algorithm within a particle filtering framework <ref type="bibr" target="#b10">[11]</ref>. As far as we are aware, this is the only prior work to attempt any form of discriminative training of particle filters.</p><p>All of the above discriminative methods can be viewed as driving the learning process by iteratively using the current filter to perform inference on a set of training sequences and then updating parameters based on some measure of the disparity between the filter's output and the desired output. For example, Limketkai et al.'s approach computes a MAP state sequence for each training example using the current filter and then attempts to adjust filter parameters so that the ground truth sequences become more probable than the current MAP sequences. However because filters sometimes fail badly, often early in training, the filter parameter updates these approaches make can be dominated by the portion of the sequence that occurs after the failure rather than focused on correcting the original point of failure. Our experience in multi-agent tracking suggests that such parameter updates can be counterproductive.</p><p>To address this issue, the perceptron algorithm has been extended to focus training directly on points of filter failure. For example, recent work has proposed performing updates based only on the part of the predicted sequence up to and including the first failure <ref type="bibr" target="#b2">[3]</ref>. Later work has extended this idea by updating at successive points of failure <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b16">17]</ref>. The learning approach we describe in Section 4 can be viewed as extending these failure-driven approaches to the particle filtering framework.</p><p>Finally, we note that there has been work that uses discriminative learning to produce certain individual components of particle filters, for example by learning objectdetection classifiers to be included as part of the particle filter's proposal distribution <ref type="bibr" target="#b12">[13]</ref>. However, such indirect learning approaches never take into account the actual filter performance and hence offer no guidance to improve the filter further after the original components have been learned. Our approach is complimentary, as such learned components could be included in a filter and the filter then further improved based on actual filtering performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Psuedo-Independent Log-Linear Filters</head><p>Below we first review the standard Bayesian particle filter, and then describe our specific particle filter-based multiobject tracking framework, which uses pseudo-independent filters parameterized by log-linear models.</p><p>Particle Filters: Particle filtering is a Monte Carlo approximation to the optimal Bayesian filter <ref type="bibr" target="#b5">[6]</ref>, which monitors the posterior probability of a first-order Markov process through the following formula:</p><formula xml:id="formula_0">p(xt|y1:t) = Î±p(yt|xt) Z x t-1 p(xt|xt-1)p(xt-1|y1:t-1). (1)</formula><p>Here, x t is the process state at time t, y t is the observation, y 1:t is all of the observations through time t, p(x t |x t-1 ) is the process dynamical distribution, p(y t |x t ) is the observation likelihood distribution, and Î± is a normalizing factor.</p><p>The integral in (1) does not have a closed form solution, except in the most basic cases, so particle filters are used to approximate (1) using a set of weighted samples {x</p><formula xml:id="formula_1">(i) t , Ï (i) t } i=1,...,n , where each x (i)</formula><p>t is an instantiation of the process state, known as a particle, and the Ï (i) t 's are the corresponding particle weights. Under this representation, the approximation to the Bayesian filtering equation ( <ref type="formula">1</ref>) is</p><formula xml:id="formula_2">p(xt|y1:t) â Î± p(yt|xt) n X i=1 Ï (i) t-1 p(x (i) t |x (i) t-1 ).<label>(2)</label></formula><p>To implement a standard particle filter, one must choose a state representation x t , which, in the case of object tracking might include object locations, scales, etc. In addition, one must design three distributions: the process dynamical distribution, p(x <ref type="formula">1</ref>), which, in object tracking, describes how objects move between time steps; the proposal distribution, q(x</p><formula xml:id="formula_3">(i) t |x (i) t-</formula><formula xml:id="formula_4">(i) t |x (i) 0:t-1 , y 1:t ),</formula><p>which is sampled at each time step to update the particle distribution; and the observation likelihood distribution, p(y t |x (i) t ), which, in tracking, describes how objects appear within the video data, y t .</p><p>At each time step, given the previous particle set {x</p><formula xml:id="formula_5">(i) t-1 , Ï (i)</formula><p>t-1 }, a basic sequential importance resampling <ref type="bibr" target="#b5">[6]</ref> particle filter updates the particles as follows:</p><p>1. Sample n particles x (i) t-1 with replacement from current particle set according to probabilities Ï</p><formula xml:id="formula_6">(i) t-1 .</formula><p>2. Generate an updated particle set by sampling from the proposal distribution,</p><formula xml:id="formula_7">x (i) t â¼ q(x (i) t |x (i) 0:t-1</formula><p>, y 1:t ). 3. Reweight each particle according to the following formula and normalize so that the Ï</p><formula xml:id="formula_8">(i)</formula><p>t sum to 1:</p><formula xml:id="formula_9">Ï (i) t â p(yt|x (i) t )p(x (i) t |x (i) t-1 ) q(x (i) t |x (i) 0:t-1 , y1:t) . (<label>3</label></formula><formula xml:id="formula_10">)</formula><p>In tracking and and many other applications, it is typical to estimate the process state at each time step as the sample mean of the particles</p><formula xml:id="formula_11">Ã[x t ] = n i=1 Ï (i) t x (i)</formula><p>t . Pseudo-Independent Filters: When multiple interacting objects must be tracked, the joint state space of those objects is high dimensional and renders the straightforward application of particle filtering impractical. As discussed in Section 2, extensions to the basic particle filtering framework have been explored that utilize more complex MRF dynamic models to capture important object interactions in a more tractable way. In contrast to those methods, we use a simple particle filtering framework for multi-object tracking. Specifically, we assign each object of interest its own single-object particle filter. These filters are not completely independent, however, but are pseudo-independent, in the sense that each tracker estimates only a single object's state but has the previous state estimates of other trackers available as observations to use during inference.</p><p>Unlike the more sophisticated MRF approaches, our pseudo-independent approach does not increase the computational complexity of filtering over that of purely independent filters, but it still allows some amount of dependency between trackers through observations of one another's internal states from previous time steps. While the pseudoindependent approach is more restricted in the types of dependencies it can represent, we believe that it will be sufficient for many applications because the log-linear filtering framework described below enables straightforward representation of rich features of both individual objects and relations among objects, which the pseudo-independent filtering approach can exploit for improved performance.</p><p>Log-Linear Filters: To allow for maximum flexibility, we wish to allow the designer to devise arbitrary features that can capture joint properties of a tracked object's state, its observations, and the previous state estimates of other objects and to incorporate these features into the individual filters. For example, by including features that measure the distance between an object's proposed state and the predicted locations of other objects, it is possible to bias the filter against allowing two objects occupying the same space.</p><p>While in principle one can attempt to define the dynamic and observation distributions in terms of such features, doing so is quite difficult in practice. In particular, one must decide how to weight the potentially many features against one another and/or make the assumption that features are independent in order to support traditional generative learning. In this work, we instead utilize a more flexible combination of features based on log-linear modeling.</p><p>From an algorithmic perspective, the main difference between our particle filtering framework and the traditional framework is in the way we compute particle weights. The traditional reweighting computation in equation ( <ref type="formula" target="#formula_9">3</ref>) is the result of trying to account for dynamics, observations, and proposal bias all at once by combining their associated generative model terms. In contrast, we attempt to learn a single reweighting function defined in terms of arbitrary features, which can encompass all of those terms but is not restricted to the specific form of equation <ref type="bibr" target="#b2">(3)</ref>.</p><p>In particular, our particle weighting function takes the form of a log-linear combination of weighted features:</p><formula xml:id="formula_12">Ï (i) t â exp j w j f j (y t , x (i) t ) . (<label>4</label></formula><formula xml:id="formula_13">)</formula><p>Here the f j (â¢)'s are user-defined feature functions and the w j 's are the weights of the features, which parameterize the model. By including features that correspond to the logarithms of the process dynamics, observation likelihood, and proposal distribution terms in equation ( <ref type="formula" target="#formula_9">3</ref>), the log-linear model can be made strictly more expressive than the traditional formulation. Note that, for our pseudo-independent filters, each y t contains traditional observation data as well as information about the previous states of other filters to allow the features to model interactions between objects. In Section 6, we describe a number of feature functions for multi-object tracking in the American football domain.</p><p>There are two ways to view this log-linear filtering model. From an algorithmic perspective, it can be seen as a more flexible parameterization of the standard particle filtering algorithm. From a modeling perspective, it can be viewed as an undirected, log-linear probabilistic model over sequences-as in the work on CRF-filters <ref type="bibr" target="#b10">[11]</ref>-for which a particle filtering inference procedure based on nonparametric belief propagation can be derived. In either case, the ultimate goal is to learn feature weights that optimize filter performance as described next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Error-Driven Discriminative Filter Training</head><p>We take a supervised approach to training our individual log-linear particle filters. The training set contains examples of the form (x * 0:T , y 1:T ), where y 1:T is an observation sequence, for example, a video of a football play, and x * 0:T is the ground-truth or target state sequence, for example, the trajectory of a particular player in the football play. The goal is to optimize the filter weights so that the filter output is as close to the target state sequences as possible.</p><p>The basic training approach iterates through the training examples and, for each one, calls Algorithm 1, which produces updated filter weights that are used as the initial weights for the next call. The iteration continues until a maximum number of steps is reached or performance no longer improves. In practice, we average the weights learned across iterations to arrive at the final weight vector, which is a common technique that has been shown to improve performance of online learning <ref type="bibr" target="#b1">[2]</ref>.</p><p>Algorithm 1 is identical to the log-linear filter of Section 3 with the addition of training mechanisms in lines 6 through 12. Intuitively, each call to this algorithm monitors the filter's performance on the current example and tunes the feature weights each time the filter fails. Specifically, at each time step, a new particle set is proposed and reweighted according to the log-linear model. After particle reweighting, the filter's current state estimate xt is compared to the ground truth state x * t , and, if the distance between the two is above a user-specified threshold Î» u , a weight update is performed (see below). Additionally, if the distance between xt and x * t is greater than a second thresh- Sample new particle set from proposal distribution:</p><formula xml:id="formula_14">x (i) t â¼ q(x (i) t |x (i) 0:t-1 , y1:t) 5:</formula><p>Reweight each particle using current weights: end if 13: end for old Î» r , the filter is reset to the current ground truth state.</p><formula xml:id="formula_15">Ï (i) t â exp " P j wjfj(yt, x (i) t ) " 6: Compute = ||x * t -</formula><p>By updating the feature weights when an error is made during inference and by restarting the filter when a large enough error is made, the filter is allowed to focus its attention on meaningful points of failure, resulting in more purposeful weight updates. In addition, performing successive restarts can be seen as reducing training time by allowing the filter to encounter a variety of errors within a training iteration. If instead the filter is never reset for large errors, which is essentially Limketkai et al.'s approach <ref type="bibr" target="#b10">[11]</ref>, many weight updates would be performed on wildly diverging state estimates due to cascading errors. We have found this approach to work poorly in our tracking domain where filters often diverge badly in earlier training iterations.</p><p>Using the generic error-driven approach described above, we can optimize a number of discriminative objective functions by specifying appropriate weight update equations (line 8), along with the type of state estimate xt to be used (line 6). In what follows, we specify these choices for three different objective functions.</p><p>Perceptron Updates: Collins' perceptron update <ref type="bibr" target="#b1">[2]</ref> can be viewed as an approximation to the gradient of the conditional log-likelihood of the training data log p(x * 0:T |y 1:T ) with respect to the feature weights, and thus, the perceptron algorithm can be thought of as attempting to maximize this probability via approximate gradient ascent.</p><p>The batch perceptron update of Collins can easily be modified into an iterative update for use in our error-driven training approach. The update to weight w j takes the form:</p><formula xml:id="formula_16">w j = w j + Î³ f j (x * t , y t ) -f j (x t , y t ) , (<label>5</label></formula><formula xml:id="formula_17">)</formula><p>where Î³ is the learning rate. In this case, the state estimate xt used by the filter is taken to be the particle with the highest particle weight (i.e. the MAP state estimate). Thus, filters learned with the perceptron update aim at making the filter's MAP state close to ground truth at every time step.</p><p>Minimizing the Squared Residual of Mean: In the case of object tracking, the perceptron update is somewhat unsatisfactory because it places emphasis on the MAP particle instead of on the sample mean Ã[x t ], which is typically used as the state estimate in particle filter-based object tracking and in our experience typically leads to more robust tracking. To remedy this, we can use an error-driven learning instantiation where the sample mean is taken as the state estimate (i.e. xt = Ã[x t ]), and the objective function is to minimize the squared residual of the sample mean</p><formula xml:id="formula_18">|| Ã[x t ] -x * t || 2 .</formula><p>We update the weights upon each error in the gradient direction of this objective, which for weight w j yields the following update:</p><formula xml:id="formula_19">wj = wj + Î³ `Ã[xt] -x * t Â´T `Ã[xtfj(xt, yt)] -Ã[xt] Ã[fj(xt, yt)] Â´. (6)</formula><p>Using this update, w j converges when the state x t is uncorrelated with feature f j (â¢) according the sample distribution. Using this update in our error-driven framework can be viewed as performing stochastic gradient descent on the truncated squared residual, which is set equal to zero when the residual is less than our update threshold Î» u .</p><p>Minimizing Mean Squared Error: The above update has the unfortunate property of ignoring the sample variance var(x t ) of the state x t . In particular, we have</p><formula xml:id="formula_20">|| Ã[x t ] -x * t || 2 = Ã ||x t -x * t || 2 -var(x t ).<label>(7)</label></formula><p>This shows that it is possible to minimize the mean's residual while both the mean squared error (MSE) and the variance take on very large values, which is quite undesirable. For example, in object tracking this would be akin to minimizing the residual to a ground truth location at the center of the video frame by placing an equal number of equally weighted particles at each of the four corners of the frame. Thus, we here consider minimizing the MSE Ã ||x t -x * t || 2 as a potentially more robust objective, which from <ref type="bibr" target="#b6">(7)</ref>, corresponds to minimizing the sum of the mean's squared residual and the sample variance. In tracking, minimizing this objective corresponds to having all of the particles bunched tightly around the ground truth location. Differentiating Ã ||x t -x * t || 2 with respect to w j yields the following gradient descending weight update:</p><formula xml:id="formula_21">wj = wj + Î³ `Ã Ë||xt -x * t || 2 fj(xt, yt) - Ã Ë||xt -x * t || 2 ËÃ [fj(xt, yt)] Â´. (<label>8</label></formula><formula xml:id="formula_22">)</formula><p>This update has the intuitively satisfying property of converging when the MSE is uncorrelated with feature f j (â¢). Again, using this update, our error-driven training process can be viewed as stochastic gradient descent on a truncated version of MSE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Improving Training Computation Time</head><p>Since each iteration of error-driven training involves running the particle filter once for each training example, this approach can become computationally expensive when each run of the particle filter has a non-trivial computational cost. This is particularly true in tracking domains in which a large number of objects must be tracked at once, necessitating many calls to feature functions involving expensive pixel-level operations on sizable regions of the video frame, which form a computational bottleneck.</p><p>In order to overcome the computational burden associated with performing many of these calculations repeatedly, we use an approximate method that operates on strategically drawn state samples with pre-computed values for these features. Specifically, we pre-process each training example (x * 0:T , y 1:T ) by drawing a large set of samples {x (k) t } k=1,...,N normally distributed around each of the ground truth states x * t with large variance and, for each of these samples, pre-computing the values of all features involving expensive pixel-level operations.</p><p>Then, during training, the particle filter is modified by only allowing the proposal distribution to propose states at time t that are represented in {x (k) t } k=1,...,N . This can be implemented by turning the continuous proposal distribution into a discrete distribution in a straightforward way. In this way, during the particle re-weighting step, the available pre-computed feature values are used for all of the particles, while all other features are computed online.</p><p>This approach allows training to proceed significantly faster than when using the full particle filter while still providing a close approximation to the way the full filter performs. Performance may suffer in tracking domains where most errors are made due to background clutter and other factors rather than to hijacking by other objects. However, in such domains, it is possible to use a slightly modified version of this method that generates sample sets during actual runs of the tracker and iteratively augments those sets after they have been used for several iterations of training. We are currently investigating such an approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Experiments and Results</head><p>We test our approach by tracking the 22 players and one referee in low-resolution videos of American football. Each video contains footage of a single football play shot from a panning, tilting, and zooming camera with a sideline view high above the center of the field. Figure <ref type="figure" target="#fig_1">1</ref> depicts a typical view from this camera. Every video is pre-processed to register frames to an overhead model of the football field using the method described in <ref type="bibr" target="#b6">[7]</ref>, thereby enabling us to determine players' locations in football field coordinates.</p><p>The football domain is an extremely challenging testbed for any multi-object tracking algorithm. The players being tracked in this domain move very erratically, and the characteristics of players' motion change substantially depending on the player's type and the time stage of the video. In the first several seconds of each video, for example, nearly all of the players stand virtually still, while perhaps one or two move only gradually. However, after the ball is snapped (a one-time that occurs in every football play), all of the players begin to move very quickly, and the tracker must be able to adapt accordingly. In addition, football players interact in complex ways, frequently in very large groups. For example, in every play, a group of five linemen on the offense stand shoulder to shoulder in a line and attempt to block a group of about three to five defensive players who, in turn, attempt to break through the offensive line. Many other complicated interactions take place between smaller groups of players throughout the course of a play. In what follows, we first describe the filter models and feature functions we use to capture these interactions and other salient aspects of the football domain. We then move on to present the results of our experiments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Football domain modeling</head><p>In the football domain, we represent each player as a rectangular region defined by his location in football field coordinates and the scale of the region (i.e. x = {x, y, s x , s y }). Players' motion is modeled using the second-order autoregressive dynamical model that is common in the tracking literature, in which x t â¼ N (g(x t-1 , x t-2 ), Î£ d ), where N (Î¼, Î£) is the normal distribution with mean Î¼ and covariance Î£,</p><formula xml:id="formula_23">g(x t-1 , x t-2 ) = A 1 x t-1 + A 2 x t-2 ,<label>(9)</label></formula><p>and A 1 and A 2 define a constant acceleration model.</p><p>The proposal distribution we use is slightly nonstandard. Specifically, it takes the form of the process dynamical distribution above but uses the previous sample means in place of the state values x t-1 and x t-2 . In other words, under our proposal distribution,</p><formula xml:id="formula_24">x t â¼ N (g( Ã[x t-1 ], Ã[x t-2 ]), Î£ d )</formula><p>, where g(â¢) is as in <ref type="bibr" target="#b8">(9)</ref>. We have found that this form of proposal distribution works well in practice and is more stable than the motion model.</p><p>We use a variety of feature functions to describe different aspects of players' appearances, their motion, and the interactions between players. In order to model motion patterns that change depending on the time stage of the football play, each feature we describe below is replicated once for each possible time stage. All features that do not correspond to the current time stage take on zero values. In all, each filter uses 15 base features, described below, and 4 time stages for a total of 60 features.</p><p>Player motion features: We use 11 different features to describe player motion. The first of these is the logarithm of the Gaussian probability density value of the player state x t evaluated under the proposal distribution. The second is the negative squared distance between the player's current state and the state estimate from the previous time step, i.e. -||x t -Ã[x t-1 ]|| 2 . Intuitively, these features allow for a trade-off between rewarding a particle for being close to the proposal's prediction and not straying too far from the player's previous location.</p><p>We also use a set of binary features that indicate in which of the eight compass directions a player is moving. These are calculated by quantizing the player's motion vector (x t -Ã[x t-1 ]). These features allow us to model motion tendencies that occur regularly across all football plays. For example, the quarterback nearly always moves backwards immediately after the ball is snapped.</p><p>Appearance features: We use two features to describe players' appearances. The first of these is an RGB histogram-based feature, which is calculated based on the Bhattacharyya coefficient-based histogram distance (as in <ref type="bibr" target="#b13">[14]</ref>) between a reference histogram and the histogram of the region defined by x t . The second appearance feature is based on background modeling and is computed by using a pre-computed background color model to count the number of foreground pixels inside the player region defined by x t to the total area of that region.</p><p>Player interaction features: The final two features describe interactions between players. The first of these is similar to the MRF edge potential used in <ref type="bibr" target="#b8">[9]</ref>, which penalizes overlap between player regions in the video frame. The second is similar to the MRF edge potential used in <ref type="bibr" target="#b17">[18]</ref>, which penalizes proximity between players in state space. Intuitively, these features cause trackers to "repel" one another, thereby helping them to to better cope with interactions between players by avoiding hijacking.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Results</head><p>Our dataset contains 20 videos of different football plays, each around 400 frames long, along with handlabeled ground truth data for every player in every frame 1 .</p><p>We used a four-fold cross validation approach to evaluate our training method on this dataset. Specifically, we divided the entire set into four folds of five videos each and, for each fold, trained trackers on the other three folds over 100 iterations of the method described in Section 5 using each of the weight updates in equations ( <ref type="formula" target="#formula_16">5</ref>), <ref type="bibr" target="#b5">(6)</ref>, and <ref type="bibr" target="#b7">(8)</ref>. To account for the different characteristics of various player types, we learned 13 separate sets of weights, one for each individual player type, with filters for players of the same type sharing the same set of weights in both tracking and learning.</p><p>We evaluated each fold after every 10 training iterations using the full pseudo-independent log-linear filtering model with averaged feature weights for each player type. In addition, we also evaluated each video using Khan et al.'s MCMC-based particle filter <ref type="bibr" target="#b8">[9]</ref> and Yu and Wu's mean field Monte Carlo algorithm <ref type="bibr" target="#b17">[18]</ref>, two state-of-the-art multiobject particle-filter trackers. For all of these methods, player types and initial locations are computed automatically using mixture-of-parts pictorial structures <ref type="bibr" target="#b7">[8]</ref>. We also tried to use the CRF-Filter perceptron algorithm of Limketkai et al. <ref type="bibr" target="#b10">[11]</ref> on our data set and found that it did not converge well in training. We believe that this is due to the non-incremental nature of the updates, which are based in large part on extremely erroneous filtering runs.</p><p>Figures <ref type="figure" target="#fig_3">2</ref> and<ref type="figure" target="#fig_5">3</ref> compare the performance of pseudoindependent log-linear filters trained using the weight updates in equations ( <ref type="formula" target="#formula_16">5</ref>), <ref type="bibr" target="#b5">(6)</ref>, and (8) and of Khan et al.'s and Yu and Wu's methods. Figure <ref type="figure" target="#fig_3">2</ref> depicts the mean squared per-frame pixel error (x t -x * t ) 2 , while Figure <ref type="figure" target="#fig_5">3</ref> depicts the failure rate, which is the proportion of frames in which a player was considered to be lost (i.e. in which the tracker is at least 5 yards in error). Results are given averaged over all players for both the training and testing folds.</p><p>First, these results make it clear that the training algorithm is able to significantly reduce the training error, indicating that the optimization approach is effective. Further, by both error measures, pseudo-independent log-linear filters trained using each of the weight updates achieve substantially better results than untrained pseudo-independent log-linear filters (iteration 0) and the previous state-of-theart methods on the test set. It is especially important to note that the significantly lower lost-player rates attained by our filters indicate that our discriminative error-driven training approach is effective in achieving its goal of improving filter performance by learning to overcome failures. This also suggests that the approximate method described in Section 5 is a valid approximation to the full tracking process. 1 Our entire hand-labeled tracking dataset is available at http://eecs.oregonstate.edu/football/tracking/dataset.</p><p>We also see that the MSE and residual updates perform better than the perceptron updates on this data, with the MSE update having an edge in peak accuracy and the performance of perceptron-trained trackers deteriorating quickly after achieving their peak performance. As is common for incremental learning methods, the error does not monotonically decrease. In practice one would use a validation set to select the best stopping point for training.</p><p>As an additional assessment of tracking performance, we also counted the number of players that were never lost by the tracker during testing. Interestingly, our untrained filters lost every player for at least a very small portion of the video, while Yu and Wu's and Khan et al.'s methods were successful on 174 and 119 players (out of a total of 440), respectively. In comparison, the best performing filters trained with the MSE update, the residual update, and the perceptron update were successful on 280, 264, and 223 players, respectively. Examining these players further, we found the best performing trained filters achieved an average per-frame MSE of 74.0 (MSE update), 76.3 (residual update), and 82.4 (perceptron update), while Yu and Wu's and Khan et al.'s methods respectively achieved average per-frame MSEs of 110.0 and 100.1. These results show that our trained filters can fully track a significantly larger number of players more accurately. In our model 6 pixels corresponds to one yard on the field, indicating that MSE and residual updates achieve an error of approximately 1.5 yards for these players, which, in our experience, is more than enough to infer many types of player behavior.</p><p>Average run times for pseudo-independent log-linear filters, Yu and Wu's method and Khan et al.'s method are summarized in Table <ref type="table" target="#tab_1">1</ref>. We can see that, in addition to improved filter performance, pseudo-independent log-linear filters also offer faster tracking times.  <ref type="bibr" target="#b17">[18]</ref>, and Khan et al.'s method <ref type="bibr" target="#b8">[9]</ref>. These are computed over the entire football dataset on a standard desktop computer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Summary and Future Work</head><p>We have described a framework for multi-object tracking based on pseudo-independent log-linear particle filters. Our main contribution is an error-driven discriminative training algorithm for this model. We gave results in the domain of American football that show the effectiveness of the method in comparison to recently proposed multi-object trackers. To our knowledge, our learned trackers are state-of-the-art in the football domain. In future work, we plan to extend our approach to learn the parameters of more complex MRF-style models to allow for more significant joint inference about object interactions. In addition, we plan to study the theoretical convergence of our error-driven algorithms.    <ref type="formula" target="#formula_16">5</ref>), <ref type="bibr" target="#b5">(6)</ref>, and <ref type="bibr" target="#b7">(8)</ref>. Included for reference are MSE values for Yu and Wu's method <ref type="bibr" target="#b17">[18]</ref> and Khan et al.'s method <ref type="bibr" target="#b8">[9]</ref>.   </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Algorithm 1 1 n</head><label>11</label><figDesc>Error-driven particle filter training Input: (x * 0:T , y1:T ) -Training sequence w -Input feature weight vector Î³ -Learning rate Î»u -Update threshold Î»r -Restart threshold (â¥ Î»u) , i = 1, . . . , n 2: for t = 1 to T do</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: A typical video frame from our dataset.</figDesc><graphic coords="6,72.47,71.96,189.07,126.07" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Mean squared per-frame pixel error at every 10 training iterations, averaged over all players in (a) the testing and (b) the training folds for each of the three weight update equations (5),<ref type="bibr" target="#b5">(6)</ref>, and<ref type="bibr" target="#b7">(8)</ref>. Included for reference are MSE values for Yu and Wu's method<ref type="bibr" target="#b17">[18]</ref> and Khan et al.'s method<ref type="bibr" target="#b8">[9]</ref>.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Failure rate at every 10 training iterations, averaged over all players in (a) the testing folds and (b) the training folds. Failure rate is computed as the proportion of a player's frames in which the player was lost by the tracker.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>xt||, where xt is the current state estimate</figDesc><table><row><cell>7:</cell><cell>if &gt; Î»u then</cell></row><row><cell>8:</cell><cell>Update feature weights w (one of equations 5, 6, or 8)</cell></row><row><cell>9:</cell><cell>end if</cell></row><row><cell>10:</cell><cell>if &gt; Î»r then</cell></row><row><cell>11:</cell><cell>Reset particle filter to ground truth state at time t by</cell></row><row><cell></cell><cell>setting all particle states to x  *  t</cell></row><row><cell>12:</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Average run time in minutes for pseudo-independent log-linear filters, Yu and Wu's method</figDesc><table><row><cell></cell><cell>PILLFs</cell><cell>Yu and Wu</cell><cell>Khan et al.</cell></row><row><cell>Avg. run time</cell><cell>18.30 m</cell><cell>30.55 m</cell><cell>84.50 m</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Acknowledgments</head><p>This work is supported by NSF grant IIS-0546867 and DARPA contract FA8750-05-2-0283. We would like the thank the coaching staff of the Oregon State Football team for use of their video and William Brendel and Jervis Pinto for assistance in constructing the labeled data set.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Discriminative training of Kalman filters</title>
		<author>
			<persName><forename type="first">P</forename><surname>Abbeel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Coates</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Montemerlo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Thrun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Robitics: Science and Systems</title>
		<meeting>Robitics: Science and Systems</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Discriminative training methods for hidden Markov models: Theory and experiments with perceptron algorithms</title>
		<author>
			<persName><forename type="first">M</forename><surname>Collins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EMNLP</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Incremental parsing with the perceptron algorithm</title>
		<author>
			<persName><forename type="first">M</forename><surname>Collins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Roark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Annual Meeting for the Assoc. for Computational Linguistics</title>
		<meeting>Annual Meeting for the Assoc. for Computational Linguistics</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A discriminative model for tree-to-tree translation</title>
		<author>
			<persName><forename type="first">B</forename><surname>Cowan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>KucerovÃ¡</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Collins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EMNLP</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Learning as search optimization: Approximate large margin methods for structured prediction</title>
		<author>
			<persName><forename type="first">H</forename><surname>Daume</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Marcu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Doucet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Freitas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Gordon</surname></persName>
		</author>
		<title level="m">Sequential Monte Carlo Methods in Practice</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Improved video registration using non-distinctive local image features</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hess</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Mixture-of-parts pictorial structures for objects with variable part sets</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hess</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fern</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Mortensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICCV</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">MCMC-based particle filtering for tracking a variable number of interacting targets</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Balch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Dellaert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PAMI</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1805" to="1819" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Conditional random fields: Probabilistic models for segmenting and labeling sequence data</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Lafferty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mccallum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">C N</forename><surname>Pereira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">CRF-filters: Discriminative particle filters for sequential state estimation</title>
		<author>
			<persName><forename type="first">B</forename><surname>Limketkai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Fox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Liao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICRA</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">On discriminative vs. generative classifiers: A comparison of logistic regression and naive bayes</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jordan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A boosted particle filter: multitarget detection and tracking</title>
		<author>
			<persName><forename type="first">K</forename><surname>Okuma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Taleghani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>De Freitas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Little</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">G</forename><surname>Lowe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECCV</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Color-based probabilistic tracking</title>
		<author>
			<persName><forename type="first">P</forename><surname>PÃ©rez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vermaak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ganget</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECCV</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Max-margin Markov networks</title>
		<author>
			<persName><forename type="first">B</forename><surname>Taskar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Guestrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Koller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Support vector machine learning for interdependent and structured output spaces</title>
		<author>
			<persName><forename type="first">I</forename><surname>Tsochantaridis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Hofmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Joachims</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Altun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">On learning linear ranking functions for beam search</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Collaborative tracking of multiple targets</title>
		<author>
			<persName><forename type="first">T</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Decentralized multiple target tracking using netted collaborative autonomous trackers</title>
		<author>
			<persName><forename type="first">T</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Online learning of relaxed CCG grammars for parsing to logical form</title>
		<author>
			<persName><forename type="first">L</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Collins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EMNLP/CoNLL</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
