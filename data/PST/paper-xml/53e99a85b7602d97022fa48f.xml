<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A hybrid genetic heuristic for scheduling parallel batch processing machines with arbitrary job sizes</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2006-08-17">17 August 2006</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ali</forename><forename type="middle">Husseinzadeh</forename><surname>Kashan</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Industrial Engineering</orgName>
								<orgName type="institution">Amirkabir University of Technology</orgName>
								<address>
									<addrLine>424 Hafez Ave</addrLine>
									<postCode>15916-34311</postCode>
									<settlement>Tehran</settlement>
									<country key="IR">Iran</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Behrooz</forename><surname>Karimi</surname></persName>
							<email>b.karimi@aut.ac.ir</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Industrial Engineering</orgName>
								<orgName type="institution">Amirkabir University of Technology</orgName>
								<address>
									<addrLine>424 Hafez Ave</addrLine>
									<postCode>15916-34311</postCode>
									<settlement>Tehran</settlement>
									<country key="IR">Iran</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Masoud</forename><surname>Jenabi</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Industrial Engineering</orgName>
								<orgName type="institution">Amirkabir University of Technology</orgName>
								<address>
									<addrLine>424 Hafez Ave</addrLine>
									<postCode>15916-34311</postCode>
									<settlement>Tehran</settlement>
									<country key="IR">Iran</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A hybrid genetic heuristic for scheduling parallel batch processing machines with arbitrary job sizes</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2006-08-17">17 August 2006</date>
						</imprint>
					</monogr>
					<idno type="MD5">EC7108808EF9F378A6A4FD7F62211962</idno>
					<idno type="DOI">10.1016/j.cor.2006.07.005</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:49+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Scheduling</term>
					<term>Parallel batch processing machines</term>
					<term>Genetic algorithm</term>
					<term>Simulated annealing</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper investigates the scheduling problem of parallel identical batch processing machines in which each machine can process a group of jobs simultaneously as a batch. Each job is characterized by its size and processing time. The processing time of a batch is given by the longest processing time among all jobs in the batch. Based on developing heuristic approaches, we proposed a hybrid genetic heuristic (HGH) to minimize makespan objective. To verify the performance of our algorithm, comparisons are made through using a simulated annealing (SA) approach addressed in the literature as a comparator algorithm. Computational experiments reveal that affording the knowledge of problem through using heuristic procedures, gives HGH the ability of finding optimal or near optimal solutions in a reasonable time.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>This paper addresses the problem of scheduling n jobs on m identical parallel batch processing machines. A batch processing machine is capable to accommodate a group of jobs simultaneously. Once processing of a batch is initiated, it cannot be interrupted and other jobs cannot be introduced into the machine until processing is completed. With each job i we shall associate an arbitrary size s i and an arbitrary processing time p i . Each batch processing machine has a capacity B, so the sum of job sizes in each batch must be less than or equal to B. We assume that no job has a size exceeding the machine capacity and it cannot be split across batches.</p><p>This research is motivated by burn-in operation in semiconductor manufacturing <ref type="bibr" target="#b0">[1]</ref>. The purpose of burn-in operation is to test the integrated circuits by subjecting them to thermal stress for an extended period. The burn-in oven has a limited capacity and sub-grouping the boards holding the circuits in to batches would be inevitable. So, using all or as much available space in the processor maximizes efficiency. The processing times of burn-in operations are generally longer compared to those of other testing operations, so the burn-in operations constitute a bottleneck in the final testing operation and optimal scheduling of the burn-in operations is of great concern in productivity and on-time delivery management.</p><p>In scheduling problems, makespan (C max ) is equivalent to the completion time of the last job leaving the system. The small C max usually implies a high utilization. The utilization for bottleneck station is closely related to throughput rate of the system. Therefore, reducing the C max should also lead to a higher throughput rate. This concern led us to consider the makespan performance measure as the scheduling objective.</p><p>The structure of the paper is as follows. In Section 2, we review related works on scheduling models of batch processing machines. Section 3 examines the combinatorial complexity of the problem under the considered assumptions. Sections 4 and 5, respectively, deal with the proposed lower bound and a heuristic approach developed for the problem. The proposed hybrid genetic heuristic (HGH) and its implementation is presented in Section 6. Section 7 deals with the effectiveness of the HGH compared to the SA comparator algorithm. The paper will be concluded in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Previous related works</head><p>Problems related to scheduling batch processing machines, in which machine has the ability of processing a number of jobs simultaneously, have been examined extensively by many researchers in recent years. Ikura and Gimple <ref type="bibr" target="#b1">[2]</ref> probably are the first who addressed scheduling with batch processors. Given identical job processing times, they proposed an O(n 2 ) algorithm for the problem of determining whether a schedule exists in which all the due dates can be met, when release times and due dates are agreeable. Lee et al. <ref type="bibr" target="#b0">[1]</ref> considered minimizing maximum lateness, L max , and number of tardy jobs, U i , under the same assumptions. Li and Lee <ref type="bibr" target="#b2">[3]</ref> showed that these problems are both strongly NP-hard, if release times and due dates are not agreeable.</p><p>There are number of researches concerned with scheduling burn-in ovens in semiconductor manufacturing industry. In such these operations, the batch processing time depends to batch content and is given by the processing time of the longest job in the batch. Lee et al. <ref type="bibr" target="#b0">[1]</ref>, the first researchers who popularized scheduling burn-in operations, gave efficient algorithms for minimizing L max and U i , assuming agreeable processing times and due dates. Brucker et al. <ref type="bibr" target="#b3">[4]</ref> gave several exact algorithms and complexity results for the case of infinite machine capacity. For the limited case, they proved that due date-based scheduling criteria give rise to NP-hard problems and provided an O(n B(B-1) ) exact algorithm for minimizing C i . Chandru et al. <ref type="bibr" target="#b4">[5]</ref> provided heuristics and a branch-and-bound method for minimizing C i that can be implemented for solving problems with up to 35 jobs. Adding some new elimination rules, Dupont and Jolai Ghazvini <ref type="bibr" target="#b5">[6]</ref> made their method useful for the problems with up to 100 jobs. Uzsoy and Yang <ref type="bibr" target="#b6">[7]</ref> studied the problem of minimizing total weighted completion time, w i C i , and provided some heuristics and a branch-andbound algorithm. Lee and Uzsoy <ref type="bibr" target="#b7">[8]</ref> studied the problem of minimizing C max in the presence of dynamic job arrivals. Scheduling a single batch processing machine where boards are also considered as a secondary resource constraint has been considered by Kempf et al. <ref type="bibr" target="#b8">[9]</ref>.</p><p>Scheduling batching machines with incompatible job families, i.e. when the processing times of all jobs in the same family are equal and jobs of different families cannot be processed together in the same batch, has been addressed by researchers. Uzsoy <ref type="bibr" target="#b9">[10]</ref> developed efficient algorithms for minimizing L max and w i C i on a single batch processing machine. He also addressed the problems of minimizing C max and L max in the presence of dynamic job arrivals. Mehta and Uzsoy <ref type="bibr" target="#b10">[11]</ref> provided exact and heuristic algorithms for minimizing total tardiness, T i . Dobson and Nambimadom <ref type="bibr" target="#b11">[12]</ref> studied the problem of minimizing w i C i where each job requires a different amount of machine capacity. Jolai <ref type="bibr" target="#b12">[13]</ref> showed that the problem of minimizing number of tardy jobs, U i , is NP-hard. In this paper a dynamic programming algorithm with polynomial time complexity for the fixed number of job families and batch machine capacity is provided.</p><p>Minimizing C i on a batch processing machine with compatible job families has been considered by Chandru et al. <ref type="bibr" target="#b13">[14]</ref>, Hochbaum and Landy <ref type="bibr" target="#b14">[15]</ref> and Brucker et al. <ref type="bibr" target="#b3">[4]</ref>. They have presented dynamic programming algorithms with time complexity order of O(m 3 B m+1 ), O(3 m m 2 ) and O(B 2 2 m m 2 ), respectively.</p><p>Considering jobs with different sizes, Uzsoy <ref type="bibr" target="#b15">[16]</ref> gave complexity results for the C max and C i criteria and provided some heuristics and a branch-and-bound algorithm. Jolai and Dupont <ref type="bibr" target="#b16">[17]</ref> considered C i criterion for the same problem. A branch-and-bound procedure for minimizing the C max was also developed by Dupont and Dhaenens-Flipo <ref type="bibr" target="#b17">[18]</ref>. Considering jobs release times, Shuguang et al. <ref type="bibr" target="#b18">[19]</ref> presented an approximation algorithm with worst-case ratio 2 + for this problem.</p><p>Recently solving the batch machine scheduling problems using metaheuristic algorithms have been considered by researchers. Wang and Uzsoy <ref type="bibr" target="#b19">[20]</ref> coupled a random key-based representation genetic algorithm (GA) with a dynamic programming algorithm to minimize L max on a batch processing machine in the presence of job ready times. Melouk et al. <ref type="bibr" target="#b20">[21]</ref> developed a simulated annealing (SA) approach for minimizing C max to schedule a batch processing machine with different job sizes. Koh et al. <ref type="bibr" target="#b21">[22]</ref> proposed some heuristics and a random key-based representation GA approach for the problems of minimizing C max and w i C i on a batch processing machine with incompatible job families and non-identical job sizes.</p><p>Scheduling with identical parallel batch processing machines, Lee et al. <ref type="bibr" target="#b0">[1]</ref> examined the worst-case error bound of any list-scheduling algorithm for minimizing C max with unit job sizes and extended the use of LPT rule <ref type="bibr" target="#b22">[23]</ref> to the case of parallel batching machines. They also proposed the worst-case error bound of a list-scheduling algorithm for minimizing L max . Balasubramanian et al. <ref type="bibr" target="#b23">[24]</ref> developed two different versions of GA, based on the decomposition approaches for minimizing total weighted tardiness w i T i , with incompatible job families. Also in another paper Monch et al. <ref type="bibr" target="#b24">[25]</ref> extended their solution method to consider the case of unequal job ready times. Koh et al. <ref type="bibr" target="#b25">[26]</ref> proposed a number of heuristics and designed a random key-based GA for the problems of minimizing C max and w i C i , with incompatible job families and non-identical job sizes. Malve and Uzsoy <ref type="bibr" target="#b26">[27]</ref> considered the problem of minimizing L max with dynamic job arrivals and incompatible job families. They proposed a random key-based GA combined with a family of iterative improvement heuristics. Chang et al. <ref type="bibr" target="#b27">[28]</ref> developed a SA approach for minimizing C max to schedule different size jobs. They compared the results of proposed SA with CPLEX optimization software. We use their proposed SA as a comparator algorithm in our computational experiments, since it is a recently published benchmark algorithm based on our problem assumptions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Combinatorial complexity</head><p>Uzsoy <ref type="bibr" target="#b15">[16]</ref> proved that makespan minimization on a batch processing machine with non-identical job sizes and identical processing times is equivalent to a bin-packing problem which is NP-hard in the strong sense. Considering each batch as an individual job, optimal scheduling of parallel machines for minimizing makespan is also NP-hard in the ordinary sense even for two machines. Regarding the cited results the NP-hardness of minimizing makespan under the considered assumptions can be inferred.</p><p>To find out the intractability of the problem, an upper bound on the search space is attainable through using the following relation:</p><formula xml:id="formula_0">n k=l ⎡ ⎣ k-1 b=0 1 k! (-1) b (k -b) n c(k, b) ⎛ ⎝ m i=1 i-1 j =0 1 i! (-1) j (i -j) k c(i, j ) ⎞ ⎠ ⎤ ⎦ ,<label>(1)</label></formula><p>where l = n i=1 s i /B is the minimum number of required batches to group the jobs ( x denotes the smallest integer larger than or equal to x) and c(p, q) is the number of combinations of p taken q at a time.</p><p>The above relation gives the number of all possible schedules by enumerating all the batching plans, considering this point that for each batching plan containing k batches, we should enumerate all the ways of assigning its batches to m machines.</p><p>As can be seen, increasing the problem size, results in exponential growth of the number of possible schedules; therefore obtaining the optimal solution(s) becomes impractical for large-scale problems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">A lower bound on the optimal makespan</head><p>In this section a lower bound on the optimal makespan is proposed. The role of the lower bound is to use it as a reference for evaluating the performance results of our HGH approach and also the performance of SA comparator approach.</p><p>For the case of parallel identical processors with unit capacity, formula (2) gives the minimum makespan when the preemption is allowed <ref type="bibr" target="#b28">[29]</ref>:</p><formula xml:id="formula_1">C p max = max n i=1 p i /m, max i=1,...,n {p i } . (<label>2</label></formula><formula xml:id="formula_2">)</formula><p>The formula states that either the work will be allocated evenly among the machines, or the length of the longest job will determine the makespan.</p><p>If we prohibit job preemption, then the above C p max is a lower bound on the optimal makespan for the scheduling problem with unit capacity parallel machines. Now we propose the following lower bound on the optimal makespan related to our problem: Lower bound BEGIN 1. Put the jobs satisfying following relation in the set J, and remove them from the set of whole jobs and assign each of them to an individual batch,</p><formula xml:id="formula_3">J = q|B -s q &lt; min i∈{1,...,n} {s i } . (<label>3</label></formula><formula xml:id="formula_4">)</formula><p>2. For the reduced problem construct an instance with unit job sizes where each job g is replaced by s g jobs of unit size and processing time p g . List these jobs in decreasing order of their processing time and successively group the B jobs with longest processing times into the same batch. For the current batching plan with l = i / ∈J s i /B number of batches, compute the relation:</p><formula xml:id="formula_5">C S = l k=1 P k + i∈J p i , (<label>4</label></formula><formula xml:id="formula_6">)</formula><p>where P k is the processing time of batch k. 3. The lower bound on the optimal makespan (C LB max ) can be obtained as follows:</p><formula xml:id="formula_7">C LB max = max C S /m , max i=1,...,n {p i } .<label>(5)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>END</head><p>This bound can be further improved by ordering the batches resulted in steps 1 and 2 in decreasing order of their processing time and considering that: C Optimal max P m + P m+1 , where P m is the processing time of the mth batch in the ordering. Then, it is possible to tighten the bound as follows:</p><formula xml:id="formula_8">C LB max = max C S /m , max i=1,...,n {p i }, P m + P m+1 .<label>(6)</label></formula><p>Contrary to the unit capacity counterpart, for the case of parallel batch processing machines, for each feasible batching plan, Eq. ( <ref type="formula" target="#formula_1">2</ref>) can be applied to get the related lower bound, by considering each batch as an individual job. So, there may be many lower bounds with respect to existence of many feasible batching planes. Since C S is a lower limit for the summation of batch processing times, to ensure reaching a true lower bound, we allow the jobs to be split among batches. However to get a more effective bound, splitting the jobs that cannot be grouped with any job in a same batch is not allowed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Proposed heuristic</head><p>Considering the above lower bound, as the problem size increases, it is expected for C LB max to be equal to C S /m . This implies that in the batching phase, a batching plan with smaller summation of batch processing times would probably result in a smaller makespan in scheduling phase. Hence, it can be inferred that grouping jobs with longer processing times in the same batch would be desirable (this follows directly from the optimal solution to the unit size problem).</p><p>For the sake of grouping longer processing time jobs in the same batch, we propose the following heuristic named random batches procedure (RBP), which constructs a feasible batching plan through simultaneously minimizing the residual batch capacity. The RBP heuristic corresponded to the batching phase is as follows: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RBP</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>END IF END</head><p>The effect of the randomness included in the derived batching plan by RBP will be further highlighted by increasing the initial number of batches (L). So starting RBP with small number of batches would be desirable. The above heuristic tries to give a batching plan with smaller summation of batch processing times. To schedule the batches resulted by RBP (scheduling phase), the following step could be added to RBP:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Assign jobs to machines in arbitrary order.</head><p>Arranging batches in any order may cause the schedule to be ineffective, even though the batching is done effectively. Since the longest processing time (LPT) rule guarantees very good result for minimizing makespan on parallel identical machines with unit capacity <ref type="bibr" target="#b22">[23]</ref>, we refine the above step as follows:</p><p>6. List the batches in LPT order (considering each batch as a job) and assign them to machines successively, whenever a machine becomes free.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Proposed HGH and its implementation</head><p>GA are powerful and broadly applicable stochastic search and optimization techniques based on principles of evolution theory. In the past few years, GA have received considerable attention for solving difficult combinatorial optimization problems <ref type="bibr" target="#b29">[30]</ref>.</p><p>We propose a HGH that uses the heuristic approaches to find a superior schedule. The HGH searches the solutions space via generating random batches of jobs using GA operators. For each generated offspring chromosome, the RBP is applied to ensure feasibility, and then for a feasible batching plan the LPT rule is applied to schedule the batches on machines effectively (once a capacity feasible batching plan is achieved, the problem reduces to minimizing C max on parallel identical processors while viewing each batch as a job). To improve effectiveness of HGH, two local search heuristics are developed based on the problem characteristics for both batching and scheduling phases. The following steps describe in detail how the HGH is implemented in this research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Coding</head><p>In HGH, a solution for the problem of assigning jobs to batches is an array whose length is equal to the number of jobs to be scheduled. Each gene represents the batch to which the job is assigned. Fig. <ref type="figure" target="#fig_0">1</ref> shows the chromosome representation of HGH for a batch-scheduling problem with five jobs. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Initial population</head><p>As stated before, the performance of RBP depends on the number of initial batches, where starting RBP with large number of initial batches would be unfavorable. However, starting RBP with small number of initial batches may cause premature convergence to a local optimum. To cope with poor quality of initial seeds and to avoid premature convergence, we use a truncated geometric distribution to generate randomly the number of initial batches used for RBP. Using a geometric distribution to simulate the number of initial batches ensures that the probability of starting RBP with a large number of batches would be small compared to the high probability for starting with small number of batches. The following relation gives the random number of initial batches to start with RBP:</p><formula xml:id="formula_9">L = ln(1 -(1 -(1 -p) l-1 )R) ln(1 -p) + 1, L ∈ {2, 3, . . . , l}, (<label>7</label></formula><formula xml:id="formula_10">)</formula><p>where L is a random number of initial batches for starting RBP, distributed by a truncated geometric distribution, R ∈ [0, 1], p is the probability of success and l is the minimum number of required batches,</p><formula xml:id="formula_11">l = n i=1 s i /B .</formula><p>The above approach for generating the initial population in HGH has some advantages, since it uses efficiently the knowledge of the problem to group the jobs with longer processing times in the same batches as long as possible. One can adjust the quality of initial population by choosing a proper value of p. Setting a high value for p, seems to be effective on accelerating the convergence rate through a good quality initial seeds but may cause premature convergence to a local optimum. Low value of p causes to less-accelerate converging due to the relatively low quality of initial population. So a tuned value of p would be drastic to exploit advantages of such a robust mechanism of generating initial population. Based on our primary experiments we found 0.1 to be appropriate value for p, for all problem instances.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.">Selection</head><p>For selecting the chromosomes, the tournament selection rule is followed. In this rule two individuals are chosen randomly, and then the fittest one will be chosen if a random value r is smaller than a probability value k, otherwise the other one is chosen. Selected individuals are returned to the population and can be chosen again as a parent. Here, we use a value equal to 0.7 for the probability value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4.">Crossover</head><p>The parameterized uniform crossover of Bean <ref type="bibr" target="#b30">[31]</ref> is utilized in which a bias coin is used to determine which of two selected parents should pass its gene. Using parameterized uniform crossover allows us to bias the search more strongly toward components of better solutions and to accelerate convergence. Due to our representation it may happen to lose some of batches in the generated offspring chromosomes. In this case we rename the batches of the offspring chromosome as it is shown in Fig. <ref type="figure">2</ref>. For any infeasible generated offspring chromosome, the RBP is applied to ensure the feasibility. In this case each generated offspring chromosome indicates an initial batching plan, which is infeasible. Then we ensure the feasibility through using the RBP heuristic. </p><formula xml:id="formula_12">J 1 J 2 J 3 J 4 J 5 J 1 J 2 J 3 J 4 J 5 3 1 3 2</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5.">Mutation</head><p>The swapping mutation is used as mutation operator. It selects two random genes of a selected chromosome and swaps their content. The feasibility of the mutated schedule is kept through using the RBP heuristic. Fig. <ref type="figure">3</ref> shows the swap mutation procedure applied for HGH.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.6.">Local search heuristics</head><p>To improve the effectiveness of HGH, we developed two local search heuristics, based on the problem characteristics. The first heuristic, which is used for the batching phase, ensures reduction in summation of batch processing times corresponding to a batching plan by pairwise swapping jobs between batches. For a given batching plan in scheduling phase, our second heuristic tries to reduce makespan through suitable pairwise interchange of batches between machines. We name the corresponding local search heuristic to batching and scheduling phases as LSHBP and LSHSP, respectively. Both LSHBP and LSHSP are detailed as follows:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>LSHBP heuristic</head><p>For any selected batching plan do: BEGIN 1. Set k = 1; 2. Find the kth batch (name it batch a) that has only one job with maximum processing time; 3. IF there is not any batch a THEN consider the current batching plan as the result of LSHBP and go to 9; ELSE 4.</p><p>Set u = 1; 5.</p><p>Find the uth batch (name it batch b) with batch processing time equal or longer than the processing time of batch a; 6.</p><p>IF there is not any batch b THEN set k = k + 1 and go to 2; ELSE 7.</p><p>IF there is a job j b in b such that: p j a &gt; p j b , p j a = max i|job i∈batch a {p i } THEN</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>8.</head><p>IF swapping jobs j b and j a between batches a and b does not violate the capacity restriction THEN Swap the jobsj b and j a between batches a and b, then go to 1; ELSE set u = u + 1 and go to 5; END IF ELSE set u = u + 1 and go to 5;</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>END IF END IF END IF</head><p>9. List the batches in LPT order (considering each batch as a job) and then assign them to machines successively, whenever a machine becomes free; END For a given batching plan in an iteration of LSHBP, swapping the jobs j a and j b causes decreasing the processing time of batch a without any change in processing time of batch b. Therefore, the swapping ensures improvement in the summation of batch processing times.</p><p>In problems with small size jobs, swapping the jobs may cause less capacity violation comparing to other problems. Therefore LSHBP will have more latitude with this kind of problems and can be significantly effective to direct the search to the optimal solution(s). However, its effect on the other problem categories should not be disregard, especially for mixed size jobs problems (see Section 7).</p><p>To decrease the computation time spent by LSHBP, only a small number of generated batching plans based on their fitness ranking, should be selected to be improved. So in each generation of HGH, the LSHBP is applied on the selected chromosomes based on a predefined rate. We found 0.25 to be an appropriate rate value by our primary experiments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>LSHSP heuristic</head><p>For each schedule do: BEGIN 1. Arrange the machines in decreasing order of their finish time (FT), where the finish time is defined by the time in which the processing on the last batch by the machine is completed; 2. IF all machines have the same finish time THEN stop; the optimal makespan corresponding to the current schedule is achieved. ELSE set i = 1; j = m; and k = 0; END IF 3. Select the ith machine and name it m i . Considering the jth machine (name it m j ), find the batches a ∈ m i and b ∈ m j (the ∈ denotes the assignment of the batch to machine) such that: 0 &lt; P a -P b &lt; F T i -F T j (P a and P b are the processing time of batches a and b, respectively); 4. IF there is not any pair of a and b THEN set j = j -1; </p><formula xml:id="formula_13">and k = k + 1; 5. IF k = m -(i + 1) THEN set i = i</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>END IF ELSE Interchange batches a and b between m i and m j and go to 1; END IF END</head><p>Effectiveness of proposed LSHBP and LSHSP has been experienced on an extensive set of randomly generated instances. Tables <ref type="table" target="#tab_3">1</ref> and<ref type="table">2</ref>, summarize the performance of LSHBP and LSHSP, respectively. The performance of each heuristic has been estimated based on the average ratio of 100 randomly generated feasible batching plans for each of the six problem categories (see Section 7) combined with four levels for the number of jobs and two levels for the number of machines. Also each combination was replicated 30 times with different seed data to create different instances. In Table <ref type="table">2</ref> the first column for each category with different number of machines (columns 3 and 7) shows the C max related to a list-scheduling algorithm, in which the batches are sorted in arbitrary order and are assigned to machines successively, whenever a machine becomes free. The next columns (column 4 and 8) show the improved C max of the corresponded batches order, by the LSHSP. The results for the LPT ordered batches and the improved cases are reported in columns 5, 9 and 6, 10, respectively. It should be noted that the performance in Table <ref type="table" target="#tab_3">1</ref> is measured based on the average percentage of improvement (the average difference between the ratio of a randomly generated batching plan and the ratio of the improved batching plan by LSHBP respect to C S ) resulted by LSHBP, while the performance in Table <ref type="table">2</ref> is measured based on the ratio respect to C p max . As can be seen, both heuristics are significantly effective and can perform very well as a complement part of any constructive heuristic such as RBP.</p><p>In each generation of HGH, the new population is formed by the offspring generated by GA operators. The rest of the population is filled with the best chromosomes of the former generation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.7.">Parameter tuning</head><p>For each GA there are a number of parameters which choosing a proper value for them affects the search behavior and improves the quality of convergence. These parameters include the population size, number of generations, crossover rate, mutation rate and the head probability of the bias coin. For tuning crossover rate, mutation rate and the head probability, different values are considered; 0.5 and 0.7 for crossover rate, 0.05, 0.1 and 0.15 for mutation rate and 0.7 and 0.9 for head probability. Based on the primary experiments on HGH, the appropriate values found to be 0.5, 0.15 and 0.9 for crossover rate, mutation rate and the head probability, respectively. About the population size and stopping criteria, we evaluated the pairs (n, 50) and (2n, 100), where the first member of these ordered pairs denotes the population size (which increases by the problem size) and the second one indicates the number of generations. The results for the pair of (2n, 100) are slightly better in average performance (while there is not any difference in the best and the worst-case performance) at the expense of significant increase in running times. So, it is preferred to keep the pair (n, 50) to provide good results together with saving of the execution time. However the HGH will be stopped if there is no improvement in the best solution obtained in last 15 generations. Worth to mention that to avoid useless computations in both HGH and SA, we set an extra stopping criterion that is getting to the lower bound solution explained in Section 4.</p><p>The general framework of the proposed HGH is described in the following procedure:  Discrete uniform <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b9">10]</ref>, discrete uniform <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b3">4]</ref> and discrete uniform <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b7">8]</ref> Table <ref type="table">4</ref> Upper bound for the search space of test problem instances UNTIL stopping criteria is true.</p><formula xml:id="formula_14">Algorithm</formula><formula xml:id="formula_15">Job size n = 10 n = 20 n = 50 n = 100 m = 2 m = 4 m = 2 m = 4 m = 2 m = 4 m = 2 m =</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Experimentations and results</head><p>For testing effectiveness of proposed HGH, test problem instances are randomly generated in a manner similar to Chang et al. <ref type="bibr" target="#b27">[28]</ref> (in addition we have also considered instances with 100 jobs). For covering various types of problems, four factors are identified: number of jobs, number of machines, variation in job processing times, and variation in job sizes. In general six categories of problems are generated by combining three levels of job sizes (small, large and combination of small and large (mixed)) and two levels of processing times. Processing times and job sizes are generated from discrete uniform distribution. The factors, their levels and ranges, are shown in Table <ref type="table" target="#tab_5">3</ref>. The machine capacity is assumed to be 10 in all instances. Table <ref type="table">4</ref> shows the search space related to the test problem instances as a function of problem size and average number of required batch.</p><p>Each category of problems is represented with a run code. For example a problem category with 10 jobs, four batch processing machines, processing times generated from the discrete uniform <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b19">20]</ref> and job sizes generated from the discrete uniform <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b7">8]</ref> is shown by J1m2p2s3.</p><p>All the algorithms HGH, SA, and the lower bound, are coded in MATLAB 6.5.1 and all test problem instances are solved 15 times by HGH and SA on a Pentium III, 800 MGz computer with 128 MB RAM.</p><p>Table <ref type="table">5</ref> represents the results for 10 jobs instances. Columns 2, 3 and 4, report the best, average and the worst performance against the lower bound among the 15 runs of HGH, respectively. Column 5 reports the average time taken by HGH. These values are reported in columns 6, 7, 8 and 9 for SA, respectively. Tables 6-8 can be interpreted in a same manner. For each algorithm, the performance is measured by  Computational analysis shows that in all categories of test problem instances, HGH performs better than the SA. Especially its superiority over SA has been proved in both cases of the average and the worst-case performance. Regarding the best case performance, no solution is reported by SA that is better than its counterpart reported by HGH, and the best solutions reported by HGH are at least as good as those reported by SA.</p><p>As can be seen in the resulting tables, for all problems with small jobs (J.m.p.s2), where the search space is larger than the other problems, HGH achieved the optimal makespan. As was mentioned before, for these problems, jobs swapping can be more easily handled by the LSHBP, so converging to the optimal makespan may be best achieved through the hybridizing LSHBP with HGH. For the problems with mixed size jobs (J.m.p.s1) results show the better performance for HGH compared to SA. Similar to the case with small size jobs, in this case the differences in objective values are still meaningfully large. Because of the diversity in the job sizes, effective use of the batch capacity in assigning the jobs to batches is an important factor that is satisfied by RBP for HGH. The least difference in objective values exists for the problems with large size jobs (J.m.p.s3). In this case, as can be seen from Table <ref type="table">4</ref>, the search space is significantly smaller compared to other problems. It is expected that for these problems, 40% of individual jobs lie in exactly one batch (the jobs with sizes 7 and 8) and yet the 60% of jobs need to be assigned efficiently to batches to decrease the makespan. This causes reduction in the differences between objective values of HGH and SA.</p><p>As a performance criterion, it is desirable to take into consideration the amount of variation between the worst and the best performance of each algorithm. For each problem instance the SA reports wide range of variation (due to big difference between the worst and the best cases) where the results for HGH show its concentration on an exact value that indicates its good quality of convergence.</p><p>Comparing the required running time for the algorithms, the tables show different results for different problem sizes. For all problems with 10 and 20 jobs instances the times taken by HGH are almost trivial compared to SA running times. This can be related to the high rate of convergence in HGH because of its effective components. So in these cases, our second stopping criterion that is getting to the lower bound solution is fired. Therefore the HGH's needed time for getting to the lower bound solution will be small compared to SA. The major part of the run time in HGH belongs to LSHBP, which increases as the problem size increases. However by eliminating LSHBP, still HGH may be able to outperform SA, but at the expense of the quality performance. We use a population size proportional to the problem size for HGH where the SA uses a fixed value for its parameters (such as the number of temperature decreasing times and also the number of neighboring generation at each temperature) for all problem sizes. This may cause longer execution time for HGH comparing to SA in some large size problem instances.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Conclusions and future research directions</head><p>In this paper we considered the problem of minimizing makespan on m identical parallel batch processing machines with non-identical job sizes. The processing time of a batch is given by the longest processing time (LPT) of the jobs in the batch. To examine the problem search space, we developed an enumerative formula as a function of both problem size (n) and the least number of required batches (l). We proposed a hybrid genetic heuristic (HGH) based on a batch-based representation. Our computational results show that the HGH outperforms a simulated annealing (SA) approach, taken from the literature as a comparator algorithm. Also its good performance comparing to a developed lower bound is indicated. Some characteristics such as using a robust mechanism for generating initial population, using an efficient local search heuristic (LSHBP) to bring longer jobs together as a batch, which has the ability of steering quickly the search toward the optimal solution(s) and using a local search heuristic (LSHSP) to further improve machines load, are the cases that cause HGH to dominate the SA approach.</p><p>For future research, the extension of our approach could include due date related performance measures and also considering dynamic job arrivals and incompatible families.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Chromosome representation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>[(C SA(HGH) max -C LB max )/C LB max ] * 100. Column 10 compares HGH with SA in terms of solutions quality. The content of this column implies how much improvement HGH obtains over SA.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 1</head><label>1</label><figDesc>Performance of LSHBP (% of improvement)</figDesc><table><row><cell>Run code</cell><cell></cell><cell></cell><cell>n = 10</cell><cell></cell><cell>n = 20</cell><cell></cell><cell>n = 50</cell><cell>n = 100</cell></row><row><cell>p1s1</cell><cell></cell><cell></cell><cell>4.53</cell><cell></cell><cell>7.56</cell><cell></cell><cell>11.82</cell><cell>14.82</cell></row><row><cell>p1s2</cell><cell></cell><cell></cell><cell>17.78</cell><cell></cell><cell>24.72</cell><cell></cell><cell>24.71</cell><cell>27.01</cell></row><row><cell>p1s3</cell><cell></cell><cell></cell><cell>3.54</cell><cell></cell><cell>5.71</cell><cell></cell><cell>9.29</cell><cell>10.00</cell></row><row><cell>p2s1</cell><cell></cell><cell></cell><cell>5.55</cell><cell></cell><cell>8.72</cell><cell></cell><cell>12.6</cell><cell>16.03</cell></row><row><cell>p2s2</cell><cell></cell><cell></cell><cell>13.01</cell><cell></cell><cell>30.23</cell><cell></cell><cell>35.05</cell><cell>37.06</cell></row><row><cell>p2s3</cell><cell></cell><cell></cell><cell>3.95</cell><cell></cell><cell>6.33</cell><cell></cell><cell>9.92</cell><cell>10.88</cell></row><row><cell>Table 2</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">Performance of LSHSP</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="2">Run code m = 2</cell><cell></cell><cell></cell><cell></cell><cell>m = 4</cell><cell></cell></row><row><cell></cell><cell></cell><cell>List</cell><cell>List</cell><cell>LPT</cell><cell cols="2">LPT-LSHSP List</cell><cell>List</cell><cell>LPT</cell><cell>LPT-LSHSP</cell></row><row><cell></cell><cell></cell><cell cols="2">scheduling scheduling-LSHSP</cell><cell></cell><cell></cell><cell cols="2">scheduling scheduling-LSHSP</cell></row><row><cell>n = 10</cell><cell>p1s1</cell><cell>1.0812</cell><cell>1.0258</cell><cell cols="2">1.0366 1.0178</cell><cell>1.2135</cell><cell>1.1113</cell><cell>1.0992 1.0984</cell></row><row><cell></cell><cell>p1s2</cell><cell>1.1550</cell><cell>1.1218</cell><cell cols="2">1.1193 1.1193</cell><cell>1.0002</cell><cell>1.0000</cell><cell>1.0000 1.0000</cell></row><row><cell></cell><cell>p1s3</cell><cell>1.0661</cell><cell>1.0095</cell><cell cols="2">1.0147 1.0030</cell><cell>1.2349</cell><cell>1.0980</cell><cell>1.0837 1.0806</cell></row><row><cell></cell><cell>p2s1</cell><cell>1.0866</cell><cell>1.0316</cell><cell cols="2">1.0437 1.0259</cell><cell>1.2014</cell><cell>1.0825</cell><cell>1.0716 1.0706</cell></row><row><cell></cell><cell>p2s2</cell><cell>1.1307</cell><cell>1.0964</cell><cell cols="2">1.0934 1.0933</cell><cell>1.0000</cell><cell>1.0000</cell><cell>1.0000 1.0000</cell></row><row><cell></cell><cell>p2s3</cell><cell>1.0736</cell><cell>1.0117</cell><cell cols="2">1.0185 1.0041</cell><cell>1.2476</cell><cell>1.0931</cell><cell>1.0792 1.0733</cell></row><row><cell>n = 20</cell><cell>p1s1</cell><cell>1.0393</cell><cell>1.0014</cell><cell cols="2">1.0072 1.0002</cell><cell>1.1379</cell><cell>1.0142</cell><cell>1.0334 1.0072</cell></row><row><cell></cell><cell>p1s2</cell><cell>1.0589</cell><cell>1.0119</cell><cell cols="2">1.0421 1.0103</cell><cell>1.2481</cell><cell>1.1689</cell><cell>1.1659 1.1659</cell></row><row><cell></cell><cell>p1s3</cell><cell>1.0321</cell><cell>1.0002</cell><cell cols="2">1.0050 1.0000</cell><cell>1.1141</cell><cell>1.008</cell><cell>1.0217 1.0025</cell></row><row><cell></cell><cell>p2s1</cell><cell>1.0421</cell><cell>1.0018</cell><cell cols="2">1.0092 1.0005</cell><cell>1.1483</cell><cell>1.0197</cell><cell>1.0458 1.0121</cell></row><row><cell></cell><cell>p2s2</cell><cell>1.0633</cell><cell>1.0139</cell><cell cols="2">1.0418 1.0116</cell><cell>1.2604</cell><cell>1.1730</cell><cell>1.1699 1.1699</cell></row><row><cell></cell><cell>p2s3</cell><cell>1.0365</cell><cell>1.0006</cell><cell cols="2">1.0052 1.0002</cell><cell>1.1317</cell><cell>1.0090</cell><cell>1.0190 1.0038</cell></row><row><cell>n = 50</cell><cell>p1s1</cell><cell>1.0155</cell><cell>1.0000</cell><cell cols="2">1.0007 1.0000</cell><cell>1.0558</cell><cell>1.0002</cell><cell>1.0044 1.0000</cell></row><row><cell></cell><cell>p1s2</cell><cell>1.0260</cell><cell>1.0004</cell><cell cols="2">1.0130 1.0000</cell><cell>1.0847</cell><cell>1.0109</cell><cell>1.0320 1.0056</cell></row><row><cell></cell><cell>p1s3</cell><cell>1.0137</cell><cell>1.0000</cell><cell cols="2">1.0004 1.0000</cell><cell>1.0600</cell><cell>1.0004</cell><cell>1.0087 1.0002</cell></row><row><cell></cell><cell>p2s1</cell><cell>1.0597</cell><cell>1.0004</cell><cell cols="2">1.0096 1.0001</cell><cell>1.0590</cell><cell>1.0004</cell><cell>1.0082 1.0001</cell></row><row><cell></cell><cell>p2s2</cell><cell>1.0271</cell><cell>1.0004</cell><cell cols="2">1.0124 1.0001</cell><cell>1.0529</cell><cell>1.0001</cell><cell>1.0046 1.0000</cell></row><row><cell></cell><cell>p2s3</cell><cell>1.0524</cell><cell>1.0001</cell><cell cols="2">1.0035 1.0000</cell><cell>1.0515</cell><cell>1.0001</cell><cell>1.0051 1.0000</cell></row><row><cell cols="2">n = 100 p1s1</cell><cell>1.0078</cell><cell>1.0000</cell><cell cols="2">1.0001 1.0000</cell><cell>1.0282</cell><cell>1.0000</cell><cell>1.0010 1.0000</cell></row><row><cell></cell><cell>p1s2</cell><cell>1.0129</cell><cell>1.0000</cell><cell cols="2">1.0055 1.0000</cell><cell>1.0433</cell><cell>1.0002</cell><cell>1.0142 1.0000</cell></row><row><cell></cell><cell>p1s3</cell><cell>1.0067</cell><cell>1.0000</cell><cell cols="2">1.0000 1.0000</cell><cell>1.0241</cell><cell>1.0000</cell><cell>1.0001 1.0000</cell></row><row><cell></cell><cell>p2s1</cell><cell>1.0085</cell><cell>1.0000</cell><cell cols="2">1.0003 1.0000</cell><cell>1.0310</cell><cell>1.0000</cell><cell>1.0021 1.0000</cell></row><row><cell></cell><cell>p2s2</cell><cell>1.0142</cell><cell>1.0000</cell><cell cols="2">1.0056 1.0000</cell><cell>1.0466</cell><cell>1.0002</cell><cell>1.0177 1.0000</cell></row><row><cell></cell><cell>p2s3</cell><cell>1.0075</cell><cell>1.0000</cell><cell cols="2">1.0001 1.0000</cell><cell>1.0264</cell><cell>1.0000</cell><cell>1.0007 1.0000</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>Crossing over the selected parents using parameterized uniform crossover to get the offspring; 7. For the generated offspring, rename the batches in a numerical order; 8. Ensure feasibility of the generated offspring, using steps 2 and 3 of RBP; 9. Assign batches to machines using LPT rule; 10. Apply LSHSP on the current schedule to make further improvement; 11. Set crossover_offspring = crossover_offspring + 1; Mutate the selected parent using swap mutation to get the offspring; 14. Ensure feasibility of the generated offspring, using steps 2 and 3 of RBP; 15. Assign batches to machines using LPT rule; 16. Apply LSHSP on the current schedule to make further improvement; 17. Set mutation_offspring = mutation_offspring + 1; UNTIL mutation_offspring &lt; (0.15 * n) 18. Migrate the top (0.1 * n) chromosomes of the former generation to the current population; % LSHBP 19. Sort all chromosomes in increasing order of their fitness (delete the repeated chromosomes);</figDesc><table><row><cell>HGH</cell></row><row><cell>BEGIN</cell></row><row><cell>% Initial population:</cell></row><row><cell>FOR each chromosome of initial population</cell></row><row><cell>1. Simulate the number of initial batches using Eq. (7);</cell></row><row><cell>2. Apply RBP to reach a feasible batching plan;</cell></row><row><cell>3. Assign batches to machines using LPT rule;</cell></row><row><cell>4. Apply LSHSP on the current schedule to make further improvement;</cell></row><row><cell>END FOR</cell></row><row><cell>REPEAT</cell></row><row><cell>% Cross over</cell></row><row><cell>5. Set crossover_offspring = 1;</cell></row><row><cell>REPEAT</cell></row><row><cell>6. UNTIL crossover_offspring &lt; (0.5  *  n)</cell></row><row><cell>% Mutation</cell></row><row><cell>12. Set mutation_offspring = 1;</cell></row><row><cell>REPEAT</cell></row><row><cell>13.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 3</head><label>3</label><figDesc></figDesc><table><row><cell>Factors and levels</cell><cell></cell></row><row><cell>Factors</cell><cell>Levels</cell></row><row><cell>m</cell><cell>2, 4</cell></row><row><cell>|J |</cell><cell>10, 20, 50 and 100 jobs</cell></row><row><cell>p</cell><cell>Discrete uniform [1, 10] and discrete uniform [1, 20]</cell></row><row><cell>s</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>Apply LSHBP on the LSHBP_offspringth chromosome of the sorted population to get the improved offspring; 22. Assign batches to machines using LPT rule; 23. Apply LSHSP on the current schedule to make further improvement; 24. Set LSHBP_offspring = LSHBP_offspring + 1;</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>4</cell></row><row><cell>s1</cell><cell>1.89E6</cell><cell>1.32E7</cell><cell>6.12E15</cell><cell>1.14E18</cell><cell>1.72E50</cell><cell>7.11E56</cell><cell>2.84E116</cell><cell>3.21E130</cell></row><row><cell>s2</cell><cell>2.20E6</cell><cell>1.38E7</cell><cell>1.19E16</cell><cell>1.33E18</cell><cell>2.23E52</cell><cell>3.63E57</cell><cell>3.95E124</cell><cell>1.97E134</cell></row><row><cell>s3</cell><cell>1.21E6</cell><cell>1.11E7</cell><cell>1.15E15</cell><cell>5.53E17</cell><cell>5.65E46</cell><cell>5.88E54</cell><cell>3.80E106</cell><cell>3.93E123</cell></row><row><cell cols="3">20. Set LSHBP_offspring = 1;</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>REPEAT</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="4">21. UNTIL LSHBP_offspring &lt; (0.25  *  n)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">% Selection</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="9">25. From the current population, select n chromosomes using tournament selection technique (n= population_size);</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 8</head><label>8</label><figDesc>Results for instances with 100 jobs (comparing to the lower bound) Best C max Avg. C max Worst C max Avg. run-time (s) Best C max Avg. C max Worst C max Avg. run-time (s)</figDesc><table><row><cell>Run code HGH</cell><cell></cell><cell></cell><cell></cell><cell>SA</cell><cell></cell><cell></cell><cell></cell><cell>Avg. diff (%)</cell></row><row><cell>J4m1p1s1 1.35</cell><cell>1.89</cell><cell>2.02</cell><cell>186.69</cell><cell>6.08</cell><cell>6.82</cell><cell>8.78</cell><cell>99.51</cell><cell>4.93</cell></row><row><cell>J4m1p1s2 0.00</cell><cell>0.42</cell><cell>1.06</cell><cell>44.15</cell><cell>2.12</cell><cell>5.03</cell><cell>6.38</cell><cell>34.91</cell><cell>4.61</cell></row><row><cell>J4m1p1s3 1.54</cell><cell>1.64</cell><cell>2.57</cell><cell>131.58</cell><cell>2.06</cell><cell>3.09</cell><cell>5.67</cell><cell>138.70</cell><cell>1.45</cell></row><row><cell>J4m1p2s1 3.61</cell><cell>3.72</cell><cell>3.97</cell><cell>249.18</cell><cell>7.94</cell><cell>9.06</cell><cell>10.46</cell><cell>106.90</cell><cell>5.34</cell></row><row><cell>J4m1p2s2 0.00</cell><cell>0.69</cell><cell>1.22</cell><cell>55.49</cell><cell>2.45</cell><cell>4.60</cell><cell>6.74</cell><cell>32.18</cell><cell>3.91</cell></row><row><cell>J4m1p2s3 2.05</cell><cell>2.17</cell><cell>2.56</cell><cell>143.36</cell><cell>2.30</cell><cell>3.10</cell><cell>3.84</cell><cell>160.50</cell><cell>0.93</cell></row><row><cell>J4m2p1s1 1.56</cell><cell>2.59</cell><cell>3.12</cell><cell>174.60</cell><cell>4.68</cell><cell>7.39</cell><cell>9.37</cell><cell>92.96</cell><cell>4.8</cell></row><row><cell>J4m2p1s2 0.00</cell><cell>0.65</cell><cell>2.50</cell><cell>29.76</cell><cell>5.00</cell><cell>6.32</cell><cell>10.00</cell><cell>32.62</cell><cell>5.67</cell></row><row><cell>J4m2p1s3 3.09</cell><cell>3.50</cell><cell>4.12</cell><cell>160.46</cell><cell>3.09</cell><cell>4.43</cell><cell>6.18</cell><cell>156.10</cell><cell>0.93</cell></row><row><cell>J4m2p2s1 2.89</cell><cell>3.23</cell><cell>4.34</cell><cell>200.69</cell><cell>5.79</cell><cell>8.18</cell><cell>10.14</cell><cell>102.60</cell><cell>4.95</cell></row><row><cell>J4m2p2s2 0.00</cell><cell>0.32</cell><cell>1.25</cell><cell>45.97</cell><cell>2.50</cell><cell>4.66</cell><cell>7.50</cell><cell>36.57</cell><cell>4.34</cell></row><row><cell>J4m2p2s3 1.56</cell><cell>1.91</cell><cell>2.08</cell><cell>148.25</cell><cell>2.08</cell><cell>3.28</cell><cell>4.68</cell><cell>144.80</cell><cell>1.37</cell></row></table></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Efficient algorithms for scheduling semiconductor burn-in operations</title>
		<author>
			<persName><forename type="first">C-Y</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Uzsoy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin-</forename><surname>Vega</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L-A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operations Research</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="764" to="775" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Efficient scheduling algorithms for a single batch processing machine</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ikura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gimple</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operations Research Letters</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="61" to="65" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Scheduling with agreeable release times and due dates on a batch processing machine</title>
		<author>
			<persName><forename type="first">C-L</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C-Y</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">European Journal of Operational Research</title>
		<imprint>
			<biblScope unit="volume">96</biblScope>
			<biblScope unit="page" from="564" to="569" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Scheduling a batching machine</title>
		<author>
			<persName><forename type="first">P</forename><surname>Brucker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gladky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Hoogeveen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M-Y</forename><surname>Kovalyov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Potts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Tautenhahn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Scheduling</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="31" to="54" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Minimizing total completion time on batch processing machines</title>
		<author>
			<persName><forename type="first">V</forename><surname>Chandru</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C-Y</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Uzsoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Production Research</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="2097" to="2121" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Branch and bound method for minimizing mean flow time on a single batch processing machine</title>
		<author>
			<persName><forename type="first">L</forename><surname>Dupont</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jolai</forename><surname>Ghazvini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Industrial Engineering: Applications and Practice</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="197" to="203" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Minimizing total weighted completion time on a single batch processing machine</title>
		<author>
			<persName><forename type="first">R</forename><surname>Uzsoy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Production and Operations Management</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="57" to="73" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Minimizing makespan on a single batch processing machine with dynamic job arrivals</title>
		<author>
			<persName><forename type="first">C-Y</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Uzsoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Production Research</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="219" to="236" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Scheduling a single batch processing machine with secondary resource constraints</title>
		<author>
			<persName><forename type="first">K-G</forename><surname>Kempf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Uzsoy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C-S</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Manufacturing Systems</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="37" to="51" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Scheduling batch processing machines with incompatible job families</title>
		<author>
			<persName><forename type="first">R</forename><surname>Uzsoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Production Research</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="2685" to="2708" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Minimizing total tardiness on a batch processing machine with incompatible job families</title>
		<author>
			<persName><forename type="first">S-V</forename><surname>Mehta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Uzsoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IIE Transactions</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="165" to="178" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The batch loading and scheduling problem</title>
		<author>
			<persName><forename type="first">G</forename><surname>Dobson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R-S</forename><surname>Nambimadom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Research Report</title>
		<imprint>
			<date type="published" when="1992">1992</date>
			<pubPlace>Rochester, NY, USA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Simon School of Business Administration, University of Rochester</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Minimizing number of tardy jobs on a batch processing machine with incompatible job families</title>
		<author>
			<persName><forename type="first">F</forename><surname>Jolai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">European Journal of Operational Research</title>
		<imprint>
			<biblScope unit="volume">162</biblScope>
			<biblScope unit="page" from="184" to="190" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Minimizing total completion time on a batch processing machine with job families</title>
		<author>
			<persName><forename type="first">V</forename><surname>Chandru</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C-Y</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Uzsoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operations Research Letters</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="61" to="65" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Algorithms and heuristics for scheduling semiconductor burn-in operations</title>
		<author>
			<persName><forename type="first">D-S</forename><surname>Hochbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Landy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
			<pubPlace>Berkeley, USA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of California</orgName>
		</respStmt>
	</monogr>
	<note>Research Report ESRC 94-8</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A single batch processing machine with non-identical job sizes</title>
		<author>
			<persName><forename type="first">R</forename><surname>Uzsoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Production Research</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="1615" to="1635" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Minimizing mean flow time on a single batch processing machine with non-identical job sizes</title>
		<author>
			<persName><forename type="first">Jolai</forename><surname>Ghazvini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Dupont</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Production Economics</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="page" from="273" to="280" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Minimizing the makespan on a batch machine with non-identical job sizes: an exact procedure</title>
		<author>
			<persName><forename type="first">L</forename><surname>Dupont</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Dhaenens-Flipo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers and Operations Research</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="807" to="819" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Minimizing makespan on a single batching machine with release times and non-identical job sizes</title>
		<author>
			<persName><forename type="first">L</forename><surname>Shuguang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Guojun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Xiaoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Qiming</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operations Research Letters</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="157" to="164" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A genetic algorithm to minimize maximum lateness on a batch processing machine</title>
		<author>
			<persName><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Uzsoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers and Operations Research</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="1621" to="1640" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Minimizing make span for single machine batch processing with non-identical job sizes using simulated annealing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Melouk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Damodaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P-Y</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Production Economics</title>
		<imprint>
			<biblScope unit="volume">87</biblScope>
			<biblScope unit="page" from="141" to="147" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Scheduling a single batch processing machine with arbitrary job sizes and incompatible job families</title>
		<author>
			<persName><forename type="first">S-G</forename><surname>Koh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P-H</forename><surname>Koo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D-C</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W-S</forename><surname>Hur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Production Economics</title>
		<imprint>
			<biblScope unit="volume">98</biblScope>
			<biblScope unit="page" from="81" to="96" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Bounds on multiprocessor timing anomalies</title>
		<author>
			<persName><forename type="first">R-L</forename><surname>Graham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal of Applied Mathematics</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="416" to="429" />
			<date type="published" when="1969">1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Genetic algorithm based scheduling of parallel batch machines with incompatible job families to minimize total weighted tardiness</title>
		<author>
			<persName><forename type="first">H</forename><surname>Balasubramanian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Monch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Fowler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pfund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Production Research</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="1621" to="1638" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Heuristic scheduling of jobs on parallel batch machines with incompatible job families and unequal ready times</title>
		<author>
			<persName><forename type="first">L</forename><surname>Monch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Balasubramanian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Fowler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pfund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers and Operations Research</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="2731" to="2750" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Scheduling parallel batch processing machines with arbitrary job sizes and incompatible job families</title>
		<author>
			<persName><forename type="first">S-G</forename><surname>Koh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P-H</forename><surname>Koo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J-W</forename><surname>Ha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W-S</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Production Research</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="4091" to="4107" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A genetic algorithm for minimizing maximum lateness on parallel identical batch processing machines with dynamic job arrivals and incompatible job families</title>
		<author>
			<persName><forename type="first">S</forename><surname>Malve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Uzsoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers and Operations Research</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note>in press</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Minimizing makespan on parallel batch processing machines</title>
		<author>
			<persName><forename type="first">P-Y</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Damodaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Melouk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Production Research</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="4211" to="4220" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Scheduling with deadlines and loss functions</title>
		<author>
			<persName><forename type="first">R</forename><surname>Mcnaughton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Management Science</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="1" to="12" />
			<date type="published" when="1959">1959</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Genetic algorithms and engineering design</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cheng</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Wiley</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Genetic algorithms and random keys for sequencing and optimization</title>
		<author>
			<persName><forename type="first">J-C</forename><surname>Bean</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ORSA Journal of Computing</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="154" to="160" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
