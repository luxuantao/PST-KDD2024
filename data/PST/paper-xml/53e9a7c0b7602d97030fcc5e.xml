<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Reconstructing RSA Private Keys from Random Key Bits</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Nadia</forename><surname>Heninger</surname></persName>
							<email>nadiah@cs.princeton.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Princeton University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Hovav</forename><surname>Shacham</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>San Diego</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Reconstructing RSA Private Keys from Random Key Bits</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">8799B9D839B16D9B7DD2131D52248C4E</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T10:56+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We show that an RSA private key with small public exponent can be efficiently recovered given a 0.27 fraction of its bits at random. An important application of this work is to the "cold boot" attacks of Halderman et al. We make new observations about the structure of RSA keys that allow our algorithm to make use of the redundant information in the typical storage format of an RSA private key. Our algorithm itself is elementary and does not make use of the lattice techniques used in other RSA key reconstruction problems. We give an analysis of the running time behavior of our algorithm that matches the threshold phenomenon observed in our experiments.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In this paper, we present a new algorithm for the problem of reconstructing RSA private keys given a random δ-fraction of their bits. For RSA keys with small public exponent, our algorithm reconstructs the private key with high probability when δ ≥ 0.27. The runtime analysis of our algorithm relies on an assumption (Conjecture 1) and is thus heuristic; but we have verified experimentally that it succeeds with high probability.</p><p>Motivation: cold boot attacks. An important application of our algorithm is key recovery from the randomly distributed unidirectional bit corruption observed in the recent work of Halderman et al. <ref type="bibr" target="#b9">[10]</ref>, which demonstrated that DRAM remanence effects make possible practical, nondestructive attacks that recover (a degraded version of) secret keys stored in a computer's memory. Using these "cold boot" attacks, attackers with physical access to a machine can break popular disk encryption systems or recover an SSL server's private key.</p><p>One consequence of the nature of the attack is that a perfect image of the contents of memory may not be available to the attacker; instead, some bits may have been flipped. <ref type="bibr">Halderman et al.</ref> observe that, within a DRAM region, the decay is overwhelmingly either 0 → 1 or 1 → 0. The decay direction for a region can be determined by comparing the number of 0s and 1s. (In an uncorrupted key we expect these to be approximately equal.) For a region of 1 → 0 decay, a 1 bit in the decayed version is known (with high probability) to correspond to a 1 bit in the original key, whereas a 0 bit might correspond to either a 0 or 1 bit in the original key. If a ρ fraction of bits decays and 0s and 1s were present in equal numbers in the key then we will know, given the degraded representation, a δ = (1ρ)/2 fraction of key bits.</p><p>Halderman et al. further showed that it is possible to exploit redundancy in key data to create algorithms for reconstructing DES, AES, and cipher tweak keys from their degraded in-memory representations. In addition, they experimented with reconstructing RSA keys by using the public modulus N to correct its partly-known factors p and q. We extend this idea to take into account other fields of an RSA private key and provide an analysis of the resulting algorithm's runtime behavior. Our improvement makes a significant difference in practice: their algorithm takes several minutes to recover a 2048-bit RSA key from 12% unidirectional corruption; ours takes under a second to recover a 2048-bit key from as much as 46% unidirectional corruption.</p><p>Our algorithm and its performance. Our two main results in this paper are: <ref type="bibr" target="#b0">(1)</ref> an algorithm for reconstructing RSA private keys given a random δ-fraction of their bits; and (2) an analysis of the algorithm's runtime behavior for random inputs that shows that it will succeed in expected quadratic time when δ ≥ .27. The runtime analysis depends crucially on both a uniformly random distribution of known bits and the assumption that the effect of a bit error during reconstruction is propagated uniformly through subsequent bits of the key.</p><p>Our algorithm performs better than the algorithm given by Halderman et al. because it is able to make use of five components of the RSA private key: p, q, d, d p , and d q . We can use known bits in d, d p , and d q to make progress where bits in p and q are not known. To relate d to the rest of the private key, we make use of techniques due to Boneh, Durfee, and Frankel <ref type="bibr" target="#b3">[4]</ref>; to relate d p and d q to the rest of the private key, we make new observations about the structure of RSA keys that may be of independent interest. This is discussed in Section 2.</p><p>If the algorithm has access to fewer components of the RSA private key, the algorithm will still perform well given a sufficiently large fraction of the bits. For example, it can efficiently recover a key given δ = .27 fraction of the bits of p, q, d, d p , and d q . δ = .42 fraction of the bits of p, q, and d. δ = .57 fraction of the bits of p and q.</p><p>The reconstruction algorithm itself, described in Section 3, is elementary and does not make use of the lattice basis reduction or integer programming techniques that have been applied to other kinds of RSA key reconstruction problems. At each step, it branches to explore all possible keys, and prunes these possibilities using our understanding of the structure of RSA keys and the partial information we are given about key bits. We give an analysis of the algorithm for random inputs in Section 4. We obtain a sharp threshold around 2 -2 (4/5) ≈ 27% of known key bits. Below this threshold, the expected number of keys examined is exponential in the number of bits of the key, and above this threshold, the expected number of keys examined is close to linear. Note that this threshold applies only to our particular approach. We suspect these results could be improved using more sophisticated methods.</p><p>Finally, we have implemented our algorithm and performed extensive experiments using it. The results are described in Section 5. The algorithm's observed behavior matches our analytically derived bounds and validates the heuristic assumptions made in the analysis.</p><p>Small public-exponent RSA. Our algorithm is specialized to the case where the public exponent e is small. The small-e case is, for historical reasons, the overwhelmingly common one in deployed RSA applications such as SSL/TLS. For example, until recently Internet Explorer would reject TLS server certificates with an RSA public exponent longer than 32 bits <ref type="bibr">[5, p. 8]</ref>. The choice e = 65537 = 2 16 + 1 is especially widespread. Of the certificates observed in the UCSD TLS Corpus <ref type="bibr" target="#b22">[23]</ref> (which was obtained by surveying frequently-used TLS servers), 99.5% had e = 65537, and all had e at most 32 bits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related work.</head><p>Inspired by cold boot attacks, Akavia, Goldwasser, and Vaikuntanathan <ref type="bibr" target="#b0">[1]</ref> formally introduced memory attacks, a class of side-channel attacks in which the adversary is leaked a (shrinking) function of the secret key. One research direction, pursued by Akavia, Goldwasser, and Vaikuntanathan and, in followup work, Naor and Segev <ref type="bibr" target="#b17">[18]</ref>, is constructing cryptosystems provably secure against memory attacks.<ref type="foot" target="#foot_0">1</ref> Another research direction is to evaluate the security of existing cryptosystems against memory attacks. Our work is along this latter direction.</p><p>There is a great deal of work on both factoring and reconstructing RSA private keys given a fraction of the bits.</p><p>Maurer <ref type="bibr" target="#b13">[14]</ref> shows that integers can be factored in polynomial time given oracle access to an fraction of the bits of a factor.</p><p>In a slightly stricter model, the algorithm has access to a fixed subset of consecutive bits of the integer factors or RSA private keys. Rivest and Shamir <ref type="bibr" target="#b20">[21]</ref> first solved the problem for a 2/3-fraction of the least significant bits of a factor using integer programming. This was improved to 1/2 of the least or most significant bits of a factor using lattice-reduction techniques pioneered by Coppersmith <ref type="bibr" target="#b5">[6]</ref>; we refer the reader surveys by Boneh <ref type="bibr" target="#b2">[3]</ref> and May <ref type="bibr" target="#b15">[16]</ref> as well as May's Ph. D. thesis <ref type="bibr" target="#b14">[15]</ref> for bibliographies. More recently, Herrmann and May extended these techniques to efficiently factor given at most log log N known blocks of bits <ref type="bibr" target="#b11">[12]</ref>.</p><p>The problem we seek to solve can be viewed as a further relaxation of the conditions on access to the key bits to a fully random subset. These lattice-reduction techniques are not directly applicable to our problem because they rely on recovering consecutive bits of the key (expressed as small integer solutions to modular equations), whereas the missing bits we seek to find are randomly distributed throughout the degraded keys. It is possible to express our reconstruction problem as a knapsack, and there are lattice techniques for solving knapsack problems (see, e.g., Nguyen and Stern <ref type="bibr" target="#b18">[19]</ref>), but we have not managed to improve on our solution by this approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RSA Private Keys</head><p>The PKCS#1 standard specifies <ref type="bibr" target="#b21">[22,</ref><ref type="bibr">Sect. A.1.2</ref>] that an RSA private key include at least the following information:</p><p>the (n-bit) modulus N and public exponent e; -the private exponent d; -the prime factors p and q of N ; -d modulo p -1 and q -1, respectively denoted d p and d q ; and the inverse of q modulo p, denoted q -1 p .</p><p>In practice, an RSA key in exactly this format can be recovered from the RAM of a machine running Apache with OpenSSL <ref type="bibr" target="#b9">[10]</ref>. The first items -N and e -make up the public key and are already known to the attacker. A naïve RSA implementation would use d to perform the private-key operation c → c d mod N , but there is a more efficient approach, used by real-world implementations such as OpenSSL, that is enabled by the remaining private-key entries. In this approach, one computes the answer modulo p and q as (c mod p) dp and (c mod q) dq , respectively; then combines these two partial answers by means of q -1 p and the Chinese Remainder Theorem (CRT). This approach requires two exponentiations but of smaller numbers, and is approximately four times as fast as the naïve method <ref type="bibr">[17, p. 613</ref>].</p><p>Observe that the information included in PKCS#1 private keys is highly redundant. In fact, knowledge of any single one of p, q, d, d p , and d q is sufficient to reveal the factorization of N . <ref type="foot" target="#foot_2">2</ref> It is this redundancy that we will use in reconstructing a corrupted RSA key.</p><p>We now derive relations between p, q, d, d p , and d q that will be useful in mounting the attack. The first such relation is obvious:</p><formula xml:id="formula_0">N = pq . (1) Next, since d is the inverse of e modulo ϕ(N ) = (p -1)(q -1) = N -p -q + 1, we have ed ≡ 1 (mod ϕ(N ))</formula><p>and, modulo p -1 and q -1,</p><formula xml:id="formula_1">ed p ≡ 1 (mod p -1)</formula><p>and ed q ≡ 1 (mod q -1) .</p><p>As it happens, it is more convenient for us to write explicitly the terms hidden in the three congruences above, obtaining</p><formula xml:id="formula_2">ed = k(N -p -q + 1) + 1 (2) ed p = k p (p -1) + 1 (3) ed q = k q (q -1) + 1 . (<label>4</label></formula><formula xml:id="formula_3">)</formula><p>It may appear that we have thereby introduced three new unknowns: k, k p , and k q . But in fact for small e we can compute each of these three variables given even a badly-degraded version of d.</p><p>Computing k. The following argument, due to Boneh, Durfee, and Frankel <ref type="bibr" target="#b3">[4]</ref>,</p><p>shows that k must be in the range 0 &lt; k &lt; e. We know d &lt; ϕ(N ). Assume e ≤ k; then ed &lt; kϕ(N ) + 1, which contradicts (2). The case k = 0 is also impossible, as can be seen by reducing ( <ref type="formula" target="#formula_25">2</ref>) modulo e. This shows that we can enumerate all possible values of k, having assumed that e is small. For each such choice k , define</p><formula xml:id="formula_4">d(k ) def = k (N + 1) + 1 e .</formula><p>As Boneh, Durfee, and Frankel observe, when k equals k, this gives an excellent approximation for d:</p><formula xml:id="formula_5">0 ≤ d(k) -d ≤ k(p + q)/e &lt; p + q .</formula><p>In particular, when p and q are balanced, we have p + q &lt; 3 √ N , which means that d(k) agrees with d on their n/2 -2 most significant bits. (Our analysis applies also in the less common case when p and q are unbalanced, but we omit the details.) This means that small-public-exponent RSA leaks half the bits of the private exponent in one of the candidate values d(1), . . . , d(e -1).</p><p>The same fact allows us to go in the other direction, using information about d to determine k, as again noted by Boneh, Durfee, and Frankel. We are given d, a corrupted version of d. We enumerate d(1), . . . , d(e -1) and check which of these agrees, in its more significant half, with the known bits of d. Provided that δn/2 lg e, there will be just one value of k for which d(k ) matches; that value is k. Even for 1024-bit N and 32-bit e, there is, with overwhelming probability, enough information to compute k for any δ we consider in this paper. This observation has two implications:</p><p>1. we learn the correct k used in (2); and 2. we correct the more significant half of the bits of d, by copying from d(k).</p><p>Computing k p and k q . Once we have determined k, we can compute k p and k q . First, observe that by an analysis like that above, we can show that 0 &lt; k p , k q &lt; e. This, of course, means that k p = (k p mod e) and k q = (k q mod e); when we solve for k p and k q modulo e, this will reveal the actual values used in (3) and ( <ref type="formula" target="#formula_2">4</ref>). Now, reducing equations ( <ref type="formula" target="#formula_41">1</ref>)-( <ref type="formula" target="#formula_2">4</ref>) modulo e, we obtain the following congruences:</p><formula xml:id="formula_6">N ≡ pq (5) 0 ≡ k(N -p -q + 1) + 1 (6) 0 ≡ k p (p -1) + 1 (7) 0 ≡ k q (q -1) + 1 . (<label>8</label></formula><formula xml:id="formula_7">)</formula><p>These are four congruences in four unknowns: p, q, k p , and k q ; we solve them as follows. From ( <ref type="formula">7</ref>) and ( <ref type="formula" target="#formula_6">8</ref>) we write (p -1) ≡ -1/k p and (q -1) ≡ -1/k q ; we substitute these into the equation obtained from using (5) to reexpress ϕ(N ) in ( <ref type="formula">6</ref>):</p><formula xml:id="formula_8">0 ≡ k(N -p-q+1)+1 ≡ k(p-1)(q-1)+1 ≡ k(-1/k p )(-1/k q )+1 ≡ k/(k p k q )+1, or k + k p k q ≡ 0 . (<label>9</label></formula><formula xml:id="formula_9">)</formula><p>Next, we return to <ref type="bibr" target="#b5">(6)</ref>, substituting in ( <ref type="formula">7</ref>), <ref type="bibr" target="#b7">(8)</ref>, and ( <ref type="formula" target="#formula_8">9</ref>):</p><formula xml:id="formula_10">0 ≡ k(N -p -q + 1) + 1 ≡ k(N -1) -k(p -1 + q -1) + 1 ≡ k(N -1) -(-k p k q )(-1/k p -1/k q ) + 1 ≡ k(N -1) -(k q + k p ) + 1 ;</formula><p>we solve for k p by substituting</p><formula xml:id="formula_11">k q = -k/k p , obtaining 0 ≡ k(N -1) -(k p -k/k p ) + 1 ,</formula><p>or, multiplying both sides by k p and rearranging,</p><formula xml:id="formula_12">k 2 p -k(N -1) + 1 k p -k ≡ 0 . (<label>10</label></formula><formula xml:id="formula_13">)</formula><p>This congruence is easy to solve modulo e and, in the common case where e is prime, has two solutions, just as it would over C. One of the two solutions is the correct value of k p ; and it is easy to see, by symmetry, that the other must be the correct value of k q . We need therefore try just two possible assignments to k p and k q in reconstructing the RSA key. When e has m distinct prime factors, there may be up to 2 m roots <ref type="bibr" target="#b3">[4]</ref>. Note that we also learn the values of p and q modulo e. If we then use the procedure outlined below to decode the r least significant bits of p (up to a list of possibilities), we will know p mod e2 r ; we can then factor N , provided r + lg e &gt; n/4, by applying Boneh, Durfee, and Frankel's Corollary 2.2 ([4]; a generalization of Coppersmith's attack on RSA with known low-order bits [6, Theorem 5] that removes the restriction that the partial knowledge of p must be modulo a power of 2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">The Reconstruction Algorithm</head><p>Once we have the above relationships between key data, the remainder of the attack consists of enumerating all possible partial keys and pruning those that do not satisfy these constraints. More precisely, given bits 1 through i -1 of a potential key, generate all combinations of values for bit i of p, q, d, d p , d q , and keep a candidate combination if it satisfies (1), ( <ref type="formula" target="#formula_25">2</ref>), (3), and (4) mod 2 i .</p><p>The remainder of this section details how to generate and prune these partial solutions.</p><p>In what follows, we assume that we know the values of k p and k q . When equation <ref type="bibr" target="#b9">(10)</ref> has two distinct solutions, we must run the algorithm twice, once for each of the possible assignments to k p and k q .</p><p>Let p [i] denote the ith bit of p, where the least significant bit is bit 0, and similarly index the bits of q, d, d p and d q . Let τ (x) denote the exponent of the largest power of 2 that divides x.</p><p>As p and q are large primes, we know they are odd, so we can correct p</p><formula xml:id="formula_14">[0] = q [0] = 1. It follows that 2 | p -1, so 2 1+τ (kp) | k p (p -1)</formula><p>. Thus, reducing (3) modulo 2 1+τ (kp) , we have</p><formula xml:id="formula_15">ed p ≡ 1 (mod 2 1+τ (kp) ) .</formula><p>Since we know e, this allows us immediately to correct the 1 + τ (k p ) least significant bits of d p . Similar arguments using ( <ref type="formula" target="#formula_2">4</ref>) and ( <ref type="formula" target="#formula_25">2</ref>) allow us to correct the 1 + τ (k q ) and 2 + τ (k) bits of d q and d, respectively.</p><p>What is more, we can easily see that, having fixed bits &lt; i of p, a change in p [i] affects d p not in bit i but in bit i + τ (k p ); and, similarly, a change in q [i] affects d q i + τ (k q ) , and a change in p [i] or q [i] affects d i + τ (k) . When any of k, k p , or k q is odd, this is just the trivial statement that changing bit i of the right-hand side of an equation changes bit i of the left-hand side. Powers of 2 in k p shift left the bit affected by p [i], and similarly for the other variables.</p><p>Having recovered the least-significant bits of each of our five variables, we now attempt to recover the remaining bits. For each bit index i, we consider a slice of bits:</p><formula xml:id="formula_16">p [i] q [i] d i + τ (k) d p i + τ (k p ) d q i + τ (k q ) .</formula><p>For each possible solution up to bit slice i -1, generate all possible solutions up to bit slice i that agree with that solution at all but the ith position. If we do this for all possible solutions up to bit slice i -1, we will have enumerated all possible solutions up to bit slice i. Above, we already described how to obtain the only possible solution up to i = 0; this is the solution we use to start the algorithm. The factorization of N will be revealed in one or more of the possible solutions once we have reached i = n/2 . <ref type="foot" target="#foot_3">3</ref>All that remains is how to lift a possible solution (p , q , d , d p , d q ) for slice i-1 to possible solutions for slice i. Naïvely there are 2 5 = 32 such possibilities, but in fact there are at most 2 and, for large enough δ, almost always fewer.</p><p>First, observe that we have four constraints on the five variables: equations (1), ( <ref type="formula" target="#formula_25">2</ref>), (3), and (4). By plugging in the values up to slice i -1, we obtain from each of these a constraint on slice i, namely values c 1 , . . . , c 4 such that the following congruences hold modulo 2:</p><formula xml:id="formula_17">p [i] + q [i] ≡ c 1 (mod 2) d i + τ (k) + p [i] + q [i] ≡ c 2 (mod 2)</formula><formula xml:id="formula_18">d p i + τ (k p ) + p [i] ≡ c 3 (mod 2)</formula><formula xml:id="formula_19">d q i + τ (k q ) + q [i] ≡ c 4 (mod 2) . (11)</formula><p>For example, if N and p q agree at bit i, c 1 = 0; if not, c 1 = 1. Four constraints on five unknowns means that there are exactly two possible choices for bit slice i satisfying these four constraints. (Expressions for the c i s are given in <ref type="bibr" target="#b12">(13)</ref>.)</p><p>Next, it may happen that we know the correct value of one or more of the bits in the slice, through our partial knowledge of the private key. These known bits might agree with neither, one, or both of the possibilities derived from the constraints above. If neither possible extension of a solution up to i -1 agrees with the known bits, that solution is pruned. If δ is sufficiently large, the number of possibilities at each i will be kept small.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Algorithm Runtime Analysis</head><p>The main result of this section is summarized in the following informal theorem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1.</head><p>Given the values of a δ = .27 fraction of the bits of p, q, d, d mod p, and d mod q, the algorithm will correctly recover an n-bit RSA key in expected O(n 2 ) time with probability 1 -1 n 2 . The running time of the algorithm is determined by the number of partial keys examined. To bound the total number of keys seen by the program, we will first understand how the structure of the constraints on the RSA key data determines the number of partial solutions generated at each step of the algorithm. Then we will use this understanding to calculate some of the distribution of the number of solutions generated at each step over the randomness of p and q and the missing bits. Finally we characterize the global behavior of the program and provide a bound on the probability that the total number of branches examined over the entire run of the program is too large.</p><p>Lifting solutions mod 2 i . The process of generating bit i of a partial solution given bits 0 through i -1 can be seen as lifting a solution to the constraint equations mod 2 i to a solution mod 2 i+1 . Hensel's lemma characterizes the conditions when this is possible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 1 (Multivariate Hensel's Lemma</head><formula xml:id="formula_20">). A root r = (r 1 , r 2 , . . . , r n ) of the polynomial f (x 1 , x 2 , . . . , x n ) mod π i can be lifted to a root r + b mod π i+1 if b = (b 1 π i , b 2 π i , . . . , b n π i ), 0 ≤ b j ≤ π -1 is a solution to the equation f (r + b) = f (r) + j b j π i f xj (r) ≡ 0 (mod π i+1 ) .</formula><p>(Here, f xj is the partial derivative of f with respect to x j .)</p><p>We can rewrite the lemma using the notation of Section 3. Write r in base π = 2 and assume the i first bits are known. Then the lemma tells us that the next bit of r, r</p><formula xml:id="formula_21">[i] = (r 1 [i], r 2 [i], . . .), must satisfy f (r)[i] + j f xj (r)r j [i] ≡ 0 (mod 2) . (<label>12</label></formula><formula xml:id="formula_22">)</formula><p>In our case, the constraint polynomials generated in Section 2, equations ( <ref type="formula" target="#formula_41">1</ref>)-( <ref type="formula" target="#formula_2">4</ref>) form four simultaneous equations in five variables. Given a partial solution (p , q , d , d p , d q ) up to slice i of the bits, we apply the condition in equation ( <ref type="formula" target="#formula_21">12</ref>) above to each polynomial and reduce modulo 2 to obtain the following conditions, modulo 2, on bit i:</p><formula xml:id="formula_23">p [i] + q [i] ≡ (n -p q ) [i] d i + τ (k) + p [i] + q [i] ≡ k(N + 1) + 1 -k(p + q ) -ed i + τ (k) d p i + τ (k p ) + p [i] ≡ k p (p -1) + 1 -ed p i + τ (k p ) d q i + τ (k q ) + q [i] ≡ k q (q -1) + 1 -ed q i + τ (k q ) . (<label>13</label></formula><formula xml:id="formula_24">)</formula><p>These are precisely <ref type="bibr" target="#b10">(11)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Local Branching Behavior</head><p>Without additional knowledge of the keys, the system of equations in ( <ref type="formula" target="#formula_23">13</ref>) is underconstrained, and each partial satisfying assignment can be lifted to two partial satisfying assignments for slice i. If bit i -1 of a variable x is known, the corresponding x [i -1] is fixed to the value of this bit, and the new partial satisfying assignments correspond to solutions of ( <ref type="formula" target="#formula_23">13</ref>) with these bit values fixed. There can be zero, one, or two new solutions at bit i generated from a single solution at bit i -1, depending on the known values. Now that we have a framework for characterizing the partial solutions generated at step i from a partial solution generated at step i -1, we will assume that a random fraction δ of the bits of the key values are known, and estimate the expectation and variance of the number of these solutions that will be generated.</p><p>In order to understand the number of solutions to the equation, we would like to understand the behavior of the c i when the partial solution may not be equal to the real solution. Let Δx = xx , then substituting x = x -Δx into <ref type="bibr" target="#b12">(13)</ref> we see that any solution to <ref type="bibr" target="#b10">(11)</ref> corresponds to a solution to</p><formula xml:id="formula_25">Δp [i] + Δq [i] ≡ (qΔp + pΔq + ΔpΔq) [i] ( m o d2 ) Δd i + τ (k) + Δp [i] + Δq [i] ≡ (eΔd + kΔp + kΔq)) i + τ (k) (<label>mod 2</label></formula><p>)</p><formula xml:id="formula_26">Δd p i + τ (k p ) + Δp [i] ≡ (eΔd p -k p Δp) i + τ (k p ) (<label>mod 2</label></formula><p>)</p><formula xml:id="formula_27">Δd q i + τ (k q ) + Δq [i] ≡ (eΔd q -k q Δq) i + τ (k q ) (<label>mod 2)</label></formula><p>and Δx [i] is restricted to 0 if bit i of x is fixed.</p><p>Incorrect solutions generated from a correct solution. When the partial satisfying assignment is correct, all of the Δx will be equal to 0. If all of the Δx [i] are unconstrained or if only Δd [i + τ (k)] is set to 0, there will be two possible solutions (of which we know one is "good" and the other is "bad"), otherwise there will be a single good solution. Let Z g be a random variable denoting the number of bad solutions at bit i + 1 generated from a single good solution at bit i. Since each Δx [i] is set to 0 independently with probability δ, the expected number of bad solutions generated from a good solution is equal to</p><formula xml:id="formula_28">E Z g = δ(1 -δ) 4 + (1 -δ) 5 and E Z 2 g = E Z g .</formula><p>Both these expressions are dependent only on δ.</p><p>Incorrect solutions generated from an incorrect solution. When the partial satisfying assignment is incorrect, at least one of the Δx is nonzero. The expected number of new incorrect satisfying assignments generated from an incorrect satisfying assignment is dependent both on δ and on the behavior of the b j . We conjecture the following is close to being true:</p><p>Conjecture 1. For random p and q and for Δx not all zero and satisfying</p><formula xml:id="formula_29">qΔp + pΔq -ΔpΔq = 0 (mod 2 i ) eΔd + kΔp + kΔq = 0 (mod 2 i+τ (k) ) eΔd p -k p Δp = 0 (mod 2 i+τ (kp) )</formula><p>eΔd qk q Δq = 0 (mod 2 i+τ (kq) ) , the next bit of each congruence is 0 or 1 independently with probability near 1/2.</p><p>We tested this empirically; each value of the vector (b 1 , b 2 , b 3 , b 4 ) occurs with probability approximately 1/16. (The error is approximately 5% for δ = 0.25 and n = 1024, and approximately 2% for δ = 0.25 and n = 4096.) Let W b be a random variable denoting the number of bad solutions at bit i +1 generated from a single bad solution at bit i. Assuming Conjecture 1,</p><formula xml:id="formula_30">E W b = (2 -δ) 5 16 and E W 2 b = E W b + δ(1 -δ) 4 + 2(1 -δ) 5 .</formula><p>Note that the expectation is over the randomness of p and q and the positions of the unknown bits of the key.</p><p>When partial knowledge of some of the values (p, q, d, d p , d q ) is totally unavailable, we can obtain a similar expression.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Global Branching Behavior at Each Step of the Program</head><p>Now that we have characterized the effect that the constraints have on the branching behavior of the program, we can abstract away all details of RSA entirely and examine the general branching process of the algorithm. We are able to characterize the behavior of the algorithm, and show that if the expected number of branches from any partial solution to the program is less than one, then the total number of branches examined at any step of the program is expected to be constant. All of the following analysis assumes Conjecture 1.</p><p>Let X i be a random variable denoting the number of bad assignments at step i, and recall that Z g and W b are random variables denoting the number of bad solutions at bit i + 1 generated from a single good or bad solution at bit i.</p><p>Theorem 2</p><formula xml:id="formula_31">E X i = E Z g 1 -E W b (1 -(E W b ) i )</formula><p>This expression can be calculated in a number of ways; we demonstrate how to do so using generating functions in Appendix A. When E W b &lt; 1, we can bound E X i from above.</p><formula xml:id="formula_32">E X i ≤ E Z g 1 -E W b</formula><p>In the previous section, we calculated expressions for E Z g and E W b dependent only on δ, thus when E W b &lt; 1, E X i can be bounded above by a constant dependent on δ and not on i.</p><p>We can evaluate this expression numerically using the values for the expected number of bad solutions discovered in the last section.</p><p>In the case with four equations and five unknowns (that is, we have partial knowledge of p, q, d, d p , and d q ), E W b &lt; 1 at δ &gt; 2 -2 4 5 . For δ = .2589, E X i &lt; 93247; for δ = .26, E X i &lt; 95; and for δ = .27 E X i &lt; 9.</p><p>In a similar fashion we can obtain the following complicated expression for the variance Var</p><formula xml:id="formula_33">X i = E X 2 -(E X) 2 .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 3</head><p>Var</p><formula xml:id="formula_34">X i = α 1 + α 2 (E W b ) i + α 3 (E W b ) 2i<label>(14)</label></formula><p>with</p><formula xml:id="formula_35">α 1 = E Z g Var W b + (1 -E W b ) Var Z g (1 -(E W b ) 2 )(1 -E W b ) α 2 = E W 2 b + E W b -2 E W b E Z g -E Z g 1 -E W b + 2 E Z g 1 -E W b 2 α 3 = -α 1 -α 2 .</formula><p>Again evaluating numerically for five unknowns and four equations, at δ = .26 Var X i &lt; 7937, at δ = .27 Var X i &lt; 80, and at δ = .28 Var X i &lt; 23.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Bounding the Total Number of Keys Examined</head><p>Now that we have some information about the distribution of the number of partial keys examined at each step, we would like to understand the distribution of the total number of keys examined over an entire run of the program.</p><p>We know the expected total number of keys examined for an n-bit key is</p><formula xml:id="formula_36">E n i=0 X i ≤ E Z g 1 -E W b n .</formula><p>We will bound how far the total sum is likely to be from this expectation. First, we apply the following bound on the variance of a sum of random variables:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 2</head><p>Var n i=1</p><formula xml:id="formula_37">X i ≤ n 2 max i Var X i</formula><p>The proof writes the variance of the sum in terms of covariance, and applies Schwartz's inequality and √ ab ≤ a+b 2 . Apply Chebyshev's inequality to bound the likelihood that X i is too large:</p><formula xml:id="formula_38">Pr(| i X i -E i X i | ≥ nα) ≤ 1 (nα) 2 Var i X i .</formula><p>Apply the above lemma to obtain</p><formula xml:id="formula_39">Pr(| i X i -E i X i | ≥ nα) ≤ 1 α 2 max i Var X i .</formula><p>When δ = .27, setting α &gt; 9n gives that, for an n-bit key, the algorithm will examine more than 9n 2 + 71n potential keys with probability less than 1 n 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Missing Key Fields</head><p>The same results apply when we have partial knowledge of fewer key fields.</p><p>-If the algorithm has partial knowledge of d, p, and q but no information on d p and d q , we know that</p><formula xml:id="formula_40">E Z g = δ(1 -δ) 2 + (1 -δ) 3 E Z 2 g = E Z g E W b = (2 -δ) 3 4 E W 2 b = E W b + δ(1 -δ) 2 + 2(1 -δ) 3 , so E W b &lt; 1 when δ &gt; 2 -2<label>3</label></formula><p>4 ≈ .4126. Then for δ = .42 the probability that the algorithm examines more than 22n 2 + 24n keys is less than 1 n 2 . -If the algorithm has partial knowledge of p and q but no information on the other values,</p><formula xml:id="formula_41">E Z g = (1 -δ) 2 E Z 2 g = E Z g E W b = (2 -δ) 2 2 E W 2 b = E W b + 2(1 -δ) 2 . Then E W b &lt; 1 when δ &gt; 2 -2<label>1</label></formula><p>2 ≈ .5859. When δ = .59 the probability that the algorithm examines more than 29n 2 + 29n keys is less than 1 n 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Implementation and Performance</head><p>We We ran experiments for key sizes between 512 bits and 8192 bits, and for δ values between 0.40 and 0.24. The public exponent is always set to 65537. In each experiment, a key of the appropriate size is randomly censored so that exactly a δ fraction of the bits of the private key components considered together is available to be used for reconstruction. To reduce the time spent on key generation, we reused keys: We generated 100 keys for each key size. For every δ and keysize, we ran 100 experiments with each one of the pregenerated keys, for a total of 10,000 experimental runs. In all, we conducted over 1.1 million runs.</p><p>For each run, we recorded the length and width. The length is the total number of keys considered in the run of the algorithm, at all bit indices; the width is the maximum number of keys considered at any single bit index. These correspond essentially to n/2 i=1 X i and max i X i , in the notation of Section 4, but can be somewhat larger because we run the algorithm twice in parallel to account for both possible matchings of solutions of (10) to k p and k q . To avoid thrashing, we killed runs as soon as the width for some index i exceeded 1,000,000.</p><p>When the panic width was not exceeded, the algorithm always ran to completion and correctly recovered the factorization of the modulus.</p><p>Of the 900,000 runs of our algorithm with δ ≥ 0.27, only a single run (n = 8192, δ = 0.27) exceeded the panic width. Applying a Chebyshev bound in this case (with E X i = 9 and Var X i = 80) suggests that a width of 1,000,000 should happen with extremely low probability.</p><p>Even below δ = 0.27, our algorithm almost always finished within the allotted time. Table <ref type="table" target="#tab_1">1</ref> shows the number of runs (out of 10,000) in which the panic width was exceeded for various parameter settings. Even for n = 8192 and δ = 0.24, our algorithm recovered the factorization of the modulus in more than 97% of all runs. And in many of the overly long runs, the number of bits recovered before the panic width was exceeded suffices to allow recovering the rest using the lattice methods considered in Section 2; this is true of 144 of the 274 very long runs at n = 8192 and δ = 0.24, for example. As expected, search runtime was essentially linear in the total number of keys examined. For n = 1024, for example, examining a single key took approximately 5 μsec; for n = 6144, approximately 8 μsec. The setup time varied depending on whether k was closer to 0 or to e, but never exceeded 210 msec, even for n = 8192.</p><p>The plot in Figure <ref type="figure">1</ref> gives the behavior for n = 2048. For each value of δ we show, using a boxplot, the distribution of the total number of keys examined by runs of the algorithm -i.e., the length of the run. (In our boxplot, generated using R's boxplot function, the central bar corresponds to the median, the hinges to the first and third quartiles, and the whisker extents depend on the interquartile range.)</p><p>In the full version of this paper <ref type="bibr" target="#b10">[11]</ref> we undertake additional analysis of the runtime data. This material is based in part upon work supported by the National Science Foundation under CNS grant no. 0831532 (Cyber Trust) and a Graduate Research Fellowship. Any opinions, findings, conclusions or recommendations expressed in this publication are those of the authors and do not necessarily reflect the views of the National Science Foundation.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>have developed an implementation of our algorithm in approximately 850 lines of C++, using NTL version 5.4.2 and GMP version 4.2.2. Our tests were run, in 64-bit mode, on an Intel Core 2 Duo processor at 2.4 GHz with 4 MB of L2 cache and 4 GB of DDR2 SDRAM at 667 MHz on an 800 MHz bus.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 .</head><label>1</label><figDesc>Runs (out of 10,000) in which width exceeded 1,000,000 Boxplot for total number of keys examined by algorithm for n = 2048, varying δ</figDesc><table><row><cell></cell><cell cols="9">n = 512 768 1024 1536 2048 3072 4096 6144 8192</cell></row><row><cell>δ = 0.27</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>1</cell></row><row><cell>0.26</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>1</cell><cell>5</cell><cell>3</cell><cell>4</cell><cell>8</cell></row><row><cell>0.25</cell><cell>0</cell><cell>0</cell><cell>3</cell><cell>6</cell><cell cols="5">8 10 17 35 37</cell></row><row><cell>0.24</cell><cell>4</cell><cell>5</cell><cell cols="7">7 27 50 93 121 201 274</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>There has been substantial other recent work on designing cryptosystems secure in related key-leakage models (e.g.,<ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b1">2]</ref>); for a survey, see Goldwasser's invited talk at Eurocrypt</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2009" xml:id="foot_1"><p><ref type="bibr" target="#b8">[9]</ref> and the references therein.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_2"><p>This is obvious for p and q and well known for d (cf.<ref type="bibr" target="#b6">[7]</ref>); dp reveals p as gcd(a edp-1 -1, N) with high probability for random a provided dp = dq, and similarly for dq; if dp and dq are equal to each other then they are also equal to d.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_3"><p>In fact, as we discussed in Section 2 above, information sufficient to factor N will be revealed much earlier, at i = n/4lg e .</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank Dan Boneh for suggesting the connection to Hensel lifting; Amir Dembo for improving our branching process analysis; Daniele Micciancio for extensive discussions on using lattice reduction to solve the knapsack problem implicit in our attack; and Eric Rescorla for his help with analyzing the observed runtimes of our algorithm.</p><p>In addition, we had fruitful discussions with J. Alex Halderman, Howard Karloff, and N. J. A. Sloane. We would also like to thank the anonymous Crypto reviewers for their comments and suggestions.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Computing the Expectation and Variance</head><p>In this appendix, we derive expressions for the expectation and variance of the number of incorrect keys generated at each step of the program. Let X i be a random variable denoting the number of bad assignments at step i. We will calculate the expectation E X i and variance Var X i . (We know that the number of good assignments is always equal to one.)</p><p>To calculate these values, we will use probability generating functions. For more information on this approach, see e.g., <ref type="bibr" target="#b12">[13,</ref><ref type="bibr">Ch. 8]</ref>. A probability generating function F (s) = Pr[X = k]s k represents the distribution of the discrete random variable X. F (s) satisfies the following identities:</p><p>Let G i (s) be the probability generating function for the X i , z(s) the probability generating function for the Z g (the number of bad assignments generated from a correct assignment) and w(s) the probability generating function for the W b (the number of bad assignments generated from a bad assignment).</p><p>From Section 4, we know that</p><p>and</p><p>that is, that the number of bad solutions at each step is equal to the number of bad solutions lifted from bad solutions plus the number of bad solutions produced from good solutions. (Recall that a generating function for the sum of two independent random variables is given by the convolution of their generating functions.) We also have that</p><p>because initially there are no bad solutions. Differentiating <ref type="bibr" target="#b14">(15)</ref> gives</p><p>Set s = 1 and use the fact that G i (1) = w(1) = z(1) = 1 to obtain</p><p>Solving the recurrence yields</p><p>If w (1) &lt; 1, then w (1) i tends to 0 as i increases and</p><p>for all i. The expected number of bad solutions at any step of the process will be bounded by a value dependent only on δ and not on i.</p><p>Variance of X i . To compute the variance Var</p><p>we differentiate <ref type="bibr" target="#b15">(16)</ref> again to obtain</p><p>Evaluating at s = 1 gives</p><p>Substitute in <ref type="bibr" target="#b16">(17)</ref> to get</p><p>The general solution to this recurrence is</p><p>with</p><p>(w (1) + 2w (1)z (1)) + z (1)</p><p>(w (1) + 2w (1)z ( <ref type="formula">1</ref>))</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Simultaneous hardcore bits and cryptography against memory attacks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Akavia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2009</title>
		<editor>
			<persName><forename type="first">O</forename><surname>Reingold</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5444</biblScope>
			<biblScope unit="page" from="474" to="495" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Public key cryptography in the bounded retrieval model and security against side-channel attacks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Alwen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wichs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2009</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5677</biblScope>
			<biblScope unit="page" from="36" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Twenty years of attacks on the RSA cryptosystem</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Notices of the American Mathematical Society</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="203" to="213" />
			<date type="published" when="1999">1999</date>
			<publisher>AMS</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">An attack on RSA given a small fraction of the private key bits</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Durfee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Frankel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 1998</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Ohta</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Pei</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1514</biblScope>
			<biblScope unit="page" from="25" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Fast variants of RSA</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Shacham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">RSA Cryptobytes</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="9" />
			<date type="published" when="2002">2002</date>
			<pubPlace>Winter/Spring</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Small solutions to polynomial equations, and low exponent RSA vulnerabilities</title>
		<author>
			<persName><forename type="first">D</forename><surname>Coppersmith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Cryptology</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="233" to="260" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Deterministic polynomial-time equivalence of computing the RSA secret key and factoring</title>
		<author>
			<persName><forename type="first">J.-S</forename><surname>Coron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>May</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Cryptology</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="39" to="50" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On cryptography with auxiliary input</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Tauman Kalai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lovett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of STOC 2009</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Mitzenmacher</surname></persName>
		</editor>
		<meeting>STOC 2009<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Cryptography without (hardly any) secrets</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2009</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Joux</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5479</biblScope>
			<biblScope unit="page" from="369" to="370" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Lest we remember: Cold boot attacks on encryption keys</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Halderman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Schoen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Heninger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Clarkson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Paul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Calandrino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Feldman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Appelbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Felten</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of USENIX Security</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Van Oorschot</surname></persName>
		</editor>
		<meeting>USENIX Security</meeting>
		<imprint>
			<publisher>USENIX</publisher>
			<date type="published" when="2008-07">2008. July 2008. 2008</date>
			<biblScope unit="page" from="45" to="60" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">N</forename><surname>Heninger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Shacham</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
		<title level="m">Reconstructing RSA private keys from random key bits. Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2008-12">2008. December 2008</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Solving linear equations modulo divisors: On factoring given any bits</title>
		<author>
			<persName><forename type="first">M</forename><surname>Herrmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>May</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2008</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Pieprzyk</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5350</biblScope>
			<biblScope unit="page" from="406" to="424" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Karlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">M</forename><surname>Taylor</surname></persName>
		</author>
		<title level="m">First Course in Stochastic Processes</title>
		<meeting><address><addrLine>London</addrLine></address></meeting>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">On the oracle complexity of factoring integers</title>
		<author>
			<persName><forename type="first">U</forename><surname>Maurer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Complexity</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3/4</biblScope>
			<biblScope unit="page" from="237" to="247" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">New RSA Vulnerabilities Using Lattice Reduction Methods</title>
		<author>
			<persName><forename type="first">A</forename><surname>May</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003-10">October 2003</date>
		</imprint>
		<respStmt>
			<orgName>University of Paderborn</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Using LLL-reduction for solving RSA and factorization problems: A survey</title>
		<author>
			<persName><forename type="first">A</forename><surname>May</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of LLL+25</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Nguyen</surname></persName>
		</editor>
		<meeting>LLL+25</meeting>
		<imprint>
			<date type="published" when="2007-06">June 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Menezes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>Van Oorschot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Vanstone</surname></persName>
		</author>
		<title level="m">Handbook of Applied Cryptography</title>
		<meeting><address><addrLine>Boca Raton</addrLine></address></meeting>
		<imprint>
			<publisher>CRC Press</publisher>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Public-key cryptosystems resilient to key leakage</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Segev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2009</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5677</biblScope>
			<biblScope unit="page" from="18" to="35" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Adapting density attacks to low-weight knapsacks</title>
		<author>
			<persName><forename type="first">P</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Stern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2005</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Roy</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3788</biblScope>
			<biblScope unit="page" from="41" to="58" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A leakage-resilient mode of operation</title>
		<author>
			<persName><forename type="first">K</forename><surname>Pietrzak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EURO-CRYPT 2009</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Joux</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5479</biblScope>
			<biblScope unit="page" from="462" to="482" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Efficient factoring based on partial information</title>
		<author>
			<persName><forename type="first">R</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 1985</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Pichler</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">219</biblScope>
			<biblScope unit="page" from="31" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">PKCS #1 v2.1: RSA cryptography standard</title>
		<author>
			<persName><surname>Rsa Laboratories</surname></persName>
		</author>
		<ptr target="http://www.rsa.com/rsalabs/node.asp?id=2125" />
		<imprint>
			<date type="published" when="2002-06">June 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Yilek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Rescorla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Shacham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Enright</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Savage</surname></persName>
		</author>
		<title level="m">When private keys are public: Results from the 2008 Debian OpenSSL debacle</title>
		<imprint>
			<date type="published" when="2009-05">May 2009</date>
		</imprint>
	</monogr>
	<note>manuscript</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
