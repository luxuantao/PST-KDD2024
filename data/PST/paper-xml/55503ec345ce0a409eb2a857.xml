<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Circuit ORAM: On Tightness of the Goldreich-Ostrovsky Lower Bound</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Shaun</forename><surname>Xiao</surname></persName>
						</author>
						<author>
							<persName><surname>Wang</surname></persName>
						</author>
						<author>
							<persName><forename type="first">T-H</forename><forename type="middle">Hubert</forename><surname>Chan</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Elaine</forename><surname>Shi</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">University of Maryland</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">University of Hong Kong</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Circuit ORAM: On Tightness of the Goldreich-Ostrovsky Lower Bound</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">341E6FB5ED087663440F3F400D002251</idno>
					<idno type="DOI">10.1145/2810103.2813634</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T09:19+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C</term>
					<term>2</term>
					<term>0 [Computer-Communication Networks]: Generalsecurity and protection Oblivious RAM; Secure Computation</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We propose a new tree-based ORAM scheme called Circuit ORAM. Circuit ORAM makes both theoretical and practical contributions. From a theoretical perspective, Circuit ORAM shows that the well-known Goldreich-Ostrovsky logarithmic ORAM lower bound is tight under certain parameter ranges, for several performance metrics. Therefore, we are the first to give an answer to a theoretical challenge that remained open for the past twenty-seven years. Second, Circuit ORAM earns its name because it achieves (almost) optimal circuit size both in theory and in practice for realistic choices of block sizes. We demonstrate compelling practical performance and show that Circuit ORAM is an ideal candidate for secure multi-party computation applications.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Oblivious RAM (ORAM), initially proposed by Goldreich and Ostrovsky <ref type="bibr" target="#b15">[17,</ref><ref type="bibr" target="#b17">19]</ref>, is a general cryptographic primitive that allows oblivious accesses to sensitive data, such that access patterns during the computation reveal no secret information. Since the original proposal of ORAM <ref type="bibr" target="#b17">[19]</ref>, it has been studied in various application settings including secure processors <ref type="bibr" target="#b10">[12,</ref><ref type="bibr" target="#b12">14,</ref><ref type="bibr" target="#b35">37,</ref><ref type="bibr" target="#b45">47]</ref>, cloud outsourced storage <ref type="bibr" target="#b19">[21,</ref><ref type="bibr" target="#b47">49,</ref><ref type="bibr" target="#b48">50,</ref><ref type="bibr" target="#b55">57]</ref> and secure multi-party computation <ref type="bibr" target="#b13">[15,</ref><ref type="bibr" target="#b14">16,</ref><ref type="bibr" target="#b23">25,</ref><ref type="bibr" target="#b26">28,</ref><ref type="bibr" target="#b31">33,</ref><ref type="bibr" target="#b51">53]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Rethinking ORAM Metric for Secure Computation</head><p>When ORAM was previously considered for cloud outsourcing and secure processor applications, its bandwidth Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from Permissions@acm.org. CCS'15, October 12-16, 2015, Denver, Colorado, USA. cost <ref type="bibr" target="#b19">[21,</ref><ref type="bibr" target="#b46">48,</ref><ref type="bibr" target="#b48">[50]</ref><ref type="bibr" target="#b49">[51]</ref><ref type="bibr" target="#b50">[52]</ref> was used as a primary metric of performance, since it is well-understood that bandwidth is the main performance bottleneck in these scenarios. As a result, many existing ORAM schemes focused on optimizing the bandwidth metric <ref type="bibr" target="#b19">[21,</ref><ref type="bibr" target="#b46">48,</ref><ref type="bibr" target="#b48">[50]</ref><ref type="bibr" target="#b49">[51]</ref><ref type="bibr" target="#b50">[52]</ref>.</p><p>With the new tree-based ORAM framework, it became feasible to implement ORAM atop secure multi-party computation (MPC) <ref type="bibr" target="#b23">[25,</ref><ref type="bibr" target="#b26">28,</ref><ref type="bibr" target="#b51">53]</ref>. It is well-understood that ORAM carries the promise of scaling MPC to big data <ref type="bibr" target="#b31">[33,</ref><ref type="bibr" target="#b51">53]</ref>.As a result, the community is interested in optimized ORAM constructions for MPC <ref type="bibr" target="#b13">[15,</ref><ref type="bibr" target="#b23">25,</ref><ref type="bibr" target="#b26">28,</ref><ref type="bibr" target="#b34">36,</ref><ref type="bibr" target="#b51">53]</ref>. One recent revelation <ref type="bibr" target="#b51">[53]</ref> is that ORAMs optimized for the bandwidth metric are not necessarily the best for the MPC scenario. Instead, MPC demands a new metric of ORAM schemes, namely, the circuit complexity. In a standard ORAM setting, a client interacts with a server multiple rounds to make an ORAM access, and performs computation in between these accesses. In an MPC scenario, the ORAM client's computation will be expressed as circuits that will be securely evaluated between the multiple parties. Therefore, an ORAM's circuit complexity is the total circuit size of the ORAM client algorithm over all rounds of interaction <ref type="bibr" target="#b51">[53]</ref>. Furthermore, for several MPC protocols <ref type="bibr" target="#b16">[18,</ref><ref type="bibr" target="#b56">58]</ref> where XOR operations are essentially free <ref type="bibr" target="#b28">[30]</ref>, the number of AND gates is the primary performance metric.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">The Quest for ORAMs with Optimal Circuit Complexity</head><p>Due to increasing interest of implementing ORAMs to scale up MPC, the hunt is on for an ORAM scheme with optimal circuit complexity. Our new ORAM scheme, Circuit ORAM, is the first to give a compelling solution to this question in both practical and theoretical senses.</p><p>Compelling practical performance. In comparison with known ORAM schemes, Circuit ORAM achieves 58.4X improvement in terms of number of non-free gates <ref type="bibr" target="#b28">[30]</ref> over a straightforward implementation of Path ORAM <ref type="bibr" target="#b50">[52]</ref>, 31X improvement over the binary-tree ORAM <ref type="bibr" target="#b46">[48]</ref>, and 5.1X improvement over the recent SCORAM <ref type="bibr" target="#b51">[53]</ref> -a heuristic ORAM scheme without theoretical performance bounds. These performance numbers are attained for a moderately large database of 4GB and with a 2 80 security failure probability. Our performance gains are asymptotic, so Circuit ORAM's improvement will be even greater for bigger data sizes.</p><p>Several earlier works on RAM-model MPC also investigated at what data sizes ORAM starts to outperform the trivial linear-scan ORAM, a metric referred to as the breakeven point with trivial ORAM. Previous implementations reported this breakeven point to be rather large. For example, Gordon et al. <ref type="bibr" target="#b23">[25]</ref> who implemented the binary-tree ORAM <ref type="bibr" target="#b46">[48]</ref> reported a breakeven point of 8MB with a block size of 512 bits and a security failure probability of roughly 2 14 . Under the same block size, we achieve an 8KB breakeven point (an 1000X improvement) at a much tighter failure probability of 2 80 ! Theoretical near-optimality. For block sizes of D = ‚å¶(log<ref type="foot" target="#foot_1">2</ref> N ) bits or higher, Circuit ORAM achieves a circuit size of O(D log N )!(1) gates for a negl(N ) failure probability<ref type="foot" target="#foot_0">1</ref> . This is almost optimal since the well-known logarithmic ORAM lower bound <ref type="bibr" target="#b17">[19]</ref> is immediately applicable to the circuit size metric as well. We discuss situations when the logarithmic ORAM lower bound <ref type="bibr" target="#b17">[19]</ref> is tight in the following section.</p><p>Table <ref type="table" target="#tab_1">1</ref> compares the circuit size of Circuit ORAM and existing works, both in terms of asymptotics and concrete performance numbers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">On Tightness of the Goldreich-Ostrovsky ORAM Lower Bound</head><p>For theoretical discussions regarding the tightness of the Goldreich-Ostrovsky ORAM lower bound, we consider several additional metrics besides circuit size, such as number of accesses and bandwidth blowup. We elaborate on these various metrics in Section 7.2.</p><p>In their seminal work, Goldreich and Ostrovsky <ref type="bibr" target="#b15">[17,</ref><ref type="bibr" target="#b17">19]</ref> showed a logarithmic lower bound for any ORAM construction. While not explicitly stated in their work, it is clear that this lower bound is very "powerful" in the sense that it holds i) for arbitrary block sizes, ii) for several relevant metrics including number of accesses, bandwidth blowup, and circuit size 2 ; and iii) even when tolerating up to O(1) statistical failure probability.</p><p>For mildly large block sizes of ‚å¶(log 2 N ), Circuit ORAM achieves O(D log N + D log 1 ) cost in terms of both circuit size and bandwidth cost, where is the failure probability. This means that for any f (N ) = !(1), there is an ORAM scheme that achieves O(D log N )f (N ) circuit size or bandwidth cost, such that its statistical failure probability is bounded by some negligible function negl(N ). In other words, for the circuit size or bandwidth cost metrics, the Goldreich-Ostrovsky lower bound is asymptotically tight for ‚å¶(log 2 N ) block size and negligible failure probabilities. Equivalently, we rule out any g(N ) lower bound where g(N ) = !(log N ).</p><p>As we elaborate in Appendix 8 <ref type="foot" target="#foot_2">3</ref> , we also show the tightness of the lower bound for the classical runtime blowup metric, but under a bigger block size of ‚å¶(N ‚úè ) bits for an arbitrary constant 0 &lt; ‚úè &lt; 1.</p><p>To summarize, one way to view our tightness result is the following: we give explicit and broad parameter ranges under which no asymptotically tighter lower bound can be proven. While this provides only a partial answer to the tightness of the Goldreich-Ostrovsky lower bound, we stress that for the past twenty-seven years, the tightness of the lower bound has not been demonstrated for any parameter ranges at all.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">Technical Highlights</head><p>Path ORAM has a complex eviction circuit. In the secure processor setting, Path ORAM <ref type="bibr" target="#b50">[52]</ref> and its improved variants <ref type="bibr" target="#b12">[14,</ref><ref type="bibr" target="#b14">16,</ref><ref type="bibr" target="#b45">47]</ref> o‚Üµer the best performance in terms of bandwidth cost. Therefore, the first natural idea is to try out Path ORAM for the MPC setting too. Unfortunately, Path ORAM's eviction circuit is complex, and would result in O(D log 2 N ) size with a naive implementation. Although Wang et al. noted that Path ORAM's eviction algorithm can be implemented with a circuit of size O(D log N log N log N )!(1) using oblivious sorting <ref type="bibr" target="#b18">[20]</ref>, they also show that oblivious sorting makes the practical performance even worse than the naive O(D log 2 N ) implementation for typical parameter ranges.</p><p>One thing to note is that Path ORAM's eviction algorithm in some sense performs (oblivious) sorting on ‚á•(log N ) items (imagine that bucket size were 1). Therefore, to do better we need a fundamentally di‚Üµerent idea.</p><p>Reducing eviction complexity. Our idea is to find an eviction circuit that is less complex than that of Path ORAM's, and yet preserves the e‚Üµectiveness of eviction. Achieving this is non-trivial. We first tested numerous ideas empirically, most of which failed to empirically bound the stash size since the eviction algorithm is not as aggressive as Path ORAM. After months of trying, we eventually identified a good empirical candidate, which in turn inspired the design of its provable variant, Circuit ORAM, that is documented in this paper.</p><p>Just like Path ORAM <ref type="bibr" target="#b50">[52]</ref> and its variants <ref type="bibr" target="#b12">[14,</ref><ref type="bibr" target="#b14">16]</ref>, Circuit ORAM performs eviction on O(1) number of paths upon each data access. Our key idea is to complete the eviction algorithm within a single block scan of the current eviction path (while evicting as aggressively as we can). Achieving this directly introduces some di culties due to a "lack-offoresight" problem, i.e., the ORAM client does not know when to pick up a block and remove it from the path, and when to drop it into an empty slot on the path. To tackle this problem, we leverage two additional metadata scans to precompute the foresight required, before beginning the real block scan. Our construction and proofs share common themes with Path ORAM <ref type="bibr" target="#b50">[52]</ref> and the CLP ORAM <ref type="bibr" target="#b5">[7]</ref>. However, our construction and proofs di‚Üµer in a substantial and non-trivial manner from either Path ORAM or CLP ORAM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.5">Related Work</head><p>Hierarchical ORAMs. Oblivious RAM was first proposed in a groundbreaking work by Goldreich and Ostrovsky <ref type="bibr" target="#b17">[19]</ref>. In addition to the aforementioned lower bound, Goldreich and Ostrovsky were the first to propose a poly-logarithmic hierarchical construction, which was subsequently improved in numerous works <ref type="bibr">[6, 17, 19, 21-24, 32, 35, 36, 42-44, 54-57]</ref>. Most of these hierarchical ORAM schemes are expensive in practice for MPC applications, not only due to their asymptotical poly-logarithmic cost (as opposed to logarithmic), but also crucially, because the ORAM client in these schemes must compute a PRF function -in an MPC application, this PRF would have to be securely evaluated using a multi-party protocol. Further, all schemes dependent on O(D log 2 N + C PRF log N ) linear scan KLO12 <ref type="bibr" target="#b30">[32]</ref> O((D + C PRF ) ‚Ä¢ log 2 N/ log log N ) LO13 <ref type="bibr" target="#b34">[36]</ref> O((D + C PRF ) ‚Ä¢ log N ) (63488M) (Note: 2-server model)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Tree-based ORAMs</head><p>Binary-tree ORAM <ref type="bibr" target="#b46">[48]</ref> O((D + log 2 N ) log 2 N )!(1) 30.1M CLP13 <ref type="bibr" target="#b5">[7]</ref> (naive circuit) O((D + log 2 N ) log 3 N )!(1) 37.9M CLP13 <ref type="bibr" target="#b5">[7]</ref> (w/ oblivious queue <ref type="bibr" target="#b37">[39,</ref><ref type="bibr" target="#b43">45,</ref><ref type="bibr" target="#b57">59]</ref>)</p><p>O((D + log 2 N ) log 2 N )!(1) 37.9M Path ORAM (naive circuit) <ref type="bibr" target="#b50">[52]</ref> O((D + log 2 N ) log 2 N )!(1) 56.6M Path ORAM (o-sort circuit) <ref type="bibr" target="#b51">[53]</ref> O((D cuckoo hashing <ref type="bibr" target="#b19">[21,</ref><ref type="bibr" target="#b30">32,</ref><ref type="bibr" target="#b34">36]</ref> (including the two-server ORAM by Lu and Ostrovsky <ref type="bibr" target="#b34">[36]</ref>) require the smallest level to have size‚å¶ (log 7 N ) to tightly bound the failure probability of cuckoo hashing. Technically, this means that these schemes basically reduce to the trivial ORAM (or the Goldreich-Ostrovsky ORAM <ref type="bibr" target="#b15">[17,</ref><ref type="bibr" target="#b17">19]</ref>) for N &lt; 2 37 .</p><formula xml:id="formula_0">+ log 2 N ) log N log log N )!(1) 41.4M Circuit ORAM (This Paper) O((D + log 2 N)logN)!(1) 0.97M</formula><p>Tree-based ORAM framework. The tree-based ORAM framework, initially proposed by Shi et al. <ref type="bibr" target="#b46">[48]</ref>, departs fundamentally from the hierarchical framework <ref type="bibr" target="#b17">[19]</ref>, and is a new paradigm for constructing a class of ORAM schemes. Several later works <ref type="bibr" target="#b5">[7,</ref><ref type="bibr" target="#b13">15,</ref><ref type="bibr" target="#b50">52]</ref> improved Shi et al.'s initial construction <ref type="bibr" target="#b46">[48]</ref> (commonly referred to as binary-tree ORAM). These schemes are conceptually simpler, statistically secure, and easy to implement in secure processors <ref type="bibr" target="#b10">[12,</ref><ref type="bibr" target="#b12">14,</ref><ref type="bibr" target="#b35">37,</ref><ref type="bibr" target="#b45">47]</ref> or MPC applications <ref type="bibr" target="#b14">[16,</ref><ref type="bibr" target="#b23">25,</ref><ref type="bibr" target="#b26">28,</ref><ref type="bibr" target="#b31">33,</ref><ref type="bibr" target="#b51">53]</ref>. A more detailed description of tree-based ORAMs are provided in Section 2.</p><p>Remarks about the ORAM lower bound. Besides efforts at constructing more e cient upper bounds, the community has also been interested in tightening the lower bound. Beame and Machmouchi <ref type="bibr" target="#b3">[5]</ref> show a super-logarithmic lower bound for oblivious branching programs. Although some works cited their lower-bound as being applicable to the ORAM setting <ref type="bibr" target="#b6">[8,</ref><ref type="bibr" target="#b19">21]</ref>, it was later recognized that Beame et al.'s super-logarithmic lower bound is not applicable to the standard model of Oblivious ORAM. As the authors noted themselves in an updated version <ref type="bibr" target="#b3">[5]</ref>, one key di‚Üµerence is that the standard ORAM model requires that the probability distribution of the observed access patterns be statistically close regardless of the input; whereas Beame's model requires that for each given random string r, the access pattern be independent of the input. Therefore, their super-logarithmic lower-bound is in a much stronger model than standard ORAM, and hence inapplicable to ORAM. To date, Goldreich and Ostrovsky's original lower bound is still the best we know.</p><p>Oblivious storage and server-side computation. The original ORAM model proposed by Goldreich and Ostrovsky assumes a passive server (or memory) that does not perform computation. However, several subsequent works leveraged server-side computation to improve performance <ref type="bibr" target="#b7">[9,</ref><ref type="bibr" target="#b8">10,</ref><ref type="bibr" target="#b36">38,</ref><ref type="bibr" target="#b44">46,</ref><ref type="bibr" target="#b55">57]</ref> or reduce the number of roundtrips <ref type="bibr" target="#b54">[56]</ref>.</p><p>To distinguish this server-computation setting from standard ORAM, we refer to it as oblivious storage as suggested by several earlier works <ref type="bibr" target="#b1">[3,</ref><ref type="bibr">6]</ref>. Apon et al. <ref type="bibr" target="#b1">[3]</ref> point out that the Goldreich-Ostrovsky lower bound is not applicable to the oblivious storage setting for the bandwidth metric. In fact, one can construct oblivious storage schemes with constant bandwidth blowup but with poly-logarithmic server work. <ref type="bibr" target="#b8">[10]</ref>.</p><p>Most of existing oblivious storage schemes (with server computation) are unsuitable for the MPC setting, because they focus on optimizing the client-server bandwidth while paying the price of higher, typically poly-logarithmic server work. In an MPC setting, all server-side work must be securely evaluated using an MPC protocol which immediately incurs poly-logarithmic circuit size, and is thus expensive.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Subsequent work.</head><p>Circuit ORAM is now provided as the default ORAM implementation in the ObliVM secure computation framework by Liu et al. <ref type="bibr" target="#b32">[34]</ref>. ObliVM is based on garbled circuits, and at the front-end provides expressive programming abstractions and language features for nonspecialist programmers. Using Liu et al.'s ObliVM framework, in Section 5.1 we provide more detailed end-to-end performance of Circuit ORAM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PRELIMINARIES</head><p>Definitions. Our definition of Oblivious RAM (ORAM) is standard, and we therefore defer formal definitions to Appendix 7.1 <ref type="bibr">[1]</ref>. Below, we introduce the tree-based ORAM framework.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Tree-based ORAM Framework</head><p>Shi et al. proposed a new tree-based framework <ref type="bibr" target="#b46">[48]</ref>, which was adopted subsequently by several improved con-structions <ref type="bibr" target="#b5">[7,</ref><ref type="bibr" target="#b13">15,</ref><ref type="bibr" target="#b38">40,</ref><ref type="bibr" target="#b50">52,</ref><ref type="bibr" target="#b51">53]</ref>. We now briefly review the framework.</p><p>Notation. We use N to denote the number of (real) data blocks in ORAM, D to denote the bit-length of a block in ORAM, Z to denote the capacity of each bucket in the ORAM tree, and to denote the ORAM's statistical security parameter. When discussing binary trees of depth L = log N + 1 in this paper, we say the leaves are at level L and the root is at level 1. For convenience in algorithm descriptions, we sometimes treat the stash as a depth-0 bucket with some capacity R that is the imaginary parent of the root. We assume that leaves are numbered sequentially from 0 to N 1. We also denote [a..b] := {a, a + 1, . . . , b}.</p><p>Data structure. The server organizes blocks into a binary tree of height L = log N + 1; each node of the tree is a bucket containing Z blocks. Each block is of the form:</p><formula xml:id="formula_1">{idx||label||data},</formula><p>where idx is the index of a block, e.g., the (logical) address of desired block; label is a leaf identifier specifying the path on which the block resides; and data is the payload of the block, of D bits in size.</p><p>The client stores a stash for bu‚Üµering overflowing blocks. In certain schemes such as the original binary-tree scheme <ref type="bibr" target="#b46">[48]</ref>, such a stash is not necessary. In this case, we can simply treat this as a degenerate stash of size 0.</p><p>The client also stores a position map, mapping a block's idx to a leaf label. As described later, position map storage can be reduced to O(1) by recursively storing the position map in a smaller ORAM. These leaf labels are assigned randomly and are reassigned as blocks are accessed. If we label the leaves from 0 to N 1, then each label is associated with a path from the root to the corresponding leaf.</p><p>Main path invariant. Tree-based ORAMs maintain the invariant that a block marked label resides on the path from the stash (to the root) to the leaf node marked label.</p><p>Operations. Tree-based ORAMs all follow a similar recipe as shown in Figure <ref type="figure" target="#fig_1">1</ref>. In particular, the ReadAndRm operation would read every block on the path leading to the leaf node marked label, and fetches and removes the block idx from the path.</p><p>Various tree-based ORAMs are di‚Üµerentiated by the eviction algorithm denoted Evict(). For example, the original binary-tree ORAM adopts a simple eviction algorithm engineered to make their proof easy: with each data access, two distinct buckets are chosen at random from each level to evict from. By contrast, the Path ORAM algorithm performs eviction on the read path, and the eviction strategy is aggressive: pack all blocks as close to the leaf as possible respecting the main invariant. In Path ORAM, a O(log N ) ‚Ä¢ !(1) stash is necessary to bu‚Üµer overflowing blocks.</p><p>Recursion. Instead of storing the entire position map in the client's local memory, the client can store it in a smaller ORAM on the server. In particular, this position map ORAM needs to store N labels each of log N bits. We can apply this idea recursively until we get down to a constant amount of metadata, which the client could store locally.</p><p>As mentioned in Appendix 8 [1], we will leverage the "big block, little block" trick first proposed by Stefanov et al. <ref type="bibr" target="#b50">[52]</ref> to parametrization the recursion, such that the recursion does not introduce additional asymptotic cost in terms of circuit size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Circuit ORAM</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Overview</head><p>Circuit ORAM follows the tree-based ORAM framework, by building a binary tree containing N nodes (referred to as buckets), where each bucket can store Z = O(1) number of blocks.</p><p>Stash. As later proved in Theorem 1 and 2, with probability at least 1 2 ‚å¶(R) , the stash holds at most R blocks. We can parameterize R = O(log N ) ‚Ä¢ !(1) to obtain a failure probability negligible in N . To achieve O(D) bits of client space, this stash can be stored on the server side, and operated on by the client in each data access obliviously. For convenience, we will often refer to the stash as being the 0-th level on the path, i.e., path[0].</p><p>Operations. The data access algorithm Access follows the same structure as in the binary-tree ORAM <ref type="bibr" target="#b46">[48]</ref> or Path ORAM <ref type="bibr" target="#b50">[52]</ref> -explained in Figure <ref type="figure" target="#fig_1">1</ref> in Section 2. It su ces for us to describe how eviction is implemented in Circuit ORAM, which we will focus on in the remainder of this section.</p><p>Definition 1 (Legally reside). We say that a block B can legally reside in path[`] if by placing B in path[`], the main path invariant is satisfied.</p><p>Definition 2 (Deepness w.r.t eviction path). For a given eviction path denoted path, block B0 is deeper than block B1 (with respect to path), if there exists some path[`] such that B0 can legally reside in path[`], but B1 cannot; in the case when both blocks can legally reside in the same buckets along path, the block with smaller index idx will be considered deeper.</p><p>In other words, B0 is deeper on the current eviction path than B1 if it can legally reside nearer to the leaf along path. If two blocks have the same deepness, we use their indices idx to resolve ambiguity. This will be useful later in our proofs.</p><p>Our notion of deepness and the greedy eviction choice of the deepest block on a path are inspired by the novel ideas of the CLP ORAM <ref type="bibr" target="#b5">[7]</ref> -but it will soon become apparent that we apply it in a fundamentally di‚Üµerent manner.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Intuition</head><p>We would like to have an eviction algorithm that is easy to implement as a small circuit. Ideally it should make a single scan of the data blocks on the eviction path from the stash to leaf (and only a constant number of metadata scans), and still try to push blocks towards the leaf as much as possible.</p><p>During the one-pass scan of the data blocks, we would like the client to "pick up" (i.e., remove from path) and hold onto one block, which can later be "dropped" somewhere further along the path. At any point of time, the client should hold onto at most one block. Further, it makes sense for the client to hold onto the currently deepest block when it does decide to hold a block. This way, the block in holding will have the maximum chance of being dropped later. On encountering a deeper block, the client could swap it with the one in holding. However, a dilemma arises. How does the client decide when it should pick up a block and hold onto it? Maybe this block will never get a chance to be dropped later, in which case there will be two equally bad choices: 1) put the block into the stash -which results in rapid stash growth; and 2) go back and revisit the path to write the block back. However, doing this obliviously results in high cost.</p><p>Remedy: lookahead mechanism with two metadata scans. The above issues result from the lack of foresight. If the client could only know when to pick up a block and place it in holding, and when to write the block back into an available slot, then these issues would have been resolved. Our idea, therefore, is to rely on two metadata scans prior to the real block scan, to compute all the information necessary for the client to develop this foresight. These metadata scans need not touch the actual blocks on the eviction path, but only metadata information such as the leaf label for each block, and the dummy bit indicator for each block. If the bucket size is O(1), then the bandwidth blowup is O(log N ). The most technical part of the proof is to show that the stash size is still O(log N ) with similar failure probability as Path ORAM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Detailed Scheme Description</head><p>To describe a circuit representation of our eviction algorithm, we write it as an oblivious algorithm. A program is oblivious if its memory accesses do not depend on secret inputs. In other words, all memory addresses can be statically inferred from public values. When we construct a circuit, the circuit's wiring must be statically inferred (as opposed to at runtime). This is exactly why an oblivious (and deterministic program) can easily be encoded as a circuit.</p><p>A slow and non-oblivious version of the eviction algorithm. To aid understanding, we first describe a slow, non-oblivious version of our eviction algorithm, EvictOnceSlow, as shown in Algorithm 1. This slow version only serves to illustrate the e‚Üµect of the eviction algorithm, but does not describe how the algorithm can be e ciently implemented in circuit. Furthermore, this slow, non-oblivious version of our eviction algorithm gives a simpler way to reason about the stash usage of the algorithm, and hence will facilitate our proofs later. Later in this section, we describe how to implement our eviction algorithm e ciently and obliviously by making use of two metadata scans and a one real block scan; this can be readily converted into a small-sized circuit.</p><p>The EvictOnceSlow algorithm makes a reverse (i.e., leaf to stash) scan over the current eviction path. When it first encounters an empty slot in path[i], it will try to evict the deepest block B in path[0..i 1] to this empty slot, provided that the block B can legally reside in path <ref type="bibr">[i]</ref>. Suppose this deepest block B resides in path[`] where `&lt; i. After relocating the block B to path[i], the algorithm now skips levels path[`+ 1..i 1], and continues its reverse scan at level `instead (Line 8 in Algorithm 1). In case no block in path[0..i 1] can fill the empty slot in path[i], the scan simply continues to level path[i 1].</p><p>E cient and oblivious implementation of our eviction algorithm. In Algorithm 1, Line 4 is ine cient, and Line 8 is non-oblivious. We now explain how to implement the same EvictSlow algorithm obliviously and e ciently, but using two metadata scans (Algorithms 2 and 3) plus a single real block scan (Algorithm 4). Since metadata is typically much smaller than real data blocks, a metadata scan is faster than a real block scan.</p><p>The two metadata scans will generate two helper data structures:</p><p>‚Ä¢ the deepest block in path[i] will be evicted to. This target array is prepopulated using a backward metadata scan as depicted in the PrepareTarget algorithm (see Algorithm 3). Observe that the prepopulated target array basically gives a precise prescription of the client's actions (including when to pick up a block and when to drop it) during the real block scan. At this moment, the client performs a forward block scan from stash to leaf, as depicted in the EvictOnceFast algorithm (see <ref type="bibr">Algorithm 4)</ref>. The high level idea here is to "hold a block in one's hand" as one scans through the path, where the block-in-hand is denoted as hold in the algorithm. This block hold will later be written to its appropriate destination level, when the scan reaches that level.</p><p>Example. To aid understanding, a detailed example, including the PrepareDeepest, PrepareTarget, and the EvictOnceFast steps, is given in Figure <ref type="figure">2</ref>.</p><p>Eviction rate and choice of eviction path. For each data access, two paths are chosen for eviction using the EvictOnceFast algorithm. While other approaches are conceivable, we describe two simple ways for choosing the eviction paths: `:= Deepest level that a block in path[i] can legally reside on path.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>8:</head><p>if `&gt; goal then 9:</p><p>goal := `, src := i 10:</p><p>end if 11: end for the stash and the root. This means that one path is randomly chosen from each of the left and the right branches of the root.</p><p>‚Ä¢ A deterministic-order strategy denoted as EvictDeterministic() (Algorithm 6). This is inspired by Gentry et al. <ref type="bibr" target="#b13">[15]</ref> and several subsequent works <ref type="bibr" target="#b11">[13,</ref><ref type="bibr" target="#b14">16]</ref>.</p><p>Recursion. So far, we have assumed that the client stores the entire position map. Based on a standard trick <ref type="bibr" target="#b46">[48,</ref><ref type="bibr" target="#b49">51,</ref><ref type="bibr" target="#b50">52]</ref>, we can recursively store the position map on the server. In the position map recursion levels, we will use a di‚Üµerent block size than the main data level as suggested by Stefanov et al. <ref type="bibr" target="#b50">[52]</ref>. Specifically, we group c number of labels in one block for an appropriate constant c &gt; 1. In other words, the block size for position map levels is set to be D 0 = O(log N ), resulting in O(log N ) depth of recursion. In this way, our total bandwidth cost over all recursion levels would be O(D log N + log 3 N ) ‚Ä¢ !(1) (for negligible failure probability), assuming that the stashes reside on the server side, and the hence client only needs to hold a constant number of blocks at any time. For inverse polynomial failure probability, the total bandwidth cost is O(D log N +log 3 N ).</p><p>Security proof. The security proof is trivial. First, as in all tree-based ORAMs, every time a block is read or written, a random path is read, where the random choice has not been revealed to the server before. This part of the proof is trivial, and the same as Shi et al. <ref type="bibr" target="#b46">[48]</ref>. We now show that the eviction process is oblivious too. As we can see from Algorithms 2,3 and 4, eviction on a selected path always reads blocks or metadata (stored on the server) in a sequential manner, either from leaf to root or from root to leaf. Clearly this does not depend on the logical address being read or written. In fact, saying that our eviction algorithm (Algorithms 4) is oblivious is the same as saying that it can be implemented e ciently in circuit representation! Finally, no matter whether we use random-order eviction (Algorithm 5) or deterministic order eviction (Algorithm 6), the choice of the eviction path is also independent of the logical address sequence being read/written.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Theoretical Bounds</head><p>Although our scheme superficially borrows the "deepest" idea from the CLP ORAM, and borrows the "eviction on a path" idea from Path ORAM, we stress that our construction is fundamentally di‚Üµerent from either which necessitates novel proof techniques.</p><p>A slightly modified Circuit ORAM construction. For subtle technical reasons, in our proofs we need to make a minor modification to the main construction. Since this modification is not very interesting, we did not document it in our main scheme for clarity. The modification involves introducing an additional partial eviction performed on the read path, simply to fill up the hole that is newly created by the Algorithm 3 PrepareTarget(path) /*Make a leaf-to-root linear metadata scan to prepare the target array. */ After this algorithm, if target[i] 6 = ?, then one block shall be moved from path[i] to path[target <ref type="bibr">[i]</ref>] in EvictOnceFast(path). */ 1: dest := ?, src := ?, target := (?, ?, . . . , ?) 2: for i = L downto 0 do: ReadAndRm operation. A partial eviction works just like a normal eviction, but works on only part of the path upto the point where the the block is removed (and for obliviousness dummy eviction operations are performed for the rest of the path). We refer the readers to Appendix 9 [1] for a detailed description of the modification. This additional modified partial eviction is only necessary to to show an equivalence between a post-processed 1-ORAM and the real ORAM (see Section 4 and Appendix 9 for more details).</p><p>In our experiments described in Section 5, we also chose not to implement this partial eviction -this leads to slightly better empirical results. However, even if one chooses to implement this partial eviction in practice, it would only incur a small constant factor penalty.</p><p>Stash bounds. We prove stash bounds for both randomorder and deterministic-order eviction. Below we give the formal theorem statements but defer their proofs to the appendices.</p><p>Theorem 1 (Stash growth for random eviction). Let the bucket size Z 5. Let st(ORAM Z [s]) be a random variable denoting the stash size after access sequence s for a Circuit ORAM with bucket size Z and randomized eviction. Then, for any access sequence s,</p><formula xml:id="formula_2">Pr h st(ORAM Z [s]) &gt; R i Ô£ø 42 ‚Ä¢ 0.6 R</formula><p>where probability is taken over the ORAM algorithm's randomness.</p><p>The detailed proof of this theorem is deferred to Appendix 9 and 10.1. .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 2. (Stash growth for deterministic eviction).</head><p>Let the bucket size Z 4. Let st(ORAM Z [s]) be a random variable denoting the stash size after access sequence s for a Circuit ORAM with bucket size Z and deterministic eviction. Then, for any access sequence s,</p><formula xml:id="formula_3">Pr h st(ORAM Z [s]) &gt; R i Ô£ø 14 ‚Ä¢ e R ,</formula><p>where probability is taken over the ORAM algorithm's randomness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 4 EvictOnceFast(path)</head><p>1: Call the PrepareDeepest and PrepareTarget subroutines to pre-process arrays deepest and target. 2: hold := ?, dest := ?. Place towrite into bucket path[i] if towrite 6 = ?. 14: end for Algorithm 5 EvictRandom() 1: Choose a leaf from each of the left and the right branches of the root independently, and denote the two corresponding (stash-to-leaf) paths by path 0 and path 1 . 2: Call EvictOnceFast(path 0 ) and EvictOnceFast(path 1 ) Algorithm 6 EvictDeterministic()</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>In timestep t:</head><p>1: Choose two paths, path 0 and path 1 , corresponding to the leaves labeled with integers bitrev(2t mod N ) and bitrev((2t + 1) mod N ), respectively. In the above bitrev(i) denotes the integer obtained by reversing the bit order of i when expressed in binary. 2: Call EvictOnceFast(path 0 ) and EvictOnceFast(path 1 ) 3: Increase t by 1 for the next access.</p><p>The detailed proof of this theorem is deferred to Appendix 9 and 10.2 [1]. . While our formal proof requires Z 5 for randomized eviction and Z 4 for deterministic-order eviction, empirical results show that choosing Z = 3 for randomized eviction and Z = 2 for deterministic eviction would result in bounded stash size R with failure probability 2 ‚á•(R) .</p><p>Theorem 3 (Circuit size bound). Circuit ORAM achieves O((D+log 2 N )(log N +log 1 )) circuit size for a statistical failure probability of . Specifically, if the block size D = ‚å¶(log 2 N ), then Circuit ORAM achieves O(D(log N + log 1 )) circuit size for a statistical failure probability of .</p><p>Proof. For D = ‚å¶(log 2 N ), consider Circuit ORAM with big data blocks of O(D) bits, and little metadata blocks of O(log N ) bits (used in the position map levels of the recursion). In Theorems 1 and 2, we show that the stash size is O(log 1 ) blocks for a failure probability of . The rest immediately follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">PROOF ROADMAP</head><p>We give a roadmap of how the probability statements concerning stash usage in Theorems 1 and 2 are proved. The full proofs are given in Appendices 9 and 10 [1]. Although our proof borrows some high-level ideas from both Path ORAM <ref type="bibr" target="#b50">[52]</ref> and CLP ORAM <ref type="bibr" target="#b5">[7]</ref>, we stress that both our construction and proof are non-trivial and di‚Üµer from Path ORAM and CLP ORAM in significant ways.</p><p>Equivalence to post-processed 1-ORAM. Similar to Path ORAM <ref type="bibr" target="#b50">[52]</ref>'s analysis, we consider an imaginary construct known as 1-ORAM, which is the same as Circuit ORAM, except that buckets have infinite capacity. 1-ORAM is not a real-world e cient ORAM scheme, but a construct that facilitates analysis.</p><p>Suppose we are given the state of the 1-ORAM at some moment, and we would like to infer from it the stash usage of the real ORAM. One natural way is to post-process the 1-ORAM such that if a bucket contains more blocks than its capacity, the extra blocks are pushed back to its parent. This is performed repeatedly until all extra blocks are pushed from the root to the stash. As in the analysis of Path ORAM, the hope is that the stash usage of the postprocessed 1-ORAM is the same as that of the real ORAM. If this is true, then we can use the same approach <ref type="bibr" target="#b50">[52]</ref> to analyze 1-ORAM.</p><p>It is intuitive that the stash usage of the real ORAM should be at least that of the post-processed 1-ORAM. Our 1-ORAM shows how far blocks could be evicted towards the leaves even without any restrictions because of bucket capacity. The post-processing adds back the bucket capacity requirement. Hence, the post-processed 1-ORAM gives some bound on how far the blocks could be evicted towards the leaves in the real ORAM.</p><p>However, it is not obvious that the real ORAM could evict blocks towards the leaves to the same extent as the postprocessed 1-ORAM. Indeed, if we do not perform partial eviction on the read path in a ReadAndRm operation (see Appendix 9.1), then a hole (an available slot that would be (a) The stash exceeds R with probability 2 ‚á•(R) . N = 2 10 is used. (b) The stash size is independent of the ORAM capacity N . Z = 3 is used.</p><p>Figure <ref type="figure">3</ref>: Evaluation of stash size. Deterministic-order eviction is adopted.</p><p>filled in post-processing) could be created in the real ORAM. This could mean an extra block has to be stored in the stash of the real ORAM, thereby breaking the equivalence of stash usage between the real ORAM and the post-processed 1-ORAM.</p><p>Fortunately, a partial eviction in a ReadAndRm operation is su cient to fix this issue. However, unlinke Path ORAM's analysis, in our case it is highly non-trivial to show that indeed the post-processed 1-ORAM is equivalent to the real Circuit ORAM. The key insight is to maintain the invariant (Fact 2 in Appendix 9) that if some bucket in the real ORAM has an available slot, then during the post-processing of 1-ORAM, no blocks can be pushed through this bucket towards the root. However, to formalize this argument requires an intricate induction proof that is presented in Appendix 9. This technical proof can be skimmed, if the reader is convinced of the validity of the post-processed 1-ORAM.</p><p>Probabilistic tools to analyze 1-ORAM. Once it is established that the post-processed 1-ORAM is equivalent to the real ORAM as in the analysis of Path ORAM <ref type="bibr" target="#b50">[52]</ref>, one can observe that the post-processed 1-ORAM has stash usage of R blocks i‚Üµ there exists a subtree T at the root with n := n(T ) buckets in 1-ORAM such that the number of blocks residing in T is nZ + R, where Z is the bucket capacity. The goal is to show that at some fixed moment, for a fixed subtree T , the probability that T (in unprocessed 1-ORAM) contains at least nZ + R blocks is at most exp( Cn R), for some large enough constant C &gt; 0. Since there are at most 4 n subtrees with n nodes, a union bound over all possible subtrees T can establish the probability bound in Theorems 1 and 2.</p><p>The full proof is in Appendix 10 [1], and we outline the key ideas here. To analyze the usage of the subtree T , we consider two cases at the subtree's boundary, where blocks might possibly be evicted from T .</p><p>‚Ä¢ Suppose bucket u in T is also a leaf in 1-ORAM, and let Xu be the number of blocks in T whose label corresponds to u. Observe that these blocks cannot leave T . Since there are N distinct blocks, by a standard balls-into-bins argument, in the worst case, Xu is a sum of N independent {0, 1}-random variables each having mean 1 N . ‚Ä¢ Suppose bucket u is not in T , but its parent bucket is in T . In this case, we say that u is an exit node, and let Xu be the number of blocks in T that can legally reside in u. Since in each ORAM access operation, a block is assigned a fresh random label and there are two eviction paths, we shall argue that Xu can be viewed as a Markov queue whose departure rate is twice that of its arrival rate. For random eviction path selection, Xu behaves like a a discrete-time M/M/1 queue, while for deterministic-order eviction variant, Xu behaves like a discrete-time M/D/1 queue <ref type="bibr" target="#b27">[29]</ref>. Assuming that Circuit ORAM is initially empty, we can instead consider the stochastically dominating scenario when Xu is already in the stationary distribution, whose analysis does not depend on the number N of distinct blocks. We shall see that in either of the above cases, the random variable Xu has constant expectation. Hence, the number of blocks in T , which is the sum of the Xu's, has expectation ‚á•(n). Observe that in the analysis of CLP ORAM <ref type="bibr" target="#b5">[7]</ref>, they consider how often each Xu reaches some threshold, whereas we directly consider the sum of the Xu's as in <ref type="bibr" target="#b50">[52]</ref>. We next use a measure concentration argument to prove that the probability that the sum deviates from its mean is exponentially small.</p><p>Observe that the Xu's are not independent. In fact, the Xu's are negatively associated <ref type="bibr" target="#b9">[11]</ref>, because if a block is assigned to one of the Xu's, then it cannot be assigned to another. Nevertheless, negative associativity is enough to prove measure concentration results via moment generating functions, which are standard tools used to derive results like Cherno‚Üµ and Hoe‚Üµding bounds.</p><p>In Appendix 10, we formally prove that the Xu's are negative associated using Lemma 10, and give upper bounds for the moment generating functions t 7 ! E[exp(tXu)] of the Xu's in Lemma 9. Finally, the probability calculations to achieve Theorems 1 and 2 are completed in the proof of <ref type="bibr">Lemma 8 [1]</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EVALUATION</head><p>Stash size distribution. We simulate Circuit ORAM for a single long run, for about 2 33 accesses, after 2 25 accesses to warm up the ORAM to steady state. In our experiments, we use the following request sequence where we repeatedly cycle through all N logical addresses: 1, 2, . . . , N, 1, 2, . . . , N, . . .. Using the same argument as in Path ORAM <ref type="bibr" target="#b50">[52]</ref>, it is not hard to see that this is the worst-case access sequence. Instead of measuring multiple runs, we use a single, very long run, and measure the fraction of time that the stash has a certain size. This methodology is well-founded, since it is well-known that if a stochastic process is regenerative, the time average over a single run is equivalent to the ensemble average over multiple runs (see Chapter 5 of Harchol-Balter <ref type="bibr" target="#b24">[26]</ref>).</p><p>Figure <ref type="figure">3a</ref> plots the stash size against the quantity log( 1 ) where is the failure probability. A point on the curve should be interpreted as: the stash exceeds R (value on yaxis) with probability . The two curves correspond to a bucket size of 2 and 3 respectively. Clearly, the fact that both curves are a linear line suggests that the stash exceeds R with probability of 2 cR , where the constant c in the exponent is di‚Üµerent for the two curves. Further, Figure <ref type="figure">3b</ref> shows that the stash size is independent of the ORAM's capacity N . Besides a bucket size of 2 and 3, we also tried a bucket size of 4 -in this case, we never observed the stash growing beyond 5 for the first 2 33 accesses.</p><p>Circuit size. In Table <ref type="table" target="#tab_6">2</ref>, we compare the circuit sizes of Circuit ORAM and other state-of-the-art ORAM schemes. Results in this table are obtained for a 4GB dataset with the following concrete parameters: N = 2 30 , D = 32 bits, and security failure = 2 80 . For Path ORAM <ref type="bibr" target="#b50">[52]</ref>, we consider a naive implementation, and an asymptotically more ecient implementation relying on 3 oblivious sorts <ref type="bibr" target="#b51">[53]</ref>. For all schemes, we consider two strategies for choosing the eviction path: random-order eviction and deterministic-order eviction (based on digit-reversed lexicographic order <ref type="bibr" target="#b13">[15]</ref>).</p><p>The table shows that Circuit ORAM results in 8.2x to 48.6x smaller circuit size than Path ORAM, and is 4.1x to 5.1x better than SCORAM <ref type="bibr" target="#b51">[53]</ref>. Circuit ORAM's speedup will become even bigger when the total data size N is greater.</p><p>Breakeven point with trivial ORAM. Depending on the block size, the breakeven point between Circuit ORAM and trivial ORAM varies -Table <ref type="table" target="#tab_7">3</ref>. We also compare our breakeven point with Gordon et al. <ref type="bibr" target="#b23">[25]</ref>, and Keller and Scholl <ref type="bibr" target="#b26">[28]</ref>, and show that we achieve dramatic improvement at much higher security parameters. Gordon et al. implemented the binary-tree ORAM and reported a breakeven point of 8MB with a block size D = 512 bits, and 2 14 failure probability. Our breakeven point is 8KB with a block size D = 512 bits, and at 2 80 failure probability. Keller and Scholl <ref type="bibr" target="#b26">[28]</ref> implement an optimized Path ORAM algorithm, and report a breakeven point of 9.77KB with a block size D = 40 bits, and a 2 20 failure probability. We achieve 1.3KB breakeven point at D = 40 bits, and with 2 80 failure probability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Implementation over Garbled Circuits</head><p>Since our work, Circuit ORAM has now been implemented and provided as the default ORAM implementation in the ObliVM secure computation framework <ref type="bibr">[2,</ref><ref type="bibr" target="#b32">34]</ref>. <ref type="bibr">Liu et al. [2,</ref><ref type="bibr" target="#b32">34]</ref> report some Circuit ORAM performance numbers in the ObliVM framework. We report more detailed performance numbers of Circuit ORAM atop the ObliVM framework.</p><p>Running time. We tested the performance of Circuit ORAM under di‚Üµerent network bandwidth configurations. Figure <ref type="figure" target="#fig_5">4a</ref> and Figure <ref type="figure" target="#fig_5">4b</ref> report the wallclock running time obtained, and the performance breakdown. To maximize performance, we apply di‚Üµerent optimizations for these di‚Üµerent settings. When the bandwidth is 1Gbps (Figure <ref type="figure" target="#fig_5">4a</ref>), we use Garbled Row Reduction <ref type="bibr" target="#b39">[41]</ref> and Free XOR <ref type="bibr" target="#b28">[30]</ref>. When the bandwidth is 20Mbps, we use the halfgate optimization <ref type="bibr" target="#b58">[60]</ref> instead.   Interpreting the performance numbers. First, the present implementation of the ObliVM framework does not exploit AES-NI instructions to speed up garbling. We expect a noticeable speedup for the computation time when hardware AES is employed. Second, the present ObliVM uses a Javabased implementation. Therefore, the timing measurements are subject to the artifacts of Java.</p><p>In Figure <ref type="figure" target="#fig_5">4a</ref>, when the bandwidth is 1Gbps, we observe that the garbler's garbling I/O is negligible. The evaluator's garbling I/O is higher -and most of this stems from I/O synchronization cost since in this case the bandwidth is ample. When the bandwidth is 20Mbps (Figure <ref type="figure" target="#fig_5">4b</ref>) the garbler spends noticeable time on transmitting garbled circuits to the evaluator (I/O for Garbling). Since garbling is never blocked waiting for the evaluator, most of this cost is network transmission cost. For the OT cost, presently ObliVM does not employ the known cache optimizations <ref type="bibr" target="#b2">[4]</ref> (which are di cult to realize in a Java-based implementation). We therefore expect significant savings in performance when ObliVM transitions to a C-based implementation adopting state-of-the-art cache optimizations for OT, and hardware AES-NI features.</p><p>Appendices Appendices are supplied in an online full version available at https://eprint.iacr.org/2014/672.pdf.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>c</head><label></label><figDesc>2015 ACM. ISBN 978-1-4503-3832-5/15/10 ...$15.00. DOI: http://dx.doi.org/10.1145/2810103.2813634.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Access(op) // where op = ("read", idx) or op = ("write", idx, data ‚á§ ) 1: label := PositionMap[idx] 2: {idx||label||data} := ReadAndRm(idx, label) 3: PositionMap[idx] := UniformRandom(0 . . . N 1) 4: If op is "read": data ‚á§ := data 5: stash.add({idx||PositionMap[idx]||data ‚á§ }) 6: Evict() 7: Return data</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Bandwidth=1Gbps. Garbled Row Reduction<ref type="bibr" target="#b39">[41]</ref> and Free XOR<ref type="bibr" target="#b28">[30]</ref> are used.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Bandwidth=20Mbps. Halfgate<ref type="bibr" target="#b58">[60]</ref> is used.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Runtime breakdown for Circuit ORAM under di‚Üµerent bandwidth configurations. In each pair of bars, the left is for the garbler while the right is for the evaluator. Performance numbers are measured based on the ObliVM framework provided by Liu et al. [34]. The plots correspond to a data size D = 32 bits and = 2 80 failure probability.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Circuit size of various ORAM schemes. D is the bit length of each block, and N is the total number of blocks. All schemes are parameterized to have 1 N !(1) failure probability. *: The variable CPRF denotes the circuit size of a PRF function with input size of O(log N ) bits. Among all single-server ORAM schemes, Circuit ORAM has asymptotically the smallest circuit size if CPRF is at least !(log N log log N ) -which is true for all known PRF constructions provably secure based on computationally hard problems. **: The concrete circuit size is calculated based on 4GB data with a 32-bit block size, with 2 80 security failure probability.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Make a root-to-leaf linear metadata scan to prepare the deepest array. After this algorithm, deepest[i] stores the source level of the deepest block in path[0..i 1] that can legally reside in path[i].</figDesc><table><row><cell cols="4">Algorithm 1 EvictOnceSlow(path)</cell></row><row><cell cols="4">/*A slow, non-oblivious version of our eviction algorithm, only for illustration purpose*/</cell></row><row><cell cols="2">1: i := L</cell><cell cols="2">/* start from leaf */</cell></row><row><cell cols="3">2: while i 1 do:</cell></row><row><cell>3:</cell><cell cols="3">if path[i] has empty slot then</cell></row><row><cell>4:</cell><cell cols="3">(B, `) := Deepest block in path[0..i 1] that can legally reside in path[i].</cell></row><row><cell>5:</cell><cell cols="3">/* B := ? if such a block does not exist.*/ end if</cell></row><row><cell>6: 7:</cell><cell cols="3">if B 6 = ? then Move B from path[`] to path[i].</cell></row><row><cell>8:</cell><cell cols="2">i := `// skip to level</cell><cell>9:</cell></row><row><cell></cell><cell>else</cell><cell></cell></row><row><cell>10:</cell><cell cols="2">i := i 1</cell></row><row><cell>11:</cell><cell>end if</cell><cell></cell></row><row><cell cols="2">12: end while</cell><cell></cell></row><row><cell cols="4">Algorithm 2 PrepareDeepest(path)</cell></row><row><cell cols="2">/*3: end if</cell><cell></cell></row><row><cell cols="3">4: for i = 1 to L do:</cell></row><row><cell>5:</cell><cell cols="3">if goal i then deepest[i] := src</cell></row><row><cell>6:</cell><cell>end if</cell><cell></cell></row><row><cell>7:</cell><cell></cell><cell></cell></row></table><note><p><p><p>‚Ä¢ A random-order eviction strategy denoted EvictRandom() (see</p>Algorithm 5)</p>. The randomized strategy chooses two random paths that are non-overlapping except at */ 1: Initialize deepest := (?, ?, ..., ?), src := ?, goal := 1. 2: if stash not empty then src := 0, goal := Deepest level that a block in path[0] can legally reside on path.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>3: for i = 0 to L do 4: towrite := ? 5: if (hold 6 = ?) and (i == dest) then /* The block stored in hold will be placed in bucket path[i]. */</figDesc><table><row><cell>6:</cell><cell>towrite := hold</cell></row><row><cell>7: 8:</cell><cell>hold := ?, dest := ?. end if</cell></row><row><cell>9: 10:</cell><cell>if target[i] 6 = ? then hold := read and remove deepest block in path[i]</cell></row><row><cell>11:</cell><cell>dest := target[i]</cell></row><row><cell>12:</cell><cell>end if</cell></row><row><cell>13:</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 2 :</head><label>2</label><figDesc>Comparison of Circuit ORAM and variant of Path ORAM. N = 2 30 , D = 32, = 2 80 . Path ORAM(o-sort)<ref type="bibr" target="#b51">[53]</ref> uses 3 o-sorts. "Rand." stands for randomly chose eviction paths; "Det." stands for eviction with reverse-lexicographicalordered paths, described in earlier works<ref type="bibr" target="#b11">[13,</ref><ref type="bibr" target="#b13">15,</ref><ref type="bibr" target="#b14">16]</ref>.</figDesc><table><row><cell cols="2">Type Of ORAM</cell><cell cols="6">Circuit ORAM Path ORAM(naive) Path ORAM(o-sort) Det. Rand. Det. Rand. Det. Rand.</cell><cell cols="2">SCORAM Det. Rand.</cell></row><row><cell cols="2">Circuit size</cell><cell>3.5M</cell><cell cols="2">6.6M 28.5M</cell><cell>170.1M</cell><cell>62.1M</cell><cell>124.1M</cell><cell cols="2">14.5M 17.9M</cell></row><row><cell cols="2">Relative overhead</cell><cell>1X</cell><cell>1.9X</cell><cell>8.2X</cell><cell>48.6X</cell><cell>17.7X</cell><cell>35.5X</cell><cell>4.14X</cell><cell>5.1X</cell></row><row><cell cols="2">#AND gates</cell><cell cols="2">0.97M 1.6M</cell><cell>9.5M</cell><cell>56.6M</cell><cell>20.7M</cell><cell>41.4M</cell><cell>4.9M</cell><cell>6.1M</cell></row><row><cell cols="2">Relative overhead</cell><cell>1X</cell><cell>1.6X</cell><cell>9.79X</cell><cell>58.4X</cell><cell>21.34X</cell><cell>42.7X</cell><cell>5.1X</cell><cell>6.3X</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">Circuit ORAM</cell><cell></cell><cell></cell><cell cols="3">GKKKMRV12 [25]</cell><cell>KS12 [28]</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">= 2 80</cell><cell></cell><cell></cell><cell></cell><cell>‚á° 2 14</cell><cell>= 2 20</cell></row><row><cell>Block size (bits)</cell><cell>32</cell><cell>40</cell><cell>128</cell><cell>512</cell><cell>2048</cell><cell>8192</cell><cell></cell><cell>512</cell><cell>40</cell></row><row><cell>Breakeven point (entries)</cell><cell>256</cell><cell>256</cell><cell>128</cell><cell>128</cell><cell>64</cell><cell>64</cell><cell></cell><cell>131072</cell><cell>‚á°2000</cell></row><row><cell>Breakeven point (total data size)</cell><cell>1KB</cell><cell>1.3KB</cell><cell>2KB</cell><cell>8KB</cell><cell>16KB</cell><cell>65KB</cell><cell></cell><cell>8MB</cell><cell>9.77KB</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 3 :</head><label>3</label><figDesc>Breakeven point for di‚Üµerent ORAMs. Circuit ORAM numbers correspond to a security parameter of 80, whereas GKKKMRV12 and KS12 adopt a security parameter of roughly 14 and 20 respectively.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Throughout this paper, the notation g(N ) = O(f (N ))!(1) denotes that for any ‚Üµ(N ) = !(1), g(N ) = O(f (N )‚Üµ(N )).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>For number of accesses and bandwidth blowup, the lower bound is applicable to O(1) client storage.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>Due to limit of space, all appendices are supplied in an online full version available at https://eprint.iacr.org/2014/672.pdf.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments. This research was funded in part by NSF grants CNS-1314857, CNS-1453634, CNS-1518765, CNS-1514261, a subcontract from the DARPA PROCEED program, a Sloan Research Fellowship, a Google Faculty Research Award and a grant from Hong Kong RGC under the contract HKU719312E. We gratefully acknowledge Bill Gasarch, Mor Harchol-Balter, Dov Gordon, Clyde Kruskal, Kartik Nayak, Charalampos Papamanthou, and abhi shelat for helpful discussions.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Verifiable oblivious storage</title>
		<author>
			<persName><forename type="first">D</forename><surname>Apon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Thiruvengadam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PKC</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">More e cient oblivious transfer and extensions for faster secure computation</title>
		<author>
			<persName><forename type="first">G</forename><surname>Asharov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zohner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Making branching programs oblivious requires superlogarithmic overhead</title>
		<author>
			<persName><forename type="first">P</forename><surname>Beame</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Machmouchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCC</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Remote oblivious storage: Making oblivious RAM practical</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mazieres</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Popa</surname></persName>
		</author>
		<ptr target="http://dspace.mit.edu/bitstream/handle/1721.1/62006/MIT-CSAIL-TR-2011-018.pdf" />
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Statistically-secure oram with √ï(log 2 n) overhead</title>
		<author>
			<persName><forename type="first">K.-M</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pass</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Asiacrypt</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Perfectly secure oblivious RAM without random oracles</title>
		<author>
			<persName><forename type="first">I</forename><surname>Damg√•rd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Meldgaard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Nielsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Burst oram: Minimizing oram response times for bursty access patterns</title>
		<author>
			<persName><forename type="first">J</forename><surname>Dautrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Stefanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">23rd USENIX Security Symposium (USENIX Security 14)</title>
		<meeting><address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2014-08">Aug. 2014</date>
			<biblScope unit="page" from="749" to="764" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Van Dijk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wichs</surname></persName>
		</author>
		<title level="m">Onion ORAM: A constant bandwidth oram without FHE</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Balls and bins: a study in negative dependence</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dubhashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Ranjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Random Struct. Algorithms</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="99" to="124" />
			<date type="published" when="1998-09">September 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A secure processor architecture for encrypted computation on untrusted programs</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">V</forename><surname>Dijk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STC</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">RAW Path ORAM: A low-latency, low-area hardware ORAM controller with integrity verification</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kwon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Van Dijk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Stefanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Suppressing the oblivious RAM timing channel while making information leakage and program e ciency trade-o‚Üµs</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Van Dijk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HPCA</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="213" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Optimizing ORAM and using it e ciently for secure computation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">A</forename><surname>Goldman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Jutla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Raykova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wichs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Privacy Enhancing Technologies Symposium (PETS)</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Private database access with he-over-oram architecture</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Jutla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Raykova</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2014">2014/345. 2014</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Towards a theory of software protection and simulation by oblivious RAMs</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">How to play any mental game</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Software protection and simulation on oblivious RAMs</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Zig-zag sort: A simple deterministic data-oblivious sorting algorithm running in O(N Log N) time</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Goodrich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Privacy-preserving access of outsourced data via oblivious RAM simulation</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Goodrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mitzenmacher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Oblivious RAM simulation with e cient worst-case access overhead</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Goodrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mitzenmacher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Ohrimenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tamassia</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
			<publisher>CCSW</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Practical oblivious storage</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Goodrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mitzenmacher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Ohrimenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tamassia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CODASPY</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Privacy-preserving group data access via stateless oblivious RAM simulation</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Goodrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mitzenmacher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Ohrimenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tamassia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SODA</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Secure two-party computation in sublinear (amortized) time</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kolesnikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Krell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Malkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Raykova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Vahlis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Performance Modeling and Design of Computer Systems: Queueing Theory in Action. Performance Modeling and Design of Computer Systems: Queueing Theory in Action</title>
		<author>
			<persName><forename type="first">M</forename><surname>Harchol-Balter</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Behavior of tandem bu‚Üµers with geometric input and Markovian output</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hsu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Burke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Transactions on Communications</title>
		<imprint>
			<date type="published" when="1976">1976</date>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="358" to="361" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">E cient, oblivious data structures for mpc</title>
		<author>
			<persName><forename type="first">M</forename><surname>Keller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Scholl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Stochastic processes occurring in the theory of queues and their analysis by the method of the imbedded markov chain</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">G</forename><surname>Kendall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Annals of Mathematical Statistics</title>
		<imprint>
			<date type="published" when="1953">1953</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Improved Garbled Circuit: Free XOR Gates and Applications</title>
		<author>
			<persName><forename type="first">V</forename><surname>Kolesnikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">The distribution of waiting times in clocked multistage interconnection networks</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">P</forename><surname>Kruskal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Snir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Weiss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Computers</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1337" to="1352" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">On the (in)security of hash-based oblivious RAM and a new balancing scheme</title>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SODA</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Automating e cient ram-model secure computation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hicks</surname></persName>
		</author>
		<editor>IEEE S &amp; P</editor>
		<imprint>
			<date type="published" when="2014">2014</date>
			<publisher>IEEE Computer Society</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">ObliVM: A Generic, Customizable, and Reusable Secure Computation Architecture</title>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><forename type="middle">S</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nayak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
			<publisher>S &amp; P</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Shroud: Ensuring private access to large-scale data in the data center</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Lorch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Parno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Mickens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Raykova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Schi‚Üµman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">FAST</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Distributed oblivious ram for secure two-party computation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Phantom: Practical oblivious computation in a secure processor</title>
		<author>
			<persName><forename type="first">M</forename><surname>Maas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Love</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Stefanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tiwari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Asanovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kubiatowicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><surname>Mayberry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E.-O</forename><surname>Blass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">H</forename><surname>Chan</surname></persName>
		</author>
		<title level="m">E cient private file retrieval by combining oram and pir</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Data-Oblivious Data Structures</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zimmerman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STACS</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><surname>Moataz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mayberry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E.-O</forename><surname>Blass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">H</forename><surname>Chan</surname></persName>
		</author>
		<title level="m">Resizable tree-based oblivious ram</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Privacy preserving auctions and mechanism design</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sumner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EC</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">E cient computation on oblivious RAMs</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Private information storage</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Oblivious RAM revisited</title>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Reinman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Relations among complexity measures</title>
		<author>
			<persName><forename type="first">N</forename><surname>Pippenger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Fischer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1979-04">Apr. 1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kwon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Stefanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Van Dijk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2014/997/" />
		<title level="m">Constants count: Practical improvements to oblivious ram</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Design space exploration and optimization of path oblivious RAM in secure processors</title>
		<author>
			<persName><forename type="first">L</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Van Dijk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="571" to="582" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Oblivious RAM with O((log N ) 3 ) worst-case cost</title>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T.-H</forename><forename type="middle">H</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Stefanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Multi-cloud oblivious storage</title>
		<author>
			<persName><forename type="first">E</forename><surname>Stefanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Computer and Communications Security (CCS)</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Oblivistore: High performance oblivious cloud storage</title>
		<author>
			<persName><forename type="first">E</forename><surname>Stefanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy (S &amp; P)</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Towards practical oblivious RAM</title>
		<author>
			<persName><forename type="first">E</forename><surname>Stefanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Path ORAM: an extremely simple oblivious ram protocol</title>
		<author>
			<persName><forename type="first">E</forename><surname>Stefanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Van Dijk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T.-H</forename><forename type="middle">H</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="issue">280</biblScope>
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Scoram: Oblivious ram for secure computation</title>
		<author>
			<persName><forename type="first">X</forename><forename type="middle">S</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T.-H</forename><forename type="middle">H</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shelat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Usable PIR</title>
		<author>
			<persName><forename type="first">P</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sion</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Single round access privacy on outsourced storage</title>
		<author>
			<persName><forename type="first">P</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sion</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">SR-ORAM: Single round-trip oblivious ram</title>
		<author>
			<persName><forename type="first">P</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sion</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Building castles out of mud: Practical access pattern privacy and correctness on untrusted storage</title>
		<author>
			<persName><forename type="first">P</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sion</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Carbunar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Protocols for secure computations (extended abstract)</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename></persName>
		</author>
		<author>
			<persName><forename type="first">-C</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<imprint>
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Circuit structures for improving e ciency of security and privacy tools</title>
		<author>
			<persName><forename type="first">S</forename><surname>Zahur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Evans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">S &amp; P</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Two halves make a whole: Reducing data transfer in garbled circuits using half gates</title>
		<author>
			<persName><forename type="first">S</forename><surname>Zahur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rosulek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Evans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
