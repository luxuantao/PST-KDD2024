<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Answering Why and Why Not Questions in User Interfaces</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Brad</forename><surname>Myers</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Human Computer Interaction Institute</orgName>
								<orgName type="institution">Carnegie Mellon University Pittsburgh</orgName>
								<address>
									<postCode>15213</postCode>
									<region>PA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">David</forename><forename type="middle">A</forename><surname>Weitzman</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Human Computer Interaction Institute</orgName>
								<orgName type="institution">Carnegie Mellon University Pittsburgh</orgName>
								<address>
									<postCode>15213</postCode>
									<region>PA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Andrew</forename><forename type="middle">J</forename><surname>Ko</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Human Computer Interaction Institute</orgName>
								<orgName type="institution">Carnegie Mellon University Pittsburgh</orgName>
								<address>
									<postCode>15213</postCode>
									<region>PA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Duen</forename><forename type="middle">Horng</forename><surname>Chau</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Human Computer Interaction Institute</orgName>
								<orgName type="institution">Carnegie Mellon University Pittsburgh</orgName>
								<address>
									<postCode>15213</postCode>
									<region>PA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Answering Why and Why Not Questions in User Interfaces</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">012C0596D0A00D939BA3F7DC52850512</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:55+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Why, Help, Questions, Natural Programming D.2.2 Design Tools and Techniques: User interfaces</term>
					<term>D.2.6 Programming Environments: Graphical environments</term>
					<term>H.5.2 User Interfaces: Interaction styles, Training, help, and documentation</term>
					<term>D.2.11 Software Architectures</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Modern applications such as Microsoft Word have many automatic features and hidden dependencies that are frequently helpful but can be mysterious to both novice and expert users. The "Crystal" application framework provides an architecture and interaction techniques that allow programmers to create applications that let the user ask a wide variety of questions about why things did and did not happen, and how to use the related features of the application without using natural language. A user can point to an object or a blank space and get a popup list of questions about it, or the user can ask about recent actions from a temporal list. Parts of a text editor were implemented to show that these techniques are feasible, and a user test suggests that they are helpful and well-liked.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>INTRODUCTION</head><p>One of the classic guidelines for user interface design is to have "visibility of system status" to "keep users informed about what is going on" <ref type="bibr" target="#b17">[18]</ref>. And yet, in an informal survey of novice and expert computer users, everyone was able to remember situations in which their computer did something that seemed mysterious. For example, sometimes Microsoft Word automatically changes "teh" into "the", but it does not change "nto" into "not". The spacing above a paragraph can be affected by properties in the "Format Paragraph" dialog box, along with the heights of the actual characters on the first line of the paragraph (even the heights of invisible characters such as spaces). In the Windows desktop and Windows Explorer "Icon" view, some-times the icons go where you put them but sometimes they auto-arrange into columns. A command that hides all the windows can be invoked by accident, making users wonder where their windows went.</p><p>All of these features, and the dozens of others that we collected (and that the reader can undoubtedly think of), are quite useful to most users, and have been added to user interfaces because they help most people most of the time. However, when a novice or expert is unfamiliar with these features, or when something happens that is not desired, there is no mechanism to figure out why the actions happened, or how to control or prevent them. It is even more difficult when an expected action does not happen, for example, why did the spelling not get corrected? No help system built into any of today's systems can answer these questions. As applications inevitably get more sophisticated, such a facility will be even more necessary.</p><p>Inspired by the Whyline research <ref type="bibr" target="#b10">[11]</ref> that answers "why" and "why not" questions about a program's execution to aid debugging, we created an application framework called Crystal that helps programmers build applications that can answer questions about an application (see Figure <ref type="figure" target="#fig_0">1</ref>). Crystal provides Clarifications Regarding Your Software using a Toolkit, Architecture and Language. The idea is that the system makes things "crystal clear." At this point Crystal is The answer for why "Teh" was changed into "The". The pink "?" in the upper left shows where the F1 key was hit.</p><p>primarily a feasibility demonstration, but it does show that a system can helpfully answer users' "why" and "why not" questions.</p><p>Instead of supporting natural language, Crystal builds question menus dynamically based on the current state of the application. The user can ask questions either by hitting a key (currently F1) while the mouse cursor is over the item of interest, as was done in Figure <ref type="figure" target="#fig_0">1</ref>, in which case Crystal automatically builds a menu of questions about the objects under the mouse. Crystal provides invisible objects under every point in the window so users can ask questions by pointing to where there are apparently no objects, such the white space around paragraphs. Alternatively, a "why" menu displays a list of the last few operations that were or were not performed. This includes explicit user actions (e.g., "hitting the 'Backspace' key"), along with automatic actions like spelling correction, and other actions which are normally not logged (e.g., hiding windows). This list also includes actions that the user tried to perform but did not actually execute, such as hitting Control-C for Copy with nothing selected. The application designer can add to the menus questions about other things that did not happen which might be mysterious to users. Examples include when interdependencies or constraints prevent an object from moving or cause automatic correction to not happen.</p><p>In response to any of these questions, Crystal displays a window containing an automatically-created explanation (see the bottom-left of Figure <ref type="figure" target="#fig_0">1</ref>). Whenever possible, the elements of the user interface that contributed to the value are displayed, and a red highlight is put around the user interface controls (also called "widgets") relevant to the question. In Figure <ref type="figure" target="#fig_0">1</ref>, the "Replace text as you type" checkbox of the AutoCorrect dialog is highlighted. In cases where the user interface controls cannot be so easily displayed, Crystals adds a "How Can I…" question to the bottom of the explanation window, to allow the user to ask how to control the features that were involved in the operation. Other systems have supported such "How Can I" questions, but not in the context of "why" questions, and Crystal also differs in that it automatically determines how to enable the actions.</p><p>Like the Whyline <ref type="bibr" target="#b10">[11]</ref>, Crystal must store extra information about a program's execution to support answering the questions. Therefore, the question-answering cannot simply be plugged into an existing application like Microsoft Word. Instead, the application must be built in such a way as to collect the appropriate information during execution. The Crystal framework adds novel extensions to the commandobject model <ref type="bibr" target="#b15">[16]</ref> to store the appropriate information. This makes it easy to build applications which will support the asking of questions.</p><p>To demonstrate the effectiveness of this framework, we used it to build parts of a sample text editor which has some automatic transformations like Microsoft Word. We then used this editor in a small user study. The results suggest that Crystal is effective in teaching users about these complex features, and the interaction techniques were easy to use and well-liked. Participants with the "why" features were able to complete about 30% more tasks than those without, and of the tasks completed, participants with the "why" features were about 20% faster.</p><p>The Crystal framework is primarily intended to help explain complex behaviors and interdependencies among the various features. It is not intended to help the end-user find out why things happened if the programmer introduced bugs into the application. The assumption that Crystal makes is that all the resulting behaviors are intended. If the programmer does not know why something happens, it is unrealistic to expect end-users to! The rest of this paper summarizes the related work, describes the user interface features, and then explains in detail the software architecture that makes asking the questions possible. The user study is then described, followed by future work and conclusions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RELATED WORK</head><p>Help systems for interactive applications have been studied extensively. Norman discusses two important "gulfs" in people's use of their systems <ref type="bibr" target="#b18">[19]</ref>. Many help systems (e.g., <ref type="bibr" target="#b6">[7]</ref> [13] [20] <ref type="bibr" target="#b21">[22]</ref>) are designed to help with the gulf of execution: teaching users how to perform actions, primarily to learn about a command they already know the name of, or learn how to perform tasks. For example, Cartoonist <ref type="bibr" target="#b21">[22]</ref> displays animated help showing the steps required, but it must explicitly be given the name of a command or task. In contrast, we believe that Crystal provides the first help system to specifically target the gulf of evaluation: helping users interpret what they are seeing on the screen and determine how to fix it if it is not what they intended.</p><p>Many recent help systems focus on giving tutorials for how to use a system. For example SmartAidè <ref type="bibr" target="#b19">[20]</ref> uses AI planning methods to give step-by-step instructions when the user has a goal in mind but does not know how to execute it. "Stencils" focuses the user's attention on certain parts of the interface during a tutorial to prevent errors <ref type="bibr" target="#b7">[8]</ref>. The Crystal framework would probably be helpful in building such systems, since it provides an explicit representation between the user actions and the underlying behaviors, but creating tutorials using Crystal is left for future work. AI-based question answering systems (e.g., <ref type="bibr" target="#b12">[13]</ref>  <ref type="bibr" target="#b22">[23]</ref>) focus on improving the effectiveness of queries that use natural language, which Crystal avoids by generating popup menus containing specific relevant questions .</p><p>A number of systems have allowed the user to go into a special mode and click on controls in the interface to get help on them. This was available, for example, in the first version of LabView <ref type="bibr" target="#b16">[17]</ref> in 1986, and the "?" icon works this way in some Windows dialog boxes. Eclipse will display "infopops" when the user presses F1 over any user interface widget <ref type="bibr" target="#b6">[7]</ref>. The infopops can contain links to various topics. In these kinds of systems, however, the help text is statically written by the programmer and does not help with questions about why actions did or did not happen. In Crystal, the question and answer text is automatically generated from the program's execution history.</p><p>In its answers, Crystal highlights the actual widgets of the interface. This approach has been used in Apple Guide <ref type="bibr" target="#b9">[10]</ref>, Stencils <ref type="bibr" target="#b7">[8]</ref>, and the "Show me" feature of some modern help systems. A difference from these is that Crystal automatically determines which widgets should be highlighted.</p><p>The only systems we are aware of that try to use tracing and dependency information to help users are programming systems such as spreadsheets and debuggers. For example, Microsoft Excel 2003 will show the cells on which the current cell depends. Forms/3 goes further in providing visualizations that try to focus the user's attention on from where faulty values may have come <ref type="bibr" target="#b20">[21]</ref>. Production systems, such as ACT-R, have long had the ability to ask why productions did or did not fire <ref type="bibr" target="#b2">[3]</ref>, and the Whyline <ref type="bibr" target="#b10">[11]</ref> generalizes this to any output statement in the program. Dourish <ref type="bibr" target="#b4">[5]</ref> speculates about how an open data model <ref type="bibr" target="#b8">[9]</ref> [14] might help applications explain their behavior, and provides motivation and technical guidelines, but does not describe any implementation. We are not aware of any applications for end users that dynamically generate a list of "why" questions about the context, or dynamically create the answers based on the history of users' actions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>USER INTERFACE</head><p>Crystal makes contributions in two areas: the interaction designs for asking and answering questions, and the framework to make implementing this easier. Research has shown that users are often reticent to use help systems and that the help system's own user interface can be a barrier to its use <ref type="bibr" target="#b5">[6]</ref>. Therefore, a key requirement for Crystal is that it be very easy to invoke and that the answers be immediately helpful.</p><p>To address these issues, we designed the interface to the "why" system with just two simple interaction techniques: the F1 key and the "why" menu. The "why" menu also contains an item to go into a mode that allows invoking location-based questions, in case the user does not know how to use the F1 key. Our observations suggest that virtually all of the user's questions will be about things that are visible (or invisible in the case of white space) in their application, or things that happened recently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Which Questions To Include</head><p>The next important design issue is what questions belong in the menus. In a simple direct manipulation application, such as a drawing editor, the only things that happen are what the user explicitly does, so the question menu will simply have one entry for each user action. In this case, the question menu is automatically built by Crystal from the commands that are executed. However, any sophisticated application will also have situations where there are hidden states or invisible dependencies that affect what users see. Examples include when a setting in one part of the user interface controls whether other things happen, such as the autocorrections in Figure <ref type="figure" target="#fig_0">1</ref>, and whether meta-information, such as paragraph marks ( ¶), are displayed or not. These must be added to the question menus as well. However, the application designer must guard against having too many questions in the menu, because then it will take too long for the user to find the desired question. Crystal therefore provides a way for the designers to note that certain actions should be omitted from the question menus.</p><p>For example, when implementing the sample text editor, we decided not to add regular typing to the menu, because it seemed unnecessary to let the user ask why "b" appeared, with the answer being "because you typed it." Similarly, we do not add questions about why characters move around (characters move when you type before them). In general, these are excluded because the actions and their feedback are so common and so immediate that users already know the answers. In other application domains, there are similar types of basic operations that would be excluded by the application designer (such as back and forward in a web browser, automatically marking e-mails as read after five seconds, changing tools in Photoshop, and other actions with immediate and direct visual feedback). Note that designers use similar heuristics today to decide what should go into the undo menus, and at what granularity -scrolling is not on the undo menu at all, and typing is grouped into chunks for undo.</p><p>In the sample text editor, there are questions for all other explicit user actions, including when typing causes the selected text to be deleted. If the editor supported complex mechanisms that moved text in non-intuitive ways (such as the widow/orphan control in Word), then these would be added to the menu as well.</p><p>The "why" menu also contains some actions that did not happen. Of course, an infinite number of different things could be added, but users only need to be able to find out about things they expected to happen. Some of these can be handled automatically by Crystal, including non-actions that stem from explicit user input. For example, Crystal adds to the menu questions for keystrokes that have no effect, such as typing Control-C with nothing selected (see Figure <ref type="figure" target="#fig_1">2</ref>). Also added are questions about actions that did not do anything because they were explicitly disabled. For example, if the auto-correct shown in Figure <ref type="figure" target="#fig_0">1</ref> was turned off, and the user types "Teh", the menu will let the user ask why it was not corrected (see Figure <ref type="figure" target="#fig_1">2</ref>). For background tasks, however, the application designer will have to notify Crystal when menu items should be added. The programmer specified that spelling corrections should be added to the menus, but "Why Not" questions are not added for words that are spelled correctly and therefore not corrected, since this would quickly fill up the menu with questions that are never likely to be of interest.    The answer to "Why is the 'p' bold?", when it was because the user set the property using the toolbar button.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Designing the Menus</head><p>When the F1 key is hit, Crystal looks at all objects under the cursor to generate the list of questions. For example, before getting the windows shown in Figure <ref type="figure" target="#fig_0">1</ref>, the menu at the left of Figure <ref type="figure" target="#fig_2">3</ref> would have appeared. The first level menu has questions about the character and paragraph under the mouse, and any global operations performed on that object. Figure <ref type="figure" target="#fig_0">1</ref> resulted from choosing the last item in the first menu. In Figure <ref type="figure" target="#fig_2">3</ref>-a, the user has selected the question about the properties of the character "h".</p><p>The questions in the menus are designed to feature the values in an easy-to-find place (at the end of each question) so that a quick scan will show all the properties' values. To display each value, Crystal uses a variety of built-in rules so the menus are concise yet readable. For Boolean properties, the value name or "not" the value name is used, such as "bold" or "not italic". For numeric properties, we use property = value. These automatic rules can be augmented by the designer with rules for application-specific types. For example, for the sample text editor, we added a custom rule to just use the style name for style values (such as "Default" in Figure <ref type="figure" target="#fig_2">3</ref>).</p><p>If the F1 key is hit while the mouse is over a blank part of the window, Crystal includes questions in the menu about why that white space is there. In Figure <ref type="figure" target="#fig_3">4</ref>, the paragraph is listed because it has an invisible portion that extends to the left edge of the window, since paragraphs control indenting. The designer of the editor has also added to the menu an additional question about whitespace, which summarizes all the different contributions to that whitespace (since character and paragraph properties might both be involved in other situations).</p><p>Like Eclipse <ref type="bibr" target="#b6">[7]</ref>, hitting F1 while the mouse cursor is over a control, such as a dialog box or a menu item, will provide help for that control. If the item is grayed out, Crystal will generate an explanation for why it is disabled.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Providing Useful Answers</head><p>Answers to the questions typically have two parts: a textual explanation and highlighting of the relevant user interface controls (see Figure <ref type="figure" target="#fig_4">5</ref>). The motivation is that users typically want to know more than why something happenedthey also want to know what they can do about it, such as changing it to be different. Therefore, whenever possible, answers highlight specific actions that users can take.</p><p>When the referenced control is in a dialog box, Crystal also highlights all the controls necessary to making it appear, so the user does not have to figure out how to get what the answer discusses to happen. For example, in Figure <ref type="figure" target="#fig_0">1</ref>, Crystal has highlighted the AutoCorrect Options menu item in the Tools menu, and the specific control used on the resulting dialog. All dialogs are "live" while they are highlighted, so the user can operate them normally. This will often save the user a number of steps if the property needs to be changed. In fact, it is sometimes quicker to use the F1 fea-ture to get to the desired dialog box instead of navigating to it, even when the user knows why things happened.</p><p>While we expect that the controls and dialog boxes of the application will be the primary focus for the user's answers, the textual explanation is necessary in some situations, such as when there is a chain of causes for the situation. For example, Figure <ref type="figure" target="#fig_5">6</ref> shows the answer explaining why the text is size 20, which is inherited from its style. The explanation is also useful when the user wants to learn how the application works in detail.</p><p>When there are multiple causes and actions as part of the explanation, Crystal adds to the bottom of the answer window a link for each one (see Figure <ref type="figure" target="#fig_5">6</ref>). When clicked, the text window provides the answer and the appropriate controls are highlighted. The back button in the answer window can then be used to return to the original question. When the user closes the answer window, the highlighting is removed from all controls. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPLICATION FRAMEWORK</head><p>An important contribution of this research is an objectoriented framework that makes it easy to create applications that support "why" and "why not" questions. The Crystal framework is implemented on top of Java Swing 1.5 and makes use of the standard Swing controls and architecture. The key additions in the Crystal framework are abstractions to represent application objects and their properties, and command objects that support undo and questions. The result is a framework where only a small amount of additional code is needed to support the "why" questions, beyond what is needed anyway to support undo. We used this framework to implement a sample text editor as a test application. We chose a text editor because it is a particularly difficult kind of application to build. Also, the Microsoft Word text editor contains many complex features that we wanted to see if our system could help explain. Implementing a graphical editor, as has been used to test most previous frameworks <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b15">16]</ref>, would be straightforward.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Hierarchical Command Objects</head><p>Crystal uses a "Command Object model" <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b15">16]</ref> to implement all of the actions. As commands are executed, they are stored on a command list which serves as a history of all the actions that have been taken. This command list is used for undo and the why menus.</p><p>Crystal uses hierarchical command objects <ref type="bibr" target="#b15">[16]</ref>. The toplevel command objects are all the user-executed commands (like when the user clicks on a menu item). The lower-level command objects are for the individual actions that a command may include. For example, setting some text to the "Heading" style might change the size, the font, and make the text bold. Crystal separates these into three different sub-commands of the Set-Style top-level command.</p><p>Each command object contains a variety of methods and fields, as shown in Figure <ref type="figure" target="#fig_6">7</ref>. The first six are typical of other command object systems <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b15">16]</ref>, but the second six are novel with Crystal, and are described next.</p><p>Dependencies: Crystal needs to know the dependencies among commands and values. In particular, many commands' actions depend on the values of controls. For example, the auto-correct command of Figure <ref type="figure" target="#fig_0">1</ref> depends on the value of the Replace-Text-As-You-Type property, and the answer wants to describe this for users. Using the saved old values, the answer generator can fetch the value of the control at the time when the command was executed. This allows Crystal to generate a message like "the auto-correct preference was disabled" even if the property is now enabled. When values are inherited for properties, such as when the font size for a character comes from a named style, the Dependencies parameter is used to record where the value came from.</p><p>Invoking-Control: Each command records the specific control used to invoke this command, since there may be multiple ways to initiate any command (e.g., a keyboard key, a toolbar button and a menu item can invoke the bold command). The Invoking-Control value is used to highlight the control in red as part of answers.</p><p>Questions-Method: When more specific questions and answers are needed for an application, the designer can implement this method. It can also be useful when the designer wants to improve the naturalness of phrasing of the answers. The method returns an object that contains a method to generate the corresponding answer. This is used in the sample text editor for example, by the background auto-correction process. For standard property setting (e.g., "make bold") and actions like creation and deletion, Crystal automatically creates the questions and answers, and the designer does not need to supply a method here.</p><p>Undoable/Undone: Whether this command can be undone, and if so, whether it was undone yet.</p><p>Show-In-Why-Menus: As discussed above, the programmer might determine that some commands should not be shown to the user as part of "why" menus even though they are undoable. For example, the Crystal text editor allows regular typing to be undone, but does not add to the "why" menus. The programmer can set Show-In-Why-Menus to false for these kinds of commands. Conversely, normally sub-commands are not shown to users in the "why" menus, and instead just the top-level command would be included. However, if the programmer wants to allow the user to ask about a sub-command, then its Show-In-Why-Menus can be set to true. An example is that when a new character is typed, the top-level typing command is not displayed in the "why" menus, but if the new character inherits its formatting from a named style, the programmer might want the sub-command that sets the character's properties from the style to appear on the "why" menus, since that may be mysterious to some users.</p><p>When a command's Enabled property specifies that it is disabled, but the user tries to execute it anyway (e.g., typing Control-C with nothing selected), then a command object is put on the command list with its Enabled property set to false to show that it was not actually executed. These unexecuted commands allow Crystal to support asking of "why not" questions (Figure <ref type="figure" target="#fig_1">2</ref>). Of course, these commands are not undoable, since they were never executed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Supporting Do/Undo/Redo</head><p>In the Crystal framework, an application object, such as a character in a text editor or a rectangle in a graphics editor, is represented as a set of "properties." Examples of properties for a character include the value (e.g., "b") and the font. In order to support undo, the old values of properties must be remembered. The Amulet command objects <ref type="bibr" target="#b15">[16]</ref> stored the old values in the command objects themselves. Instead in Crystal (like the Whyline <ref type="bibr" target="#b10">[11]</ref>) each property of an object contains a list of all of the old values. Each value is marked with a timestamp, which makes it easy to revert an object to all the correct values at any previous point in the history. If the old values were in the command objects instead, this would require searching all the commands for the appropriate values. Each old value also contains a pointer to the command object that set it, and that command object will contain the same timestamp. Note that making the properties be first-class objects like this is common in many modern toolkits. For example, Swing requires that some properties be objects so that other objects can install propertylisteners on them to be notified of changes.</p><p>When the user performs undo and then performs a new command, the undone commands can never be redone, so most previous systems throw away the command objects. However, in Crystal, we keep a complete history of all previous actions, even if they were undone, so nothing is ever popped off the command list. Instead, undo causes a new Undo-Command object to be added to the head of the list, with a new sub-command that undoes the appropriate action. Then, the command that was undone is marked as undone, so future undo commands will know to skip it.</p><p>Note that, as in Microsoft Word, the automatic correction features are added as undoable commands, so, for example, when the user types "teh " and Crystal changes it to "the ", the auto-correct-command is added to the command list, so the user can undo the auto-correction separately from undoing the typing of the space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Connecting Properties of Objects to Commands</head><p>As mentioned above, each property of objects in Crystal contains a current value and a list of old values (see Figure <ref type="figure" target="#fig_8">8</ref>). Each value is associated with a timestamp and a reference to the command object that caused it to have the current value. Values that are inherited, for example from styles, will still have a local value but there will be an associated property that specifies that the value is inherited. The command object associated with the property will be the</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Name Function</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Do-Method</head><p>Performs the action, e.g. changes the font to bold</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Undo-Method</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Undoes the action</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Redo-Method</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Redoes the action</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Object-Modified</head><p>Object affected by this action, so the command can be undone.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Enabled</head><p>Boolean to determine if action can be invoked now</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Label</head><p>String that describes this command</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Dependencies</head><p>Which properties of which objects are used by this command</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Invoking-Control</head><p>Which control was used to invoke this command</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Questions-Method</head><p>Supports application-specific questions</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Undoable/Undone</head><p>Field that notes whether this command was undone yet</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Show-In-Why-Menus</head><p>Boolean that flags whether this command should appear in Why menus one that caused the inheritance to happen, and that command object will contain the reference to where the value came from. For example, if a character's font size is 18, which is inherited from a style named "Header", the character's font-size property will contain a value 18 with a reference to an Inherit-From-Style-Command object, which in turn will reference the Header style object. The character will also have an internal Font-Size- Inherited property with the value true.</p><p>Properties in Crystal have a number of additional parameters beyond those needed just to support undo (see Figure <ref type="figure" target="#fig_8">8</ref>). Internal properties like Font-Size-Inherited have Show-In-Why-Menus set to false so they will not be made visible to users in the "why" menus. Each property also knows the full set of controls that can affect it directly. For example, the bold property of a character knows about Control-B, the "Toggle Bold" item in the Edit menu, and the "b" button in the toolbar. However, the character bold property does not need to know about the "b" button in the paragraph window, since that operates on the bold property of paragraph styles, and when appropriate, Crystal can deduce that it was used by following the dependency information. The list of controls is used to tell the user how the property can be changed.</p><p>To explain to the user how values were derived for properties that are never explicitly set, the application designer must add a special non-undoable command to the beginning of the command list which represents all the default, initial values. Then, question and answers can be handled automatically by Crystal, as can be seen in Figure <ref type="figure" target="#fig_0">1</ref>, where auto-correct has its default value. For systems such as Microsoft Word where initial values can come from many different places: such as various options, Normal.dot, etc., the designer would add multiple initialization command objects with custom question methods, so each can describe how the user would change the corresponding default value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Generating the List of Questions</head><p>Generating the list of questions for the "why" menu is straightforward. It is just the last few user-visible items in the command list. Note that it will often include more than what would be available in the undo history, since unexecuted commands and the undo commands themselves will be in the "why" menu. As discussed above, some commands, such as regular typing, are not added to the "why" menu as controlled by the Show-In-Why-Menus flag on the commands. The questions used both fixed and dynamic information about what happened (as shown in Figure <ref type="figure" target="#fig_1">2</ref>).</p><p>Generating the list of questions for the F1 menu is more involved. First, Crystal uses a Swing mechanism to iterate through the components under the mouse, and checks each to see if it implements the Question-Askable interface, and if so, calls it. There are three basic ways this interface is implemented by the Crystal framework.</p><p>The first is used when F1 is hit on a Swing control, such as a menu or toolbar item, and then associated the command object is used. The programmer can provide a string explaining what the command does. The Enabled property of the associated command is automatically checked to see if an additional question should be generated about why the control is disabled. In this case, the programmer can provide a string to explain how to make it be enabled.</p><p>The second way is used for objects that have properties. In this case, the framework can handle the questions and answers without help from the programmer. All the uservisible properties of the object, along with their current values, are added in a sub-menu, as shown in Figure <ref type="figure" target="#fig_2">3</ref>. The user typed "g" in Figure <ref type="figure" target="#fig_4">5</ref> while "helpful" was selected, so it was deleted. Crystal inserts an invisible marker in the text so a question will appear about the deleted object.</p><p>The third way is used for describing why graphical objects were created or deleted, and is also automatically handled by Crystal. All graphical objects have a pointer to the command that created them so it can be added. Auto-correction is actually implemented as a special kind of create, so a question about auto-correction will be displayed for the appropriate text. However, in this case we added a custom question method to specifically describe the automatic features and dependencies. Objects that are deleted by the user leave invisible objects where they used to be, linked to the commands that deleted them. In a regular graphical editor, this would make it easy to ask about the object that used to be at a location. In the sample text editor, the objects are invisible markers that flow with the text (see Figure <ref type="figure" target="#fig_7">9</ref>).</p><p>In the text editor, we added a custom method for whitespace that adds an extra question that asks about the whitespace itself. Alternatively, the programmer can provide special invisible objects in all the blank areas, and let them generate questions about why the area is empty.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Name Function</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Value</head><p>Value of the property, e.g., "b"</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>My-Object</head><p>Backpointer to the object this is a property of Whether this property should be shown in the "why" menus</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Invoking-Controls</head><p>All the controls that could change this property's value </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Generating the Answers</head><p>For most questions, Crystal has built-in techniques for generating the answers. For properties of objects (e.g., "Why is the 'g' not bold"), the answer for why it has its current value is provided by showing the operation that caused it to have that value, and recursively, why that operation happened. Therefore, asking about a property of an object is the same as asking about the command that caused that property to have its current value. This observation was also made by the Whyline study <ref type="bibr" target="#b10">[11]</ref> where the "Why is…" questions that were originally in the menus were removed because users were confused about the difference from the "Why did" questions.</p><p>For a property that was set locally on the object (such as a character that was explicitly set to bold), the answer says that it was set by the user, as in Figure <ref type="figure" target="#fig_4">5</ref>. The corresponding control is also highlighted, by referencing the Invoking- Control of the command.</p><p>When the property's value is inherited, for example when a font size property comes from a named style, then the answer must include a discussion of the inheritance, as well as the final place in which the value was set, as in Figure <ref type="figure" target="#fig_5">6</ref>. This required a custom answer method in the sample text editor, to generate understandable messages. However, facilities in the Crystal framework automatically traverse the command's Dependencies to determine the properties that contributed to the current value. If any of those properties themselves were inherited, then Crystal recursively goes to those properties' commands, and then to their De- pendencies, etc. At each step, Crystal checks to see if the property is marked as Show-In-Why-Menus. If so, another sentence is added to the answer window. (Internal properties are often involved in dependencies, but should not be shown because users cannot change them.) When there are multiple steps, then a "How can I…" question is added to the end of the answer, so the user can ask about each step individually.</p><p>To highlight the controls, Crystal needs the ability to bring up widgets programmatically, set them to specific values, find their location, and highlight them, while still having them be operational for the user. Furthermore, the dialog boxes need to keep track of what causes them to be displayed, so Crystal can highlight the appropriate menu item. We were able to implement all of these using the Swing toolkit. Such support is also available in other commercial toolkits such as Mac OS X's Cocoa, where it has been used to implement several types of universal access features.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Implementing the Sample Text Editor</head><p>We implemented parts of a sample text editor using the Crystal framework as a test. We used a Model-View design, where the view uses the Java Swing TextLayout to format each line. Like Glyphs <ref type="bibr" target="#b3">[4]</ref>, Crystal's model uses an object for each character that stores the letter and all of its properties (font, size, bold, etc.) except location, which is handled by the layout. Along with the regular characters, the Crystal editor adds special invisible markers to show where various operations occurred, such as deleting text. A marker moves with the characters to its left (if any), and can never be deleted (although the question mechanism could decide not to include old deletions in the "why" menus). Styles are implemented as objects with sets of properties that can be inherited by characters. There are no additional structures needed for words or paragraphs in Crystal. About 10% extra code (most of it quite simple) was needed to add support for answering why questions to the text editor.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Other Kinds of Applications</head><p>We believe it would be straightforward to use the Crystal framework to implement other types of applications. We chose to implement a text editor because it seemed like the most difficult. For a drawing editor like Microsoft Power-Point, each graphical object would have a list of usersettable properties and Crystal would automatically keep track of which commands set them. For "smart" operations, such as the automatic adjustment of font sizes, and moving of attached lines when boxes are moved, the developer would add extra commands to the command list to explain why these happened. When the user hits F1, the system should return all objects under the mouse, including individual objects, groups, and background ("master") objects, and put these into the first-level menu. An implementation for spreadsheets might combine the techniques described here with techniques discussed elsewhere <ref type="bibr" target="#b20">[21]</ref> [1] that explain how the values were calculated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>USER STUDY</head><p>A small lab study was performed to evaluate whether the "why" menus in Crystal were usable, and to what extent they helped users understand what was happening in their user interfaces.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Experimental Setup and Participants</head><p>We used a between-participants design, because the key issue is learning about how to use the system. One group used the Crystal sample text editor as shown here, and the other used the identical text editor, but with the "why" menu removed, and F1 disabled. Each group contained 10 participants, all between the ages of 18 and 53 with an average age of 24. 12 participants were male and 8 female. We recruited participants who reported "little or no" experience with Microsoft Word, although they all had extensive general computer experience, and all but two had experience with other text editors. Those two happened to both be in the group with the "why" menus. Participants were randomly assigned to one of the two groups and were paid to participate. The experiment was conducted on a laptop and was recorded.</p><p>Both groups received the identical six tasks. These were derived from real observations of Microsoft Word users, published articles about difficulties with Word, and an inspection of Microsoft's support pages. The tasks represent common issues that real Word users encounter. In sum-mary, the tasks were (1) turn off automatic capitalization;</p><p>(2) turn off automatic spelling correction; (3) change paragraph formatting; (4) explain why the "Paste" menu item is grayed out; (5) use the Styles mechanism to change italics of some headings; and (6) use the inheritance property of the Styles mechanism to adjust the font size of all headings. However, the tasks were not presented this way. We demonstrated a problem or a surprising behavior (or let the user do it), and then asked them to fix it. For example, the experimenter read the following script as the stimulus for the first task:</p><p>1. Type in the following sentence "The abbreviation fl. oz. stands for fluid ounce." 2. You notice that the word processor has capitalized some characters for you, but you don't want this to happen. 3. Your task is to make the automatic capitalization not happen again. 4. When you think you're done, type "fl. oz. stands" again to make sure it works.</p><p>In order to make the experiment somewhat realistic, we copied Microsoft Word 2003's "Tools" menu and the "Options" and "Auto Correct Options" dialogs that are invoked using the Tools menu (see Figure <ref type="figure" target="#fig_0">1</ref>). All of the submenus and the various tabs on each of these were live, so the users would have to search through more places. Both tasks 1 and 2 required using the "Auto Correct Options" dialog (Figure <ref type="figure" target="#fig_0">1</ref>), and no task required using the Options dialog. Tasks 3, 5 and 6 required using the paragraph styles dialog (Figure <ref type="figure" target="#fig_5">6</ref>).</p><p>The dependent measures were whether the participants were able to complete the tasks at all and how long they took for the ones they completed. A few users got stuck and required hints, and then we counted them as unsuccessful.</p><p>We were also interested in usability observations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Results</head><p>Because not all participants completed all tasks successfully, the data could not be analyzed using a standard repeated-measures ANOVA. Therefore, we analyzed both the number of tasks completed and the mean time per completed task using between-participants ANOVA. Participants in the "why" menus condition completed an average of 5.60 (93%) of the tasks whereas those without "why" menus completed an average of 4.20 (70%) of the tasks (F [1, 20] = 12.60, p &lt; .005). As shown in Figure <ref type="figure" target="#fig_0">10</ref>, participants with "why" menus had an advantage in each of the six tasks.</p><p>Figure <ref type="figure" target="#fig_0">11</ref> shows the average time per task for those participants who could finish it. Participants with "why" menus completed each task in an average of 91.38 (SD = 51.66) seconds, whereas those without "why" menus required an average of 137.74 seconds (SD = 49.62). This difference approached significance (F [1, 20] = 4.19, p = .06).</p><p>The anomalous value for task 6 seems to be due to a few participants in the "without" group accidentally figuring out a workable strategy during task 5, compared to the "why" menu group who almost all used the "why" menus to try to learn how inheritance works.</p><p>The participants who saw them really liked the "why" features. Each of the statements got an average agreement value of greater than 6.2 out of 7: "I understand how to use the Why feature in Crystal", "I found the Why feature easy to use", "The Why feature improved my word-processing experience", "The answers provided by the Why feature were easy to understand", "The answers provided by the Why feature were what I wanted to know", "I was comfortable using the Why feature", and "I would really like a Why feature like this in the programs I use."  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Discussion</head><p>Clearly, the "why" menus were helpful to users. It is not surprising that the later tasks fared worse, since these tasks were quite difficult, even for some experts. For some people, the "why" features played the crucial role of explaining the concept to some of the participants, which directly led to successful task completion. However, Crystal is not necessarily designed to serve as a tutorial, and it probably did not teach participants about the concept of inheritance if they did not know it already.</p><p>We had a number of usability observations about the system. Most of the participants preferred using the F1 key to have more control over the questions they could ask. It seemed that the most efficient people used the F1 key first. Some participants were reticent to use the F1 key-this apparently was not a natural interaction for them. They used the "Ask about a location…" item in the "why" menu when the desired question was not in the "why" menu directly.</p><p>Participants using the "why" features generally knew which objects they should ask questions about, and the questions that showed up matched their expectation. A lot of trialand-error clicking of menus happened for participants who did not have the "why" features, while the "why" people did not, and seemed to be more purposeful and effective.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FUTURE WORK AND CONCLUSIONS</head><p>An obvious next step for Crystal is to do a more complete implementation of the framework so full applications can be built with it, to verify that the ideas scale up and work well in different domains. It would be useful to be able to field-test applications supporting the "why" menus to see to what extent they really help in practice. It would be interesting to see if the Crystal framework would be easier to implement on top of a toolkit with a constraint system such as Citrus <ref type="bibr" target="#b11">[12]</ref>. Another open question is how important it is to save the Why information across sessions, so that later users can ask questions about the contents of files read from the disk. We know of no system that saves the undo or command history with the files. The current framework cannot answer questions about operations that are no longer part of the command history.</p><p>Everyone to whom we have described the ideas in Crystal has remembered situations in which they wished they could have asked their applications and operating systems why things happened. As even more sophisticated and "intelligent" operations are increasingly added to future systems, asking why will be even more important. Even if natural language processing were to become successful, making the need for Crystal's popup "why" menus unnecessary, the Crystal architecture would still be useful for collecting and organizing the needed information.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1:The answer for why "Teh" was changed into "The". The pink "?" in the upper left shows where the F1 key was hit.</figDesc><graphic coords="1,316.20,190.80,240.71,191.52" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: "Why" menu. The top item lets the user click for where to get help. The next two actions in the menu did not happen.</figDesc><graphic coords="4,54.30,225.90,240.54,80.22" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Menus resulting from hitting F1, showing sub-menus for the character (a) and paragraph (b) properties.</figDesc><graphic coords="4,54.24,329.10,240.78,108.06" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Questions about blank areas when hit F1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5:The answer to "Why is the 'p' bold?", when it was because the user set the property using the toolbar button.</figDesc><graphic coords="4,73.26,542.22,202.68,150.84" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: The answer shown for when a property's value is inherited from a style.</figDesc><graphic coords="5,54.00,283.86,241.08,388.50" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Fields and methods of the command objects in Crystal. Properties in bold are novel.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9:The user typed "g" in Figure5while "helpful" was selected, so it was deleted. Crystal inserts an invisible marker in the text so a question will appear about the deleted object.</figDesc><graphic coords="7,316.80,381.90,225.72,63.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Fields and methods for Properties of Objects</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 10 :Figure 11 :</head><label>1011</label><figDesc>Figure 10: Percent of people in each group that completed the tasks and the overall average. Taller bars are better.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>Thanks to Susan Fussell for extensive help with the statistics for this paper. Thanks also to Jake Wobbrock and Andrew Faulring for help with this paper. This work was partially supported under NSF grant IIS-0329090 and by the EUSES Consortium via NSF grant ITR-0325273. Opinions, findings and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect those of the NSF.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Goal-Directed Debugging of Spreadsheets</title>
		<author>
			<persName><forename type="first">R</forename><surname>Abraham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Erwig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VL/HCC 2005</title>
		<meeting><address><addrLine>Dallas, TX</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="37" to="44" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A Selective Undo Mechanism for Graphical User Interfaces Based on Command Objects</title>
		<author>
			<persName><forename type="first">T</forename><surname>Berlage</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Human Interaction</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="269" to="294" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">ACT-R Environment Manual</title>
		<author>
			<persName><forename type="first">D</forename><surname>Bothell</surname></persName>
		</author>
		<ptr target="http://act-r.psy.cmu.edu/software/EnvironmentManual.pdf" />
		<imprint>
			<date type="published" when="2004">Version 5.0, April 22. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Glyphs: Flyweight Objects for User Interfaces</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">R</forename><surname>Calder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Linton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">UIST 1990</title>
		<meeting><address><addrLine>Snowbird, Utah</addrLine></address></meeting>
		<imprint>
			<biblScope unit="page" from="92" to="101" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Accounting for System Behaviour: Representation, Reflection and Resourceful Action</title>
		<author>
			<persName><forename type="first">P</forename><surname>Dourish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third Decennial Conference on Computers in Context CIC&apos;95</title>
		<meeting>the Third Decennial Conference on Computers in Context CIC&apos;95<address><addrLine>Aarhus, Denmark</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Helping users to use help: improving interaction with help systems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Dworman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rosenbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CHI 2004 Extended abstracts</title>
		<meeting><address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<biblScope unit="page" from="1717" to="1718" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Eclipse help system: an open source user assistance offering</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Halsted</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Roberts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGDOC 2002: Proceedings of the 20th annual international conference on Computer documentation</title>
		<meeting><address><addrLine>Toronto, Ontario, Canada</addrLine></address></meeting>
		<imprint>
			<biblScope unit="page" from="49" to="59" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Stencils-based tutorials: design and evaluation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Kelleher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pausch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CHI 2005</title>
		<meeting><address><addrLine>Portland, OR</addrLine></address></meeting>
		<imprint>
			<biblScope unit="page" from="541" to="550" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Towards a New Model of Abstraction in Software Engineering</title>
		<author>
			<persName><forename type="first">G</forename><surname>Kiczales</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IMSA&apos;92 Workshop on Reflection and Meta-level Architectures</title>
		<meeting>the IMSA&apos;92 Workshop on Reflection and Meta-level Architectures</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Apple guide: a case study in user-aided design of online help</title>
		<author>
			<persName><forename type="first">K</forename><surname>Knabe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CHI 1995 Conference companion. Denver</title>
		<imprint>
			<biblScope unit="page" from="286" to="287" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Designing the Whyline, A Debugging Interface for Asking Why and Why Not questions about Runtime Failures</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Ko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CHI</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="151" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Citrus: A Toolkit for Simplifying the Creation of Structured Editors for Code and Data</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Ko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">UIST 2005</title>
		<meeting><address><addrLine>Seattle, WA</addrLine></address></meeting>
		<imprint>
			<biblScope unit="page" from="3" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The role of context in question answering systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CHI 2003 extended abstracts. Ft</title>
		<meeting><address><addrLine>Lauderdale, FL</addrLine></address></meeting>
		<imprint>
			<biblScope unit="page" from="1006" to="1007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">The Case for an Open Data Model</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Myers</surname></persName>
		</author>
		<idno>CMU-CS-98-153</idno>
		<imprint>
			<date type="published" when="1998-08">August, 1998</date>
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon University, School of Computer Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Scripting Graphical Applications by Demonstration</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CHI 1998</title>
		<meeting><address><addrLine>Los Angeles, CA</addrLine></address></meeting>
		<imprint>
			<biblScope unit="page" from="534" to="541" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Reusable Hierarchical Command Objects</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kosbie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CHI 1996</title>
		<meeting><address><addrLine>Vancouver, BC, Canada</addrLine></address></meeting>
		<imprint>
			<biblScope unit="page" from="260" to="267" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m">LabVIEW. National Instruments Corporation, 11500 N Mopac Expwy</title>
		<meeting><address><addrLine>Austin, TX</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="78759" to="73504" />
		</imprint>
		<respStmt>
			<orgName>National Instruments</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Heuristic evaluation of user interfaces</title>
		<author>
			<persName><forename type="first">J</forename><surname>Nielsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Molich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CHI 1990</title>
		<meeting><address><addrLine>Seattle, WA</addrLine></address></meeting>
		<imprint>
			<biblScope unit="page" from="249" to="256" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">The Design of Everyday Things</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Norman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<publisher>Doubleday</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Providing intelligent help across applications in dynamic user and environment contexts</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ramachandran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Young</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IUI 2005</title>
		<meeting><address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<biblScope unit="page" from="269" to="271" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Interactive, Visual Fault Localization Support for End-User Programmers</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Ruthruff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Journal of Visual Languages and Computing</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="3" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Coupling A UI Framework with Automatic Generation of Context-Sensitive Animated Help</title>
		<author>
			<persName><forename type="first">P</forename><surname>Sukaviriya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Foley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">UIST 1990</title>
		<meeting><address><addrLine>Snowbird, Utah</addrLine></address></meeting>
		<imprint>
			<biblScope unit="page" from="152" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Finding relevant documents using top ranking sentences: an evaluation of two alternative schemes</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>White</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Ruthven</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Jose</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGIR &apos;02: The 25th annual international ACM SIGIR conference on Research and development in information retrieval</title>
		<meeting><address><addrLine>Tampere, Finland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="57" to="64" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
