<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">An Integration of Model Checking with Automated Proof Checking*</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">S</forename><surname>Rajan</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Laboratory SRI International</orgName>
								<address>
									<postCode>94025</postCode>
									<settlement>Menlo Park</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">N</forename><surname>Shankar</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Laboratory SRI International</orgName>
								<address>
									<postCode>94025</postCode>
									<settlement>Menlo Park</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Srivas</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Laboratory SRI International</orgName>
								<address>
									<postCode>94025</postCode>
									<settlement>Menlo Park</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">An Integration of Model Checking with Automated Proof Checking*</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">A6B021C1A0A68008778479BB664DDEB6</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:16+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Although automated proof checking tools for generalpurpose logics have been successfully employed in the verification of digital systems, there are inherent limits to the efficient automation of expressive logics. If the expressiveness is constrained, there are useful logic fragments for which efficient decision procedures can be found. The model checking paradigm yields an important class of decision procedures for establishing temporal properties of finite-state systems. Model checking is remarkably effective for automatically verifying finite automata with relatively small state spaces, but is inadequate when the state spaces are either too large or unbounded. For this reason, it is useful to integrate the complementary technologies of model checking and proof checking. Such an integration has to be carried out in a delicate manner in order to be more than just the sum of the techniques. We describe an approach for such an integration where a BDD-based model checker for the propositional mu-calculus has been used as a decision procedure within the framework of the PVS proof checker. We argue that our approach fits in nicely with the design philosophy of PVS of providing highly effective mechanical reasoning capability by using efficient decision procedures as the workhorses of an interactive proof checker.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">I n t r o d u c t i o n</head><p>In the theorem proving approach to verification, a system and its properties are described by means of logical formulae and the system is shown by means of a logical proof to entail the desired properties. This approach when supplemented with the use of automated theorem proving tools has been employed successfully in the verification of digital hardware and software systems. Though this approach is very general and applies to a large variety of systems and properties, there are inherent limits to the efficiency with which expressive general-purpose logics can be fully mechanized. There are two approaches for dealing with this limitation. The first approach is to use interactive proof checkers so that correctness proofs can be developed using a combination of user guidance and limited forms of automated deduction. The second approach has been to find useful fragments of logic that can be mechanized very effectively. Model checking is an important instance of the latter approach for the verification of temporal properties of finite-state systems. The finite-state system is represented as a Kripke model and the system property is represented as a formula in propositional temporal logic. For certain temporal logics such as CTL <ref type="bibr" target="#b4">[5]</ref>, the model-checking problem is linear even when the decidability of the logic itself is EXPTIMEcomplete <ref type="bibr" target="#b9">[9]</ref>.</p><p>Model checking thus provides a fully automatic technique for deciding an important class of verification problems. The importance of such automation cannot be overemphasized. The effort required to construct logical proofs of correctness for these problems can be large since it requires the discovery of suitably strong invariant. The primary disadvantage of model checking is that it only works well for small state spaces. This limitation can be partially overcome through the use of binary decision diagrams (BDD) and symbolic model checking <ref type="bibr" target="#b2">[3]</ref>. Here the state space and the automaton transition relation are represented by means of binary decision diagrams which provide a representation for entire classes of states rather than individual states. Even so, the state explosion problem limits the applicability of model checking in practice. BDDs also require a lot of careful attention to variable ordering which often requires significant manual effort. A lot of careful reasoning is required to abstract the real problem into one with a finite state.</p><p>Since proof checking and model checking are complementary technologies, it seems reasonable to somehow combine them. Even so, there has been very little progress in achieving such a combination in an effective manner. The HOL/Voss system <ref type="bibr" target="#b15">[15]</ref> is an early attempt in this direction. In this combination, the HOL proof checker <ref type="bibr" target="#b12">[12]</ref> is given input that contains constants that are uninterpreted for HOL but given an interpretation in Voss which is a symbolic model checker. Voss is used to establish properties of these constants and the resulting assertions are fed back to the HOL proof as lemmas. In the HOL/Voss implementation the connection between the two systems is not close enough for the properties established by Voss to be proved directly in the unextended HOL system. <ref type="bibr">Kurshan and Lamport [17]</ref> present a similar connection between the TLP proof checker for TLA, the temporal logic of actions, and COSPAN <ref type="bibr" target="#b18">[18]</ref> which is a language containment verifier based on BDDs. They present a proof of a multiplier where the 8-bit multiplier can be verified by COSPAN and N-bit multiplier composed from 8-bit multipliers can be verified in TLP <ref type="bibr" target="#b11">[11]</ref>. In <ref type="bibr" target="#b17">[17]</ref>, the two systems used to verify the multiplier were used independently and not actually integrated. Hungar describes a similar effort where a model checker is used to verify properties of processes and a syntactic formalization of MCTL is used to verify the composition of the individual processes.</p><p>There is other relevant work where model checking has been extended in significant ways to deal with problems involving large and unbounded state spaces. Wolper and Lovinfosse <ref type="bibr" target="#b25">[25]</ref> and <ref type="bibr">Kurshan and McMillan [19]</ref> present techniques where model checking can be used for the inductive step by using an invariant to capture the induction hypothesis. This approach can be used for example to verify an N-bit buffer and the N-dining philosopher problem.</p><p>The goal of the present work is to present a smooth and tight integration of model checking with theorem proving in the context of the PVS proof checker <ref type="bibr" target="#b23">[23]</ref>. The propositional mu-calculus serves as a basis of our approach. An extension of the mu-calculus is defined using the higher-order logic of PVS. The temporal operators are then given their customary fixpoint definitions using the mu-calculus. These temporal operators apply to arbitrary state spaces. In the instance when the state type is constructed in a hereditarily finite manner, we translate mu-calculus expressions to input acceptable by a mu-calculus model checker. This model checker can then be used as a decision procedure within a proof to prove certain subgoals. This yields a tight integration between PVS and the mu-calculus model checker since the latter is used as a decision procedure for a well-defined fragment of PVS.</p><p>Typical uses for the capability provided by our integrated system include the verification of temporal properties of finite-state abstractions of systems, and the use of model checking in the induction step of iterated finite-state systems. Examples verified by the combined system include Paterson's 2-process mutual exclusion algorithm, the alternating-bit protocol, a simple counter, and an arbiter for a CPU running concurrently with a lookahead-fetch unit. Our basic approach can be generalized to also integrate temporal logic model checkers such as SMV <ref type="bibr" target="#b20">[20]</ref> and language containment systems such as COSPAN <ref type="bibr" target="#b18">[18]</ref>.</p><p>Our approach is quite similar to that of Dingel and Filkorn <ref type="bibr" target="#b8">[8]</ref> in that they use a combination of a model checker for LTL and a theorem prover for firstorder logic, but with a looser integration than the one we present. Miiller and Nipkow <ref type="bibr" target="#b22">[22]</ref> also describe a combination of model checking and theorem proving using I/O automata where they verify the main safety property of the alternating bit protocol using a property-preserving abstraction that yields a finite-state system. Such property-preserving abstractions in the context of model checking have also been studied by Graf <ref type="bibr" target="#b13">[13]</ref>, Clarke, Grumberg, and Long <ref type="bibr" target="#b4">[5]</ref>, and Dams, Grumberg, and Gerth <ref type="bibr" target="#b6">[7]</ref>.</p><p>The rest of the paper is organized as follows: The propositional mu-calculus is introduced in Section 2.1 The definition of CTL and fairCTL operators in terms of mu-calculus and their embedding in PVS are discussed in Section 2.2. The translation of a finite-state fragment of the mu-cMculus into input acceptable by a model checker for propositional mu-calculus is shown in Section 2.3. The use of abstraction for reducing the verification of arbitrary transition system to finitestate ones is described in Section 3. Section 4 presents the basic methodology for using the model checker as a decision procedure within a proof, and then describe a significant example that exploits the model checker. This example was motivated by a problem that we encountered during the verification of a commercial processor, AAMP5 <ref type="bibr" target="#b21">[21]</ref>, using PVS. The verification of AAMP5, which contains almost half a million transistors, is too large to be verified entirely by a model checker. Conclusions are summarized in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Model Checking within Theorem Proving</head><p>Our primary design choice in integrating model checking with PVS is to view model checking as a decision procedure for a well-defined fragment of PVS. Transition systems can be described in terms of a next-state relation over a specific state type. The temporal operators then permit assertions over the states and computation paths in such a transition system. The mu-calculus can be used to define such temporal operators. The higher-order logic of PVS is used to define a mu-calculus theory that is parametric in its state type. The CTL operators can be defined using the mu-calculus. These operators are parametric both in the state type and a given next-state relation over this state type. Formulas in the mu-calculus over finite state types can be translated into the propositional mu-calculus where the state type is just a tuple consisting of booleans. We first present the mu-calculus and the propositional mu-calculus. We then briefly describe the definition of the CTL and fairCTL operators. Finally, we discuss the translation between the mu-calculus over finite types and the propositional mu-calculus so that a decision procedure for the propositional case can be used for the finite case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Propositional mu-calculus and Temporal Logic: Overview</head><p>Propositional mu-calculus is an extension of propositional calculus that includes universal and existential quantification on propositional variables (i.e., quantified Boolean formulas), and predicates defined by means of the least and greatest fixpoint operators, # and v, respectively. It is strictly more expressive than CTL*, and provides a framework to express fairness and extended temporal modalities <ref type="bibr" target="#b10">[10]</ref>.</p><p>There have been several variations of mu-calculus proposed in the past <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b16">16,</ref><ref type="bibr" target="#b24">24]</ref>. We closely follow the formal definition of the syntax of propositional mu-calculus from Burch, et al <ref type="bibr" target="#b2">[3]</ref>, that forms the basis of the model checker <ref type="bibr" target="#b14">[14]</ref> used in this work. Let 27 be a finite signature, in which every symbol is a propositional variable or a predicate variable with a positive arity. The two syntactic categories formulas and relational terms are defined in the following manner. A formula is either: -Z, an n-ary predicate variable in S -Azx, z2,..., z,~. f, where f is a formula and zl, z2,..., z, are propositional variables in S.</p><p>-pZ. P[Z], denoting the least fixpoint of P. Here, Z is an n-ary predicate variable in S and P[Z] is a relational term formally monotonic in Z (i.e., Z occurs under an even number of negations in P[Z]). Similarly, vZ. P is the greatest fixpoint of P, and is equivalent to the negation of the least fixpoint of "-,P <ref type="bibr">[~Z]</ref>.</p><p>The satisfiability and model-checking problems for propositional mu-calculus expressions are decidable since fixpoints exist and can be computed. We can generalize the propositional mu-calculus to obtain a mu-calculus for an arbitary type by allowing relational terms to be predicates over this state type. Quantification must also be generalized to range over the state type. Stirling and Bradfield <ref type="bibr" target="#b0">[1]</ref> describe a tableau proof system for a similar mu-calculus.</p><p>Temporal logics such as CTL with extensions of fairness (fairCTL) and other temporal modalities can be succinctly expressed using the mu-calculus <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b10">10]</ref> defined above. Additionally, it has been shown that LTL model checking can be reduced to fairCTL model checking <ref type="bibr" target="#b3">[4]</ref>. CTL is a branching-time temporal logic that can quantify over paths in a computation tree. It can thus capture temporal possibility but not, in general, inevitability. The latter notion requires a lineartime temporal logic. The definitions of selected CTL operators are shown below.</p><p>Let N be a binary next-state relation over the state type cr and let p and q be relational terms over cr. The predicate (EXp) holds at a state x ifp holds at some successor state. The predicate EGp holds at z if p holds on every state along some infinite path of successive states leading out of x. The predicate E(pUq) holds at state x if there is a state y where predicate q holds that is reachable along a path of successive states leading out of x where p holds until q does.</p><formula xml:id="formula_0">(EXp)(x) = 3z. p(z) A g(z, z) (EGp)(x) = (vZ. ()~z. p(z) A (EXZ)))(x) (E(pUq))(x) = (#Z.Az. q(z) V (p(z) A (EXZ)(z)))(x)</formula><p>2.2 Mu-Calculus and CTL in PVS PVS employs a specification language based on a simply typed higher-order logic so that it is permissible to quantify over predicate variables and variables that are functions, or functions of functions, and so on. The type of functions from type S to T is represented as [S -&gt; T]. The type of predicates over type T is then represented as [T -&gt; bool] (abbreviated as PRED IT]), where bool is the type of booleans consisting of TRUE and FALSE. The everywhere-true predicates T and the everywhere-false predicate .l_ can be represented as LANBDA (x:T): TRUE and LANBDA (x:T) : FALSE, respectively. We can define a pointwise ordering &lt;= of predicates, say pl and p2, of type PRED[T] as (pl &lt;= p2) = (FORALL (x:T) : pl(x) INPLIES p2(x)). When pl &lt;= p2 we say that p1 is stronger than p2 or conversely that p2 is weaker than p1.</p><p>We can lift the logical operations like conjunction, negation, and disjunction to predicates by overloading the symbols used for the corresponding boolean operations. For example, pl AND p2 can be defined as (FORALL (x:T) : pl(x) AND p2(x)). A predicate transformer for predicates over T has the type</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>[PRED [T] -&gt; PRED [T] ]</head><p>. A predicate transformer is monotonic if it preserves the &lt;= ordering on predicates. Given a monotonic predicate transformer pp, the predicate rau(pp) is defined to be the least fixpoint of pp, and nu(pp) is defined to be its greatest fixpoint. The Tarski-Knaster argument for the unique existence of these fixpoints is easily verified in PVS.</p><p>Given mu and nu, we can define the CTL operators so that they are parametric in the next-state relation N of type I'T, T -&gt; bool], where f, g, and h range over predicates of the state type. It is useful to be able to assert that a temporal property holds along some fair path or along all fair paths. There are many different notions of fairness. A simple and useful notion of fairness is given by characterizing the fair paths as those along which a fairness predicate holds infinitely often. This form of fairness cannot be expressed in CTL but can easily be defined in the mu-calculus. Let fairEG(N, f)(h)(u) assert the existence of a fair path from u along which f holds on each state and h holds infinitely often. This has the following definition in the PVS formalization of the mu-calculus.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>EX(N,f)(u):bool</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>fairEG(N, f)(h) = nu(LANBDA p. EU(N, f, f AND h AND EX(N, p)))</head><p>The other fairCTL operators, fairAF, fairAG, fairEF, etc., are defined by using the fairE6 operator in the same manner as Burch et al <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b20">20]</ref>. The advantage of having an explicit formalization of fairness in a verification system is that it allows one to check if there exists at least one fair path in a given model. Without such an explicit formalization, there is a danger of imposing fairness constraints that are never satisfied by the transition system so that many properties might hold trivially.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Translation from PVS to mu-calculus</head><p>Since the low-level BDD-based mu-calculus model checker accepts only the language of propositional mu-calculus as discussed in Section 2.1, an automatic translation is provided from the mu-cMculus fragment of the PVS language to propositional mu-calculus.</p><p>The fragment of the PVS language that is translated into mu-calculus consists of expressions involving types that are finite, i.e., constructed inductively from the booleans or scalar types using type constructors that are either tupies, records, or arrays over a specific finite subrange of the integers. The type of booleans is written in PVS as boo1. A scalar type consisting of cl,..., c, is written as {cl,..., cn}. A subrange type from specific integers lo to hi is written as subrange <ref type="bibr">[lo, hi]</ref> ))))(s) V (Yl A (Zl "-Yl ^~z2 ^z3--Y3^Z4 = Y4))</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>v ^ (zl ^z= ^z3= y3^z4= y4)))</head><p>The above translation has been automated in PVS. There is a single atomic proof step in PVS that can take a goal given by a PVS formula containing mu and nu operators, translate this to the propositional mu-calculus as shown above, and apply BDD-based model checking to this formula. The application of the model checker either proves the goal, returns a list of one or more subgoals corresponding to collection of initial states where the property fails to model check, or it merely applies boolean simplification to the goal. We have defined a PVS proof strategy that carries out a sequence of inference steps that simplify goal formulas written in the CTL fragment of PVS by expanding out the definitions of the CTL operators in terms of the mu and nu operators, and applies the model checking proof step to the result.</p><p>The fragment of the PVS language given above is rich enough to express specifications and properties of state-machine models in a structured manner. In comparison to language front-ends for other model checkers such as SMV <ref type="bibr" target="#b20">[20]</ref>, the PVS sublanguage used for model checking is more expressive, and has the significant advantage of a proof system for the language.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Using Model Checking during Proof Checking</head><p>Using the model checker to verify CTL or any other mu-calculus property of a finite-state system is of course straightforward. The state of the system is presented as a finite type in PVS. The system is then described in terms of an initialization predicate and a next-state relation. System properties can be expressed in the CTL fragment or in terms of any other operators definable using the mu-calculus. Such properties can be proved by a single proof command called model-check. This usage of the model-checking capability in PVS is not much of an improvement over a conventional model checker. The real increase in convenience comes from the ability to combine model checking with the use of abstraction, induction, and compositionality. All of these techniques have been well studied in the model checking literature but the bulk of the reasoning is carried out informally. We illustrate how our combined technology can be applied to these problems.</p><p>The use of abstraction is fundamental to exploiting the combination of theorem proving and model checking. Many simple system properties are expressible in VCTL whose formulas in negation normal form, i.e., with only atomic negations, contain only the universal A path quantifier and not the existential E path quantifer. As shown by Clarke, Grumberg, and Long <ref type="bibr" target="#b4">[5]</ref>, there is a simple way to construct abstractions in this case. Given a concrete state type C and an abstract state type A, we need a surjective mapping h from C to A that "preserves" the initialisation predicate, the next-state relation, and the property of interest. Let the concrete transition system Mc be described in terms of an initiMisation predicate Iv and a next-state relation Nc, and similarly the abstract transition system MA is given in terms of IA and NA. In order to show My ~ Pc A stronger version of the above conditions on abstraction is used in Section 4 to verify a liveness property of a simple pipelined microprocessor. These conditions on the abstraction can be extended in several ways to preserve properties in all of CTL or CTL* <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b6">7]</ref>. Dams, Grumberg, and Gerth <ref type="bibr" target="#b6">[7]</ref> present a notion of mixed abstraction that preserves all CTL* properties but involves multiple nextstate relations. The mu-calculus can in fact capture temporal formulas involving multiple next-state relations.</p><p>2 These conditions are somewhat different from those given by Clarke, Grumberg, and Long <ref type="bibr" target="#b4">[5]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Abstraction to Finite State</head><p>In this section, we demonstrate an application for our integrated facility where the model checker is used as a primitive step, i.e., a decision procedure, in a PVS proof. The application also illustrates the use of abstraction as a means of decomposing a potentially tedious manual proof into two automatic proofs, one involving theorem proving and the other model checking. The problem is a simplified version of a real verification problem that arose in the context of verifying a commercial microprocessor <ref type="bibr" target="#b21">[21]</ref>.</p><p>We verify a property of a small microprocessor CPU design that is an extension of the CPU example used by Butch, et al, <ref type="bibr" target="#b2">[3]</ref> to illustrate the power of symbolic model checking. The example is a register-transfer level design of the datapath and controller of a microprocessor that executes instructions of the form (opcode srcl src2 dstn) to perform both register-register and registermemory operations. The CPU consists of a three stage read-execute-write pipeline with suitable control logic to handle external asynchronous (hand-shake) memory interaction and look-ahead instruction fetch. The only assumption made about the memory is that every read/write request by the design is eventually acknowledged (ack) and that the memory operation is correctly completed when an acknowledgement is received. The signal ack is required to become false one cycle after it becomes true and is implicitly assumed to be true infinitely often by virtue of the fact that we prove the correctness theorem under the fairness assumption of ack being true.</p><p>The CPU is held or frozen (indicated by dhld) till a data read/write to memory is acknowledged, and stalled (by introducing a stream of noop instructions) as long as the next instruction is not ready (i.e., instrn.xdy does not hold). We want to prove a property next_instrn_entry (shown below) that along all fair paths (where ack occurs infinitely often), if the next instruction (at the current pc) is not yet fetched, its opcode in the updated memory will eventually be loaded into the appropriate pipeline register, namely, opcoded. This loading could be delayed either because the machine is stalled or frozen. Hence a proof of this property relies on two lemmas characterizing the behavior of the CPU when it is either held or stalled. The fetch_completes lemma shows that the machine will eventually unstMl (given the fairness condition) without changing the value of the pc. The second lemma shows that machine will eventually be unfrozen again without changing the value of the pc. The main theorem can be deduced from these lemmas using PVS. The above lemmas are not easy prove directly in PVS since they involve induction on the length of time for the memory to respond with an acknowledgment. Complicating the induction proof is the fact that the stalling loop and the data-holding loop are interdependent. Our approach is to abstract away the irrelevant parts of the processor state so that we are left with a finite-state processor-memory system that preserves the properties of interest. The relevant components in this case are: ack, the signals write, next_write, which determine instrn_rdy and dhld, opcoded, and pc. The state of the memory is completely abstracted except for its control signals.</p><p>Since we are only interested in analyzing whether the value of pc has changed from the initial state for the property, it is only necessary to retain a 1-bit information about the pc that indicates if the concrete program counter will be updated in the current state. The updating of pc in the abstract model captures the conditions under which the program counter is not changed in the concrete model. The abstraction function (shown below) takes an additional parameter init_pc_val that denotes the value with respect to which the concrete pc is compared to get the abstract pc value. We have also used PVS to establish that this abstraction mapping satisfies the conditions on the abstraction mapping that are actually stronger than those discussed in Section 3. These are shown above for this example. The lemma homo_morphic shows that abstraction abs preserves the nexs-state relation and congruent shows that the atomic predicates used in the property proved are congruent with respect to the equivalence classes introduced by the abstraction on the concrete machine states. There is still a gap in the proof since we have not proved that these abstraction conditions do guarantee property preservation. This fact can also be proved using PVS for abstraction mappings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusions and Future Work</head><p>Model checking and theorem proving are complementary verification technologies. Model checking is effective for control-dominated systems with small state spaces, where neither the invariant nor the proof is easily constructed. Theorem proving on the other hand is suitable for data-dominated verification where the state spaces can be large or unbounded.</p><p>The combination of these technologies can be exploited in a number of ways. We have illustrated one application where model checking is applied to a finite state abstraction of a system where the abstraction is justified by means of theorem proving. We have studied the example of the asynchronous interaction between a pipelined processor and memory. The main safety property of this system is rather more easily proved by the PVS theorem prover than by model checking. PVS is used to construct a finite state abstraction of the processormemory system. Model checking applied to this abstraction easily yields that each subsequent opcode is eventually loaded. This example is usually done informally.</p><p>The combination of theorem proving and model checking has several other uses we are currently exploring. For example, theorem proving can be used to prove general temporal properties that can be combined with temporal properties of specific next-state relations proved using model checking. Theorem proving can be used to prove global system properties by composing local system properties (with smaller state spaces) that have been proved using model checking. Model checking can also be used in the induction step for showing that a property holds of an N-process system. Consider for example, an N-process mutual-exclusion algorithm obtained by recursively selecting a "winner" from N -1 processes and using Peterson's algorithm to arbitrate between this winner and the Nth process. By the induction hypothesis, there is at most one winner from the first N-1 processes. Ths Nth process does not interfere with this selection. The correctness of the algorithm then follows from the correctness of the 2-process Peterson algorithm which has been verified by model checking.</p><p>We argue that the mu-calculus serves as a good basis for combining model checking with theorem proving. The mu-calculus can be used to conveniently define past, future LTL operators, and CTL with fairness constraints. It can also be cleanly defined in PVS so that model checking can be used as a decision procedure for a well-defined fragment of PVS. The mu-calculus has one drawback: the complexity of model checking is exponential in the number of alternations of fixpoint operators, but this is rarely a problem in practice.</p><p>Our framework can also be used to integrate PVS with a CTL model checker such as SMV by defining CTL operators in PVS and using SMV as a decision procedure for the CTL fragment. For our present purpose, we have chosen the mu-calculus for its greater expressiveness and for ease of translation. Note that, the model checkable fragment of PVS already provides a richer language than SMV. One disadvantage with respect to SMV is that we are unable, at present, to generate counterexample traces when a property does not hold in a model. This is an important topic for future work. We also plan to investigate the use of the combined technology to explore LTL model checking and verification based on language-containment</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>- a propositional variable z in 27 -</head><label>27</label><figDesc>the conjunction, negation, disjunction, implication, or equivalence of formulas: f Ag, ~f, fVg, f Dg, or f=g -an n-ary relational term p applied to a list of n formulas fl,..., f,~: p(s the result of apply existential or universal quantification of a variable over a formula: qz. f or Vz. f A n-ary relational term is one of the following:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>. A record consisting of n labels li of type ~ is written as [# 11 : T1,...,l, : T, #]. A tuple consisting of n types T1,..., T, is written as IT1,..., Tn]. An array of element type T over a specific subrange of the integers is written as [subrange[lo, hi] -&gt; 73. The details of the translation from PVS to the propositional mu-calculus are easily described by means of an example. Consider a state type state given by the following PVS declarations: ACK : TYPE = {ready, wait} DATA : TYPE = [subrange[O,l] -&gt; bool] state : TYPE = [# request: bool, ack: ACK, data : DATA #] s, sl, s2 : VAR state P, Q : VAR PRED[state] i, j : VAR subrange[O, I] If we take the PVS formula ack(s) = ready IMPLIES EU(N, (LAMBDA sl: ack(s) = ready), (LAMBDA sl: NOT request(sl)))(s) and expand the definition of EU, we obtain ack(s) = ready IMPLIES mu(LAMBDA 0: (LAMBDA sl: NOT request(sl) OR (ack(sl) = ready AND (EXISTS s2: Q(s2) AND ((s2 = sl WITH [request := NOT request(sl)]) OR (request(sl) AND s2 = sl WITH [ack := ready]) OR (NOT request(sl) AND s2 = sl WITH [ack := .air]))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>for a concrete state formula Pc written in VCTL or in the more expressive VCTL*, it is sufficient to prove 2 --V(c: C): Ic(c) D IA(h(c)) -V(al,a2 : A) : (3(cl,c2 : C): cl = NA(al,a2) ) A c2 = h(al) A Nc(cl,c2)) D Dh PC holds, where PA Dh PC is defined for the case of VCTL as: AGpA Dh AGpc iffpA Dh PC AFpA 3h AFpc iff PA Dh PC A(pAUqA) Dh A(pcUqc) iff pA Dh PC and qA Dh qc (V(c : C) : pa(h(c)) D pc(c)), when PA and Pc contain no temporal operators. PA</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>next_instrn_entry: THEOREM NOT instrn_rdy(sO) =&gt; fairAF(N, A (sl): instrn_rdy(sl) &amp; AX(N, A (s2): opcoded(s2) = opcodeof(memory(sl)(pc(sO))))(sl))(ack)(sO) fetch_completes: LEMMA NOT instrn_rdy(sO) IMPLIES fairAP(N, A (sl): instrn_rdy(sl) &amp; pc(sO) = pc(sl))(ack)(sO) write_completes: LEMMA dhld(sO) IMPLIES fairAF(N, A (st): NOT cthld(sl) &amp; pc(sl) = pc(sO))(ack)(sO)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>abs(init_pc_val: word)(cs): staterec = (# write := write(cs), next_write := next_write(cs), ack := ack(cs), pc := (pc(cs) = init_pc_val) #) homo_morphic: LEMMA (abs_pipe.N(sl, s2)) IFF EXISTS (csl, cs2): abs(pc(csl))(csl) = sl &amp; abs(pc(csl))(cs2)= s2 &amp; concrete_pipe.N(csl, cs2) congruent: LEMMA FORALL (wd: word): LET abs = abs(wd) IN instrn_rdy(abs(cs)) IFF instrn_rdy(cs) &amp; (write(abs(cs)) IFF write(cs)) &amp; (ack(ahs(cs)) IFF ack(cs)) &amp; (next_write(abs(cs)) IFF next_write(cs)) &amp; pc(abs(cs)) IFF (pc(cs) = wd)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>The translation of the state s into the propositional mu-calculus is given by a tuple consisting of a boolean variable xl for request(s), a boolean variable x2 which is false if ack(s) is ready, and true if it is not, and two boolean variables x3 and x4 corresponding to data(s) (0) and data(s) (1), respectively.</figDesc><table><row><cell cols="6">The state variables sl and s2 can similarly be encoded in terms of variables</cell></row><row><cell cols="6">yl,..., ya and zl,..., z4, respectively. Since the scalar type hCI( is represented</cell></row><row><cell cols="6">by a single boolean variable indicating ready when false, and wait when true,</cell></row><row><cell cols="6">the PVS formula ack(s) = ready is simply translated as -~x2. The entire PVS</cell></row><row><cell cols="3">formula above is therefore translated as</cell><cell></cell><cell></cell></row><row><cell>~x 2</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>9 9</cell><cell>u4.</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">~Yl</cell><cell></cell><cell></cell><cell></cell></row><row><cell>V</cell><cell>"W2</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">A ::lzl,...,z4.</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>Q(zl,...,zn)</cell><cell></cell><cell></cell></row><row><cell></cell><cell>A</cell><cell>( (zl</cell><cell>^z2</cell><cell>^za=</cell><cell>a^z4=y4))</cell></row></table></figure>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>* Supported by ARPA under contract PR8556, by NSF Grant CCR-930044, and by NASA under contract NAS1-20334.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Verifying temporal properties of processes</title>
		<author>
			<persName><forename type="first">Julian</forename><surname>Bradfield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Colin</forename><surname>Stirling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CONCUR &apos;90</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">C M</forename><surname>Baeten</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Klop</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">458</biblScope>
			<biblScope unit="page" from="115" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Symbolic model checking for sequential circuit verification</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Burch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computer-Aided Design</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="401" to="424" />
			<date type="published" when="1994-04">April 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Symbolic model checking: 102o states and beyond</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Burch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmiuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">J</forename><surname>Hwang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">98</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="142" to="170" />
			<date type="published" when="1992-06">June 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Another look at LTL model checking</title>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hamaguchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">David</forename><surname>Dill</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">94</biblScope>
			<biblScope unit="page" from="415" to="427" />
			<date type="published" when="1994-06">June 1994</date>
			<publisher>Springer Verlag</publisher>
			<pubPlace>Stanford, CA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Model checking and abstraction</title>
		<author>
			<persName><forename type="first">Edmund</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Orna</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">E</forename><surname>Long</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">A CM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1512" to="1542" />
			<date type="published" when="1994-09">September 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Tableau-based model checking in the propositional mu-calculus</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cleaveland</surname></persName>
		</author>
		<idno>2/89</idno>
		<imprint>
			<date type="published" when="1989-03">March 1989</date>
		</imprint>
		<respStmt>
			<orgName>University of Sussex</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Abstract interpretation of reactive systems: Abstractions preserving u 3CTL* and CTL*</title>
		<author>
			<persName><forename type="first">Dennis</forename><surname>Dams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Orna</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rob</forename><surname>Gerth</surname></persName>
		</author>
		<editor>Ernst-Riidiger</editor>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName><surname>Olderog</surname></persName>
		</author>
		<title level="m">Programming Concepts, Methods and Calculi (PROCOMET &apos;9~)</title>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="561" to="581" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Model checking for infinite state systems using data abstraction, assumption-commitment style reasoning and theorem proving</title>
		<author>
			<persName><forename type="first">J/Irgen</forename><surname>Dingel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Filkorn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer-Aided Verification 95</title>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Temporal and modal logic</title>
		<author>
			<persName><forename type="first">E</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Allen</forename><surname>Emerson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Models and Semantics</title>
		<title level="s">book of Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">Jan</forename><surname>Van Leeuwen</surname></persName>
		</editor>
		<meeting><address><addrLine>Amsterdam, The Netherlands, and Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier and MIT press</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">B</biblScope>
			<biblScope unit="page" from="995" to="1072" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Efficient model checking in fragments of the propositional mu-calculus</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Lei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings o] the lOth Symposium on Principles of Programming Languages</title>
		<meeting>o] the lOth Symposium on Principles of Programming Languages<address><addrLine>New Orleans, LA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="1985-01">January 1985</date>
			<biblScope unit="page" from="84" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Mechanical verification of concurrent systems with TLA</title>
		<author>
			<persName><forename type="first">Urban</forename><surname>Engberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Grenning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leslie</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer-Aided Verification 92</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">G</forename><forename type="middle">V</forename><surname>Bochmann</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">K</forename><surname>Probst</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">663</biblScope>
			<biblScope unit="page" from="44" to="55" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J C</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Melham</surname></persName>
		</author>
		<title level="m">Introduction to HOL: A Theorem Proving Environment for Higher-Order Logic</title>
		<meeting><address><addrLine>Cambridge, UK</addrLine></address></meeting>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Verification of a distributed cache memory by using abstractions</title>
		<author>
			<persName><forename type="first">Susanne</forename><surname>Graf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">L</forename><surname>David</surname></persName>
		</editor>
		<editor>
			<persName><surname>Dill</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">94</biblScope>
			<biblScope unit="page" from="207" to="219" />
			<date type="published" when="1994">1994</date>
			<publisher>Springer Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">G</forename><surname>Janssen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993-10">October 1993</date>
		</imprint>
		<respStmt>
			<orgName>ROBDD Software. Department of Electrical Engineering, Eindhoven University of Technology</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Linking Bdd-based symbolic evaluation to interactive theorem proving</title>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">J</forename><surname>Joyce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Carl-Johan</surname></persName>
		</author>
		<author>
			<persName><surname>Seger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th Design Automation Conference</title>
		<meeting>the 30th Design Automation Conference</meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Results on the propositional mu-calculus</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kozen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="page" from="333" to="354" />
			<date type="published" when="1983-12">December 1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Verification of a multiplier: 64 bits and beyond</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kurshan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Costas</forename><surname>Courcoubetis</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">93</biblScope>
			<biblScope unit="page" from="166" to="179" />
			<date type="published" when="1993-07">June/July 1993</date>
			<publisher>Springer Verlag</publisher>
			<pubPlace>Etounda, Greece</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Automata-Theoretic Verification of Coordinating Processes</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Kurshan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>Princeton University Press</publisher>
			<pubPlace>Princeton, NJ</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A structural induction theorem for processes</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Kurshan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">8th ACM Symposium on Principles of Distributed Computing</title>
		<meeting><address><addrLine>Edmonton, Alberta, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1989-08">August 1989</date>
			<biblScope unit="page" from="239" to="248" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><surname>Kenneth</surname></persName>
		</author>
		<author>
			<persName><surname>Mcmillan</surname></persName>
		</author>
		<title level="m">Symbolic Model Checking</title>
		<meeting><address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<publisher>Kluwer Academic Publishers</publisher>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Formal verification of the AAMP5 microprocessor: A case study in the industrial use of formal methods</title>
		<author>
			<persName><forename type="first">Steven</forename><forename type="middle">P</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mandayam</forename><surname>Srivas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WIFT &apos;95: Workshop on Industrial-Strength Formal Specification Techniques</title>
		<meeting><address><addrLine>Boca Raton, FL</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="2" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Combining model checking and deduction for I/O automata</title>
		<author>
			<persName><forename type="first">Olaf</forename><surname>Miiuer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Nipkow</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
	<note type="report_type">Draft manuscript</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">PVS: A prototype verification system</title>
		<author>
			<persName><forename type="first">S</forename><surname>Owre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Rushby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Shankar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">11th International Conference on Automated Deduction (CADE)</title>
		<title level="s">Lecture Notes in Artificial Intelligence</title>
		<editor>
			<persName><forename type="first">Deepak</forename><surname>Kapur</surname></persName>
		</editor>
		<meeting><address><addrLine>Saratoga, NY</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1992-06">June 1992</date>
			<biblScope unit="volume">607</biblScope>
			<biblScope unit="page" from="748" to="752" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Finiteness is mu-effable</title>
		<author>
			<persName><forename type="first">D</forename><surname>Park</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989-03">March 1989</date>
			<publisher>Theory of Computation Report</publisher>
		</imprint>
		<respStmt>
			<orgName>The University of Warwick</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report 3</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Verifying properties of large sets of processes with network invariants</title>
		<author>
			<persName><forename type="first">P</forename><surname>Wolper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Lovinfosse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Workshop on Automatic Verification Methods for Finite State Systems</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Sifakis</surname></persName>
		</editor>
		<meeting><address><addrLine>Grenoble, France</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1989-06">June 1989</date>
			<biblScope unit="volume">407</biblScope>
			<biblScope unit="page" from="68" to="80" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
