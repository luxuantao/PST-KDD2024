<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Inherently safe backup routing with BGP</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Lixin</forename><surname>Gao</surname></persName>
							<email>gao@cs.smith.edu</email>
						</author>
						<author>
							<persName><forename type="first">Timothy</forename><surname>Griffin</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Jennifer</forename><surname>Rexford</surname></persName>
						</author>
						<title level="a" type="main">Inherently safe backup routing with BGP</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">B6EB6A56C0470AC27434E554546C96BF</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:28+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>IP routing requires the cooperation of a large number of Autonomous Systems (ASes) via the Border Gateway Protocol (BGP). Each AS applies local policies for selecting routes and propagating routes to others, with important implications for the reliability and stability of the global system. In and of itself, BGP does not ensure that every pair of hosts can communicate. In addition, routing policies are not guaranteed be safe, and may cause persistent protocol oscillations. Backup routing is often used to increase the reliability of the network under link and router failures, at the possible expense of safety. This paper presents two models for backup routing that increase global network reliability without compromising safety. Indeed, our models are inherently safe in the sense that they remain safe under any combination of link and router failures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>The Internet consists of thousands of autonomous systems (ASes) that interact to coordinate the delivery of IP traffic. An AS is a collection of routers and links administered by a single institution, such as a company, university, or Internet service provider. An institution may consist of multiple ASes. Neighboring ASes use the Border Gateway Protocol (BGP) to exchange routing information [1], [2], [3]. Each BGP</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>peer-peer relationship. A customer pays its provider for access to the rest of the Internet, whereas peers agree to exchange traffic, usually without charge, for the good of their respective customers.</p><p>These relationships translate into rules that determine whether or not an AS exports its best routes to a neighboring AS <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b4">[5]</ref>. We term these rules Normal Export Rules (NER), which are as follows. An AS learns routes from its customers, peers, and providers.</p><p>The AS propagates its best route for each block of addresses to its customers, and propagates its customers' routes to all neighboring ASes. That is, an AS provides transit service to ensure that each customer, and its downstream customers, can communicate with hosts in the rest of the Internet. In contrast, an AS does not export routes learned from one provider to another provider. Otherwise, these two providers might exchange traffic via their common customer. Similarly, an AS does not inform its peers about routes learned from other peers or providers. That is, an AS does not provide transit service for its providers and peers.</p><p>The interaction of locally defined routing policies can have global ramifications for the stability of the BGP system. Conflicting local policies among a collection of ASes can result in BGP route oscillations <ref type="bibr" target="#b6">[7]</ref>. We call a collection of routing policies safe if they can never lead to BGP divergence. Verifying the safety of a set of routing policies is computationally expensive <ref type="bibr" target="#b7">[8]</ref> and would require ASes to reveal their (often proprietary) routing policies. Safety is not guaranteed even if each AS conforms to NER. However, Gao and Rexford <ref type="bibr" target="#b8">[9]</ref> present additional guidelines that guarantee safety. They present two basic ap-proaches. In the first, each AS uses the shortest paths rule and prefers routes with shorter AS paths. In the second, each AS always prefers customer routes over peer and provider routes. This second approach provides more flexibility in expressing local routing policies and conforms to current practices.</p><p>These scenarios cover what might be called normal routing. The main problem with normal routing is that it does not guarantee that connectivity is maintained in the face of network failures. To address this, another type of routing, which we call backup routing, is commonly employed. The main idea behind backup routing is to designate some routes as backup routes that are to be used only in the event that other primary routes are not available. Two types of backup links are most common. First, some links to upstream providers may be designated as multi-homed backups, to be used only in case of failure of other primary links. Second, peer-to-peer links may be used for backup routing as suggested in <ref type="bibr" target="#b5">[6]</ref>. This allows two or more peers to cooperate in providing backup connectivity. Two ASes within a single institution, such as large service provider, may have a similar backup arrangement to improve the reliability of the network without the overhead of installing additional links.</p><p>In order to increase network reliability, backup routing is often allowed to violate some of the rules imposed on normal routing. In particular, backup routing present two challenges for the guidelines presented in <ref type="bibr" target="#b8">[9]</ref>. First, implementing peer-to-peer backups requires the violation of NER. Second, backup routing may violate the path preference guidelines of <ref type="bibr" target="#b8">[9]</ref>. For example, a provider route may be preferred over a customer route if the customer route is a backup route.</p><p>The current paper investigates how the results of <ref type="bibr" target="#b8">[9]</ref> can be extended to backup routing. We present guidelines for backup routing that guarantee that routing policies are inherently safe, which means they are safe under any combination of link and router failures. At the same time, the routing policies are locally implementable. That is, only coordination between an AS and its neighbors is required. Our results can be summarized as follows. We show that, in order to guarantee safety, if a route is marked as a backup route, then it must retain this marking as is traverses subsequent ASes. We then investigate two basic models. In Model I, there is just one class of backup route, and routing policies are not able to differentiate between routes that have traversed a single backup link or multiple backup links. We show that in Model I, we are forced to adopt the shortest paths rule for backup routes. In Model II, the "backup level" of a route is incremented each time it traverses a backup link. This model allows a generalization of <ref type="bibr" target="#b8">[9]</ref> where each AS can now prefer customers to peers and providers within a backup level. Both Model I and Model II are locally implementable, but a full implementation of Model II may be difficult to realize given the current low-level nature of most router configuration languages.</p><p>We investigate backup routing in the context of the stable paths problem, a static formalism that captures the semantics of the dynamic interdomain routing protocol <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b10">[11]</ref>. This allows us to define models for backup routing that are independent of BGP-specific details. In addition, we employ the results of <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b10">[11]</ref> in the proofs that our models are inherently safe. Section II reviews the stable paths problem (SPP) while Section II-B reviews the main result of <ref type="bibr" target="#b8">[9]</ref>. Section III formalizes the notion of a multi-homed backup link and a peer backup link and presents SPP versions of Models I and II. In Section IV, we describe how to realize the two models using the BGP community attribute. Section V concludes the paper with a summary of future research directions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. ROUTING POLICY MODEL</head><p>Analyzing the convergence properties of a dynamic routing protocol like BGP is very difficult. Instead, our analysis draws on the static Shortest Path Problem (SPP) formalism that captures the underlying semantics of interdomain routing policies as expressed in BGP configurations <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b10">[11]</ref>. Then, we define customer-provider and peer-peer relationships and show that the resulting constraints on the Stable Paths Problem ensure that the routing protocol does not diverge.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Stable Paths Problem (SPP)</head><p>The Stable Paths Problem is a static formalism similar to the shortest paths problem, that can be described in a manner independent of any dynamic protocol used to solve instances of this problem <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b10">[11]</ref>.</p><p>SPP is based on the notion of permitted paths and ranking functions on these paths. Let G = (V; E) be a simple, undirected graph where V = f0; 1; 2; : : : ; ng is the set of nodes and E is the set of edges. For any node u, neighbors(u) = fw j fu; wg 2 Eg is the set of neighbors for u. There is a special node o 2 V , called the origin, that it is the destination to which all other nodes attempt to establish a path. Our examples will often use node 0 as the origin.</p><p>A path in G is either the empty path, denoted by , or a sequence of nodes, (v k v k?1 : : : v 1 v 0 ), k 0, such that for each i, k i &gt; 0, fv i ; v i?1 g is in E.</p><p>Note that if k = 0, then (v 0 ) represents the trivial path consisting of the single node v 0 . Each non-empty path P = (v k v k?1 : : : v 1 v 0 ) has a direction from its first node v k to its last node v 0 . If P and Q are non-empty paths such that the first node in Q is the same as the last node in P, then PQ denotes the path formed by the concatenation of these paths. We extend this with the convention that P = P = P, for any path P. For example, (4 3 2) (2 1 0) represents the path (4 3 2 1 0), whereas (2 1 0) represents the path (2 1 0) This notation is most commonly used when P is a path starting with node v and fu; vg is an edge in E. In this case (u v)P denotes the path that starts at node u, traverses the edge fu; vg, and then follows path P from node v.</p><p>For each v 2 V , P v denotes the set of permitted paths from v to the origin (node o).</p><formula xml:id="formula_0">If P = (v v k : : : v 1 o</formula><p>) is in P v , then the node v k is called the next hop of path P. Let P be the union of all sets P v . For each v 2 V , there is a non-negative, integervalued ranking function v , defined over P v , which represents how node v ranks its permitted paths. If P 1 ; P 2 2 P v and v (P 1 ) &lt; v (P 2 ), then P 2 is said to be preferred over P 1 . Let = f v j v 2 V ? fogg.</p><p>An instance of the Stable Paths Problem, S = (G; o; P; ), is a graph, an origin node, the set of permitted paths from each node to the origin, and the ranking functions for each node. In addition, we assume that P o = f(o)g, and for all v 2 V ? fog:</p><p>(empty path is permitted) 2 P v , (empty path is lowest ranked) v ( ) = 0, v (P ) &gt; 0</p><p>for P 6 = , (strictness) If P 1 6 = P 2 and v (P 1 ) = v (P 2 ), then there is a u such that P 1 = (v u)P 0 1 and P 2 = (v u)P 0 2 (paths P 1 and P 2 have the same next-hop), (simplicity) If path P 2 P v , then P is a simple path (no repeated nodes),</p><p>Let S = (G; o; P; ) be an instance of the Stable Paths Problem. A path assignment is a function that maps each node u 2 V to a path (u) 2 P u . An assignment is stable if each node u selects a path (u)</p><p>that is the highest ranked permitted path that is consistent with the path chosen by the next-hop node. For example, if (u) = (u v)P, then (v) = P. If no such assignment exists, then S is unsolvable. Figure <ref type="figure">1</ref> presents the SPP called BAD GADGET, which has no A Simple Path Vector Protocol (SPVP) was defined in <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b10">[11]</ref> to solve the Stable Paths Problem in a distributed manner. SPVP can be thought of as an abstraction of BGP. There are two desirable properties for an instance of SPP with respect to behavior we can expect from SPVP:</p><p>Safety: An instance of the SPP is safe if the protocol SPVP can never diverge. The example BAD GADGET</p><p>is not safe since it has no solution and so the protocol can never converge.</p><p>Inherent safety: An instance of the SPP is inherently safe if it is safe, and remains safe after removing any nodes, edges, or permitted paths.</p><p>Inherent safety guarantees that a system will remain safe under network failures and under more restrictive routing policies that filter out some permitted paths.</p><p>In Section III, we introduce two approaches to providing backup paths that ensure that the SPP is inherently safe.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Neighbor Relationships</head><p>Motivated by the commercial contracts between autonomous systems in the Internet, we consider the possibility that adjacent nodes have either a customer-provider or peer-peer relationship. Consider a node u. We partition neighbors(u) into three sets customers(u), peers(u), and providers(u)the customers, peers, and providers of u, respectively <ref type="bibr" target="#b8">[9]</ref>. Relationships must be consistent between a pair of nodes. That is, if w 2 customers(u) then u 2 providers(w); similarly, if w 2 peers(u) then u 2 peers(w). We also classify a path as a customer, peer, or provider path, depending on the relationship between the first two nodes in the path. A path (u w)P is a customer path if w 2 customers(u), a peer path if w 2 peers(u), or a provider path if w 2 providers(u). In particular, the work in <ref type="bibr" target="#b8">[9]</ref> identified several combinations of restrictions are sufficient to guarantee that the resulting system is inherently safe. The restrictions are reasonable in the sense that they are faithful to the commercial relationships between neighboring autonomous systems. In the remainder of this section, we revisit one of these scenarios in the context of the stable paths problem and introduce terminology that will be used in the rest of the paper.</p><p>First, we assume that provider-customer relationships are hierarchical. Informally, if u is a customer of v and v is a customer of w, then w is not a customer of u. That is, the graph G does not have a cycle of edges with provider-customer relationships. Figure <ref type="figure" target="#fig_1">2</ref> has such a hierarchical structure. However, adding a provider-customer edge f0; 5g would introduce a cycle involving nodes 5, 3, and 0.</p><p>Second, we assume that no permitted path has a valley -a provider-customer edge followed by one or more customer-provider edges. That is, a path between two nodes should not traverse an intermediate node that is lower in the hierarchy <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b4">[5]</ref>. For ex- Fig. <ref type="figure" target="#fig_1">2</ref>. AS graph with provider-customer and peer-peer relationships, with permissible paths to node 2 ample, paths (6 5 3) and (0 3 2) would be permissible. In contrast, (6 0 3) and (6 1 0 3) would not be permissible since they each include a valley. The path (6 1 0 3) has a provider-customer edge f6; 1g followed by a customer-provider edge f0; 3g. In this case, the valley includes an intermediate peer-peer edge f1; 0g.</p><p>Third, we impose restrictions on paths that include peer-peer edges. We allow uphill paths such as (0 3 5) that consist of one or more customer-provider edges and downhill paths such as (5 3 0) that consist of one or more provider-customer edges <ref type="bibr" target="#b11">[12]</ref>. We also permit paths P 1 (u v)P 2 where P 1 is either an empty path or an uphill path, fu; vg is a peer-peer edge, and P 2 is either an empty path or a downhill path. For example, (1 6 5 3) is a permissible path. However, we do not permit paths that have steps -an uphill or downhill path that is interrupted by one or more peer-peer edges. Formally, (step) A peer-peer edge fu; vg is a step in path P 1 (u v)P 2 if either (1) the last edge of P 1 or the first edge of P 2 is a peer-peer link, or (2) the last edge in P 1 is a provider-customer edge, or (3) the first edge in P 2 is a customer-provider edge.</p><p>For example, the path (5 4 3 2 0) is not permissible because it has two steps: f4; 3g and f2; 0g. Likewise, the path (1 0 2) is not permissible because it has two steps: f1; 0g and f0; 2g.</p><p>Fourth, we assume that customer paths are preferable to peer and provider paths. For example, node 5 would rank the customer path (5 3 0) higher than peer path (5 6 0). We do not impose any restriction on the ranking of different customer paths, or of different peer and provider paths.</p><p>In summary, we consider a stable paths problem with the following four properties:</p><p>(acyclic) The directed graph induced by the customerprovider relationships is acyclic.</p><p>(no-valley) If (v k : : : v 1 v 0 ) 2 P and v j?1 2 customers(v j ) for some j = k; : : : ; 1, then v i?1 6 = providers(v i ) for all i = j ? 1; : : : ; 1.</p><p>(no-step) If (v k : : : v 1 v 0 ) 2 P and v j?1 2 peers(v j ) for some j = k; : : : ; 1, then v h?1 2 providers(v h ) for h = k; : : : ; j ? 1 and v i?1 2 customers(v i ) for i = j ? 1; : : : ; 1.</p><p>(prefer-customer) If w 2 customers(u) and v 2 peers(u) providers(u), then ((u w)P 1 ) &gt; ((u v)P 2 ) for all paths P 1 and P 2 .</p><p>These assumptions result in the following theorem from <ref type="bibr" target="#b8">[9]</ref>, expressed in SPP terminology:</p><p>Theorem II.1: Any SPP S with the acyclic, novalley, no-step, and prefer-customer properties is inherently safe.</p><p>The theorem is a corollary of Theorem III.2, presented later in Section III-C.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. BACKUP FORMULATION</head><p>The restrictions outlined in Section II-B ensure that the system in Figure <ref type="figure" target="#fig_1">2</ref> is inherently safe. However, removing edges from graph would disconnect certain pairs of nodes. Consider the graph after removing the edge f5; 3g. The new solution to the stable paths problem may select different paths for some pairs of nodes.</p><p>For example, deleting edge f5; 3g would remove the customer path (5 3 2), forcing node 5 to use the other customer path (5 4 2) to reach node 2. However, node 5 would have to use a peer path (5 6 0) to reach node 0, since the customer path (5 3 0) is no longer available. If f5; 3g and f4; 2g both fail, then nodes 1, 5, and 6 do not have any permissible path to 2, even though the graph is still connected. Ensuring that these nodes have a non-empty path to 2 requires relaxing the restrictions on the set of permitted paths. For example, relaxing the no-step restriction would make (5 4 3 2)</p><p>into a permissible paths with a step involving edge f4; 3g.</p><p>Enlarging the set of permissible paths has important implications on whether the system remains inherently safe. On the one extreme, every path could be permissible. However, paths with valleys violate the basic notion of hierarchical relationships between nodes. Instead, we define a slightly weaker notion of reachability where the set P of permitted paths can include any path that does not have a valley. That is, in contrast to Section II-B, we allow paths with steps to be used as backup paths. A backup path is a permitted path P with one or more backup edges. A path with no backup edges is a primary path. A backup edge can arise in two ways, depending on the relationship between the adjacent nodes:</p><p>(multi-homed backup) For each node u, the set providers(u) is partitioned into backup providers(u)</p><p>and primary providers(u). Each edge fu; vg with v 2 backup providers(u) is a backup edge. Any path including edge fu; vg is a backup path.</p><p>(peer backup) For each node u and each node v 2 peers(u), the edge fu; vg is a backup edge in path P if fu; vg is a step in the path. Otherwise, fu; vg is not a backup edge.</p><p>In the multi-homed backup scenario, node u has an edge to provider v specifically for the purpose of having backup paths. In the peer backup scenario, node u has a peer v that can appear in backup paths to and from v. The main goal of this paper is to determine how to allow nodes to have multi-homed backup and peer backup relationships without compromising the inherent safety of the global system. To achieve this goal, we are forced to revisit the prefer-customer assumption. For simplicity, our examples consider cases where all providers are primary providers and the permissible set P consists of all no-valley paths.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Lower Ranking for Backup Paths</head><p>First, we consider how backup paths should be ranked. In the example in Figure <ref type="figure" target="#fig_4">3</ref>, nodes 2, 3, and 4</p><p>each have a provider-customer relationships with node 1 and peer-peer relationships with each other. Node 1 also has a peer-peer relationship with 0, which is a customer of 2. Limiting the consideration to primary, valley-free paths, nodes 2, 3, and 4 would each select a path that uses the link from 2 to 0, and node 1 would select a direct path. Now, suppose that the set of permissible paths is extended to include paths with steps, such as (2 1 0) and (3 4 1 0). Nodes 2, 3, and 4 should still prefer the primary path that uses the link from 2 to 0. That is, (prefer primary paths) If path P 1 has no backup edges and path P 2 has one or more backup edges, then (P 1 ) &gt; (P 2 ).</p><p>Note that having a backup edge is a global property.</p><p>That is, if a path P has a backup edge, then (u v)P  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Model I : Preferring Shorter Backup Paths</head><p>Next, we consider how the ranking functions should differentiate between backup paths. We consider a simple SPP model where each node selects a primary path, if available, or the shortest possible backup path:</p><p>(prefer-customer-among-primary-paths) If (u w)P 1 and (u v)P 2 are primary paths, and w 2 customer(u) and v 2 peer(u) provider(u), then ((u w)P 1 ) &gt; ((u v)P 2 ).</p><p>(shortest-backup-path) If P 1 ; P 2 2 P are backup paths, and jP 1 j &lt; jP 2 j, then (P 1 ) &gt; (P 2 ).</p><p>This has the desirable property of minimizing the length of backup paths. We can prove that Theorem III.1: Any SPP S with the acyclic and novalley properties that obeys the prefer-primary-paths, prefer-customer-among-primary-paths, and shortestbackup-path properties at each node is inherently safe.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof:</head><p>The full paper contains a detailed proof.</p><p>Informally, ranking primary paths over backup paths reduces the problem to two subproblems related to primary paths and backup paths, respectively. The prefercustomer requirement addresses the subproblem concerning primary paths, and the shortest-path requirement addresses the subproblem concerning backup paths. Each case is treated using the sufficient condition for safety presented in <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b10">[11]</ref>.</p><p>Requiring each node to prefer shorter backup paths over longer backup paths is important. Consider the do not have any primary (step-free) paths to node 0.</p><p>The prefer-customer property would result in node 4</p><p>preferring a path via 3, node 3 preferring a path via 2. Node 1 may prefer the shorter customer path via 4 over the path via 2. In addition, node 2 may prefer the shorter provider route via 1 over the peer route via 8. This system does not have a stable path assignment. Yet, if each node used path length to rank among backup paths, this problem would not arise.</p><p>This example shows that a policy that prefers a customer backup paths over peer and provider backup paths may result in a system that is not inherently safe.</p><p>Similar examples can be shown for preferring peers over providers, preferring providers over peers, and for preferring customers over peers. We conclude that having just two classes of paths (primary and backup) forces us to use the shortest paths rule in ranking paths. (prefer-fewer-backup-edges) If P 1 has s 1 steps and P 2 has s 2 backup edges, and s 1 &lt; s 2 , then (P 1 ) &gt; (P 2 ).</p><p>(prefer-customer-within-backup-class) If (u w)P 1 and (u v)P 2 have the same number of backup edges, and w 2 customer(u) and v 2 peer(u) provider(u),</p><p>then (P 1 ) &gt; (P 2 ).</p><p>Note that this model is a generalization of the system described in Section II-B. We can prove that Theorem III.2: Any SPP S with the acyclic and novalley properties that obeys the prefer-fewer-backupedges and the prefer-customer-within-backup-class properties at each node is inherently safe.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof:</head><p>The full paper contains a detailed proof. Informally, ranking paths with s 1 backup edges higher than paths with s 2 &gt; s 1 backup edges reduces the problem to a collection of subproblems, each corresponding to paths with a fixed number of backup edges. Each subproblem is addressed by the prefercustomer requirement, in a manner similar to the proof of Theorem III.1.</p><p>Returning to the example in Figure <ref type="figure" target="#fig_5">4</ref>, nodes 2 and 3 each have a permissible path with a single backup edge. For example, node 3 would rank the path (3 6 7 0) with one backup edge f7; 0g higher than the path (3 2 8 9 10 0) with two backup edges f2; 8g and f10; 0g. Similarly, node 2 would prefer the path (2 8 9 10 0) with one backup edge f10; 0g. Node 4 has two backup paths, (4 5 0) and (4 3 6 7 0), each with two backup edges; hence, node 4 prefers the customer path (4 3 6 7 0). The resulting system is inherently safe.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. IMPLEMENTING BACKUP ROUTING IN BGP</head><p>We now consider how Models I and II might be implemented in BGP. BGP exchanges route announcements between BGP speaking routers. These announcements are records containing a destination (IP prefix) and attributes associated with this destination.</p><p>Route announcements include the following attributes. The local preference attribute local pref is not passed between autonomous systems, but is used internally within an autonomous system to assign a local degree of preference. Community values <ref type="bibr" target="#b14">[15]</ref> are typically used in routing policies for deciding on the value of local pref or on filtering.</p><p>The BGP attributes are used by import policies and export policies at each router to implement its routing policies. A route transformation T is a function on route records, T (r) = r 0 , that operates by deleting, inserting, or modifying the attribute values of r. If T (r) = hi (the empty record), then we say that r has been filtered out by T . Suppose u and w are autonomous systems with a direct BGP relationship. As a record r moves from w to u it undergoes three transformations. First, r 1 = export(w ! u; r)</p><p>represents the application of export policies (defined by w) to r. Second, r 2 = PVT(u w; r 1 ) is the BGP-specific path vector transformation that adds w to the as path of r 1 , sets next hop, and filters out the record if its as path contains u. Finally, r 3 = import(u w; r 2 ) represents the application of import policies (defined at u) to r 2 . In particular, this is the function that assigns a local pref value for r 3 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Implementing Model II</head><p>RFC 1998 <ref type="bibr" target="#b5">[6]</ref> suggests using communities as a way to influence a neighbor's routing policies. It applies this technique to the implementation of backup peering.</p><p>Our implementation of Models I and II uses the basic technique suggested in RFC 1998. However, we implement formally defined models and prove the correctness of the implementations. We first define an implementation of Model II, and then show that an implementation of Model I can be obtained by simplification.</p><p>We assume that each AS w has defined the following community values, and that the semantics of these labels is shared with w neighbors. (w : bu : i) tag for backup route of level i, (w : up) tag for provider routes, (w : down) tag for customer routes, (w : peer) tag for the customer routes of a peer, (w : peerbu) tag for the upstream routes of a peer. We also assume that for any neighbor u, and any backup level i, that lpbu(w; u; i) represents the local preference assigned to routes from u received at w. For primary routes, we assume that function lpnorm(w; u) is defined. We assume that for each w, Model II routing policy at w for u 2 customers(w).</p><p>these functions conform to the following rules: If u 2 customers(w); v 2 peers(w) providers(w), then lpnorm(w; v) &lt; lpnorm(w; u), and lpbu(w; v; i) &lt; lpbu(w; u; i) for each i.</p><p>For each i, lpbu(w; u; i) &lt; lpnorm(w; u). For each i; u; v, lpbu(w; u; i + 1) &lt; lpbu(w; v; i).</p><p>That is, primary routes are always preferred over backup routes, and backup routes of level i are always preferred over backup routes of level i + 1. Within each level, customer routes are preferred over peer and provider routes.</p><p>Figure <ref type="figure" target="#fig_8">5</ref> shows how a node w implements this policy in exchanging BGP advertisements with a customer u. The command deny(r) filters out the record r, while permit(r) allows the route to pass the filter, perhaps after some modification. Figure <ref type="figure">6</ref> presents the routing policy for providers, while Figure <ref type="figure">7</ref> presents the policy for peers. These policies are complicated by the "arithmetic" required on backup levels. Some</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Fig. 1. BAD GADGET</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2</head><label>2</label><figDesc>Figure 2 shows an example graph where peer-peer relationships are represented by a dotted line and provider-customer relationships are represented by a solid line with an arrow pointing from the provider to the customer. Based on these relationships, we can define special cases of the stable paths problem that impose practical restrictions on the graph structure, the permitted paths, and the ranking functions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>has a backup edge. If the link between 0 and 2 fails, nodes 2, 3, and 4 select paths to 0 that include node 1. Each of these paths has a backup edge. It does not matter where the backup edge occurs. For example, node 2 should not prefer the path (2 3 1 0) over path (2 1 0) just because the subpath (2 3 1) does not involve a step. Otherwise, the example in Figure3could devolve to the BAD-GADGET scenario in Figure1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Backup routes should be global</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 4 .</head><label>4</label><figDesc>Fig.4. A counterexample to inherent safety when customer routes can be preferred over peer routes</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>C</head><label></label><figDesc>. Model II : Preferring Paths With Fewer Backup EdgesModel I has two disadvantages. First, the shortestpath policy does not provide any flexibility in ranking among backup paths. Second, the shortest-path policy would cause a node to favor a path with a large number of backup edges with a small number of backup edges, whenever the path with more backup edges has a shorter overall length. This may be an undesirable property since a path with a large number of backup edges imposes on a large number of backup relationships. We consider another model that ranks paths based on the number of backup edges, and ranks paths with the same number of backup edges based on the customer, peer, and provider relationships:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>nlri : network layer reachability information (address block for a set of destinations) next hop : next hop (address of next hop router) as path : ordered list of ASes traversed local pref : local preference c set : set of community values</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5.</figDesc></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>additional explanation is required for the export policy to peers. The last two "else if" clauses are required to allow backup transit between a node's peers. In this case two peering links in a row will be encountered, and both must be treated as backup links. In addition, a peer's upstream routes (with w : peerbu tag) are passed to other peers as w : up routes, since if these are actually used the peer u will be acting as a (temporary) upstream provider to w. Similarly, a peer's downstream routes (with w : peer tag) are passed to other peers as w : down routes, since if these are actually used the peer u will be acting as a (temporary) customer of w.</p><p>Theorem IV.1: The routing policies described in </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Implementing Model I</head><p>The implementation of Model II can be simplified to obtain an implementation of Model I. First, the tags w : bu : i are replaced by a single value w : bu, and all clauses that increment the backup level are modified in the obvious way. Second, each line of the form r:local pref := lpbu(w; w; i) is replaced by r:local pref := low(w), where low(w) is low value of local preference used for all backup routes at w.    Several issues remain to be addressed. First, the interaction of backup routing with prefix aggregation needs to be studied. Second, the models presented in this paper are simplified in that they ignore the internal structure of ASes. Routing policies may not actually be AS-wide, but may vary between border routers, mostly to meet traffic engineering goals. The interaction and tradeoffs between external routing (both normal and backup) and internal routing should be explored.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">A Border Gateway Protocol 4 (BGP-4)</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Rekhter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Li</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995-03">March 1995</date>
		</imprint>
	</monogr>
	<note>Request for Comments 1771</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Internet Routing Architectures</title>
		<author>
			<persName><forename type="first">B</forename><surname>Halabi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Cisco Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Inter-Domain Routing in the Internet</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Stewart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BGP</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<date type="published" when="1998">1998</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Interconnection, peering, and settlements</title>
		<author>
			<persName><forename type="first">G</forename><surname>Huston</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. INET</title>
		<meeting>INET</meeting>
		<imprint>
			<date type="published" when="1999-06">June 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Scalable router configuration for the Internet</title>
		<author>
			<persName><forename type="first">C</forename><surname>Alaettinoglu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE IC3N</title>
		<meeting>IEEE IC3N</meeting>
		<imprint>
			<date type="published" when="1996-10">October 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">An Application of the BGP Community Attribute in Multi-home Routing</title>
		<author>
			<persName><forename type="first">E</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Bates</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1998. August 1996</date>
		</imprint>
	</monogr>
	<note>Request for Comments</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Persistent route oscillations in inter-domain routing</title>
		<author>
			<persName><forename type="first">K</forename><surname>Varadhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Govindan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Estrin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996-02">February 1996</date>
			<publisher>USC/ISI</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep. 96-631</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">An analysis of BGP convergence properties</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">G</forename><surname>Griffin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Wilfong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="1999-09">September 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Stable Internet routing without global coordination</title>
		<author>
			<persName><forename type="first">L</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMETRICS</title>
		<meeting>ACM SIGMETRICS</meeting>
		<imprint>
			<date type="published" when="2000-06">June 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Policy disputes in path-vector protocols</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">G</forename><surname>Griffin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">B</forename><surname>Shepherd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Wilfong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Inter. Conf. on Network Protocols</title>
		<meeting>Inter. Conf. on Network Protocols</meeting>
		<imprint>
			<date type="published" when="1999-11">November 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A safe path vector protocol</title>
		<author>
			<persName><forename type="first">T</forename><surname>Griffin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Wilfong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE INFOCOM</title>
		<meeting>IEEE INFOCOM</meeting>
		<imprint>
			<date type="published" when="2000-03">March 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">On inferring autonomous system relationships in the Internet</title>
		<author>
			<persName><forename type="first">L</forename><surname>Gao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Global Internet Symposium</title>
		<meeting>IEEE Global Internet Symposium</meeting>
		<imprint>
			<date type="published" when="2000-11">November 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Internet Routing Architectures</title>
		<author>
			<persName><forename type="first">B</forename><surname>Halabi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Cisco Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Inter-Domain Routing in The Internet</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Stewart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BGP</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<date type="published" when="1998">1998</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">BGP communities attribute</title>
		<author>
			<persName><forename type="first">R</forename><surname>Chandra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Traina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">RFC 1997</title>
		<imprint>
			<date type="published" when="1996-08">August 1996</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
