<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Piecemeal Graph Exploration by a Mobile Robot*</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Baruch</forename><surname>Awerbuch</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Johns Hopkins University</orgName>
								<address>
									<postCode>21218</postCode>
									<settlement>Baltimore</settlement>
									<region>Maryland</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Margrit</forename><surname>Betke</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">Boston College</orgName>
								<address>
									<addrLine>Chestnut Hill</addrLine>
									<postCode>02167</postCode>
									<region>Massachusetts</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ronald</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Laboratory for Computer Science</orgName>
								<orgName type="institution">Massachusetts Institute of Technology</orgName>
								<address>
									<postCode>02139</postCode>
									<settlement>Cambridge</settlement>
									<region>Massachusetts</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mona</forename><surname>Singh</surname></persName>
							<affiliation key="aff3">
								<orgName type="institution">Whitehead Institute for Biomedical Research</orgName>
								<address>
									<postCode>02142</postCode>
									<settlement>Cambridge</settlement>
									<region>Massachusetts</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Piecemeal Graph Exploration by a Mobile Robot*</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">2B5998DAFBC4F6229DF88FCCE5729690</idno>
					<note type="submission">Received January 16, 1997; final manuscript received June 27, 1998</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:23+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We study how a mobile robot can learn an unknown environment in a piecemeal manner. The robot's goal is to learn a complete map of its environment, while satisfying the constraint that it must return every so often to its starting position (for refueling, say). The environment is modeled as an arbitrary, undirected graph, which is initially unknown to the robot. We assume that the robot can distinguish vertices and edges that it has already explored. We present a surprisingly efficient algorithm for piecemeal learning an unknown undirected graph G=(V, E) in which the robot explores every vertex and edge in the graph by traversing at most O(E+V 1+o(1) ) edges. This nearly linear algorithm improves on the best previous algorithm, in which the robot traverses at most O(E+V 2 ) edges. We also give an application of piecemeal learning to the problem of searching a graph for a ``treasure.''</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>We address the situation where a robot must explore an unknown environment. The robot's goal is to learn a complete map of this environment while satisfying the piecemeal constraint that the exploration must be done in phases of limited duration.</p><p>Why might mobile robot exploration be done piecemeal? Robots have limited power, and after some exploration, they may need to recharge or refuel. In addition, robots are useful for exploring environments that are too risky or costly for humans to explore, such as the inside of a volcano (e.g., as attempted by CMU's Dante II robot), or a chemical waste site, or the surface of Mars. In these cases, the robot's hardware may be too expensive or fragile to stay long in dangerous conditions. Thus, it may be best to organize the learning into phases, allowing the robot to return to a start position for refueling and maintenance.</p><p>The piecemeal learning problem and the formal model used here were introduced by Betke, Rivest, and Singh <ref type="bibr" target="#b7">[8]</ref>. The robot's environment is modeled as an unknown graph. The piecemeal constraint is a bound on the number of edges the robot is allowed to traverse in each exploration phase. In order to assure that the robot can reach any vertex in the graph and do some exploration, this bound must allow at least one round trip from the start vertex s to any vertex in the graph. The robot's efficiency (or running time) is measured in terms of the number of edges traversed. Betke, Rivest, and Singh <ref type="bibr" target="#b7">[8]</ref> show that a robot can explore grid-graphs with rectangular obstacles in a piecemeal manner in linear time. In this paper, we extend these results to show that the robot can learn any undirected graph G= (V, E) piecemeal in almost linear time. We first give a simple algorithm that runs in O(E+V 1.5 ) time. We then improve this algorithm and give an almost linear time algorithm that achieves O(E+V 1+o (1) ) running time. The most efficient previously known algorithm has O(E+V 2 ) running time. It is open whether arbitrary, undirected graphs can be learned piecemeal in linear time.</p><p>The piecemeal constraint is most naturally satisfied by requiring the robot to explore in a near breadth-first manner, so that it is never much further away from the start vertex s than necessary to visit any unexplored vertex. In this manner, returns to s are efficient. Breadth-first search (BFS) on unknown graphs is also an important problem in its own right, with many applications. We consider one such application, treasure hunting, where the goal is to find a treasure (or a lost child, or a particular landmark) that is believed to be near s. If the robot knows that the treasure is close to its current location, it should explore in a breadth-first manner from its current location.</p><p>BFS is a classic technique for searching graphs <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b17">18]</ref>. However, standard BFS is efficient for exploring unknown graphs only when the robot can efficiently switch or ``teleport'' from expanding one vertex to expanding another. In contrast, our model assumes a more natural scenario where the robot must physically move from one vertex to the next. In this case, if the robot exactly satisfies the traditional BFS constraint (i.e., it cannot move further away from s than the unvisited vertex nearest to s), then it may traverse up to O(E 2 ) edges. Thus, for efficiency reasons, in the more difficult teleport-free exploration model, our algorithms for the piecemeal learning problem give approximate BFS algorithms, where the robot does not move much further away from s than the shortest path distance from s to the unvisited vertex nearest to s.</p><p>In the teleport-free BFS algorithms we first present, the robot never visits a vertex more than twice as far from s as the nearest unvisited vertex is from s. Our final teleport-free BFS algorithm, for the treasure hunting problem, satisfies the stronger condition that if the closest unvisited vertex to s is distance $ away, the robot is never more than $+o($) away from s. This algorithm is also efficient: if the treasure is at a vertex that has shortest path distance $ T away from s, then the robot traverses at most O(E+V 1+o (1) ) edges, where E and V are the number of edges and vertices within radius 2=$ T +o($ T ) from s. Our final treasure hunting algorithm is also a solution to the piecemeal learning problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related Work</head><p>Many researchers have studied problems in environment learning and robot motion planning. Papadimitriou and Yanakakis <ref type="bibr" target="#b18">[19]</ref> developed one of the first formal models for exploring unknown environments. They show how to find a shortest path in an unknown, undirected graph. Deng and Papadimitriou <ref type="bibr" target="#b12">[13]</ref> and Betke <ref type="bibr" target="#b5">[6]</ref> address the problem of learning an unknown directed graph. Bender and Slonim <ref type="bibr" target="#b4">[5]</ref> show how two cooperating robots can learn a directed graphs. Rivest and Schapire <ref type="bibr" target="#b20">[21]</ref> model the robot's unknown environment by a deterministic finite automaton. They describe algorithms that efficiently infer the structure of the automaton through experimentation. Deng, Kameda, and Papadimitriou <ref type="bibr" target="#b11">[12]</ref> consider how to learn the interior of a two-dimensional room. Blum, Raghavan, and Schieber <ref type="bibr" target="#b9">[10]</ref> consider a robot navigating in an unknown twodimensional geometric terrain with convex obstacles. Bar-Eli, Berman, Fiat, and Yan <ref type="bibr" target="#b3">[4]</ref> give an efficient algorithm for reaching the center of a twodimensional room with obstacles. Betke and Gurvits <ref type="bibr" target="#b6">[7]</ref>, Kleinberg <ref type="bibr" target="#b15">[16]</ref>, and Romanik and Schuierer <ref type="bibr" target="#b21">[22]</ref> address the problem of localizing a mobile robot in its environment. Blum and Chalasani <ref type="bibr" target="#b8">[9]</ref> consider the problem of finding a ``k-trip'' shortest path in the environment. There are many other related papers in the literature (e.g., <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b19">20]</ref>).</p><p>Our techniques are inspired by the work of Awerbuch and Gallager <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref>. We observe that our learning model bears some similarity to the asynchronous distributed message passing model. This similarity is surprising and has not been explored in the past.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Model and Definitions</head><p>This section reviews the piecemeal exploration model introduced by Betke, Rivest, and Singh <ref type="bibr" target="#b7">[8]</ref>. The robot's environment is modeled as a finite connected undirected graph G=(V, E) with a distinguished start vertex s. Vertices represent accessible locations. Edges represent accessibility: if [x, y] # E then the robot can move from x to y, or back, in a single step.</p><p>The robot can always recognize a previously visited vertex; it never confuses distinct locations. At any vertex the robot can sense only the edges incident to it; it has no vision or other long-range sensors. The robot can distinguish between incident edges at any vertex. Each edge has a label that distinguishes it from any other edge. Without loss of generality, we can assume that the edges are ordered. At a vertex, the robot knows which edges it has traversed already. The robot only incurs a cost for traversing edges; the time the robot speeds ``thinking and path planning'' is free (although for all the algorithms in this paper, this planning can be done in time polynomial in the size of the graph). We also assume a uniform cost for an edge traversal. We measure the running time of a piecemeal exploration algorithm in terms of the number of edges traversals made by the robot.</p><p>The robot's goal in piecemeal exploration is to explore its entire unknown environment while satisfying the piecemeal constraint that it must return every so often to its starting point. The robot is given an upper bound B on the number of steps it can make (edges it can traverse) in one exploration phase. In order to assure that the robot can reach any vertex in the graph, do some exploration, and then get back to the start vertex, we assume B allows for at least one round trip between s and any other single vertex in G, as well as for some number of exploration steps. More precisely, we assume B=(2+:) r, where :&gt;0 is some constant and r is the radius of the graph (i.e., the maximum of all shortest-path distances between s and any vertex in G). Note that our definition of the radius of the graph is relative to the start vertex s.</p><p>Initially all the robot knows is its starting vertex s, the bound B, and the radius r of the graph. The robot's goal is to explore the entire graph: to visit every vertex and traverse every edge, minimizing the total number of edges traversed.</p><p>We say an exploration is efficiently interruptible if the robot always knows a path of explored edges of length at most r back to s. All the algorithms presented in this paper are efficiently interruptible and, using the following theorem, give efficient piecemeal learning algorithms for undirected graphs. Theorem 1. An efficiently interruptible algorithm A for exploring an unknown graph G=(V, E) with n vertices and m edges that takes time T(n, m) can be transformed into a piecemeal learning algorithm that takes time O(T(n, m)).</p><p>Proof. Assume that the radius of the graph is r and that the number of edges the robot is allowed to traverse in each phase of exploration is B=(2+:) r for some constant : such that :r is a positive integer. In each exploration phase, the robot executes :r steps of the original search algorithm A, interrupts its search, and returns to the start vertex s. At the beginning of the next phase, the robot returns from s to the appropriate vertex to resume exploration. Then, the robot traverses again :r edges as determined by the original search algorithm A and returns to s. Since the search algorithm A is efficiently interruptible, the robot knows a path of length at most r from s to any vertex in the graph. Thus during any exploration phase, the robot traverses at most 2r edges for relocation to s and back and :r edges for new exploration. The total number of edges traversed in each phase is at most 2r+:r=B. Since there are WT(n, m)Â(:r)X segments, there are WT(n, m)Â(:r)X&amp;1 interruptions, and the number of edges traversals due to interruptions is</p><formula xml:id="formula_0">\Â T(n, m) :r | &amp;1 + 2r T(n, m) :r 2r 2T(n, m) : .</formula><p>Since : is a constant, the total number of edge traversals is still O(T(n, m)). K</p><p>BFS is an efficiently interruptible algorithm, where the robot may not move further away from the source than the unvisited vertex nearest to the source. At any given time in the algorithm, let 2 denote the shortest-path distance from s to the vertex the robot is visiting, and let $ denote the shortest-path distance from s to the vertex nearest to s that is as yet unvisited. With traditional breadth-first search we have 2 $ at all times. With teleport-free exploration, it is generally impossible to maintain 2 $ without a great loss of efficiency. Lemma 1. A robot that maintains 2 $ (such as one using a traditional BFS) may traverse 0(E 2 ) edges.</p><p>Proof. Consider a graph with vertices [ &amp;n, &amp;n+1, ..., &amp;1, 0, 1, 2, ..., n&amp;1, n], where s=0 and edges connect consecutive integers. To achieve 2 $, a teleport-free BFS algorithm would run in quadratic time, traveling back and forth from 1 to &amp;1 to &amp;2 to 2 to 3 .... K Given this lower bound, we solve the piecemeal learning problem and the treasure hunting problem efficiently while maintaining the approximate BFS constraint that the robot is never more than twice as far from s as is the nearest unvisited vertex from s (i.e., 2 2$). Our final algorithm Treasure-Search satisfies the stronger condition 2=$+o($). Note that this algorithm is also efficiently interruptible and thus can also be used to solve the piecemeal learning problem.</p><p>In the remainder of this paper, we give three algorithms for piecemeal learning undirected graphs. In Section 2, we first give a simple algorithm that runs in O(E+V 1.5 ) time. In Section 3, we then give a modification of this algorithm that runs in O((E+V 1.5 ) log V) time. Although this algorithm has a slightly slower running time, we are able to make it recursive, and in Section 4, we describe this recursive algorithm which has a nearly linear running time: it achieves O(E+V 1+o (1) ) running time. Finally, in Section 5, we give our algorithm for treasure hunting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">ALGORITHM STRIP-EXPLORE</head><p>This section describes an efficiently interruptible algorithm for undirected graphs with running time O(E+V 1.5 ). It is based on breadth-first search. A layer in a BFS tree consists of vertices that have the same shortest path distance to the start vertex. A frontier vertex is a vertex that is incident to unexplored edges. A frontier vertex is expanded when the robot has traversed all the unexplored edges incident to it.</p><p>The traditional BFS algorithm expands frontier vertices layer by layer. In the teleport-free model, this algorithm runs in time O(E+rV), since expanding all the vertices takes time O(E) and visiting all the frontier vertices on layer i can be performed with a depth-first search of layers 1 } } } i in time O(V), and there are at most r layers. Since r can be O(V), this can result in an O(E+V 2 ) algorithm.</p><p>The procedure Local-BFS describes a version of the traditional BFS procedure that has been modified for our teleport-free BFS model in two respects. First, when expanding vertices on layer i, the robot does not relocate to any vertices in that layer that no longer have any unexplored edges. Second, it only explores vertices within a given distance-bound L of the given start vertex s. (The first modification, while seemingly straightforward, is essential for our analysis of Strip-Explore which uses Local-BFS as a subroutine.) A procedure call of the form Local-BFS(s, r), where s is the start vertex of the graph and r is its radius, would cause the robot to explore the entire graph.</p><p>Local-BFS(s, L)</p><formula xml:id="formula_1">1. For i=0 To L&amp;1 Do 2.</formula><p>let verts=all vertices at shortest path distance i from s 3.</p><p>For each u # verts Do 4.</p><p>If u has any incident unexplored edges 5. Then 6.</p><p>relocate to u 7.</p><p>traverse each unexplored edge incident to u 8. relocate to s Awerbuch and Gallager <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref> give a distributed BFS algorithm which partitions the network (i.e., graph) into strips, where each strip is a group of L consecutive layers. (Here L is a parameter to be chosen.) All vertices in strip i&amp;1 are expanded before any vertices in strip i are expanded. Their algorithms use as a subroutine breadth-first type searches with distance L.</p><p>Our algorithm, Strip-Explore, searches in strips in a new way (see Fig. <ref type="figure" target="#fig_0">1</ref>). The robot explores the graph in strips of width L. First the robot follows Local-BFS(s, L) to explore the first strip. It then explores the second strip as follows. Suppose there are k frontier vertices v 1 , v 2 , ..., v k in layer L; each such vertex is a source vertex for exploring the second strip. A naive way for exploring the second strip is for the robot for each i, to relocate to v i , and then to find all vertices that are within distance L of v i by doing a BFS of distance-bound L from v i within the second strip.</p><p>The robot thus traverses a forest of k BFS trees of depth L, completely exploring the second strip. The robot then has a map of the BFS tree of depth L for the first strip and a map of the BFS forest for the second strip, enabling it to create a BFS tree of depth 2L for the first two strips. The robot continues, strip by strip, until the entire graph is explored.</p><p>The naive algorithm described above is inefficient, due to the overlap between the trees in the forest at a given level, causing portions of each strip to be repeatedly re-explored (see Fig. <ref type="figure" target="#fig_2">2</ref>). The algorithm Strip-Explore presented below solves this problem by using the Local-BFS procedure as the basic subroutine, instead of using a naive BFS. In Strip-Explore, the robot searches in a breadth-first manner, but ignores previously explored territory. The only time the robot traverses edges that have been previously explored is when moving to a frontier vertex it is about to expand. This results in retraversal of some edges in previously explored territory, but not as many as in the naive algorithm.</p><p>Strip-Explore(s, L, r) For each u # sources Do 5.</p><p>relocate to u 6.</p><p>Local-BFS(u, L) 7.</p><p>sources=all frontier vertices Theorem 2. Strip-Explore runs in O(E+V 1.5 ) time. Proof. First we count edge traversals for relocating between source vertices for a given strip. For these relocations, the robot can mentally construct a tree in the known graph connecting these vertices and then move between source vertices by doing a depth-first traversal of this tree. Thus the number of edge traversals due to relocations between source vertices for this strip is at most 2V. Since there are WrÂLX strips, the total number of edges traversals due to relocations between source vertices is at most WrÂLX 2V (rÂL+1) 2V=2rVÂL+2V. Now we count edge traversals for repeatedly executing the Local-BFS algorithm. First, for the robot to expand all vertices and explore all edges, it traverses 2E edges. Next, each time the relocate in line 8 of procedure Local-BFS is called, at most L edges are traversed, thus resulting in at most LV edge traversals. To account for relocations in line 6 of procedure Local-BFS, we use the following scheme for ``charging'' edge traversals. Say the robot is within a call of the Local-BFS algorithm. It has just expanded a vertex u and will now relocate to a vertex v to expand it. Vertex v is charged for the edges traversed to relocate from u to v. (We are only considering relocations within the same call of the Local-BFS algorithm; relocations between calls of the Local-BFS algorithm were considered above.) Source vertices are not charged anything. Moreover, the robot can always relocate from u to v by going from u to the source vertex of the current local BFS, and then to v, traversing at most 2L edges. Thus, each vertex is charged at most 2L when it is expanded. Local-BFS never relocates to a vertex v unless it can expand vertex v (i.e., unless v is adjacent to unexplored edges). Thus, all relocations are charged to the expansion of some vertex, and the total number of edge traversals due to relocation is at most 2LV.</p><p>Thus, the total number of edge traversals is at most 2rVÂL+2V+3LV+2E, which is O(rVÂL+LV+E). When L is chosen to ber, this gives O(E+V 1.5 ) edge traversals. K Procedure Strip-Explore and the generalizations of it given in later sections maintain that 2 2$ at all times the robot never visits a vertex more than twice as far from s as the nearest unvisited vertex is from s. The worst case is while exploring the second strip.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">ALGORITHM ITERATIVE-STRIP</head><p>We now describe Iterative-Strip, an algorithm similar to the Strip-Explore algorithm. It is an efficiently interruptible algorithm for undirected graphs inspired by Awerbuch and Gallager's <ref type="bibr" target="#b1">[2]</ref> distributed iterative BFS algorithm. Although its running time of O((V 1.5 +E) log V) is worse than the running time of Strip-Explore, its recursive version (described in Section 4) is more efficient. (It is not clear how to recursively implement Strip-Explore as efficiently, because the trees in a strip are not disjoint.)</p><p>With Iterative-Strip, the robot grows a global BFS tree with root s, strip by strip, in a manner similar to Strip-Explore. Unlike Strip-Explore, here each strip is processed several times before it has correctly deepened the BFS tree byr. We next explain the algorithm's behavior on a typical strip by describing how a strip is processed for the first time and then for the remaining iterations. In the first iteration, a strip is explored much as in Strip-Explore. The robot explores a tree of depthr from each source vertex, by exploring in breadth-first manner from each source vertex, without re-exploring previous trees. Whenever the robot finds a collision edge connecting the current tree to another tree in the same strip, it does not enter the other tree. Unlike Strip-Explore, the robot does not traverse explored edges to get to the frontier vertices on other trees. Therefore, after the first iteration, the trees explored are approximate BFS trees that may have frontier vertices with path length less thanr from some source vertex. We call these vertices active frontier vertices for the next iteration. A connected component within a strip is an active connected component if it contains active frontier vertices. After the first iteration, the current strip may not yet extend the global BFS tree by depthr, so more iterations are needed until all frontier vertices are inactive and the global BFS tree is extended by depthr (see Fig. <ref type="figure" target="#fig_3">3</ref>).</p><p>In the second iteration (see Fig. <ref type="figure" target="#fig_4">4</ref>), the robot uses the property that two tree connected by a collision edge form a connected component within the strip. (The graph to be explored is connected and, thus, forms one connected component; but we refer to connected components of the explored portion of the graph contained within the strip.) The robot need not traverse any edges outside the current strip to relocate between these active frontier vertices in the same connected component. In the second and later iterations, the robot works on one connected component at a time.</p><p>The robot explores active frontier vertices in one connected component as follows. It computes (mentally) a spanning tree of the vertices in the current component. This spanning tree lies within the strip. Let d be the shortest known path length from any active frontier vertex in the component to any source vertex in the component. The robot visits the vertices in the strip in an order determined by a DFS of the spanning tree. As it visits active frontier vertices of depth d, it expands them. It then recomputes the spanning tree (since the component may now have new vertices) and again traverses the tree, expanding vertices of the appropriate next depth d $. Traversing a collision edge does not add the new vertex to the tree, since this vertex has been explored before. This process continues (at mostr times) until no active frontier vertex in the connected component has known path length less thanr from some source vertex in the component.</p><p>The robot handles each connected component in turn, as described above. In the next iteration it combines the components now connected by collision edges and explores the new active frontier vertices in these combined components. Lemma 2 states that at most log V iterations cause all frontier vertices to become inactive. That is, all frontier vertices are depthr from the source vertices of this strip. These frontier vertices are the new sources for the next strip.</p><p>Iterative-Strip(s, r)</p><formula xml:id="formula_2">1. For i=1 To -r Do 2.</formula><p>For each source vertex u in strip i Do 3.</p><p>relocate to u 4.</p><p>BFS from u to depthr, but do not enter previously explored territory 5.</p><p>While there are any active connected components Iterate 6.</p><p>For each active connected component c Do 7.</p><p>Repeat 8.</p><p>let v 1 , v 2 , v 3 , ... be active frontier vertices exclusively in c with smallest depth among active frontier vertices in c 9.</p><p>relocate to each of v 1 , v 2 , v 3 , ..., and expand 10.</p><p>Until no more active frontier vertices exclusively in c 11.</p><p>determine new and active connected components Lemma 2. At most log V iterations per strip are needed to explore a strip and extend the global BFS tree by depthr.</p><p>Proof. If there are initially l source vertices, then after the first iteration there are at most l connected components. If a component does not collide with another active component, then it will have no active frontier vertices for the next iteration.</p><p>The only active components in the next iteration are those that have collided with other components, and thus, each iteration halves the number of components with active frontier vertices. After at most log V iterations there is no connected component with active frontier vertices left. The robot then has a complete map of the current strip and of the global BFS tree built in previous strips, so it can combine this information and extend the global BFS tree by depthr. K Theorem 3. Iterative-Strip runs in time O((E+V 1.5 ) log V).</p><p>Proof. We first count the number of edge traversals within a strip. Let V i and E i be the number of vertices and edges explored in strip i. For each component, the robot computes a spanning tree of the component, does a DFS of the spanning tree, and expands all vertices that have known shortest path length t from some source vertex (line 9). At each iteration (line 5), components are disjoint, so relocating to all these vertices takes at most O(V i ) edge traversals. Thus, in one iteration, relocating to all vertices in the strip within distancer takes at most O(-r V i ) edge traversals. Moreover, note that in order for the robot to expand each vertex, it traverses at most O(E i ) edges. Thus, the total number of edge traversals for strip i in one iteration is O(E i +-r V i ). Combining this with Lemma 2, the total number of edge traversals within strip i to completely explore strip i takes O((E i +-r V i ) log V) edge traversals. Now we count edge traversals for relocating between source vertices in strip i. As in the proof of Theorem 2, in each iteration the robot traverses at most 2V edges to relocate between source vertices. Since there are at most log V iterations, this results in 2V log V edge traversals between source vertices to explore strip i. Thus, the total number of edge traversals to explore strip i is O((E i +-r V i ) log V+ 2V log V). Summing over ther disjoint strips gives O((E+-r V) log V+ 2V -r log V)=O((E+-r V) log V)=O((E+V 1.5 ) log V). K</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">A NEARLY LINEAR TIME ALGORITHM FOR EXPLORING UNDIRECTED GRAPHS</head><p>This section describes an efficiently interruptible algorithm Recursive-Strip, which gives a piecemeal exploration algorithm with running time O(E+V 1+o (1) ).</p><p>Recursive-Strip is the recursive version of Iterative-Strip; it provides a recursive structure that coordinates the exploration of strips, of approximate BFS trees, and of connected components in a different manner. The robot still, however, builds a global BFS tree from start vertex s, strip by strip. The robot expands vertices at the bottom level of recursion.</p><p>In Recursive-Strip, the depth of each strip depends on the level of recursion (see Fig. <ref type="figure" target="#fig_5">5</ref>). If there are k levels of recursion, then the algorithm starts at the top level by splitting the exploration of G into rÂd k&amp;1 strips of depth d k&amp;1 . Each of these strips is split into d k&amp;1 Âd k&amp;2 searches of strips of depth d k&amp;2 , etc. We have</p><formula xml:id="formula_3">r=d k &gt;d k&amp;1 &gt; } } } &gt;d 1 &gt;d 0 =1.</formula><p>Each recursive call of the algorithm is passed a set of source vertices sources, the depth to which it must explore, and a set T of all vertices in the strip already known to have path length less than depth from one of the sources. The set of vertices T At recursion level i, the algorithm divides the exploration into strips and processes each strip in turn, as follows. Suppose the strip has l source vertices v 1 , ..., v l . Then the strip is processed in at most log l=O(log V) iterations. In each iteration, the algorithm partitions T into maximal sets T 1 , T 2 , ..., T k such that each set is known to be connected within the strip. Let S c denote the set of source vertices in T c . A DFS of the spanning tree of the vertices T gives an order for the source vertices in S 1 , S 2 , ..., S k ; this spanning tree is used for efficient relocations between these source vertices. Note that all source vertices are known to be connected through the spanning tree of the vertices in T, but they might not be connected within the substrips. Since relocations between the vertices in S c in the next level of recursion use a spanning tree of T c , for efficiency the vertices of T c must be connected within the substrip. After partitioning the vertices into connected components within the strip, for each connected component T c the robot relocates (along a spanning tree) to some arbitrary source vertex in S c . It then calls the algorithm recursively with S c , the depth of the substrip, and the vertices T c which are connected to the sources S c within the substrip.</p><p>The remaining iterations in the strip combine the connected components until the strip is finished. Then the robot continues with the next strip in the same level of recursion. Or, if it finished the last strip, it relocated to its starting position and returns to the next higher level of recursion.</p><p>Recursive-Strip(sources, depth, T )</p><formula xml:id="formula_4">1. If depth=1 2. Then 3.</formula><p>let v 1 , v 2 , ..., v k be the depth-first ordering of sources in spanning tree 4.</p><p>For i=1 To k Do 5.</p><p>relocate to v i 6.</p><p>If v i has adjacent unexplored edges 7.</p><p>Then traverse v i 's incident edges 8.</p><p>T=T _ [newly discovered vertices] 9.</p><p>Return 10. Else 11.</p><p>determine next depth as in proof of Theorem 4 12.</p><p>number-of-strips Â depthÂnext-depth 13.</p><p>For i=1 To number-of-strips Do 14.</p><p>determine set of source vertices 15.</p><p>For j=1 To number-of-iterations Do 16.</p><p>partition vertices in T into maximal sets T 1 , T 2 , ..., T k such that vertices in each T c are known to be connected within strip i 17.</p><p>For each T c in suitable order Do 18.</p><p>let S c be the source vertices in T c 19.</p><p>relocate to some source s # S c 20.</p><p>Recursive-Strip(S c , next-depth, T c ) 21.</p><p>T=T _ T c 22. relocate to some s # sources 23. Return We count edge traversals for each of these cases. First we give some notation. We consider the top level of recursion to be a level-k recursive call, and the bottom level of recursion to be a level-0 recursive call. For a particular level-i call of Recursive-Strip, let C i denote the number of edge traversals due to relocations, and let E i denote the number of distinct edges that are traversed due to relocation. Let V i denote the number of vertices incident to these edges and whose incident edges are all known at the end of this call. Let \ i be a uniform upper bound on C i ÂV i . Thus, if the depth of recursion is k then the total number of edge traversals is bounded by O(V\ k ).</p><p>First we observe that each vertex is expanded at most once, so there are at most O(E+V) edge traversals due to exploration at line 7 in the bottom level of recursion.</p><p>Second, for a level-i call, we count the number of edge traversals for relocation between source vertices. Since all the source vertices in the call are connected by a tree of size O(V i ), relocating to all source vertices at the start of one strip takes O(V i ) edge traversals. With d i Âd i&amp;1 strips and log V iterations per strip, there are V i log V(d i Âd i&amp;1 ) edge traversals for relocations between source vertices.</p><p>Third, we now count traversals for recursive calls within a level-i call. Note that our algorithm avoids re-exploring previously explored edges. Thus, for a level-i call, when working on a particular strip l, for each iteration within this strip, the sets of vertices whose edges are explored in each recursive call are disjoint. Suppose that, in this strip, in one iteration the procedure makes k recursive calls, each at level i&amp;1. Then let C ( j) i&amp;1 , 1 j k, denote the number of edge traversals due to relocations resulting from the j th recursive call, and let V ( j)  i&amp;1 denote the number of vertices adjacent to these edges. Furthermore, let V l, i denote the number of vertices which are in strip l of this procedure call at recursion level i. Then we would like first to calculate</p><formula xml:id="formula_5">: k j=1 C ( j) i&amp;1 ,</formula><p>which is the number of edge traversals due to relocation in recursive calls in one iteration within this strip. This is at most</p><formula xml:id="formula_6">: k j=1 \ i&amp;1 V ( j) i&amp;1 =\ i&amp;1 : k j=1 V ( j) i&amp;1 .</formula><p>Since the recursive calls are disjoint, k j=1 V ( j) i&amp;1 =V l, i , and thus, the number of edge traversals due to relocations in recursive calls in one iteration within this strip is at most \ i&amp;1 V l, i . Finally, since there are log V iterations in each strip, and all strips are disjoint from each other, the number of edge traversals due to recursive calls is at most \ i&amp;1 V i log V.</p><p>Fourth, note that we relocate once at the end of each procedure call of Recursive-Strip (see line <ref type="bibr" target="#b21">22)</ref>. This results in at most V i edge traversals. Thus, the number of edge traversals due to relocation (not including relocations for expanding vertices) is described by the recurrence</p><formula xml:id="formula_7">C i V i log V(d i Âd i&amp;1 )+ \ i&amp;1 V i log V+V i .</formula><p>Normalizing by V i , we get the recurrence</p><formula xml:id="formula_8">\ i = \ d i d i&amp;1 +\ i&amp;1 + log V+O(1).</formula><p>Solving the recurrence for \ k gives</p><formula xml:id="formula_9">\ k \ d k d k&amp;1 + log V+ \ d k&amp;1 d k&amp;2 + log 2 V+ } } } + \ d 1 d 0 + log k V+\ 0 log k V+ : k&amp;1 i=0 log i V \ d k d k&amp;1 + log V+ \ d k&amp;1 d k&amp;2 + log 2 V+ } } } + \ d 1 d 0 + log k V+O(log k V) : k i=1 \ d k+1&amp;i d k&amp;i + log i V+O(log k V).</formula><p>We note that \ 0 =O(1), since at the bottom level, if there are V$ vertices expanded, then the number of edge traversals due to relocation is O(V$). The product of the first k terms in the recurrence is</p><formula xml:id="formula_10">k i=1 log i V \ d k+1&amp;i d k&amp;i + = d k d 0 (log V) (k+1) kÂ2 =r(log V) (k+1) kÂ2 .</formula><p>We choose d k&amp;1 , d k&amp;2 , ... by setting each of the first k terms equal to the kth root of this product. (Note that this also specifies how to calculate depth d i&amp;1 from depth d i in line 11.) Substituting, we get</p><formula xml:id="formula_11">\ k kr 1Âk (log V) (k+1)Â2 +O(log k V) 2 log k } 2 (log r)Âk } 2 (k+1)Â2 log log V +O(2 k log log V ).</formula><p>Choosing k=(log VÂlog log V) 1Â2 gives us</p><formula xml:id="formula_12">\ k 2 log -log V&amp;log -log log V+(-log log VÂ-log V) log V+(-log VÂ-log log V+1) 1Â2 log log V +O(2 (-log VÂ-log log V) log log V ) 2 log log V&amp;(1Â2) log log log V+(3Â2) -log V log log V +O(2 -log V log log V ) =2 O(-log V log log V)</formula><p>and thus,</p><formula xml:id="formula_13">C k =V 2 O(-log V log log V)</formula><p>which is V 1+o (1) . Adding the edge traversals for relocation to the edge traversals for exploration gives us O(E+V 1+o (1) ) edge traversals total. K</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">TREASURE HUNTING</head><p>We now consider an application of our algorithms to the problem of finding a treasure (or a lost child, or a particular landmark) in an unknown, potentially infinite graph G=(V, E). If the robot searching for the treasure knows that the treasure is close to its start location, it should explore in a manner such that it does not get too far away from this location.</p><p>We give the procedure Treasure-Search, which uses the Recursive-Strip algorithm as a subroutine. If the treasure is shortest path distance $ T away from the source vertex, this algorithm maintains the condition that the robot is never further from the source than 2, where 2 $ T +o($ T ). Following procedure Treasure-Search, the robot traverses O(E+V 1+o (1) ) edges, where E and V are the total number of distinct edges and vertices within radius 2 from the source.</p><p>The robot explores the graph for the treasure in phases. In each phase, the size of the strip to be explored changes. The change at phase i depends on = i =1Â-i. Initially, the robot explores the graph out to distance r 1 =1+= 1 . Next, the robot extends its exploration by a factor of 1+= 2 . That is, the size of the next strip is For |x| &lt;1, using a Taylor expansion, we have ln(1+x)=x&amp;x 2 Â2+x 3 Â3&amp;x 4 Â4 + } } } . For 0&lt;x&lt;1, we have ln(1+x)&gt;x&amp;x 2 Â2. So 4 ln 2 $ T ln(1+1Â(2 ln $ T ))&gt; (4 ln 2 $ T )(1Â(2 ln $ T )&amp;1Â(8 ln 2 $ T ))=2 ln $ T &amp;1Â2, which is at least ln $ T for $ T 2. K Theorem 5. The robot is never further than $ T +$ T Â-log $ T from the source vertex.</p><p>Proof. Let 2 be the furthest distance the robot gets from the source vertex. Let i be the number of phases that need to be explored to get out to depth $ T . Then, 2&amp;$ T is at most the depth of the strip in the i th phase. That is, 2&amp;$ T (1+= 1 ) (1+= 2 ) } } } (1+= i )&amp;(1+= 1 )(1+= 2 ) } } } (1+= i&amp;1 )=(1+= 1 )(1+= 2 ) } } } (1+= i&amp;1 ) = i &lt; $ T = i . Lemma 3 shows that the total number of strips explored is at least log $ T . Thus, = i is at most 1Â-log $ T , and 2 $ T +$ T Â-log $ T =$ T +o($ T ). K Theorem 6. Given a treasure at distance $ T from the source, procedure Treasure-Search traverses at most O(E+V 1+o (1) ) edges, where E and V are the total number of distinct edges and vertices within radius 2 $ T +o($ T ) from the source.</p><p>Proof. Since the edges traversed in the different phases are disjoint, the number of edges traversed, ignoring relocations between source vertices in line 16, is at most O(E+V 1+o (1) ). To get between source vertices in line 16, a spanning tree of the known vertices can be used. (Note that for recursive calls of Recursive-Strip, the algorithm relocates between source vertices using the vertices connected within the appropriate strip.) By Lemma 4, we know the number of phases is at most 4 ln 2 $ T , and in each phase it may take up to log V iterations to explore the entire strip. Thus there are an additional 4V ln 2 $ T log V edge traversals due to relocations between source vertices, and this gives a total of O(E+V 1+o (1) ) edge traversals for the entire Treasure-Search procedure. K</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>FIG. 1 .</head><label>1</label><figDesc>FIG.1. In Strip-Explore, the shaded areas are passed through more than once only if necessary to get to frontier vertices. In the naive algorithm, the shaded areas are retraversed completely.</figDesc><graphic coords="7,10.00,43.17,358.56,134.23" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>1. numstrips=WrÂLX 2. sources=[s] 3. For i=1 To numstrips Do 4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>FIG. 2 .</head><label>2</label><figDesc>FIG. 2. Contrasting BFS and Local-BFS: Consider a BFS of depth 5 from s 1 , followed by a BFS of depth 5 from s 2 . (The depth of the strip is L=5.) The BFS from s 2 revisits vertices a, b, c, d, e. On the other hand, if the BFS from s 1 is followed by a Local-BFS from s 2 , then the Local-BFS only revisits d, c, e. After edge ( f, d) is found, vertex e is a frontier vertex that is expanded by Local-BFS(s 2 , 5).</figDesc><graphic coords="7,107.60,464.26,163.92,123.44" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>FIG. 3 .</head><label>3</label><figDesc>FIG. 3. The iterative strip algorithm after the first iteration on the fourth strip. Two connected components c 1 , c 2 have been explored. The collision edges e 1 and e 2 connect the first three approximate BFS trees. The dashed line shows how source vertices s 1 , s 2 , s 3 connect within the strip. There are three active frontier vertices with depth less than D+-r.</figDesc><graphic coords="9,9.10,43.37,360.72,136.03" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>FIG. 4 .</head><label>4</label><figDesc>FIG. 4. The iterative strip algorithm after the second iteration. Now the circled vertices which were active frontier vertices at the beginning of the iteration are expanded. One of the expansions resulted in a collision edge. Now the strip consists of only one connected component (shaded area). There are six frontier vertices which become source vertices of the next strip. All frontier vertices have depth D+-r.</figDesc><graphic coords="9,9.10,451.25,360.96,136.45" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>FIG. 5 .</head><label>5</label><figDesc>FIG. 5. The recursive strip algorithm processing an approximate BFS tree from source vertex s 2 to depth d k&amp;1 =L. Recursive calls within the tree are of depth d k&amp;2 =L$.</figDesc><graphic coords="12,9.10,42.47,359.52,133.93" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Theorem 4 .</head><label>4</label><figDesc>Recursive-Strip runs in time O(E+V 1+o(1) ). Proof. At a particular call of Recursive-Strip, there are four situations in which the robot traverses edges: 1. expansion of vertices in line 7 2. relocating to sources in lines 5 and 19 3. relocations due to recursive calls in line 20 4. relocation back to a beginning source vertex in line 22.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUDING REMARKS</head><p>We have presented an efficient O(E+V 1+o <ref type="bibr" target="#b0">(1)</ref> ) algorithm for piecemeal learning of arbitrary, undirected graphs. The only lower bound known for this problem is the trivial bound 0(E+V), and it is not known whether a linear-time algorithm exists.</p><p>We have also given an algorithm for the application of treasure hunting on potentially infinite graphs. Is it possible (we conjecture not) to find a treasure in time nearly linear in the number of those vertices and edges whose distance to the source is less than or equal to that of the treasure?</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>(1+= 1 )(1+= 2 )&amp;(1+= 1 ), and at the end of the second phase, the robot has learned the graph out to distance r 2 =(1+= 1 )(1+= 2 ). After extending the next strip, the robot has learned the graph out to distance r 3 =(1+= 1 )(1+= 2 )(1+= 3 ), and so on. In each phase i, the robot initially calls Recursive-Strip from the set of source vertices (vertices at distance r i&amp;1 ). When the robot finds collisions edges, it does not re-explore edges. Thus, within each phase, it may take up to log V iterations (as in Iterative-Strip and Recursive-Strip) before it has explored the entire strip.</p><p>Lemmas 3 and 4 bound the number of phases in the Treasure-Search procedure. Using Lemma 3, Theorem 5 shows that the robot does not get too far away from the source vertex, and using Lemma 4, Theorem 6 bounds the number of edges the robot traverses.</p><p>Treasure-Search(s)</p><p>If i=1 8.</p><p>Then 9.</p><p>Recursive-Strip([s], r 1 , [s]) 10.</p><p>Else 11.</p><p>let T be the set of source vertices distance r i&amp;1 away from s 12.</p><p>For j=1 To number-of-iterations Do 13.</p><p>partition vertices in T into maximal sets T 1 , ..., T k such that vertices in each T c are known to be connected within strip i 14.</p><p>For each T c in suitable order Do 15.</p><p>let S c be the source vertices in T c 16.</p><p>relocate to some source s # S c 17.</p><p>Recursive-Strip(S c , r i &amp;r i&amp;1 , T c ) 18.</p><p>T=T _ T c Lemma 3. The number of phases in Treasure-Search is at least log $ T .</p><p>Proof. Since = 1 &gt;= 2 &gt;= 3 } } } , we know that, for any j, (1+= 1 )(1+= 2 ) } } } (1+= j ) (1+= 1 ) j . Thus, if we let j be the smallest number such that (1+= 1 ) j $ T , then we know that the number of phases i to reach the treasure at $ T is at least j. Since = 1 =1, we have 2 j $ T , or j log $ T . K Lemma 4. The number of phases in Treasure-Search is at most 4 ln 2 $ T +1.</p><p>Proof. A treasure at depth $ T =1 is found in the first phase, so we consider only $ T &gt;1. We know that for any j, (1+= j ) j (1+= 1 )(1+= 2 ) } } } (1+= j ). Thus, if (1+= j ) j $ T , we know that the number of phases i is at most j. So we prove the lemma by showing that (1+= 4 ln 2 $ T ) 4 ln 2 $ T $ T , or equivalently, that 4 ln 2 $ T ln(1+= 4 ln 2 $ T )=4 ln 2 $ T ln(1+1Â(2 ln $ T )) ln $ T .</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Near-linear time construction of sparse neighborhood covers</title>
		<author>
			<persName><forename type="first">B</forename><surname>Awerbuch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Peleg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="254" to="262" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Distributed BFS algorithm</title>
		<author>
			<persName><forename type="first">B</forename><surname>Awerbuch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">G</forename><surname>Gallager</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th Symposium on Foundations of Computer Science</title>
		<meeting>the 26th Symposium on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="250" to="256" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A new distributed algorithm to find breadth first search trees</title>
		<author>
			<persName><forename type="first">B</forename><surname>Awerbuch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">G</forename><surname>Gallager</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory IT</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">332</biblScope>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">On-line navigation in a room</title>
		<author>
			<persName><forename type="first">E</forename><surname>Bar-Eli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Berman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fiat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Yan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Algorithms</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page">341</biblScope>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The power of team exploration: two robots can learn unlabeled directed graphs</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Bender</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">K</forename><surname>Slonim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Thirty-Fifth Annual Symposium on Foundations of Computer Science</title>
		<meeting>the Thirty-Fifth Annual Symposium on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="75" to="85" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Algorithms for Exploring an Unknown Graph</title>
		<author>
			<persName><forename type="first">M</forename><surname>Betke</surname></persName>
		</author>
		<idno>MITÂLCSÂTR-536</idno>
		<imprint>
			<date type="published" when="1992-03">1992. March 1992</date>
		</imprint>
		<respStmt>
			<orgName>MIT Department of Electrical Engineering and Computer Science, Published as MIT laboratory for Computer Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>Master&apos;s thesis</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Mobile robot localization using landmarks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Betke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Gurvits</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Robot. Automat</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="251" to="263" />
			<date type="published" when="1997-04">April 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Piecemeal learning of an unknown environment</title>
		<author>
			<persName><forename type="first">M</forename><surname>Betke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Singh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mach. Learning</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">2Â3</biblScope>
			<biblScope unit="page">254</biblScope>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">An on-line algorithm for improving performance in navigation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Chalasani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Thirty-Fourth Annual Symposium on Foundations of Computer Science</title>
		<meeting>the Thirty-Fourth Annual Symposium on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="2" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Navigating in unfamiliar geometric terrain</title>
		<author>
			<persName><forename type="first">A</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Raghavan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Schieber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">137</biblScope>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Introduction to Algorithms</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">H</forename><surname>Cormen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Leiserson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>McGraw-Hill</publisher>
			<pubPlace>Cambridge, MA; New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">How to learn an unknown environment I: The rectilinear case</title>
		<author>
			<persName><forename type="first">X</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kameda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Papadimitriou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Assoc. Comput. Mach</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">245</biblScope>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Exploring an unknown graph</title>
		<author>
			<persName><forename type="first">X</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Papadimitriou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31st Symposium on Foundations of Computer Science</title>
		<meeting>the 31st Symposium on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">I</biblScope>
			<biblScope unit="page" from="355" to="361" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Using multiple markers in graph exploration</title>
		<author>
			<persName><forename type="first">G</forename><surname>Dudek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jenkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Milios</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wilkes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SPIE</title>
		<imprint>
			<biblScope unit="volume">1195</biblScope>
			<biblScope unit="page" from="77" to="87" />
			<date type="published" when="1989">1989</date>
			<pubPlace>Mobile Robots IV</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Walking an unknown street with bounded detour</title>
		<author>
			<persName><forename type="first">R</forename><surname>Klein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Geom. Theory Appl</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page">351</biblScope>
			<date type="published" when="1992-06">June 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">The localization problem for mobile robots</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Kleinberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 35st Annual Symposium on Foundations of Computer Science</title>
		<meeting>the 35st Annual Symposium on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="521" to="531" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">An algorithm for path connection and its applications</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">Y</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IRE Transactions on Electronic Computers EC</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">365</biblScope>
			<date type="published" when="1961">1961</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The shortest path through a maze</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">F</forename><surname>Moore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on the Theory of Switching</title>
		<meeting>the International Symposium on the Theory of Switching</meeting>
		<imprint>
			<date type="published" when="1959">1959</date>
			<biblScope unit="page" from="285" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Shortest paths without a map</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Papadimitriou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yanakakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">84</biblScope>
			<biblScope unit="page">150</biblScope>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Robot Navigation in Unknown Terrains: Introductory Survey of Non-heuristic Algorithms</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">S V</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kareti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Iyengar</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
		<respStmt>
			<orgName>ORNLÂTM-12410 Oak Ridge National Laboratory</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Inference of finite automata using homing sequences</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Schapire</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. and Comput</title>
		<imprint>
			<biblScope unit="volume">103</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">347</biblScope>
			<date type="published" when="1993-04">April 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Optimal robot localization in trees</title>
		<author>
			<persName><forename type="first">K</forename><surname>Romanik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Schuierer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th Symposium on Foundations of Computational Geometry</title>
		<meeting>the 12th Symposium on Foundations of Computational Geometry</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
