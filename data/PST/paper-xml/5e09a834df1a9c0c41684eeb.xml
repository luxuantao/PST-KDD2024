<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A survey on semi-supervised learning</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2019-11-15">15 November 2019</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Jesper</forename><forename type="middle">E</forename><surname>Van Engelen</surname></persName>
							<email>jesper.van.engelen@gmail.com</email>
							<idno type="ORCID">0000-0001-7220-5441</idno>
							<affiliation key="aff0">
								<orgName type="department">Leiden Institute of Advanced Computer Science</orgName>
								<orgName type="institution">Leiden University</orgName>
								<address>
									<settlement>Leiden</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Holger</forename><forename type="middle">H</forename><surname>Hoos</surname></persName>
							<idno type="ORCID">0000-0003-0629-0099</idno>
							<affiliation key="aff0">
								<orgName type="department">Leiden Institute of Advanced Computer Science</orgName>
								<orgName type="institution">Leiden University</orgName>
								<address>
									<settlement>Leiden</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of British Columbia</orgName>
								<address>
									<settlement>Vancouver</settlement>
									<region>BC</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A survey on semi-supervised learning</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2019-11-15">15 November 2019</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1007/s10994-019-05855-6</idno>
					<note type="submission">Received: 3 December 2018 / Revised: 20 September 2019 / Accepted: 29 September 2019 /</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T14:19+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Semi-supervised learning</term>
					<term>Machine learning</term>
					<term>Classification</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Semi-supervised learning is the branch of machine learning concerned with using labelled as well as unlabelled data to perform certain learning tasks. Conceptually situated between supervised and unsupervised learning, it permits harnessing the large amounts of unlabelled data available in many use cases in combination with typically smaller sets of labelled data. In recent years, research in this area has followed the general trends observed in machine learning, with much attention directed at neural network-based models and generative learning. The literature on the topic has also expanded in volume and scope, now encompassing a broad spectrum of theory, algorithms and applications. However, no recent surveys exist to collect and organize this knowledge, impeding the ability of researchers and engineers alike to utilize it. Filling this void, we present an up-to-date overview of semi-supervised learning methods, covering earlier work as well as more recent advances. We focus primarily on semi-supervised classification, where the large majority of semi-supervised learning research takes place. Our survey aims to provide researchers and practitioners new to the field as well as more advanced readers with a solid understanding of the main approaches and algorithms developed over the past two decades, with an emphasis on the most prominent and currently relevant work. Furthermore, we propose a new taxonomy of semi-supervised classification algorithms, which sheds light on the different conceptual and methodological approaches for incorporating unlabelled data into the training process. Lastly, we show how the fundamental assumptions underlying most semi-supervised learning algorithms are closely connected to each other, and how they relate to the well-known semi-supervised clustering assumption.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In machine learning, a distinction has traditionally been made between two major tasks: supervised and unsupervised learning <ref type="bibr" target="#b18">(Bishop 2006)</ref>. In supervised learning, one is presented with a set of data points consisting of some input x and a corresponding output value y. The goal is, then, to construct a classifier or regressor that can estimate the output value for previously unseen inputs. In unsupervised learning, on the other hand, no specific output value is provided. Instead, one tries to infer some underlying structure from the inputs. For instance, in unsupervised clustering, the goal is to infer a mapping from the given inputs (e.g. vectors of real numbers) to groups such that similar inputs are mapped to the same group.</p><p>Semi-supervised learning is a branch of machine learning that aims to combine these two tasks <ref type="bibr" target="#b24">(Chapelle et al. 2006b;</ref><ref type="bibr" target="#b206">Zhu 2008)</ref>. Typically, semi-supervised learning algorithms attempt to improve performance in one of these two tasks by utilizing information generally associated with the other. For instance, when tackling a classification problem, additional data points for which the label is unknown might be used to aid in the classification process. For clustering methods, on the other hand, the learning procedure might benefit from the knowledge that certain data points belong to the same class.</p><p>As is the case for machine learning in general, a large majority of the research on semisupervised learning is focused on classification. Semi-supervised classification methods are particularly relevant to scenarios where labelled data is scarce. In those cases, it may be difficult to construct a reliable supervised classifier. This situation occurs in application domains where labelled data is expensive or difficult obtain, like computer-aided diagnosis, drug discovery and part-of-speech tagging. If sufficient unlabelled data is available and under certain assumptions about the distribution of the data, the unlabelled data can help in the construction of a better classifier. In practice, semi-supervised learning methods have also been applied to scenarios where no significant lack of labelled data exists: if the unlabelled data points provide additional information that is relevant for prediction, they can potentially be used to achieve improved classification performance.</p><p>A plethora of learning methods exists, each with their own characteristics, advantages and disadvantages. The most recent comprehensive survey of the area was published by <ref type="bibr" target="#b206">Zhu in 2005</ref><ref type="bibr">and last updated in 2008</ref><ref type="bibr">[see Zhu (2008)</ref>]. The book by <ref type="bibr" target="#b24">Chapelle et al. (2006b)</ref> and the introductory book by <ref type="bibr" target="#b210">Zhu and Goldberg (2009)</ref> also provide good bases for studying earlier work on semi-supervised learning. More recently, <ref type="bibr" target="#b155">Subramanya and Talukdar (2014)</ref> provided an overview of several graph-based techniques, and <ref type="bibr" target="#b168">Triguero et al. (2015)</ref> reviewed and analyzed pseudo-labelling techniques, a class of semi-supervised learning methods.</p><p>Since the survey by <ref type="bibr" target="#b206">Zhu (2008)</ref> was published, some important developments have taken place in the field of semi-supervised learning. Across the field, new learning approaches have been proposed, and existing approaches have been extended, improved, and analyzed in more depth. Additionally, the rise in popularity of (deep) neural networks <ref type="bibr" target="#b60">(Goodfellow 2017)</ref> for supervised learning has prompted new approaches to semi-supervised learning, driven by the simplicity of incorporating unsupervised loss terms into the cost functions of neural networks. Lastly, there has been increased attention for the development of robust semi-supervised learning methods that do not degrade performance, and for the evaluation of semi-supervised learning methods for practical purposes.</p><p>In this survey, we aim to provide the reader with a comprehensive overview of the current state of the research area of semi-supervised learning, covering early work and recent advances, and providing explanations of key algorithms and approaches. We present a new taxonomy for semi-supervised classification methods that captures the assumptions under-lying each group of methods as well as the way in which they relate to existing supervised methods. In this, we provide a perspective on semi-supervised learning that allows for a more thorough understanding of different approaches and the connections between them. Furthermore, we shed new light on the fundamental assumptions underlying semi-supervised learning, and show how they connect to the so-called cluster assumption.</p><p>Although we aim to provide a comprehensive survey on semi-supervised learning, we cannot possibly cover every method in existence. Due to the sheer size of the literature on the topic, this would not only be beyond the scope of this article, but also distract from the key insights which we wish to provide to the reader. Instead, we focus on the most influential work and the most important developments in the area over the past twenty years.</p><p>The rest of this article is structured as follows. The basic concepts and assumptions of semisupervised learning are covered in Sect. 2, where we also make a connection to clustering. In Sect. 3, we present our taxonomy of semi-supervised learning methods, which forms the conceptual basis for the remainder of our survey. Inductive methods are covered in Sects. 4 through 6. We first consider wrapper methods (Sect. 4), followed by unsupervised preprocessing (Sect. 5), and finally, we cover intrinsically semi-supervised methods (Sect. 6). Sect. 7 covers transductive methods, which form the second major branch of our taxonomy. Semi-supervised regression and clustering are discussed in Sect. 8. Finally, in Sect. 9, we provide some prospects for the future of semi-supervised learning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head><p>In traditional supervised learning problems, we are presented with an ordered collection of l labelled data points D L = ((x i , y i )) l i=1 . Each data point (x i , y i ) consists of an object x i ∈ X from a given input space X , and has an associated label y i , where y i is real-valued in regression problems and categorical in classification problems. Based on a collection of these data points, usually called the training data, supervised learning methods attempt to infer a function that can successfully determine the label y * of some previously unseen input x * .</p><p>In many real-world classification problems, however, we also have access to a collection of u data points, D U = (x i ) l+u i=l+1 , whose labels are unknown. For instance, the data points for which we want to make predictions, usually called the test data, are unlabelled by definition. Semi-supervised classification methods attempt to utilize unlabelled data points to construct a learner whose performance exceeds the performance of learners obtained when using only the labelled data. In the remainder of this survey, we denote with X L and X U the collection of input objects for the labelled and unlabelled samples, respectively. <ref type="foot" target="#foot_0">1</ref>There are many cases where unlabelled data can help in constructing a classifier. Consider, for example, the problem of document classification, where we wish to assign topics to a collection of text documents (such as news articles). Assuming our documents are represented by the set of words that appear in it, one could train a simple supervised classifier that, for example, learns to recognize that documents containing the word "neutron" are usually about physics. This classifier might work well on documents containing terms that it has seen in the training data, but will inherently fail when a document does not contain predictive words that also occurred in the training set. For example, if we encounter a physics document Fig. <ref type="figure">1</ref> A basic example of binary classification in the presence of unlabelled data. The unlabelled data points are coloured according to their true label. The coloured, unfilled circles depict the contour curves of the input data distribution corresponding to standard deviations of 1, 2 and 3 (Color figure online) about particle accelerators that does not contain the word "neutron", the classifier is unable to recognize it as a document concerning physics. This is where semi-supervised learning comes in. If we consider the unlabelled data, there might be documents that connect the word "neutron" to the phrase "particle accelerator". For instance, the word "neutron" would often occur in a document that also contains the word "quark". Furthermore, the word "quark" would regularly co-occur with the phrase "particle accelerator", which guides the classifiers towards classifying these documents as revolving around physics as well, despite having never seen the phrase "particle accelerator" in the labelled data.</p><p>Figure <ref type="figure">1</ref> provides some further intuition towards the use of unlabelled data for classification. We consider an artificial classification problem with two classes. For both classes, 100 samples are drawn from a 2-dimensional Gaussian distribution with identical covariance matrices. The labelled data set is then constructed by taking one sample from each class. Any supervised learning algorithm will most likely obtain as the decision boundary the solid line, which is perpendicular to the line segment connecting the two labelled data points and intersects it in the middle. However, this is quite far from the optimal decision boundary. As is clear from this figure, the clusters we can infer from the unlabelled data can help us considerably in placing the decision boundary: assuming that the data stems from two Gaussian distributions, a simple semi-supervised learning algorithm can infer a close-to-optimal decision boundary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Assumptions of semi-supervised learning</head><p>A necessary condition of semi-supervised learning is that the underlying marginal data distribution p(x) over the input space contains information about the posterior distribution p(y|x). If this is the case, one might be able to use unlabelled data to gain information about p(x), and thereby about p(y|x). If, on the other hand, this condition is not met, and p(x) contains no information about p(y|x), it is inherently impossible to improve the accuracy of predictions based on the additional unlabelled data <ref type="bibr" target="#b206">(Zhu 2008)</ref>.</p><p>(a) Smoothness and low-density assumptions.</p><p>(b) Manifold assumption.</p><p>Fig. <ref type="figure">2</ref> Illustrations of the semi-supervised learning assumptions. In each picture, a reasonable supervised decision boundary is depicted, as well as the optimal decision boundary, which could be closely approximated by a semi-supervised learning algorithm relying on the respective assumption Fortunately, the previously mentioned condition appears to be satisfied in most learning problems encountered in the real world, as is suggested by the successful application of semisupervised learning methods in practice. However, the way in which p(x) and p(y|x) interact is not always the same. This has given rise to the semi-supervised learning assumptions, which formalize the types of expected interaction <ref type="bibr" target="#b24">(Chapelle et al. 2006b</ref>). The most widely recognized assumptions are the smoothness assumption (if two samples x and x are close in the input space, their labels y and y should be the same), the low-density assumption (the decision boundary should not pass through high-density areas in the input space), and the manifold assumption (data points on the same low-dimensional manifold should have the same label). These assumptions are the foundation of most, if not all, semi-supervised learning algorithms, which generally depend on one or more of them being satisfied, either explicitly or implicitly. Throughout this survey, we will elaborate on the underlying assumptions utilized by each specific learning algorithm. The assumptions are explained in more detail below; a visual representation is provided in Fig. <ref type="figure">2</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.1">Smoothness assumption</head><p>The smoothness assumption states that, for two input points x, x ∈ X that are close by in the input space, the corresponding labels y, y should be the same. This assumption is also commonly used in supervised learning, but has an extended benefit in the semi-supervised context: the smoothness assumption can be applied transitively to unlabelled data. For example, assume that a labelled data point x 1 ∈ X L and two unlabelled data points x 2 , x 3 ∈ X U exist, such that x 1 is close to x 2 and x 2 is close to x 3 , but x 1 is not close to x 3 . Then, because of the smoothness assumption, we can still expect x 3 to have the same label as x 1 , since proximity-and thereby the label-is transitively propagated through x 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.2">Low-density assumption</head><p>The low-density assumption implies that the decision boundary of a classifier should preferably pass through low-density regions in the input space. In other words, the decision boundary should not pass through high-density regions. The assumption is defined over p(x), the true distribution of the input data. When considering a limited set of samples from this distribution, it essentially means that the decision boundary should lie in an area where few data points are observed. In that light, the low-density assumption is closely related to the smoothness assumption; in fact, it can be considered the counterpart of the smoothness assumption for the underlying data distribution.</p><p>Suppose that a low-density area exists, i.e. an area R ⊂ X where p(x) is low. Then very few observations are expected to be contained in R, and it is thus unlikely that any pair of similar data points in R is observed. If we place the decision boundary in this low-density area, the smoothness assumption is not violated, since it only concerns pairs of similar data points. For high-density areas, on the other hand, many data points can be expected. Thus, placing the decision boundary in a high-density region violates the smoothness assumption, since the predicted labels would then be dissimilar for similar data points.</p><p>The converse is also true: if the smoothness assumption holds, then any two data points that lie close together have the same label. Therefore, in any densely populated area of the input space, all data points are expected to have the same label. Consequently, a decision boundary can be constructed that passes only through low-density areas in the input space, thus satisfying the low-density assumption as well. Due to their close practical relation, we depict the low-density assumption and the smoothness assumption in a single illustration in Fig. <ref type="figure">2</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.3">Manifold assumption</head><p>In machine learning problems where the data can be represented in Euclidean space, the observed data points in the high-dimensional input space R d are usually concentrated along lower-dimensional substructures. These substructures are known as manifolds: topological spaces that are locally Euclidean. For instance, when we consider a 3-dimensional input space where all points lie on the surface of a sphere, the data can be said to lie on a 2-dimensional manifold. The manifold assumption in semi-supervised learning states that (a) the input space is composed of multiple lower-dimensional manifolds on which all data points lie and (b) data points lying on the same manifold have the same label. Consequently, if we are able to determine which manifolds exist and which data points lie on which manifold, the class assignments of unlabelled data points can be inferred from the labelled data points on the same manifold.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Connection to clustering</head><p>In semi-supervised learning research, an additional assumption that is often included is the cluster assumption, which states that data points belonging to the same cluster belong to the same class <ref type="bibr" target="#b24">(Chapelle et al. 2006b</ref>). We argue, however, that the previously mentioned assumptions and the cluster assumption are not independent of each other but, rather, that the cluster assumption is a generalization of the other assumptions.</p><p>Consider an input space X with some objects X ⊂ X , drawn from the distribution p(x). A cluster, then, is a set of data points C ⊆ X that are more similar to each other than to other data points in X , according to some concept of similarity <ref type="bibr" target="#b2">(Anderberg 1973)</ref>. Determining clusters corresponds to finding some function f : X → Y that maps each input in x ∈ X to a cluster with label y = f (x), where each cluster label y ∈ Y uniquely identifies one cluster. Since we do not have direct access to p(x) to determine a suitable clustering, we need to rely on some concept of similarity between data points in X , according to which we can assign clusters to similar data points.</p><p>The concept of similarity we choose, often implicitly, dictates what constitutes a cluster. Although the efficacy of any particular clustering method for finding these clusters depends on many other factors, the concept of similarity uniquely defines the interaction between p(x) and p(y|x). Therefore, whether two points belong to the same cluster can be derived from their similarity to each other and to other points. From our perspective, the smoothness, lowdensity, and manifold assumptions boil down to different definitions of the similarity between points: the smoothness assumption states that points that are close to each other in input space are similar; the low-density assumption states that points in the same high-density area are similar; and the manifold assumption states that points that lie on the same low-dimensional manifold are similar. Consequently, the semi-supervised learning assumptions can be seen as more specific instances of the cluster assumption: that similar points tend to belong to the same group.</p><p>One could even argue that the cluster assumption corresponds to the necessary condition for semi-supervised learning: that p(x) carries information on p(y|x). In fact, assuming the output space Y contains the labels of all possible clusters, the necessary condition for semisupervised learning to succeed can be seen to be the necessary condition for clustering to succeed. In other words: if the data points (both unlabelled and labelled) cannot be meaningfully clustered, it is impossible for a semi-supervised learning method to improve on a supervised learning method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">When does semi-supervised learning work?</head><p>The primary goal of semi-supervised learning is to harness unlabelled data for the construction of better learning procedures. As it turns out, this is not always easy or even possible. As mentioned earlier, unlabelled data is only useful if it carries information useful for label prediction that is not contained in the labelled data alone or cannot be easily extracted from it. To apply any semi-supervised learning method in practice, the algorithm then needs to be able to extract this information. For practitioners and researchers alike, this begs the question: when is this the case?</p><p>Unfortunately, it has proven difficult to find a practical answer to this question. Not only is it difficult to precisely define the conditions under which any particular semi-supervised learning algorithm may work, it is also rarely straightforward to evaluate to what extent these conditions are satisfied. However, one can reason about the applicability of different learning methods on various types of problems. Graph-based methods, for example, typically rely on a local similarity measure to construct a graph over all data points. To apply such methods successfully, it is important that a meaningful local similarity measure can be devised. In high-dimensional data, such as images, where Euclidean feature distance is rarely a good indicator of the similarity between data points, this is often difficult. As can be seen in the literature, most semi-supervised learning approaches for images rely on a weak variant of the smoothness assumption that requires predictions to be invariant to minor perturbations in the input <ref type="bibr" target="#b135">(Rasmus et al. 2015;</ref><ref type="bibr" target="#b88">Laine and Aila 2017;</ref><ref type="bibr" target="#b166">Tarvainen and Valpola 2017)</ref>. Semisupervised extensions of supervised learning algorithms, on the other hand, generally rely on the same assumption as their supervised counterparts. For instance, both supervised and semi-supervised support vector machines rely on the low-density assumption, which states that the decision boundary should lie in a low-density region of the decision space. If a supervised classifier performs well in such cases, it is only natural to use the semi-supervised extension to the algorithm.</p><p>As is the case for supervised learning algorithms, no method has yet been discovered to determine a priori what learning method is best-suited for any particular problem. What is more, it is impossible to guarantee that the introduction of unlabelled data will not degrade performance. Such performance degradation has been observed in practice, and its prevalence is likely under-reported due to publication bias <ref type="bibr" target="#b206">(Zhu 2008</ref>). The problem of potential performance degradation has been identified in multiple studies <ref type="bibr" target="#b206">(Zhu 2008;</ref><ref type="bibr" target="#b24">Chapelle et al. 2006b;</ref><ref type="bibr" target="#b149">Singh et al. 2009;</ref><ref type="bibr" target="#b99">Li and Zhou 2015;</ref><ref type="bibr" target="#b122">Oliver et al. 2018</ref>), but remains difficult to address. It is particularly relevant in scenarios where good performance can be achieved with purely supervised classifiers. In those cases, the potential performance degradation is much larger than the potential performance gain.</p><p>The main takeaway from these observations is that semi-supervised learning should not be seen as a guaranteed way of achieving improved prediction performance by the mere introduction of unlabelled data. Rather, it should be treated as another direction in the process of finding and configuring a learning algorithm for the task at hand. Semi-supervised learning procedures should be part of the suite of algorithms considered for use in a particular application scenario, and a combination of theoretical analysis (where possible) and empirical evaluation should be used to choose an approach that is well suited to the given situation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Empirical evaluation of semi-supervised learning methods</head><p>When evaluating and comparing machine learning algorithms, a multitude of decisions influence the relative performance of different algorithms. In supervised learning, these include the selection of data sets, the partitioning of those data sets into training, validation and test sets, and the extent to which hyperparameters are tuned. In semi-supervised learning, additional factors come into play. First, in many benchmarking scenarios, a decision has to be made which data points should be labelled and which should remain unlabelled. Second, one can choose to evaluate the performance of the learner on the unlabelled data used for training (which is by definition the case in transductive learning), or on a completely disjoint test set. Additionally, it is important to establish high-quality supervised baselines to allow for proper assessment of the added value of the unlabelled data. In practice, excessively limiting the scope of the evaluation can lead to unrealistic perspectives on the performance of the learning algorithms. Recently, <ref type="bibr" target="#b122">Oliver et al. (2018)</ref> established a set of guidelines for the realistic evaluation of semi-supervised learning algorithms; several of their recommendations are included here.</p><p>In practical use cases, the partitioning of labelled and unlabelled data is typically fixed. In research, data sets used for evaluating semi-supervised learning algorithms are usually obtained by simply removing the labels of a large amount of data points from an existing supervised learning data set. In earlier research, the data sets from the UCI Machine Learning Repository were often used <ref type="bibr" target="#b50">(Dua and Graff 2019)</ref>. In more recent research on semi-supervised image classification, the CIFAR-10/100 <ref type="bibr" target="#b85">(Krizhevsky 2009)</ref> and SVHN <ref type="bibr" target="#b115">(Netzer et al. 2011)</ref> data sets have been popular choices. Additionally, two-dimensional toy datasets are sometimes used to demonstrate the viability of a new approach. Typically, these toy data sets consist of an input distribution where data points from each class are concentrated along a one-dimensional manifold. For instance, the popular half-moon data set consists of data points drawn from two interleaved half circles, each associated with a different class.</p><p>As has been observed in practice, the choice of data sets and their partitioning can have significant impact on the relative performance of different learning algorithms (see, e.g. <ref type="bibr" target="#b24">Chapelle et al. 2006b;</ref><ref type="bibr" target="#b168">Triguero et al. 2015)</ref>. Some algorithms may work well when the amount of labelled data is limited and perform poorly when more labelled data is available; others may excel on particular types of data sets but not on others. To provide a realistic evaluation of semi-supervised learning algorithms, researchers should thus evaluate their algorithms on a diverse suite of data sets with different quantities of labelled and unlabelled data.</p><p>In addition to the choice of data sets and their partitioning, it is important that a strong baseline is chosen when evaluating the performance of a semi-supervised learning method. After all, it is not particularly relevant to practitioners whether the introduction of unlabelled data improves the performance of any particular learning algorithm. Rather, the central question is: does the introduction of unlabelled data yield a learner that is better than any other learner-be it supervised or semi-supervised. As pointed out by <ref type="bibr" target="#b122">Oliver et al. (2018)</ref>, this calls for the inclusion of state-of-the-art, properly tuned supervised baselines when evaluating the performance of semi-supervised learning algorithms.</p><p>Several studies have independently evaluated the performance of different semi-supervised learning methods on various data sets. <ref type="bibr" target="#b24">Chapelle et al. (2006b)</ref> empirically compared eleven diverse semi-supervised learning algorithms, using supervised support vector machines and knearest neighbours as their baseline. They included semi-supervised support vector machines, label propagation and manifold regularization techniques, applying hyperparameter optimization for each algorithm. Comparing the performance of the algorithms on eight different data sets, the authors found that no algorithm uniformly outperformed the others. Substantial performance improvements over the baselines were observed on some data sets, while performance was found to be degraded on others. Relative performance also varied with the amount of unlabelled data. <ref type="bibr" target="#b122">Oliver et al. (2018)</ref> compared several semi-supervised neural networks, including the mean teacher model, virtual adversarial training and a wrapper method called pseudo-label, on two image classification problems. They reported substantial performance improvements for most of the algorithms, and observed that the error rates typically declined as more unlabelled data points were added (without removing any labelled data points). Performance degradations were observed only when there was a mismatch between the classes present in the labelled data and the classes present in the unlabelled data. These results are promising indeed: they indicate that, in image classification tasks, unlabelled data can be employed by neural networks to consistently improve performance. It is an interesting avenue for future research to investigate whether these consistent performance improvements can also be obtained for other types of data. Furthermore, it is an open question whether the assumptions underlying these semi-supervised neural networks could be exploited to consistently improve the performance of other learning methods.</p><p>Fig. <ref type="figure">3</ref> Visualization of the semi-supervised classification taxonomy. Each leaf in the taxonomy corresponds to a specific type of approach to incorporating unlabelled data into classification methods. In the leaf corresponding to transductive, graph-based methods, the dashed boxes represent distinct phases of the graph-based classification process, each of which has a multitude of variations between different groups of methods. Furthermore, the categorizations are often fine-tuned towards existing work, making them less suited for the inclusion of new approaches.</p><p>In this survey, we propose a new way to represent the spectrum of semi-supervised classification algorithms. We attempt to group them in a clear, future-proof way, allowing researchers and practitioners alike to gain insight into the way semi-supervised learning methods relate to each other, to existing supervised learning methods, and to the semi-supervised learning assumptions. The taxonomy is visualized in Fig. <ref type="figure">3</ref>. At the highest level, it distinguishes between inductive and transductive methods, which give rise to distinct optimization procedures: the former attempt to find a classification model, whereas the latter are solely concerned with obtaining label predictions for the given unlabelled data points. At the second level, it considers the way the semi-supervised learning methods incorporate unlabelled data. This distinction gives rise to three distinct classes of inductive methods, each of which is related to supervised classifiers in a different way.</p><p>The first distinction we make in our taxonomy, between inductive and transductive methods, is common in the literature on semi-supervised learning (see, e.g. <ref type="bibr" target="#b24">Chapelle et al. 2006b;</ref><ref type="bibr" target="#b206">Zhu 2008;</ref><ref type="bibr" target="#b210">Zhu and Goldberg 2009)</ref>. The former, like supervised learning methods, yield a classification model that can be used to predict the label of previously unseen data points. The latter do not yield such a model, but instead directly provide predictions. In other words, given a data set consisting of labelled and unlabelled data, X L , X U ⊆ X , with labels y L ∈ Y l for the l labelled data points, inductive methods yield a model f : X → Y, whereas transduc-tive methods produce predicted labels ŷU for the unlabelled data points in X U . Accordingly, inductive methods involve optimization over prediction models, whereas transductive methods optimize directly over the predictions ŷU .</p><p>Inductive methods, which generally extend supervised algorithms to include unlabelled data, are further differentiated in our taxonomy based on the way they incorporate unlabelled data: either in a preprocessing step, directly inside the objective function, or via a pseudolabelling step. The transductive methods are in all cases graph-based; we group these based on the choices made in different stages of the learning process. In the remainder of this section, we will elaborate on the grouping of semi-supervised learning methods represented in the taxonomy, which forms the basis for our discussion of semi-supervised learning methods in the remainder of this survey.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Inductive methods</head><p>Inductive methods aim to construct a classifier that can generate predictions for any object in the input space. Unlabelled data may be used when training this classifier, but the predictions for multiple new, previously unseen examples are independent of each other once training has been completed. This corresponds to the objective in supervised learning methods: a model is built in the training phase and can then be used for predicting the labels of new data points.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Wrapper methods</head><p>A simple approach to extending existing, supervised algorithms to the semi-supervised setting is to first train classifiers on labelled data, and to then use the predictions of the resulting classifiers to generate additional labelled data. The classifiers can then be re-trained on this pseudo-labelled data in addition to the existing labelled data. Such methods are known as wrapper methods: the unlabelled data is pseudo-labelled by a wrapper procedure, and a purely supervised learning algorithm, unaware of the distinction between originally labelled and pseudo-labelled data, constructs the final inductive classifier. This reveals a key property of wrapper methods: most of them can be applied to any given supervised base learner, allowing unlabelled data to be introduced in a straightforward manner. Wrapper methods form the first part of the inductive side of the taxonomy, and are covered in Sect. 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Unsupervised preprocessing</head><p>Secondly, we consider unsupervised preprocessing methods, which either extract useful features from the unlabelled data, pre-cluster the data, or determine the initial parameters of a supervised learning procedure in an unsupervised manner. Like wrapper methods, they can be used with any supervised classifier. However, unlike wrapper methods, the supervised classifier is only provided with originally labelled data points. These methods are covered in Sect. 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.3">Intrinsically semi-supervised methods</head><p>The last class of inductive methods we consider directly incorporate unlabelled data into the objective function or optimization procedure of the learning method. Many of these methods are direct extensions of supervised learning methods to the semi-supervised setting: they extend the objective function of the supervised classifier to include unlabelled data. Semisupervised support vector machines (S3VMs), for example, extend supervised SVMs by maximizing the margin not only on labelled, but also on unlabelled data. There are intrinsically semi-supervised extensions of many prominent supervised learning approaches, including SVMs, Gaussian processes and neural networks, and we describe these in Sect. 6. We further group the methods inside this category based on the semi-supervised learning assumptions on which they rely.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Transductive methods</head><p>Unlike inductive methods, transductive methods do not construct a classifier for the entire input space. Instead, their predictive power is limited to exactly those objects that it encounters during the training phase. Therefore, transductive methods have no distinct training and testing phases. Since supervised learning methods are by definition not supplied with unlabelled data until the testing phase, no clear analogies of transductive algorithms exist in supervised learning.</p><p>Since no model of the input space exists in transductive learners, information has to be propagated via direct connections between data points. This observation naturally gives rise to a graph-based approach to transductive methods: if a graph can be defined in which similar data points are connected, information can then be propagated along the edges of this graph. In practice, all transductive methods we discuss are either explicitly graph-based or can implicitly be understood as such. We note that inductive graph-based methods also exist; we cover them in Sect. 6.3. Inductive as well as transductive graph-based methods are typically premised on the manifold assumption: the graphs, constructed based on the local similarity between data points, provide a lower-dimensional representation of the potentially high-dimensional input data.</p><p>Transductive graph-based methods generally consist of three steps: graph construction, graph weighting and inference. In the first step, the set of objects, X , is used to construct a graph where each node represents a data point and pairwise similar data points are connected by an edge. In the second step, these edges are weighted to represent the extent of the pairwise similarity between the respective data points. In the third step, the graph is used to assign labels to the unlabelled data points. Different methods for carrying out these three steps are discussed in detail in Sect. 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Wrapper methods</head><p>Wrapper methods are among the oldest and most widely known algorithms for semisupervised learning <ref type="bibr" target="#b206">(Zhu 2008)</ref>. They utilize one or more supervised base learners and iteratively train these with the original labelled data as well as previously unlabelled data that is augmented with predictions from earlier iterations of the learners. The latter is commonly referred to as pseudo-labelled data. The procedure usually consists of two alternating steps of training and pseudo-labelling. In the training step, one or more supervised classifiers are trained on the labelled data and, possibly, pseudo-labelled data from previous iterations. In the pseudo-labelling step, the resulting classifiers are used to infer labels for the previously unlabelled objects; the data points for which the learners were most confident of their predictions are pseudo-labelled for use in the next iteration.</p><p>A significant advantage of wrapper methods is that they can be used with virtually any supervised base learner. The supervised base learner can be entirely unaware of the wrapper method, which simply passes pseudo-labelled samples to the base learner as if they were regular labelled samples. Although some wrapper methods require the base learner to provide probabilistic predictions, many wrapper methods relying on multiple base learners do not. For any particular wrapper method, the semi-supervised learning assumptions underlying it are dependent on the base learners that are used. In that sense, a wrapper method cannot be considered a learning method on its own: it only becomes a complete learning method when it is combined with a particular set of base learners.</p><p>A comprehensive survey of wrapper methods was published recently by <ref type="bibr" target="#b168">Triguero et al. (2015)</ref>. In addition to providing an overview of such methods, they also proposed a categorization and taxonomy of wrapper methods, which is based on (1) how many classifiers are used, (2) whether different types of classifiers are used, and (3) whether they use single-view or multi-view data (i.e. whether the data is split into multiple feature subsets). This taxonomy provides valuable insight into the space of wrapper methods.</p><p>We present a less complex taxonomy, focused on the three relatively independent types of wrapper methods that have been studied in the literature. Firstly, we consider self-training, which uses one supervised classifier that is iteratively re-trained on its own most confident predictions. Secondly, we consider co-training, an extension of self-training to multiple classifiers that are iteratively re-trained on each other's most confident predictions. The classifiers are supposed to be sufficiently diverse, which is usually achieved by operating on different subsets of the given objects or features. Lastly, we consider pseudo-labelled boosting methods. Like traditional boosting methods, they build a classifier ensemble by constructing individual classifiers sequentially, where each individual classifier is trained on both labelled data and the most confident predictions of the previous classifiers on unlabelled data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Self-training</head><p>Self-training methods (sometimes also called "self-learning" methods) are the most basic of pseudo-labelling approaches <ref type="bibr" target="#b168">(Triguero et al. 2015)</ref>. They consist of a single supervised classifier that is iteratively trained on both labelled data and data that has been pseudo-labelled in previous iterations of the algorithm.</p><p>At the beginning of the self-training procedure, a supervised classifier is trained on only the labelled data. The resulting classifier is used to obtain predictions for the unlabelled data points. Then, the most confident of these predictions are added to the labelled data set, and the supervised classifier is re-trained on both the original labelled data and the newly obtained pseudo-labelled data. This procedure is typically iterated until no more unlabelled data remain.</p><p>Self-training was first proposed by <ref type="bibr" target="#b194">Yarowsky (1995)</ref> as an approach to word sense disambiguation in text documents, predicting the meaning of words based on their context. Since then, several applications and variations of self-training have been put forward. For instance, <ref type="bibr" target="#b139">Rosenberg et al. (2005)</ref> applied self-training to object detection problems, and showed improved performance over a state-of-the-art (at that time) object detection model. <ref type="bibr" target="#b48">Dópido et al. (2013)</ref> developed a self-training approach for hyperspectral image classification. They used domain knowledge to select a set of candidate unlabelled samples, and pseudo-labelled the most informative of these samples with the predictions made by the trained classifier.</p><p>The self-training paradigm admits a multitude of design decisions, including the selection of data to pseudo-label, the re-use of pseudo-labelled data in later iterations of the algorithm, and stopping criteria (see, e.g. <ref type="bibr" target="#b139">Rosenberg et al. 2005;</ref><ref type="bibr" target="#b168">Triguero et al. 2015)</ref>. The selection procedure for data to be pseudo-labelled is of particular importance, since it determines which data end up in the training set for the classifier. In typical self-training settings, where this selection is made based on prediction confidence, the quality of the confidence estimates significantly influences algorithm performance. In particular, the ranking of prediction probabilities for the unlabelled samples should reflect the true confidence ranking.</p><p>If well-calibrated probabilistic predictions are available, the respective probabilities can be used directly. In this case, the self-training approach is iterative and not incremental, as label probabilities for unlabelled data points are re-estimated in each step. In that case, the approach becomes similar to expectation-maximization (EM; <ref type="bibr" target="#b44">Dempster et al. 1977)</ref>. It has been particularly well studied in the context of naïve Bayes classifiers, which are inherently probabilistic <ref type="bibr" target="#b117">(Nigam and Ghani 2000;</ref><ref type="bibr">Nigam et al. 2000</ref><ref type="bibr" target="#b118">Nigam et al. , 2006))</ref>. <ref type="bibr" target="#b188">Wu et al. (2012b)</ref> recently applied semi-supervised EM with a naïve Bayes classifier to the problem of detecting fake product reviews on e-commerce websites.</p><p>Algorithms that do not natively support robust probabilistic predictions may require adaptations to benefit from self-training. Decision trees are a prime example of this: without any modifications or pruning, prediction probability estimates, which are generally calculated from the fraction of samples in a leaf with a certain label, are generally of low quality. This can be mainly attributed to the fact that most decision tree learning algorithms explicitly attempt to minimize the impurity in tree nodes, thereby encouraging small leaves and highly biased probability estimates <ref type="bibr" target="#b133">(Provost and Domingos 2003)</ref>. <ref type="bibr" target="#b165">Tanha et al. (2017)</ref> attempted to overcome this problem in two distinct ways. Firstly, they applied several existing methods, such as grafting and Laplace correction, to directly improve prediction probability estimates. Secondly, they used a local distance-based measure to determine the confidence ranking between instances: the prediction confidence of an unlabelled data point is based on the absolute difference in the Mahalanobis distances between that point and the labelled data from each class. They showed improvements in performance of both decision trees and random forests (ensembles of decision trees) using this method <ref type="bibr" target="#b165">(Tanha et al. 2017)</ref>. <ref type="bibr" target="#b93">Leistner et al. (2009)</ref> also utilized self-training to improve random forests. Instead of labelling the unlabelled data x ∈ X U with the label predicted to be most likely, they pseudolabel each unlabelled data point independently for each tree according to the estimated posterior distribution p(y|x). Furthermore, they proposed a stopping criterion based on the out-of-bag-error: when the out-of-bag-error (which is an unbiased estimate of the generalization error) increases, training is stopped.</p><p>The base learners in self-training are by definition agnostic to the presence of the wrapper method. Consequently, they have to be completely re-trained in each self-training iteration. However, when a classifier can be trained incrementally (i.e. optimizing the objective function over individual data points or subsets of the given data), an iterative pseudo-labelling approach similar to self-training can be applied. Instead of re-training the entire algorithm in each iteration, data points can be pseudo-labelled throughout the training process. This approach was applied to neural networks by <ref type="bibr" target="#b92">Lee (2013)</ref>, who proposed the pseudo-label approach. Since the pseudo-labels predicted in the earlier training stages are generally less reliable, the weight of the pseudo-labelled data is increased over time. The pseudo-label approach exhibits clear similarities to self-training, but differs in the sense that the classifier is not re-trained after each pseudo-labelling step: instead, it is fine-tuned with new pseudo-labelled data, and therefore technically deviates from the wrapper method paradigm.</p><p>Limited studies regarding the theoretical properties of self-training algorithms exist. <ref type="bibr" target="#b69">Haffari and Sarkar (2007)</ref> performed a theoretical analysis of several variants of self-training and showed a connection with graph-based methods. <ref type="bibr" target="#b35">Culp and Michailidis (2008)</ref> analyzed the convergence properties of a variant of self-training with several base learners, and considered the connection to graph-based methods as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Co-training</head><p>Co-training is an extension of self-training to multiple supervised classifiers. In co-training, two or more supervised classifiers are iteratively trained on the labelled data, adding their most confident predictions to the labelled data set of the other supervised classifiers in each iteration. For co-training to succeed, it is important that the base learners are not too strongly correlated in their predictions. If they are, their potential to provide each other with useful information is limited. In the literature, this condition is usually referred to as the diversity criterion <ref type="bibr" target="#b183">(Wang and Zhou 2010)</ref>. <ref type="bibr" target="#b205">Zhou and Li (2010)</ref> provided a survey of semi-supervised learning methods relying on multiple base learners. They jointly refer to these methods as disagreement-based methods, referring to the observation that co-training approaches exploit disagreements between multiple learners: they exchange information through unlabelled data, for which different learners predict different labels.</p><p>To promote classifier diversity, earlier co-training approaches mainly relied on the existence of multiple different views of the data, which generally correspond to distinct subsets of the feature set. For instance, when handling video data, the data can be naturally decomposed into visual and audio data. Such co-training methods belong to the broader class of multiview learning approaches, which includes a broad range of supervised learning algorithms as well. A comprehensive survey of multi-view learning was produced by <ref type="bibr" target="#b189">Xu et al. (2013)</ref>. We cover multi-view co-training methods in Sect. 4.2.1. In many real-world problem scenarios, no distinct views of the data are known a priori. Single-view co-training methods address this problem either by automatically splitting the data into different views, or by promoting diversity in the learning algorithms themselves; we cover these methods in Sect. 4.2.2. We also briefly discuss co-regularization methods, in which multiple classifiers are combined into a single objective function, in Sect. 4.2.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Multi-view co-training</head><p>The basic form of co-training was proposed by <ref type="bibr" target="#b21">Blum and Mitchell (1998)</ref>. In their seminal paper, they proposed to construct two classifiers that are trained on two distinct views, i.e. subsets of features, of the given data. After each training step, the most confident predictions for each view are added to the set of labelled data for the other view. Blum and Mitchell applied the co-training algorithm to the classification for university web pages, using the web page text and the anchor text in links to the web page from external sources as two distinct views. This algorithm and variants thereof have been successfully applied in several fields, most notably natural language processing <ref type="bibr" target="#b83">(Kiritchenko and Matwin 2001;</ref><ref type="bibr" target="#b112">Mihalcea 2004;</ref><ref type="bibr" target="#b176">Wan 2009)</ref>.</p><p>The original co-training algorithm by <ref type="bibr" target="#b21">Blum and Mitchell (1998)</ref> relies on two main assumptions to succeed: (1) each individual subset of features should be sufficient to obtain good predictions on the given data set, and (2) the subsets of features should be conditionally independent given the class label. The first assumption can be understood trivially: if one of the two feature subsets is insufficient to form good predictions, a classifier using that set can never contribute positively to the overall performance of the combined approach. The second assumption is related to the diversity criterion: if the feature subsets are conditionally independent given the class label, the predictions of the individual classifiers are unlikely to be strongly correlated. Formally, for any data point</p><formula xml:id="formula_0">x i = x (1) i × x (2) i , decomposed into x (1)</formula><p>i and x</p><p>(2) i for the first and second feature subset, respectively, the conditional independence assumption amounts to p(x <ref type="bibr" target="#b39">Dasgupta et al. (2002)</ref> showed that, under the previously mentioned assumptions, generalization error can be decreased by promoting agreement among the individual learners.</p><formula xml:id="formula_1">(1) i |x (2) i , y i ) = p(x (1) i |y i ).</formula><p>In practice, the second assumption is generally not satisfied: even if a natural split of features exists, such as in the experimental setup used by <ref type="bibr" target="#b21">Blum and Mitchell (1998)</ref>, it is unlikely that information contained in one view provides no information about the other view when conditioned on the class label <ref type="bibr" target="#b49">(Du et al. 2011)</ref>. Considering the university web page classification example, the anchor text of a link to a web page can indeed be expected to contain clues towards the content of the web page, even if it is known that the web page is classified as a faculty member's home page. For example, if the link's anchor text is "Dean of the Engineering Faculty", one is more likely to find information about the dean of the engineering faculty than about any other person in the text of that page. Thus, several alternatives to this assumption have been considered. <ref type="bibr" target="#b1">Abney (2002)</ref> showed that a weak independence assumption is sufficient for successful co-training. <ref type="bibr" target="#b6">Balcan et al. (2005)</ref> further relaxed the conditional independence assumption, showing that a much weaker assumption, which they dub the expansion assumption, is sufficient and to some extent necessary. The expansion assumption states that the two views are not highly correlated, and that individual classifiers never confidently make incorrect predictions. <ref type="bibr" target="#b49">Du et al. (2011)</ref> studied empirical methods to determine to what degree the sufficiency and independence assumptions hold. They proposed several methods for automatically splitting the feature set into two views, and showed that the resulting empirical independence and sufficiency is positively correlated with the performance of the co-trained algorithm, indicating that feature splits optimizing sufficiency and independence lead to good classifiers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Single-view co-training</head><p>As shown by <ref type="bibr" target="#b49">Du et al. (2011)</ref>, co-training can be successful even when no natural split in a given feature set is known a priori. This observation is echoed throughout the literature on cotraining, and many different approaches to applying co-training in this so-called single-view setting exist. <ref type="bibr">Chen et al. (2011)</ref> attempted to alleviate the need for pre-defined disjoint feature sets by automatically splitting the feature set in each co-training iteration. They formulated a single optimization problem closely related to co-training, incorporating both the requirement that the feature sets should be disjoint and the expansion property of <ref type="bibr" target="#b6">Balcan et al. (2005)</ref>. They showed promising results for this approach on a partially synthetic data set, where multiple views of each data point are automatically generated. <ref type="bibr" target="#b183">Wang and Zhou (2010)</ref> reasoned about sufficient and necessary conditions for co-training to succeed, approaching co-training from a graph-based perspective, where label propagation is alternately applied to each learner. A downside of this approach is that, although inspired by co-training, it cannot be applied to an arbitrary supervised learning algorithm without modification: the operations resembling co-training are embedded in the objective function, which is optimized directly.</p><p>Several techniques have been proposed for splitting single-view data sets into multiple views. For instance, <ref type="bibr" target="#b181">Wang et al. (2008b)</ref> suggested to generate k random projections of the data, and use these as the views for k different classifiers. <ref type="bibr" target="#b199">Zhang and Zheng (2009)</ref> proposed to project the data onto a lower-dimensional subspace using principal component analysis and to construct the pseudo-views by greedily selecting the transformed features with maximal variance. <ref type="bibr" target="#b195">Yaslan and Cataltepe (2010)</ref> do not transform the data to a different basis, but select the features for each view iteratively, with preference given to features with high mutual information with respect to the given labels.</p><p>Further approaches to apply algorithms resembling co-training to data sets where no explicit views are available focus on other ways of introducing diversity among the classifiers. For example, one can use different hyperparameters for the supervised algorithms <ref type="bibr" target="#b182">(Wang and Zhou 2007;</ref><ref type="bibr" target="#b203">Zhou and Li 2005a)</ref>, or use different algorithms altogether <ref type="bibr" target="#b59">(Goldman and Zhou 2000;</ref><ref type="bibr" target="#b190">Xu et al. 2012;</ref><ref type="bibr" target="#b201">Zhou and Goldman 2004)</ref>. <ref type="bibr" target="#b182">Wang and Zhou (2007)</ref> provided both theoretical and empirical analyses on why co-training can work in single-view settings. They showed that the diversity between the learners is positively correlated with their joint performance. <ref type="bibr" target="#b204">Zhou and Li (2005b)</ref> proposed tri-training, where three classifiers are alternately trained. When two of the three classifiers agree on their prediction for a given data point, that data point is passed to the other classifier along with the respective label. Crucially, tri-training does not rely on probabilistic predictions of individual classifiers, and can thus be applied to a much broader range of supervised learning algorithms.</p><p>The authors of the tri-training approach proposed to extend it to more than three learnersnotably, to random forests <ref type="bibr" target="#b96">(Li and Zhou 2007)</ref>. The approach, known as co-forest, starts by training the decision trees independently on all labelled data. Then, in each iteration, each classifier receives pseudo-labelled data based on the joint prediction of all other classifiers on the unlabelled data: if the fraction of classifiers predicting a class ŷi for an unlabelled data point x i exceeds a certain threshold, the pseudo-labelled data point (x i , y i ) is passed to the classifier. The decision trees are then all re-trained on their labelled and pseudo-labelled data. In the next iteration, all previously pseudo-labelled data is treated as unlabelled again. We note that, as the number of trees approaches infinity, this approach becomes a form of self-training.</p><p>Co-forest includes a mechanism for reducing the influence of possibly mislabelled data points in the pseudo-labelling step by weighting the newly labelled data based on prediction confidence. <ref type="bibr" target="#b45">Deng and Zu Guo (2011)</ref> attempted to further prevent the influence of possibly mislabelled data points by removing "suspicious" pseudo-labellings. After each pseudo-labelling step, the prediction for each pseudo-labelled data point x i is compared to the (pseudo-)labels of its k nearest neighbours (both labelled and pseudo-labelled); in case of a mismatch, the pseudo-label is removed from x i .</p><p>We note that in existing literature concerning co-forest, the size of the forest has always been limited to six trees. It has been empirically shown that, in supervised random forests, performance can substantially improve as the number of trees is increased <ref type="bibr" target="#b123">(Oshiro et al. 2012)</ref>. Therefore, it is likely that increasing the number of trees in co-forest will substantially affect relative performance compared to random forests.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Co-regularization</head><p>Co-training methods reduce disagreement between classifiers by passing information between them, in the form of pseudo-labelled data. Furthermore, the implicit objective of cotraining is to minimize the error rate of the ensemble of classifiers. <ref type="bibr">Sindhwani et al. proposed</ref> to make these properties explicit in a single objective function <ref type="bibr" target="#b147">(Sindhwani et al. 2005;</ref><ref type="bibr" target="#b148">Sindhwani and Rosenberg 2008)</ref>. They propose co-regularization, a regularization framework in which both the ensemble quality and the disagreement between base learners are simultaneously optimized. The key idea is to use an objective function comprised of two terms: one that penalizes incorrect predictions made by the ensemble, and another that directly penalizes different predictions of the base classifiers. To handle per-view noise within this framework, <ref type="bibr" target="#b196">Yu et al. (2011)</ref> introduced Bayesian co-training, which uses a graphical model for combining data from multiple views and a kernel-based method for co-regularization. This model was extended to handle different noise levels per data point by <ref type="bibr" target="#b29">Christoudias et al. (2009)</ref>.</p><p>Co-training can be seen as a greedy optimization strategy for the co-regularization objective. The two components of the objective function are minimized in an alternating fashion: the prediction error of the ensemble is minimized by training the base learners independently, and the disagreement between classifiers is minimized by propagating predictions from one classifier to the others as if they were ground truth. We note, however, that the general coregularization objective does not have to be optimized using a wrapper method, and many co-regularization algorithms use different approaches (see, e.g. <ref type="bibr" target="#b148">Sindhwani and Rosenberg 2008;</ref><ref type="bibr" target="#b196">Yu et al. 2011)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Boosting</head><p>Ensemble classifiers consist of multiple base classifiers, which are trained and then used to form combined predictions <ref type="bibr" target="#b202">(Zhou 2012)</ref>. The simplest form of ensemble learning trains k base classifiers independently and aggregates their predictions. Beyond this simplistic approach, two main branches of supervised ensemble learning exist: bagging and boosting <ref type="bibr" target="#b202">(Zhou 2012)</ref>. In bagging methods, each base learner is provided with a set of l data points, which are sampled, uniformly at random with replacement, from the original data set (bootstrapping). The base classifiers are trained independently. When training is completed, their outputs are aggregated to form the prediction of the ensemble. In boosting methods, on the other hand, each base learner is dependent on the previous base learners: it is provided with the full data set, but with weights applied to the data points. The weight of a data point x i is based on the performance of the previous base learners on x i , such that larger weights get assigned to data points that were incorrectly classified. The final prediction is obtained as a linear combination of the predictions of the base classifiers.</p><p>Technically, boosting methods construct a weighted ensemble of classifiers h t in a greedy fashion. Let</p><formula xml:id="formula_2">F T −1 (x) = T −1 t=1 α t • h t (x)</formula><p>denote the ensemble of classifiers h t with weight α t at time T − 1. Furthermore, let ( ŷ, y) denote the loss function for predicting label ŷ for a data point with true label y. In each iteration of the algorithm, an additional classifier h T is added to the ensemble with a certain weight α T , such that the cost function</p><formula xml:id="formula_3">L(F T ) = l i=1 (F T (x i ), y i ) = l i=1 (F T −1 (x i ) + α T • h T (x i ), y i )</formula><p>is minimized. Note that, at time T , the ensemble F T −1 is fixed. With particular choices of loss functions, such as ( ŷ, y) = exp(− ŷ • y), the optimization problem yields a weighted classification problem for determining h T , and allows us to express the optimal α T in terms of the loss of h T on the training data.</p><p>By definition, base learners in bagging methods are trained independently. Therefore, the only truly semi-supervised bagging method would apply self-training to individual base learners. Co-training, however, can be seen to be closely related to bagging methods: the only way classifiers interact is by the exchange of pseudo-labelled data; other than that, the classifiers can be trained independently and simultaneously. However, most co-training methods do not use bootstrapping, a defining characteristic of bagging methods. In boosting, on the other hand, there is an inherent dependency between base learners. Consequently, boosting methods can be readily extended to the semi-supervised setting, by introducing pseudo-labelled data after each learning step; this idea gives rise to the class of semi-supervised boosting methods.</p><p>Semi-supervised boosting methods have been studied extensively over the past two decades. The success achieved by supervised boosting methods, such as AdaBoost <ref type="bibr" target="#b56">(Freund and Schapire 1997)</ref>, gradient boosting, and XGBoost (Chen and Guestrin 2016), provides ample motivation for bringing boosting to the semi-supervised setting. Furthermore, the pseudo-labelling approach of self-training and co-training can be easily extended to boosting methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">SSMBoost</head><p>The first effort towards semi-supervised boosting methods was made by <ref type="bibr">Grandvalet et al., who extended</ref> AdaBoost to the semi-supervised setting. They proposed a semi-supervised boosting algorithm <ref type="bibr" target="#b65">(Grandvalet et al. 2001)</ref>, which they later extended and motivated from the perspective of gradient boosting (d'Alché <ref type="bibr" target="#b37">Buc et al. 2002)</ref>. A loss function is defined for unlabelled data, based on the predictions of the current ensemble and on the predictions of the base learner under construction. Experiments were conducted with multiple loss functions; the authors reported the strongest results using the expected loss of the new, combined classifier. The weighted error t for base classifier h t is thus adapted to include the unlabelled data points, causing the weight term α t to depend on the unlabelled data as well.</p><p>Crucially, SSMBoost does not assign pseudo-labels to the unlabelled data points. As a result, it requires semi-supervised base learners to make use of the unlabelled data and is therefore intrinsically semi-supervised, in contrast to most other semi-supervised boosting algorithms, which are wrapper methods. Nevertheless, SSMBoost is included here, because it forms the foundation for all other forms of semi-supervised boosting algorithms, which do not require semi-supervised base learners.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2">ASSEMBLE</head><p>The ASSEMBLE algorithm, short for Adaptive Supervised Ensemble, pseudo-labels the unlabelled data points after each iteration, and uses these pseudo-labelled data points in the construction of the next classifier, thus alleviating the need for semi-supervised base learners <ref type="bibr" target="#b16">(Bennett et al. 2002)</ref>. As shown by its authors, ASSEMBLE effectively maximizes the classification margin in function space.</p><p>Since pseudo-labels are used in ASSEMBLE, it is not trivial to decide which unlabelled data points to pass to the next base learner. <ref type="bibr" target="#b16">Bennett et al. (2002)</ref> proposed to use bootstrapping-i.e. sampling, uniformly at random, with replacement, l data points from the l + u labelled and unlabelled data points.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.3">SemiBoost</head><p>The semi-supervised boosting algorithm SemiBoost addresses the problem of selecting data points to be used by the base learners by relying on the manifold assumption, utilizing principles from graph-based methods <ref type="bibr" target="#b110">(Mallapragada et al. 2009)</ref>. Each unlabelled data point is assigned a pseudo-label, and the corresponding prediction confidence is calculated based on a predefined neighbourhood graph that encodes similarity between data points. Then, a subset of these pseudo-labelled data points is added to the set of labelled data points for training the next base learner. The probability of a sample being selected for this subset is proportional to its prediction confidence. SemiBoost was successfully applied to object tracking in videos by <ref type="bibr" target="#b63">Grabner et al. (2008)</ref>.</p><p>SemiBoost uses the standard boosting classification model, expressing the final label prediction as a linear combination of the predictions of the individual learners. Its cost function, however, is highly dissimilar from the previously described semi-supervised boosting methods. <ref type="bibr" target="#b110">Mallapragada et al. (2009)</ref> argue that a successful labelling of the test data should conform to the following three requirements. Firstly, the predicted labels of the unlabelled data should be consistent for unlabelled data points that are close to each other. Secondly, the predicted labels of the unlabelled data should be consistent with the labels of nearby labelled data points. And, thirdly, the predicted labels for the labelled data points should correspond to their true labels. These requirements are expressed in the form of a constrained optimization problem, where the first two are captured by the objective function, and the last is imposed as a constraint. In other words, the SemiBoost algorithm uses boosting to solve the optimization problem minimize</p><formula xml:id="formula_4">F T L L (ŷ, A, F T ) + λ • L U (ŷ, A, F T ) subject to ŷi = y i , i = 1, . . . , l,<label>(1)</label></formula><p>where L U and L L are the cost functions expressing the inconsistency across the unlabelled and the combined labelled and unlabelled data, respectively, and λ ∈ R is a constant governing the relative weight of the cost terms; A is an n × n symmetric matrix denoting the pairwise similarities between data points. Lastly, F T denotes the joint prediction function of the ensemble of classifiers at time T . We note that the optimization objective in Eq. 1 is very similar to the cost functions encountered in graph-based methods (see Sects. 6.3 and 7) in that it favours classifiers that consistently label data points on the same manifold. In graphbased methods, however, no distinction is generally made between labelled-unlabelled and unlabelled-unlabelled pairs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.4">Other semi-supervised boosting methods</head><p>The three previously discussed methods form the core of semi-supervised boosting research. Further work in the area includes RegBoost, which, like SemiBoost, includes local label consistency in its objective function <ref type="bibr" target="#b26">(Chen and Wang 2011)</ref>. In RegBoost, this term is also dependent on the estimated local density of the marginal distribution p(x). Several attempts have been made to extend the label consistency regularization to the multiclass setting <ref type="bibr" target="#b164">(Tanha et al. 2012;</ref><ref type="bibr" target="#b171">Valizadegan et al. 2008)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Unsupervised preprocessing</head><p>We now turn to a second category of inductive methods, known as as unsupervised preprocessing, which, unlike wrapper methods and intrinsically semi-supervised methods, use the unlabelled data and labelled data in two separate stages. Typically, the unsupervised stage comprises either the automated extraction or transformation of sample features from the unlabelled data (feature extraction), the unsupervised clustering of the data (cluster-then-label), or the initialization of the parameters of the learning procedure (pre-training).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Feature extraction</head><p>Since the early days of machine learning, feature extraction has played an important role in the construction of classifiers. Feature extraction methods attempt to find a transformation of the input data such that the performance of the classifier improves or such that its construction becomes computationally more efficient. Feature extraction is an expansive research topic that has been covered by several books and surveys. We focus on a small number of particularly prominent techniques and refer the reader to the existing literature on feature extraction methods for further information (see, e.g. <ref type="bibr" target="#b68">Guyon and Elisseeff 2006;</ref><ref type="bibr" target="#b145">Sheikhpour et al. 2017)</ref>.</p><p>Many feature extraction methods operate without supervision, i.e. without taking into account labels. Principal component analysis, for example, transforms the input data to a different basis, such that they are linearly uncorrelated, and orders the principal components based on their variance <ref type="bibr" target="#b185">(Wold et al. 1987)</ref>. Other traditional feature extraction algorithms operate on the labelled data and try to extract features with high predictive power (see, e.g.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Guyon and Elisseeff 2006).</head><p>Recent semi-supervised feature extraction methods have mainly been focused on finding latent representations of the input data using deep neural networks (in Sect. 6.2.1, we further discuss neural networks). The most prominent example of this is the autoencoder: a neural network with one or more hidden layers that has the objective of reconstructing its input. By including a hidden layer with relatively few nodes, usually called the representation layer, the network is forced to find a way to compactly represent its input data. Once the network is trained, features are provided by the representation layer. A schematic representation of a standard autoencoder is provided in Fig. <ref type="figure" target="#fig_0">4</ref>.</p><p>The network can be considered to consist of two parts: the encoder h, which maps an input vector x to its latent representation h(x), and the decoder g, which attempts to map the latent representation back to the original x. The network is trained by optimizing a loss function penalizing the reconstruction error: a measure of inconsistency between the input x and the corresponding reconstruction g(h(x)). Once the network is trained, the latent representation of any x can be found by simply propagating it through the encoder part of the network to obtain h(x). A popular type of autoencoders is the denoising autoencoder, which is trained on noisy versions of the input data, penalizing the reconstruction error of the reconstructions against the noiseless originals <ref type="bibr" target="#b174">(Vincent et al. 2008)</ref>. Another variant, the contractive autoencoder, directly penalizes the sensitivity of the autoencoder to perturbations in the input <ref type="bibr" target="#b138">(Rifai et al. 2011b)</ref>.</p><p>Autoencoders attempt to find a lower-dimensional representation of the input space without sacrificing substantial amounts of information. Thus, they inherently act on the assumption that the input space contains lower-dimensional substructures on which the data lie. Furthermore, when applied as a preprocessing step to classification, they assume that two samples on the same lower-dimensional substructure have the same label. These obser-. . . . . . . . . In some domains, data is not inherently represented as a meaningful feature vector. Since many common classification methods require such a representation, feature extraction is a necessity in those cases. The feature extraction step, then, consists of finding an embedding of the given object into a vector space by taking into account the relations between different input objects. Examples of such approaches can be found in natural language processing <ref type="bibr" target="#b31">(Collobert et al. 2011;</ref><ref type="bibr" target="#b113">Mikolov et al. 2013</ref>) and network science <ref type="bibr" target="#b67">(Grover and Leskovec 2016;</ref><ref type="bibr" target="#b128">Perozzi et al. 2014;</ref><ref type="bibr" target="#b177">Wang et al. 2016)</ref>.</p><formula xml:id="formula_5">Encoder h(•) Decoder g(•) x h(x) g(h(x))</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Cluster-then-label</head><p>Clustering and classification have traditionally been regarded as relatively disjoint research areas. However, many semi-supervised learning algorithms use principles from clustering to guide the classification process. Cluster-then-label approaches form a group of methods that explicitly join the clustering and classification processes: they first apply an unsupervised or semi-supervised clustering algorithm to all available data, and use the resulting clusters to guide the classification process. <ref type="bibr" target="#b58">Goldberg et al. (2009)</ref> first cluster the labelled data and a subset of the unlabelled data. A classifier is then trained independently for each cluster on the labelled data contained in it. Finally, the unlabelled data points are classified using the classifiers for their respective clusters. In the clustering step, a graph is constructed over the data points using the Hellinger distance; size-constrained spectral clustering is then applied to the resulting graph. Since the clustering is only used to segment the data, after which individual learners are applied to each cluster, the approach supports any supervised base learner. <ref type="bibr" target="#b43">Demiriz et al. (1999)</ref> first cluster the data in a semi-supervised manner, favouring clusters with limited label impurity (i.e. a high degree of consistency in the labels of the data points within a given cluster), and use the resulting clusters in classification. <ref type="bibr" target="#b38">Dara et al. (2002)</ref> proposed a more elaborate preprocessing step, applying self-organizing maps <ref type="bibr" target="#b84">(Kohonen 1998)</ref> to the labelled data in an iterative fashion. The unlabelled data points are then mapped, yielding a cluster assignment for each of them. If the cluster to which an unlabelled data point x i is mapped contains only data points with the same label, that label is also assigned to x i . This process can be iterated, after which the resulting label assignments can be used to train an inductive classifier (in the work of <ref type="bibr">Dara et al., a multilayer perceptron)</ref>. We note that this approach can be regarded as a wrapper method (see Sect. 4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Pre-training</head><p>In pre-training methods, unlabelled data is used to guide the decision boundary towards potentially interesting regions before applying supervised training.</p><p>This approach naturally applies to deep learning methods, where each layer of the hierarchical model can be considered a latent representation of the input data. The most commonly known algorithms corresponding to this paradigm are deep belief networks and stacked autoencoders. Both methods are based on artificial neural networks and aim to guide the parameters (weights) of a network towards interesting regions in model space using the unlabelled data, before fine-tuning the parameters with the labelled data.</p><p>Pre-training approaches have deep roots in the field of deep learning. Since the early 2000s, neural networks with multiple hidden layers (deep neural networks) have been gaining an increasing amount of attention. However, due to their high number of tunable parameters, training these networks has often been challenging: convergence tended to be slow, and trained networks were prone to poor generalization <ref type="bibr" target="#b54">(Erhan et al. 2010)</ref>. Early on, these problems were commonly addressed by employing unsupervised pre-training methods. Since then, this has been mostly superseded by the application of weight sharing, regularization methods and different activation functions. Consequently, the work we cover in this section mainly stems from the first decade of the 2000s. However, the underlying principles still apply, and are still used in other methods (such as ladder networks, see Sect. 6.2.2).</p><p>Deep belief networks consist of multiple stacked restricted Boltzmann machines (RBMs), which are trained layer-by-layer with unlabelled data in a greedy fashion <ref type="bibr" target="#b73">(Hinton et al. 2006)</ref>. The resulting weights are then used as the initialization for a deep neural network with the same architecture augmented by an additional output layer, enabling the model to be trained in a supervised manner on the labelled data.</p><p>Stacked autoencoders are very similar to deep belief networks, but they use autoencoders as their base models instead of RBMs. The autoencoders are trained layer-by-layer, where the encoding h(x) produced by each autoencoder is passed as the input to the next autoencoder, which is then trained to reconstruct it with minimal error. Finally, these trained autoencoders are combined, an output layer is added (as in deep belief networks), and the resulting network is trained on the labelled data in a supervised manner. The paradigm works with multiple types of autoencoders, including denoising and contractive autoencoders <ref type="bibr" target="#b174">(Vincent et al. 2008;</ref><ref type="bibr" target="#b138">Rifai et al. 2011b)</ref>.</p><p>Based on an empirical analysis of deep belief networks and stacked autoencoders, <ref type="bibr" target="#b54">Erhan et al. (2010)</ref> suggested that unsupervised pre-training guides the neural network model towards regions in model space that provide better generalization. Deep neural networks are often motivated from the perspective that they learn a higher-level representation of the data at each layer. Thus, each layer of the network can be considered to contain a different representation of the input data. Both deep belief networks and stacked autoencoders attempt to guide the model in the extraction of these hierarchical representations, pushing the model towards the extraction of representations that are deemed informative. From that perspective, pre-training methods are closely related to the unsupervised feature extraction methods described earlier: they both use unlabelled data in an attempt to extract meaningful information from the input data. Crucially, however, the parameters used for unsupervised preprocessing can be changed in the supervised fine-tuning phase of pre-training methods, whereas they remain fixed after the unsupervised phase of feature extraction approaches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Intrinsically semi-supervised methods</head><p>We now turn our attention to inductive learning algorithms that directly optimize an objective function with components for labelled and unlabelled samples. These methods, which we call intrinsically semi-supervised, do not rely on any intermediate steps or supervised base learners. Usually, they are extensions of existing supervised methods to include unlabelled samples in the objective function.</p><p>Generally, these methods rely either explicitly or implicitly on one of the semi-supervised learning assumptions (see Sect. 2.1). For instance, maximum-margin methods rely on the low-density assumption, and most semi-supervised neural networks rely on the smoothness assumption. We begin with an overview of the earliest intrinsically semi-supervised classification methods, namely maximum-margin methods. Next, we discuss perturbationbased methods, which directly incorporate the smoothness assumption. These encompass most semi-supervised neural networks. Then, we consider manifold-based techniques, which either explicitly or implicitly approximate the manifolds on which the data lie. Finally, we consider generative models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Maximum-margin methods</head><p>Maximum-margin classifiers attempt to maximize the distance between the given data points and the decision boundary. This approach corresponds to the semi-supervised low-density assumption: when the margin between all data points and the decision boundary is large (except for some outliers), the decision boundary must be in a low-density area <ref type="bibr" target="#b13">(Ben-David et al. 2009</ref>). Conceptually, maximum-margin methods thus lend themselves well to extension to the semi-supervised setting: one can incorporate knowledge from the unlabelled data to determine where the density is low and thus, where a large margin can be achieved.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.1">Support vector machines</head><p>The most prominent example of a supervised maximum-margin classifier is the support vector machine (SVM): a classification method that attempts to maximize the distance from the decision boundary to the points closest to it, while encouraging data points to be classified correctly. It was one of the first maximum-margin approaches to be proposed in the semisupervised setting, and it has been studied extensively since. We briefly introduce supervised SVMs, but the reader to machine learning book by <ref type="bibr" target="#b18">Bishop (2006)</ref> for a more extensive introduction.</p><p>The objective of an SVM is to find a decision boundary that maximizes the margin, which is defined as the distance between the decision boundary and the data points closest to it. The term is also commonly used to describe the area extruding from the decision boundary in which no data points lie. The soft-margin SVM is a popular variant of SVMs that allows data points to violate the margin (i.e. lie between the corresponding margin boundary and the decision boundary, or even be misclassified) at a certain cost. SVMs supports implicit mapping of objects to higher-dimensional feature spaces using the so-called kernel trick.</p><p>Formally, when training an SVM, we endeavour to find a weight vector w ∈ R d with minimal magnitude and a bias variable b ∈ R, such that y i • (w</p><formula xml:id="formula_6">• x i + b) ≥ 1 − ξ i for all data points x i ∈ X L .</formula><p>Here, ξ i ≥ 0 is called the "slack variable" for x i , which allows x i to violate the margin at some cost, which is incorporated into the objective function. The corresponding optimization problem can be formulated as follows: minimize w,b,ξ</p><formula xml:id="formula_7">1 2 • ||w|| 2 + C • l i=1 ξ i subject to y i • (w • x i + b) ≥ 1 − ξ i , i = 1, . . . , l, ξ ≥ 0, i = 1, . . . , l,</formula><p>where C ∈ R is a constant scaling factor for the penalization of data points violating the margin. If C is large, the optimal margin will generally be narrow, and if C is small, the optimal margin will generally be wide. Thus, C acts as a regularization parameter, governing the trade-off between the complexity of the decision boundary and prediction accuracy on the training set.</p><p>The concept of semi-supervised SVMs, or S3VMs, is similar: we want to maximize the margin, and we want to correctly classify the labelled data. However, in the semi-supervised setting, an additional objective becomes relevant: we also want to minimize the number of unlabelled data points that violate the margin. Since the labels of the unlabelled data points are unknown, those that violate (i.e. lie within) the margin are penalized based on their distance to the closest margin boundary.</p><p>The intuitive extension of the optimization problem for S3VMs thus becomes minimize w,b,ξ</p><formula xml:id="formula_8">1 2 • ||w|| 2 + C • l i=1 ξ i + C • n i=l+1 ξ i subject to y i • (w • x i + b) ≥ 1 − ξ i , i = 1, . . . , l, |w • x i + b| ≥ 1 − ξ i , i = l + 1, . . . , n, ξ i ≥ 0, i = 1, . . . , n,<label>(2)</label></formula><p>where C ∈ R is the margin violation cost associated with unlabelled data points. S3VMs were proposed by Vapnik (1998), who motivated the problem from a more transductive viewpoint: instead of optimizing only over the weight vector, bias and slack variables, he proposed to also optimize over the label predictions ŷU . The constraint for the unlabelled data was formulated similarly to that for labelled data, but with the predicted labels ŷU . Though different at first sight, this formulation is equivalent to optimization problem 2 above, since any labelling ŷU can only be optimal if, for each ŷi ∈ ŷU , x i is on the correct side of the decision boundary (i.e. ŷi • (w • x i + b) ≥ 0). Otherwise, a better solution could be obtained by simply inverting the labelling of x i .</p><p>The extension of SVMs to the semi-supervised setting carries one significant disadvantage: the optimization problem encountered when training S3VMs becomes non-convex and NPhard. Consequently, most efforts in the study of S3VMs have been focused on training them efficiently in practice.</p><p>Initial efforts showed promising results in applying S3VMs, but only to small data sets. For instance, <ref type="bibr" target="#b15">Bennett and Demiriz (1999)</ref> proposed to use the L1 norm instead of the L2 norm in the objective function and posed the problem as a mixed integer programming problem. The earliest widely used optimization approach was introduced by Joachims (1999), whose approach for solving the optimization problem starts with a random assignment of ŷU and a low value for C . Each iteration of the algorithm then consists of three steps. First, the supervised SVM optimization problem corresponding to the current label assignment ŷU is solved. Next, the algorithm inverts the labels of each pair of data points for which this inversion improves the objective function, until no more such pairs exist. Finally, C is increased. The algorithm terminates when C reaches a predefined value specified by the user.</p><p>Other approaches to solving S3VMs have been put forward. For instance, several studies have proposed convex relaxations of the objective function, which can be solved using semidefinite programming methods. The earliest such approach was introduced by de Bie and <ref type="bibr" target="#b40">Cristianini (2004</ref><ref type="bibr" target="#b41">Cristianini ( , 2006) )</ref> and later extended to the multiclass setting by <ref type="bibr" target="#b191">Xu and Schuurmans (2005)</ref>. However, due to their time complexity, these approaches do not scale to large amounts of data. <ref type="bibr" target="#b24">Chapelle et al. (2008)</ref> provided an overview of optimization procedures for S3VMs up until 2008 and broadly categorize S3VM optimization methods into two categories: combinatorial methods, finding the label assignment ŷU that minimizes the objective function, and continuous methods, directly solving the optimization problem using label assignments ŷi = sign(w •x i +b). All the approaches we have thus far described fall into the combinatorial category. However, the formulation in optimization problem 2 corresponds to the continuous approach; it underlies, for example, the concave-convex procedure, which decomposes the non-convex objective function into a convex and a concave component, and iteratively solves the optimization problem by replacing the concave component with a linear approximation at the current solution <ref type="bibr" target="#b24">(Chapelle et al. 2008;</ref><ref type="bibr" target="#b30">Collobert et al. 2006)</ref>.</p><p>Other continuous methods make use of the fact that problem 2 can be reformulated as an optimization problem without constraints. This stems from the fact that, if a labelled point x i ∈ X L does not violate the margin, then ξ i = 0 in the optimal solution. If it does violate the margin, then</p><formula xml:id="formula_9">ξ i = 1 − y i • (w • x i + b).</formula><p>For an unlabelled data point x i ∈ X U , ξ i = 0 if it does not violate the margin, and otherwise, ξ i = 1 − |w • x i + b|. Thus, the optimization problem can be reformulated as minimize</p><formula xml:id="formula_10">w,b 1 2 • ||w|| 2 + C • l i=1 max (0, 1 − y i • f (x i )) + C • n i=l+1 max (0, 1 − | f (x i )|) ,<label>(3)</label></formula><p>where f</p><formula xml:id="formula_11">(x i ) = w • x i + b.</formula><p>This approach underlies ∇TSVM by <ref type="bibr" target="#b25">Chapelle and Zien (2005)</ref>, which is based on a smooth approximation of the object function in Eq. 3 obtained by squaring the loss for the labelled data points, and by approximating the loss for the unlabelled data points with an exponential function. This optimization problem is then solved by gradient descent, where C is gradually increased from some value close to zero to its intended value. <ref type="bibr" target="#b23">Chapelle et al. (2006a)</ref> take a similar approach, where they keep C fixed and use a continuous approach to transform the objective function from using only the labelled data to the final objective function.</p><p>As is the case for most semi-supervised learning methods, S3VMs are not guaranteed to perform better than their supervised counterparts <ref type="bibr" target="#b149">(Singh et al. 2009)</ref>. Specifically, if one of the underlying assumptions of the semi-supervised learning method is violated, there is a large risk of degrading performance when introducing the unsupervised objective. In the case of S3VMs, many highly diverse decision boundaries may exist that pass through a low-density area and achieve reasonable classification performance on the labelled data. Consequently, one can expect the generalization performance of such classifiers to exhibit significant variance. <ref type="bibr" target="#b99">Li and Zhou (2015)</ref> proposed to mitigate this problem by considering a diverse set of low-density separators and choosing the separator that performs best under the worst possible ground truth. Like all S3VM variants, their method is premised on the assumption that the optimal decision boundary lies in a low-density area. Their algorithm, called S4VM (safe S3VM), consists of two stages. Firstly, a diverse set of low-density decision boundaries is constructed. To this end, the authors propose to minimize a cost function that penalizes the pairwise similarity between the label predictions associated with the decision boundaries, using deterministic annealing and a heuristic sampling method. Secondly, the decision boundary with maximal worst-case performance gain over the supervised decision boundary is chosen as the result of S4VM training. This problem formulation limits the probability that the solution found by a S4VM exhibits performance worse than the corresponding supervised SVM.</p><p>The performance gain is formulated as the resulting increase in the number of correctly labelled data points minus the increase in the number of incorrectly labelled data. The latter term is multiplied by a factor λ ∈ R, governing the amount of risk of performance degradation one wishes to take. Formally, this is captured by a scoring function J (ŷ, y, y svm ) for a set of predicted labels ŷ, ground truth y, and supervised SVM predictions y svm defined as</p><formula xml:id="formula_12">J (ŷ, y, y svm ) = gain(ŷ, y, y svm ) − λ • lose(ŷ, y, y svm ),</formula><p>where gain and lose denote the increases in correctly and incorrectly labelled data points, respectively. The optimal label assignment ȳ in the worst-case true labelling can then be found as ȳ ∈ arg max</p><formula xml:id="formula_13">y∈{±1} u min ŷ∈M J (y, ŷ, y svm ) ,</formula><p>where M is the set of all candidate label assignments such that the corresponding decision boundary cuts through a low-density area. Due to the optimization over all possible label assignments, this optimization problem is NP-hard. <ref type="bibr" target="#b99">Li and Zhou (2015)</ref> proposed a convex relaxation of the problem to effectively find a good candidate solution. Based on the assumption that the true label assignment is indeed in this set, they proved that, if λ ≥ 1, the performance of S4VM is never lower than that of the corresponding SVM. They validated this finding empirically, and showed that their implementation achieves performance improvements over standard SVMs similar to other S3VM approaches, but that, contrary to those, performance never significantly degrades relative to supervised SVMs. The formulation of the second stage of the optimization procedure is not limited to support vector machines; indeed, it could theoretically be applied to any other semi-supervised learning algorithm. <ref type="bibr" target="#b99">Li and Zhou (2015)</ref> additionally propose to perform both stages simultaneously in a deterministic annealing approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.2">Gaussian processes</head><p>The notion of margin maximization is directly incorporated into support vector machines, and it should thus not come as a surprise that they are easily extended to the semi-supervised setting. Less obviously, similar efforts have been made with other supervised methods as well. Notably, <ref type="bibr" target="#b90">Lawrence and Jordan (2005)</ref> have extended Gaussian processes to handle unlabelled data.</p><p>Gaussian processes are a family of non-parametric models that estimate the posterior probability over the function f mapping points in the input space to a continuous output space. When used for binary classification purposes, which are the focus of the paper by <ref type="bibr" target="#b90">Lawrence and Jordan (2005)</ref>, this output is in turn mapped to the label space Y = {−1, 1}. In the learning phase, f is established such that the likelihood of observing the data points ((x i , y i )) l i=1 is maximized. The resulting model can be considered an l-dimensional Gaussian distribution over the label vector y of the input data points, where l is the number of labelled data points. Predictions for previously unseen data points x * can then be made by the model by evaluating the posterior probability of the respective class label, conditioned on the observed data points X , their associated labels y, and the observed data point x * . The associated covariance matrix is the Gram matrix obtained from all l + 1 data points using some kernel function k. <ref type="bibr" target="#b90">Lawrence and Jordan (2005)</ref> extended Gaussian processes for binary classification to the semi-supervised case by incorporating the unlabelled data points into the likelihood function. Specifically, the likelihood for an unlabelled data point x is low when it is close to the decision boundary (i.e. when f (x) is close to 0), and high when it is far away from the decision boundary. The space of possible labels is expanded to include a null category; the posterior probability of this null category is high around the decision boundary. By imposing the constraint that unlabelled data points can never be mapped to the null category, the model is explicitly discouraged from choosing a decision boundary that passes through a highdensity area of unlabelled data points. In other words, unlabelled data points should be far away from the decision boundary.</p><p>This extension of Gaussian processes to the semi-supervised setting has an interesting side effect: contrary to supervised Gaussian processes, introducing additional (unlabelled) data can increase the posterior variance. In other words, additional data can increase uncertainty. This effect stems from the observation that the likelihood function for a single unlabelled data point x * can be bimodal if f (x * ) is close to 0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.3">Density regularization</head><p>Another way of encouraging the decision boundary to pass through a low-density area is to explicitly incorporate the amount of overlap between the estimated posterior class probabilities into the cost function. When there is a large amount of overlap, the decision boundary passes through a high-density area, and when there is a small amount of overlap, it passes through a low-density area. Several approaches have been proposed to use this assumption to regularize the objective function used in the context of classification. <ref type="bibr" target="#b64">Grandvalet and Bengio (2005)</ref> proposed to formalize this in the maximum a posteriori (MAP) framework by imposing a prior on the model parameters, favouring parameters inducing small class overlap in the predictive model (additionally, see <ref type="bibr" target="#b24">Chapelle et al. 2006b)</ref>. In particular, they used Shannon's conditional entropy as a measure of class overlap. The prior is weighted by a constant λ ∈ R. The resulting objective is generally non-convex. The authors proposed solving the optimization problem by means of deterministic annealing. This entropy regularization method can be applied to any supervised learning method based on maximum-likelihood; the authors conducted experiments using logistic regression. <ref type="bibr" target="#b32">Corduneanu and Jaakkola (2003)</ref> proposed to directly incorporate an estimate of p(x), the distribution over the input data, into the objective function. They add a cost term to the objective function that reflects the belief that, in high-density areas, the posterior probability of y conditioned on x should not vary too much. To this end, they cover the entire input space X with multiple, possibly overlapping, small regions; the cost term is then calculated as the sum of the mutual information between labels and inputs in each of these regions, weighted by the estimated density in the region. Their work is an extension of earlier work by <ref type="bibr" target="#b158">Szummer and Jaakkola (2003)</ref>. <ref type="bibr" target="#b104">Liu et al. (2013</ref><ref type="bibr" target="#b106">Liu et al. ( , 2015) )</ref> proposed to incorporate the prior density into the node splitting criterion of decision trees. When selecting the hyperplane for splitting the data at a node in a decision tree, their approach penalizes high-density areas, using Gaussian kernel density estimators to approximate p(x). They conducted experiments with random forests consisting of 100 of the resulting semi-supervised decision trees and observed significant performance improvements over supervised random forests for several data sets. <ref type="bibr" target="#b94">Levatić et al. (2017)</ref> introduced a more generic framework for using unlabelled data in the splitting criterion by constructing an impurity measure for unlabelled data. In their experiments, they promoted feature consistency within the data subsets on each side of the splitting boundary, penalizing empirical variance for numerical data and the Gini impurity for nominal data. We note that the specific categorization of these methods within our taxonomy depends on the choice of splitting criterion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.4">Pseudo-labelling as a form of margin maximization</head><p>Depending on the base learner used, the self-training approach described in Sect. 4 can also be regarded a margin-maximization method. For instance, when using self-training with supervised SVMs, the decision boundary is iteratively pushed away from the unlabelled samples. Even though the unlabelled data are not explicitly incorporated into the loss function, this amounts to exploiting the low-density assumption, as done in the case of S3VMs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Perturbation-based methods</head><p>The smoothness assumption entails that a predictive model should be robust to local perturbations in its input. This means that, when we perturb a data point with a small amount of noise, the predictions for the noisy and the clean inputs should be similar. Since this expected similarity is not dependent on the true label of the data points, we can make use of unlabelled data.</p><p>Many different methods exist for incorporating the smoothness assumption into a given learning algorithm. For instance, one could apply noise to the input data points, and incorporate the difference between the clean and the noisy predictions into the loss function. Alternatively, one could implicitly apply noise to the data points by perturbing the classifier itself. These two approaches give rise to the category of perturbation-based methods.</p><p>Perturbation-based methods are often implemented with neural networks. Due to their straightforward incorporation of additional (unsupervised) loss terms into their objective function, they are extendable to the semi-supervised setting with relative ease. In recent years, neural networks have received renewed interest, due their successful application in various application areas (see, e.g. <ref type="bibr" target="#b31">Collobert et al. 2011;</ref><ref type="bibr" target="#b86">Krizhevsky et al. 2012;</ref><ref type="bibr" target="#b91">LeCun et al. 2015)</ref>. As a result, interest in semi-supervised neural networks has risen as well. In particular, neural networks with many layers, so-called deep neural networks, have given rise to interesting extensions to the semi-supervised setting. These intrinsically semi-supervised neural networks differ from the neural networks used for feature extraction, which we discussed in Sect. 5.1: the unlabelled data is incorporated directly into the optimization objective, rather than being used in a separate preprocessing step. Before continuing our discussion of such methods, we provide a short, general introduction to neural networks targeted at readers who are not too familiar with them. For a more extensive introduction to (deep) neural networks, we refer the interested reader to the recent book by <ref type="bibr" target="#b60">Goodfellow et al. (2016)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.1">Neural networks</head><p>A neural network is a formal system that computes an output vector by propagating an input vector through a network of simple processing elements with weighted connections between them. These simple processing elements are called nodes, and each of them contains an activation function that ultimately determines its output. In the feedforward networks we are considering here, nodes are usually grouped together into layers, where nodes from each layer are only connected to nodes from adjacent layers. The output vector is calculated by propagating the input vector through the weighted connections of the network. The output of each node, commonly referred to as its activation, is calculated by applying its activation function to the weighted sum of its inputs.</p><p>In supervised neural networks, the network weights are generally optimized to calculate the desired output vector for a given input vector. Considering the classification task, let f : R d → R |Y| denote the vector-valued function modelled by a neural network, mapping an input vector x ∈ R d to a |Y|-dimensional output vector, where Y denotes the set of possible classes. The function f is modelled by a neural network consisting of one or multiple layers; nodes in consecutive layers are connected by weighted edges. The weights are stored in a weight matrix W , where the element at position (i, j) denotes the weight of the edge between nodes i and j. We use f (x; W ) to denote the output obtained by propagating the input x through the network and evaluating the activations of the final layer.</p><p>A loss function is then defined, calculating the cost associated with output layer activations f (x; W ) for a data point x with true label y. The complete cost function is then defined as</p><formula xml:id="formula_14">L(W ) = l i=1 ( f (x i ; W ), y i ).</formula><p>(4)</p><p>The explicit notion of the parametrization of f by W is often omitted for conciseness.</p><p>The weights in W are iteratively optimized by passing input samples through the network and propagating the share of one or more samples in the cost L backwards through the network. In this process, known as backpropagation, the weights are updated, using gradient descent or a similar method to iteratively minimize the cost <ref type="bibr" target="#b60">(Goodfellow et al. 2016</ref>). To achieve good performance (in terms of loss), the network generally needs to pass multiple times over the entire training set, and each such pass is known as an epoch.</p><p>In the literature on neural networks, various notation styles are used. In particular, some of the articles we discuss use θ to denote the network weights, and denote the output of the corresponding network by f θ (x). In discussing these articles, we use this notation style when we deem it essential for maintaining relatability between the respective article and this survey.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.2">Semi-supervised neural networks</head><p>The simplicity and efficiency of the backpropagation algorithm for a great variety of loss functions make it attractive to simply add an unsupervised component to L. This approach, which can be considered a form of regularization over the unlabelled data, is employed by virtually all semi-supervised deep learning methods. Furthermore, the hierarchical nature of representations in deep neural networks make them a viable candidate for other semi-supervised approaches. If deeper layers in the network express increasingly abstract representations of the input sample, one can argue that unlabelled data could be used to guide the network towards more informative abstract representations. Approaches based on this argument can be readily implemented in deep neural networks through the smoothness assumption, giving rise to so-called perturbation-based semi-supervised neural networks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.3">Ladder networks</head><p>The first such approach is the ladder network, proposed by <ref type="bibr" target="#b135">Rasmus et al. (2015)</ref>. It extends a feedforward network to incorporate unlabelled data by using the feedforward part of the network as the encoder of a denoising autoencoder, adding a decoder, and including a term in the cost function to penalize the reconstruction cost. The underlying idea is that latent representations that are useful for input reconstruction can also facilitate class prediction.</p><p>Consider a feedforward network with K hidden layers and weights W . We denote the inputs of a layer k (after normalization) as z k , and the layer's activations (i.e. after applying the activation function) as h k . Note that for conciseness, when referring to layer inputs and activations, we do not explicitly mention the input data x i , nor the parametrization W (e.g. we write h k for the activation vector of the k-th layer in a neural network with weights W for data point x i ). In a regular feedforward network, the loss for a given data point x i is calculated by comparing the activations of the final layer f (x i ) = h K to the corresponding label y i with ( f (x i ), y i ). As is shown in Eq. 4, the final cost function for the network is then L(W ) = l i=1 ( f (x i ), y i ). Ladder networks add an additional term to L, in order to penalize the sensitivity of the network to small perturbations of the input. This is achieved by treating the entire network as the encoder part of a denoising autoencoder: isotropic Gaussian noise with mean zero and fixed variance is added to the input samples, and the existing feedforward network is treated as the encoder part. A decoder is then added alongside it, which is supposed to take the final-layer representation h K of a noisy data point x, and transform it to reconstruct x. To achieve this goal, a reconstruction cost is added to the cost function of the network. This inherently unsupervised cost term penalizes the difference between the input data points and their reconstructions generated by the network; it applies to both labelled and unlabelled data.</p><p>Although the autoencoder component of ladder networks is highly similar to regular denoising autoencoders, it differs from those in two ways. Firstly, a ladder network injects noise not only at the first layer, but at every layer. We denote the noisy inputs of a layer k as zk , and the resulting activations as hk . The supervised loss component for each sample 'omes ( hK , y): the loss function is evaluated against the output for the noisy sample. Note that, in the testing phase, no noise is induced at any point in the network.</p><p>Secondly, ladder networks utilize a different reconstruction cost calculation. Where regular denoising autoencoders only penalize the difference between the clean input x and the reconstructed version x of the noisy input x, the ladder network also penalizes local reconstructions of the hidden representations of the data. To do so, they enforce the decoder to have K layers, the same number of layers as the original network (the encoder). Each of these layers is also required to have the same number of nodes as the corresponding layer in the encoder. As a data point passes through the encoder, noise is added to the layer inputs at each layer. Then, at each layer in the decoder, the reconstructed representation ẑk is compared to the hidden representation z k of the clean input x at layer k in the encoder. This, of course, requires each data point to pass through the network twice: once without noise (to obtain z), and once with noise (to obtain z and the reconstructed ẑ).</p><p>The final semi-supervised cost function of ladder networks then becomes</p><formula xml:id="formula_15">L(W ) = l i=1 ( f (x i ), y i ) + n i=1 K k=1 ReconsCost(z k i , ẑk i ),</formula><p>where ReconsCost(•, •) is defined as the squared L2 norm of the difference between the two normalized latent vectors and summed over the labelled and unlabelled data. For a detailed diagram of the information flow in ladder networks, which uses the same notation we do, we refer the reader to Figure <ref type="figure">1</ref> in the ladder network study by <ref type="bibr">Pezeshki et al. (2016, p. 4</ref>).</p><p>Through their penalization of reconstruction errors, ladder networks effectively attempt to push the network towards extracting interesting latent representations of the data. The method is premised on the assumption that a latent representation h K that is useful for reconstructing x can also facilitate the prediction of the corresponding class label. <ref type="bibr" target="#b135">Rasmus et al. (2015)</ref> showed that ladder networks achieve state-of-the-art results on image data sets with partially labelled data, including MNIST. Interestingly, they also reported improvements when using only labelled data. Prémont-Schwarz et al. ( <ref type="formula">2017</ref>) extended the ladder network architecture to the recurrent setting by adding connections between the encoders and decoders of successive instances of the network.</p><p>Rasmus et al. also proposed a simpler, computationally more efficient variant of ladder networks. This method, generally referred to as the -model, only includes the reconstruction cost for the last layer. Therefore, no full decoder needs to be constructed. The -model was empirically shown to provide substantial performance improvements over the corresponding fully-supervised model. <ref type="bibr" target="#b129">Pezeshki et al. (2016)</ref> conducted an extensive empirical study of the different components of ladder networks. Their study revealed that the reconstruction cost at the first layer of the neural network, combined with the introduction of noise in that layer, has critical impact on overall performance. We note that this architecture differs from the -model, which only considers the last, rather than the first, layer of the network when assessing reconstruction error.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.4">Pseudo-ensembles</head><p>Instead of explicitly perturbing the input data, one can also perturb the neural network model itself. Robustness in the model can then be promoted by imposing a penalty on the difference between the activations of the perturbed network and those of the original network for the same input. <ref type="bibr" target="#b4">Bachman et al. (2014)</ref> proposed a general framework for this approach, where an unperturbed parent model with parameters θ is perturbed to obtain one or more child models. In this framework, which they call pseudo-ensembles, the perturbation is obtained from a noise distribution . The perturbed network fθ (x; ξ) is then generated based on the unperturbed parent network f θ (x) and a sample ξ from the noise distribution. The semi-supervised cost function then consists of a supervised part and an unsupervised part. The former captures the loss of a perturbed network for labelled input data, and the latter the consistency across perturbed networks for the unlabelled data points.</p><p>Based on this framework, <ref type="bibr" target="#b4">Bachman et al. (2014)</ref> proposed a semi-supervised cost function. Consider a neural network with K layers, and let f k θ (x) and f k θ (x; ξ) denote the k-th layer activations of the unperturbed and the perturbed network, respectively. The cost function of the pseudo-ensemble for neural networks then becomes</p><formula xml:id="formula_16">E ξ ∼ 1 l • l i=1 L( fθ (x i ; ξ), y i ) + E ξ ∼ 1 n • n i=1 K k=2 λ k • V k f k θ (x i ), f k θ (x i ; ξ) ,</formula><p>where the consistency loss V k penalizes differences between the activations of the unperturbed and perturbed networks at the k-th layer for the same input; λ k is the relative weight of that particular cost term. <ref type="foot" target="#foot_2">2</ref> Bachman et al. propose to gradually increase each ˘k over time, in effect placing more weight on the supervised objective in early iterations. One particularly prominent method of inducing noise is dropout, which randomly sets weights to zero (i.e. removes connections in the neural network) in each training iteration <ref type="bibr" target="#b152">(Srivastava et al. 2014)</ref>. In its originally proposed form, it was only applied to the supervised loss component. However, <ref type="bibr" target="#b175">Wager et al. (2013)</ref> and <ref type="bibr" target="#b4">Bachman et al. (2014)</ref> showed that dropout can be readily applied to unlabelled data as well.</p><p>The framework proposed by Bachman et al. is not limited to semi-supervised settings: the supervised term in the loss function can be applied to any supervised learning problem. Furthermore, a similar approach could be applied to other learning algorithms than neural networks, although the per-layer activation comparison would have to be replaced by a suitable alternative. Of course, since neural networks are entirely parametrized by connection weights, they offer a relatively straightforward implementation of model perturbation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.5">5-model</head><p>Instead of comparing the activations of the unperturbed parent model with those of the perturbed models in the cost function, one can also compare the perturbed models directly. A simple variant of this approach, where two perturbed neural network models are trained, was suggested by <ref type="bibr" target="#b88">Laine and Aila (2017)</ref>. They use dropout <ref type="bibr" target="#b152">(Srivastava et al. 2014)</ref> as the perturbation process, and penalize the differences in the final-layer activations of the two networks using squared loss. The weight of the unsupervised term in the cost function starts at zero, and is gradually increased. This approach, which they name the -model, can be seen as a simple variant of pseudo-ensembles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.6">Temporal ensembling</head><p>Since the noise process used in the methods described thus far is stochastic, the entire neural network model can be considered a stochastic model. With the -model, the network is regularized by penalizing the difference in output of two perturbed network models, drawn from the same distribution, on the same input. This idea can be extended to more than two perturbed models. Such an approach was taken by <ref type="bibr" target="#b141">Sajjadi et al. (2016)</ref>, who additionally perturbed the input data with random transformations. Of course, such pairwise comparisons will increase the running time of each training iteration quadratically in the number of perturbations. Pseudo-ensembles solve this problem by comparing the perturbed network activations to the activations of the unperturbed network model.</p><p>In the same paper in which they propose the -model, <ref type="bibr" target="#b88">Laine and Aila (2017)</ref> propose a different approach to combining multiple perturbations of a network model: they compare the activations of the neural network at each epoch to the activations of the network at previous epochs. In particular, after each epoch, they compare the output of the network to the exponential moving average of the outputs of the network in previous epochs. Since the connection weights are changed in each iteration, this cannot be considered a form of pseudo-ensembling, but it is conceptually related, in that the network output is smoothed over multiple model perturbations.</p><p>This approach-dubbed temporal ensembling, because it penalizes the difference in the network outputs at different points in time during the training process-can be considered an extension of the -model. However, instead of comparing f θ (x; ξ) to f θ (x; ξ ) for ξ, ξ ∼ , it uses comparisons to the exponential moving average of final-layer activations in previous epochs. Since the loss function for unlabelled data points depends on the network output in previous iterations, temporal ensembling is closely related to pseudo-labelling methods, such as the pseudo-label approach (Lee 2013) and self-training. The crucial difference, however, is that the entire set of final-layer activations is compared to the activations of the previous network model, whereas self-training approaches and pseudo-label convert these outputs to a single, hard prediction (the pseudo-label).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.7">Mean teacher</head><p>When training a neural network using temporal ensembling, unlabelled data points are incorporated into the learning process at large intervals. Since the activations for each input are only generated once per epoch, it takes a long time for the activations of unlabelled data points to influence the inference process. <ref type="bibr" target="#b166">Tarvainen and Valpola (2017)</ref> attempted to overcome this problem by considering moving averages over connection weights, instead of moving averages over network activations.</p><p>Specifically, they suggested calculating the exponential moving average of weights at each training iteration, and compared the resulting final-layer activations to the final-layer activations when using the latest set of weights. Furthermore, they imposed noise on the input data to increase robustness. Formally, consider a neural network with weights W t at iteration t, and a set of averaged weights Ŵt . The loss function for an unlabelled input, then, is calculated as</p><formula xml:id="formula_17">(x) = || f (x; Ŵt ) − f (x ; W t )|| 2 ,</formula><p>where x and x are two noiseaugmented versions of x. After calculating W t+1 using backpropagation, Ŵt+1 is calculated by</p><formula xml:id="formula_18">Ŵt+1 = α • Ŵt + (1 − α) • W t+1</formula><p>, where α is the decay rate. They name the model with averaged weights Ŵ the teacher model, and the latest model with weights W t the student model. This terminology has since been adopted in the literature when constructing semisupervised neural networks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.8">Virtual adversarial training</head><p>Most of the perturbation-based approaches we have discussed thus far aim to promote robustness to small perturbations in the input. In doing so, they do not take into account the directionality of the perturbation: the injected noise is generally isotropic. However, it has been suggested in several studies that the sensitivity of neural networks to perturbations in the input is often highly dependent on the direction of these perturbations <ref type="bibr" target="#b156">(Szegedy et al. 2013;</ref><ref type="bibr" target="#b62">Goodfellow et al. 2014b</ref>). <ref type="bibr" target="#b114">Miyato et al. (2018)</ref> proposed a regularization procedure that takes the perturbation direction into account. For each data point, labelled or unlabelled, they approximate the perturbation to the corresponding input data that would yield the largest change in network output (the so-called advesarial noise). They then incorporate a term into the loss function that penalizes the difference in the network outputs for the perturbed and unperturbed input data. For the unperturbed data point, the weights from the previous optimization iteration are used. Formally, the adversarial loss function for a sample x can be defined as</p><formula xml:id="formula_19">(x) = D( f (x; Ŵ ), f (x + γ adv ; W )),</formula><p>where D is some divergence measure, γ adv is the adversarial noise, and Ŵ are the previous network weights. Their approach is called virtual adversarial training, after the supervised adversarial training method proposed by <ref type="bibr" target="#b62">Goodfellow et al. (2014b)</ref>. In the latter approach, the outputs for the perturbed input are compared to the respective true outputs, rather than to the outputs of the network for the unperturbed input. As such, regular adversarial training can only be applied in a supervised setting. Adversarial training and virtual adversarial training both bear close similarity to contractive autoencoders: there, the sensitivity of the network to perturbations in the inputs is penalized by directly assessing the derivatives of the network outputs with respect to the inputs <ref type="bibr" target="#b138">(Rifai et al. 2011b)</ref>. <ref type="bibr" target="#b125">Park et al. (2018)</ref> combined concepts from virtual adversarial training with the -model (see Sect. 6.2.5). Instead of perturbing the unlabelled data points with adversarial noise, they apply an adversarial dropout mask to the network weights. First, they sample a random dropout mask s . Then, within some maximum distance from s , they find the dropout mask adv that maximizes the difference between the unperturbed network output and the network output when the dropout mask is applied. Their loss function, then, is defined as</p><formula xml:id="formula_20">(x) = D( f (x; W , s ), f (x; W , adv )),</formula><p>where the network is parameterized by the weights W as well as the dropout mask. <ref type="bibr" target="#b125">Park et al. (2018)</ref> reported small performance improvements over virtual adversarial training and the -model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.9">Semi-supervised mixup</head><p>The perturbation-based neural networks we have discussed thus far rely on a particularly strong instantiation of the smoothness assumption: they encourage the predictions of the network to be identical for minor perturbations in the input, regardless of the direction of the perturbation. Recently, several researchers have considered the possibility of applying larger perturbations to the input. In this scenario, the direction of the perturbation generally does matter: when the perturbation points towards the decision boundary, the neural network outputs (but not necessarily the resulting class assignment) should typically change more than when it points away from the decision boundary. This approach was formalized in the supervised mixup method, which was proposed by <ref type="bibr" target="#b197">Zhang et al. (2018)</ref>. They postulate that, in a robust classifier, the predictions for a linear combination of feature vectors should be a linear combination of their labels. They incorporate this by training on augmented data points in addition to the original labelled samples. To this end, they randomly select pairs of data points (x, y) and (x , y ) during training, and sample an interpolation factor λ from a symmetric beta distribution Beta(α, α), where α is a predetermined hyperparameter. The network is then trained in a supervised manner on the linearly interpolated data point (x, ŷ), where</p><formula xml:id="formula_21">x = λ • x + (1 − λ) • x , ŷ = λ • y + (1 − λ) • y .</formula><p>In their experiments, <ref type="bibr" target="#b197">Zhang et al. (2018)</ref> report substantial performance improvements in several training scenarios. Their best results are achieved when the beta distribution hyperparameter, α, is relatively low, causing the distribution to be strongly biased towards the extremes (i.e., λ = 0 and λ = 1). Consequently, a large majority of interpolated samples will lie very close to either of the two selected data points.</p><p>The interpolation used in mixup can be applied to unlabelled samples as well, by interpolating the predicted labels rather than the true labels. <ref type="bibr" target="#b173">Verma et al. (2019)</ref> combined mixup with the mean teacher approach (see Sect. 6.2.7), determining the target label for the augmented data point as the linear interpolation of the predictions of the teacher model. Interestingly, the interpolation was only applied to pairs of unlabelled data points, and not to mixed pairs of labelled and unlabelled data points. <ref type="bibr" target="#b17">Berthelot et al. (2019)</ref> proposed a semi-supervised neural network composed of several supervised and semi-supervised components, including a semi-supervised extension of mixup. In selecting data points for interpolation, they do not distinguish between labelled and unlabelled data points. For labelled data points, the true label is then used in interpolation; for unlabelled data points, the predicted label is used.</p><p>Mixup exhibits similarities to graph-based methods (see Sects. 6.3 and 7): rather than employing pointwise perturbations, they apply perturbations based on combinations of different data points. Unlike in graph-based methods, however, the pairwise similarity between data points is not taken into account. The precise implications of this remain an interesting avenue for future research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Manifolds</head><p>Perturbation-based methods make direct use of the smoothness assumption, penalizing differences in the behaviour of a classifier under slight changes in the input or in the classifier itself. However, one can imagine that not all minor changes to the input should yield similar outputs. In particular, if the data lie on lower-dimensional manifolds, one can expect the classifier to be insensitive only to minor changes along the manifold. This observation corresponds to the manifold assumption, which forms the basis of a significant body of intrinsically semi-supervised learning algorithms.</p><p>An m-dimensional manifold is a subspace of the original input space that locally resembles Euclidean space R m . Reiterating the definition from Sect. 2, the manifold assumption states that (a) the input space is composed of multiple lower-dimensional manifolds on which all data points lie and (b) data points lying on the same lower-dimensional manifold have the same label. Formally, the first part of the manifold assumption states that each conditional probability distribution p(x|y) has a structure corresponding to the union of one or more Riemannian manifolds M. The second part, then, states that points on the same Riemannian manifold M should have the same label. If these assumptions hold, information about the manifolds present in the input space can prove useful to classification.</p><p>In this section, we consider two general types of methods that are based on the manifold assumption. Firstly, we consider manifold regularization techniques, which define a graph over the data points and implicitly penalize differences in predictions for data points with small geodesic distance. Secondly, we consider manifold approximation techniques, which explicitly estimate the manifolds M on which the data lie and optimize an objective function accordingly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.1">Manifold regularization</head><p>Consider a labelled data point x i and an unlabelled data point x j , and assume that x i lies on some manifold M. If x j also lies on M, the manifold assumption implies that it is likely to have the same label as x i . Furthermore, assuming that the data is concentrated on lower-dimensional manifolds, we can expect there to be more data points x * located on M.</p><p>If we have sufficiently many data points, we can thus expect there to be some "path", a so-called geodesic, from x j to x i , passing through other labelled or unlabelled samples, such that each path segment is relatively short. We can formalize this notion of a path by defining a graph over all data points, connecting pairs of data points that are close together in the original input space with an edge. Edge weights may be used to express the degree of similarity. This is the key principle underlying graph-based methods, which also form the basis of transductive semi-supervised learning (see Sect. 7).</p><p>Following this motivation, <ref type="bibr" target="#b11">Belkin et al. (2005</ref><ref type="bibr" target="#b12">Belkin et al. ( , 2006</ref>) formulated a general framework for regularizing inductive learners based on manifolds. They considered a kernel K : X ×X → R with a corresponding hypothesis space H K and an associated norm || • || K . For supervised problems, then, they formulated the following general optimization problem:</p><formula xml:id="formula_22">minimize f ∈H K l i=1 [ ( f (x i ), y i )] + γ • || f || 2 K ,</formula><p>for some loss function on labelled data. Here, γ denotes the relative influence of the smoothing term. This objective function simultaneously penalizes misclassifications and promotes smoothness of the predictive function. For the semi-supervised setting, they added an unsupervised regularization term that penalizes differences in label assignments for pairs of data points that have a direct edge between them in the graph. Implicitly, they thereby encourage data points on the same manifold to receive the same label prediction. This unsupervised regularization term gives rise to the class of manifold regularization methods. Consider a similarity graph with symmetric weighted adjacency matrix W , where W i j denotes the similarity between data points x i and x j (W i j = 0 if the points are not connected). Let D denote the degree matrix, which is a diagonal matrix with</p><formula xml:id="formula_23">D ii = n j=1 W i j . The manifold regularization term || f || 2 I is then defined as || f || 2 I = 1 2 • n i=1 n j=1 W i j • ( f (x i ) − f (x j )) 2 . (<label>5</label></formula><formula xml:id="formula_24">)</formula><p>The regularization term can be expressed as f • L • f, where L = D − W is the graph Laplacian, and f ∈ R n is the vector of evaluations of f for each x i . The final optimization problem, including the manifold regularization term from Eq. 5, becomes minimize</p><formula xml:id="formula_25">f ∈H K 1 l • l i=1 ( f (x i ), y i ) + γ • || f || 2 K + γ U • || f || 2 I , (<label>6</label></formula><formula xml:id="formula_26">)</formula><p>where γ U determines the relative influence of the manifold regularization term. This general framework leads to semi-supervised extensions of popular supervised learning algorithms, such as Laplacian support vector machines (LapSVMs), where the loss function is defined as the hinge loss, i.e. ( ŷ, y) = max{1− y ŷ, 0}. The supervised objective of LapSVMs maximizes the margin, and the unsupervised objective maximizes consistency of predictions along the estimated manifolds. In the paper proposing this framework, <ref type="bibr" target="#b12">Belkin et al. (2006)</ref> suggested to solve the resulting loss minimization problem in its dual form, similar to popular solving techniques for supervised SVMs, in time O(n 3 ). <ref type="bibr" target="#b111">Melacci and Belkin (2011)</ref> suggested solving the optimization problem in its primal form. Combining an early stopping criterion with a preconditioned conjugate gradient, they reduced the time complexity to O(c • n 2 ) for some c that is empirically shown to be significantly smaller than n. <ref type="bibr" target="#b134">Qi et al. (2012)</ref> suggested to extend twin SVMs, which optimize two SVM-like objective functions to yield two non-parallel decision boundaries (one for each class) <ref type="bibr" target="#b75">(Jayadeva et al. 2007)</ref>, to include the LapSVM regularization term. <ref type="bibr" target="#b147">Sindhwani et al. (2005)</ref>; <ref type="bibr" target="#b148">Sindhwani and Rosenberg (2008)</ref> extend manifold regularization to the co-regularization framework (see Sect. 4.2). They proposed to construct two classifiers using an objective function similar to that of LapSVMs for two different views. <ref type="bibr" target="#b120">Niyogi (2008)</ref> provided some theoretical analysis on the manifold regularization framework and analyzed its usefulness in semi-supervised learning. <ref type="bibr" target="#b211">Zhu and Lafferty (2005)</ref> proposed to incorporate a manifold regularization term in a generative model. They expressed the data-generating distribution as a mixture model, where the manifold is locally approximated by a mixture model component. Their loss function consists of a regularizer over the graph and a generative component. <ref type="bibr" target="#b184">Weston et al. (2008)</ref> incorporated a manifold regularization term into deep neural networks. They proposed several methods to incorporate the manifold structure using an auxiliary embedding task, which encourages the latent representations in the neural network to be similar for similar inputs. Furthermore, they suggested to include a regularization term that explicitly pushes the latent representations of non-similar data points (defined as not being neighbours in the underlying graph) further apart. This approach was applied to hyperspectral image classification by <ref type="bibr" target="#b136">Ratle et al. (2010)</ref>. More recently, <ref type="bibr" target="#b108">Luo et al. (2018)</ref> employed a loss function that encourages data points with the same label, either predicted (for unlabelled data points) or true (for labelled data points), to have similar latent representations in the penultimate layer. Additionally, it encourages the latent representations of data points with different predicted labels to be dissimilar.</p><p>The graph construction process is non-trivial and involves many hyperparameters. For instance, one can use a variety of connectivity criteria and edge weighting schemes. This makes the performance of manifold regularization methods highly dependent on hyperparameter settings. <ref type="bibr" target="#b57">Geng et al. (2012)</ref> attempted to overcome this problem by first selecting a set of candidate Laplacians using different hyperparameter settings. They then posed the optimization problem as finding the linear combination of Laplacians that minimizes the manifold regularization objective. Formally, let there be m candidate Laplacians L 1 , . . . , L m . Assume that the optimal manifold L * lies in the convex hull of L 1 , . . . , L m , i.e. L * = m j=1 μ j • L j with m j=1 μ j = 1 and μ j ≥ 0 for j = 1, . . . , m. Since each L j is a valid graph Laplacian, their linear combination is a valid graph Laplacian as well. Using exponential weights in the Laplacian, the manifold regularization term || f || 2 I then becomes</p><formula xml:id="formula_27">|| f || 2 I = f • L • f = f • ⎛ ⎝ m j=1 μ j • L j ⎞ ⎠ • f = m j=1 μ j • || f || 2 I ( j) ,</formula><p>where || f || 2 I ( j) is the manifold regularization term for candidate Laplacian L j . This final regularization term is then used in the original optimization problem from Eq. 6, with the addition of a regularization term ||μ|| 2 to prevent the optimizer from overfitting to one manifold, and the constraint that m j=1 μ j = 1. The objective function is then optimized with respect to μ and f , which Geng et al. proposed to do in an EM-like fashion (i.e. fixing one and optimizing the other alternatingly). Their approach, which they call ensemble manifold regularization, was demonstrated to be superior to LapSVMs when applied to the SVM objective function on both synthetic and real-world data sets <ref type="bibr" target="#b57">(Geng et al. 2012)</ref>.</p><p>Aside from the methods proposed by <ref type="bibr" target="#b57">Geng et al. (2012)</ref> and <ref type="bibr" target="#b108">Luo et al. (2018)</ref>, graph construction methods have mainly been studied in the context of transductive semi-supervised learning. We cover these methods extensively in Sect. 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.2">Manifold approximation</head><p>Manifold regularization techniques introduce a regularization term that directly captures the fact that manifolds locally represent lower-dimensional Euclidean space. However, one can also consider a two-stage approach, where the manifold is first explicitly approximated and then used in a classification task. This is the approach taken by manifold approximation techniques, which construct an explicit representation of the manifold. We note that such approaches have a close relation to, and can in some cases even be considered as, semisupervised preprocessing (see Sect. 5). <ref type="bibr" target="#b137">Rifai et al. (2011a)</ref> developed such an approach, where the manifolds are first estimated using contractive autoencoders (CAE, see <ref type="bibr" target="#b137">Rifai et al. 2011a)</ref>, and then used by a supervised training algorithm. CAEs are a variant of autoencoders that, in addition to the normal reconstruction cost term in autoencoders, penalize the derivatives of the output activations with respect to the input values. By doing so, they penalize the sensitivity of the learned features to small perturbations in the input without relying on sampling these perturbations (like denoising autoencoders do). <ref type="bibr" target="#b138">Rifai et al. (2011b)</ref> claim that CAEs do not merely penalize sensitivity to small perturbations in the input, but that they penalize small perturbations of the input data along the manifold. They argue that this effect occurs due to the balance of promoting reconstruction and penalizing sensitivity to inputs. In other words, they claim to act directly on the manifold assumption.</p><p>The loss function L utilized by contractive autoencoders with reconstruction cost (•, •) is</p><formula xml:id="formula_28">L = n i=1 (g(h(x i )), y i ) + λ • ||J || 2 F ,</formula><p>where ||J || F is the Frobenius norm of the Jacobian matrix of the outputs with respect to the inputs, i.e. the sum of the squared partial derivatives of each output activation with respect to each input value. <ref type="bibr">Rifai et al. additionally</ref> proposed to penalize the Hessian of the output values. Due to the computational complexity of exactly calculating the Hessian, they propose to approximate it as the difference between the Jacobians corresponding to small perturbations of the input.</p><p>Using singular value decomposition, they estimate the tangent plane at each input point to approximate the actual manifolds. As a result, the distance between two data points along the manifold can be estimated and subsequently used in classification, e.g. via a k-nearest neighbour algorithm. Additionally, they suggested to use a deep neural network pre-trained with multiple, stacked contractive autoencoders, where an additional term is added to the loss function to explicitly penalize sensitivity of the outputs to perturbations along the tangent plane.</p><p>A manifold can be described as a collection of overlapping charts, each having a simple geometry, that jointly cover the entire manifold. Such a collection of charts is known as an atlas. <ref type="bibr" target="#b130">Pitelis et al. (2013</ref><ref type="bibr" target="#b131">Pitelis et al. ( , 2014) )</ref> suggested to approximate these charts explicitly, associating each with an affine subspace. They alternate between assigning data points to charts, and choosing the affine subspace best matching the data for each chart. The charts are initialized using principal component analysis on a set of random subspaces. From this, a set of charts and a soft assignment of points to charts is obtained (since points can be associated with more than one chart). Finally, from these charts and soft assignments, kernels are generated that are then used in SVM-based supervised learning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Generative models</head><p>The aforementioned methods are all discriminative: their only goal is to infer a function that can classify data points. In some cases, they produce probabilistic predictions; in others, they only yield the most likely class to assign. In all cases, they approach the classification problem without explicitly modelling any of the data-generating distributions. In contrast, the primary goal of methods based on generative models is to model the process that generated the data. When such a generative model is conditioned on a given label y, it can also be used for classification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4.1">Mixture models</head><p>If prior knowledge about p(x, y) is available, generative models can be very powerful. For instance, consider the case where we know that our data p(x, y) is composed of a mixture of k Gaussian distributions, each of which corresponds to a certain class. Most discriminative methods would not be able to properly incorporate this prior information. Instead, one would be best served by simply fixing the model as a mixture of k Gaussian components. Each component j = 1, . . . , k has three parameters: a weight π j (where k j=1 π j = 1), mean vector μ j , and covariance matrix j . The most likely parameters can then be inferred, for example via expectation-maximization <ref type="bibr" target="#b44">(Dempster et al. 1977)</ref>. This model is generative: it models the distribution p(x, y), from which samples (x, y) can be drawn. The model can then also be used for classification: since the inference procedure yields an estimate p(x|y) of the conditional distribution p(x|y), one can simply assign to an unlabelled data point x i ∈ X U the class c that maximizes p(x i |y i = c) • p(y i = c). In the case of Gaussian mixture models described earlier, p(y i = c) = π c .</p><p>The application of mixture models to generative modelling comes with several caveats <ref type="bibr" target="#b34">(Cozman et al. 2003;</ref><ref type="bibr" target="#b206">Zhu 2008)</ref>. Firstly, the mixture model should be identifiable: each distinct parameter choice for the mixture model should determine a distinct joint distribution, up to a permutation of the mixture components. Secondly, mixture models hinge on the critical assumption that the assumed model is correct. If the model is not correct, i.e. the true distribution p(x, y) does not conform with the assumed model, unlabelled data may hurt performance rather than improve it.</p><p>In real-world applications, the model correctness assumption rarely holds. Therefore, using mixture models for generative modelling can prove difficult. Some approaches exist to mitigate these problems; for example, <ref type="bibr">Nigam et al. (2000)</ref> vary the influence of unlabelled data in EM. However, the rigidity of mixture models has caused attention to shift to more flexible classes of generative models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4.2">Generative adversarial networks</head><p>Recently, a new type of learning paradigm known as generative adversarial networks (GAN) has been proposed, based on the idea of simultaneously constructing generative and discriminative learners <ref type="bibr" target="#b61">(Goodfellow et al. 2014a</ref>). Generally implemented using neural networks, this approach simultaneously trains a generative model, tasked with generating data points that are difficult to distinguish from real data, and a discriminative classifier, tasked with predicting whether a given data point is 'real' or 'fake' (i.e. artificially generated).</p><p>The discriminator D, with parameters θ (D) , and generator G, with parameters θ (G) , are trained simultaneously to optimize a single objective function. Crucially, the discriminator's goal is to minimize the objective function, whereas the generator's goal is to maximize it. The discriminative function D expresses the probability that a data point x is real; the generative function G generates a data point x from a noise vector z sampled from some distribution p(z). The cost function then consists of two terms; the first of these expresses the ability of the discriminator to identify true data points as such, and its optimization involves only the discriminator. The second term expresses the discriminator's ability to identify fake data points, and its optimization involves both the discriminator and the generator. Formally, treating the real data as samples from some underlying probability distribution p(x), the optimization problem can be formulated as</p><formula xml:id="formula_29">min G max D V (D, G) = E x∼ p(x) [log D(x)] + E z∼ p(z) [log(1 − D(G(z))],<label>(7)</label></formula><p>where the parametrizations of D by θ (D) and G by θ (G) are omitted for conciseness. The generator and the discriminator are trained in an alternating fashion. In each training step, multiple real data points are taken from the training data, and multiple fake data points are generated using G by sampling from p(z). The respective parameters θ (D) and θ (R) of the discriminator and the generator are then adjusted independently to optimize the empirical objective function over the batches of samples using gradient descent <ref type="bibr" target="#b60">(Goodfellow 2017)</ref>.</p><p>GANs are naturally unsupervised: they consist of a generative model, trained on unlabelled data, in combination with a discriminative classifier used to assess the quality of the generator. However, extensions exist to support classification in GANs. Proposed but not implemented in the original GAN paper <ref type="bibr" target="#b61">(Goodfellow et al. 2014a</ref>), these methods also use a generator and a discriminator, but train the discriminator to identify different classes instead of only distinguishing real from fake data points. As such, GANs naturally extend to the semisupervised case: the purely discriminative component of the loss term (the first cost term in Eq. 7) can easily be extended to incorporate true labels when these are known. <ref type="bibr" target="#b151">Springenberg (2015)</ref> proposed to extend the GAN discriminator to use |Y| outputs, corresponding to the |Y| possible classes. In their method, named CatGAN, they adapt the GAN cost function to include a cross-entropy cost term that penalizes misclassifications of real data by the discriminator. The ability of the discriminator to distinguish real from fake data points is assessed by considering the entropy of its outputs: for fake data, the discriminator should be uncertain of the class to assign, whereas it should be certain of its prediction for real data points. Furthermore, they add a cost term to encourage the generator to assign equal probability of generation to each class. We note that CatGAN can also be used in an unsupervised setting, by leaving out the cross-entropy cost term. <ref type="bibr" target="#b142">Salimans et al. (2016)</ref> extended GANs to the semi-supervised setting by using |Y| + 1 outputs, where outputs 1, . . . , |Y| correspond to the individual classes, and output |Y| + 1 is used to indicate fake data points. The loss function is adapted to include the cross-entropy loss of the prediction given the true label for the labelled data points. Otherwise, the loss function does not need to be changed significantly: when presented with an unlabelled data point, the discriminator's estimate of the data point not being fake can be calculated as</p><formula xml:id="formula_30">|Y| c=1 D c (x)</formula><p>for data point x, where D c (x) is the value of output c of the discriminator. <ref type="bibr" target="#b121">Odena (2016)</ref> independently proposed the same idea around the same time. <ref type="bibr" target="#b36">Dai et al. (2017)</ref> provided some theoretical analysis of this framework. They argued that, for the method to improve performance over the discriminator by itself, the distribution modelled by the generator should complement the true data distribution: it should assign high probability density to regions in the input space that have low density in the true distribution.</p><p>Instead of using the discriminator for determining both the class and the authenticity of data points, one can also use a separate discriminative model for each task. This is the approach taken in triple adversarial networks, where one discriminator is used for classifying data points, and another is tasked with distinguishing real from fake data <ref type="bibr" target="#b95">(Li et al. 2017)</ref>.</p><p>For an extensive overview of GANs, their applications and their extensions, we refer the reader to the summary of the 2016 NIPS tutorial on GANs by <ref type="bibr" target="#b60">Goodfellow (2017)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4.3">Variational autoencoders</head><p>Aside from GANs, further efforts have been made in recent years towards constructing semi-supervised deep generative models. One notable example is the proposal of variational autoencoders (VAE) and their application to semi-supervised learning.</p><p>Proposed by <ref type="bibr" target="#b81">Kingma and Welling (2013)</ref>, variational autoencoders are a type of latent variable model that treats each data point x as being generated from a vector of latent variables z. Traditional latent variable models, such as autoencoders, generally yield a model with a highly complex distribution p(z), which makes it very difficult to use them for sampling. Contrastingly, VAEs constrain p(z) to be a simple distribution, such as a standard multivariate Gaussian distribution, from which sampling is straightforward. The transformation from p(z) to some more complex distribution p(x|z) is then left to a decoder.</p><p>At training time, an encoder is used to determine the parameters of a distribution p(z|x) based on a data point x. To generate reconstructions of x, latent vectors z can then be sampled from this distribution and passed through the decoder. The decoder and encoder are jointly trained, minimizing a combined cost function consisting of (1) the Kullback-Leibler divergence between the posterior distribution p(z|x) and some simple prior distribution p(z), and (2) the reconstruction cost of the output of the autoencoder for input data. The first term is crucial: it allows the decoder to be used as a generative model, taking in latent vectors that are directly sampled from p(z).</p><p>For brevity, we do not go into too much detail regarding the training procedure of VAEs, which includes a nontrivial backpropagation step due to the sampling procedure; instead, we refer the reader to the VAE tutorial by <ref type="bibr" target="#b47">Doersch (2016)</ref>. <ref type="bibr" target="#b80">Kingma et (2014)</ref> propose a two-step model to use VAEs for semi-supervised learning. In the first step, a VAE is trained on both the unlabelled and labelled data to extract meaningful latent representations from data points. By itself, this can be seen as an unsupervised preprocessing step, allowing the latent representations to be used by any supervised classifier. In the second step, they implement a VAE in which the latent representation is augmented with the label vector y i , which contains the one-hot-encoded true labels for labelled data points and is treated as an additional latent variable for unlabelled data. In addition to the decoder, a classification network is introduced that infers the label predictions <ref type="bibr" target="#b80">(Kingma et al. 2014)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Transductive methods</head><p>The semi-supervised learning methods described in the previous sections were all inductive algorithms: their primary goal was to use both labelled and unlabelled data to construct a procedure capable of providing label predictions for data points in the entire input space. In inductive learners, we can therefore clearly distinguish between a training phase and a testing phase: in the training phase, labelled data (X L , y L ) and unlabelled data X U are used to construct a classifier. In the testing phase, this classifier is used to independently classify the unlabelled or other, previously unseen data points.</p><p>In this section, we discuss transductive algorithms, which constitute the second major class of semi-supervised learning methods. Unlike inductive algorithms, transductive algorithms do not produce a predictor that can operate over the entire input space. Instead, transductive methods yield a set of predictions for the set of unlabelled data points provided to the learning algorithm. Contrary to the inductive setting, we thus cannot distinguish between a training phase and a testing phase: transductive algorithms are provided with labelled data (X L , y L ) and unlabelled data X U , and output exclusively predictions ŷU for the unlabelled data.</p><p>Transductive methods typically define a graph over all data points, both labelled and unlabelled, encoding the pairwise similarity of data points with possibly weighted edges <ref type="bibr" target="#b206">(Zhu 2005</ref>). An objective function is then defined and optimized, in order to achieve two goals:</p><p>1. For labelled data points, the predicted labels should match the true labels. 2. Similar data points, as defined via the similarity graph, should have the same label predictions.</p><p>In other words, these methods encourage consistent predictions for similar data points while taking into account the known labels. A close similarity exists between these methods and the inductive manifold-based methods from Sect. 6.3. Both methods construct a graph over the data points and use pairwise similarity between data points to approximate more complex structures. The only major difference between them is that the inductive methods seek to obtain a classifier that can operate across the entire input space, whereas transductive methods only yield predictions for a given set of unlabelled data points. Collectively, these methods are often referred to as graph-based methods <ref type="bibr" target="#b206">(Zhu 2008</ref>).</p><p>In Sect. 6.3, we focused on the interpretation and motivation of graph-based techniques from the theoretical perspective of manifolds. The development of transductive graph-based methods, however, has generally been driven directly by the two optimization criteria outlined above. This section, in which we discuss transductive semi-supervised learning, follows that line of reasoning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">A general framework for graph-based methods</head><p>Graph-based semi-supervised methods generally involve three separate steps: graph creation, graph weighting and inference <ref type="bibr" target="#b76">(Jebara et al. 2009;</ref><ref type="bibr" target="#b105">Liu et al. 2012</ref>). In the first step, nodes (representing data points) in the graph are connected to each other, based on some similarity measure. In the second step, the resulting edges are weighted, yielding a weight matrix. The first two steps together are commonly referred to as the graph construction phase. After graph construction, we have a graph consisting of a set of nodes V = {v 1 , . . . , v n }, corresponding to the data points, and an n × n weight matrix W containing the edge weights for all pairs of nodes, where an edge weight of zero indicates that no edge is present. In the remainder of this section, we use the terms node and data point interchangeably in the context of graph-based methods.</p><p>Once the graph is constructed, it is used to obtain predictions ŷU for the unlabelled data points. The general form of objective functions for transductive graph-based methods contains one component for penalizing predicted labels that do not match the true label, and another component for penalizing differences in the label predictions for connected data points. Formally, given a supervised loss function for the labelled data and an unsupervised loss function U for pairs of labelled or unlabelled data points, transductive graph-based methods attempt to find a labelling ŷ that minimizes</p><formula xml:id="formula_31">λ • l i=1 ( ŷi , y i ) + n i=1 n j=1 W i j • U ( ŷi , ŷ j ),<label>(8)</label></formula><p>where λ governs the relative importance of the supervised term. Furthermore, some graphbased methods impose an additional unary regularization term on the unlabelled predictions. This general framework for graph-based methods allows for a multitude of variations in each of its steps. The formulation is commonplace in graph-based methods, and most graph-based inference algorithms can be shown to fit into this framework <ref type="bibr" target="#b14">(Bengio et al. 2006;</ref><ref type="bibr" target="#b155">Subramanya and Talukdar 2014)</ref>. It is also present in the manifold regularization framework <ref type="bibr" target="#b11">(Belkin et al. 2005</ref>) discussed in Sect. 6.3. For graph construction, most graph-based methods rely on the local similarity between data points in the input space, connecting data points with similar features. In that case, they implicitly rely on the smoothness assumption in addition to the manifold assumption. A parallel can be drawn between such graph-based methods and supervised nearest-neighbour methods. The latter predict the label of an unlabelled data point by looking at the labels of similar (i.e. nearby) labelled data points; graph-based methods also consider the similarity between pairs of unlabelled data points. Using that information, labels can be propagated transitively from a labelled data point to an unlabelled data point through other data points, both labelled and unlabelled. In that light, some graph-based methods can be seen as semisupervised extensions to nearest-neighbour methods.</p><p>The spectrum of graph-based semi-supervised learning methods can be effectively structured based on the different approaches in the two main phases, i.e. graph construction and inference. Early work on graph-based methods focused mainly on the second phase, leaving graph construction a scarcely studied topic. <ref type="bibr" target="#b206">Zhu (2008)</ref> noted that this imbalance might be unjust, and that graph construction can have significant impact on classifier performance. Later work has addressed this imbalance, and graph construction has since become an area of substantial research interest <ref type="bibr" target="#b42">(de Sousa et al. 2013)</ref>.</p><p>Graph-based transductive methods were introduced in the early 2000s, and graph-based inference methods were particularly intensively studied during the subsequent decade. A substantial portion of research conducted in this field is covered in the semi-supervised learning survey by <ref type="bibr" target="#b206">Zhu (2008)</ref> and in the doctoral thesis of <ref type="bibr" target="#b206">Zhu (2005)</ref>. Furthermore, Subramanya and <ref type="bibr" target="#b155">Talukdar (2014)</ref> recently published a book on graph-based methods.</p><p>Following the general chronological order of research in the field of graph-based methods, we begin by outlining different approaches to solving the inference problem. After that, we provide an overview of research on graph construction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Inference in graphs</head><p>The inference process in transductive methods consists of forming predictions ŷU for the unlabelled data points X U . If the predicted labels of the labelled data are not fixed to the true labels in the inference process, optimization proceeds over the entire set of predicted labels ŷ.</p><p>Many approaches have been suggested for tackling the optimization of Expression 8; generally, these differ in the specific choices of the loss functions and U and the trade-off parameter λ. Furthermore, some methods infer only the most likely label assignment ŷ, while others estimate the marginal probability distributions. Jointly, these variations give rise to a plethora of different graph-based inference methods.</p><p>Although the general objective function from Expression 8 applies to the multiclass setting as well, many graph-based methods do not naturally extend beyond binary classification. The inference methods we focus on in the following mostly consider the binary classification case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.1">Hard label assignments: graph min-cut</head><p>The first graph-based semi-supervised classification method was proposed by <ref type="bibr" target="#b19">Blum and Chawla (2001)</ref>, who experimented with graph construction using a k-nearest neighbours algorithm and the -neighbourhood (connecting pairs of data points with distance smaller than ). They kept the edge weights fixed and uniform, but experimented with changing the weight of edges between unlabelled data points relative to other edges.</p><p>Once the graph is constructed, the optimization problem is approached from a min-cut perspective. Specifically, a single source node v + is added and connected with infinite weight to the positive data points, and a single sink node v − , connected with infinite weight to the negative data points. Determining the minimum cut, then, corresponds to finding a set of edges with minimal combined weight that, when removed, result in a graph with no paths from the source node to the sink node. All unlabelled nodes in the resulting graph that are in the component containing v + are labelled as positive, and all unlabelled nodes that are in the component containing v − are labelled as negative.</p><p>The min-cut approach can be seen to minimize the general objective function of Expression 8 as λ approaches infinity (fixing the predictions on labelled data points to their true labels) and U ( ŷi , ŷ j ) = 1 { ŷi = ŷ j } , where 1 is the indicator function. Note that, assuming labels 0 and 1 are used, the loss function for unlabelled data corresponds to quadratic cost, i.e. 1 { ŷi = ŷ j } = ( ŷi − ŷ j ) 2 . We can write the corresponding objective function as</p><formula xml:id="formula_32">λ • l i=1 ( ŷi − y i ) 2 + n i=1 n j=1 W i j • ( ŷi − ŷ j ) 2 . (<label>9</label></formula><formula xml:id="formula_33">)</formula><p>Note that this objective function can be written in an alternate form, using the graph Laplacian L = D − W (where D is the diagonal matrix containing the degree for node i at D ii ) as follows:</p><formula xml:id="formula_34">λ • l i=1 ( ŷi − y i 2 + 2 • ŷ • L • ŷ.</formula><p>Pang and <ref type="bibr" target="#b124">Lee (2004)</ref> used the min-cut approach for classification in the context of sentiment analysis. They note that, instead of fixing the predicted labels of labelled data to their true labels, one can also assign finite weight to the edges connecting the source and sink nodes to the labelled data points, indicating confidences in either classification from the perspective of the individual data point.</p><p>The min-cut approach can easily lead to degenerate cuts, yielding a solution where almost all unlabelled data fall within the same graph component. This behaviour originates from the fact that more balanced cuts generally have more potential edges to cut: when a cut yields a split into negative nodes V − and positive nodes V + , the number of edges to cut is potentially <ref type="bibr" target="#b78">Joachims (2003)</ref> proposed to normalize the objective function of min-cut based on this potential number of edges being cut, using spectral methods to solve the resulting optimization problem.</p><formula xml:id="formula_35">|V + | • |V − |.</formula><p>Since the min-cut algorithm optimizes over a binary vector, it does not permit the extraction of marginal probabilities. To solve this problem, <ref type="bibr" target="#b20">Blum et al. (2004)</ref> proposed to construct an ensemble of min-cut classifiers, each finding the minimum cut on a randomly perturbed version of the constructed graph, obtained by adding noise to the edge weights. The prediction probabilities are then simply calculated as the fraction of classifiers predicting a given label.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.2">Probabilistic label assignments: Markov random fields</head><p>The lack of a principled, efficient way of estimating classification probabilities is a fundamental disadvantage of the min-cut approach to graph-based inference. In many cases, we wish to estimate the probability P(y i = c) that an unlabelled data point x i has label c. Standard min-cut, however, only provides hard classifications (i.e. it only outputs class labels and no probabilities). Approaching graph-based methods from the perspective of Markov random fields provides a potential solution to this problem. In the following, with a slight abuse of notation, we use X and x to denote random variables and their realizations, respectively, rather than data points.</p><p>The Hammersley-Clifford theorem states that a probability distribution P(X = x) for random variables X 1 , . . . , X n corresponds to a Markov random field if a graph G exists such that the joint probability function P(X = x) can be factorized over the (maximal) cliques of G <ref type="bibr" target="#b70">(Hammersley and Clifford 1971)</ref>. In other words, P(X = x) corresponds to a Markov random field formed by G if</p><formula xml:id="formula_36">P(X = x) = 1 Z • c∈C G ψ c (x c ),</formula><p>where Z is a normalization constant, C G is the set of cliques in G, ψ c is an arbitrary function, and x c contains the realizations of random variables in clique c. Using the Hammersley-Clifford theorem, we can show that the general minimization for graph-based methods, formulated in Expression 8, can be expressed in the form of a Markov random field. Let G denote the graph with weight matrix W obtained in the graph construction phase, and let Ŷ = ( Ŷ1 , . . . , Ŷn ) be a collection of random variables corresponding to the predicted labels (i.e. 0 or 1) for data points x 1 , . . . , x n . We extend G by connecting each node Ŷi corresponding to a labelled data point x i to an auxiliary node Y i , corresponding to a random variable which can only attain the true label y i . We denote the entire collection of This situation is depicted in Fig. <ref type="figure" target="#fig_1">5</ref>. The filled nodes Ŷ and the edges between them correspond to the original graph G; the unfilled nodes marked with plus and minus signs represent the auxiliary nodes Y , and are connected only to the corresponding filled node.</p><p>Recall that a clique is a subset of nodes within which every pair of nodes is connected by an edge. A maximal clique, then, is a clique that cannot be expanded, i.e. to which no nodes can be added such that the resulting subset of nodes also forms a clique. We note that every pair of nodes that is connected by an edge is part of at least one clique. Thus, if we can find an expression of the form 1 Z • (u,v)∈E ψ {u,v} <ref type="bibr">({u, v})</ref> for P( Ŷ = ŷ), the probability distribution corresponds to a Markov random field. We proceed to show that we can express the cost function from Expression 8 such that minimizing it corresponds to maximizing the probability P( Ŷ = ŷ). We can distinguish between two different types of edges: those between two normal nodes u, v from Ŷ , and those between a normal node and its auxiliary node (u from Ŷ , v from Y , or vice versa). Let us define ψ(•) for these two cases independently:</p><formula xml:id="formula_37">ψ({ ŷi , ŷ j }) = exp(−W i j • U ( ŷi , ŷ j )) if v i , v j ∈ Ŷ , ψ({ ŷi , y i }) = exp(− ( ŷi , y i )) if v i ∈ Ŷ , v j ∈ Y or v i ∈ Y , v j ∈ Ŷ .</formula><p>The probability P( Ŷ = ŷ) then becomes</p><formula xml:id="formula_38">1 Z • (u,v)∈E ψ {u,v} ({u, v}) = exp ⎛ ⎜ ⎝− y i ∈Y ( ŷi , y i ) − ŷi , ŷ j ∈ Ŷ U ( ŷi , ŷ j ) ⎞ ⎟ ⎠ ,</formula><p>where the normalization constant Z can be calculated by summing over all possible configurations of Y . Although this is computationally too expensive for all practical purposes, the normalization constant is irrelevant in the context of maximum-likelihood estimation. The negative logarithm of the unnormalized probability, then, is exactly equal to the general loss function for graph-based methods from Expression 8. Maximizing the probability P(Y = y), we obtain the mode of the Markov random field, i.e. its most likely configuration. This solution is exactly the solution found when minimizing the min-cut objective <ref type="bibr" target="#b19">(Blum and Chawla 2001)</ref>.</p><p>In the inductive semi-supervised classification setting, classifier predictions are independent, i.e. P( Ŷ = ŷ) = p(Y 1 = ŷ1 ) • p( Ŷ2 = ŷ2 ) • . . . • p( Ŷn = ŷn ). In transductive, graph-based methods, however, this is generally not the case: predictions are dependent on each other. Therefore, the most probable label assignment ŷ generally does not correspond to the label assignment minimizing the expected error rate. To find the latter, each data point x i would have to be assigned the label that maximizes the marginal probability for that data point. Unfortunately, finding the marginal probabilities of a random field is not trivial. <ref type="bibr" target="#b208">Zhu and Ghahramani (2002b)</ref> attempted the calculation of the marginal probabilities via Markov chain Monte Carlo (MCMC) sampling. They experimented with Metropolis and Swendsen-Wang sampling and reported low computational efficiency. <ref type="bibr" target="#b146">Shental and Domany (2005)</ref> used a multicanonical MCMC method to compute the marginal probabilities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.3">Efficient probabilistic label assignments: Gaussian random fields</head><p>There is no closed-form solution for calculating the marginal probabilities in the Markov random field with binary labels described previously. However, when the random variables Ŷ are relaxed to take real values, a closed-form solution exists. This approach was proposed by <ref type="bibr" target="#b209">Zhu et al. (2003)</ref>; it involves fixing the labels of the labelled data points and using quadratic cost for the pairs of predictions ŷi , ŷ j ∈ R. This results in an objective function identical to that used in the min-cut formulation (see Expression 9), except for the relaxation of the predictions to real numbers.</p><p>Using real-valued predictions with a quadratic loss function, the exponential form for P( Ŷ = ŷ) is a multivariate Gaussian distribution. Thus, a closed-form solution for the mode of the field, which equals its mean, exists. Furthermore, the marginal probability distribution P( Ŷi = ŷi ) is Gaussian as well, allowing for computation of the label predictions minimizing the error rate. This is why the random field is called a Gaussian random field.</p><p>Recall from Sect. 6.3 that we defined the graph Laplacian as L = D − W , where D is the degree matrix (i.e. a diagonal matrix with the vertex degrees on the diagonal). <ref type="bibr" target="#b209">Zhu et al. (2003)</ref> showed that the prediction function is harmonic, i.e. L • ŷ = 0 at unlabelled data points, and is equal to the true label at labelled data points. The predicted label at each unlabelled data point is equal to the average of the predictions of its neighbours, i.e.</p><formula xml:id="formula_39">ŷi = 1 D ii • v j ∈N (v i ) W i j • ŷ j , for i = l + 1, . . . , n,</formula><p>where N (v i ) denotes the neighbourhood of node v i , that is, N (v i ) = {v j : W i j = 0}. Furthermore, the solution is unique and ŷi ∈ [0, 1] for each i. Thus, label predictions can be easily obtained from the solution using thresholding.</p><p>Computation of the marginals of the Markov random field involves an inversion of the submatrix L U corresponding to the unlabelled data points in the graph Laplacian. This is computationally expensive for large numbers of unlabelled data points. Several other approaches have been proposed for finding the solution to the harmonic function, including loopy belief propagation and a conjugate gradient method <ref type="bibr" target="#b209">(Zhu et al. 2003)</ref>.</p><p>Before proposing the Gaussian random fields approach to graph-based methods, <ref type="bibr" target="#b207">Zhu and Ghahramani (2002a)</ref> introduced the label propagation algorithm for inference on graphs. It is an iterative algorithm that computes soft label assignments ŷi ∈ R by pushing (propagating) the estimated label at each node to its neighbouring nodes based on the edge weights. In other words, the new estimated label at each node is calculated as the weighted sum of the labels of its neighbours. In matrix notation, let</p><formula xml:id="formula_40">A i j = W i j v k ∈N (v i ) W ik</formula><p>denote the transition matrix. The label propagation algorithm then consists of two steps, which are repeated until the label assignment ŷ converges. Starting with an initial label assignment ŷ, which is random for the unlabelled data points and equal to the true labels for the labelled data points:</p><p>1. Propagate labels from each node to the neighbouring nodes: ŷ = A • ŷ.</p><p>2. Reset the predictions of the labelled data points to the corresponding true labels. <ref type="bibr" target="#b206">Zhu (2005)</ref> showed that the algorithm is guaranteed to converge to the harmonic function solution described earlier. They also showed that the label propagation approach can be interpreted as a random walk with transition matrix A, which stops when a labelled node is hit. <ref type="bibr" target="#b187">Wu et al. (2012a)</ref> cast this procedure in a framework they call partially absorbing random walks, where they, instead of deterministically stopping when a labelled node is hit, stochastically determine whether to stop (absorb) or continue the random walk. The label propagation approach is closely related to the Markov random walks approach by <ref type="bibr" target="#b157">Szummer and Jaakkola (2002)</ref>. <ref type="bibr" target="#b10">Belkin et al. (2004)</ref> considered a similar objective function and provided some theoretical analysis. <ref type="bibr" target="#b3">Azran (2007)</ref> proposed a random walk approach, where walks originate in unlabelled nodes and the labelled nodes are absorbing states. The probability that an unlabelled data points attains a certain label is then derived from the probability that a walk starting from the unlabelled node ends up in a labelled node of the corresponding class, as the length of the random walk approaches infinity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.4">Handling label noise and irregular graphs: local and global consistency</head><p>The Gaussian random fields method has two drawbacks <ref type="bibr" target="#b155">(Subramanya and Talukdar 2014)</ref>. Firstly, since the true labels are clamped to the labelled data points, it does not handle label noise well. Secondly, in irregular graphs, the influence of nodes with a high degree is relatively large. An approach closely related to the Gaussian random fields method that addresses these two issues was proposed by <ref type="bibr" target="#b201">Zhou et al. (2004)</ref>. It is commonly known as the local and global consistency (LGC) method, referring to the observation that graph-based methods promote consistency of labels on manifolds (global) and nearby in the input space (local). Note that, in the following, we assume Y = {−1, 1}.</p><p>To address the first issue, LCF does not clamp the true labels to the labelled data points, but rather penalizes the squared error between the true label and the estimated label. The second issue is addressed by regularizing the penalty term for unlabelled data points by the node degrees. Furthermore, predictions for the unlabelled data points are regularized by pulling them towards zero <ref type="bibr" target="#b14">(Bengio et al. 2006)</ref>. We can write the corresponding objective function in the general form as</p><formula xml:id="formula_41">l i=1 ( ŷi − y i ) 2 + n i=l+1 ŷ2 i + λ U • n i=1 n j=1 W i j • ŷi √ D ii − ŷ j D j j 2 ,</formula><p>where λ U governs the weight of the penalization of inconsistencies in label predictions between neighbours in the graph. Note that, like for the min-cut and MRF objectives, the last term of the objective function can be expressed using matrix notation. The only difference is that LGC uses the normalized graph Laplacian L = D − 1 2 • L • D − 1 2 instead of the unnormalized Laplacian L = D − W in that term. Like Gaussian random fields, this formalization admits a closed-form solution and a relatively efficient iterative approach to optimization. In this algorithm, the label vector ŷt+1 at iteration t + 1 is calculated based on that at iteration t, using the update rule</p><formula xml:id="formula_42">ŷt+1 = α • L • ŷt + (1 − α) • y,</formula><p>where y is 0 for the unlabelled data points, and α governs the relative importance of the calculated label vector versus the base label vector y. This algorithm is often referred to as label spreading.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.5">Further research on graph-based inference</head><p>The previously described approaches, and in particular label propagation, have been the de facto standard approach to the inference phase in graph-based semi-supervised classification. Several variants and extensions to the approach have been proposed, which we briefly summarize here. <ref type="bibr" target="#b7">Baluja et al. (2008)</ref> applied graph-based methods to recommender systems (in particular, video suggestions to users). They proposed adsorption, a heuristic algorithm for predicting the label ŷi of node i by performing a random walk starting at node v i . At each step in the random walk, the process can either continue to the next step (continue), accept the label of a labelled node as the prediction (injection), or explicitly predict no label (abandonment). The last option corresponds to a dummy prediction, which specifically indicates that the learning algorithm is unable to produce a confident prediction. The option chosen by the algorithm is dependent on two hyperparameters governing the relative frequencies of the three options. Heuristic approaches to hyperparameter optimization have been proposed by <ref type="bibr" target="#b7">Baluja et al. (2008)</ref> and <ref type="bibr" target="#b161">Talukdar et al. (2008)</ref>. The algorithm has been successfully applied to video recommendation, but is difficult to analyze theoretically, due to its many heuristic components. <ref type="bibr" target="#b159">Talukdar and Crammer (2009)</ref> found that there is no objective function that is minimized by the adsorption algorithm, and proposed a modification to the algorithm for which such an objective function does exist.</p><p>The previously described graph-based methods can be sensitive to class imbalance <ref type="bibr" target="#b206">(Zhu 2008)</ref>. Several approaches have been proposed to mitigate this problem. <ref type="bibr" target="#b209">Zhu et al. (2003)</ref> suggested to adjust the classification threshold such that the predicted label proportions correspond to predefined label proportions. <ref type="bibr" target="#b179">Wang et al. (2008a)</ref> developed an optimization scheme that is less sensitive to noise in the true labels and that mitigates the problem of sensitivity to class imbalance by altering the influence of labelled samples based on the label proportions. They modified the objective function to optimize over real-valued predictions as well as binary label assignments; their approach penalizes the difference between real-valued and binary predictions. It then proceeds to optimize the objective function by optimizing, in an alternating fashion, the real-valued and binary label assignments. Later, <ref type="bibr" target="#b180">Wang et al. (2013)</ref> considered the same approach from a graph max-cut perspective.</p><p>In structured output learning, the labels of data points cannot be captured using simple binary or real-valued representations. For instance, the output labels might be better represented with histograms or probability distributions in some cases (e.g. when predicting the relative traffic density at a location over a 24-hour cycle). <ref type="bibr">Subramanya and</ref><ref type="bibr">Bilmes (2008, 2011)</ref> propagate discrete probability distributions through a graph, based on the KLdivergence between the distributions of different nodes. As an alternative to KL-divergence, <ref type="bibr" target="#b150">Solomon et al. (2014)</ref> proposed to use the Wasserstein distance to measure the similarity between the discrete distributions of neighbouring nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Graph construction</head><p>Arguably, graph construction is the most important aspect of graph-based methods: in order for inference to work, the constructed graph must accurately capture local similarities. Initial research on graph-based methods was chiefly focused on the inference phase, and graph construction was not well-studied <ref type="bibr" target="#b206">(Zhu 2008)</ref>. In recent years, however, this has changed. Extensive experiments have been conducted on different graph construction algorithms, and new methods have been introduced <ref type="bibr" target="#b42">(de Sousa et al. 2013;</ref><ref type="bibr" target="#b76">Jebara et al. 2009;</ref><ref type="bibr" target="#b155">Subramanya and Talukdar 2014)</ref>.</p><p>Since the nodes of the graph correspond to the data points (both labelled and unlabelled), the graph construction phase amounts to forming edges between nodes (yielding the adjacency matrix) and attaching weights to them (yielding the weight matrix). In many cases, the similarity measure governing the connectivity between nodes is also used to construct the weight matrix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.1">Adjacency matrix construction</head><p>The first step in constructing the graph is the creation of an adjacency matrix, whose elements indicate the presence of edges between pairs of nodes. Three popular methods for determining edges exist and are outlined below. We note that the first two methods, -neighbourhood and k-nearest neighbours, are local in the sense that a set of neighbours can be determined independently for each node. In other words, the construction of a neighbourhood for a node v i does not influence neighbourhood construction for another node v j (unless v i is a neighbour of v j ). The third method, b-matching, on the other hand, optimizes a global objective, and nodes that are far apart can significantly influence each other's connectivity.</p><p>-neighbourhood. One of the first methods to be used in graph construction was theneighbourhood method, which simply connects each node to all nodes to which the distance is at most <ref type="bibr" target="#b19">(Blum and Chawla 2001)</ref>. In other words, an edge between x i and x j is created if, and only if, d(x i , x j ) ≤ , where d(•, •) is some distance measure (usually Euclidean distance). The structure of the resulting graph is highly dependent on the choice of and the distance measure. Furthermore, since is fixed, it does not work well if the scale of patterns varies across the given input data. Because of these limitations, the -neighbourhood method is rarely used in practice <ref type="bibr" target="#b42">(de Sousa et al. 2013;</ref><ref type="bibr" target="#b76">Jebara et al. 2009)</ref>.</p><p>k-nearest neighbours. The most common graph construction method for transductive methods is the k-nearest neighbours method, where each node is connected to its k nearest neighbours in the input space according to some distance measure <ref type="bibr" target="#b19">(Blum and Chawla 2001)</ref>. Using vanilla k-nearest neighbours, however, gives rise to a problem: since k-nearest neighbours is not symmetric, some additional processing is often required to obtain an undirected graph. Two options are commonly considered: one (symmetric k-nearest neighbours) constructs an edge if i is in the k-neighbourhood of j or vice versa, and the other (mutual k-nearest neighbours) constructs an edge if i and j are both in each other's k-neighbourhood <ref type="bibr" target="#b42">(de Sousa et al. 2013)</ref>. The difference between the -neighbours and k-nearest neighbours methods has been extensively studied by <ref type="bibr" target="#b109">Maier et al. (2009)</ref> in the context of clustering methods. b-matching. The postprocessing step used when constructing the graph with k-nearest neighbours generally results in a graph where not all nodes have exactly k neighbours. When symmetric k-nearest neighbours is used, it often occurs that some nodes have much higher degrees than others. <ref type="bibr" target="#b76">Jebara et al. (2009)</ref> showed that this can negatively impact the final performance of the classifier. They proposed an edge construction method that enforces the regularity of the constructed graph, i.e. ensures that each node has the same number of neighbours, and that the nodes have exactly the requested number of edges. Their approach is inspired by matching, a concept from graph theory where one tries to find a subset of edges in a graph such that the edges do not share any vertices. In their method, referred to as bmatching, the objective is to find the subset of edges in the complete graph such that (1) each node has degree b and (2) the sum of the edge weights is maximized.</p><p>Note that, in the original study by <ref type="bibr" target="#b76">Jebara et al. (2009)</ref>, instead of maximizing the sum of edge weights, the objective is to minimize the sum of the distances between the remaining edges. However, since they define the distance matrix C as C i j = W ii + W j j − 2W i j , these notions are equivalent. The corresponding optimization problem is formulated as minimize</p><formula xml:id="formula_43">A∈B n×n n i=1 n j=1 A i j • C i j subject to n j=1 A i j = b i= 1, . . . , n, A ii = 0 i = 1, . . . , n, A i j = A ji i, j = 1, . . . , n.</formula><p>It can be shown that this corresponds to the optimization problem solved by the k-nearest neighbour algorithm, with the addition of the constraint A i j = A ji , which ensures that a symmetric graph is constructed without the need for a postprocessing step. However, the most efficient known algorithm for the b-matching optimization problem has time complexity O(n 2.5 ) and requires several assumptions that are not always satisfied in real-world scenarios <ref type="bibr" target="#b74">(Huang and Jebara 2011)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.2">Graph weighting</head><p>The graph weighting phase, which forms the second step of graph construction, determines the weights for the edges in the graph. In many cases, the weights correspond to the similarity measure used for constructing the edges. For instance, a Gaussian kernel is often used to determine the connectivity of the graph via k-nearest neighbours as well as the edge weights. In that case, the graph construction process is usually considered as consisting of weighting and sparsification. First, a complete adjancency matrix K is constructed using some kernel function k for all pairs of nodes such that K i j = k(x i , x j ); then, the weight matrix W is obtained by sparsification, i.e. by removing edges from K .</p><p>Several methods for edge weighting have been suggested in the literature. One of the most popular weighting schemes is Gaussian edge weighting <ref type="bibr" target="#b42">(de Sousa et al. 2013;</ref><ref type="bibr" target="#b76">Jebara et al. 2009)</ref>, where</p><formula xml:id="formula_44">W i j = exp −||x i − x j || 2 2σ 2 ,</formula><p>and σ 2 is the variance of the Gaussian kernel. Note that this corresponds to an isotropic Gaussian kernel; a non-isotropic Gaussian kernel can also be used. <ref type="bibr" target="#b72">Hein and Maier (2007)</ref> suggested a local variant of Gaussian edge weighting for k-nearest neighbour graph construction, where the variance for a pair of nodes i and j is based on the maximum distance to i and j's nearest neighbours. They define the weight as</p><formula xml:id="formula_45">W i j = exp −||x i − x j || 2 (max{h i , h j }) 2 ,</formula><p>where</p><formula xml:id="formula_46">h i = max v k ∈N (v i ) ||x i − x k || 2 , i.e</formula><p>. the maximum squared distance between i and its neighbours. <ref type="bibr" target="#b19">Blum and Chawla (2001)</ref> suggested altering the importance of different features in the similarity calculation based on their information gain. <ref type="bibr" target="#b76">Jebara et al. (2009)</ref> experimented with binary weights, where W i j = 1 if nodes i and j are connected, and W i j = 0 otherwise. We note that, in all weighting schemes described above, W i j = 0 for unconnected nodes. The approaches described above determine edge weights W i j based solely on the pairwise similarity of nodes x i and x j . However, it is also possible to take the entire neighbourhood of a node into account when determining edge weights. <ref type="bibr" target="#b178">Wang and Zhang (2008)</ref> introduced the linear neighbourhood propagation (LNP) algorithm, which is based on the assumption that the graph should be constructed such that any data point x i can be approximated as a linear combination of its neighbours, i.e.</p><formula xml:id="formula_47">x i = v j ∈N (v i ) W i j • x j + i</formula><p>for some vector i of low magnitude. In this equation, the unknowns are the weights W i j of the contributions of each neighbour to the approximation of x i . The approach by Wang and Zhang consists of estimating W such that the difference between the approximated and true data points is minimized, while ensuring that the weights are positive and that the edge weights for each node sum to 1. This leads to the following optimization problem: minimize</p><formula xml:id="formula_48">W ∈R n×n n i=1 ||x i − xi || 2 subject to v j ∈N (v i ) W i j = 1 i = 1, . . . , n W i j ≥ 0 i, j = 1, . . . , n<label>(10)</label></formula><p>where xi = v j ∈N (v i ) W i j • x j is the reconstruction of x i . This formulation is identical to locally linear embedding <ref type="bibr" target="#b140">(Roweis and Saul 2000)</ref>, with the addition of the two constraints. LNP can be solved via a series of quadratic programming problems (one for each node).</p><p>Crucially, this depends on the fact that edge weight symmetry is not enforced, i.e. it is not necessarily the case that W i j = W ji ; because of this, the weights W i j are independent of W k j for k = i. <ref type="bibr" target="#b79">Karasuyama and Mamitsuka (2013)</ref> combined locally linear embedding with a local similarity measure to obtain the edge weights. In particular, given a pre-constructed graph (for instance, using the k-nearest neighbour algorithm), they calculate the weight between two connected nodes using a Gaussian kernel with diagonal covariance matrix. This matrix is constructed by finding the coefficients that minimize the local reconstruction error. <ref type="bibr" target="#b102">Liu and Chang (2009)</ref> construct the weight matrix with a modification of the symmetric k-nearest neighbours method: two nodes are connected if either of them is in the other's k-neighbourhood, but the weight of the two connections is summed if they are both in each other's neighbourhoods. In other words, the modified weight matrix W is constructed based on the original weight matrix Ŵ as follows:</p><formula xml:id="formula_49">W i j = ⎧ ⎪ ⎨ ⎪ ⎩ Ŵi j + Ŵ ji , if v i ∈ N (v j ) and v j ∈ N (v i ) Ŵ ji , if v i ∈ N (v j ) and v j / ∈ N (v i ) Ŵi j , otherwise</formula><p>de Sousa et al. ( <ref type="formula">2013</ref>) compared the influence of several of these methods on the performance of transductive algorithms. In particular, they compared Gaussian weighting (where edges are weighted using an isotropic Gaussian kernel), the locally normalized Gaussian weighting approach by <ref type="bibr" target="#b72">Hein and Maier (2007)</ref>, and LNP <ref type="bibr" target="#b178">(Wang and Zhang 2008)</ref>; somewhat surprisingly, their best results were obtained using Gaussian weighting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.3">Simultaneous graph construction and weighting</head><p>The LNP algorithm described earlier (see Sect. 7.3.2) assumes that the graph structure (i.e. the set of edges) is known and fixed, and determines the edge weights for each node locally, based on the assumption that each node can be reconstructed as a linear combination of its neighbours. Instead of fixing the graph structure, however, one can also simultaneously infer the graph structure and edge weights by linearly reconstructing nodes based on all other nodes.</p><p>Such an approach was first proposed by <ref type="bibr" target="#b192">Yan and Wang (2009)</ref>, based on the sparse coding approach formulated for face recognition by <ref type="bibr" target="#b186">Wright et al. (2009)</ref>. The idea is to find, for each node x i , a coefficient vector a ∈ R n denoting the contributions of all other nodes to the reconstruction of x i . This reconstruction is then calculated as xi = (X ) •a, where X ∈ R n×d denotes the full data matrix, but with a row of zeroes at index i (since a node cannot contribute to its own reconstruction). Note that, unlike the LNP reconstruction from Problem 10 above, where only predetermined neighbours contribute to the reconstruction, here, all n − 1 other nodes can be used. The corresponding basic optimization problem attempts to minimize, for each data point, the norm of the error vector i = xi − x i , expressing the difference between the reconstruction and the true data. Crucially, unlike LNP, which makes use of the L2 norm and thus promotes non-sparse solutions, <ref type="bibr" target="#b192">Yan and Wang (2009)</ref> use the L1 norm.</p><p>To avoid an underdetermined system of equations in some cases, the final optimization problem penalizes both the norm of the reconstruction coefficients and the noise vector. Let B = [(X ) , I d ] be the concatenation of the data matrix X and the d × d identity matrix I d . Each data point x i can then be expressed as x i = B • a . Here, a consists of the coefficient vector a = [a 1 , . . . , a n ] and the error vector = [a n+1 , . . . , a n+d ]. The final optimization problem for finding the optimal coefficients is then defined as follows for each node x i : <ref type="bibr">(11)</ref> where || • || 1 is the L1 norm. Now, let a i denote the coefficient vector found for node i. The final graph is then constructed by simply adding an edge between nodes i and j if, and only if, a i j = 0, and setting the edge weights to the magnitude of the coefficient, i.e. W i j = |a i j |. We note that this approach does not yield an undirected graph. A variant of the sparse coding method was proposed by <ref type="bibr" target="#b71">He et al. (2011)</ref>, who a constraint that all coefficients be non-negative to the objective from Problem 11 above.</p><formula xml:id="formula_50">minimize a ∈R n+d ||a || 1 subject to B • a = x i ,</formula><p>The coefficient vector a can be seen as an encoding of x i . From this perspective, one would expect similar data points to have similar encodings. <ref type="bibr" target="#b212">Zhuang et al. (2012)</ref> captured this assumption by constructing a matrix A from all encodings a 1 , . . . , a n and regularizing the objective function by the rank of A. Based on a well-known clustering method called lowrank representation <ref type="bibr" target="#b101">(Liu et al. 2010a</ref>), the regularization term penalizes coefficient matrices of high rank. The low-rankness of the matrix captures global structures in the data, while sparsity captures the local structure among data points. The resulting optimization problem, which includes the non-negativity constraint and penalizes the L0 norm of the coefficients, is NP-hard; <ref type="bibr" target="#b212">Zhuang et al. (2012)</ref> proposed a convex relaxation leading to an objective function identical to the sparse coding objective function from Problem 11, but with the addition of the non-negativity constraint and a surrogate for the rank-regularization term.</p><p>Although this approach achieves good empirical results, the motivation for using the contribution coefficients a as graph weights remains somewhat unclear. As an alternative, <ref type="bibr">Li and</ref><ref type="bibr">Fu (2013, 2015)</ref> use the reconstruction coefficients of pairs of data points to measure their similarity. In particular, they build a matrix of encoding vectors that is sparse and of low rank, and base the similarity of data points on the distance between their encodings. Additionally, they impose the constraint that all nodes have equal degree, to promote sparsity and regularity of the graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Scalable transductive learning</head><p>Many of the graph construction and inference methods discussed thus far suffer from a lack of scalability <ref type="bibr" target="#b105">(Liu et al. 2012)</ref>. Graph construction methods commonly have time complexity O(n 2 ) (for instance, k-nearest neighbours has time complexity O(k • n 2 )); inference methods generally have time complexity O(n 3 ) for obtaining exact solutions and O(n) for approximate solutions. This can make it difficult to apply graph-based methods in real-world applications with large quantities of unlabelled data. <ref type="bibr" target="#b105">Liu et al. (2012)</ref> provided an overview of approaches for making graph-based methods more scalable.</p><p>To tackle the scalability problem, several approaches have been proposed for efficiently constructing smaller graphs on which inference can then be performed. These approaches rely on finding a set of m n prototype or anchor points to express the structure in the given data more compactly. These anchor points are used in the inference phase, after which unlabelled data points are classified based on the inferred labels of nearby anchor points.</p><p>A commonly used approach called anchor graph regularization was proposed by <ref type="bibr" target="#b103">Liu et al. (2010b)</ref>. Their method seeks to find a set of anchor points u 1 , . . . , u k and corresponding label assignments so that each data point can be expressed as a linear combination of the labels of nearby anchor points. They choose the positions of the anchor points using k-means clustering, and construct a graph connecting each data point to its closest anchors. The corresponding weights are defined via locally linear embedding (see Sect. 7.3.2); these are then used to construct a graph over all data points. The inference process indirectly optimizes the predictions for the data points, by optimizing a graph-based objective function defined over the predictions for the anchor points. <ref type="bibr">Zhang et al. (2009)</ref> proposed to use a low-rank approximation of the adjacency matrix in the unsupervised cost term in the inference phase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.5">From transduction to induction</head><p>To obtain a prediction for a previously unseen data point, transductive algorithms to be rerun in their entirety. Since transductive methods are often computationally expensive, this is undesirable in many real-world problem scenarios, where on-the-fly classification for new data points is required. The issue of adapting and extending transductive algorithms for inductive classification has not been studied extensively in the literature, but some potential solutions have been proposed.</p><p>The first type of approach is to find the optimal label prediction for previously unseen data points based on the objective function of the transductive algorithm. Such approaches fix the transductive predictions, and use the resulting graph to predict the label of previously unseen data points <ref type="bibr" target="#b14">(Bengio et al. 2006;</ref><ref type="bibr" target="#b206">Zhu 2008)</ref>. Considering the general objective function from Expression 8, the optimal label assignment for the new data point x i can be calculated efficiently: assuming we can calculate the graph weights W i j for j = 1, . . . , n, we can optimize the objective function with respect to only the predicted label of the new data point. The label assignment ŷi minimizing the cost function is then given by the weighted majority vote of the neighbours of the data point:</p><formula xml:id="formula_51">ŷi ∈ arg max c∈Y v j ∈N (v i )∧ ŷ j =c W i j</formula><p>The second type of approach for building an inductive classifier is to treat the pseudolabelled predictions as true labels, and to train a supervised classifier based on these predictions. This approach was taken by <ref type="bibr" target="#b87">Kveton et al. (2010)</ref>, who used the min-cut approach to obtain the optimal labels, and trained a supervised SVM using the combined labelled and unlabelled data. One can consider using a transductive approach with probability estimates, such that unlabelled samples can be weighted in the supervised learning algorithm. This approach can also be applied to inductive learners that have a computationally expensive prediction phase: we can train an inductive semi-supervised learning method on all available data, and pass its predictions for the unlabelled data along with the labelled data to a computationally more efficient classifier <ref type="bibr" target="#b170">(Urner et al. 2011</ref>). The efficient predictor can then be used to make predictions on new, previously unseen data points.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.6">Classification in network data</head><p>In some real-world problems, data is inherently represented as a graph. Such data, which is commonly referred to as network data, arises in the context of social networks, scientific collaboration, spreading of infectious diseases, company structures, etc. In such networks, nodes generally represent entities (such as people), and edges represent relations between them (such as friendship). The field that studies such data is commonly known as network science <ref type="bibr" target="#b8">(Barabási 2016)</ref>.</p><p>In such network data, graph-based transductive methods are highly appropriate candidates for performing inference. Node classification in particular can be considered a regular transductive semi-supervised learning task, and is broadly applied to problems in social network analysis and natural language processing <ref type="bibr" target="#b162">(Tan et al. 2011;</ref><ref type="bibr" target="#b193">Yang et al. 2016)</ref>. Although there is a considerable amount of overlap between these fields, the semi-supervised learning and network science communities have operated rather independently. Of course, significant differences also exist between data that is inherently given in the form of a network and graphs that are inferred from input vectors based on some similarity measure. <ref type="bibr" target="#b143">Sen et al. (2008)</ref> provided an overview of inference techniques for classification in network data. They emphasized the difference between local classification, where each node is classified individually based on its neighbours (possibly iteratively), and global classification, where a global, joint objective function is optimized. They specifically consider the iterative classification algorithm, which constructs a local, supervised classifier for each node and assigns to the node the most likely label based on its neighbours and their labels <ref type="bibr" target="#b107">(Lu and Getoor 2003;</ref><ref type="bibr" target="#b116">Neville and Jensen 2000)</ref>. This procedure is iterated until the predictions in the entire network stabilize. <ref type="bibr" target="#b193">Yang et al. (2016)</ref> proposed a neural network-based approach that simultaneously predicts the label of a node and its context, i.e. (properties of) nearby nodes in the network, using node embedding.</p><p>They extended this approach to the inductive setting, by expressing the embedding as a function of the features of a given node (and not its context). The context is predicted using a random walk; similar approaches to that problem have been previously studied <ref type="bibr" target="#b128">(Perozzi et al. 2014;</ref><ref type="bibr" target="#b163">Tang et al. 2015)</ref>. Several approaches have been suggested to generalize convolutional neural network architectures to network data (see, e.g. <ref type="bibr" target="#b22">Bruna et al. 2014;</ref><ref type="bibr" target="#b51">Duvenaud et al. 2015;</ref><ref type="bibr" target="#b82">Kipf and Welling 2016)</ref>.</p><p>Network-based methods generally attempt to find a way to represent given network data as vectors, allowing for inductive inference <ref type="bibr" target="#b193">(Yang et al. 2016</ref>). Interestingly, this can be considered the inverse task of what most semi-supervised graph-based methods attempt to do, which is to construct a graph based on vector data. These complementary approaches highlight the difference between 'standard', tabular data and data specified natively in the form of a network.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Related areas</head><p>Although the vast majority of semi-supervised learning research has been focussed on semisupervised classification, other problems have also been studied. Semi-supervised regression, where the label space Y is real-valued instead of categorical, is particularly closely related to semi-supervised classification; we cover it in limited detail below. Semi-supervised clustering, which can be considered the counterpart of semi-supervised classification, is also covered in some detail later in this section. Some other areas related to semi-supervised classification are not covered in this survey. They include the field of active learning, where the learning algorithm can query the user for the labels of previously unlabelled data points. Consequently, new labelled data can be obtained. Since labelling data is generally costly, the challenge lies in the selection of unlabelled data points whose labels would be most informative <ref type="bibr" target="#b144">(Settles 2012</ref>). We also do not cover learning from positive and unlabelled data, which is a special case of semi-supervised learning where the algorithm has access to a set of unlabelled data points, but where all labelled data points belong to a single class (see, e.g. <ref type="bibr" target="#b100">Liu et al. 2002;</ref><ref type="bibr" target="#b46">Denis et al. 2005;</ref><ref type="bibr" target="#b52">Elkan and Noto 2008)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Semi-supervised regression</head><p>In classification problems, the label space Y is categorical; in regression problems, on the other hand, the output value space is continuous. Although classification and regression problems are both concerned with predicting output values for input data points, most semisupervised classification methods cannot be naturally applied to the regression setting.</p><p>A class of methods that can be rather easily extended to the regression setting that of graph-based methods (see Sect. 7). Many such methods model a real-valued function in an intermediate step and incorporate the real-valued predictions in a regularization term in the objective function. These real-valued predictions can be readily utilized in the regression scenario (see, e.g. <ref type="bibr" target="#b10">Belkin et al. 2004;</ref><ref type="bibr" target="#b33">Cortes and Mohri 2007)</ref>.</p><p>The second class of methods that is naturally equipped to deal with regression problems is the class of wrapper methods (see Sect. 4). Although relatively little research has been conducted in this direction, wrapper methods such as self-training and co-training to regression methods can be readily applied in a semi-supervised regression setting. In fact, as in the case of supervised classification methods, any supervised regressor can be used within a wrapper method. <ref type="bibr" target="#b203">Zhou and Li (2005a)</ref> proposed a co-training algorithm for semi-supervised regression. They construct two k-nearest neighbour regressors on the labelled data, which then iteratively pass pseudo-labelled data to each other. The labelling confidence, which is used to select data points to pseudo-label, is based on the performance of the regressors obtained when adding the pseudo-labelled data point to the training set, as measured on the labelled data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Semi-supervised clustering</head><p>Semi-supervised classification is a relatively well-defined task, where one is presented with fully labelled data as well as completely unlabelled data. In semi-supervised clustering, however, the supervised information can take different forms. For instance, there can be must-link (two samples are known to be in the same cluster) and cannot-link (two samples are known to be in different clusters) constraints <ref type="bibr" target="#b89">(Lange et al. 2005)</ref>. It is also possible that some cluster assignments are known beforehand.</p><p>An example for incorporation of the latter type of information is the use of labelled data for cluster seeding. <ref type="bibr" target="#b9">Basu et al. (2002)</ref> proposed to initialize the clusters based on the data points for which cluster assignments are known. For every cluster, they initialize the cluster centroid for the k-means algorithm to the mean feature values of the data points known to belong to that cluster. They also proposed an alternative of this approach, where the cluster assignments of the labelled data points are kept fixed in the k-means procedure.</p><p>Like semi-supervised regression, semi-supervised clustering is a relatively small research area when compared to semi-supervised classification. For a more extensive overview of semi-supervised clustering methods, we refer the reader to the recent survey by <ref type="bibr" target="#b5">Bair (2013)</ref> and the older survey on clustering methods by <ref type="bibr" target="#b66">Grira et al. (2004)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Conclusions and future perspectives</head><p>In this survey, we have presented an overview of the field of semi-supervised learning. Covering methods from the early 2000s and more recent advances, our survey constitutes an up-to-date review of this important topic within machine learning. Furthermore, we have presented a new taxonomy for semi-supervised classification methods, distinguishing between the primary objective of the approach (transductive versus inductive learning) and the way unlabelled data is used (i.e. wrapper methods, unsupervised preprocessing, and intrinsically semi-supervised methods).</p><p>Early research in the field of semi-supervised learning mainly focused on wrapper methods (Sect. 4) and semi-supervised extensions of traditional supervised algorithms (such as SVMs, see Sect. 6). Graph-based methods (Sects. 6.3 and 7) have been extensively researched the past two decades. They are perhaps the most intuitive semi-supervised learning method, explicitly incorporating the similarity of different unlabelled data points in a principled way. However, they still pose computational challenges. In recent years, semi-supervised learning has developed along similar lines as supervised learning: notably, there has been a strong focus on semi-supervised neural networks, in the form of unsupervised preprocessing (Sect. 5.3) as well as semi-supervised regularization (Sect. 6.2). Additionally, deep generative models have been extended to the semi-supervised setting (Sect. 6.4).</p><p>From our perspective, one of the most important issues to be resolved in semi-supervised learning is the potential performance degradation caused by the introduction of unlabelled data. Although this has received relatively little attention in the literature (likely due to publication bias, as noted by Zhu 2008), many semi-supervised learning methods only perform better than their supervised counterparts or base learners in specific cases <ref type="bibr" target="#b99">(Li and Zhou 2015;</ref><ref type="bibr" target="#b149">Singh et al. 2009)</ref>. In other cases, the supervised baselines used for empirically evaluating the performance of semi-supervised learning methods are relatively weak, causing a skewed perspective on the benefits of incorporating unlabelled data <ref type="bibr" target="#b122">(Oliver et al. 2018</ref>). Moreover, the potential performance degradation is generally much more significant than the potential improvement, especially in machine learning problems where strong performance is achieved with purely supervised learning. We believe that this is one of the main reasons for the dearth of applications of semi-supervised learning methods in practice when compared to supervised learning.</p><p>Notable exceptions are the recent advances in semi-supervised neural networks, which are generally perturbation-based (see Sect. 6.2). They incorporate the relatively weak smoothness assumption (i.e. minor variations in the input space should only cause minor variations in the output space). Empirically, these methods have been shown to consistently outperform their supervised counterparts. A considerable advantage of using neural networks for semi-supervised learning is that it is relatively straightforward to incorporate unsupervised loss terms into the cost function, which can then be optimized using backpropagation. This flexibility also accomodates the incorporation of more complex cost terms, facilitating, for example, graph-based regularization. For these reasons, we expect that the popularity of semi-supervised neural networks will continue to grow for the foreseeable future.</p><p>A second potential remedy for the lack of robustness of semi-supervised learning methods lies in the application of automated machine learning (AutoML) to the semi-supervised setting. Recently, there has been a steep increase in interest in the automatic selection and configuration of learning algorithms for a given classification problem. These approaches include meta-learning and neural architecture search as well as automated algorithm selection and hyperparameter optimization. While AutoML techniques have been prominently and successfully applied to supervised learning (see, e.g. <ref type="bibr" target="#b53">Elsken et al. 2019;</ref><ref type="bibr" target="#b55">Feurer et al. 2015;</ref><ref type="bibr" target="#b167">Thornton et al. 2013)</ref>, there has been no application to semi-supervised learning so far.</p><p>Another important step towards the adoption of semi-supervised in practice is the development of standardized software packages. Several highly popular toolkits exist for supervised learning, such as scikit-learn <ref type="bibr" target="#b127">(Pedregosa et al. 2011</ref>), but there is much less standardization in the field of semi-supervised learning. We note that some generic toolkits do exist; the KEEL software package includes a semi-supervised learning module <ref type="bibr" target="#b169">(Triguero et al. 2017)</ref>, and implementations of some transductive graph-based methods exist in scikit-learn. For neural networks, it is typically relatively straightforward to implement semi-supervised loss terms within popular software packages such as PyTorch <ref type="bibr" target="#b126">(Paszke et al. 2017)</ref> and TensorFlow <ref type="bibr" target="#b0">(Abadi et al. 2016)</ref>.</p><p>Lastly, we expect the strong distinction between clustering and classification to fade. Fundamentally, both can be seen as special cases of semi-supervised in which either only labelled data or only unlabelled data is present. When we can confidently reason about the connections between the marginal distribution p(x) and the conditional distribution p(y|x), learning algorithms can make effective use of unlabelled as well as labelled data. The recent rise in popularity of generative models (see Sect. 6.4) can be seen as evidence for this paradigm shift.</p><p>Ultimately, we expect the incorporation of unlabelled data to be a vital step in the progress of machine learning and its applications. To uncover the intricate and complex structures underlying the data model, the machine needs to be able to infer patterns between observations about which it receives no explicit labelling information. Semi-supervised learning, which aims to provide mechanisms to build such connections, will be an important tool towards this end.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 4</head><label>4</label><figDesc>Fig. 4 Simplified representation of an autoencoder. The rectangles correspond to layers within the network; the trapeziums represent the encoder and decoder portions of the network, which can consist of multiple layers</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 5</head><label>5</label><figDesc>Fig. 5 Example of undirected graphical model for graph-based classification. Filled nodes and edges between them correspond to the original graph G. Unfilled nodes with plus and minus signs correspond to auxiliary nodes connected to labelled data</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0">We note that the collections of data points referred to here are technically lists. However, following common usage, in this survey, we refer to them as 'sets' and, in a slight abuse of notation, apply standard set-theoretic concepts to them.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1">Taxonomy of semi-supervised learning methodsOver the past two decades, a broad variety of semi-supervised classification algorithms has been proposed. These methods differ in the semi-supervised learning assumptions they are based on, in how they make use of unlabelled data, and in the way they relate to supervised algorithms. Existing categorizations of semi-supervised learning methods generally use a subset of these properties and are typically relatively flat, thereby failing to capture similarities</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_2"><ref type="bibr" target="#b4">Bachman et al. (2014)</ref> consider distributions over the input data and consequently use expectations in their formalism; for consistency within this survey, we replaced these expectations by averages over the given data.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_3">We note that technically, Ŷ , Y and Y are lists rather than sets, but-following common practice in the machine learning literature-use set notation in the following.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We thank Matthijs van Leeuwen for his valuable feedback on drafts of this article.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Compliance with ethical standards</head></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conflict of interest</head><p>The authors declare that they have no conflict of interest.</p><p>Open Access This article is distributed under the terms of the Creative Commons Attribution 4.0 International License (http://creativecommons.org/licenses/by/4.0/), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Tensorflow: A system for large-scale machine learning</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Barham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Devin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ghemawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Irving</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Isard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th USENIX symposium on operating systems design and implementation</title>
				<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="265" to="283" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Bootstrapping</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 40th annual meeting on association for computational linguistics</title>
				<meeting>the 40th annual meeting on association for computational linguistics</meeting>
		<imprint>
			<publisher>association for computational linguistics</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="360" to="367" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Cluster analysis for applications</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Anderberg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1973">1973</date>
			<publisher>Academic Press</publisher>
			<pubPlace>Cambridge</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The rendezvous algorithm: Multiclass semi-supervised learning with Markov random walks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Azran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th international conference on machine learning</title>
				<meeting>the 24th international conference on machine learning</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="49" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Learning with pseudo-ensembles</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bachman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Alsharif</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Precup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="3365" to="3373" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Semi-supervised clustering methods</title>
		<author>
			<persName><forename type="first">E</forename><surname>Bair</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Wiley Interdisciplinary Reviews: Computational Statistics</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="349" to="361" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Co-training and expansion: Towards bridging theory and practice</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Balcan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="89" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Video suggestion and discovery for youtube: Taking random walks through the view graph</title>
		<author>
			<persName><forename type="first">S</forename><surname>Baluja</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Seth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sivakumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Jing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yagnik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Ravichandran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Aly</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th international conference on world wide web</title>
				<meeting>the 17th international conference on world wide web</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="895" to="904" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Network science</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Barabási</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016">2016</date>
			<publisher>Cambridge University Press</publisher>
			<pubPlace>Cambridge</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Semi-supervised clustering by seeding</title>
		<author>
			<persName><forename type="first">S</forename><surname>Basu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Banerjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mooney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th international conference on machine learning</title>
				<meeting>the 19th international conference on machine learning</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="27" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Regularization and semi-supervised learning on large graphs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Belkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Matveeva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Niyogi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the international conference on computational learning theory</title>
				<meeting>the international conference on computational learning theory</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="624" to="638" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">On manifold regularization</title>
		<author>
			<persName><forename type="first">M</forename><surname>Belkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Niyogi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Sindhwani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th international conference on artificial intelligence and statistics</title>
				<meeting>the 10th international conference on artificial intelligence and statistics</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="17" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Manifold regularization: A geometric framework for learning from labeled and unlabeled examples</title>
		<author>
			<persName><forename type="first">M</forename><surname>Belkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Niyogi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Sindhwani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="2399" to="2434" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Learning low density</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ben-David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pál</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sotáková</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th international conference on artificial intelligence and statistics</title>
				<meeting>the 12th international conference on artificial intelligence and statistics</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="25" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Chapter 11. Label propagation and quadratic criterion</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Delalleau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Le Roux</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Semi-supervised learning</title>
				<editor>
			<persName><forename type="first">O</forename><surname>Chapelle</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Schölkopf</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">&amp;</forename><forename type="middle">A</forename><surname>Zien</surname></persName>
		</editor>
		<meeting><address><addrLine>Cambridge</addrLine></address></meeting>
		<imprint>
			<publisher>The MIT Press</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="193" to="216" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Semi-supervised support vector machines</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">P</forename><surname>Bennett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Demiriz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="368" to="374" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Exploiting unlabeled data in ensemble methods</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">P</forename><surname>Bennett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Demiriz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Maclin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th ACM SIGKDD international conference on knowledge discovery and data mining</title>
				<meeting>the 8th ACM SIGKDD international conference on knowledge discovery and data mining</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="289" to="296" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><surname>Berthelot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Carlini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Goodfellow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Papernot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Oliver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Raffel</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1905.02249</idno>
		<title level="m">Mixmatch: A holistic approach to semi-supervised learning</title>
				<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Pattern recognition and machine learning</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Bishop</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Learning from labeled and unlabeled data using graph mincuts</title>
		<author>
			<persName><forename type="first">A</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chawla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th international conference on machine learning</title>
				<meeting>the 18th international conference on machine learning</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="19" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Semi-supervised learning using randomized mincuts</title>
		<author>
			<persName><forename type="first">A</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lafferty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Rwebangira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Reddy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st international conference on machine learning</title>
				<meeting>the 21st international conference on machine learning</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page">13</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Combining labeled and unlabeled data with co-training</title>
		<author>
			<persName><forename type="first">A</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th annual conference on computational learning theory</title>
				<meeting>the 11th annual conference on computational learning theory</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="92" to="100" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Spectral networks and locally connected networks on graphs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bruna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zaremba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Szlam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lecun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International conference on learning, representations</title>
				<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A continuation method for semi-supervised SVMs</title>
		<author>
			<persName><forename type="first">O</forename><surname>Chapelle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Chi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zien</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd international conference on machine learning</title>
				<meeting>the 23rd international conference on machine learning</meeting>
		<imprint>
			<date type="published" when="2006">2006a</date>
			<biblScope unit="page" from="185" to="192" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Optimization techniques for semi-supervised support vector machines</title>
		<author>
			<persName><forename type="first">O</forename><surname>Chapelle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Schölkopf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zien</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Chapelle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Sindhwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Keerthi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Semi-supervised learning</title>
				<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="2006">2006b. 2008</date>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="203" to="233" />
		</imprint>
	</monogr>
	<note>Cambridge: The</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Semi-supervised classification by low density separation</title>
		<author>
			<persName><forename type="first">O</forename><surname>Chapelle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zien</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th international workshop on artificial intelligence and statistics</title>
				<meeting>the 10th international workshop on artificial intelligence and statistics</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="57" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Semi-supervised learning via regularized boosting working on multiple semisupervised assumptions</title>
		<author>
			<persName><forename type="first">K</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Pattern Analysis and Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="129" to="143" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Automatic feature decomposition for single view co-training</title>
		<author>
			<persName><forename type="first">M</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">Q</forename><surname>Weinberger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th international conference on machine learning</title>
				<meeting>the 28th international conference on machine learning</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="953" to="960" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Xgboost: A scalable tree boosting system</title>
		<author>
			<persName><forename type="first">T</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Guestrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd ACM SIGKDD international conference on knowledge discovery and data mining</title>
				<meeting>the 22nd ACM SIGKDD international conference on knowledge discovery and data mining</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="785" to="794" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Co-training with noisy perceptual observations</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Christoudias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Urtasun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kapoorz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Darrell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2009 IEEE conference on computer vision and pattern recognition</title>
				<meeting>the 2009 IEEE conference on computer vision and pattern recognition</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="2844" to="2851" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Large scale transductive SVMs</title>
		<author>
			<persName><forename type="first">R</forename><surname>Collobert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Sinz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Weston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bottou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="1687" to="1712" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Natural language processing (almost) from scratch</title>
		<author>
			<persName><forename type="first">R</forename><surname>Collobert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Weston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bottou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Karlen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kavukcuoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kuksa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="2493" to="2537" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">On information regularization</title>
		<author>
			<persName><forename type="first">A</forename><surname>Corduneanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Jaakkola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th conference on uncertainty in artificial intelligence</title>
				<meeting>the 19th conference on uncertainty in artificial intelligence</meeting>
		<imprint>
			<publisher>Morgan Kaufmann Publishers Inc</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="151" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">On transductive regression</title>
		<author>
			<persName><forename type="first">C</forename><surname>Cortes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mohri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="305" to="312" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Semi-supervised learning of mixture models</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">G</forename><surname>Cozman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Cirelo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th international conference on machine learning</title>
				<meeting>the 20th international conference on machine learning</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="99" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">An iterative algorithm for extending learners to a semi-supervised setting</title>
		<author>
			<persName><forename type="first">M</forename><surname>Culp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Michailidis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computational and Graphical Statistics</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="545" to="571" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Good semi-supervised learning that requires a bad gan</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Salakhutdinov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="6510" to="6520" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Semi-supervised marginboost</title>
		<author>
			<persName><forename type="first">Alché</forename><surname>Buc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Grandvalet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ambroise</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Advances in Neural Information Processing Systems</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="553" to="560" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Clustering unlabeled data with SOMs improves classification of labeled real-world data</title>
		<author>
			<persName><forename type="first">R</forename><surname>Dara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Kremer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Stacey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the international joint conference on neural networks</title>
				<meeting>the international joint conference on neural networks</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="2237" to="2242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">PAC generalization bounds for co-training</title>
		<author>
			<persName><forename type="first">S</forename><surname>Dasgupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Littman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Mcallester</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="375" to="382" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Convex methods for transduction</title>
		<author>
			<persName><forename type="first">T</forename><surname>De Bie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Cristianini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural processing systems</title>
				<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="73" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Semi-supervised learning using semi-definite programming</title>
		<author>
			<persName><forename type="first">T</forename><surname>De Bie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Cristianini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Semi-supervised learning</title>
				<editor>
			<persName><forename type="first">O</forename><surname>Chapelle</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Schölkopf</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">&amp;</forename><forename type="middle">A</forename><surname>Zien</surname></persName>
		</editor>
		<meeting><address><addrLine>Cambridge</addrLine></address></meeting>
		<imprint>
			<publisher>The MIT Press</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="119" to="135" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Influence of graph construction on semi-supervised learning</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>De Sousa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">O</forename><surname>Rezende</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Batista</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the joint European conference on machine learning and knowledge discovery in databases</title>
				<meeting>the joint European conference on machine learning and knowledge discovery in databases</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="160" to="175" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Semi-supervised clustering using genetic algorithms</title>
		<author>
			<persName><forename type="first">A</forename><surname>Demiriz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">P</forename><surname>Bennett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Embrechts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Artificial Neural Networks in Engineering</title>
				<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="809" to="814" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Maximum likelihood from incomplete data via the EM algorithm</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Dempster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">M</forename><surname>Laird</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Rubin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the Royal statistical society, Series B</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="1" to="38" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">A new co-training-style random forest for computer aided diagnosis</title>
		<author>
			<persName><forename type="first">C</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zu Guo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Intelligent Information Systems</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="253" to="281" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Learning from positive and unlabeled examples</title>
		<author>
			<persName><forename type="first">F</forename><surname>Denis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gilleron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Letouzey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">348</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="70" to="83" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Doersch</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1606.05908</idno>
		<title level="m">Tutorial on variational autoencoders</title>
				<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Semisupervised selflearning for hyperspectral image classification</title>
		<author>
			<persName><forename type="first">I</forename><surname>Dópido</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">R</forename><surname>Marpu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Plaza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M B</forename><surname>Dias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Benediktsson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Geoscience and Remote Sensing</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="4032" to="4044" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">When does cotraining work in real data?</title>
		<author>
			<persName><forename type="first">J</forename><surname>Du</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">X</forename><surname>Ling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">H</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Knowledge and Data Engineering</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="788" to="799" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<title level="m" type="main">UCI machine learning repository</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dua</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Graff</surname></persName>
		</author>
		<ptr target="http://archive.ics.uci.edu/ml" />
		<imprint>
			<date type="published" when="2019-09-12">2019. September 12. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Convolutional networks on graphs for learning molecular fingerprints</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">K</forename><surname>Duvenaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Maclaurin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Iparraguirre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bombarell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Hirzel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aspuru-Guzik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Adams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="2224" to="2232" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Learning classifiers from only positive and unlabeled data</title>
		<author>
			<persName><forename type="first">C</forename><surname>Elkan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Noto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th ACM SIGKDD international conference on knowledge discovery and data mining</title>
				<meeting>the 14th ACM SIGKDD international conference on knowledge discovery and data mining</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="213" to="220" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Neural architecture search: A survey</title>
		<author>
			<persName><forename type="first">T</forename><surname>Acm. Elsken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Metzen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Hutter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">55</biblScope>
			<biblScope unit="page" from="1" to="21" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Why does unsupervised pre-training help deep learning</title>
		<author>
			<persName><forename type="first">D</forename><surname>Erhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Courville</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Manzagol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Vincent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bengio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="625" to="660" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Efficient and robust automated machine learning</title>
		<author>
			<persName><forename type="first">M</forename><surname>Feurer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Eggensperger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Springenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Hutter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="2962" to="2970" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">A decision-theoretic generalization of on-line learning and an application to boosting</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Freund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Schapire</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="119" to="139" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Ensemble manifold regularization</title>
		<author>
			<persName><forename type="first">B</forename><surname>Geng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><forename type="middle">S</forename><surname>Hua</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Pattern Analysis and Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1227" to="1233" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Multi-manifold semi-supervised learning</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">D</forename><surname>Nowak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th international conference on artificial intelligence and statistics</title>
				<meeting>the 12th international conference on artificial intelligence and statistics</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="169" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Enhancing supervised learning with unlabeled data</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th international conference on machine learning</title>
				<meeting>the 17th international conference on machine learning</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="327" to="334" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<monogr>
		<author>
			<persName><forename type="first">I</forename><surname>Goodfellow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Goodfellow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Courville</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1701.00160</idno>
		<title level="m">NIPS 2016 tutorial: Generative adversarial networks</title>
				<meeting><address><addrLine>Cambridge</addrLine></address></meeting>
		<imprint>
			<publisher>The MIT Press</publisher>
			<date type="published" when="2016">2017. 2016</date>
		</imprint>
	</monogr>
	<note>Deep learning</note>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Generative adversarial nets</title>
		<author>
			<persName><forename type="first">I</forename><surname>Goodfellow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pouget-Abadie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mirza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Warde-Farley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ozair</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Courville</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="2014">2014a</date>
			<biblScope unit="page" from="2672" to="2680" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<monogr>
		<title level="m" type="main">Explaining and harnessing adversarial examples</title>
		<author>
			<persName><forename type="first">I</forename><surname>Goodfellow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Shlens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Szegedy</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1412.6572</idno>
		<imprint>
			<date type="published" when="2014">2014b</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Semi-supervised on-line boosting for robust tracking</title>
		<author>
			<persName><forename type="first">H</forename><surname>Grabner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Leistner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Bischof</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th European conference on computer vision</title>
				<meeting>the 10th European conference on computer vision</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="234" to="247" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Semi-supervised learning by entropy minimization</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Grandvalet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="529" to="536" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Boosting mixture models for semi-supervised learning</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Grandvalet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Buc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ambroise</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International conference on artificial neural networks</title>
				<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="41" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Unsupervised and semisupervised clustering: A brief survey</title>
		<author>
			<persName><forename type="first">N</forename><surname>Grira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Crucianu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Boujemaa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">7th ACM SIGMM international workshop on multimedia information retrieval</title>
				<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">node2vec: Scalable feature learning for networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Grover</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Leskovec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">of the 22nd ACM SIGKDD international conference on knowledge discovery and data mining</title>
				<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="855" to="864" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">An introduction to feature extraction</title>
		<author>
			<persName><forename type="first">I</forename><surname>Acm. Guyon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Elisseeff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Feature extraction</title>
				<editor>
			<persName><forename type="first">I</forename><surname>Guyon</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Nikravesh</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Gunn</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Zadeh</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="1" to="25" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Analysis of semi-supervised learning with the Yarowsky algorithm</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">R</forename><surname>Haffari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sarkar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd conference on uncertainty in artificial intelligence</title>
				<meeting>the 23rd conference on uncertainty in artificial intelligence</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="159" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<monogr>
		<title level="m" type="main">Markov fields on finite graphs and lattices</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Hammersley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Clifford</surname></persName>
		</author>
		<ptr target="http://www.statslab.cam.ac.uk/~grg/books/hammfest/hamm-cliff.pdf" />
		<imprint>
			<date type="published" when="1971-10-27">1971. October 27. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Nonnegative sparse coding for discriminative semi-supervised learning</title>
		<author>
			<persName><forename type="first">R</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">S</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">G</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><forename type="middle">W</forename><surname>Kong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2011 IEEE conference on computer vision and pattern recognition</title>
				<meeting>the 2011 IEEE conference on computer vision and pattern recognition</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="2849" to="2856" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Manifold denoising</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Maier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="561" to="568" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">A fast learning algorithm for deep belief nets</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Hinton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Osindero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">W</forename><surname>Teh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neural Computation</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="1527" to="1554" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">Fast b-matching via sufficient selection belief propagation</title>
		<author>
			<persName><forename type="first">B</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Jebara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th international conference on artificial intelligence and statistics</title>
				<meeting>the 14th international conference on artificial intelligence and statistics</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="361" to="369" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">Twin support vector machines for pattern classification</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R</forename><surname>Jayadeva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chandra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Pattern Analysis and Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="905" to="910" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">Graph construction and b-matching for semi-supervised learning</title>
		<author>
			<persName><forename type="first">T</forename><surname>Jebara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">F</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th annual international conference on machine learning</title>
				<meeting>the 26th annual international conference on machine learning</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="441" to="448" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<analytic>
		<title level="a" type="main">Transductive inference for text classification using support vector machines</title>
		<author>
			<persName><forename type="first">T</forename><surname>Joachims</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th international conference on machine learning</title>
				<meeting>the 16th international conference on machine learning</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">99</biblScope>
			<biblScope unit="page" from="200" to="209" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">Transductive learning via spectral graph partitioning</title>
		<author>
			<persName><forename type="first">T</forename><surname>Joachims</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th international conference on machine learning</title>
				<meeting>the 20th international conference on machine learning</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="290" to="297" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">Manifold-based similarity adaptation for label propagation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Karasuyama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Mamitsuka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1547" to="1555" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">Semi-supervised learning with deep generative models</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Kingma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mohamed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Rezende</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Welling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="3581" to="3589" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<analytic>
		<title level="a" type="main">Auto-encoding variational Bayes</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Kingma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Welling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International conference on learning, representations</title>
				<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b82">
	<monogr>
		<title level="m" type="main">Semi-supervised classification with graph convolutional networks</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">N</forename><surname>Kipf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Welling</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1609.02907</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<analytic>
		<title level="a" type="main">Email classification with co-training</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kiritchenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Matwin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2001 conference of the centre for advanced studies on collaborative research</title>
				<meeting>the 2001 conference of the centre for advanced studies on collaborative research</meeting>
		<imprint>
			<publisher>IBM press</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<analytic>
		<title level="a" type="main">The self-organizing map</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kohonen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neurocomputing</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="1" to="6" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<monogr>
		<title level="m" type="main">Learning multiple layers of features from tiny images</title>
		<author>
			<persName><forename type="first">A</forename><surname>Krizhevsky</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
		<respStmt>
			<orgName>University of Toronto, Department of Computer Science</orgName>
		</respStmt>
	</monogr>
	<note>Master&apos;s thesis</note>
</biblStruct>

<biblStruct xml:id="b86">
	<analytic>
		<title level="a" type="main">Imagenet classification with deep convolutional neural networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Krizhevsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Hinton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="1097" to="1105" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b87">
	<analytic>
		<title level="a" type="main">Semi-supervised learning with max-margin graph cuts</title>
		<author>
			<persName><forename type="first">B</forename><surname>Kveton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Valko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rahimi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th international conference on artificial intelligence and statistics</title>
				<meeting>the 13th international conference on artificial intelligence and statistics</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="421" to="428" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b88">
	<analytic>
		<title level="a" type="main">Temporal ensembling for semi-supervised learning</title>
		<author>
			<persName><forename type="first">S</forename><surname>Laine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Aila</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International conference on learning, representations</title>
				<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b89">
	<analytic>
		<title level="a" type="main">Learning with constrained and unlabelled data</title>
		<author>
			<persName><forename type="first">T</forename><surname>Lange</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Law</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Buhmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2005 IEEE conference on computer vision and pattern recognition</title>
				<meeting>the 2005 IEEE conference on computer vision and pattern recognition</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="731" to="738" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b90">
	<analytic>
		<title level="a" type="main">Semi-supervised learning via Gaussian processes</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">D</forename><surname>Lawrence</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">I</forename><surname>Jordan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="753" to="760" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b91">
	<analytic>
		<author>
			<persName><forename type="first">Y</forename><surname>Lecun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Hinton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Deep learning</title>
				<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">521</biblScope>
			<biblScope unit="page">436</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b92">
	<analytic>
		<title level="a" type="main">Pseudo-label: The simple and efficient semi-supervised learning method for deep neural networks</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th ICML workshop on challenges in representation learning</title>
				<meeting>the 30th ICML workshop on challenges in representation learning</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b93">
	<analytic>
		<title level="a" type="main">Semi-supervised random forests</title>
		<author>
			<persName><forename type="first">C</forename><surname>Leistner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Saffari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Santner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Bischof</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE 12th international conference on computer vision</title>
				<meeting>the IEEE 12th international conference on computer vision</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="506" to="513" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b94">
	<analytic>
		<title level="a" type="main">Semi-supervised classification trees</title>
		<author>
			<persName><forename type="first">J</forename><surname>Levatić</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ceci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kocev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Džeroski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Intelligent Information Systems</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="461" to="486" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b95">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Zhang</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1703.02291</idno>
		<title level="m">Triple generative adversarial nets</title>
				<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b96">
	<analytic>
		<title level="a" type="main">Improve computer-aided diagnosis with machine learning techniques undiagnosed samples</title>
		<author>
			<persName><forename type="first">M</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">H</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Transactions on Systems, Man, and Cybernetics-Part A: Systems and Humans</title>
				<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="1088" to="1098" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b97">
	<analytic>
		<title level="a" type="main">Low-rank coding with b-matching constraint for semi-supervised classification</title>
		<author>
			<persName><forename type="first">S</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Fu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd international joint conference on artificial intelligence</title>
				<meeting>the 23rd international joint conference on artificial intelligence</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1472" to="1478" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b98">
	<analytic>
		<title level="a" type="main">Learning balanced and unbalanced graphs via low-rank coding</title>
		<author>
			<persName><forename type="first">S</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Fu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Knowledge and Data Engineering</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1274" to="1287" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b99">
	<analytic>
		<title level="a" type="main">Towards making unlabeled data never hurt</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">F</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">H</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Pattern Analysis and Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="175" to="188" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b100">
	<analytic>
		<title level="a" type="main">Partially supervised classification of text documents</title>
		<author>
			<persName><forename type="first">B</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">S</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th international conference on machine learning</title>
				<meeting>the 19th international conference on machine learning</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="387" to="394" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b101">
	<analytic>
		<title level="a" type="main">Robust subspace segmentation by low-rank representation</title>
		<author>
			<persName><forename type="first">G</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th international conference on machine learning</title>
				<meeting>the 27th international conference on machine learning</meeting>
		<imprint>
			<date type="published" when="2010">2010a</date>
			<biblScope unit="page" from="663" to="670" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b102">
	<analytic>
		<title level="a" type="main">Robust multi-class transductive learning with graphs</title>
		<author>
			<persName><forename type="first">W</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">F</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2009 IEEE conference on computer vision and pattern recognition</title>
				<meeting>the 2009 IEEE conference on computer vision and pattern recognition</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="381" to="388" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b103">
	<analytic>
		<title level="a" type="main">Large graph construction for scalable semi-supervised learning</title>
		<author>
			<persName><forename type="first">W</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">F</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th international conference on machine learning</title>
				<meeting>the 27th international conference on machine learning</meeting>
		<imprint>
			<date type="published" when="2010">2010b</date>
			<biblScope unit="page" from="679" to="686" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b104">
	<analytic>
		<title level="a" type="main">Semi-supervised node splitting for random forest construction</title>
		<author>
			<persName><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2013 IEEE conference on computer vision and pattern recognition</title>
				<meeting>the 2013 IEEE conference on computer vision and pattern recognition</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="492" to="499" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b105">
	<monogr>
		<title level="m" type="main">Robust and scalable graph-based semisupervised learning. Proceedings of the IEEE</title>
		<author>
			<persName><forename type="first">W</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">F</forename><surname>Chang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">100</biblScope>
			<biblScope unit="page" from="2624" to="2638" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b106">
	<analytic>
		<title level="a" type="main">Random forest construction with robust semisupervised node splitting</title>
		<author>
			<persName><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Image Processing</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="471" to="483" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b107">
	<analytic>
		<title level="a" type="main">Link-based classification</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Getoor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th international conference on machine learning</title>
				<meeting>the 20th international conference on machine learning</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="496" to="503" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b108">
	<analytic>
		<title level="a" type="main">Smooth neighbors on teacher graphs for semi-supervised learning</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE conference on computer vision and pattern recognition</title>
				<meeting>the IEEE conference on computer vision and pattern recognition</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="8896" to="8905" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b109">
	<analytic>
		<title level="a" type="main">Influence of graph construction on graph-based clustering measures</title>
		<author>
			<persName><forename type="first">M</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><forename type="middle">V</forename><surname>Luxburg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="1025" to="1032" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b110">
	<analytic>
		<title level="a" type="main">Semiboost: Boosting for semi-supervised learning</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">K</forename><surname>Mallapragada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Pattern Analysis and Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="2000" to="2014" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b111">
	<analytic>
		<title level="a" type="main">Laplacian support vector machines trained in the primal</title>
		<author>
			<persName><forename type="first">S</forename><surname>Melacci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Belkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="1149" to="1184" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b112">
	<analytic>
		<title level="a" type="main">Co-training and self-training for word sense disambiguation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Mihalcea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th conference on computational natural language learning</title>
				<meeting>the 8th conference on computational natural language learning</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b113">
	<analytic>
		<title level="a" type="main">Distributed representations of words and phrases and their compositionality</title>
		<author>
			<persName><forename type="first">T</forename><surname>Mikolov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Corrado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dean</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="3111" to="3119" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b114">
	<analytic>
		<title level="a" type="main">Virtual adversarial training: A regularization method for supervised and semi-supervised learning</title>
		<author>
			<persName><forename type="first">T</forename><surname>Miyato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">I</forename><surname>Maeda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Koyama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ishii</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Pattern Analysis and Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1979" to="1993" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b115">
	<analytic>
		<title level="a" type="main">Reading digits in natural images with unsupervised feature learning</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Netzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Coates</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bissacco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Ng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS workshop on deep learning and unsupervised feature learning</title>
				<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b116">
	<analytic>
		<title level="a" type="main">Iterative classification in relational data</title>
		<author>
			<persName><forename type="first">J</forename><surname>Neville</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Jensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th AAAI workshop on learning statistical models from relational data</title>
				<meeting>the 17th AAAI workshop on learning statistical models from relational data</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="13" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b117">
	<analytic>
		<title level="a" type="main">Analyzing the effectiveness and applicability of co-training</title>
		<author>
			<persName><forename type="first">K</forename><surname>Nigam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ghani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th international conference on information and knowledge management</title>
				<meeting>the 9th international conference on information and knowledge management</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="86" to="93" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b118">
	<analytic>
		<title level="a" type="main">Semi-supervised text classification using EM</title>
		<author>
			<persName><forename type="first">K</forename><surname>Nigam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mccallum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Semi-Supervised Learning</title>
				<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="33" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b119">
	<analytic>
		<title level="a" type="main">Text classification from labeled and unlabeled documents using EM</title>
		<author>
			<persName><forename type="first">K</forename><surname>Nigam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Mccallum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Thrun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Learning</title>
				<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="103" to="134" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b120">
	<analytic>
		<title level="a" type="main">Manifold regularization and semi-supervised learning: Some theoretical analyses</title>
		<author>
			<persName><forename type="first">P</forename><surname>Niyogi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1229" to="1250" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b121">
	<monogr>
		<title level="m" type="main">Semi-supervised learning with generative adversarial networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Odena</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1606.01583</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b122">
	<monogr>
		<title level="m" type="main">Realistic evaluation of deep semisupervised learning algorithms</title>
		<author>
			<persName><forename type="first">A</forename><surname>Oliver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Odena</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Raffel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">D</forename><surname>Cubuk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">J</forename><surname>Goodfellow</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1804.09170</idno>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b123">
	<analytic>
		<title level="a" type="main">How many trees in random forest?</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M</forename><surname>Oshiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Perez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Baranauskas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the international workshop on machine learning and data mining in pattern recognition</title>
				<meeting>the international workshop on machine learning and data mining in pattern recognition</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="154" to="168" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b124">
	<analytic>
		<title level="a" type="main">A sentimental education: Sentiment analysis using subjectivity summarization based on minimum cuts</title>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 42nd annual meeting on association for computational linguistics</title>
				<meeting>the 42nd annual meeting on association for computational linguistics</meeting>
		<imprint>
			<publisher>association for computational linguistics</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page">271</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b125">
	<analytic>
		<title level="a" type="main">Adversarial dropout for supervised and semi-supervised learning</title>
		<author>
			<persName><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Moon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the thirty-second AAAI conference on artificial intelligence</title>
				<meeting>the thirty-second AAAI conference on artificial intelligence</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="3917" to="3924" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b126">
	<analytic>
		<title level="a" type="main">Automatic differentiation in pytorch</title>
		<author>
			<persName><forename type="first">A</forename><surname>Paszke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chintala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Chanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Devito</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Desmaison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Antiga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lerer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS Autodiff workshop</title>
				<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b127">
	<analytic>
		<title level="a" type="main">Scikit-learn: Machine learning in python</title>
		<author>
			<persName><forename type="first">F</forename><surname>Pedregosa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Varoquaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gramfort</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Michel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Thirion</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grisel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="2825" to="2830" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b128">
	<analytic>
		<title level="a" type="main">Deepwalk: Online learning of social representations</title>
		<author>
			<persName><forename type="first">B</forename><surname>Perozzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Al-Rfou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Skiena</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th ACM SIGKDD international conference on knowledge discovery and data mining</title>
				<meeting>the 20th ACM SIGKDD international conference on knowledge discovery and data mining</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="701" to="710" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b129">
	<analytic>
		<title level="a" type="main">Deconstructing the ladder network architecture</title>
		<author>
			<persName><forename type="first">M</forename><surname>Pezeshki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Brakel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Courville</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd international conference on machine learning</title>
				<meeting>the 33rd international conference on machine learning</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="2368" to="2376" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b130">
	<analytic>
		<title level="a" type="main">Learning a manifold as an atlas</title>
		<author>
			<persName><forename type="first">N</forename><surname>Pitelis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Russell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Agapito</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2013 IEEE conference on computer vision and pattern recognition</title>
				<meeting>the 2013 IEEE conference on computer vision and pattern recognition</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1642" to="1649" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b131">
	<analytic>
		<title level="a" type="main">Semi-supervised learning using an unsupervised atlas</title>
		<author>
			<persName><forename type="first">N</forename><surname>Pitelis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Russell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Agapito</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the joint European conference on machine learning and knowledge discovery in databases</title>
				<meeting>the joint European conference on machine learning and knowledge discovery in databases</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="565" to="580" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b132">
	<monogr>
		<author>
			<persName><forename type="first">I</forename><surname>Prémont-Schwarz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ilin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rasmus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Boney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Valpola</surname></persName>
		</author>
		<title level="m">Advances in neural information processing systems</title>
				<editor>
			<persName><forename type="first">I</forename><surname>Guyon</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">U</forename><forename type="middle">V</forename><surname>Luxburg</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Bengio</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Wallach</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Fergus</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Vishwanathan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Garnett</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="6009" to="6019" />
		</imprint>
	</monogr>
	<note>Recurrent ladder networks</note>
</biblStruct>

<biblStruct xml:id="b133">
	<analytic>
		<title level="a" type="main">Tree induction for probability-based ranking</title>
		<author>
			<persName><forename type="first">F</forename><surname>Provost</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Domingos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Learning</title>
				<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="page" from="199" to="215" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b134">
	<analytic>
		<title level="a" type="main">Laplacian twin support vector machine for semi-supervised classification</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Qi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neural Networks</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="46" to="53" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b135">
	<analytic>
		<title level="a" type="main">Semi-supervised learning with ladder networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Rasmus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Berglund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Honkala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Valpola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Raiko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="3546" to="3554" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b136">
	<analytic>
		<title level="a" type="main">Semisupervised neural networks for efficient hyperspectral image classification</title>
		<author>
			<persName><forename type="first">F</forename><surname>Ratle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Camps-Valls</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Weston</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Geoscience and Remote Sensing</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="2271" to="2282" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b137">
	<analytic>
		<title level="a" type="main">The manifold tangent classifier</title>
		<author>
			<persName><forename type="first">S</forename><surname>Rifai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">N</forename><surname>Dauphin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Vincent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Muller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="2011">2011a</date>
			<biblScope unit="page" from="2294" to="2302" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b138">
	<analytic>
		<title level="a" type="main">Contractive auto-encoders: Explicit invariance during feature extraction</title>
		<author>
			<persName><forename type="first">S</forename><surname>Rifai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Vincent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Muller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Glorot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th international conference on machine learning</title>
				<meeting>the 28th international conference on machine learning</meeting>
		<imprint>
			<date type="published" when="2011">2011b</date>
			<biblScope unit="page" from="833" to="840" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b139">
	<analytic>
		<title level="a" type="main">Semi-supervised self-training of object detection models</title>
		<author>
			<persName><forename type="first">C</forename><surname>Rosenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hebert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Schneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th IEEE workshop on applications of computer vision</title>
				<meeting>the 7th IEEE workshop on applications of computer vision</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="29" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b140">
	<analytic>
		<title level="a" type="main">Nonlinear dimensionality reduction by locally linear embedding</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>Roweis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">K</forename><surname>Saul</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">290</biblScope>
			<biblScope unit="issue">5500</biblScope>
			<biblScope unit="page" from="2323" to="2326" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b141">
	<analytic>
		<title level="a" type="main">Regularization with stochastic transformations and perturbations for deep semi-supervised learning</title>
		<author>
			<persName><forename type="first">M</forename><surname>Sajjadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Javanmardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Tasdizen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1163" to="1171" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b142">
	<analytic>
		<title level="a" type="main">Improved techniques for training gans</title>
		<author>
			<persName><forename type="first">T</forename><surname>Salimans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Goodfellow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zaremba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Radford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="2234" to="2242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b143">
	<analytic>
		<title level="a" type="main">Collective classification in network data</title>
		<author>
			<persName><forename type="first">P</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Namata</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bilgic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Getoor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Galligher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Eliassi-Rad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AI Magazine</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">93</biblScope>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b144">
	<analytic>
		<title level="a" type="main">Active learning</title>
		<author>
			<persName><forename type="first">B</forename><surname>Settles</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Synthesis Lectures on Artificial Intelligence and Machine Learning</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="114" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b145">
	<analytic>
		<title level="a" type="main">A survey on semi-supervised feature selection methods</title>
		<author>
			<persName><forename type="first">R</forename><surname>Sheikhpour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Sarram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gharaghani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A Z</forename><surname>Chahooki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pattern Recognition</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="page" from="141" to="158" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b146">
	<analytic>
		<title level="a" type="main">Semi-supervised learning-A statistical physics approach</title>
		<author>
			<persName><forename type="first">N</forename><surname>Shental</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Domany</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd ICML workshop on learning with partially classified training data</title>
				<meeting>the 22nd ICML workshop on learning with partially classified training data</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b147">
	<analytic>
		<title level="a" type="main">A co-regularization approach to semi-supervised learning with multiple views</title>
		<author>
			<persName><forename type="first">V</forename><surname>Sindhwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Niyogi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Belkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd ICML workshop on learning with multiple views</title>
				<meeting>the 22nd ICML workshop on learning with multiple views</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="74" to="79" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b148">
	<analytic>
		<title level="a" type="main">An RKHS for multi-view learning and manifold co-regularization</title>
		<author>
			<persName><forename type="first">V</forename><surname>Sindhwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Rosenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th international conference on machine learning</title>
				<meeting>the 25th international conference on machine learning</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="976" to="983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b149">
	<analytic>
		<title level="a" type="main">Unlabeled data: Now it now it doesn&apos;t</title>
		<author>
			<persName><forename type="first">A</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Nowak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="1513" to="1520" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b150">
	<analytic>
		<title level="a" type="main">Wasserstein propagation for semi-supervised learning</title>
		<author>
			<persName><forename type="first">J</forename><surname>Solomon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rustamov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Guibas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Butscher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31st international conference on machine learning</title>
				<meeting>the 31st international conference on machine learning</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="306" to="314" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b151">
	<monogr>
		<title level="m" type="main">Unsupervised and semi-supervised learning with categorical generative adversarial networks</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">T</forename><surname>Springenberg</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1511.06390</idno>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b152">
	<analytic>
		<title level="a" type="main">Dropout: a simple way to prevent neural networks from overfitting</title>
		<author>
			<persName><forename type="first">N</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Hinton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Krizhevsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Salakhutdinov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1929" to="1958" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b153">
	<analytic>
		<title level="a" type="main">Soft-supervised learning for text classification</title>
		<author>
			<persName><forename type="first">A</forename><surname>Subramanya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bilmes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the conference on empirical methods in natural language processing</title>
				<meeting>the conference on empirical methods in natural language processing</meeting>
		<imprint>
			<publisher>association for computational linguistics</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="1090" to="1099" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b154">
	<analytic>
		<title level="a" type="main">Semi-supervised learning with measure propagation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Subramanya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bilmes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="3311" to="3370" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b155">
	<analytic>
		<title level="a" type="main">Graph-based semi-supervised learning</title>
		<author>
			<persName><forename type="first">A</forename><surname>Subramanya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">P</forename><surname>Talukdar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Synthesis Lectures on Artificial Intelligence and Machine Learning</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1" to="125" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b156">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Szegedy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zaremba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bruna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Erhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Goodfellow</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1312.6199</idno>
		<title level="m">Intriguing properties of neural networks</title>
				<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b157">
	<analytic>
		<title level="a" type="main">Partially labeled classification with Markov random walks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Szummer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Jaakkola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="945" to="952" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b158">
	<analytic>
		<title level="a" type="main">Information regularization with partially labeled data</title>
		<author>
			<persName><forename type="first">M</forename><surname>Szummer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">S</forename><surname>Jaakkola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="1049" to="1056" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b159">
	<analytic>
		<title level="a" type="main">New regularized algorithms for transductive learning</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">P</forename><surname>Talukdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Crammer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the joint European conference on machine learning and knowledge discovery in databases</title>
				<meeting>the joint European conference on machine learning and knowledge discovery in databases</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="442" to="457" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b160">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b161">
	<analytic>
		<title level="a" type="main">Weakly-supervised acquisition of labeled class instances using graph random walks</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">P</forename><surname>Talukdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Reisinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Paşca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Ravichandran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bhagat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pereira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the conference on empirical methods in natural language processing</title>
				<meeting>the conference on empirical methods in natural language processing</meeting>
		<imprint>
			<publisher>association for computational linguistics</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="582" to="590" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b162">
	<analytic>
		<title level="a" type="main">User-level sentiment analysis incorporating social networks</title>
		<author>
			<persName><forename type="first">C</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th ACM SIGKDD international conference on knowledge discovery and data mining</title>
				<meeting>the 17th ACM SIGKDD international conference on knowledge discovery and data mining</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="1397" to="1405" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b163">
	<analytic>
		<title level="a" type="main">Line: Large-scale information network embedding</title>
		<author>
			<persName><forename type="first">J</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Qu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Mei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th international conference on world wide web, international world wide web conferences steering committee</title>
				<meeting>the 24th international conference on world wide web, international world wide web conferences steering committee</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1067" to="1077" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b164">
	<analytic>
		<title level="a" type="main">An adaboost algorithm for multiclass semi-supervised learning</title>
		<author>
			<persName><forename type="first">J</forename><surname>Tanha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Van Someren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Afsarmanesh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th IEEE international conference on data mining</title>
				<meeting>the 12th IEEE international conference on data mining</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="1116" to="1121" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b165">
	<analytic>
		<title level="a" type="main">Semi-supervised self-training for decision tree classifiers</title>
		<author>
			<persName><forename type="first">J</forename><surname>Tanha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Van Someren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Afsarmanesh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Machine Learning and Cybernetics</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="355" to="370" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b166">
	<analytic>
		<title level="a" type="main">Weight-averaged consistency targets improve semi-supervised deep learning results</title>
		<author>
			<persName><forename type="first">A</forename><surname>Tarvainen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Valpola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1195" to="1204" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b167">
	<analytic>
		<title level="a" type="main">Auto-weka: Combined selection and hyperparameter optimization of classification algorithms</title>
		<author>
			<persName><forename type="first">C</forename><surname>Thornton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Hutter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">H</forename><surname>Hoos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Leyton-Brown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th ACM SIGKDD international conference on knowledge discovery and data mining</title>
				<meeting>the 19th ACM SIGKDD international conference on knowledge discovery and data mining</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="847" to="855" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b168">
	<analytic>
		<title level="a" type="main">Self-labeled techniques for semi-supervised learning: Taxonomy, software and empirical study</title>
		<author>
			<persName><forename type="first">I</forename><surname>Triguero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>García</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Herrera</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Knowledge and Information Systems</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="245" to="284" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b169">
	<analytic>
		<title level="a" type="main">KEEL 3.0: An open source software for multi-stage analysis in data mining</title>
		<author>
			<persName><forename type="first">I</forename><surname>Triguero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>González</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Moyano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>García López</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Alcalá Fernández</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Luengo Martín</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Computational Intelligence Systems</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="1238" to="1249" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b170">
	<analytic>
		<title level="a" type="main">Access to unlabeled data can speed up prediction time</title>
		<author>
			<persName><forename type="first">R</forename><surname>Urner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ben-David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shalev-Shwartz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th international conference on machine learning</title>
				<meeting>the 27th international conference on machine learning</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="641" to="648" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b171">
	<analytic>
		<title level="a" type="main">Semi-supervised boosting for multi-class classification</title>
		<author>
			<persName><forename type="first">H</forename><surname>Valizadegan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Jain</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Joint European conference on machine learning and knowledge discovery in databases</title>
				<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="522" to="537" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b172">
	<monogr>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vapnik</surname></persName>
		</author>
		<title level="m">Statistical learning theory</title>
				<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Wiley</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b173">
	<monogr>
		<title level="m" type="main">Interpolation consistency training for semi-supervised learning</title>
		<author>
			<persName><forename type="first">V</forename><surname>Verma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lamb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kannala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lopez-Paz</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1903.03825</idno>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b174">
	<analytic>
		<title level="a" type="main">Extracting and composing robust features with denoising autoencoders</title>
		<author>
			<persName><forename type="first">P</forename><surname>Vincent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Larochelle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Manzagol</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th international conference on machine learning</title>
				<meeting>the 25th international conference on machine learning</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="1096" to="1103" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b175">
	<analytic>
		<title level="a" type="main">Dropout training as adaptive regularization</title>
		<author>
			<persName><forename type="first">S</forename><surname>Wager</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in information processing systems</title>
				<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="351" to="359" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b176">
	<analytic>
		<title level="a" type="main">Co-training for cross-lingual sentiment classification</title>
		<author>
			<persName><forename type="first">X</forename><surname>Wan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 47th annual meeting of the ACL</title>
				<meeting>the 47th annual meeting of the ACL</meeting>
		<imprint>
			<publisher>association for computational linguistics</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="235" to="243" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b177">
	<analytic>
		<title level="a" type="main">Structural deep network embedding</title>
		<author>
			<persName><forename type="first">D</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zhu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd ACM SIGKDD international conference on knowledge discovery and data mining</title>
				<meeting>the 22nd ACM SIGKDD international conference on knowledge discovery and data mining</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1225" to="1234" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b178">
	<analytic>
		<title level="a" type="main">Label propagation through linear neighborhoods</title>
		<author>
			<persName><forename type="first">F</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Knowledge and Data Engineering</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="55" to="67" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b179">
	<analytic>
		<title level="a" type="main">Graph transduction via alternating minimization</title>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Jebara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">F</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th international conference on machine learning</title>
				<meeting>the 25th international conference on machine learning</meeting>
		<imprint>
			<date type="published" when="2008">2008a</date>
			<biblScope unit="page" from="1144" to="1151" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b180">
	<analytic>
		<title level="a" type="main">Semi-supervised learning using greedy max-cut</title>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Jebara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">F</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="771" to="800" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b181">
	<analytic>
		<title level="a" type="main">A random subspace method for co-training</title>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="middle">X H</forename><surname>Zeng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE international joint conference on neural networks</title>
				<meeting>the IEEE international joint conference on neural networks</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2008">2008b</date>
			<biblScope unit="page" from="195" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b182">
	<analytic>
		<title level="a" type="main">Analyzing co-training style algorithms</title>
		<author>
			<persName><forename type="first">W</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">H</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th European conference on machine learning</title>
				<meeting>the 18th European conference on machine learning</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="454" to="465" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b183">
	<analytic>
		<title level="a" type="main">A new analysis of co-training</title>
		<author>
			<persName><forename type="first">W</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">H</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th international conference on machine learning</title>
				<meeting>the 27th international conference on machine learning</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="1135" to="1142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b184">
	<analytic>
		<title level="a" type="main">Deep learning via semi-supervised embedding</title>
		<author>
			<persName><forename type="first">J</forename><surname>Weston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Ratle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Collobert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th international conference on machine learning</title>
				<meeting>the 25th international conference on machine learning</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="1168" to="1175" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b185">
	<monogr>
		<title level="m" type="main">Principal component analysis. Chemometrics and Intelligent Laboratory Systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Wold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Esbensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Geladi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="37" to="52" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b186">
	<analytic>
		<title level="a" type="main">Robust face recognition via sparse representation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Wright</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ganesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Sastry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Pattern Analysis and Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="210" to="227" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b187">
	<analytic>
		<title level="a" type="main">Learning with partially absorbing random walks</title>
		<author>
			<persName><forename type="first">X</forename><forename type="middle">M</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>So</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wright</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">F</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="2012">2012a</date>
			<biblScope unit="page" from="3077" to="3085" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b188">
	<analytic>
		<title level="a" type="main">Hysad: A semi-supervised hybrid shilling attack detector for trustworthy product recommendation</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th ACM SIGKDD international conference on knowledge discovery and data mining</title>
				<meeting>the 18th ACM SIGKDD international conference on knowledge discovery and data mining</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012b</date>
			<biblScope unit="page" from="985" to="993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b189">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Xu</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1304.5634</idno>
		<title level="m">A survey on multi-view learning</title>
				<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b190">
	<analytic>
		<title level="a" type="main">Dcpe co-training for classification</title>
		<author>
			<persName><forename type="first">J</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Man</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neurocomputing</title>
		<imprint>
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="page" from="75" to="85" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b191">
	<analytic>
		<title level="a" type="main">Unsupervised and semi-supervised multi-class support vector machines</title>
		<author>
			<persName><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Schuurmans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th national conference on artificial intelligence</title>
				<meeting>the 20th national conference on artificial intelligence</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page">13</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b192">
	<analytic>
		<title level="a" type="main">Semi-supervised learning by sparse representation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2009 SIAM international conference on data mining</title>
				<meeting>the 2009 SIAM international conference on data mining</meeting>
		<imprint>
			<publisher>SIAM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="792" to="801" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b193">
	<analytic>
		<title level="a" type="main">Revisiting semi-supervised learning with graph embeddings</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Salakhutdinov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd international conference on machine learning</title>
				<meeting>the 33rd international conference on machine learning</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="40" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b194">
	<analytic>
		<title level="a" type="main">Unsupervised word sense disambiguation rivaling supervised methods</title>
		<author>
			<persName><forename type="first">D</forename><surname>Yarowsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd annual meeting of the association for computational linguistics</title>
				<meeting>the 33rd annual meeting of the association for computational linguistics</meeting>
		<imprint>
			<publisher>association for computational linguistics</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="189" to="196" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b195">
	<analytic>
		<title level="a" type="main">Co-training with relevant random subspaces</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Yaslan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Cataltepe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neurocomputing</title>
		<imprint>
			<biblScope unit="volume">73</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1652" to="1661" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b196">
	<analytic>
		<title level="a" type="main">Bayesian co-training</title>
		<author>
			<persName><forename type="first">S</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Krishnapuram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rosales</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">B</forename><surname>Rao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="2649" to="2680" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b197">
	<analytic>
		<title level="a" type="main">mixup: Beyond empirical risk minimization</title>
		<author>
			<persName><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Cisse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">N</forename><surname>Dauphin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lopez-Paz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International conference on learning representations</title>
				<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b198">
	<analytic>
		<title level="a" type="main">Prototype vector machine for large scale semi-supervised learning</title>
		<author>
			<persName><forename type="first">K</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">T</forename><surname>Kwok</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Parvin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th international conference on machine learning</title>
				<meeting>the 26th international conference on machine learning</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="1233" to="1240" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b199">
	<analytic>
		<title level="a" type="main">Tsfs: A novel algorithm for single view co-training</title>
		<author>
			<persName><forename type="first">W</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Zheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd IEEE international joint conference on computational sciences and optimization</title>
				<meeting>the 2nd IEEE international joint conference on computational sciences and optimization</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="492" to="496" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b200">
	<analytic>
		<title level="a" type="main">Learning with local and global consistency</title>
		<author>
			<persName><surname>Ieee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Bousquet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">N</forename><surname>Lal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Weston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Schölkopf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
				<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="321" to="328" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b201">
	<analytic>
		<title level="a" type="main">Democratic co-learning</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th IEEE international conference on tools with artificial intelligence</title>
				<meeting>the 16th IEEE international conference on tools with artificial intelligence</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="594" to="602" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b202">
	<monogr>
		<title level="m" type="main">Ensemble methods: Foundations and algorithms</title>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">H</forename><surname>Zhou</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>CRC Press</publisher>
			<pubPlace>Boca Raton</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b203">
	<analytic>
		<title level="a" type="main">Semi-supervised regression with co-training</title>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">H</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th international joint conference on artificial intelligence</title>
				<meeting>the 19th international joint conference on artificial intelligence</meeting>
		<imprint>
			<date type="published" when="2005">2005a</date>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="908" to="913" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b204">
	<analytic>
		<title level="a" type="main">Tri-training: Exploiting unlabeled data using three classifiers</title>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">H</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Knowledge and Data Engineering</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1529" to="1541" />
			<date type="published" when="2005">2005b</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b205">
	<monogr>
		<title level="m" type="main">Semi-supervised learning by disagreement. and Information Systems</title>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">H</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Li</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="415" to="439" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b206">
	<monogr>
		<title level="m" type="main">Semi-supervised learning literature survey</title>
		<author>
			<persName><forename type="first">X</forename><surname>Zhu</surname></persName>
		</author>
		<idno>. 1530</idno>
		<imprint>
			<date type="published" when="2005">2005. 2008</date>
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon University. Zhu, X. ; University of Wisconsin-Madison</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>Semi-supervised learning with graphs</note>
</biblStruct>

<biblStruct xml:id="b207">
	<monogr>
		<title level="m" type="main">Learning from labeled and unlabeled data with label propagation</title>
		<author>
			<persName><forename type="first">X</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Ghahramani</surname></persName>
		</author>
		<idno>. CMU-CALD-02-107</idno>
		<imprint>
			<date type="published" when="2002">2002a</date>
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b208">
	<monogr>
		<title level="m" type="main">Towards semi-supervised classification with Markov random fields</title>
		<author>
			<persName><forename type="first">X</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Ghahramani</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002b</date>
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">CMU-CALD-02-106</note>
</biblStruct>

<biblStruct xml:id="b209">
	<analytic>
		<title level="a" type="main">Semi-supervised learning using Gaussian fields and harmonic functions</title>
		<author>
			<persName><forename type="first">X</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Ghahramani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Lafferty</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th international conference on machine learning</title>
				<meeting>the 20th international conference on machine learning</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="912" to="919" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b210">
	<analytic>
		<title level="a" type="main">Introduction to semi-supervised learning</title>
		<author>
			<persName><forename type="first">X</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Goldberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Synthesis Lectures on Artificial Intelligence and Machine Learning</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="130" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b211">
	<analytic>
		<title level="a" type="main">Harmonic mixtures: Combining mixture models and graph-based methods for inductive and scalable semi-supervised learning</title>
		<author>
			<persName><forename type="first">X</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lafferty</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd international conference on machine learning</title>
				<meeting>the 22nd international conference on machine learning</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="1052" to="1059" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b212">
	<analytic>
		<title level="a" type="main">Non-negative low rank and sparse graph for semi-supervised learning</title>
		<author>
			<persName><forename type="first">L</forename><surname>Zhuang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2012 IEEE conference on computer vision and pattern recognition</title>
				<meeting>the 2012 IEEE conference on computer vision and pattern recognition</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="2328" to="2335" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b213">
	<monogr>
		<title level="m" type="main">Publisher&apos;s Note Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations</title>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
