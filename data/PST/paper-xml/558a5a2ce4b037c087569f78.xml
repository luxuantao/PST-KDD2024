<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Nurse Rostering System Using Constraint Programming and Redundant Modeling</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">B</forename><forename type="middle">M W</forename><surname>Cheng</surname></persName>
						</author>
						<author>
							<persName><forename type="first">J</forename><forename type="middle">H M</forename><surname>Lee</surname></persName>
						</author>
						<author>
							<persName><forename type="first">J</forename><forename type="middle">C K</forename><surname>Wu</surname></persName>
						</author>
						<title level="a" type="main">A Nurse Rostering System Using Constraint Programming and Redundant Modeling</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">B4FDA67A166BF166AED344BA321908C3</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T02:40+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper describes the design and implementation of a constraint-based nurse rostering system using a redundant modeling approach. Nurse rostering is defined as the process of generating timetables for specifying the work shifts of nurses over a given period of time. This process is difficult because the human roster planner has to ensure that every rostering decision made complies with a mixture of hard hospital rules and soft nurse preference rules. Moreover, some nurse shift pre-assignments often break the regularity of wanted (or unwanted) shifts and reduce the choices for other unfilled slots. Soft constraints amount to disjunction, which can be modeled as choices in the search space. This approach, although straightforward, incurs overhead in the search of solution. To reduce search time, we propose redundant modeling, an effective way to increase constraint propagation through cooperations among different models for the same problem. Our problem domain involves around 25 to 28 nurses and 11 shift types. Experiments and pilot testing of the system confirm the effectiveness and efficiency of our method.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>T HE PROBLEM at hand is to design and implement a nurse rostering system for the Accident and Emergency Unit of the Tang Shiu Kin Hospital, Hong Kong. The problem domain involves generating weekly timetables for a group of nurses, whose ranks, rules to be abided (be it hard or soft) and specific shift requests are different. The duty planner currently produces the duty roster manually. This task is difficult for the duty planner for three reasons. First, there are 25 to 28 nurses of different skill classes with 11 possible shift types. The search space is enormous. The state-of-the-art system reported in <ref type="bibr" target="#b43">[44]</ref> can handle less than 12 nurses with three shift types. The same reported system also solves a problem with 30 nurses in a single skill class. Second, there are a number of hard hospital rules and soft nurse preference rules to be obeyed. Most of the hard rules are very tight, and many soft planning rules are often incompatible with each other. Third, the duty planner allows nurse to request shift preassignments. The requests often make the roster generation process even more difficult. For example, suppose a group of nurses requests to have a day off on Sunday. If this group is too large, it may over-reduce the available manpower to work on Sunday. It may also disturb normal sequences of some wanted (or unwanted) shifts and affect the fairness and quality of the roster. In addition to assigning who to work on Sunday, the duty planner also has to consider whose shift requests to reject.</p><p>Inspired by the work of Weil et al. <ref type="bibr" target="#b43">[44]</ref>, we employ a constraint-based approach in the construction of this nurse rostering system. This approach amounts to modeling the nurse rostering problem as a constraint satisfaction problem and using constraint programming tools for system implementation. A constraint satisfaction problem (CSP) is defined as <ref type="bibr" target="#b24">[25]</ref>:</p><p>We are given a set of variables, a domain of possible values for each variable, and a conjunction of constraints. Each constraint is a relation defined over a subset of the variables, limiting the combination of values that the variables in this subset can take. The goal is to find a consistent assignment of values to the variables so that all the constraints are satisfied simultaneously. After modeling the problem as a CSP, constraint programming tools are used to build up the constraint-solving engine. Constraint programming tools provide a rich set of constraintsolving functions and routines, and greatly facilitates the implementation process. The expressiveness and efficiency of constraint programming in solving such kind of scheduling problem are described in <ref type="bibr" target="#b23">[24]</ref>. In this project, we adopt ILOG SOLVER, a C class library <ref type="bibr" target="#b36">[37]</ref>, <ref type="bibr" target="#b16">[17]</ref>, as our tool. We encounter two major difficulties in the development process. First, shift pre-set requests adversely affect the efficiency of the rostering system in two ways. They cause the choices for remaining shifts to become tight and limited, and break the regularity of some wanted and unwanted shifts. Second, the problem domain consists of a series of soft planning rules. We model soft rules as disjunctions in the search tree. In this approach, the search space increases combinatorially with the number of soft rules and nurses. Solution generation efficiency is degraded.</p><p>We cope with these difficulties by applying the concept of redundant modeling <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b4">[5]</ref> in the system. Redundant modeling is based on the observation that there is usually more than one way of modeling a problem as a CSP. By modeling a problem as a CSP, we mean the process of determining the variables, the associated domains of the variables, and the expressions of the constraints. Our method amounts to implementing more than one model of a given problem and connect the model implementations. Theoretically, not pragmatically, any one model implementation suffices to solve the CSP at hand completely. Therefore, the models are redundant with respect to one another. The combined model contains the original but redundant models as sub-models. Constraints in the sub-models cooperate during constraintsolving by propagating constraints freely amongst the submodels. This extra level of pruning and propagation activities becomes the source of execution speedup. We create two different models for the nurse rostering problem. In the first model, the variables are nurses and the domains are the shifts; in the second model, the variables are the shifts and the domains are the nurses. The two models are then connected using channeling constraints to speed up constraint-solving <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b5">[6]</ref>. Experiments and pilot testing of the system confirm the feasibility of our method. In most runs, the system is able to return a quality solution in less than a minute of CPU time on a Pentium-class personal computer.</p><p>The rest of this paper is organized as follows. Section II provides an account of related work in the field of nursing staff rostering. In Section III, we give a brief synopsis of constraint programming and available tools. In Section IV, the domain of our rostering problem is detailed. Operations and structures of the Tang Shiu Kin Hospital, as well as the various planning rules, are described in length. Section V describes how the technique of redundant modeling is applied in the modeling of the nurse rostering problem. We outline design and implementation issues of the rostering system in Section VI. Section VII discusses the tension between solution efficiency and quality, followed by benchmarking results in Section VIII. Section IX summarizes our contributions and sheds light on future direction of research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. RELATED WORK</head><p>There have been extensive attempts to solve the nurse rostering problem <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b18">[19]</ref>, <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b27">[28]</ref>, <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b32">[33]</ref>, <ref type="bibr" target="#b37">[38]</ref>, <ref type="bibr" target="#b38">[39]</ref>, <ref type="bibr" target="#b42">[43]</ref>, <ref type="bibr" target="#b43">[44]</ref>, which can be classified into three main approaches. The first approach amounts to modeling the rostering problem mathematically and applying methods in operations research to search for solutions <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b42">[43]</ref>. This approach, though a solution can be found in a relatively short time, is too rigid to incorporate the flexibility of the problem domain. It also requires a lot of computing resources <ref type="bibr" target="#b27">[28]</ref>. The second approach is to design domain-specific heuristics and algorithms for solving the rostering problem <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b27">[28]</ref>, <ref type="bibr" target="#b32">[33]</ref>. It usually formulates the problem as optimization of certain criteria, such as nurse satisfaction and staff turn-over percentage. These methods are not generic. In addition, successful algorithms and heuristics in a particular scenario may not perform well in other problem domains <ref type="bibr" target="#b23">[24]</ref>. Moreover, these systems are often written in imperative languages, which cast large implementation overhead. The last approach employs constraint programming <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b23">[24]</ref>, <ref type="bibr" target="#b43">[44]</ref>. This approach is by far the most promising for its expressiveness to model problems as CSP's, in which one only needs to concentrate on the representation of variables and constraints. Solutions can be transparently generated by builtin solution generation procedure in constraint programming systems. Slight modification to the problem domain usually induces small change to the implementation. The emergence of various constraint programming tools further allow other programming methodologies, such as object-orientation, to be incorporated in constraint programming.</p><p>Our problem instance differs from those in the literature in three aspects. First, nurses in our domain prefer to work for different shifts in different days. That means that the duty planner needs to generate nonconsecutive shifts patterns. This process is difficult to achieve using specific algorithms, and constraint programming facilitates expression of such requirements. On the other hand, it is relatively simple to design specific algorithms to generate consecutive shifts over consecutive days <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b27">[28]</ref>. Second, in most of the existing nurse rostering problems, only a few main shifts (AM, PM, Night, Day-off) are involved. However, our problem domain has a total of 11 shifts, and many of them are governed by complicated planning rules. This increases the difficulty and complexity of our problem considerably. Third, rosters are not generated as cyclic schedules, in which nurses take turn in performing each and every one of the shift patterns in the roster. There are two implications. Rosters have to be generated every week, increasing the workload of the duty planner. Fairness in shift assignment, which is one of the dominant factors that determine the morale of the nursing staff, becomes an important criterion in roster generation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. CONSTRAINT PROGRAMMING</head><p>Real-world scheduling problems are combinatorial in nature. In its simplest form, scheduling problems are no different from classical combinatorial problems such as graph colorings, -queen puzzles and crypt-arithmetic problem. All of the problems involve solution searching from a large search space under various kind of constraints <ref type="bibr" target="#b40">[41]</ref>. These problems are collectively called CSP's. In this section, we give a brief introduction to CSP, an overview of the constraint programming approach to solving CSP's, and the available tools.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Features of Constraint Satisfaction Problems</head><p>A constraint satisfaction problem (CSP) is defined as a 3-tuple , where • is a finite set of variables ; • is a function mapping each variable to a finite set of possible values called the domain of ; • is a finite set of constraints, each of which acts on a subset of variables in restricting the possible combination of values that these variables can take. A solution to a CSP is a consistent variable assignment so as to make all constraints satisfied simultaneously. A naive solution for CSP is generate-and-test but it is grossly inefficient. A more efficient approach is backtracking tree search, which essentially performs a depth-first search <ref type="bibr" target="#b19">[20]</ref> of the space of the potential CSP solutions. The performance of backtracking, although better than generate-and-test, is still poor due to its thrashing <ref type="bibr" target="#b14">[15]</ref> behavior.</p><p>Constraint propagation, based on node/arc/path consistency techniques <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b24">[25]</ref>, <ref type="bibr" target="#b25">[26]</ref>, <ref type="bibr" target="#b29">[30]</ref>, <ref type="bibr" target="#b41">[42]</ref>, is a more sophisticated approach to tackle CSP's. In this approach, variables are represented by nodes in a graph and binary constraints are represented by edges. During constraint propagation along the edges, values are removed from the domains of the nodes until each arc (constraint) is individually satisfiable. However, global satisfiability is not guaranteed and searching is needed. Different constraint satisfaction algorithms are obtained by combining tree searching and different degrees of constraint propagation <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b13">[14]</ref>- <ref type="bibr" target="#b15">[16]</ref>, <ref type="bibr" target="#b26">[27]</ref>, <ref type="bibr" target="#b30">[31]</ref>, <ref type="bibr" target="#b34">[35]</ref>.</p><p>Given a CSP, we first use a constraint propagation algorithm, such as the well-known arc consistency algorithm AC-3 <ref type="bibr" target="#b24">[25]</ref> as explained above, to attain a desired level of consistency. If no solution or inconsistency is found, then one of the variables with domain size larger than one is selected and a new CSP is created for each possible assignment of this variable. These new CSP's become the successor of the current CSP. Repeating this constraint propagation and domain enumeration process for each new CSP results in possibly more new CSP's. All newly generated CSP's can be organized conveniently in the form of a search tree with the original CSP as the root node. A standard backtracking algorithm can be used to visit these nodes to search for solutions.</p><p>We have two choices in the above tree search process: variable-ordering and value-ordering. These orderings can affect the efficiency of the search strategies significantly. Variable-ordering concerns which variable to instantiate next; whereas value-ordering sets the order in which values in the domain of the chosen variable are tried. Variable-ordering can greatly affect the branching factor and hence also the size of the resulting search space. Value-ordering affects the ordering of branches in the search tree. This is important when users are interested in obtaining the first solution of a CSP fast using some form of depth-first search strategy. Therefore, various variable-and value-ordering heuristics <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b15">[16]</ref>, such as the first-failed principle, have been devised to speed up solving of particular CSP instances. These heuristics are, however, usually problem and domain specific.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Constraint Programming Tools</head><p>There are a wide variety of constraint programming languages and tools, such as Prolog III <ref type="bibr" target="#b7">[8]</ref>, CLP <ref type="bibr" target="#b17">[18]</ref>, and CHIP <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b40">[41]</ref>. These languages and tools, each differing in its constraint domain and serving in different areas of applications, offer an expressive and flexible language for problem specification and heuristics programming, allowing rapid program development for complex problems and enabling programs to be easily modified and extended. CSPsolving and scheduling are most related to CHIP and ILOG SOLVER <ref type="bibr" target="#b36">[37]</ref>, the uniqueness of which come from their finite domain constraint-solving capabilities. The idea underlying CHIP is to enhance Prolog with constraint propagation techniques <ref type="bibr" target="#b24">[25]</ref>, which prunes the search space before performing tree search. ILOG SOLVER <ref type="bibr" target="#b36">[37]</ref> is a constraint programming tool that merges constraint propagation techniques <ref type="bibr" target="#b24">[25]</ref> and object-oriented programming. ILOG SOLVER is realized as a C library that embodies such constraint logic programming concepts as logical variables, incremental constraint satisfaction, and backtracking. ILOG SCHEDULE <ref type="bibr" target="#b21">[22]</ref>, built on top of ILOG SOLVER, is a library of specialized constraints for constraint-based scheduling. CHIP and ILOG SOLVER have been applied successfully to solving such industrial applications as car sequencing, disjunctive scheduling, graph coloring, and firmware design. A fuller account of their applications can be found in <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b22">[23]</ref>, <ref type="bibr" target="#b31">[32]</ref>, <ref type="bibr" target="#b33">[34]</ref>, <ref type="bibr" target="#b35">[36]</ref>, and <ref type="bibr" target="#b40">[41]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. DOMAIN DESCRIPTION</head><p>Tang Shiu Kin Hospital is a multi-discipline hospital in Hong Kong. It consists of a number of operation units, the Accident and Emergency Unit (AEU) being one of them. The AEU provides 24-h emergency services to the general public seven days a week.</p><p>Currently, there are 55 personnel at the AEU. Around 25 to 28 of them are nurses of different ranks. These ranks include midwife nurses (N/M), registered nurses (RN), enrolled nurses (EN), male registered nurses (RN(m)), enrolled nurses (EN(m)) and part-time nurses (PTN).</p><p>Nurses in the AEU work in shifts. Generally speaking, there are three basic shifts in a day, namely AM shift (A), PM Shift (P), and Night Shift (N). An evening shift (E) is essentially a PM shift with a slightly different duty time. An irregular shift (I) has special working hours either arranged by the nursing officer or requested by individual nursing staff member. Nurses are entitled to different types of holiday. These includes day-off (O), compensation-off (CO), public holiday (PH), and vacation leave (VL). In addition, nurses can be pre-assigned some special work shifts such as study day (SD) and staff-on-loan (SOL). In total there are 11 shift types.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Overall Planning Operation</head><p>Around two weeks before the actual implementation of the rota, the duty planner, who is either the Ward Manager or one of the Nursing Officers, receives preferred shift requests from the staff. Based on the requests, the vacation leave list, the study day list, the Staff-on-Loan list and the past day-off history list (PH, CO, Saturday and Sunday day-off list), the duty planner generates a duty sheet and releases it to the staff. The staff can negotiate for adjustments in the duty sheet, but usually this is done through interchanging shifts with other nursing staff members.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Planning Rules</head><p>The planning rules to be respected by the duty planner can be categorized into two main types: imperative planning rules and preference planning rules. Imperative planning rules are rules that must be respected in any timetable. Therefore, in generating the roster, the duty planner must ensure that every planning decision made is coherent with these hard rules. Preference planning rules should be satisfied as much as possible but they can be violated. These planning rules are mainly nurse preferences on the timetable and are results of extensive consultation and consensus with the nursing staff. Thus these rules define the "goodness" of the timetable generated. The more preference planning rules a timetable respects, the better the timetable is.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. PROBLEM MODELING</head><p>This section describes the modeling of the system. Our system consists of two separate programs. The first program is a core constraint engine for generating rosters. This core engine is built using the principle of redundant modeling <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b5">[6]</ref>. This concept is to define and connect multiple, yet mutually redundant, CSP models for the same problem to form an aggregate model. The aggregate model exhibits significant speedup in constraint propagation over any of the model when used alone. The second program is a graphical user interface for user interaction. In the following, we give a brief introduction to redundant modeling, followed by a description of the two models for our nurse rostering problem. Readers interested in details of the redundant modeling approach are referred to <ref type="bibr" target="#b4">[5]</ref> and <ref type="bibr" target="#b5">[6]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Principle of Redundant Modeling</head><p>We can view virtually any real-world scheduling process in two ways. For example, a generic job-shop scheduling problem can be formulated as assigning machines to workers or assigning workers to machines. Similarly, a school timetabling problem can be seen as allocation of courses to timeslots or allocation of timeslots to courses.</p><p>From a CSP point of view, each modeling approach corresponds to one CSP and a constraint network. There is usually not a single model that is effective enough to tackle real world problems efficiently. <ref type="foot" target="#foot_1">1</ref> Experience suggests that some constraints can be expressed succinctly in one model and yet the same constraints result in a cumbersome specification in another model. In addition, some constraints propagate and prune well when expressed in one model and yet expression of the same constraints in another model exhibits opposite pruning behavior.</p><p>Our approach is inspired by the effectiveness of redundant constraints,<ref type="foot" target="#foot_2">2</ref> which are redundant semantically but augment the propagation and pruning of the original constraints of a CSP, in speeding up constraint-propagation. Intuitively speaking, our method amounts to implementing more than one model of a given problem and somehow connect the model imple- mentations. Theoretically, not pragmatically, any one model implementation suffices to solve the CSP at hand completely. Therefore, the models are redundant with respect to one another. Each model implementation corresponds to a constraint network. In order for the different models to cooperate during constraint-solving, the network must be connected so that pruning can be propagated among the networks in a multidirectional manner. One way to achieve a multi-directional connection is to use constraints to express the relationship among variables in different models. We call such constraints, which are not part of the original problem specification and exist only as an artifact of network connection, channeling constraints. Suppose now we have two models for the same problem. The first model assigns type to type and the second model assigns type to type . An effective channeling constraint in this case takes the following form:</p><p>The variable associated with object of type has object of type as value if and only if the variable associated with has as value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Problem Models</head><p>In this section, we describe two models for the nurse rostering problem. The first model is based naturally on the format of the roster sheet, which suggests allocation of shifts to nurses. Implementation of the first model performs well in general but fails to return answer in a timely manner for some difficult cases. This prompts us to look for another model which is complimentary to the first model in terms of constraint expressiveness and efficiency. The resulting second model is based on an allocation of nurses to shifts. Implementation of the second model again exhibits deficiency on some problem instances while performing well in general. Having two mutually redundant models in hand, we proceed to connect the models using channeling constraints.</p><p>1) Slot Model: The slot model for the nurse rostering problem is inspired by the layout of the roster, as shown in Fig. <ref type="figure">1</ref>, which suggests allocating shifts to nurses. Each slot in the roster constitutes a variable Nurse-Day of the model, which denotes the shift assigned to nurse Nurse on the day Day. We call each such variable a slot variable. The associated domains of slot variables contain the shifts available to the nurses. As the roster is generated on a weekly basis, each nurse is associated with seven slot variables.</p><p>2) Shift Model: This model results from another view of the problem. The shifts become variables. We call them shift variables. Each shift variable Shift-Day denotes the set of nurses assigned to work in shift Shift on the day Day. There are usually more than one nurse working in a shift so that the domain of each shift variable is the powerset of the set of all nurses. The scenario is depicted in Fig. <ref type="figure" target="#fig_2">2</ref>. For a weekly roster, the number of such variables is seven times the number of shift types, and is constant regardless of the number of nurses. However, the size of the domains depends on the number of nurses.</p><p>3) Aggregate Model: The two models are connected to form an aggregate model of the problem, using channeling constraints of the following form: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Hard Constraints Modeling</head><p>Hard constraints are results of the imperative planning rules which must be satisfied at all cost. These imperative rules can be expressed conveniently as constraints since constraints are by default hard in most constraint programming tools. In the following, we discuss how we model only some of the representative constraints in the two models. Modeling of other constraints are similar. Interested readers are referred to <ref type="bibr" target="#b6">[7]</ref>.</p><p>1) Slot Model: In the slot model, we have Rule 1 satisfied for free since the rule is implicitly satisfied by requiring each constrained variable to take on exactly one value. Rule 2 can be modeled using a counting constraint <ref type="bibr" target="#b16">[17]</ref> as follows:</p><p>For each nurse Nurse, the number of variables in Nurse-Mon , , Nurse-Sun assigned with the O shift must be equal to one. Rule 3 is expressed using a boolean implication constraint " " <ref type="bibr" target="#b16">[17]</ref>, which is a reflection of a boolean implication logical relation between two variables, as follows:</p><p>For each nurse Nurse and for each Day from Tuesday to Sunday, Nurse-Day is Nurse-Day' is , where Day' prev(Day), and prev() is a function that takes a day as input and returns the previous day of the input.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2) Shift Model:</head><p>The variables in this model are constrained set variables <ref type="bibr" target="#b16">[17]</ref>, which have as domains a powerset. The value of a constrained set variable is thus a set. As a result, the planning rules are modeled using primitive set constraints <ref type="bibr" target="#b16">[17]</ref> on these variables. Rule 1 is expressed using two set constraints on the 11 shifts in a day: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Soft Constraints Modeling</head><p>Preference planning rules, or soft constraints, are expressed in the same manner as imperative planning rules. There is, however, one significant difference in how they are posted to the constraint-solving engine. For each soft constraint , we set up a choice point. In the first branch, the constraint is told to the solver. The other branch, one without , is tried upon backtracking. Some of the soft constraints are mutually incompatible. In other words, satisfying one soft constraint may make it impossible to satisfy another one. Therefore, the order by which the soft constraints are posted to the constraint engine becomes important. In the case that some soft constraints are mutually inconsistent to each other, constraints posted the last (or those closer to the leaf nodes of the search tree) are backtracked into before those posted earlier (or those closer to the root node of the search tree).</p><p>The problem at hand is to decide an order of importance among the soft constraints. There are three areas in which such ordering can be based on: 1) among each planning rule as a whole, 2) among the days for those constraints which affect a series of days, and 3) among the nurses. The first order is a user-defined parameter, which reflects the priority of different planning rules. The second and third ordering is generated randomly. This ensures that no human factor is involved in the decision process, in which fairness is an important criterion.</p><p>Rules 9 and 11 are difficult to model as constraints in the constraint-solving engine. We devise a sequential algorithm to allocate the shift for the following reasons. First, allocation of N shifts is subject to a number of difficult constraints. Second, the process involves many history records such as the date of the last N shift for each nurse, date of last E shift for each nurse, and so on. Third, there are always cases that some nurses cannot take N shift even after they have been assigned to do so because of nurse preference shift requests.</p><p>The algorithm in Fig. <ref type="figure" target="#fig_5">3</ref> is based on the idea that the earlier the date of last shift (type of which can be N or E) of a nurse is, the sooner the shift should be allocated to the nurse. For example, suppose nurse and have their last N shifts on November 4 and November 6, respectively. Further suppose that there are two N shifts to be allocated on November 12 and 13. It is normal to assign the N shift on the 12th to nurse and the 13th to nurse . However, suppose nurse has pre-set shift SD on November 12, causing unable to take N shift on that day. An obvious answer is to exchange the shift with nurse so that nurse takes N shift on the 12th and nurse takes N shift on the 13th. Suppose there is further complication that nurse has also pre-set shift on the 12th. Then there must be another nurse replacing the shift. The main goal of our algorithm is to specify how to choose such nurse to replace the shift.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. SYSTEM DESIGN AND IMPLEMENTATION</head><p>We implement the rostering system on personal computer (PC), which is chosen over workstation for PC's wide availability. Our implementation consists of a user-interface and a rostering engine. The former is implemented in Microsoft Visual Basic 3.0 while the latter is realized in C with ILOG SOLVER library 3.0 <ref type="bibr" target="#b16">[17]</ref>. Class constraints <ref type="bibr" target="#b16">[17]</ref> of ILOG SOLVER facilitate our object-oriented design and greatly reduce our coding effort.</p><p>We show in the last section two ways of modeling the nurse rostering problem as a CSP by giving the respective sets of variables, the associated domains of the variables, and the sets of constraints. In this section, we present the system design and implementation issues of the nurse rostering system. There are five important classes of individuals in the system, namely nurses, timetable slots, shifts, days of a week, and timetables. The first two classes are used for the slot model and the remaining three classes are used for the shift model. We implement the individuals as objects in C . In the following, we describe the definition of these object classes.</p><p>1) Slot Class: Each instance of the Slot class represents a slot in a timetable. It is implemented as a derived class (or subclass) of the built-in constrained integer variable <ref type="bibr" target="#b16">[17]</ref> class of ILOG SOLVER. The principle components of a constrained integer variable are a value and an associated domain. The domain of a Slot object consists of the 13 shift types. <ref type="foot" target="#foot_3">3</ref>Being a subclass of the constrained integer variable class, the Slot class inherits all the features of constrained integer variable. Therefore, we can post constraints that are applicable to constrained integer variables, such as counting constraints and arithmetic constraints, to Slot objects.</p><p>2) Nurse Class: Each instance of the Nurse object class represents a nurse in the nurse rostering system. A Nurse object contains two types of state information: static information and dynamic information. Static information includes:</p><p>• name, rank and employment date of a nurse;</p><p>• shift history records: roster of the previous week, number of N shifts taken, number of CO1 and CO2 pending, the last PH shift, dates of the last N and E shifts, dates of last CO1 and CO2 shifts, and a flag indicating whether the nurse has VL in the previous week. This information is necessary for Rules 3-5.</p><p>Dynamic information includes an eight-element array of Slot objects, each element of which represents a day in a week. The eighth element represents the slot on next Monday. The extra Slot object is necessary for the enforcement of Rules 3 and 14. In other words, each Nurse object holds the weekly timetable for one nurse. Accordingly, N Nurse objects comprise the timetable for N nurses.</p><p>In addition to state information, a Nurse object is associated with a number of operations. Class constructor operations define the initialization module of the object. These operations are executed right after object creation. Various class constraints are posted there. State accessing functions provide an interface to access the state information of a Nurse object. For example, the getMonday member function returns a pointer to the Monday Slot of the nurse. State modifying functions provide an interface to modify the state information of a nurse object. For example, the setName member function sets the name of the Nurse object.</p><p>3) Shift Class: Each instance of the Shift class denotes a shift in the problem. A Shift object contains the following:</p><p>• a constrained set variable, whose domain is the powerset of the set of all nurses (instances of the Nurse class); • an integer indicating to which day in a week this shift belongs. The constrained set variable denotes the group of nurses assigned to work in that shift.</p><p>Most of the shifts in the problem can be represented by the Shift class. However, there are some special requirement constraints on the nurses in A shift, P shift, N shift and E shift. These shifts are conveniently modeled as subclasses of the Shift class. Consider the A shift, for example. According to Rule 5, there should be eight nurses working in the A shift. Out of these eight nurses, at most three nurses can be male, and at least one nurse should be N/M. Thus, in the AShift class which is a subclass of the Shift class, three more integer state variables are included to indicate:</p><p>• shift size for all nurses;</p><p>• maximum number of male nurses; • minimum number of N/M nurses. These state variables are then used by the class constructor functions of the AShift class to post the corresponding constraints.</p><p>4) Day Class: Instances of the Day class can be viewed as a place holder of 13 variables of Shift class objects. These 13 variables denote the 13 different shifts that a nurse can take in a day of the scheduled week. They are A, P, N, E, O, H, CO1, CO2, PH, SD, SOL, VL, UD. The Day class facilitates the modeling of constraints that act on all shifts within a day.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5) Table Class:</head><p>There is only one instance of the Table class, which acts as the place holder for Day objects in a timetable. Currently the timetable denotes a weekly roster. Therefore seven Day objects are declared inside a Table <ref type="table">class</ref>. The Table <ref type="table">class</ref> facilitates the modeling of constraints that act on all shifts within a week.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. SOLUTION EFFICIENCY VERSUS SOLUTION QUALITY</head><p>Execution of the nurse rostering engine is divided into four steps. First, all shift pre-assignment requests are collected. Second, the N and E shifts allocation algorithm is invoked to assign E and N shifts. Third, the rest of the constraints (hard or soft) induced by the planning rules (imperative or preference) are collected and told to the constraint engine. Fourth, a standard variable labeling algorithm is used to search for solutions. There are two things to note regarding variable labeling. First, since the aggregate model contains the slot model and the shift model as sub-models, labeling variables of either model will instantiate also variables in the other model. We can choose to label either set of variables. Second, we employ the simple smallest-domain-first variable-ordering heuristics and the smallest-first value-ordering heuristics in the variable labeling process. This corresponds to the a simple application of the first-fail principle <ref type="bibr" target="#b15">[16]</ref>.</p><p>We have mentioned that the number of soft constraints satisfied is an indicator of the quality of the solution. The more soft constraints the solution satisfies, the better the solution is. Our system implements soft constraints as part of the solution searching process. This approach is by no means efficient as the search space grows exponentially to the number of soft constraints although efficiency is compensated by redundant modeling. For example, the depth of the search space increases by 6 N for implementing Rule 7 for N nurses,</p><p>In some cases, even if we do not post some of the soft constraints, the generated solution may satisfy the unposted soft constraints. The reasons are:</p><p>• Requirements of the constraints may overlap.</p><p>• The hard constraints, pre-set shift requests, other posted soft constraints affect the solution searching engine nondeterministically to produce a solution that is in favor of unposted soft constraints. Nonetheless, these factors cannot be relied upon to enforce any soft rule. If a soft rule is important, it should be taken account in the solution search process.</p><p>To cope with this problem, we propose to parameterize the level of solution quality. A high level of solution quality requires the solution searching engine to explore more deeply into the search space by allowing more soft constraint in the search tree. A low level of solution quality requires the search engine to minimize exploration in the search space so as to generate a solution as quickly as possible. This parameter can be finely adjusted by allowing the user to specify selectively which soft constraint of which nurse to be enforced.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. BENCHMARKING RESULTS</head><p>Our real-life benchmark data contains 27 nurses and 13 shift types (two shift types are artificially added for handling difficult cases). The theoretical complexity of the search space  (or 4 052 555 153 018 976 267). The rostering system produces weekly roster sheets. <ref type="foot" target="#foot_4">4</ref> The implementation of the slot model generates 3884 constraints, out of which 266 are imperative, during execution. Executing the shift model implementation results in 1827 constraints, out of which 1675 are imperative. These unbalanced figures reflect two phenomena. First, some types of constraints are more expressive and concise than others. Second, some planning rules that are easier to express in one model can be tedious to formulate in another model. Finally, the aggregate model consists of, in addition to the constraints from the slot and the shift models, 2079 channeling constraints.</p><p>We have tested the system based on real-life data from the hospital. The tests differ in terms of the number of shift pre-assignments and soft constraints posted. There are several ways to generate solutions from the system. First, we can search for solutions purely based on the slot model. That means solution generations amount to posting all the constraints in the slot model and instantiating the slot variables only. Alternatively, we can use the shift model and generate rosters by instantiating the shift variables only. In both cases, the system performs satisfactorily (about 10 s for building up variables and the constraint network, 10 s to get the solutions) in the problem instances where no or few pre-set shifts are present and only one to two soft constraints are posted. When there are more pre-set shifts or more soft constraints, the system fails to generate solutions within 10 h in some difficult cases, irrespective of the choice of models.</p><p>The other way to get rosters from the system is from the aggregate models. As mentioned before, forming an aggregate model from sub-models involves channeling constraints which connect the variables in one model to variables in another model. <ref type="foot" target="#foot_5">5</ref> About 20 s are needed to build up the variables and constraints in this model, and again solutions can be obtained within 10 s. Most importantly, many cases which are unsolvable in either the slot or shift model alone can be solved efficiently using the aggregate model within 10 s. In the following, we present two case studies. The first case study involves a difficult problem instance. We give and compare the timing results of the three models for the difficult problem. This study demonstrates the efficiency of the redundant modeling approach. The second case study aims at evaluating the quality of the generated roster using the percentage of soft constraints satisfied. We study the cumulative results of 11 generated rosters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Case Study 1</head><p>Fig. <ref type="figure" target="#fig_6">4</ref> shows the pre-set requests of a difficult week's roster, which should partially explain why this problem instance is difficult. In this week's roster assignment, 17 out of the 27 nurses request for pre-set shifts. Among them, five nurses request the O shift on Sunday, which is most wanted by other nurses as well. Two nurses request VL, which extends across the entire week. Last but not least, one nurse is assigned SD from Monday to Friday and requests for O on Sunday. As a result, 47 out of 189 slots are pre-set before the roster can be generated. Some of the pre-set slots are filled in with the most undesirable (from the rostering point of view) patterns, making this week's roster exceptionally hard to generate.</p><p>The number of preference rules posted and the nature of the preference rules posted also affects the difficulty of the problem. For the same set of pre-set requests, we vary the combination of preference rules posted and show the performance of the three models in Fig. <ref type="figure" target="#fig_7">5</ref>. Column one of each row specifies the combination of preference rules imposed. Columns two and three contain the timings of the slot and shift models respectively. The string "short" means that execution finishes within 1 min. The string "fast" means an almost </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Case Study 2</head><p>Fig. <ref type="figure" target="#fig_9">6</ref> shows the pre-set requests of a typical week's roster. The last three nurses are part-time nurses, whose shifts are all pre-set. In this week's roster assignment, 95 out of the 189 slots are pre-set in advance. Note that O pre-sets can be assigned either O, CO1, CO2, PH, or H.</p><p>In this case study, all hard constraints are posted. For soft constraints, we have tried posting them all, but yielding no solution roster within 1 CPU h. Therefore, we relax some of the soft constraints and settle in the following combinations of soft constraints: Rules 7-14, 16, and 17. An answer is returned with 10 s of CPU time using the aggregate model.</p><p>The first solution given by the system is shown in Fig. <ref type="figure" target="#fig_10">7</ref>. The empty slots in the figures are reserved shifts that are marked either as "-" or "UD" in the pre-set process. The duty planner has the discretion of assigning special shifts to these slots.</p><p>In the following, we measure the quality of the generated roster by the percentage of soft constraints satisfied in the roster. Fig. <ref type="figure" target="#fig_11">8</ref> shows the degree of satisfaction of soft constraints in the generated roster. The percentage for each rule represents the ratio of the number of satisfied soft constraints to the total number of soft constraints generated from the rule.  Consider Rule 14. This rule requires that all holidays should be followed by a P or an E shift. The total number of possible soft constraint is 35, as there are totally 35 holidays allocated. Out of these 35 holidays, only 18 of them have P/E shift following them. This gives a soft constraint satisfaction of 54.5%. Other percentages are calculated similarly.</p><p>We perform ten further experiments on the system. The results obtained, recorded in Fig. <ref type="figure" target="#fig_12">9</ref>, are in line with the results in Fig. <ref type="figure" target="#fig_11">8</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IX. CONCLUDING REMARKS</head><p>During our implementation, the generated rosters are sent to the hospital duty officer for evaluation. He compares the rosters with his manually generated counterparts, and returns comments to improve the quality of the solutions. We follow his advise and improve upon the system. This iterative process lasts for about three months, and now the system is ready for pilot run. The contribution of this project is three-fold. We have successfully completed the construction of a real-life nurse rostering system, which consists of a constraint-solving engine and an ergonomic user-interface. The system is able to produce rosters for 27 nurses of different skill classes with 11 shifts in a timely manner. The generated rosters are also of high quality. Our system compares well against the state of the art. It demonstrates the potential of constraint technology in the computerization of hospital management. Instead of consuming time in generating the rosters, hospital officers can spare more time and effort on patients and other medical duties. Other areas of hospital management, such as nurse duty assignment, patient-ward allocation, should also benefit from constraint technology.</p><p>In the development process of the core engine, we observe that techniques in solving classical CSP's alone are often insufficient to cope with real-life problems. In particular, soft constraint is not part of a standard CSP, and yet it is an important element in our problem. We adopt to model soft constraints as choices in the solution search tree, but this leads to a considerably large search space, thus increasing solution search time. We alleviate this problem by applying a novel technique, redundant modeling. Benchmarking results confirm substantial improvement in solution generation efficiency.</p><p>A future direction of development is to design alternative methods for implementing soft constraints in the constraintsolving engine where no notion of soft constraints is provided. These methods include designing variable-and value-ordering heuristics and optimizing objective functions which reflect the quality of solution. Hierarchical and stochastic constraint methods can also be investigated for their suitability to cope with soft constraints.</p><p>Van Emden et al. <ref type="bibr" target="#b39">[40]</ref> suggest that system users do not usually know exactly what they want, and yet afterwards they do know what they do not want. This observation holds true in our implementation experience in this project. When we first meet with the duty planner, he gives us a set of planning rules. In subsequent meetings, he often discovers that he either misses or mistakes some details, thus leading to changes to the old planning rules or even creation of new planning rules. Yet we are able to cope with these frequent changes and modify our implementation accordingly. We attribute our flexibility to the expressiveness of constraint programming. Changing the problem specifications, in most cases, simply implies modifying the domains of the variables and expression of the associated constraints. Such high level of flexibility is difficult to achieve using mathematical programming or problem-specific algorithms.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Rule 1 :Rule 2 : 3 : 6 :</head><label>1236</label><figDesc>Each staff member is required to work one shift per day. Each staff member gets one O shift per week. Rule If a nurse is assigned an N shift on a particular day, the nurse must be assigned an A shift in the previous day. Rule 4: A VL shift should start on a Monday, and should be taken in a multiple of six days. The minimum number of VL is six days. Every six VL shifts must be followed by an O shift on Sunday. Rule 5: For each day, there should be eight nurses working in the A shift, six nurses working in the P shift, two nurses working in the E shift, and three nurses working in the N Shift. Rule There are some requirement on the number of a particular type of nurse working in a particular shift. They are summarized as follows: Type of shift Male nurses N/M EN</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .Rule 19 :</head><label>119</label><figDesc>Fig. 1. First view of nurse rostering.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Second view of nurse rostering.</figDesc><graphic coords="5,151.08,54.96,298.08,62.40" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>for each nurse Nurse, each day Day, and each shift Shift. The channeling constraints enforce that a nurse Nurse is assigned a shift Shift on day Day in the slot model if and only if the nurse Nurse is in the set of nurses assigned to shift Shift on day Day in the shift model.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>For</head><label></label><figDesc>each day Day, consider the set A-Day, P-Day, N-Day , , SOL-Day . The following two constraints must be satisfied. (1) Elements of are pairwise disjoint and (2) the cardinality of is equal to the number of nurses. Similarly, Rule 2 can be expressed as follows: Consider the set O-Mon , , O-Sun . The following two constraints must be satisfied. (1) Elements of are pairwise disjoint and (2) the cardinality of is equal to the number of nurses. Since the shift variable O-Day denotes the set of nurses having an O shift on day Day, the first constraint above ensures that no nurse gets more than one O shift per week. The union of all O-Day shift variables for every day of a week represents the set of nurses who get O shift in the week. Constraining the cardinality of the union ensures that every nurse gets an O shift in a week. The expression of Rule 3 in this model uses the subset constraint as follows. Consider the sets A-Mon , , A-Sun and N-Mon , , N-Sun . For each Day from Tuesday to Sunday, we have N-Day A-Day', where Day' prev(Day), and prev() is a function that takes a day as input and returns the previous day of input.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. N and E shifts allocation algorithm.</figDesc><graphic coords="6,304.62,59.58,253.92,324.24" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. A difficult rostering problem.</figDesc><graphic coords="8,75.66,59.58,185.76,274.80" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Benchmark results for the difficult problem.</figDesc><graphic coords="8,322.80,59.58,217.68,164.16" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>is</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. A typical rostering problem.</figDesc><graphic coords="9,74.22,59.58,188.64,276.24" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. A typical generated roster.</figDesc><graphic coords="9,336.54,59.58,190.08,277.20" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Soft constraint satisfaction of a single week.</figDesc><graphic coords="10,114.78,59.58,107.52,120.96" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. Soft constraint satisfaction of ten weeks.</figDesc><graphic coords="10,114.78,214.74,107.52,120.48" type="bitmap" /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Manuscript receivedOctober 3, 1996; revised January 2, 1997. The authors are with the Department of Computer Science and Engineering, The Chinese University of Hong Kong, Shatin, N.T., Hong Kong (e-mail: jlee@cse.cuhk.edu.hk).Publisher Item Identifier: S 1089-7771(97)03561-9.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1"><p>An effective model of the problem should facilitate convenient expression of constraints, efficient pruning, and efficient constraint-solving.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_2"><p>Given a set of constraints C. A constraint c is redundant with respect to C if C entails c.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_3"><p>In our actual implementation, we introduce two additional shift types: H and UD. H is a holiday type covering any of the holiday shifts. The H type is used for tackling difficult problems. UD is a user-defined type, which is used by the duty planner to reserve the shift for special use.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_4"><p>Generating more than one week's roster can be achieved by running the system multiple times.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_5"><p>The aggregate model introduces more memory overhead. However, with the advent of cheaper and more massive hardware, we do not foresee this as a major obstacle.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_6"><p>J. C. K. Wu received the B.Sc. degree in computer science from The Chinese University of Hong Kong in 1996.He is now with Credit Lyonnais Securities (Asia) Ltd., Hong Kong, as a programming analyst. His research interests are in constraint programming, graphical user-interface design, and windows programming.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>The authors are indebted to V. Tam of the Tang Shiu Kin Hospital, who spared great patience in explaining to us the planning rules and rostering techniques and is also always available to answer our queries. Constructive comments from the anonymous referees of the Eighth IEEE International Conference on Tools with Artificial Intelligence and the Second International Conference on Principles and Practice of Constraint Programming help improve the quality of the final version of the paper.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Disjunctive constraints for manufacturing scheduling: Principles and extensions</title>
		<author>
			<persName><forename type="first">P</forename><surname>Baptiste</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">Le</forename><surname>Pape</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Third Int. Conf. Computer Integrated Manufacturing</title>
		<meeting>Third Int. Conf. Computer Integrated Manufacturing<address><addrLine>Singapore</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A visual interactive decision support system for workforce (nurse) scheduling</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>Bell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Hay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">INFOR</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="134" to="145" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Arc-consistency and arc-consistency again</title>
		<author>
			<persName><forename type="first">C</forename><surname>Bessière</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Cordier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. AAAI-93</title>
		<meeting>AAAI-93</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="108" to="113" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Backtrack programming techniques</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bitner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Reingold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="651" to="655" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A constraint-based nurse rostering system using a redundant modeling approach</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">M W</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H M</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C K</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Eighth IEEE Int. Conf. Tools with Artificial Intelligence</title>
		<meeting>Eighth IEEE Int. Conf. Tools with Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="1996-11">Nov. 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Speeding up constraint propagation by redundant modeling</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">M W</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H M</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C K</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Second Int. Conf. Principles and Practice of Constraint Programming</title>
		<meeting>Second Int. Conf. Principles and Practice of Constraint Programming</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="91" to="103" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Nursing staff rostering using ILOG solver</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">M W</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C K</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Final Year Project Rep., Dept. Comp. Sci. Eng</title>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>The Chinese Univ. Hong Kong</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">An introduction to prolog III</title>
		<author>
			<persName><forename type="first">A</forename><surname>Colmerauer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="page" from="69" to="90" />
			<date type="published" when="1990-07">July 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Experimental evaluation of preprocessing techniques in constraint-satisfaction problems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Dechter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Meiri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Eleventh Int. Joint Conf. Artificial Intelligence</title>
		<meeting>Eleventh Int. Joint Conf. Artificial Intelligence<address><addrLine>Menlo Park, Calif</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="37" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">An efficient arc consistency algorithm for a class of CSP algorithm</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Deville</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Van Hentenryck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IJCAI 1991</title>
		<meeting>IJCAI 1991</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="325" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Solving large combinatorial problems in logic programming</title>
		<author>
			<persName><forename type="first">M</forename><surname>Dincbas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Simonis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Van Hentenryck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Progr</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="75" to="93" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Applications of CHIP to industrial and engineering problems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Dincbas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Van Hentenryck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Simonis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aggoun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Graf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1st Int. Conf. Industrial &amp; Engineering Applications of Artificial Intelligence &amp; Expert Systems</title>
		<meeting>1st Int. Conf. Industrial &amp; Engineering Applications of Artificial Intelligence &amp; Expert Systems</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="887" to="892" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The constraint logic programming language CHIP</title>
		<author>
			<persName><forename type="first">M</forename><surname>Dincbas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Van Hentenryck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Simonis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aggoun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Graf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Berthier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Fifth Generation Computer Systems (FGCS&apos;88)</title>
		<meeting>Int. Conf. Fifth Generation Computer Systems (FGCS&apos;88)<address><addrLine>Tokyo, Japan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988-12">Dec. 1988</date>
			<biblScope unit="page" from="693" to="702" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Experimental case studies of backtrack versus Waltztype versus new algorithms for satisfying assignment problems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Gaschnig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Second Biennial Conf</title>
		<meeting>Second Biennial Conf</meeting>
		<imprint>
			<publisher>Canad. Soc. Computational Studies of Intelligence, Canad. Inform. Processing Soc</publisher>
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Performance measurement and analysis of certain search algorithms</title>
		<author>
			<persName><forename type="first">J</forename><surname>Gaschnig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ph.D. dissertation, Dept. Comp. Sci</title>
		<imprint>
			<date type="published" when="1979">1979</date>
			<pubPlace>Pittsburgh, PA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon Univ</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Increasing tree search efficiency for constraint satisfaction problems</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Haralick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">L</forename><surname>Elliot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="263" to="313" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName><forename type="first">Ilog</forename><surname>Ilog</surname></persName>
		</author>
		<title level="m">Solver Reference Manual Version 3.0</title>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The CLP(R) language and system</title>
		<author>
			<persName><forename type="first">J</forename><surname>Jaffar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Michaylov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Stuckey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H C</forename><surname>Yap</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="339" to="395" />
			<date type="published" when="1992-07">July 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Nurse scheduling on a microcomputer</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Kostreva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S B</forename><surname>Jennings</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Oper. Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="731" to="739" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Depth-first search</title>
		<author>
			<persName><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Encyclopaedia of Artificial Intelligence</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Shapiro</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Wiley</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="1004" to="1005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Using SOLVER for nurse scheduling</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Lazaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Aristondo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ILOG SOLVER &amp; ILOG SCHEDULE First Int. Users&apos; Conf</title>
		<meeting>ILOG SOLVER &amp; ILOG SCHEDULE First Int. Users&apos; Conf</meeting>
		<imprint>
			<date type="published" when="1995-07">July 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Implementation of resource constraints in ILOG SCHED-ULE: A library for the development of constraint-based scheduling systems</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Pape</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Intell. Syst. Eng</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="55" to="66" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Resource constraints in a library for constraint-based scheduling</title>
	</analytic>
	<monogr>
		<title level="m">Proc. INRIA/IEEE Conf. Emerging Technologies and Factory Automation</title>
		<meeting>INRIA/IEEE Conf. Emerging Technologies and Factory Automation<address><addrLine>Paris, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Using object-oriented constraint programming tools to implement flexible &apos;easy-to-use&apos; scheduling systems</title>
	</analytic>
	<monogr>
		<title level="m">Proc. NSF Workshop on Intelligent, Dynamaic Scheduling for Manufacturing</title>
		<meeting>NSF Workshop on Intelligent, Dynamaic Scheduling for Manufacturing</meeting>
		<imprint>
			<date type="published" when="1993-01">Jan. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Consistency in networks of relations</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Mackworth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AI J</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="99" to="118" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Hierarchical arc consistency: Exploiting structured domains in constraint satisfaction problems</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Mackworth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Mulder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">S</forename><surname>Havens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computat. Intell</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="118" to="126" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Relational consistency algorithms and their applications in finding subgraph and graph isomorphism</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mcgregor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Sci</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="229" to="250" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Successful hospital personnel scheduling</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Megeath</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Interfaces</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="55" to="59" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Nurse scheduling using mathematical programming</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">E</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Oper. Res</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="857" to="870" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Arc and path consistency revisited</title>
		<author>
			<persName><forename type="first">R</forename><surname>Mohr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">C</forename><surname>Henderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="225" to="233" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Tree search and arc consistency in constraint-satisfaction algorithms</title>
		<author>
			<persName><forename type="first">B</forename><surname>Nadel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Search in Artificial Intelligence</title>
		<editor>
			<persName><forename type="first">L</forename><surname>Kanal</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">V</forename><surname>Kumar</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="page" from="287" to="342" />
			<date type="published" when="1988">1988</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>Berlin, Germany</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">A computational study of constraint satisfaction for multiple capacitated job shop scheduling</title>
		<author>
			<persName><forename type="first">W</forename><surname>Nuijten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Aarts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Eur. J. Oper. Res</title>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Goal programming model subsystem of a flexible nurse scheduling support system</title>
		<author>
			<persName><forename type="first">I</forename><surname>Ozkarahan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Bailey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IIE Trans</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="306" to="316" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Using constraint logic programming techniques in container port planning</title>
		<author>
			<persName><forename type="first">M</forename><surname>Perrett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICL Tech. J</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="537" to="545" />
			<date type="published" when="1991-05">May 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Hybrid algorithms for the constraint-satisfaction problem</title>
		<author>
			<persName><forename type="first">P</forename><surname>Prosser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AISL-46-91, Comp. Sci. Dept., Univ</title>
		<meeting><address><addrLine>Strathclyde, U.K.</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">On the satisfiability of symmetrical constrained satisfaction problems</title>
		<author>
			<persName><forename type="first">J.-F</forename><surname>Puget</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th ISMIS</title>
		<meeting>7th ISMIS<address><addrLine>Trondheim, Norway</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993-06">June 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">A C++ implementation of CLP</title>
		<author>
			<persName><forename type="first">J.-F</forename><surname>Puget</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SPICIS 94</title>
		<meeting>SPICIS 94</meeting>
		<imprint>
			<date type="published" when="1994-11">Nov. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">A heuristic-based computerized nurse scheduling system</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">U</forename><surname>Randhawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sitompul</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comp. Oper. Res</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="837" to="844" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Workforce staffing and scheduling: Hospital nursing specific models</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Siferd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Eur. J. Oper. Res</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="233" to="246" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Spreadsheets with incremental queries as a user interface for logic programming</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Van Emden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ohki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Takeuchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">New Generation Computing</title>
		<meeting><address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>OHMSHA, Ltd. and Springer-Verlag</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="287" to="304" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Van Hentenryck</surname></persName>
		</author>
		<title level="m">Constraint Satisfaction in Logic Programming</title>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Understanding line drawings of scenes with shadows</title>
		<author>
			<persName><forename type="first">D</forename><surname>Waltz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Psychology of Computer Vision</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Winston</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>McGraw-Hill</publisher>
			<date type="published" when="1975">1975</date>
			<biblScope unit="page" from="19" to="91" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Scheduling nursing personnel according to nursing preference: A mathematical programming approach</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Warner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Oper. Res</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="842" to="856" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Constraint programming for nurse scheduling</title>
		<author>
			<persName><forename type="first">G</forename><surname>Weil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Heus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Francois</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Poujade</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Eng. Med. Biol</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="417" to="422" />
			<date type="published" when="1995-08">July/Aug. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title level="m" type="main">During his studies, he participated actively in projects related to artificial intelligence, constraint satisfaction techniques, and constraint programming. He is now with Citibank</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">M W</forename></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Cheng received the B.Sc. degree in computer science from The Chinese University of Hong Kong in 1996. Hong Kong, as a Management Associate</note>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">where he also received the M.Math. degree in computer science in 1988. He then moved to the University of Victoria, Victoria, B.C., Canada, to pursue doctoral studies in computer science, and received the Ph.D. degree in 1992. He then returned to Hong Kong and joined the Department of</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">as an Assistant Professor. His current research interests include constraint processing</title>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
		<respStmt>
			<orgName>University of Waterloo, Waterloo, Ont., Canada ; Computer Science and Engineering, The Chinese University of Hong Kong</orgName>
		</respStmt>
	</monogr>
	<note>Lee received the B.Math. degree in ap. logic programming, agent-oriented programming, and intelligent real-time systems</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
