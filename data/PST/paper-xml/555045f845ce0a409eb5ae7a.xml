<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Comparing Different Moving Target Defense Techniques</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jun</forename><surname>Xu</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Pennsylvania State University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Pinyao</forename><surname>Guo</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Pennsylvania State University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mingyi</forename><surname>Zhao</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">Pennsylvania State University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Robert</forename><forename type="middle">F</forename><surname>Erbacher</surname></persName>
							<email>robert.f.erbacher.civ@mail.mil</email>
							<affiliation key="aff3">
								<orgName type="laboratory">Army Research Laboratory</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Minghui</forename><surname>Zhu</surname></persName>
							<affiliation key="aff4">
								<orgName type="institution">Pennsylvania State University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Peng</forename><surname>Liu</surname></persName>
							<email>pliu@ist.psu.edu</email>
							<affiliation key="aff5">
								<orgName type="institution">Pennsylvania State University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Comparing Different Moving Target Defense Techniques</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">4F938476D993276142693B913E073661</idno>
					<idno type="DOI">10.1145/2663474.2663486</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:05+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.6 [Computing Methodologies]: Simulation And Modelling Defense</term>
					<term>Model</term>
					<term>Evaluation Moving Target Defense Techniques</term>
					<term>Performance Evaluation</term>
					<term>Three Layer Comparing Model Input: DataFile (len=256) Mission Start Memory Error* =&gt; DataBuf Overflowed</term>
					<term>KeyBuf Overlapped</term>
					<term>Stack Crash Key Compromised =&gt; DataBuf Overflowed</term>
					<term>KeyBuf Tampered</term>
					<term>OutBuf Tampered Decryption Error(*) =&gt; DataBuf Overflowed</term>
					<term>KeyBuf Polluted</term>
					<term>OutBuf Polluted Huffman Decompress Buffer Overflow Attack ASLR Defense Start Damage Null Input: keyfile Accept*: DataBuf Overflowed</term>
					<term>KeyBuf Polluted</term>
					<term>OutBuf Polluted PSM: OpenAES Buffer Overflow Attack ASLR Defense Accept*: DataBuf Overflowed</term>
					<term>KeyBuf Tampered</term>
					<term>OutBuf Tampered Accept*: DataBuf Overflowed</term>
					<term>KeyBuf Overlapped</term>
					<term>Stack Crash Input: DataFile (len=256) DataBuf: Buffer for Data KeyBuf: Buffer for Key OutBuf: Buffer for Decrypted Data</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Moving Target Defense techniques have been proposed to increase uncertainty and apparent complexity for attackers. When more than one Moving Target Defense techniques are effective to limit opportunities of an attack, it is required to compare these techniques and select the best defense choice. In this paper, we propose a three-layer model to evaluate and compare effectiveness of different Moving Target Defenses. This model is designed as an attempt to fill a gap among existing evaluation methods and works as a systematic framework for Moving Target Defense comparison.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Moving Target Defense (MTD) techniques are defense mechanisms via changing aspects of a system (e.g. an enterprise network supporting a business) to prevent attacks. The basic idea is to hide properties of a system that are required by attackers to leverage an exploit <ref type="bibr" target="#b12">[12]</ref>. Plenty of MTD techniques <ref type="bibr" target="#b22">[22,</ref><ref type="bibr" target="#b25">25,</ref><ref type="bibr" target="#b23">23,</ref><ref type="bibr" target="#b6">6,</ref><ref type="bibr" target="#b3">3,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b7">7,</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b1">1,</ref><ref type="bibr" target="#b26">26,</ref><ref type="bibr" target="#b2">2,</ref><ref type="bibr" target="#b31">31]</ref> have been developed to protect a system against various attacks.</p><p>In Table .1, we abstractly present effectiveness of different MTD instances against different attack instances. An MTD instance refers to the set of MTDs deployed in a system. In an MTD instance, each MTD is deployed to protect one or multiple programs in the system. For example, {Address Space Layout Randomization, Code Sequence Randomization, Instruction Set Randomization} is an MTD instance to mitigate buffer overflow attacks. Likewise, an attack instance refers to a set of attack actions launched against a system. These actions in an attack instance may form a multiple-step attack, or work independently to exploit the same vulnerability in a system. For example, {Code Injection, Return-to-libc Attack, Return Oriented Programming Attack } is an attack instance to exploit a buffer overflow vulnerability. Effectiveness represents in which aspects an MTD instance can mitigate an attack instance. For instance, Instruction Set Randomization can prevent Code Injection in a buffer overflow exploitation.</p><p>As shown in Table .1, an attack instance could be mitigated by multiple MTD instances. In such cases, it is necessary to compare applicable MTD instances and select the best one. In this paper, we study the problem of comparing MTD instances in a mission-centered way. From the point view of a system, a mission refers to one or multiple tasks to be completed for a certain purpose. For example, decrypting an encrypted file is one mission for a crypto system. Specifically, our problem could be stated as:</p><p>When an attack instance is generated against a system for a mission, we want to understand how the mission will be impacted when different MTD instances are deployed to neutralize the attack instance. Table <ref type="table">1</ref>: MTD v.s. Attack: Each cell represents effectiveness of an MTD instance against an attack instance. If an MTD instance produces no effects on an attack instance, the corresponding cell is filled with an empty set.</p><p>Existing methods to evaluate the effectiveness of MTD techniques could be classified into two categories: low-level methods <ref type="bibr" target="#b28">[28,</ref><ref type="bibr" target="#b30">30]</ref> and high-level methods <ref type="bibr" target="#b32">[32,</ref><ref type="bibr" target="#b19">19]</ref>.</p><p>Low-level methods evaluate MTDs through attack-based experiments. In the experiments, attacks are launched to compromise a program secured by MTDs. Low-level contexts are captured to reflect how attacks affect the program. Such effects are interpreted to evaluate the deployed MTDs. However, low-level methods express evaluation results as program status, which require extra interpretations before being used as comparison metrics. Also, low-level methods reflect how attacks impact individual programs separately, without considering interactions between programs. Consequently, low-level methods are unable to capture effects propagation between programs. This makes low-level methods unable to evaluate effects of attacks on a whole system that contains multiple interconnected programs.</p><p>High-level methods evaluate MTDs based on simulation experiments, probability models, or a combination thereof. High-level methods require little knowledge about low-level contexts. Applicable scope of a high-level method varies from individual programs to large systems with multiple programs. Besides, high-level methods present evaluation results in an explicit way, which could be directly used for MTDs comparison. However, high-level methods evaluate MTD techniques based on abstracted information, rather than contexts of programs. Consequently, results from highlevel methods are abstractions or approximations of reality, which makes it less convincing.</p><p>A method for MTD comparison requires merit both from low-level methods and high-level methods. However, the advantages of low-level methods are deficiencies of high-level methods, and vice versa. A method to incorporate merits of both is missing, and we regard such as a gap between low-level methods and high-level methods. The motivation of our work is to design an evaluation method to fill the gap, and use our method for MTD comparison.</p><p>In this paper, we propose a three-layer model as an attempt to fill the gap. The first layer is expected to capture the low-level contexts information of individual programs in a system; the second layer models interactions between different programs and enables our model to apply in a system scale; the third layer is designed as a user interface, which abstracts impacts of different attacks and defenses on a mission and provides an uniform and explicit channel for MTD techniques comparison. We design a case study to demonstrate the feasibility of such a model. A comprehensive evaluation on this model would be our future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">REVIEW OF MTD TECHNIQUES AND EVALUATION METHODOLOGIES</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">MTD Techniques</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.1">Software-based Diversification</head><p>Existing works achieve Software-based Diversification via directly manipulating software or relying on compilers to produce diversification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Software Manipulation</head><p>The technique of software manipulation enhances security via changing software functionality to eliminate vulnerabilities or limit their exposure. Accretion, excision, and replacement of functionality are all leveraged as manipulation mechanisms. Input rectification is an example of accretion mechanism. Via inserting functions to manipulate inputs in software, input rectification converts each input to stay in a secure zone. For instance, the Pine email rectifier is developed to force messages into a specific constrained form in <ref type="bibr" target="#b24">[24]</ref>. In order to simplify software behavior and possibly avoid vulnerabilities, functionality excision removes functional but non-critical sections of a program, which may introduce result noise, but normally will not cause failure <ref type="bibr" target="#b22">[22,</ref><ref type="bibr" target="#b25">25]</ref>. Functionality replacement switches between different implementations of the same function in a program, and thus generates system variation to neutralize attacks <ref type="bibr" target="#b23">[23]</ref>.</p><p>Compiler-generated Diversity Jackson et. al <ref type="bibr" target="#b11">[11]</ref> presented two types of compiler-based diversity techniques: Malt-Variant Execution Environment (MVEE) and Massive-Scale Software Diversity (MSSD). Both of these techniques rely on automated tools, especially the compiler, to produce functionally equivalent, but internally different program variants.</p><p>Within MVEE, multiple semantically equivalent variants of a program are executed, and their behaviors are compared at synchronization points. Diverging behavior detected during synchronization indicates potential attacks. As early as the 1970s, Chen and Avizenis <ref type="bibr" target="#b6">[6]</ref> developed a technique known as N-Version Programming, to generate N ≥ 2 functionally equivalent programs. The mechanism required to achieve N-Version Programming could be completed by a compiler. The SQL interpreter known as SQLrand, prevents SQL injection by randomizing the Standard Query Language, and reflects the idea of MVEE <ref type="bibr" target="#b3">[3]</ref>.</p><p>MSSD refers to the idea of releasing diversified software variants to each user, and thus hides the internal structure of the software variants from attackers. Code Sequence Randomization (CSR) is a MSSD technique that uses instruction scheduling, call inlining, code hoisting, loop distribution, partial redundancy elimination, and many other compiler transformations to generate variants of machine codes. CSR could mitigate attacks that rely on knowledge about instruction at certain locations, such as return oriented programming attack <ref type="bibr" target="#b27">[27,</ref><ref type="bibr" target="#b5">5]</ref>. Equivalent Instructions (EI) is another MSSD technique. In software, EI stands for a set of instruction sequences that have identical effects and can be substituted for one another. Variants of machine code could be produced by replacing instructions through EI <ref type="bibr" target="#b11">[11]</ref> (e.g., loop unrolling).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.2">Runtime-based Diversifitcation</head><p>Many defenses techniques mitigate attacks via introducing diversification in runtime environments. Address Space Layout Randomization (ASLR) <ref type="bibr" target="#b28">[28]</ref> is a widely known example of Runtime-based Diversification techniques. ASLR randomly arranges starting positions of key code and data areas in a process's address space, including the base memory address of the executable, the stack, the heap, and the libraries, to prevent an attacker from correctly jumping to a particular exploited function in memory. <ref type="bibr">Kc</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.3">Communication Diversification</head><p>Techniques of communication diversification protect systems against network related attacks, in a way to hide internal information or communication protocols. Christodorescu et al. propose to change the internals of a system, aiming at defending attacks that rely on internal knowledge of the system. For instance, periodically altering the schema of the database of a website, such as changing table titles, could mitigate SQL injections but without causing service failures <ref type="bibr">[8]</ref>. The Mutable Networks (MUTE) <ref type="bibr" target="#b1">[1]</ref> defense architecture proposed by Al-Shaer enables systems to automatically change communication configurations, and thus reduce adversary's capabilities in target scanning or exploiting. With IP randomization, a network would change its IP address frequently, and only synchronize new IP addresses with authorized users. Hence, attackers are segregated from the network. Another technique called Random Finger Printing in MUTE enables a system to interpret and modify its response to outside requests. Fake information of a system exposed to the public, such as OS type and application identity, and such information could hinder remote exploitation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.4">Dynamic Platform Techniques</head><p>Dynamic platform techniques (DPT) change platform properties to stop attacking processes <ref type="bibr" target="#b18">[18]</ref>. Temporal changes (e.g. virtual machine rotation) and diversity (e.g. multiple variants execution) are widely used as DPT techniques for system protection. DPT techniques at compiler-level have been discussed above, so we focus on machine-level/OSlevel DPT techniques, which includes migration-based techniques, server-switching techniques, and self-cleansing techniques. Migration-based techniques, such as Talent <ref type="bibr" target="#b17">[17]</ref>, leverage OS-level virtualization to create a virtual execution environment for migrating a running application across different platforms and preserving the state of the application. DPT could also be achieved by switching between different implementations of servers. Saidane et al. <ref type="bibr" target="#b26">[26]</ref> propose the deployment of redundant servers with diverse software (e.g. Apache and IIS) in a web system. Redundancy improves system availability, and diversification increases the difficulty of vulnerability exploitation. Self-cleansing techniques change current platform instance without diversification, such as reimaging the OS. SCIT <ref type="bibr" target="#b2">[2]</ref> achieves self-cleansing by decommissioning a server that has been exposed to the Internet for a predetermined period of time, and launching a pristine copy of the server. Ideas of DPT are also used in works on assessing software reliability. For instance, Zhang and Liu <ref type="bibr" target="#b31">[31]</ref> designed and deployed diverse-drivers based replicas of virtual machines (Heter-device), to compare run-time behaviors of drivers from different vendors. Replicas in a Heter-device load heterogeneous drivers for identical virtual devices. The behavior of these drivers are compared to capture inconsistencies as evidence of un-trustworthiness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">MTD Evaluation Methodologies</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1">Attack-based Experiments</head><p>Attack-based experiments evaluate an MTD by measuring the amount of effort to compromise a program guarded by the defense. Shacham et al. explore the effectiveness of ASLR on Linux against a return-to-libc attack <ref type="bibr" target="#b10">[10]</ref>. In their study, PAX ASLR was deployed to randomize Apache's user address space, which leads to an unpredictable offset of libc in virtual memory. However, they correctly guessed the base address of libc through brute force, and compromised the Apache server with a subsequent return-to-libc attack. On average 216 seconds were required for a successful guess (under PAX with ≤ 24 bits randomization space) <ref type="bibr" target="#b28">[28]</ref>.</p><p>Inspired by Schacham et al's work, Sovarel et al. developed a technique to attack ISR-protected servers. They incrementally broke the keys used by ISR to encode instructions, through a chosen-ciphertext attack. Experimental results demonstrated that on average 283.6 seconds were required to crack the 32 bytes keys used by ISR, with a success rate as high as 98% <ref type="bibr" target="#b30">[30]</ref>. Attack-based experiments quantify security provided by MTD against a motivated adversary and bring insight as to how to improve MTD techniques (e.g. keys with longer length are required in ISR). During experiments, contexts of the program, including user level contexts (heap, stack, code, and data) and OS related contexts (e.g. opened files), are tracked and analyzed for evaluation. Attack-based experiments reflect what happens to a program when attacks occur. However, this evaluation method only reflects how attacks impact individual programs separately, without considering impacts propagation between programs. Further, the experiment results are represented by context statuses, which might need further interpretation to be used as comparison metrics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2">Probability Model</head><p>Probability models are frequently used to analyze MTDs. First, probability models are used to analyze attacking success when MTDs are deployed. Zhang et al.'s work <ref type="bibr" target="#b32">[32]</ref> provides a model to reflect the relationship between diversification frequency of MTD and successful probability of attacks. Second, probability models are proposed to understand the effort required to crack the randomization keys used by some MTDs <ref type="bibr" target="#b28">[28,</ref><ref type="bibr" target="#b30">30]</ref>. Third, Okhravi et al. <ref type="bibr" target="#b19">[19]</ref> deduced a probability model to predict the expected time required for an attack to compromise a system that is protected by MTDs. In a probability model, specifics of systems, attacks and defenses are abstracted as probability parameters. For instance, in <ref type="bibr" target="#b30">[30]</ref>, the length of the randomization key in ISR is represented as a numeric variable related to the probability of a successful attack. A probability model deals with effects of attacks and defenses in a concise way, which are often represented as the success rate of an attack. However, in a probability model, high excision and abstraction of contexts at low-level might lead to missing of key information and mismatch between the model and the real scenario.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.3">Simulation-based Evaluation</head><p>Zhang et al. <ref type="bibr" target="#b32">[32]</ref> propose a simulation-based approach to study the effectiveness of MTD techniques. In their study, a simulating network based on NeSSi2 <ref type="bibr" target="#b4">[4]</ref> is constructed, where Communication Diversification and machine-level Dynamic Platform are deployed as MTD techniques. Periodic attacks are conceptually launched based on an attack graph to compromise a mission. The success of an attack is determined by a pre-defined probability model and a specific MTD implementation. Results of the simulation quantify the relationship between successful attacks and different MTD settings (e.g. frequency of diversification). In their settings, for instance, the ratio of successful attacks is 50% when MTD is switched off, which shrinks to 16.2% if fre-quency of diversification via MTD reaches 20 per time unit. Thus, such a method explicitly evaluates the effectiveness of MTD techniques, and enables defenders to implement MTD properly under different security requirements.</p><p>With a simulation-based approach, a whole system can be abstracted as numeric parameter (in the simulating network), and there is no restriction on the specifics of attacks and defenses. Thus, a simulation-based method provides people with a uniform approach to evaluate MTD techniques with the least effort. Nevertheless, no real system is involved for evaluation. Therefore, lessons learned from a simulationbased approach are not well-supported and might deviate from the real world.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.4">Hybrid Approaches</head><p>Researchers also study MTD techniques based on hybrid approaches. Okhravi et al.'s work <ref type="bibr" target="#b19">[19]</ref> explores the effectiveness of MTD techniques, especially DPT , using a combination of the three approaches explained above. They simulated a system with multiple servers based on Talent <ref type="bibr" target="#b9">[9]</ref>, and deployed machine-level DPTs as MTDs. On several machines in the system, two vulnerabilities CVE-2010-4165 and CVE-2010-4249 were set up. Attacks targeting at the two vulnerabilities were conducted periodically, and the success rate of the attacks were recorded. Okhravi et al. evaluated the effectiveness of an MTD by measuring the length of time when the MTD neutralizes the attacks. Different results are presented when different features are provided by defenses. Separate probability models are constructed to illustrate the effectiveness of different features. Inspired by the similarities between these probability models, Okhravi et al. generalize a probability model to predict the effectiveness of DPTs. The generalized model involves primary awareness of system specifics (e.g. the frequency of platform diversification), and estimates the effectiveness of an MTD in a concise way (e.g. success time of an attack).</p><p>Though experimental results are used in a hybrid method, evaluation from such a method could still be insufficient to reflect the reality. First, results from the experiments are based on information of coarse granularity, which can not demonstrate what exactly happens inside a system. For instance, all information of a divide-by-zero error is abstracted out as merely being a successful attack and how this attack would affect the system is neglected. Second, experimental results are abstracted out when being used for deducing the specific probability models. Third, the process of constructing a general model also involves abstraction, which could result in further loss of evaluation precision.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">THERE IS A GAP</head><p>The above four methodologies evaluate MTD techniques based on different information and describe evaluation results in different ways. Further, these methodologies have different application scopes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Low-level Methods</head><p>Attack-based experiments look into a program and focus on the contexts of the program when an attack happens. For instance, in the experimental attack against ASLR <ref type="bibr" target="#b28">[28]</ref>, multiple context objects are collected for evaluation: (1) location of the buffer to be overwritten; (2) base-address of libc in memory; <ref type="bibr" target="#b3">(3)</ref> functions in libc to be attacked; (4) actions for compromising the program. We term such a method a low-level method, as it collects low-level context information for evaluation. As explained, a low-level method involves information with fine granularity, thus producing evaluation results with high accuracy.</p><p>However, it is difficult to compare MTDs directly based on evaluation through attack-based experiments. First, attackbased experiments present results through program contexts, which cannot be directly used as comparable metrics. It is necessary to interpret those contexts into attack status. For instance, in the attack experiment against ASLR <ref type="bibr" target="#b28">[28]</ref>, the status of the instruction pointer register could be interpreted as whether a return-to-libc is successful. Second, it is necessary to translate the attack status into explicit expression of effects on a mission. For example, arbitrary code-execution via a return-to-libc attack should be interpreted as indicating that the mission is under control by attackers.</p><p>Further, a low-level method works at the scope of an individual program. When used in a system with multiple interconnected programs, a low-level method has limited applicability. Such limitations are caused by the absence of a model for interaction between different programs. Attack effects that propagate through program interactions could not be captured by a low-level method. For instance, if P rogram1 interacts with P rogram2 via a common database, damage caused to the database by P rogram1 could propagate to P rogram2. Such propagated damage might lead to further effects on P rogram2, but they can not be identified by evaluation on P rogram2 by low-level methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">High-level Methods</head><p>The other three methodologies (including simulation-based evaluation, probability model, and hybrid methods) evaluate MTD techniques from the scope of a whole system, which we call high-level methods. Contrary to low-level methods, high-level methods use information with coarser granularity for evaluation. First, system specifics are abstracted in highlevel methods. In some cases, the only required information of a system is whether it contains certain vulnerabilities. Second, specifics of a defense are represented as general information: whether a defense is deployed; what attacks can be mitigated; the frequency of diversification if the defense involves diversification. Third, in a high-level method, attacks are often abstracted as two variables: success rate and effects. Success rate of an attack is either determined by a probability model or defense specifics. Effects of an attack are expressed explicitly (e.g. time duration when the attack succeeds), which could be directly used for comparison.</p><p>High-level methods also differ from low-level methods in term of application scope. Low-level methods focus on evaluating MTD in a single program, while high-level methods evaluate MTD in a whole system.</p><p>However, high-level methods possess the above two advantages via regarding a system as a black box. Low-level contexts are largely abstracted or neglected in high-level methods, so it is difficult for high-level methods to reflect what really happens in a system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">The Gap</head><p>We regard the differences between low-level methods and high-level methods as a gap. To the best of our knowledge there is no existing works on linking the two types of methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">A NEW EVALUATION METHOD</head><p>In this paper, we propose a new evaluation method that tries to fill the gap between low-level methods and high-level methods. First, we would like to discuss the evaluation settings of our method, and we will present a concrete example of a practical system with such settings in the next section for a case study.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">The Evaluation Settings</head><p>We evaluate MTD techniques against attacks in a system that consists of multiple interconnected programs. This system is designed to support a mission, and a set of attacks are launched to cause the mission to fail. The evaluation aims to understand how well MTD techniques protect the mission when attacks occur. And it is assumed that we have required knowledge of the system, the programs in the system, the mission supported by the system, the set of attacks, and the available MTD techniques.</p><p>The system Sys contains N programs {P1, P2, ..., PN }. Each program provides resources for Sys, and these resources refer to low-level contexts of a program. We denote contexts for Pi as a set of objects {ci1, ci2, ..., cit i }. We focus on five types of contexts: (1) data objects in the stack;</p><p>(2) data objects in the heap; (3) code segments; (4) data objects in the data segment; (5) OS related contexts (e.g. files and sockets). To complete the mission M is, it requires {cim 1 , cim 2 , ..., cim qi } from Pi. The set of attacks to fail the mission are known as Att = {a1, a2, ..., ana}. Each attack in Att aims at damaging resources from programs. We denote the resource objects from Pj targeted by a k as {cja 1 , cja 2 , ..., cja rk }. The available set of MTD techniques are M T D = {d1, d2, ..., d nd }. In contrast with attacks, each MTD expects to secure resource of some programs. We denote the resource objects from Pg protected by d h as {c gd 1 , c gd 2 , ..., c gd vh }.</p><p>We provide evidence here to indicate that the settings are reasonable. First, we assume that we know what programs are included in a system and whether they are interconnected. We believe this knowledge can be identified from system descriptions. Second, we assume that we have knowledge about contexts of a program and we summarized five types of contexts in the previous paragraph. In fact, such knowledge has been used by low-level methods in their evaluation settings <ref type="bibr" target="#b28">[28,</ref><ref type="bibr" target="#b30">30]</ref>. Thus, the second assumption is also supported. Third, we assume that we have the knowledge about the required set of resources to complete M is. Though it is hard to precisely determine such a set, we can at least identify a superset of the required resources. For example, the set that includes all resources from each program in Sys must be such a superset. However, how to reduce redundancy in the superset depends on the mission specifics. Fourth, we assume that we have knowledge about what resources are targeted by an attack or protected by a defense. We believe such an assumption is well founded, because low-level methods <ref type="bibr" target="#b28">[28,</ref><ref type="bibr" target="#b30">30]</ref> evaluate MTD based on such knowledge.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Three-layer Model</head><p>Within the evaluation settings, we propose a three-layer model as an attempt to fill the gap. As shown in Figure .1, the first layer captures low-level contexts information from individual programs. For each program, a state machine is created to present how attacks cause damage to the pro-gram. The second layer connects state machines from the first layer, and models damage propagation between different programs. In this layer, a state machine is constructed to demonstrate how attacks damage a system. The third layer explicitly expresses evaluation results to work as a user interface. Information from the second layer is abstracted and included in the third layer.</p><p>Each layer is modeled as a set of state machines. First, state machine is a widely used and accepted computational model in computer science <ref type="bibr" target="#b15">[15]</ref>. Second, our model is expected to describe change happens in a system when attacks and MTDs occur. So the ability of sate machine to deal with change/transition satisfies our requirements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">The First Layer: Program State Machine</head><p>In the first layer, a state machine (abbr. P SM ) is created for each program. We anticipate a P SM to represent how an attack instance and an MTD instance would affect resources in the program. Before discussing details of a P SM , we would like to introduce the basics of a general state machine. A state machine could be presented as {Q, , δ, q0, F }, in which, Q is a set of states; is a set for the input alphabet; δ : Q × → Q is the state transition function; q0 ∈ Q is the start state, and F ⊆ Q is the set of accept states <ref type="bibr" target="#b29">[29]</ref>.</p><p>Likewise, a P SM could be described as a tuple with 5 elements {Q P, P, δ P, q0 P, F P }. For simplicity, we discuss P SMi for Pi as an example:</p><p>Q Pi: States of P SMi refer to damage on {ci1, ci2, ..., c it i }. For each cij(1 ≤ j ≤ ti), we present its status as a set of logic statements, and such statements are interpreted as damage to cij. And a set of applicable logic statements for cij is pre-defined. For instance, given a buffer Buf with nb bytes allocated space, there are two different statements about its length when Buf is accessed: (1) len(Buf ) ≤ nb (2) len(Buf ) &gt; nb. Damage to Buf is null, if len(Buf ) ≤ nb; while damage to Buf is Buffer Overflow or Buffer Overread, if len(Buf ) &gt; nb. Three steps are necessary to determine the state of a program. First, for each cij(1 ≤ j ≤ ti), applicable logic statements are selected from the set of available statements. Second, each selected statement of cij is translated to damage on cij. The translation is completed according to a mapping function, and we denote it as Dam(cij). The function Dam depends on specifics of available logic statements. Third, the vector {Dam(ci1), Dam(ci2), ..., Dam(cit i )} is constructed as a state of P SMi.</p><p>Pi: Three types of input to Pi are regarded as input events to P SMi: data from network traffics (I DN ); data from local devices (I DF ) (e.g. local disk and keyboard); data through Inter-process Communication (IPC) (I DI). I DN and I DF could be affected by users, which are regarded as external inputs. I DI are transparent to users, which are regarded as internal inputs. However, we do not model some special inputs, if either they are controlled by the operating system (e.g. SIGXCPU for CPU time limit excess), or it is too complicated to be handled (e.g. signal communication between threads).</p><p>δ Pi(Q P × Pi → Q Pi): In this model, the transition function of a P SM is defined by the program itself, and each transition is caused by one execution of the program. Given context status and an input to a program, the period during which the program processes the input is regarded as one execution. Such a processing period starts when a program receives the input, and ends when status of the program remains unchanged without subsequent inputs. During one execution, if contexts changes and different damage is caused to resource objects, a transition occurs. q0 Pi: When a program finishes initialization and receives no inputs, its state is regarded as the start state.</p><p>F Pi: There are three different accept states. First, when no further damage can be caused to {ci1, ci2, ..., c it i } by any input, Pi arrives at an accept state. Second, when Pi crashes and can receive further no inputs, Pi arrives at an accept state. Third, when a object in {cim 1 , cim 2 , ..., cim qi } is so damaged that becomes unavailable to Pi and M is can never be completed without the object, the mission arrives at an accept state. For instance, if the file for decryption keys is deleted by an attack, the mission to decrypt an encrypted file can never be completed. P SMi as above is defined when a program is under a certain pair of attack instance and MTD instance. However, when different pairs of attack instance and defense instance occur, P SMi would be transformed in two aspects. First, new states could appear. For instance, a newly identified zero-day attack could lead to new damage on {ci1, ci2, ..., c it i }, which would introduce a new state. Second, new transitions could appear. For example, when new states appear, new transition must appear to connect these new states with existing states. When Pi is under no attacks and defenses, we define the P SMi to be clear. When Pi is under a pair of attack instance and defense instance, we call the corresponding P SMi a variant of the clear P SMi and we label the P SMi variant with the pair.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">The Second Layer: System State Machine</head><p>The first layer models each program in Sys separately, without considering interactions between different programs. Consequently, the first layer could not tell how damage propagates through programs, and is unable to evaluate damage to the whole system.</p><p>In our model, the second layer is designed upon the first layer. This layer is expected to model interaction between programs, and present damage caused to Sys. Similar to the first layer, the second layer is designed as a state machine {Q S, S, δ S, q0 S, F S}, and we name it a System State Machine (SSM ). Algorithm.1 in Appendix.A demonstrates how an SSM is generated. Two procedures are included in Algorithm.1. The first procedure INTERACT(PSMs) conservatively connects different P SM s to model interactions between different programs. Line 2 to line 6 initializes SSM . Def(q0S) defines q0 S as the start state, which is a virtual state; F S and δ S are initialized as empty sets; T E stands for the input event when transition occurs between programs. Specifically, T E could be normal input event or null. Line 7 to line 12 expands SSM iteratively. All states, input events, and transitions in each P SM are included in SSM ; a transition between the start state of SSM and the start state of each P SM is included to δ S, and input event to trigger this transition is T E. Line 13 to line 24 connects different P SM s, to present interactions between different programs. Specifically, a transition is added between any two states from two different P SM s, with T E as the input event.</p><p>When completed, INTERACT(PSMs) returns a primitive SSM . According to such an SSM , any two programs in any states could interact with each other. We model interactions between programs in such a way, because it is hard to exactly determine how and when interactions would happen. For instance, if two programs access a common database, interactions between them could happen at any time. However, many interactions modeled by INTERACT(PSMs) never happen in practice, and thus, transitions to present those interactions are redundant. We designed the second procedure P RU N E(SSM ) to prune redundant transitions in SSM .</p><p>The procedure P RU N E(SSM ) enforces two pruning principles from line 28 to line 50 in Algorithm.1. First, if Pi can not actively communicate with Pj, any transitions from states in P SMi to states in P SMj are removed. If information could flow from Pi to Pj, we say that Pi can actively communicate with Pj, and the function InterAct(Pi, Pj) returns true. Otherwise, InterAct(Pi, Pj) returns f alse. Second, any transition from a state in F S to another state in Q S are removed. We only propose the two principles, and it is sure that all transitions removed based on such principles are actual redundancies.</p><p>In Algorithm.1, the SSM is constructed when the system is under a specific pair of attack instance and defense instance. However, as explained previously, different pairs of attack instance and MTD instance lead to P SM variants, and subsequently lead to variants of SSM .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">The Third Layer: Evaluation State Machine</head><p>An SSM enables our model to analyze MTD techniques in a system scope. However, different states in an SSM represent damage to different components in the system.</p><p>To understand what can happen to the whole system, it is necessary to scan the state space of an SSM and collect damage information. Also, damage information in an SSM is expressed as status of low-level contexts, which requires further interpretations for being understood by general users (e.g. the mission manager). In addition, to evaluate the effectiveness of different MTD techniques, it is necessary to use different SSM variants and switch between them.</p><p>To handle the above problems, we design the third layer, to work as a user interface. We expect this layer to support our model in three aspects: (1) it describes damage to the whole system in a centralized way; (2) damage is explicitly expressed, which requires little interpretation to be understood; (3) a uniform mechanism to evaluate different defenses against different attacks is provided. This layer is designed as a state machine {Q E, E, δ E, q0 E, F E}, and we call it an Evaluation State Machine (ESM ). An ESM is built upon variants of SSM for Sys: {SSM1, SSM2, ..., SSMNS}. Since each SSM variant is caused by a pair of attack instance and defense instance, we label different SSM variants with {(Att1, Def1), (Att2, Def2), ..., (AttNS, DefNS)}. For each i, we call (Atti, Defi) the label of SSMi. Now we discuss details of an ESM : Q E: For each i, SSMi is abstracted as impacts of (Atti, Defi) on M is, and such impacts are regarded as a state of an ESM . In this layer, the impacts are interpreted as three measurements: damage (Dami); damage infection (DamInfi); and attack surface (AttSuri). First, Dami represents damage to the mission caused by (Atti, Defi). In this layer, Dami is explicitly presented as damage to resource objects that are required by M is. If in a state of SSMi, the damage to a resource object is not null, then the damage would be assigned to this object. If multiple damages are assigned to a object, the largest damage or damages would be kept as damage to this object. So damage could be expressed as a vector Dam = {(cm1 : dam1), (cm2 : dam2), ..., (cmt : damy)}. How to interpret such a damage vector as damage to M is depends on specifics of the mission, and we will give an example in the case study section. Further, any methods to quantify such a damage vector could be applied to get a quantitative metric of damage. Second, DamInfi represents how damage propagate through Sys to affect M is. Given directly damaged objects in Dami, the remaining objects in Dami are regarded as infected ones. When an attack occurs, if an object directly interacts with external inputs and is damaged, this object is regarded as a directly damaged object. DamInfi is measured by the infected objects. Third, AttSuri measures the attack surface in Sys that can be used to damage M is. We do not define attack surfaces in this paper, but our model is compatible with many attack surface definitions. Given a model of attack surface, AttSuri could be measured by the objects in Dami that are defined as attack surfaces by the model. For instance, Manadhata et al. <ref type="bibr" target="#b16">[16]</ref> define attack surface as subset of the system's resources potentially used in attacks on the system, which can help us to measure AttSur. E: We regard different pairs of attack instance and defense instance (e.g. (Atti, Defi)) as inputs to ESM . Under different pairs, different SSM variants for Sys could appear and thus lead to different states in ESM .</p><p>δ E: Assuming AD = {a1, a2, ..., ana} ∪ {d1, d2, ..., d nd } and P(AD) is the power set of AD, then ⊂ is a partial ordering relation on P(AD). Thus we can create a Hasse diagram (HG) for &lt; P(AD), ⊂&gt;. Each node in HG is a set of attacks and defenses, and we divide the set into a pair of an attack instance and a defense instance. By representing each node with a state that is labelled by the pair, we get a new undirected graph EG. Each edge in EG represents a transition in ESM , and the transition direction is accordant with the direction of ⊂. For instance, if node a ⊂ node b in HG, then in EG, the transition starts with the state labelled by node a and ends with the state labelled by node b. q0 E: When Sys is under no attacks and no defenses, we think the system is clear and corresponding SSM is also clear. Start state is abstracted from the clear SSM .</p><p>F E: Accept State of an ESM is a virtual state, and it is involved to maintain completeness of an ESM . If a state in Q E can not transit to any other state, a transition between this state and the Accepts State would be created.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Towards Filling the Gap</head><p>The three-layer model is expected to fill the gap between low-level methods and high-level methods. The first layer identifies required contexts from individual programs as raw information, and interprets them as damage to M is. In such a way, critical low-level contexts are captured for evaluation, and contexts are translated to reduce pre-processing on contexts in the upper layers. The second layer interconnects P SM s for different programs, and tries to model interactions between different programs. This layer enables our model to work in a system scale. The third layer is designed as an interface to interact with users (e.g. security manager). In this layer, impacts caused by attacks and defenses to Sys are explicitly abstracted as universal measurements, which can be directly used as comparison metrics.</p><p>We try to link the three layers as a whole, rather than roughly stacking them together to fill the gap. Three hooks are designed to consolidate the whole model. First, in the first layer, contexts are slightly abstracted to damage to resource objects. In this process, low-level contexts are translated into damage information, and the translation maintains sufficient low-level information for upper layers. Second, P SM s from the first layer are directly incorporated into the second layer, and mechanisms are designed to remove redundancy (or mistakes) during the incorporation. Hence, we think that the first layer and second layer are hooked. Third, an SSM variant from the second layer, as a whole, is interpreted as a state in the third layer. The interpretation is completed based on all states in the SSM , and required information for evaluation are reserved during this process. In this way, the second layer and third layer are correlated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">A CASE STUDY</head><p>In this section, we present a case study to elaborate our evaluation model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Mission and System</head><p>The mission is to extract information from an encrypted and then compressed file. The compression is based on Huffman encoding and the encryption is based on AES algorithm.</p><p>Two steps are required for the mission. First, data in the file should be decompressed. Second, the decompressed data are required to be decrypted. Though in real world, a file should be firstly compressed and then decrypted, this reality does not affect how we describe the case study.</p><p>A system is designed to support the mission. The system consists of two open source programs: Huffman decoder <ref type="bibr" target="#b21">[21]</ref> for decompression and OpenAES <ref type="bibr" target="#b20">[20]</ref> for decryption. The two programs interact through a common directory. Whenever Huffman decoder gets a new file, it will decompress the file and move it into the common directory. OpenAES periodically scans the common directory and whenever a new file is found, OpenAES will decrypt the file.</p><p>1 char KeyBuf [ 1 2 8 ] ; 2 char DataBuf [ 1 2 8 ] ; 3 . . . 4 f s e e k ( D a t a F i l e , 0 , SEEK END) 5 f i l e s i z e = f t e l l ( D a t a f i l e ) ; 6 // i f ( f i l e s i z e &gt; 128) e x i t (ERROR SIZE ) ; 7 f r e a d ( DataBuf , 1 , f i l e s i z e , D a t a F i l e ) ; 8 . . . Listing 1: OpenAES code snippet</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Attack and Defense</head><p>We insert a vulnerability into OpenAES to launch a buffer overflow attack. As shown in Listing.1, buffer KeyBuf and DataBuf are allocated adjacently on the stack. Buffer DataBuf and KeyBuf are used to store the key and encrypted data, and KeyBuf is in lower address space than DataBuf on the stack. We comment out the codes to check the size of the input file, as showed in line 6. Once more than 128 bytes of data are read into DataBuf from the input file, KeyBuf buffer would be overflowed.</p><p>During the mission, we suppose an adversary lunches a buffer overflow attack targeted on the revised OpenAES program. First, when the KeyBuf is partially overflowed, namely the length of data read from DataFile exceeds 128 bytes but less than 256 bytes, OpenAES cannot successfully decrypt the data since decryption key is polluted. Second, an attacker can carefully design a DataFile with 256 bytes. The first 128 bytes in the DataFile are padded with fake data that are encrypted with self-decided keys, and the remaining 128 bytes are padded with the self-decided keys. Then the KeyBuf will be completely overflowed by 129 ∼ 256 bytes in the DataFile, and OpenAES would decrypt the first 128 bytes with the modified keys and return the fake date. Third, OpenAES might get data more than 256 bytes from DataFile, which means it could pollute the KeyBuf or even other important data on the stack. In this case, the whole program might crash.</p><p>We deploy ASLR, ISR, and CSR as MTD techniques in the system to mitigate the buffer overflow attack.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Evaluation with Three-layer Model</head><p>In this part, we explain how to evaluate above MTDs based on our three-layer model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.1">First Layer</head><p>As mentioned, a buffer overflow attack is launched to fail the mission. We design a tool to track selected context objects in Huffman decoder and OpenAES. In Huffman decoder, context objects we tracked are: (1) the file that stores compressed data (datafile); (2) the memory buffer to load data from datafile (databuf); (3) the memory buffer for decompressed data (outbuf); (4) the file to store data in outbuf (outfile). In OpenAES, context objects we tracked are: (1) the file that stores encrypted data (DataFile); <ref type="bibr" target="#b2">(2)</ref> the memory buffer to load data from DataFile (DataBuf);</p><p>(3) the buffer to load decryption keys (KeyBuf); (4) the memory buffer to store decrypted data (OutBuf); (5) the file to store decrypted data (OutFile). As explained before, status of tracked contexts are interpreted as damage, and a state machine is created to illustrate transitions between damage.   This state machine presents how the attack damages the system when ASLR is deployed. When different MTDs are deployed, the whole state machine would change to different variants.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.3">Third Layer</head><p>The third layer explicitly expresses how different MTD combinations could mitigate the launched attack. Impacts of the attack are presented in Figure .2-(a) when different MTD instances are deployed. Dam and DamInf on resource objects are described as explained previously. It is possible to further interpret these descriptions: Dam1 can be interpreted as a system crash; Dam2 means that the decryption key is under the control of attackers and thus, the decryption process in the mission is controlled by attackers; and Dam3 can be viewed as a decryption error, and which can be identified by a mission manager. The attack surfaces are determined based on measurements proposed by Manadhata et al. <ref type="bibr" target="#b16">[16]</ref>. If CSR is deployed, damage caused by the attack would be identified by the mission manager, be-cause the attack would lead to a system crash. Otherwise, the attackers control the decryption process, which could be regarded as a failure of the mission, and such a failure could not be identified. Also, deploying CSR along with other MTDs can not improve the defense. So in this case, a good choice of MTD could be CSR.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSION</head><p>In this paper, we present a three-layer model to evaluate effectiveness of MTDs. This model is proposed as an attempt to fill the gap between low-level methods and highlevel methods. Each layer in this model is designed to integrate merits of the two types of methods. The first layer captures low-level contexts in separate programs; the second layer models damage propagation between different programs; the third layer works as a user interface to explicitly expresses evaluation results. We made a case study to demonstrate how our model works and the feasibility of this model to fill the gap. In our future works, we will evaluate this model in a more comprehensive way.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Three-layer model for MTD evaluation (The bottom part presents PSM variants for two programs in the first layer; the middle part presents SSM variants for the system consist of Program 1 and Program 2, as the second layer; the top part presents the ESM constructed based on the middle part, as the third layer. Only one defense and one attack are considered in this figure).</figDesc><graphic coords="6,92.77,269.56,191.97,144.80" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Figure.2-(c) shows how damage transits in Huffman decoder and OpenAES when the attack happens and ASLR is deployed. When different MTDs are deployed, such state machines would transform to variants.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: A Case Study (How the buffer overflow attack affect the mission when different MTDs are deployed).</figDesc><graphic coords="9,314.90,422.52,56.41,56.41" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>5. 3 . 2</head><label>32</label><figDesc>Second Layer P SM s for Huffman decoder and OpenAES are merged in this layer. As explained, Huffman decoder and OpenAES interact with each other via a common directory. If and only if a file that contains attack payloads has been decompressed by Huffman decoder, the file can be loaded by OpenAES and compromise OpenAES. This is the only way can damage transits from Huffman decoder to OpenAES. As shown in Figure.2-(b), the only connection between Huffman decoder and OpenAES is the edge connecting accept state of Huffman decoder and start state of OpenAES.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">ACKNOWLEDGMENTS</head><p>This work was supported by ARO W911NF-09-1-0525 (MURI), NSF CNS-1223710, NSF CNS-1422594, ARO W911NF-13-1-0421 (MURI), and AFOSR W911NF1210055.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3:</head><p>Q S := {q0 S} Assignment Expression</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4:</head><p>F S := ∅ Init Accept States</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5:</head><p>δ S := ∅ Init Transition</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6:</head><p>S := {T E} Init Inputs</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7:</head><p>for i from 1 to N do 8:</p><p>F S := F S ∪ F Pi 10:</p><p>--→ q0 Pi}</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>12:</head><p>end for 13:</p><p>for j from 1 to N do P SMj</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>14:</head><p>for k from 1 to N do Other P SM s</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>15:</head><p>if j==k then Exclude Self-interaction</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>16:</head><p>continue 17:</p><p>end if</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>18:</head><p>for all q j ∈ Q Pj do States in P SMj</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>19:</head><p>for all q k ∈ Q P k do Other States 20:</p><p>end for</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>22:</head><p>end for</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>23:</head><p>end for</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>24:</head><p>end for</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>25:</head><p>return SSM SSM Initialized end procedure 27: procedure PRUNE(SSM ) Prune SSM</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>28:</head><p>for j from 1 to N do Each PSM</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>29:</head><p>for k from 1 to N do Other PSMs</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>30:</head><p>if j==k then</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>31:</head><p>continue 32:</p><p>end if</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>33:</head><p>for all q j ∈ Q Pj do Single PSM States</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>34:</head><p>for all q k ∈ Q P k do Other States</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>35:</head><p>if not InterAct(P SMj , P SM k ) then</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>36:</head><p>δ S := δ S/{q j T E --→ q k} 37:</p><p>end if</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>38:</head><p>if not InterAct(P SM k , P SMj ) then</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>39:</head><p>δ S := δ S/{q k T E --→ q j} 40:</p><p>end if</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>41:</head><p>if q j ∈ F Pj then</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>42:</head><p>δ S := δ S/{q j </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Toward network configuration randomization for moving target defense</title>
		<author>
			<persName><forename type="first">E</forename><surname>Al-Shaer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Moving Target Defense</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="153" to="159" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Securing web servers using self cleansing intrusion tolerance (scit)</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Bangalore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Sood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Dependability, 2009. DEPEND&apos;09. Second International Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="60" to="65" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Sqlrand: Preventing sql injection attacks</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Boyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Keromytis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Applied Cryptography and Network Security</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="292" to="302" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Application-level simulation for network security</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Luther</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Albayrak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st international conference on Simulation tools and techniques for communications, networks and systems &amp; workshops</title>
		<meeting>the 1st international conference on Simulation tools and techniques for communications, networks and systems &amp; workshops</meeting>
		<imprint>
			<publisher>ICST</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">33</biblScope>
		</imprint>
		<respStmt>
			<orgName>Institute for Computer Sciences, Social-Informatics and Telecommunications Engineering</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Return-oriented programming without returns</title>
		<author>
			<persName><forename type="first">S</forename><surname>Checkoway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Davi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Dmitrienko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A.-R</forename><surname>Sadeghi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Shacham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Winandy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th ACM conference on Computer and communications security</title>
		<meeting>the 17th ACM conference on Computer and communications security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="559" to="572" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">N-version programming: A fault-tolerance approach to reliability of software operation</title>
		<author>
			<persName><forename type="first">L</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Avizienis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 8th IEEE Int. Symp. on Fault-Tolerant Computing (FTCS-8)</title>
		<meeting>8th IEEE Int. Symp. on Fault-Tolerant Computing (FTCS-8)</meeting>
		<imprint>
			<date type="published" when="1978">1978</date>
			<biblScope unit="page" from="3" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Mitigating buffer overflows by operating system randomization</title>
		<author>
			<persName><forename type="first">M</forename><surname>Chew</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">End-to-end software diversification of internet services</title>
		<author>
			<persName><forename type="first">M</forename><surname>Christodorescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fredrikson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Giffin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Moving Target Defense</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="117" to="130" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A moving target environment for computer configurations using genetic algorithms</title>
		<author>
			<persName><forename type="first">M</forename><surname>Crouse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Fulp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Configuration Analytics and Automation (SAFECONFIG), 2011 4th Symposium on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="1" to="7" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">return-to-libc attack</title>
		<author>
			<persName><forename type="first">S</forename><surname>Designer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bugtraq</title>
		<imprint>
			<date type="published" when="1997-08">Aug, 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Compiler-generated software diversity</title>
		<author>
			<persName><forename type="first">T</forename><surname>Jackson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Salamat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Homescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Manivannan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Wagner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Brunthaler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wimmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Franz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Moving Target Defense</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="77" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Jajodia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Ghosh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Swarup</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><forename type="middle">S</forename><surname>Wang</surname></persName>
		</author>
		<title level="m">Moving Target Defense</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Randsys: Thwarting code injection attacks with system service interface randomization</title>
		<author>
			<persName><forename type="first">X</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-M</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Reliable Distributed Systems, 2007. SRDS 2007. 26th IEEE International Symposium on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="209" to="218" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Countering code-injection attacks with instruction-set randomization</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Kc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Keromytis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Prevelakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th ACM conference on Computer and communications security</title>
		<meeting>the 10th ACM conference on Computer and communications security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="272" to="280" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Computation and state machines</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
	<note>Unpublished note</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">An attack surface metric. Software Engineering</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">K</forename><surname>Manadhata</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Wing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="371" to="386" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Creating a cyber moving target for critical infrastructure applications using platform diversity</title>
		<author>
			<persName><forename type="first">H</forename><surname>Okhravi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Comella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Robinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Haines</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Critical Infrastructure Protection</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="30" to="39" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><surname>Okhravi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Hobson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Bigelow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Streilein</surname></persName>
		</author>
		<title level="m">Finding focus in the blur of moving target techniques</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Quantitative evaluation of dynamic platform techniques as a defensivemechanism ?</title>
		<author>
			<persName><forename type="first">H</forename><surname>Okhravi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Riordan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">M</forename><surname>Carter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Research in Attacks, Intrusions, and Defenses</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">S</forename><surname>Ramli</surname></persName>
		</author>
		<ptr target="https://code.google.com/p/openaes" />
		<title level="m">Openaes portable c cryptographic library</title>
		<imprint>
			<biblScope unit="page" from="2014" to="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">D</forename><surname>Richardson</surname></persName>
		</author>
		<ptr target="https://github.com/drichardson/huffman.git" />
		<imprint>
			<biblScope unit="page" from="2014" to="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Probabilistic accuracy bounds for fault-tolerant computations that discard tasks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th annual international conference on Supercomputing</title>
		<meeting>the 20th annual international conference on Supercomputing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="324" to="334" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Manipulating program functionality to eliminate security vulnerabilities</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Moving Target Defense</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="109" to="115" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Living in the comfort zone</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="611" to="622" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Using early phase termination to eliminate load imbalances at barrier synchronization points</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Notices</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="369" to="386" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">The design of a generic intrusion-tolerant architecture for web servers. Dependable and Secure Computing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Saidane</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Nicomette</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Deswarte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="45" to="58" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The geometry of innocent flesh on the bone: Return-into-libc without function calls (on the x86)</title>
		<author>
			<persName><forename type="first">H</forename><surname>Shacham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th ACM conference on Computer and communications security</title>
		<meeting>the 14th ACM conference on Computer and communications security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="552" to="561" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">On the effectiveness of address-space randomization</title>
		<author>
			<persName><forename type="first">H</forename><surname>Shacham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Page</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pfaff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E.-J</forename><surname>Goh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Modadugu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th ACM conference on Computer and communications security</title>
		<meeting>the 11th ACM conference on Computer and communications security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="298" to="307" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Introduction to the Theory of Computation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Sipser</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>Cengage Learning</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Where&apos;s the feeb? the effectiveness of instruction set randomization</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">N</forename><surname>Sovarel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Paul</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Usenix Security</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Assessing the trustworthiness of drivers</title>
		<author>
			<persName><forename type="first">S</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Research in Attacks, Intrusions, and Defenses</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="42" to="63" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Simulation-based approaches to studying effectiveness of moving-target network defense</title>
		<author>
			<persName><forename type="first">R</forename><surname>Zhuang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Deloach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Ou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Singhal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">National Symposium on Moving Target Research</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
