<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">FlexMiner: A Pattern-Aware Accelerator for Graph Pattern Mining</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Xuhao</forename><surname>Chen</surname></persName>
							<email>xchen@csail.mit.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Massachusetts Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Tianhao</forename><surname>Huang</surname></persName>
							<email>tianhaoh@csail.mit.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Massachusetts Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Shuotao</forename><surname>Xu</surname></persName>
							<email>shuotao@csail.mit.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Massachusetts Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Thomas</forename><surname>Bourgeat</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Massachusetts Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Chanwoo</forename><surname>Chung</surname></persName>
							<email>cwchung@csail.mit.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Massachusetts Institute of Technology</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">FlexMiner: A Pattern-Aware Accelerator for Graph Pattern Mining</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2023-01-01T13:37+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Graph pattern mining (GPM) is a class of algorithms widely used in many real-world applications in bio-medicine, ecommerce, security, social sciences, etc. GPM is a computationally intensive problem with an enormous amount of coarse-grain parallelism and therefore, attractive for hardware acceleration. Unfortunately, existing GPM accelerators have not used the best known algorithms and optimizations, and thus offer questionable benefits over software implementations.</p><p>We present FlexMiner, a software/hardware co-designed GPM accelerator that improves the efficiency without compromising the generality or productivity of state-of-the-art software GPM frameworks. FlexMiner exploits massive amount of coarse-grain parallelism in GPM by deploying a large number of specialized processing elements. For efficient searches, the FlexMiner hardware accepts pattern-specific execution plans, which are generated automatically by the FlexMiner compiler from the given pattern(s). To avoid repetitive computation on neighborhood connectivity, we provide dedicated on-chip storage to memoize reusable connectivity information in a connectivity map (c-map) which is implemented with low-cost yet high-throughput hardware. The on-chip memories in FlexMiner are managed dynamically using heuristics derived by the compiler, and thus are fully utilized. We have evaluated FlexMiner with 4 GPM applications on a wide range of real-world graphs. Our cycle-accurate simulation shows that FlexMiner with 64 PEs achieves 10.6× speedup on average over the state-of-the-art software system executing 20 threads on a 10-core Intel CPU.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Graph pattern mining (GPM) finds subgraphs that match certain pattern(s) in a given graph (Fig. <ref type="figure" target="#fig_0">1</ref>). GPM is a computeintensive building block in numerous important applications in chemical engineering <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b47">48,</ref><ref type="bibr" target="#b70">71]</ref>, bioinformatics <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b59">60,</ref><ref type="bibr" target="#b60">61,</ref><ref type="bibr" target="#b69">70,</ref><ref type="bibr" target="#b73">74]</ref>, web spam detection <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b35">36]</ref>, social sciences <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b40">41]</ref>, and others <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b87">88,</ref><ref type="bibr" target="#b91">92]</ref>. For example, GPM is used to predict the functionality of a new protein in a protein-protein interaction network, where vertices represent proteins labeled with their functionality and edges are interactions between these proteins. The prediction can be preformed by mining frequent subgraphs with similar interactions to the new protein <ref type="bibr" target="#b18">[19]</ref>. We believe GPM would be used even more widely in applications if it were cheaper to compute.</p><p>Since writing efficient parallel GPM programs by hand is time-consuming and error-prone, many software GPM systems, such as, Arabesque <ref type="bibr" target="#b81">[82]</ref>, RStream <ref type="bibr" target="#b83">[84]</ref>, Fractal <ref type="bibr" target="#b24">[25]</ref>, Kaleido <ref type="bibr" target="#b94">[95]</ref>, AutoMine <ref type="bibr" target="#b57">[58]</ref>, Pangolin <ref type="bibr" target="#b15">[16]</ref>, Peregrine <ref type="bibr" target="#b43">[44]</ref>  have been proposed to improve productivity. In general, to solve a GPM problem, a solver program takes a data graph G and a pattern P of size k, enumerates all the possible subgraphs of size k in G, and checks each subgraph to see if it is isomorphic to P. This is computationally intensive even on moderate size graphs because of the massive combinatorial search space and the expensive graph isomorphism test. For example, to mine the 4-cycle pattern (Fig. <ref type="figure" target="#fig_2">3</ref>) in the Friendster <ref type="bibr" target="#b51">[52]</ref> graph with 65 million vertices and 1.8 billion edges, AutoMine <ref type="bibr" target="#b57">[58]</ref>, one of the fastest GPM software systems, takes 15 hours on a 4-socket 14-core (56-core in total) Intel CPU machine. Therefore, hardware GPM accelerators like TrieJax <ref type="bibr" target="#b45">[46]</ref> and Gramer <ref type="bibr" target="#b89">[90]</ref> have been proposed to improve GPM's performance and energy-efficiency.</p><p>Subgraph enumeration to match a pattern can be modeled as building a search tree. The efficiency of any GPM solution, to the first order, depends upon the size of this search tree. Pattern-aware solutions exploit the specific properties of a pattern to drastically prune the search space. Unfortunately, existing hardware accelerators are inefficient because they use naive pattern oblivious search strategies, resulting in significantly larger search space than the state-of-the-art software solutions. Meanwhile, existing accelerators also have limited generality. TrieJax, unlike a software GPM system, supports only a small subset of GPM problems. Gramer supports more GPM problems but adopts an ad-hoc approach which requires implementing a specific solver for each specific GPM problem, significantly hampering its usability. The limited generality is a consequence of the fact that Gramer and TrieJax lack a well-defined software/hardware interface to configure/program the accelerator. Lastly, unlike GPM software systems, existing accelerators lack the support for memoization and thus repetitively check the connectivity of vertices during the search.</p><p>We propose FlexMiner, a software-hardware co-designed GPM system, which strives for both generality and performance without sacrificing the ease of programming. Fig. illustrates an overview of the FlexMiner system which contains the FlexMiner hardware and a software/hardware interface. The FlexMiner hardware is a special-purpose architecture to offload the GPM computations of an application running on the host. It does a depth-first search (DFS) over the search tree.</p><note type="other">2</note><p>The software/hardware interface is established between the user program and the hardware, to make FlexMiner patternaware. The user program only needs to specify the pattern(s) of interest, same as state-of-the-art software GPM frameworks.</p><p>FlexMiner first does an analysis on the pattern(s), and then uses a compiler to automatically generate a pattern-specific execution plan. This execution plan is loaded by the host CPU to the FlexMiner hardware at the beginning of execution, and customizes the DFS search process in hardware. In this way, FlexMiner can flexibly mine any arbitrary pattern with high algorithmic efficiency. In addition to this flexibility, the FlexMiner hardware also provides much higher throughput than general purpose CPUs. The efficiency of the FlexMiner hardware stems from the following features: Massive Multithreading: FlexMiner exploits the embarrassing amount of parallelism in GPM which comes from the fact that the searches starting from different vertices of G are mutually independent tasks and can be done concurrently. FlexMiner consists of a collection of processing engines (PEs) to exploit this massive parallelism to saturate the memory bandwidth and hide memory latency. PE Specialization: Each PE contains a specialized unit that is optimized for efficient set intersection and set difference operations. These operations frequently compare neighbor list of vertices, and are the major bottlenecks in state-of-the-art software GPM frameworks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Connectivity Memoization:</head><p>The set operations access neighbor lists in G frequently and repeatedly, which results in a significant amount of redundant computation. We use a novel c-map structure (Section VI) to memorize the neighborhood information and avoid this redundancy with low-cost hardware. Besides, the FlexMiner compiler passes pattern-specific hints to the hardware to help efficiently manage c-map storage.</p><p>We prototype the PE of FlexMiner in RTL using Bluespec and synthesize the design with Silvaco's 15nm Open-Cell Library. Our PE with 32kB private cache and 8kB scratchpad runs at 1.3GHz and takes an area of 0.18mm 2 . In comparison, a single high-end Intel SkyLake core with 1MB L2 cache is clocked around 4GHz and takes an area of 15mm 2 <ref type="bibr" target="#b45">[46]</ref>. Detailed performance simulation shows that with 64 PEs (which take approximately the same area as a single Intel CPU core and operate at one third of its clock speed), FlexMiner achieves 10.6× speedup on average over the state-of-theart software solution on a 10-core Intel i9-7900X CPU. In summary, this paper makes the following contributions:</p><p>• FlexMiner, the first pattern-aware GPM accelerator which supports a variety of GPM applications using techniques from state-of-the-art software algorithms for GPM; • A programming interface which is the same as the state-ofthe-art software GPM systems. We use a small compiler to generate the execution plan to configure the hardware; • Hardware support for memoizing connectivity information to avoid redundant computation with low cost; • Evaluation using representative GPM applications and diverse graphs to show that FlexMiner significantly improves performance over state-of-the-art software frameworks.</p><p>Paper organization: Section II defines GPM, introduces 4 GPM problems, and describes how a GPM problem is solved in state-of-the-art software GPM systems. In Section III we point out the limitations of existing hardware to motivate our work. Section IV introduces the FlexMiner architecture. Section V defines the software/hardware interface. We discuss our hardware support for c-map in Section VI. Section VII evaluates our design and Section IX concludes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. BACKGROUND</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Graph Pattern Mining Problems</head><p>Given a graph G(V, E) and a vertex set V ⊆ V , the vertexinduced subgraph is the graph G whose vertex set is V and edge set contains the edges in E whose endpoints are in V . Given G(V, E) and an edge set E ⊆ E, the edge-induced subgraph is the graph G whose edge set is E and vertex set contains the endpoints in V of the edges in E .</p><p>Given a data graph G and a set of patterns S p = {P 1 , . . . , P n }, GPM seeks to find all those subgraphs, i.e., embeddings, in G that are isomorphic to P i , ∀P i ∈ S p . Fig. <ref type="figure" target="#fig_0">1</ref> shows an example of triangle embeddings in a graph. A GPM solution should guarantee completeness, i.e., every match of P in G should be found, and uniqueness, i.e., every distinct match should be reported only once. We consider the following GPM problems in this paper: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>✓</head><p>matching order</p><formula xml:id="formula_0">u 0 &gt; u 1 u 1 &gt; u 2 u 0 &gt; u 3 symmetry order Level 0 Level 1 Level 2 Level 3</formula><p>Lightly colored subgraphs are removed from consideration by symmetry breaking using the symmetry order. ✘ shows the unnecessary extension that can be pruned by using the matching order. ✓ shows the matched subgraph.</p><formula xml:id="formula_1">u 0 [-] u 1 [0] u 2 [0] u 3 [1,2]</formula><p>Fig. <ref type="figure">4</ref>: A portion of a subgraph search tree with 4 levels (vertex extension used).</p><p>• Triangle counting (TC) counts the number of triangles in G.</p><p>• k-clique listing (k-CL) lists all k-cliques in G, where a kclique of G is defined as a subgraph G of G, such that G has k vertices and every pair of vertices in G is connected by an edge in G , i.e., G is a complete graph. • Subgraph listing (SL) enumerates all edge-induced subgraphs of G isomorphic to a user-defined pattern P. • k-motif counting (k-MC) counts the number of occurrences of the different patterns that are possible with k vertices. Each pattern is also called a motif. Fig. <ref type="figure" target="#fig_2">3</ref> shows all 3-motifs and 4-motifs. k-MC finds vertex-induced subgraphs.</p><p>A GPM problem to mine one single pattern is called a single-pattern problem, e.g., TC, k-CL and SL, whereas a problem to find multiple patterns simultaneously is called a multi-pattern problem, e.g., k-MC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. GPM Execution Model and Search Strategies</head><p>To solve a GPM problem, a solver program enumerates all the possible subgraphs of size k in G, and checks each subgraph to see if it is isomorphic to P. This solving process can be modeled as building a search tree in which each vertex represents a subgraph of G. Fig. <ref type="figure">4</ref> shows a search tree with 4 levels. Level l of the tree represents subgraphs with l + 1 vertices. Intuitively, subgraph S 2 =(W 2 , E 2 ) is a child of subgraph S 1 =(W 1 , E 1 ) in this tree if S 2 can be obtained by extending S 1 with a single vertex v / ∈ W 1 which is connected to some vertex in W 1 (v is said to be in the neighborhood of subgraph S 1 ); this process is called vertex extension. Formally, this can be expressed as W 2 =W 1 ∪ {v} where v / ∈ W 1 and there is an edge (v, u) ∈ E for some u ∈ W 1 . It is useful to think of the edge connecting S 1 and S 2 in the tree as being labeled by v. Similarly, Edge extension extends a subgraph S 1 with a single edge (u, v) provided at least one of the endpoints of the edge is in S 1 .</p><p>Based on the search tree model, we classify existing software GPM frameworks into two categories: pattern-oblivious and pattern-aware. The pattern-oblivious approach builds the search tree and checks each leaf to determine if it is isomorphic to P. In contrast, a pattern-aware solution leverages the properties of P to prune the search tree and avoid isomorphism tests. The pattern is analyzed to generate a matching order <ref type="bibr" target="#b43">[44]</ref> and a symmetry order <ref type="bibr" target="#b56">[57]</ref> which are used to guide the search and prune the search space. We define connected ancestor and describe the two orders below. To avoid notational confusion, we call a vertex in P as a pattern vertex, denoted as u i , and a vertex in G as a data vertex, denoted as v i . Connected ancestor: Given a subgraph S and a total order T O(S) on the vertices in S, a connected ancestor of vertex u in S under T O is a vertex w in S such that w &lt; u and w is connected to u. The connected ancestor set that includes all the connected ancestors of u in S under T O, is denoted as CA S,T O (u). For example, CA S,T O (u 3 ) = {u 1 ,u 2 } means u 1 and u 2 are u 3 's connected ancestors in S under T O. For simplicity, we write CA(u) instead of CA S,T O (u) when S and T O are obvious from the context. Matching order: It is a total order among pattern vertices that defines the order to match each data vertex to a pattern vertex. For example, in Fig. <ref type="figure">4</ref>, suppose P is a 4-cycle, and we generate its matching order MO and represent it as a list of connected ancestor set of u i in P under MO: {CA(u 0 )={}, CA(u 1 )={u 0 }, CA(u 2 )={u 0 }, CA(u 3 )={u 1 ,u 2 }}, meaning (1) any vertex v 0 in V can be mapped to u 0 ; (2) v 1 mapped to u 1 must be a neighbor of v 0 ; (3) v 2 mapped to u 2 also must be a neighbor of v 0 ; (4) v 3 mapped to u 3 must be a common neighbor of v 1 and v 2 . In level 2 of the tree in Fig. <ref type="figure">4</ref>, subgraphs marked with × are pruned, because the vertex mapped to u 2 (i.e., v 2 ) is not a neighbor of the vertex mapped to u 0 (i.e., v 0 ). Note that using matching order eliminates the need to apply isomorphism tests at the leaves of the search tree, because the leaf subgraphs always match P (see level 3 in Fig. <ref type="figure">4</ref>). Symmetry order: A specific subgraph can occur in multiple places in the search tree. For example, in Fig. <ref type="figure">4</ref>, the subgraph containing vertices 1 and 2 occurs in two places at level 1 of the tree. These identical subgraphs are called automorphisms. To avoid repetitive enumeration, only one of them, known as the canonical one, is kept, and extended further. This selection is known as symmetry breaking <ref type="bibr" target="#b56">[57]</ref>. A well established</p><formula xml:id="formula_2">u 0 u 3 u 1 u 2 u 0 u 3 u 2 u 1 u 0 u 2 u 3 u 1 u 1 u 3 u 2 u 0 u 2 u 1 u 3 u 0</formula><p>Fig. <ref type="figure">5</ref>: Possible matching orders for diamond.  approach for symmetry breaking is to define a partial order, known as a symmetry order, for candidate vertices and add only those subgraphs that satisfy the symmetry order.</p><formula xml:id="formula_3">v 0 v 1 v 0 v 2 v 1 v 0 v 2 v 3 v 1 u 0 u 2 u 3 u 1 (a)</formula><p>In Fig. <ref type="figure">4</ref>, suppose we define the symmetry order for the 4-cycle pattern as</p><formula xml:id="formula_4">{v 0 &gt; v 1 , v 1 &gt; v 2 , v 0 &gt; v 3 }.</formula><p>Using this order, the lightly colored subgraphs can all be pruned, which reduces the search space and guarantees uniqueness. Specifically, the subgraphs <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref> and <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b0">1]</ref> are automorphisms, and the former can be pruned because v 0 &gt; v 1 .</p><p>Given P, pattern-aware solutions use pattern analysis <ref type="bibr" target="#b57">[58]</ref> to generate a matching order <ref type="bibr" target="#b43">[44]</ref> and a symmetry order <ref type="bibr" target="#b56">[57]</ref>, which, in turn, can be used to generate a program to find P automatically. To generate a matching order, the pattern analyzer first enumerates all the possible matching orders of P, and uses a set of rules to pick one that is likely to perform well in practice <ref type="bibr" target="#b48">[49]</ref>. Fig. <ref type="figure">5</ref> lists all the possible matching orders for diamond. The first matching order searches for a triangle first (u 0 , u 1 , u 2 form a triangle), and the second matching order searches for a wedge first (u 0 , u 1 , u 2 form a wedge). Since the number of triangles is much fewer than the number of wedges in a sparse graph, the first matching order is likely to perform better than the second as it prunes many more candidates at the early stage. Using the rules in <ref type="bibr" target="#b48">[49]</ref>, we find that the first matching order is the best out of the five.</p><p>To generate a symmetry order for a pattern P, we first take one its matching orders, (MO) and build a subgraph incrementally in the order specified by MO. At each step we also check for the symmetry (Fig. <ref type="figure" target="#fig_5">6</ref>). The matching order in (a) results in the 3 steps shown in (b), (c) and (d). In (b), we add partial order v 1 &lt; v 0 as v 0 and v 1 are interchangeable, meaning that if no order is enforced between v 0 and v 1 then any match of P in G will be found twice by permuting v 0 and v 1 . Similarly, in (c) and (d) we add partial orders v 2 &lt; v 1 and v 3 &lt; v 0 , respectively. In all, the symmetry order generated for</p><formula xml:id="formula_5">4-cycle is {v 0 &gt; v 1 , v 1 &gt; v 2 , v 0 &gt; v 3 }.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Memoizing Connectivity Information</head><p>A major computation in AutoMine <ref type="bibr" target="#b57">[58]</ref>, Peregrine <ref type="bibr" target="#b43">[44]</ref> and GraphZero <ref type="bibr" target="#b56">[57]</ref> is set intersection/difference on edgelists. This requires frequent accesses to the edgelists of G during the search. For example, for pattern 4-cycle in Fig. <ref type="figure" target="#fig_5">6</ref> (a), v 3 (match of u 3 ) is from the intersection of v 1 's neighbors and v 2 's neighbors. For every different v 2 , the same v 1 's neighbors are visited. To avoid repeated lookups in G, we can memoize v 1 's neighbors in a connectivity map (c-map) during the search. Each entry in the c-map is a key-value pair, where the key is a vertex ID (say v), and the value is a list of depths of vertices in the current embedding which are connected to v. This list is implemented as a bitset to save space. For example, assume that the current embedding has 3 vertices, the entry [w, '001'] means vertex w is connected to the first vertex, but not to the second and the third vertices in the current embedding. Once the c-map is constructed, all the set operations can be replaced by querying the c-map. For example, for 4-cycle, the intersection is replaced by querying the c-map to check if each neighbor of v 2 is connected with v 1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. LIMITATIONS OF EXISTING GPM SOFTWARE SYSTEMS AND ACCELERATORS</head><p>Software GPM systems, such as Arabesque <ref type="bibr" target="#b81">[82]</ref>, RStream <ref type="bibr" target="#b83">[84]</ref>, Fractal <ref type="bibr" target="#b24">[25]</ref>, Kaleido <ref type="bibr" target="#b94">[95]</ref>, AutoMine <ref type="bibr" target="#b57">[58]</ref>, Pangolin <ref type="bibr" target="#b15">[16]</ref>, Peregrine <ref type="bibr" target="#b43">[44]</ref>, GraphZero <ref type="bibr" target="#b56">[57]</ref> simplify GPM programming and apply algorithmic optimizations to improve performance. However, given the irregularity of the GPM computation, software systems often show poor performance. To get in-depth understanding of how software GPM systems behave on general-purpose processors, we evaluated AutoMine <ref type="bibr" target="#b57">[58]</ref>, a state-of-the-art software GPM system, on a 12-core machine with 100GB/s max DRAM bandwidth and hyper-threading (2 threads per core). Fig. <ref type="figure" target="#fig_6">7</ref> shows the performance (left) and memory bandwidth (right) scaling of mining k-cliques in orkut (Table <ref type="table" target="#tab_4">I</ref>). The performance scales linearly until 12-thread, after which hyperthreading kicks in and the scaling slows down probably because of cache contention <ref type="bibr" target="#b7">[8]</ref>. We observe the same behavior using a 56-core machine, when we scale from 56-thread to 112-thread. Fig. <ref type="figure" target="#fig_6">7</ref> also shows that the memory bandwidth scales well beyond 12 threads, indicating there is potential to improve performance with more physical cores.</p><p>In another experiment using Intel VTune, we observe that 37%∼49% of pipeline slots are wasted due to branch misprediction. This is caused by the frequent comparison and branching in set intersection/difference, which account for a majority of computation in AutoMine. These observations suggest that an accelerator with a large number of physical cores with special support for set operations and local memory should be an effective way to scale GPM performance.</p><p>Unfortunately, existing hardware GPM accelerators, TrieJax <ref type="bibr" target="#b45">[46]</ref> and Gramer <ref type="bibr" target="#b89">[90]</ref>, are not efficient. TrieJax is based on a variant of the Worst Case Optimal Join (WCOJ) algorithm. The join operations are used to perform set intersections. TrieJax introduces a specialized core which works as a coprocessor with the CPU cores. The L1 and L2 caches of the specialized core are read-only, to avoid cache pollution by the writes. It also introduces a 4MB dedicated on-chip scratchpad, called the Partial Join Results (PJR) Cache, to buffer intermediate results of join operations. However, Trie-Jax has some limitations. First, it does not perform symmetry breaking, leading to a much larger search space than necessary. Second, it suffers from redundant computation on connectivity check. Third, it lacks an interface to configure the hardware and thus, is limited to solving single, edge-induced problems.</p><p>Gramer <ref type="bibr" target="#b89">[90]</ref> proposed a data prioritization technique for GPM, which heuristically prioritizes the hot, i.e., frequently accessed, data in the cache. This technique improves performance over existing pattern-oblivious software systems, such as RStream <ref type="bibr" target="#b83">[84]</ref> and Fractal <ref type="bibr" target="#b24">[25]</ref>. However, Gramer employs a pattern-oblivious search strategy. Although a filter mechanism in Arabesque is leveraged by Gramer to remove irrelevant subgraphs, it is not sufficient enough <ref type="bibr" target="#b15">[16]</ref> to prune the search space for an arbitrary pattern, and because of a lack of the matching order, Gramer requires expensive isomorphism tests. While Gramer supports solving more GPM problems than TrieJax, it requires re-synthesizing a hardware solver for each GPM problem due to a lack of programmable interface. Extra RTL programming efforts are expected from users, which could be a significant task for one without expertise in both hardware design and graph pattern mining.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. FLEXMINER DESIGN OVERVIEW</head><p>The limitations of existing pure software and pure hardware solutions motivate us to develop a SW/HW co-designed GPM system which can overcome these limitations.</p><p>As shown in Fig. <ref type="figure" target="#fig_1">2</ref>, FlexMiner establishes a software/hardware interface (Section V), which takes the user specified pattern as input, does an analysis on the pattern, and invokes the FlexMiner compiler to generate a pattern-specific execution plan. The execution plan is fed into the FlexMiner hardware at the beginning of execution. The FlexMiner hardware can be considered as a template of DFS walker over the subgraph search tree, which is implemented as a finite-state machine (Section IV-B). This template is customized by the patternspecific execution plan, and therefore the hardware is pattern aware. To provide high throughput, the hardware contains a collection of processing elements (PEs) specialized for GPM search. This architecture leverages the parallelism that comes from the fact that each search task starting from a vertex is independent from other tasks. Inside each PE, FlexMiner introduces a hardware hashmap (Section VI) to efficiently perform the major GPM computation. In case of hashmap overflow, a specialized set operation unit is invoked. A. FlexMiner Hardware Architecture Fig. <ref type="figure">8</ref> illustrates the FlexMiner architecture. FlexMiner consists of a scheduler, a shared cache, and a number of processing elements (PE), all connected with a network on chip (NoC). The scheduler dynamically assigns tasks to available idle PEs. The shared-cache buffers the vertex/edge data for all PEs, and the intermediate data spilled from PEs. There is no cache coherency in FlexMiner because each task is independent and there is no updates to shared data. Each PE is responsible for processing assigned tasks independently and does not require synchronization with other PEs.</p><p>Each PE contains the following components. The extender is a finite-state machine (detailed in Section IV-B) responsible for adding vertices one-by-one in the search tree. The pruner is used to prune the vertex candidates and is configured specifically for the pattern prior to the execution. It checks if the ID of the vertex being added is within the bounds of the symmetry order and queries c-map to check the connectivity constraints. Only when the c-map has overflowed, SIU and SDU are invoked to perform set intersection/difference operations to compute the qualified vertex candidates. SIU/SDU uses the well-known merge-based algorithm <ref type="bibr" target="#b38">[39,</ref><ref type="bibr" target="#b41">42]</ref> and its hardware structure is shown in Fig. <ref type="figure">9</ref>. Our specialized SIU and SDU perform one loop iteration (the while loop in Fig. <ref type="figure">9</ref>) per cycle.</p><p>The reducer contains a group of counters, one for each pattern. It uses + as the reduction operation, but can be extended easily to support user-defined reduction operations. The ancestor stack is a set of registers to hold the current partial match during the DFS search. The private cache stores the edgelist data, and memoizes the frontier list which is a list of vertices that have already passed the constraint checking and are going to be reused (detailed in Section V-C). Once a frontier list is generated, its start address and size are stored in the frontier list table. The scratchpad accommodates a specialized hash map to memoize the neighborhood connectivity (detailed in Section VI). Next we show details of the state machine and the FlexMiner execution flow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. FlexMiner Execution Flow</head><p>Pattern-aware software solutions <ref type="bibr" target="#b43">[44]</ref> use recursion, which is not suitable for direct implementation in hardware. Instead, FlexMiner uses the iterative execution model shown in Fig. <ref type="figure" target="#fig_7">10</ref> which can be implemented using a simple finite state machine.</p><p>A PE can be in one of the three states at runtime: Idle, Extending and IteratingEdges. d is the the depth counter, and emb is the ancestor stack in Fig. <ref type="figure">8</ref>. Whenever the DFS steps to the next level, a vertex is pushed on to the stack. When the traversal finishes searching at the current level, the stack pops the vertex at the top and backtracks to the previous level. For each depth of the search tree, there are registers to hold the current vertex being extended and the index of edge used for extension (i.e., i-th neighbor).</p><p>The execution starts from a vertex v init , which is a task assigned by the scheduler. v init is pushed on to the stack, and the depth is set to 1. The state is switched to Extending. At this stage, if the depth has reached the size of the pattern (k), a match has been found in the stack and the matched subgraph is added to the output. After that the search backtracks to the previous level by decreasing d and popping emb. If the maximum depth not reached yet, a vertex v in emb is picked (according to the matching order order) as the new vertex for extension and the index is set to 0. Now the state switches to IteratingEdges. If the index has come to the end of the neighbor list, the search backtracks to the previous level (if the previous level is in depth 0, indicating the entire subtree is already traversed, it goes back to idle stage and waits for the next task from the scheduler). Otherwise, the next neighbor of the extender u is considered as a candidate vertex to be checked by the pruner. If u satisfies the constraints (i.e., the symmetry order and connectivity), u is pushed into emb and the search goes to the next level by increasing d and switching to the Extending state.</p><p>The overall flow of FlexMiner can be explained in Fig. <ref type="figure">8</ref> as follows. At the beginning of execution, the execution plan is loaded (). The scheduler then assigns a task (vertex v) to the PE (). The extender puts v in the ancestor stack  (), and configures the pruner () according to the execution plan. The pruner then starts to load v's edgelist from private cache (), checks vertex id bound and queries the c-map for connectivity constraints (if c-map overflows, SIU/SDU is invoked). The other intermediate data, frontier list, stays in the private cache, and is written to the shared cache when evicted from the private cache. Once a frontier list is generated, its corresponding information is updated in the table (). The frontier list is reused from the private cache when it is accessed in a deeper level (). Whenever the extender finds a match, the reducer increases the local count (), which is sent to the global reducer at the end.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. SOFTWARE/HARDWARE INTERFACE</head><p>To efficiently support pattern-awareness, in FlexMiner, we define an interface to pass a pattern-specific execution plan to the hardware. We propose an intermediate representation (IR) to express the (1) matching order, (2) symmetry order and (3) the hints to manage on-chip storage, for a specific pattern. Fig. <ref type="figure" target="#fig_8">11 (a)</ref> shows the execution plan for the 4-cycle pattern and its IR is given in Listing 1. We develop a execution plan generator (referred as a "compiler") to do the pattern analysis and generate the IR code automatically. IR code is pre-loaded to the hardware accelerator before the execution starts. Our compiler generates matching order and symmetry order using the same approach in prior software frameworks <ref type="bibr" target="#b43">[44,</ref><ref type="bibr" target="#b56">57,</ref><ref type="bibr" target="#b57">58]</ref>. We describe how it generates the hints to manage on-chip storage and how multi-pattern problems are supported.</p><formula xml:id="formula_6">v 0 ∈ V v 1 ∈ adj(v 0 ) &amp;&amp; v 1 &lt; v 0 v 2 ∈ adj(v 0 ) &amp;&amp; v 2 &lt; v 1 v 3 ∈ adj(v 1 ) ∩ adj(v 2 ) &amp;&amp; v 3 &lt; v 0 u 0 u 2 u 3 u 1 matching order: {{}, {0}, {0}, {1,2}} symmetry order: {-,v 1 &lt; v 0 , v 2 &lt; v 1 , v 3 &lt; v 0 } (a) 4-cycle v 0 ∈ V v 1 ∈ adj(v 0 ) &amp;&amp; v 1 &lt; v 0 v 2 ∈ adj(v 0 ) ∩ adj(v 1 ) v 3 ∈ adj(v 0 ) ∩ adj(v 1 ) &amp;&amp; v 3 &lt; v 2 u 0 u 3 u 1 u 2</formula><p>matching order: {{}, {0}, {0,1}, {0,1}} symmetry order: {</p><formula xml:id="formula_7">-, v 1 &lt; v 0 , -, v 3 &lt; v 2 } (b) diamond v 0 ∈ V v 1 ∈ adj(v 0 ) &amp;&amp; v 1 &lt; v 0 v 2 ∈ adj(v 0 ) ∩ adj(v 1 ) v 3 ∈ adj(v 2 ) u 0 u 3 u 2 u 1</formula><p>matching order: {{}, {0}, {0,1}, {2}} symmetry order: {-, v 1 &lt; v 0 , -, -} (c) tailed-triangle </p><formula xml:id="formula_8">2 v 0 ∈ V pruneBy (∞, {}) 3 v 1 ∈ v 0 .N pruneBy (v 0 .id , {}) 4 v 2 ∈ v 0 .N pruneBy (v 1 .id , {}) 5 v 3 ∈ v 2 .N pruneBy (v 0 .id , {v 1 })<label>6</label></formula><p>embedding :</p><formula xml:id="formula_9">7 emb 0 := v 0 8 emb 1 := emb 0 + v 1 9 emb 2 := emb 1 + v 2 10 emb 3 := emb + v 3 A. IR Format</formula><p>The IR consists of a vertex section and an embedding section. The vertex section describes how each vertex is extended and which vertices can be valid candidates for that extension step. For example, line 3 shows v 1 is extended from v 0 . The candidates are confined by the pruneBy primitive, which accepts 2 parameters: a vid upper-bound and connected ancestor set. The vid upper-bound defines the upper bound of candidate vertex ID. The connected ancestor set contains all the vertices in the current embedding that must be connected to the candidate vertex. Only candidate vertices that conform to both constraints can be added to the embedding. For example, in line 5 of Listing 1, v 3 's ID must be smaller than v 0 's ID, and v 3 must be connected to v 1 . The embedding section describes the dependencies between partially matched embeddings given by the matching order. For instance, when mining 4-cycle, we will find the following partial embeddings in order: singlevertex embedding (emb 0 ), edge (emb 1 ), wedge (emb 2 ) and 4cycle (emb 3 ). The embedding at the tail of the chain (emb 3 ) fully matches the pattern. Each link in a dependency chain is labeled with a + primitive which defines the vertex-adding action performed to extend the embedding. For example, line 9 shows that emb 1 is extended from emb 0 by adding v 1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Multi-pattern Support</head><p>For a single-pattern problem, it is straightforward to use a compiler to generate the IR code from the matching order and symmetry order. In case of multiple patterns, each pattern needs one dependency chain. Since multiple chains may contain a common part, we merge multiple chains using a dependency tree whenever possible. This way, the embedding section can express the control flow of mining multiple patterns simultaneously, with common search paths merged to avoid repetitive enumeration. Fig. <ref type="figure" target="#fig_8">11 (b</ref>) and (c) shows the execution plans of diamond and tailed-triangle. We find that for both patterns, v 0 , v 1 and v 2 are from the same Listing 2: IR code for finding diamond and tailed-triangle 11 vertex : </p><formula xml:id="formula_10">12 v 0 ∈ V pruneBy (∞, {}) 13 v 1 ∈ v 0 .N pruneBy (v 0 .id , {}) 14 v 2 ∈ v 0 .N pruneBy (∞, {v 1 }) 15 v 31 ∈ v 0 .N pruneBy (v 2 .id , {v 1 }) 16 v 32 ∈ v 2 .N</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Hints for Data Management</head><p>Different patterns can be optimized with different frontier list memoization techniques. For example, in the diamond pattern in Fig. <ref type="figure" target="#fig_8">11 (b)</ref>, v 2 and v 3 are from the same candidate set adj(v 0 ) ∩ adj(v 1 ), and the only difference is that v 3 &lt; v 2 . If we can memoize the result of adj(v 0 ) ∩ adj(v 1 ) in the PE-local cache, we can avoid repetitive computation. When analyzing the pattern, the compiler identifies which results are reusable and thus should be memoized, and indicates the hardware using a flag in the IR code. Similarly, the compiler also embeds information in the IR about how to manage the c-map. We describe it in Section VI.</p><p>In addition, the compiler does special optimization when detecting k-clique at pattern analysis, since symmetry breaking can be done by the orientation technique, i.e., converting the undirected data graph G into a directed acyclic graph (DAG) <ref type="bibr" target="#b15">[16]</ref>. The idea is to establish an order between the endpoints of every edge in G, which converts the originally undirected edge into directed. A commonly used approach is to enforce the vertex with smaller degree points to the vertex with larger degree. Vertex ID is used when there is a tie. After giving orientation, no symmetry order checking is needed at runtime. The preprocessing time is usually less than 1% of the execution time, and once converted, the graph can be used for any k-CL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Pattern-Aware Execution Flow</head><p>With execution model in Fig. <ref type="figure" target="#fig_7">10</ref>, FlexMiner can mine any pattern of interest by customizing order and constraints at each level. The customization is achieved simply by downloading the IR code to the hardware. In the example of 4-cycle in Fig. <ref type="figure" target="#fig_8">11 (a)</ref>, when FlexMiner extends a wedge to a 4-cycle in depth 3 (executing emb 3 := emb 2 + v 3 ), it refers to the primitive v 3 ∈ v 2 .N pruneBy (v 0 .id, {v 1 }) in the vertex section. This defines the extender to be v 2 (i.e., the third vertex in the ancestor stack), and the constraints include that {v 3 &lt; v 0 } and v 3 must be connected to v 1 .</p><p>For single-pattern mining, the control flow (dependencies between partial embeddings) is a sequence, so the execution model can simply use depth d as the index into the vertex section to retrieve the primitives, without using the embedding section. For multi-pattern problems, however, the embedding section will be used to handle the divergence of the control flow due to different execution plans of the multiple patterns. For example, in line 23 of Listing 2, two branches (emb 31 and emb 32 ) are explored sequentially, i.e., the DFS walk steps into level 3 with emb 31 first; when search finished in level 3 and backtracks to level 2, it steps into level 3 again with emb 32 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. HARDWARE SUPPORT FOR CONNECTIVITY MAP</head><p>In this section we explain our proposed hardware support for c-map optimization in FlexMiner. First, let's look into the details about how c-map is updated and queried at runtime.</p><p>A c-map can be constructed incrementally each time an embedding is extended with a new vertex. As shown in Fig. <ref type="figure" target="#fig_9">12</ref>, <ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b2">3]</ref>. The c-map is empty at the beginning. When vertex 1 is added to the current embedding, all neighbors of vertex 1 are inserted into the map (), and the value of these entries are all '001', indicating they are connected to vertex 1. When vertex 2 is added to the embedding, all neighbors of vertex 2 are inserted () with value '010', indicating they are connected to vertex 2. Since vertex 4 and 5 already exist, their values are updated to '011', indicating they are connected to both vertex 1 and 2. Since vertex 2 is in the embedding, the entry for vertex 2 in the map become useless (no need to update). Similarly, when vertex 3 is added to the embedding, the neighbors of vertex 3 are inserted or updated (). Note that c-map is selfcleaned during backtracking, i.e. the connectivity information is resumed in a stack fashion. Therefore when a task is completed, all entries in c-map are invalidated.</p><formula xml:id="formula_11">the current embedding is [] → [1] → [1, 2] → [1,</formula><p>When extending the current embedding with one more vertex (e.g., vertex 7), we want to check the connectivity of vertex 7 with vertex 1, 2, and 3. By querying the map with the key '7', we get the bitset '101', indicating vertex 7 is connected with vertex 1 and vertex 3, but not vertex 2. If the lookup key does not exist in the map, it means the vertex is not connected to any of the vertices in the current embedding. Orange entries are updated. Grey entries are ones became useless.</p><p>Previous work uses a vector <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b20">21]</ref> to implement a c-map in software. Instead of keeping only visited vertices in the map, the vector pre-allocates |V | entries, one per vertex in G. In such implementations, c-map queries are served in constant time, which leads to an average of 2.3× speedup for k-CL <ref type="bibr" target="#b20">[21]</ref>. However, vector c-map only work well in a restricted setting. First, such implementation is not scalable as the size of the data graph G. For example when counting the 4-cliques in a graph of a billion vertices of maximum degree 50, the working set can be bound by size 50, but the vector implementation will have to allocate a vector of size one billion (GB) per thread. Moreover, the L1 cache is particularly inefficient for such structures: each cache line holding c-map information may hold only a single byte of useful information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Hardware c-map Design</head><p>We propose a hardware c-map which keeps the information in a compact form and provides fast accesses and low hardware complexity. We use a simplified linear probing scheme: the insertions and lookups are the same, but deletion is simpler than the conventional linear probing. In our c-map, to delete an entry, we simply find the entry and invalidate it (i.e., set the value to 0). This is functionally correct due to two key observations in the GPM algorithms: (1) updates on c-map work in a bulk fashion (a sequence of neighbors), thus the deletion of the entries inserted at the same level is done atomically (no lookups before all removed); (2) we never delete a key that does not exist in the map, thus the deletion operation will always find the entry and remove it.</p><p>To probe faster, we partition the c-map into m banks, allowing parallel probes to m successive entries. We prototype our hardware c-map design in Bluespec and test it with m=4 and a bank size of 512 lines of 5 bytes: 4 bytes of the key, one byte of the value (for a total of 2K entries). These parameters led to a design successfully synthesized for FPGA at 200MHz and ASIC at 1.3GHz. We empirically observe that the map should be properly sized (&gt;4kB) to keep its occupancy below 75%, thus maintain a low expected access latency. In our design, most accesses take only a single cycle.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Support for c-map Space Management</head><p>Different patterns use the connectivity information differently. For 4-cycle, line 5 in Listing 1 shows that v 3 is searched from v 2 's neighbor list, and is checked if it is  connected to v 1 . The compiler annotates that only v 1 's connectivity information is used. Therefore, when mining 4-cycle, we only need to insert v 1 's neighbors to c-map. Besides, in line 5 there is a vertex upper bound v 0 , thus our compiler prevents any v 1 's neighbor with VID larger than v 0 from being inserted into c-map, reducing the number of entries in c-map further. Finally, we provide a fall-back mechanism to guarantee correct execution when c-map overflows. To decide when to fall back, the size of the neighbor list (i.e., the degree) is obtained before bringing the list, and then we compute how each vertex extension influence the c-map memory footprint. Hence, we dynamically estimate the occupancy of the c-map and keep it below our chosen threshold.</p><p>When we detect that estimated c-map footprint is above the threshold, the fall-back mechanism is activated, i.e., the pruner switches to invoke SIU/SDU instead of querying c-map. For example, for 4-cycle, once c-map allocation for v 1 's neighbors failed, at level 2, instead of extending v 2 and checking connectivity with v 1 , the pruner sends requests of v 1 's and v 2 's edgelists to the L1 cache, and the two edgelists are sent to SIU to compute the intersection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. EVALUATION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Experimental Setup</head><p>Benchmarks and Graph Datasets: We test 4 GPM applications discussed in Section II-A, i.e., TC, k-CL, SL, k-MC. As listed in Table <ref type="table" target="#tab_4">I</ref>, we use all the input graphs used in Gramer <ref type="bibr" target="#b89">[90]</ref>, except the two smallest graphs, which provide much higher speedups over software baseline and distort the results. All input graphs are symmetric, have no self-loops, and have no duplicated edges. We represent the input graphs in the compressed sparse row (CSR) format. The neighbor list of each vertex is sorted by ascending vertex ID. Baseline: We evaluate the efficiency of FlexMiner against state-of-the-art software GPM systems, AutoMine <ref type="bibr" target="#b57">[58]</ref> and GraphZero <ref type="bibr" target="#b56">[57]</ref>, as well as the existing hardware GPM accelerator, Gramer <ref type="bibr" target="#b89">[90]</ref>. We are unable to compare FlexMiner with TrieJax because their simulator has not been released and there are no absolute numbers in the paper <ref type="bibr" target="#b45">[46]</ref>. Au-toMine and GraphZero are run on a 10-core Intel i9-7900X CPU (3.30GHz, Turbo 4.3GHz, 13.75 MB LLC) with 64GB DRAM. We report execution time on CPU as an average of 3 runs. Gramer was evaluated on a Xilinx Alveo U250 card with a XCU250 FPGA chip (1.68M LUTs, 3.37M registers, and 11.8MB BRAM) and four 16GB DDR4 memories.</p><p>Table <ref type="table" target="#tab_6">II</ref> lists the running time (seconds) of Gramer (FPGA), AutoMine (CPU) and GraphZero (CPU). Note that Gramer results are reported from their paper <ref type="bibr" target="#b89">[90]</ref>, and the Yo graph  , regardless of all the hardware specialization that Gramer did. This speedup is mainly due to the pattern awareness in GraphZero. Note that Gramer does outperform pattern-oblivious software GPM frameworks RStream <ref type="bibr" target="#b83">[84]</ref> and Fractal <ref type="bibr" target="#b24">[25]</ref>, as demonstrated in the Gramer paper <ref type="bibr" target="#b89">[90]</ref>. However, the pattern-awareness in AutoMine significantly prunes the search space, and makes it orders-ofmagnitude faster <ref type="bibr" target="#b57">[58]</ref> than RStream and Fractal. GraphZero adds symmetry breaking on top of AutoMine, and is thus faster than AutoMine. Therefore we use GraphZero as our CPU baseline, and only compare FlexMiner with GraphZero in the following evaluation. Note that the FlexMiner compilation time is similar to GraphZero, which is negligible compared to the mining execution time, since P is much smaller than G.</p><p>FlexMiner Simulation and Configurations: For performance evaluation, we developed a custom cycle-accurate simulator, which models the microarchitecture behavior of each module described in Fig. <ref type="figure">8</ref>. We conservatively use 1.3GHz PE frequency (2.38GHz used in TrieJax), 32kB private cache and 4MB shared cache. When space is not available in private scratchpad, FlexMiner uses its fallback mechanism (i.e. with SIU and SDU). We only report simulation results for benchmarks completed within 2 seconds by GraphZero in Table <ref type="table" target="#tab_6">II</ref> due to the extremely slow cycle-accurate simulation. The simulator is integrated with DRAMsim3 <ref type="bibr" target="#b52">[53]</ref> to simulate the cycle-accurate behavior of accesses to the offchip memory, which is simulated as 64GB of DDR4-2666 DRAM with four channels (the same as our CPU baseline). We also integrated BookSim <ref type="bibr" target="#b62">[63]</ref> for NoC, and a standard cycle-accurate non-inclusive cache model for L2 cache. Note that the frontier list memoization (described in Section V-C) is always enabled in FlexMiner for a fair comparison with GraphZero, which has this technique implemented in software. We implement our proposed PE using Bluespec, generate Verilog, and synthesize the logic using Synopsys Design Compiler and Silvaco's 15nm Open-Cell Library <ref type="bibr" target="#b0">[1]</ref>. We give the synthesis tool an operating voltage of 0.8V and achieve a target clock period of 0.75ns, putting our design comfortably at 1.3GHz. We estimate area numbers of the SRAMs in a PE using CACTI <ref type="bibr" target="#b1">[2]</ref>. We use the 22nm technology node (22nm is the closest from 15nm available in CACTI). The overall area of a PE in FlexMiner is only 0.18mm 2 , while the area of an Intel SkyLake CPU core (14nm) is about 15mm 2 <ref type="bibr" target="#b45">[46]</ref>.</p><p>In the following evaluation, we only focus on ASIC design of FlexMiner. We first compare FlexMiner without c-map to the CPU baseline, GraphZero, to show the benefit of PE specialization and massive multithreading. We then evaluate FlexMiner with different sizes of c-map, to show the benefit of c-map and find out the reasonable size to use for the c-map. We change the number of PEs from 1 to 64 to demonstrate a more detailed performance scaling. Lastly NoC traffic is measured to show the impact of c-map on reducing the memory requests, i.e., memoization reduces accesses to the edgelists of G.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Performance (no-cmap) Comparison with the Baseline</head><p>Fig. <ref type="figure" target="#fig_2">13</ref> compares FlexMiner (without c-map) performance with 20-thread GraphZero. As illustrated, FlexMiner with 10-PE already outperform GraphZero for most cases, although the clock frequency is much lower than CPU. This is due to the fact that the specialized execution units (i.e., SIU and SDU) in the PE are more efficient than general purpose CPU cores for set operations. There exists other algorithms <ref type="bibr" target="#b58">[59,</ref><ref type="bibr" target="#b63">64]</ref> for set intersection, but we use the same merge-based algorithm as that is used in GraphZero to make fair comparison with the CPU baseline. Note that same as GraphZero, FlexMiner supports the memoization of the frontier list, which avoids recomputation of the set intersections for patterns that have reusable intermediate results (e.g., k-clique and diamond). The support for this memoization in FlexMiner makes sure that it has the same algorithmic efficiency as software.</p><p>Since the performance improvement mostly comes from accelerating the set operations, the speedup for a specific case depends on the portion of memory stalls in the total cycles. The benchmark benefits most from PE specialization when it spends most of the time on computation. In contrast, if the benchmark mostly waits for memory requests, the speedup would be marginal. For example, TC has the least computation in all applications, and Pa and Yo are relatively large datasets than As and Mi, which leads to poor cache behavior (we observe 65.9% and 36.3% L2 cache miss rates for Pa and Yo respectively) and likely more time spent on memory accesses. Both Lj and Yo are large graphs, but Lj contains two times more triangles than Yo. Therefore, TC for Pa and Yo on FlexMiner is slower than the baseline.</p><p>Since each PE has much simpler logic and smaller private cache than a general purpose core in CPU (CPU has 32kB L1D and 1MB L2), we can put more PEs within the same area. By scaling the number of PEs from 10-PE to 40-PE, FlexMiner achieves even more speedups, thanks to the embarrassing amount of parallelism in these GPM applications. On average, FlexMiner with 10-PE, 20-PE and 40-PE outperform the CPU baseline by 1.56×, 2.93×, and 5.15×, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Performance Impact of the c-map</head><p>We evaluate the performance impact of the c-map in Fig. <ref type="figure" target="#fig_10">14</ref>. We use different sizes of c-map from 1kB to 16kB. cmap-unlimited is the c-map with unlimited size, i.e., it represents the performance upper bound of c-map design (which is impractical). As shown, cmap-unlimited achieves significant performance improvement (up to 5.3×) over no-cmap for 4-cycle, with an average speedup of 3.0×. This is expected as there is no frontier list reuse in 4-cycle while c-map is reused heavily. As a proof, the read ratios, i.e., the percentage of reads of all accesses to c-map, are 93%, 98% and 86% in mining 4-cycle in As, mico and Pa. These high ratios are translated directly to speedups in 4-cycle. However, for k-CL and diamond where memoizing the frontier list is already quite effective, adding c-map on top of it does not bring as much performance improvement as it does for 4-cycle. For TC, there is no frontier list reuse, and the c-map reuses are fewer than those in 4-cycle. The read-write ratios for TC on As, mico and Pa are 90% and 93% and 74%. This reduced reuse (compared to 4-cycle), ends up giving a speed up between 4-cycle and k-CL.</p><p>We also observe that Mi constantly obtains good speedups across different applications. This is mainly due to the fact that Mi is the most dense graph in Table <ref type="table" target="#tab_4">I</ref> (with an average degree of 21), and therefore there exists abundant c-map reuses (also demonstrated by the high read ratio of Mi).</p><p>Meanwhile, we observe that for most of the benchmarks, a 4kB c-map already captures most of the performance benefit of cmap-unlimited. This is because (1) the maximum degree d of G is small (see Table <ref type="table" target="#tab_4">I</ref>) compared to the graph size (e.g., although with 57M edges, Yo has a d of 4,017), and high-degree vertices are rare due to power-law distribution;</p><p>(2) c-map is well utilized with our compiler heuristics in Section VI-B. In practice, we choose a c-map size of 8kB for the default FlexMiner design to support larger graphs and patterns. This configuration achieves average speedups of 2.28×, 4.24× and 7.29×, over the CPU baseline, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Large Graphs and Large Patterns</head><p>We evaluate a larger graph Or with TC (3-clique). Our simulation shows that 20-PE FlexMiner achieves 2.5× speedup over GraphZero-20T. Due to the simulation speed, we can not finish running larger graphs using our simulator, but FlexMiner does support larger graphs as long as they fits in memory. To support graphs larger than memory capacity, we can add graph partitioning support <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b39">40,</ref><ref type="bibr" target="#b79">80]</ref>     We evaluate large patterns on Pa using k-CL with k ∈ <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b8">9]</ref>. 20-PE FlexMiner outperforms GraphZero by 1.7× to 1.9×. For a pattern of size k, c-map needs 32 bits for the key and k − 2 bits for the value in each entry. We currently use 8bit for the c-map value, and thus FlexMiner can fully benefit from c-map for patterns within 10-vertex. For patterns beyond size 10, c-map is partially used, i.e. for n-bit c-map value, FlexMiner uses SIU/SDU when DFS level above n − 2 unless there is an early c-map overflow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Scalability and NoC Traffic</head><p>Fig. <ref type="figure" target="#fig_12">15</ref> illustrates the FlexMiner with 8kB c-map performance as the number of PE increases from 1 to 64. Generally we observe linear scaling with more PEs, although different applications and datasets have different impact on the scaling factor. TC is the simplest and least irregular application among all. Therefore, TC performance scaling is almost perfect. However, As is the smallest dataset, and TC on As scales worse than the other two datasets because of much fewer tasks (i.e. parallelism). 4-CL on As scales better than TC on As likely due to more computation existed in 4-CL. On average, 64-PE FlexMiner achieves 10.60× speedup over GraphZero-20T.</p><p>In Fig. <ref type="figure" target="#fig_13">16</ref> we measure NoC traffic, i.e., the number of memory requests sent from the PEs to the NoC, to show the impact of c-map on memory subsystem. For the benchmarks which benefit from c-map, i.e. TC, 4-cycle and diamond, the NoC traffic is significantly reduced by introducing the c-map. For example, 4kB c-map reduces nearly half of the NoC traffic for 4-cycle on As. For k-CL, the NoC traffic stays the same, because the frontier list already cut down the same amount of memory requests for both no-cmap and c-map cases. As a result, the performance gain for 4-CL is less impressive by increasing the c-map size. However, we observe that Mi achieves close to 2× speedup in Fig. <ref type="figure" target="#fig_10">14</ref>, which is purely achieved by c-map reducing set operations.</p><p>In summary, we demonstrate that FlexMiner achieves significant speedup over the CPU baseline, thanks to the PE specialization, massive multithreaing, and the support for memoization using c-map. More specifically, the performance speedup of 40-PE without c-map over CPU baseline is attributed to PE specialization (3.04×) and multithreading (1.76×). The adoption of c-map with a tiny 8kB scratchpad further improves VIII. RELATED WORK Software GPM Systems: Arabesque <ref type="bibr" target="#b81">[82]</ref>, Fractal <ref type="bibr" target="#b24">[25]</ref> and G-Miner <ref type="bibr" target="#b12">[13]</ref> are distributed GPM systems, while RStream <ref type="bibr" target="#b83">[84]</ref>, Kaleido <ref type="bibr" target="#b94">[95]</ref>, Pangolin <ref type="bibr" target="#b15">[16]</ref>, AutoMine <ref type="bibr" target="#b57">[58]</ref>, GraphZero <ref type="bibr" target="#b56">[57]</ref> and Sandslash <ref type="bibr" target="#b14">[15]</ref> are GPM systems targeting single-machine. There are also graph querying systems like Graphflow <ref type="bibr" target="#b46">[47,</ref><ref type="bibr" target="#b58">59]</ref> and EmptyHeaded <ref type="bibr" target="#b3">[4]</ref> which only solve single-pattern edgeinduced GPM problems. Software GPM systems improve programmability, but achieves limited performance as we explained in Section III. Hand-written Software GPM Applications: There are numerous hand-optimized GPM applications targeting various platforms, for TC <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b39">40,</ref><ref type="bibr" target="#b41">42,</ref><ref type="bibr" target="#b66">67,</ref><ref type="bibr" target="#b67">68,</ref><ref type="bibr" target="#b74">75,</ref><ref type="bibr" target="#b78">79,</ref><ref type="bibr" target="#b84">85,</ref><ref type="bibr" target="#b90">91]</ref>, k-CL <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b20">21]</ref>, k-MC <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b68">69]</ref>, SL <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b44">45,</ref><ref type="bibr" target="#b48">49,</ref><ref type="bibr" target="#b49">50,</ref><ref type="bibr" target="#b50">51,</ref><ref type="bibr" target="#b54">55,</ref><ref type="bibr" target="#b71">72,</ref><ref type="bibr" target="#b72">73,</ref><ref type="bibr" target="#b76">77,</ref><ref type="bibr" target="#b77">78,</ref><ref type="bibr" target="#b82">83]</ref>, and FSM <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b42">43,</ref><ref type="bibr" target="#b79">80,</ref><ref type="bibr" target="#b80">81,</ref><ref type="bibr" target="#b85">86]</ref>. They employ sophisticated optimizations to improve algorithmic or/and architectural efficiency. However, they lack generality and thus require a lot more programming efforts than GPM systems. Meanwhile, our accelerator can achieve better performance than these hand-written applications on CPU or GPU. Software Systems and Hardware Accelerators for Graph Analytics: Lots of graph processing frameworks have been proposed <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b53">54,</ref><ref type="bibr" target="#b55">56,</ref><ref type="bibr" target="#b64">65,</ref><ref type="bibr" target="#b93">94]</ref> to improve programmability for large-scale graph processing but have limited support for subgraph mining tasks. Many graph analytics accelerators <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b37">38,</ref><ref type="bibr" target="#b61">62,</ref><ref type="bibr" target="#b65">66,</ref><ref type="bibr" target="#b75">76,</ref><ref type="bibr" target="#b86">87,</ref><ref type="bibr" target="#b88">89,</ref><ref type="bibr" target="#b92">93,</ref><ref type="bibr" target="#b95">96]</ref> have been proposed. They can improve performance over software systems when solving graph analytics problems. However, it has been demonstrated that graph analytics accelerators yield poor performance for GPM applications <ref type="bibr" target="#b45">[46]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IX. CONCLUSION</head><p>GPM has been used widely in many real-world, computeintensive applications. We present a pattern-aware hardware accelerator for GPM, which provides much higher performance than existing software and hardware accelerated solutions. Scalability of our design allows us to exploit massive parallelism in GPM by increasing the number of processing elements specifically designed for pattern-aware GPM. FlexMiner compiler automates the generation of execution plan for the hardware, which achieves pattern-awareness without any more programming effort than software GPM frameworks. It also provides hardware support for the memoization techniques, making a tradeoff between work efficiency and parallelism. Our evaluation demonstrates significant speedups over the state-of-the art software framework on CPU.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 :</head><label>1</label><figDesc>Fig. 1: Graph pattern mining example. The pattern P is a triangle, and 3 triangles are found in the data graph G.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 :</head><label>2</label><figDesc>Fig. 2: An overview of the FlexMiner software/hardware co-designed system.</figDesc><graphic url="image-1.png" coords="2,464.60,59.18,75.40,55.60" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 :</head><label>3</label><figDesc>Fig. 3: 3-vertex (left) and 4-vertex (right) motifs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 6 :</head><label>6</label><figDesc>Fig. 6: Generating symmetry order for 4-cycle.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 7 :</head><label>7</label><figDesc>Fig. 7: Scalilibity of k-CL on 12 dual-threaded cores with maximum DRAM bandwidth of 100GB/s.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 10 :</head><label>10</label><figDesc>Fig. 10: The execution flow of FlexMiner (single-pattern).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 11 :</head><label>11</label><figDesc>Fig. 11: Execution plans for finding edge-induced 4-cycle, diamond and tailed-triangle. Errors in this figure fixed. Listing 1: IR code for 4-cycle</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 12 :</head><label>12</label><figDesc>Fig. 12: An example of c-map. Green entries are newly inserted.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 14 :</head><label>14</label><figDesc>Fig. 14: FlexMiner performance using c-map with different sizes. All with 20-PE and normalized to FlexMiner without c-map.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 15 :</head><label>15</label><figDesc>Fig. 15: FlexMiner with 8kB c-map performance scaling as the number of PEs increases from 1 to 64 (normalized to one-PE).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 16 :</head><label>16</label><figDesc>Fig.16: Total number of NoC traffic (i.e., L2 accesses) and DRAM accesses. cy: 4-cycle, di: diamond the performance by 1.36× (up to 4.82× for some patterns), which is a reasonable tradeoff for the hardware design.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>TABLE I :</head><label>I</label><figDesc>Input graphs (symmetric, no loops or duplicate edges)</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>TABLE II :</head><label>II</label><figDesc>Comparing baseline systems: Gramer (4-thread 8-PU FPGA), AutoMine (20-thread CPU) and GraphZero (20thread CPU). Bold numbers are the fastest of each row. used in Gramer (|V |=4.6M, |E|=44.0M) is a subset of ours (|V |=7.1M, |E|=57.1M). SL is not evaluated because it is not supported in Gramer. As shown in the table, GraphZero is almost always faster than Gramer except 5-CL on Lj, with an average speedup of 8.3×</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>in our framework.</figDesc><table><row><cell>Speedup over GraphZero</cell><cell>0 2 4 6 8 10 12</cell><cell>TC As Mi Pa Yo Lj As Mi Pa Yo As Pa As Mi Pa As Mi Pa Yo As Mi Pa Yo 4-CL 5-CL SL-4cycle SL-diamond 3-MC 15 26 GraphZero-20T FlexMiner-10PE FlexMiner-20PE FlexMiner-40PE</cell></row><row><cell></cell><cell cols="2">Fig. 13: FlexMiner (without c-map) performance compared with 20-thread GraphZero on CPU.</cell></row><row><cell>Speedup over no-cmap</cell><cell>1 2 3 4 5 6</cell><cell>TC As Mi Pa Yo Lj As Mi Pa Yo As Pa As Mi Pa As Mi Pa Yo As Mi Pa 4-CL 5-CL SL-4cycle SL-diamond 3-MC no-cmap 1kB-cmap 4kB-cmap 8kB-cmap 16kB-cmap unlimited-cmap</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>X. ACKNOWLEDGEMENTS</head><p>The research is funded by Samsung Semiconductor (GRO grants), NSF grant CCF-1725303, and NSFC grant 61802416.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<ptr target="https://si2.org/open-cell-library/" />
		<title level="m">Open-Cell Library and 45nm FreePDK</title>
				<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">CACTI: An integrated cache and memory access time, cycle time, area, leakage, and dynamic power model</title>
		<ptr target="https://github.com/HewlettPackard/cacti" />
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Scalemine: Scalable parallel frequent subgraph mining in a single large graph</title>
		<author>
			<persName><forename type="first">E</forename><surname>Abdelhamid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Abdelaziz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kalnis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Khayyat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Jamour</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis, ser. SC &apos;16</title>
				<meeting>the International Conference for High Performance Computing, Networking, Storage and Analysis, ser. SC &apos;16<address><addrLine>Piscataway, NJ, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="page">12</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Emptyheaded: A relational engine for graph processing</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">R</forename><surname>Aberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lamb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Nötzli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Olukotun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ré</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2017-10">Oct. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Enumerating subgraph instances using map-reduce</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">N</forename><surname>Afrati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Fotakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2013 IEEE 29th International Conference on Data Engineering (ICDE)</title>
				<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="62" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Efficient graphlet counting for large networks</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">K</forename><surname>Ahmed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Neville</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Rossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Duffield</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDM</title>
				<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Biomolecular network motif counting and discovery by color coding</title>
		<author>
			<persName><forename type="first">N</forename><surname>Alon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Dao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Hajirasouliha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Hormozdiari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sahinalp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">13</biblScope>
			<biblScope unit="page" from="241" to="249" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Locality exists in graph processing: Workload characterization on an ivy bridge server</title>
		<author>
			<persName><forename type="first">S</forename><surname>Beamer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Asanovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Patterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 IEEE International Symposium on Workload Characterization, ser. IISWC &apos;15</title>
				<meeting>the 2015 IEEE International Symposium on Workload Characterization, ser. IISWC &apos;15<address><addrLine>USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="56" to="65" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Efficient semistreaming algorithms for local triangle counting in massive graphs</title>
		<author>
			<persName><forename type="first">L</forename><surname>Becchetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Boldi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Castillo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gionis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th ACM SIGKDD international conference on Knowledge discovery and data mining</title>
				<meeting>the 14th ACM SIGKDD international conference on Knowledge discovery and data mining</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="16" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">CECI: Compact Embedding Cluster Index for Scalable Subgraph Matching</title>
		<author>
			<persName><forename type="first">B</forename><surname>Bhattarai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">H</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2019 International Conference on Management of Data, ser. SIGMOD &apos;19</title>
				<meeting>the 2019 International Conference on Management of Data, ser. SIGMOD &apos;19<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="1447" to="1462" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Efficient subgraph matching by postponing cartesian products</title>
		<author>
			<persName><forename type="first">F</forename><surname>Bi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 International Conference on Management of Data, ser. SIGMOD &apos;16</title>
				<meeting>the 2016 International Conference on Management of Data, ser. SIGMOD &apos;16<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1199" to="1214" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Gaas-x: Graph analytics accelerator supporting sparse data representation using crossbar architectures</title>
		<author>
			<persName><forename type="first">N</forename><surname>Challapalle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rampalli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Chandramoorthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Swaminathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sampson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Narayanan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2020 ACM/IEEE 47th Annual International Symposium on Computer Architecture (ISCA)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="433" to="445" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">G-miner: An efficient task-oriented graph mining system</title>
		<author>
			<persName><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Thirteenth EuroSys Conference, ser. EuroSys &apos;18</title>
				<meeting>the Thirteenth EuroSys Conference, ser. EuroSys &apos;18<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Adaptive Cache Management for Energy-Efficient GPU Computing</title>
		<author>
			<persName><forename type="first">X</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L.-W</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">I</forename><surname>Rodrigues</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-M</forename><surname>Hwu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 47th Annual IEEE/ACM International Symposium on Microarchitecture, ser. MICRO-47</title>
				<meeting>the 47th Annual IEEE/ACM International Symposium on Microarchitecture, ser. MICRO-47<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="343" to="355" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Sandslash: A Two-Level Framework for Efficient Graph Pattern Mining</title>
		<author>
			<persName><forename type="first">X</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Dathathri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Hoang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pingali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 35th ACM International Conference on Supercomputing, ser. ICS &apos;21</title>
				<meeting>the 35th ACM International Conference on Supercomputing, ser. ICS &apos;21</meeting>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Pangolin: An Efficient and Flexible Graph Mining System on CPU and GPU</title>
		<author>
			<persName><forename type="first">X</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Dathathri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pingali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Endow</title>
				<meeting>VLDB Endow</meeting>
		<imprint>
			<date type="published" when="2020-08">Aug. 2020</date>
			<biblScope unit="volume">13</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Dataset for statistics and social network of youtube videos</title>
		<author>
			<persName><forename type="first">X</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Dale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<ptr target="http://netsg.cs.sfu.ca/youtubedata/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Arboricity and subgraph listing algorithms</title>
		<author>
			<persName><forename type="first">N</forename><surname>Chiba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Nishizeki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="210" to="223" />
			<date type="published" when="1985-02">Feb. 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Predicting protein function by frequent functional association pattern mining in protein interaction networks</title>
		<author>
			<persName><forename type="first">Y.-R</forename><surname>Cho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Technology in Biomedicine</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="30" to="36" />
			<date type="published" when="2010-01">Jan. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Foregraph: Exploring large-scale graph processing on multi-fpga architecture</title>
		<author>
			<persName><forename type="first">G</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM/SIGDA International Symposium on Field-Programmable Gate Arrays</title>
				<meeting>the 2017 ACM/SIGDA International Symposium on Field-Programmable Gate Arrays</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="217" to="226" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Listing k-cliques in sparse real-world graphs*</title>
		<author>
			<persName><forename type="first">M</forename><surname>Danisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Balalau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sozio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2018 World Wide Web Conference, ser. WWW &apos;18. Republic and Canton of</title>
				<meeting>the 2018 World Wide Web Conference, ser. WWW &apos;18. Republic and Canton of<address><addrLine>Geneva, Switzerland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="589" to="598" />
		</imprint>
	</monogr>
	<note>International World Wide Web Conferences Steering Committee</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Frequent substructure-based approaches for classifying chemical compounds</title>
		<author>
			<persName><forename type="first">M</forename><surname>Deshpande</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kuramochi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Wale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Karypis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Knowledge and Data Engineering</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1036" to="1050" />
			<date type="published" when="2005-08">Aug 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Storing semistructured data with stored</title>
		<author>
			<persName><forename type="first">A</forename><surname>Deutsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fernandez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1999 ACM SIGMOD international conference on Management of data</title>
				<meeting>the 1999 ACM SIGMOD international conference on Management of data</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="431" to="442" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Theoretically efficient parallel graph algorithms can be fast and scalable</title>
		<author>
			<persName><forename type="first">L</forename><surname>Dhulipala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Blelloch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Shun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th on Symposium on Parallelism in Algorithms and Architectures, ser. SPAA &apos;18</title>
				<meeting>the 30th on Symposium on Parallelism in Algorithms and Architectures, ser. SPAA &apos;18<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="393" to="404" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Fractal: A general-purpose graph pattern mining system</title>
		<author>
			<persName><forename type="first">V</forename><surname>Dias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H C</forename><surname>Teixeira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Guedes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Meira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Parthasarathy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2019 International Conference on Management of Data, ser. SIGMOD &apos;19</title>
				<meeting>the 2019 International Conference on Management of Data, ser. SIGMOD &apos;19<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="1357" to="1374" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Preference-based configuration of web page content</title>
		<author>
			<persName><forename type="first">C</forename><surname>Domshlak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Genaim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Brafman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">14th European Conference on Artificial Intelligence (ECAI 2000), Configuration Workshop</title>
				<meeting><address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="19" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Grami: Frequent subgraph and pattern mining in a single large graph</title>
		<author>
			<persName><forename type="first">M</forename><surname>Elseidy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Abdelhamid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Skiadopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kalnis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Endow</title>
				<meeting>VLDB Endow</meeting>
		<imprint>
			<date type="published" when="2014-03">Mar. 2014</date>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="517" to="528" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Domain-specialized cache management for graph analytics</title>
		<author>
			<persName><forename type="first">P</forename><surname>Faldu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Diamond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Grot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2020 IEEE International Symposium on High Performance Computer Architecture (HPCA)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="234" to="248" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A puzzle concerning triads in social networks: Graph constraints and the triad census</title>
		<author>
			<persName><forename type="first">K</forename><surname>Faust</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Social Networks</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="221" to="233" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Automatic large scale generation of internet pop level maps</title>
		<author>
			<persName><forename type="first">D</forename><surname>Feldman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Shavitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE GLOBECOM 2008-2008 IEEE Global Telecommunications Conference</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Triad count statistics</title>
		<author>
			<persName><forename type="first">O</forename><surname>Frank</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annals of Discrete Mathematics</title>
				<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="141" to="149" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">PDTL: Parallel and distributed triangle listing for massive graphs</title>
		<author>
			<persName><forename type="first">I</forename><surname>Giechaskiel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Panagopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Yoneki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 44th International Conference on Parallel Processing</title>
				<imprint>
			<date type="published" when="2015-09">Sep. 2015</date>
			<biblScope unit="page" from="370" to="379" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">PowerGraph: Distributed Graph-parallel Computation on Natural Graphs</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Low</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Bickson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Guestrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th USENIX Conference on Operating Systems Design and Implementation, ser. OSDI&apos;12</title>
				<meeting>the 10th USENIX Conference on Operating Systems Design and Implementation, ser. OSDI&apos;12<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="17" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">The strength of weak ties: A network theory revisited</title>
		<author>
			<persName><forename type="first">M</forename><surname>Granovetter</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983">1983</date>
			<biblScope unit="page" from="201" to="233" />
		</imprint>
	</monogr>
	<note>Sociological theory</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">A scalable algorithm for clustering sequential data</title>
		<author>
			<persName><forename type="first">V</forename><surname>Guralnik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Karypis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 2001 IEEE International Conference on Data Mining</title>
				<meeting>2001 IEEE International Conference on Data Mining</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="179" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Motifs in evolving cooperative networks look like protein structure networks</title>
		<author>
			<persName><forename type="first">D</forename><surname>Hales</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Arteconi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Networks &amp; Heterogeneous Media</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">239</biblScope>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">The NBER patent citation data file: Lessons, insights and methodological tools</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">H</forename><surname>Hall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A B</forename></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M</forename></persName>
		</author>
		<ptr target="http://www.nber.org/patents/" />
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Graphicionado: A high-performance and energy-efficient accelerator for graph analytics</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Ham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sundaram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Satish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Martonosi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2016 49th Annual IEEE/ACM International Symposium on Microarchitecture</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">ExTensor: An Accelerator for Sparse Tensor Algebra</title>
		<author>
			<persName><forename type="first">K</forename><surname>Hegde</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Asghari-Moghaddam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pellauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Crago</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jaleel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Solomonik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Emer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Fletcher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 52nd Annual IEEE/ACM International Symposium on Microarchitecture, ser. MICRO &apos;52</title>
				<meeting>the 52nd Annual IEEE/ACM International Symposium on Microarchitecture, ser. MICRO &apos;52<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="319" to="333" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">DistTC: High performance distributed triangle counting</title>
		<author>
			<persName><forename type="first">L</forename><surname>Hoang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Jatala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Dathathri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pingali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HPEC 2019 23rd IEEE High Performance Extreme Computing</title>
				<imprint>
			<date type="published" when="2019-09">September 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Local structure in social networks</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">W</forename><surname>Holland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Leinhardt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sociological methodology</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="1" to="45" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Tricore: Parallel triangle counting on gpus</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">H</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SC18: International Conference for High Performance Computing, Networking, Storage and Analysis</title>
				<imprint>
			<date type="published" when="2018-11">Nov 2018</date>
			<biblScope unit="page" from="171" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Efficient mining of frequent subgraphs in the presence of isomorphism</title>
		<author>
			<persName><forename type="first">J</forename><surname>Huan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Prins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Third IEEE International Conference on Data Mining</title>
				<imprint>
			<date type="published" when="2003-11">Nov 2003</date>
			<biblScope unit="page" from="549" to="552" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Peregrine: A pattern-aware graph mining system</title>
		<author>
			<persName><forename type="first">K</forename><surname>Jamshidi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mahadasa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Vora</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifteenth EuroSys Conference, ser. EuroSys &apos;20</title>
				<meeting>the Fifteenth EuroSys Conference, ser. EuroSys &apos;20</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Path sampling: A fast and provable method for estimating 4-vertex subgraph counts</title>
		<author>
			<persName><forename type="first">M</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Seshadhri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pinar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th International Conference on World Wide Web, ser. WWW &apos;15. Republic and Canton of</title>
				<meeting>the 24th International Conference on World Wide Web, ser. WWW &apos;15. Republic and Canton of<address><addrLine>Geneva, Switzerland</addrLine></address></meeting>
		<imprint>
			<publisher>International World Wide Web Conferences Steering Committee</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="495" to="505" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">The triejax architecture: Accelerating graph operations through relational joins</title>
		<author>
			<persName><forename type="first">O</forename><surname>Kalinsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kimelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Etsion</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Fifth International Conference on Architectural Support for Programming Languages and Operating Systems, ser. ASPLOS &apos;20</title>
				<meeting>the Twenty-Fifth International Conference on Architectural Support for Programming Languages and Operating Systems, ser. ASPLOS &apos;20<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="1217" to="1231" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Graphflow: An active graph database</title>
		<author>
			<persName><forename type="first">C</forename><surname>Kankanamge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sahu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mhedbhi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Salihoglu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM International Conference on Management of Data, ser. SIGMOD &apos;17</title>
				<meeting>the 2017 ACM International Conference on Management of Data, ser. SIGMOD &apos;17<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1695" to="1698" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Graph kernels for chemoinformatics</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kashima</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Saigo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hattori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Tsuda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Chemoinformatics and advanced machine learning perspectives: complex computational methods and collaborative techniques</title>
				<imprint>
			<publisher>IGI Global</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="1" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">DUALSIM: Parallel subgraph enumeration in a massive graph on a single machine</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Bhowmick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-S</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Jarrah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 International Conference on Management of Data, ser. SIGMOD &apos;16</title>
				<meeting>the 2016 International Conference on Management of Data, ser. SIGMOD &apos;16<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1231" to="1245" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Turboflux: A fast continuous subgraph matching system for streaming graph data</title>
		<author>
			<persName><forename type="first">K</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Seo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-S</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Chafi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Jeong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2018 International Conference on Management of Data, ser. SIGMOD &apos;18</title>
				<meeting>the 2018 International Conference on Management of Data, ser. SIGMOD &apos;18<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="411" to="426" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Scalable subgraph enumeration in mapreduce</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Endow</title>
				<meeting>VLDB Endow</meeting>
		<imprint>
			<date type="published" when="2015-06">Jun. 2015</date>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="974" to="985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Leskovec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Krevl</surname></persName>
		</author>
		<ptr target="http://snap.stanford.edu/data" />
		<title level="m">SNAP Datasets: Stanford large network dataset collection</title>
				<imprint>
			<date type="published" when="2014-06">Jun. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Dramsim3: a cycle-accurate, thermal-capable dram simulator</title>
		<author>
			<persName><forename type="first">S</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Reddy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Jacob</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Architecture Letters</title>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">GraphLab: A New Parallel Framework for Machine Learning</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Low</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kyrola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Bickson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Guestrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Conf. Uncertainty in Artificial Intelligence, ser. UAI &apos;10</title>
				<meeting>Conf. Uncertainty in Artificial Intelligence, ser. UAI &apos;10</meeting>
		<imprint>
			<date type="published" when="2010-07">July 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Distributed graph pattern matching</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Huai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Wo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st International Conference on World Wide Web, ser. WWW &apos;12</title>
				<meeting>the 21st International Conference on World Wide Web, ser. WWW &apos;12<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="949" to="958" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Pregel: A system for large-scale graph processing</title>
		<author>
			<persName><forename type="first">G</forename><surname>Malewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Austern</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Bik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Dehnert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Leiser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Czajkowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGMOD International Conference on Management of Data, ser. SIGMOD &apos;10</title>
				<meeting>the ACM SIGMOD International Conference on Management of Data, ser. SIGMOD &apos;10<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="135" to="146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<monogr>
		<title level="m" type="main">Graphzero: Breaking symmetry for efficient graph mining</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mawhirter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Reinehr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Holmes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Wu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Automine: Harmonizing high-level abstraction and high performance for graph mining</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mawhirter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th ACM Symposium on Operating Systems Principles, ser. SOSP &apos;19</title>
				<meeting>the 27th ACM Symposium on Operating Systems Principles, ser. SOSP &apos;19<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="509" to="523" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Optimizing subgraph queries by combining binary and worst-case optimal joins</title>
		<author>
			<persName><forename type="first">A</forename><surname>Mhedhbi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Salihoglu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Endow</title>
				<meeting>VLDB Endow</meeting>
		<imprint>
			<date type="published" when="2019-07">Jul. 2019</date>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="1692" to="1704" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Optimal network alignment with graphlet degree vectors</title>
		<author>
			<persName><forename type="first">T</forename><surname>Milenković</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">L</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Hayes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Pržulj</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cancer informatics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page">S4744</biblScope>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Uncovering biological network function via graphlet degree signatures</title>
		<author>
			<persName><forename type="first">T</forename><surname>Milenković</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Pržulj</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cancer informatics</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page">S680</biblScope>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Exploiting locality in graph analytics through hardware-accelerated traversal scheduling</title>
		<author>
			<persName><forename type="first">A</forename><surname>Mukkara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Beckmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Abeydeera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sanchez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 51st Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="1" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">A detailed and flexible cycleaccurate network-on-chip simulator</title>
		<author>
			<persName><forename type="first">Nan</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">U</forename><surname>Becker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Michelogiannakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Balfour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Towles</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Shaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Dally</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2013 IEEE International Symposium on Performance Analysis of Systems and Software (ISPASS)</title>
				<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="86" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Beyond worst-case analysis for joins with minesweeper</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">Q</forename><surname>Ngo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">T</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Re</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rudra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems, ser. PODS &apos;14</title>
				<meeting>the 33rd ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems, ser. PODS &apos;14<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="234" to="245" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">A lightweight infrastructure for graph analytics</title>
		<author>
			<persName><forename type="first">D</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lenharth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pingali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th ACM Symposium on Operating Systems Principles (SOSP), ser. SOSP &apos;13</title>
				<meeting>the 24th ACM Symposium on Operating Systems Principles (SOSP), ser. SOSP &apos;13<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="456" to="471" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Energy efficient architecture for graph analytics accelerators</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Ozdal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yesil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ayupov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Greth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Burns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Ozturk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="166" to="177" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">H-index: Hashindexing for parallel triangle counting on gpus</title>
		<author>
			<persName><forename type="first">S</forename><surname>Pandey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><forename type="middle">S</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Buluc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2019 IEEE High Performance Extreme Computing Conference (HPEC)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2019-09">Sep. 2019</date>
			<biblScope unit="page" from="1" to="7" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">One quadrillion triangles queried on one million processors</title>
		<author>
			<persName><forename type="first">R</forename><surname>Pearce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Steil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">W</forename><surname>Priest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Sanders</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2019 IEEE High Performance Extreme Computing Conference (HPEC)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="1" to="5" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">Escape: Efficiently counting all 5-vertex subgraphs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pinar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Seshadhri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vishal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th International Conference on World Wide Web, ser. WWW &apos;17. Republic and Canton of</title>
				<meeting>the 26th International Conference on World Wide Web, ser. WWW &apos;17. Republic and Canton of<address><addrLine>Geneva, Switzerland</addrLine></address></meeting>
		<imprint>
			<publisher>International World Wide Web Conferences Steering Committee</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1431" to="1440" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Modeling interactome: scalefree or geometric</title>
		<author>
			<persName><forename type="first">N</forename><surname>Pržulj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">G</forename><surname>Corneil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Jurisica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">18</biblScope>
			<biblScope unit="page" from="3508" to="3515" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">Graph kernels for chemical informatics</title>
		<author>
			<persName><forename type="first">L</forename><surname>Ralaivola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Swamidass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Saigo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Baldi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neural networks</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1093" to="1110" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Fast and robust distributed subgraph enumeration</title>
		<author>
			<persName><forename type="first">X</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-S</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">X</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
				<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="1344" to="1356" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Parallel subgraph listing in a large-scale graph</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 ACM SIGMOD International Conference on Management of Data, ser. SIGMOD &apos;14</title>
				<meeting>the 2014 ACM SIGMOD International Conference on Management of Data, ser. SIGMOD &apos;14<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="625" to="636" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">Efficient graphlet kernels for large graph comparison</title>
		<author>
			<persName><forename type="first">N</forename><surname>Shervashidze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vishwanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Petri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Mehlhorn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Borgwardt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence and Statistics</title>
		<imprint>
			<biblScope unit="page" from="488" to="495" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">Multicore triangle computations without tuning</title>
		<author>
			<persName><forename type="first">J</forename><surname>Shun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Tangwongsan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 IEEE 31st International Conference on Data Engineering</title>
				<imprint>
			<date type="published" when="2015-04">April 2015</date>
			<biblScope unit="page" from="149" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">Graphr: Accelerating graph processing using reram</title>
		<author>
			<persName><forename type="first">L</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhuo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 IEEE International Symposium on High Performance Computer Architecture (HPCA)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="531" to="543" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">Efficient parallel subgraph enumeration on a single machine</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Che</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Luo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2019 IEEE 35th International Conference on Data Engineering (ICDE)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="232" to="243" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<analytic>
		<title level="a" type="main">Scaling up subgraph query processing with efficient subgraph matching</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Luo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2019 IEEE 35th International Conference on Data Engineering (ICDE)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="220" to="231" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">Counting triangles and the curse of the last reducer</title>
		<author>
			<persName><forename type="first">S</forename><surname>Suri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vassilvitskii</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th International Conference on World Wide Web, ser. WWW &apos;11</title>
				<meeting>the 20th International Conference on World Wide Web, ser. WWW &apos;11<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="607" to="614" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">A distributed approach for graph mining in massive networks</title>
		<author>
			<persName><forename type="first">N</forename><surname>Talukder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Zaki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Min. Knowl. Discov</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1024" to="1052" />
			<date type="published" when="2016-09">Sep. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">Parallel graph mining with dynamic load balancing</title>
		<author>
			<persName><forename type="first">N</forename><surname>Talukder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Zaki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2016 IEEE International Conference on Big Data (Big Data)</title>
				<imprint>
			<date type="published" when="2016-12">Dec 2016</date>
			<biblScope unit="page" from="3352" to="3359" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<analytic>
		<title level="a" type="main">Arabesque: A system for distributed graph mining</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H C</forename><surname>Teixeira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Fonseca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Serafini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Siganos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Zaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aboulnaga</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th Symposium on Operating Systems Principles, ser. SOSP &apos;15</title>
				<meeting>the 25th Symposium on Operating Systems Principles, ser. SOSP &apos;15<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="425" to="440" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b82">
	<analytic>
		<title level="a" type="main">An algorithm for subgraph isomorphism</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Ullmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="31" to="42" />
			<date type="published" when="1976-01">Jan. 1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<analytic>
		<title level="a" type="main">Rstream: Marrying relational algebra with streaming for efficient graph mining on a single machine</title>
		<author>
			<persName><forename type="first">K</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Zuo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Thorpe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">Q</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">H</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th USENIX Conference on Operating Systems Design and Implementation, ser. OSDI&apos;18</title>
				<meeting>the 12th USENIX Conference on Operating Systems Design and Implementation, ser. OSDI&apos;18<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="763" to="782" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<analytic>
		<title level="a" type="main">Fast linear algebra-based triangle counting with kokkoskernels</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Wolf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Deveci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Berry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Hammond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rajamanickam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2017 IEEE High Performance Extreme Computing Conference (HPEC)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1" to="7" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<analytic>
		<title level="a" type="main">gspan: graph-based substructure pattern mining</title>
		<author>
			<persName><forename type="first">Xifeng</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiawei</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2002 IEEE International Conference on Data Mining</title>
				<meeting>the 2002 IEEE International Conference on Data Mining</meeting>
		<imprint>
			<date type="published" when="2002-12">Dec 2002</date>
			<biblScope unit="page" from="721" to="724" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b86">
	<analytic>
		<title level="a" type="main">Alleviating irregularity in graph analytics acceleration: A hardware/software co-design approach</title>
		<author>
			<persName><forename type="first">M</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Basak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Akgun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Deng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 52nd Annual IEEE/ACM International Symposium on Microarchitecture</title>
				<meeting>the 52nd Annual IEEE/ACM International Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="615" to="628" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b87">
	<analytic>
		<title level="a" type="main">Graph indexing: a frequent structure-based approach</title>
		<author>
			<persName><forename type="first">X</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2004 ACM SIGMOD international conference on Management of data</title>
				<meeting>the 2004 ACM SIGMOD international conference on Management of data</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="335" to="346" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b88">
	<analytic>
		<title level="a" type="main">Graphabcd: Scaling out graph analytics with asynchronous block coordinate descent</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2020 ACM/IEEE 47th Annual International Symposium on Computer Architecture (ISCA)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="419" to="432" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b89">
	<monogr>
		<title level="m" type="main">A locality-aware energy-efficient accelerator for graph mining applications</title>
		<author>
			<persName><forename type="first">P</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Zeng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Liao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Xue</surname></persName>
		</author>
		<idno>ser. MICRO &apos;20</idno>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="1" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b90">
	<analytic>
		<title level="a" type="main">Fast triangle counting using cilk</title>
		<author>
			<persName><forename type="first">A</forename><surname>Yas ¸ar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rajamanickam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wolf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Berry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ü</forename><forename type="middle">V</forename><surname>¸atalyürek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 IEEE High Performance extreme Computing Conference (HPEC)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="1" to="7" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b91">
	<analytic>
		<title level="a" type="main">Discovering discriminative graphlets for aerial image categories recognition</title>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Tian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Image Processing</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="5071" to="5084" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b92">
	<analytic>
		<title level="a" type="main">Graphp: Reducing communication for pim-based graph processing with efficient data partition</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhuo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kozyrakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Qian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 IEEE International Symposium on High Performance Computer Architecture (HPCA)</title>
				<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b93">
	<analytic>
		<title level="a" type="main">GraphIt: A High-performance Graph DSL</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Baghdadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kamil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Shun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Amarasinghe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA</title>
				<imprint>
			<date type="published" when="2018-10">Oct. 2018</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="1" to="121" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b94">
	<analytic>
		<title level="a" type="main">Kaleido: An Efficient Out-of-core Graph Mining System on A Single Machine</title>
		<author>
			<persName><forename type="first">C</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Guo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2020 IEEE International Conference on Data Engineering (ICDE 2020), ser. ICDE &apos;20</title>
				<meeting>the 2020 IEEE International Conference on Data Engineering (ICDE 2020), ser. ICDE &apos;20</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b95">
	<analytic>
		<title level="a" type="main">Graphq: Scalable pim-based graph processing</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhuo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Niu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Qian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 52nd Annual IEEE/ACM International Symposium on Microarchitecture</title>
				<meeting>the 52nd Annual IEEE/ACM International Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="712" to="725" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
