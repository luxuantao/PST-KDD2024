<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Compositional Refinement for Hierarchical Hybrid Systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Rajeev</forename><surname>Alur</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer and Information Science</orgName>
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Radu</forename><surname>Grosu</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">State University of New York at Stony Brook</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Insup</forename><surname>Lee</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer and Information Science</orgName>
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Oleg</forename><surname>Sokolsky</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer and Information Science</orgName>
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Compositional Refinement for Hierarchical Hybrid Systems</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">1E01F78CFDDFF84CB9F1D6566E430C54</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T03:23+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper, we develop a theory of modular design and refinement of hierarchical hybrid systems. In particular, we present compositional trace-based semantics for the language Charon that allows modular specification of interacting hybrid systems. For hierarchical description of the system architecture, Charon supports building complex agents via the operations of instantiation, hiding, and parallel composition. For hierarchical description of the behavior of atomic components, Charon supports building complex modes via the operations of instantiation, scoping, and encapsulation. We develop an observational trace semantics for agents as well as for modes, and define a notion of refinement for both, based on trace inclusion. We show this semantics to be compositional with respect to the constructs in the language.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Modern software design paradigms promote hierarchy as one of the key constructs for structuring complex specifications. We are concerned with two distinct notions of hierarchy. In architectural hierarchy, a system with a collection of communicating agents is constructed by parallel composition of atomic agents, and in behavioral hierarchy, the behavior of an individual agent is described by hierarchical sequential composition. The former hierarchy is present in almost all concurrency formalisms, and the latter, while present in all block-structured programming languages, was introduced for state-machine-based modeling in Statecharts <ref type="bibr" target="#b8">[9]</ref>, and forms an integral part of modern notations such as UML <ref type="bibr" target="#b4">[5]</ref>.</p><p>A hybrid system typically consists of a collection of digital programs that interact with each other and with an analog environment. Specifications of hybrid systems integrate state-machine models of discrete behavior with differential equations for continuous behavior. This paper is about developing a formal and compositional semantics of hierarchical hybrid specifications. Formal semantics leads to definitions of semantic equivalence (or refinement) of specifications based on their observable behaviors, and compositionality means that semantics of a component can be constructed from the semantics of its subcomponents. Such formal compositional semantics is a cornerstone of concurrency frameworks such as CSP <ref type="bibr" target="#b10">[11]</ref> and CCS <ref type="bibr" target="#b13">[14]</ref>, and is a prerequisite for developing modular reasoning principles such as compositional model checking and systematic design principles such as stepwise refinement.</p><p>The main contribution of the paper is a formal compositional semantics for the language Charon <ref type="bibr" target="#b2">[3]</ref> with an accompanying compositional refinement calculus. The building block for describing the system architecture is an agent that communicates with its environment via shared variables. The language supports the operations of composition of agents to model concurrency, hiding of variables to restrict sharing of information, and instantiation of agents to support reuse. The building block for describing flow of control inside an atomic agent is a mode. A mode is basically a hierarchical state machine, that is, a mode can have submodes and transitions connecting them. Variables can be declared locally inside any mode with standard scoping rules for visibility. Modes can be connected to each other only via well-defined entry and exit points. We allow sharing of modes so that the same mode definition can be instantiated in multiple contexts. To support exceptions, the language allows group transitions from default exit points that are applicable to all enclosing modes, and to support history retention, the language allows default entry transitions that restore the local state within a mode from the most recent exit. Discrete updates are specified by guarded actions labeling transitions connecting the modes. Some of the variables in Charon can be declared analog, and they flow continuously during continuous updates that model passage of time. The evolution of analog variables can be constrained in three ways: differential constraints (e.g. by equations such as ẋ = f (x, u)), algebraic constraints (e.g. by equations such as y = g(x, u)), and invariants (e.g. |x -y| ≤ ε) which limit the allowed durations of flows. Such constraints can be declared at different levels of the mode hierarchy.</p><p>To define the modular semantics for modes, with each mode we associate two relations, one capturing its discrete behavior and one capturing its continuous behavior. Defining the discrete relation is tricky in presence of features such as group transitions, exceptions, and history retention. Our solution relies on a closure construction, inspired by a similar construction for hierarchical discrete systems <ref type="bibr" target="#b1">[2]</ref>, which allows us to treat the transfer of control between a mode and its environment as a game.</p><p>While discrete steps of a mode and its environment are interleaved, continuous steps need to be synchronized as time is a global parameter. In fact, during a flow, all active hierarchically nested modes must participate. To allow flexible and hierarchical specifications, in Charon, flow constraints can be specified at all levels of the hierarchy. To formalize this feature in a consistent and modular manner, we require that a mode can participate in a flow only when the control is at its default exit point. Then, all applicable constraints are properly used to define permitted flows.</p><p>The discrete and continuous relations of a mode allow us to define executions of a mode, and corresponding traces are obtained by projecting out the private variables. We show that the set of traces of a mode can be constructed from the traces of its submodes. This compositionality result leads to a compositional notion of refinement for modes. A mode M refines a mode N if they have the same interface in terms of entry/exit points and shared variables, and the traces of M is a subset of traces of N . This notion admits modular reasoning in the following manner. Suppose we obtain an implementation design I from a specification design S simply by locally replacing some submode N in S by a submode M . Then, to show I refines S, it suffices to show that M refines N . We illustrate this benefit by a simple example.</p><p>Once we have the compositionality results for modes, analogous results for agents are relatively straightforward. We define an observational trace semantics for agents, a resulting notion of refinement, and show it to be compositional with respect to the operations of parallel composition, hiding, and instantiation.</p><p>Related work. Early formal models for hybrid systems include phase transition systems <ref type="bibr" target="#b12">[13]</ref> and hybrid automata <ref type="bibr" target="#b0">[1]</ref>. Models such as hybrid I/O automata <ref type="bibr" target="#b11">[12]</ref> and hybrid modules <ref type="bibr" target="#b3">[4]</ref> allow compositional treatment of concurrent hybrid behaviors. The notion of hierarchical state machines was introduced in Statecharts <ref type="bibr" target="#b8">[9]</ref>, and is present in many software design paradigms such as Uml <ref type="bibr" target="#b4">[5]</ref>. Our treatment of hierarchy is closest to hierarchical reactive modules <ref type="bibr" target="#b1">[2]</ref> which shows how to define a modular semantics for hierarchical (discrete) modes. Tools such as Shift <ref type="bibr" target="#b6">[7]</ref>, Ptolemy <ref type="bibr" target="#b5">[6]</ref>, and Stateflow (see www.mathworks.com) allow hierarchical specifications of hybrid behavior, but formal semantics has not been a concern. HyCharts <ref type="bibr" target="#b7">[8]</ref> presents a hierarchical model with modular operational semantics, but does not consider refinement. Masaccio <ref type="bibr" target="#b9">[10]</ref> is a formal model for hierarchical hybrid systems. While same in spirit, it differs from our model in many technically significant aspects: it allows nesting of sequential and parallel composition, and allows a more general form of synchronous communication, but disallows high-level features of Charon modes such as exceptions, history retention, and specification of constraints at various levels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Motivational example</head><p>In this section, we present a simple example that outlines features, useful in a specification language for hybrid systems. We also point out the difficulties of defining semantics for such a language. Then we give the intuition for our approach to the semantics definition, which allows us to overcome the difficulties.</p><p>Our example is a system that controls the level of liquid in a leaky tank. The level is controlled by infusing a flow of liquid into the tank. The level in the tank can be measured directly, but the rate of the leak has to be estimated. The controller has two goals: first, it must make sure that the level is within some critical bounds. If it is not, emergency measures are taken to make the level safe. When the level is safe, the controller should change the infusion rate according to instructions of the user. To do that, the controller periodically recomputes the desired rate of change for infusion and maintains the computed rate until the next update.</p><p>We now present a hierarchical description of the system in Charon. The hierarchy in Charon is twofold. The architectural hierarchy describes how the system agents interact with each other, hiding the details of interaction between sub-agents. The behavioral hierarchy describes behavior of each agent, hiding the low-level behavioral details. In our example, we have only one level of architecture description with agents Tank and Controller. There are two variables shared by the agents: level for the level of the liquid, and infusion for the infusion rate.</p><p>Both agents are primitive, that is, without concurrent sub-agents. Behavior of a primitive agent is given by a mode, a hybrid state machine equipped with analog and discrete variables. While a mode stays in a state, its analog variables are updated continuously according to a set of constraints. Taking transitions from one state to another, the mode updates its discrete variables. States of the mode are submodes that can have their own behavior. A mode has a number of control points, through which control enters and exits the mode. That is, to perform a computation in one of its submodes, a mode takes a transition to an entry point of that submode. When the computation is complete, a transition from an exit point of the submode is taken.</p><p>Before the computation of a mode is completed, it may be interrupted by a group transition, originating from a default exit point dx. After an interrupt, control is restored to the mode via a default entry point de. In our example, the behavior of Tank is represented by a single differential equation d(level ) = infusionleak , where leak is a local variable of Tank. Figure <ref type="figure">1</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 1. Behavior of the controller</head><p>The mode Normal has two submodes. Submode Maintain is used to maintain the current rate of change for infusion, represented by a local variable rate. Every 10 seconds, measured by a local clock t, Maintain makes a call to Submode Compute that computes a new value of rate. The details of the computation are irrelevant, but we assume that the computation is done differently depending on the level. We therefore introduce two submodes in Compute and show only the constraints for infusion in each submode. The exit transition of Compute assigns the computed value to the variable rate.</p><p>Note that the mode Normal controls the value of the clock t, and its rate of change is the same in all its submodes. By contrast, infusion is updated differently in the two submodes. In this case, every submode must provide a constraint for infusion. Note also that rate is a discrete variable. It is updated only by transitions of Compute.</p><p>We use invariants to force one of the outgoing transitions. Control can reside in a mode only as long as its invariant is satisfied. As soon as an invariant is violated, control has to leave the mode by taking one of the enabled outgoing transitions. In Figure <ref type="figure">1</ref>, invariants of the modes are shown in braces. For example, ten time units after entering the mode Maintain the transition to Compute has to be taken.</p><p>We distinguish between regular transitions and interrupts. For example, control is transferred from Compute to Maintain only when the computation is complete. When it is time to perform another computation, it will start from the beginning. On the other hand, the transition from Normal to Emergency works as an interrupt. Regardless of which submode of Normal is operating when an interrupt occurs, control is transferred to Emergency. Upon return from the interrupt, the control state of Normal is restored. There is no priority between regular transitions and interrupts<ref type="foot" target="#foot_0">1</ref> . A mode can ignore an enabled interrupt and execute its internal transitions or let time elapse. We use invariants as described above to enforce interrupts (see the invariant of mode Normal). Invariants give the user finer control over interrupts. For example, a situation when an interrupt is optional for some time and then becomes urgent can be easily expressed.</p><p>In addition to discrete steps described above, a mode can make continuous steps, when time progresses and the analog variables of the mode are updated according to a set of constraints. Because of the hierarchical structure of the mode, the set of applicable constraints consists of the constraints defined in the mode itself and those from the currently active submode. This implies that a mode can engage in a continuous step only when its control properly resides within one of its submodes. For example, we cannot allow time to pass at the control point e of Compute, between executing the transition from Maintain to Compute and a transition to enter ComputeHigh or ComputeLow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Modes</head><p>Notation. We will represent modes and agents as tuples of components. If T is a tuple t 1 , . . . , t n , we identify the component t i of T as T.t i . We extend this notation to sets of tuples. If ST is a set of tuples with the same structure, we write ST.</p><formula xml:id="formula_0">t i to mean T ∈ST T.t i .</formula><p>Given a set V of typed variables, a valuation for V is a function mapping variables to their values. We will assume that all valuations are type correct. The set of valuations over V is denoted Q V . We will use variables s, t, possibly primed or subscripted, to range over valuations. Given a valuation s over V , and a set W ⊆ V , s[W ] denotes the restriction of s to the variables of W .</p><p>A flow for a set V of variables is a differentiable function f from a closed interval of non-negative reals [0, δ] to Q V . We refer to δ as the duration of the flow. We assume that only constant functions are differentiable for non real-valued types. We denote a set of flows for V as F V . <ref type="figure">Cons,</ref><ref type="figure">T</ref> , where E is a set of entry control points, X is a set of exit control points, V is a set of variables, SM is a set of submodes, Cons is a set of constraints, and T is a set of transitions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Syntax Definition 1. (Mode</head><formula xml:id="formula_1">) A mode M is a tuple E, X, V, SM,</formula><p>Variables. A mode has a finite set of typed variables V , partitioned into subsets V a and V d , the sets of analog and discrete variables, respectively. We also parition V into V g and V l , the sets of global and local variables 2 . We assume that there are no conflicts between the names of local variables of different modes. Submodes. SM is a finite set of submodes. We require that each global variable of a submode is a variable (either global or local) of its parent mode. That is, if N ∈ SM , then N.V g ⊆ V . This induces a natural scoping rule for variables in a hierarchy of modes: a variable introduced as local in a mode is accessible in all its submodes but not in any other mode. Control points. E is the set of entry points; X is the set of exit points. There are two distinguished control points representing default entry and exit: de ∈ E and dx ∈ X. We use C for the set of all control points of the mode:</p><formula xml:id="formula_2">C = E ∪ X ∪ SM.E ∪ SM.X.</formula><p>Constraints. The finite set Cons of constraints defines the flows permitted by M <ref type="foot" target="#foot_2">3</ref> . Cons contains an invariant I, which defines when the mode can be active (see the definition of an active mode below). Further, for a variable x ∈ V a , Cons can contain an algebraic constraint A x , which defines the set of admissible values for x, or a differential constraint D x , which defines admissible values for the derivative of x with respect to time. Every invariant and an algebraic constraint is a predicate c ⊆ Q V and a differential constraint D x is a predicate on Q V ∪d(V ) . A flow f is permitted by the mode if for every t in the domain of f , every variable in f (t) satisfies all constraints in Cons. Examples of constraints are d(x) ≤ f (x, y) and g(x, y) ≤ 0. Transitions. T is a finite set of transitions of the form (e, α, x), where e ∈ E ∪SM.X, x ∈ X ∪ SM.E, and α, the action of the transition, is a relation from</p><formula xml:id="formula_3">Q Vg to Q V if e ∈ E and from Q V to Q V otherwise.</formula><p>A transition connects control points of the mode or its submodes. When a transition is executed, it updates some variables of the mode. Every mode is assumed to have an identity transition from de to dx, but we disallow transitions from any non-default control point to dx. A transition that originates at a default exit point of a submode is called a group transition of that submode. A group transition can be executed to interrupt the execution of the submode. We require that if a submode has been exited by a group transition, it must be entered again through its default entry point to resume the interrupted execution.</p><p>Furthermore, we require that the mode cannot be blocked at any of its non-default control points. Precisely, for every e of M that is not de in M or dx in one of the submodes of M , the union α e of all actions of the transitions originating at e is complete, that is, for every s there is t such that (s, t) ∈ α e . Special modes. We distinguish two kinds of modes that play a special role in the semantic definitions. A mode M is a leaf mode if M.SM = ∅. Leaf modes perform continuous steps according to their constraints. A top-level mode has a single nondefault entry point init and no non-default exit points. Top-level modes are used to describe behavior of agents, as shown in Section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Semantics</head><p>Intuition. A mode can engage in a discrete or continuous behavior. During an execution, the mode and its environment either take turns making discrete steps or take a continuous step together. Discrete and continuous steps of the mode alternate. During a continuous step, the mode follows a flow from the set of flows possible for the current state for the length of its duration, updating its variables according to the flow. Note that the set of flows permitted by the mode's constraints may be further restricted by the mode's environment. A discrete step of the mode is a finite sequence of discrete steps of the submodes and enabled transitions of the mode itself. A discrete step begins in the current state of the mode and ends when it reaches an exit point or when the mode decides to yield control to the environment and let it make the choice of the next step. Note that in the latter case, the decision to break a discrete step is made by the mode itself. Technically, when the mode ends its discrete step in one of its submodes, it returns control to the environment via its default exit point. The closure construction, described below, ensures that the mode can yield control at appropriate moments, and that the discrete control state of the mode is restored when the environment schedules the next discrete step. State of a mode. We define the state of a mode in terms of all variables of the mode and its submodes. We use V * = V ∪ SM.V * for the set of all variables.</p><p>The state of a mode M is a pair (c, s), where c is the location of discrete control in the mode and s ∈ Q M.V * . Whenever the mode has control, it resides in one of its control points. In this case, c ∈ M.C. We use special symbol to denote the case when the mode does not have control. Given a state (c, s) of M , we refer to c as the control state of M and to s as the data state of M .</p><p>Preemption. An execution of a mode can be preempted by a group transition. A group transition of a mode originates at the default exit of the mode. During any discrete step of the mode, control can be transferred to the default exit and an enabled group transition can be selected. There is no priority between the transitions of a mode and its group transitions. When an execution of a mode is preempted, the control state of the mode is recorded in a special history variable, a new local variable that we introduce into every mode. Then, when the mode is entered through the default entry point next time, the control state of the mode is restored according to the history variable. The history variable and active submodes. In order to record the location of discrete control during executions, we introduce a new local variable h into each mode that has submodes. The history variable h of a mode M can assume values from the set SM ∪ . A submode N of M is called active when the history variable of M has the value N . Every top-level mode is always active. Closure of a mode. Closure construction is a technical device to allow the mode to interrupt its execution, either to allow the environment to schedule another step or to provide for preemption of the mode execution by group transitions. Transitions of the mode are modified to update h after a transition is executed. In addition, default entry and exit transitions are added to the set of transitions of the mode. These default transitions do not affect the history variable and allow us to interrupt an execution and then resume it later from the same point.</p><p>The closure modifies the transitions of M in such a way that, after each transition, h records the active submode. If a transition leads to a control point of a submode N , the resulting state has h = N . Otherwise, if the transition leads to a control point of M itself, the value of h after the transition will be . For each submode N of M , the closure adds a default exit transition from N.dx to M.dx. This transition does not change any variables of the mode and is always enabled. Default entry transitions are used to restore the local control state of M . A default entry transition leads from a default entry of the mode to the default entry of every submode N and is enabled if h = N . Furthermore, we make sure that the default entry transitions do not interfere with regular entry transitions originating from de. The closure changes each such transition so that it is enabled only if h = .</p><p>Formally, the closure c(M ) of a mode M = E, X, V, SM, Cons, T is defined to be the mode E, X, V ∪ h, c(SM ), Cons, c(T ) , where h ∈ V is a new local variable, c(SM ) = {c(m) | m ∈ SM } is the set of closed submodes of M , and c(T ) is the closed set of transitions obtained by extending T with transitions (x, α x , dx) for every x ∈ SM.dx and (de, α x , e) for every e ∈ SM.de, and extending every transition in T such that -(s, s) ∈ α x iff x ∈ N.E for some N ∈ SM and s[h] = N ; -for every transition (e, α, x) ∈ T , the respective closed transition is (e, α , x), where (s, t)</p><formula xml:id="formula_4">∈ α iff (s[V ], t[V ]) ∈ α and • if x ∈ N.E for some N ∈ SM , then t[h] = N , otherwise t[h] = , • if e ∈ N.X for some N ∈ SM , then s[h] = N , otherwise s[h] = .</formula><p>The closure construction for the example introduced in Section 2 is illustrated in Figure <ref type="figure" target="#fig_0">2</ref>. To avoid cluttering the figure, we omit the default transitions of the submode ComputeLow, and do not show the variables of the modes. Before formally defining executions of a mode, we illustrate continuous and discrete steps using the example in Figure <ref type="figure" target="#fig_0">2</ref>. Assume that the the controller is in the Maintain mode and none of the invariants is violated. Maintain can voluntarily relinquish control to the environment to let it take a step or advance time by taking the default exit transition to dx of Normal. There, the group transition is not enabled, and the default exit transition of the parent mode is taken. When the control arrives thus at the top level, the environment can schedule a continuous step. The analog variables of all agents are updated according to the constraints of the active modes. The active modes are Maintain, Normal, and Controller. Thus, the applicable constraints are d(t) = 1 and d(inf usion) = rate. The global variable level is updated according to the constraint in Tank. After the continuous step, control returns to Maintain via the chain of default entry transitions. Assume now that the invariant of Normal is violated while control is inside a submode of Compute. Then, control is transferred to dx of Compute and then on to dx of Normal. There, the choice between the group transition to Emergency or the default exit transition is non-deterministic. But since the invariant is violated, a continuous step cannot be taken. Operational semantics. An operational view of a closed mode M with the set of variables V consists of a continuous relation R C and, for each pair</p><formula xml:id="formula_5">c 1 ∈ E, c 2 ∈ X, a discrete relation R D c1,c2 .</formula><p>The relation R C ⊆ Q V × F V gives, for every data state of the mode, the set of flows from this state. By definition, if the control state of the mode is not at dx, the set of flows for the state is empty. We require that, whenever (s, f ) ∈ R C , f (0) = s. In addition, for each s, the set of flows</p><formula xml:id="formula_6">F s = {f | (s, f ) ∈ R C } is prefix-closed. That is, if the domain of f ∈ F s is [0, δ],</formula><p>then for every &lt; δ, a flow f : [0, ] that coincides with f on [0, ] also belongs to F s . R C is obtained from the constraints of a mode and relations SM.R C of its submodes. Given a data state s of a mode M , (s, f</p><formula xml:id="formula_7">) ∈ R C iff f is permitted by M and, if N is the active submode at s, (s[N.V ], f[N.V ]) ∈ N.R C .</formula><p>For each</p><formula xml:id="formula_8">c 1 ∈ E ∪ SM.X, c 2 ∈ X ∪ SM.E, relation R D c1,c2 ⊆ Q V × Q V describes the discrete behavior in which control is transferred from c 1 to c 2 . The relation R D</formula><p>e,x comprises macro-steps of a mode starting at e and ending at x. A macro step consists of a sequence of micro-steps. Each micro-step is either a transition of the mode or a macro-step of one of its submodes. Given the relations R D e ,x , e ∈ SM.E, x ∈ SM.X of macro-steps of the submodes of M , a micro-execution of a mode M = E, X, V, SM, C, T is a sequence of the form (e 0 , s 0 ), (e 1 , s 1 ), . . . , (e n , s n ) such that, for all i, e i ∈ C and s i ∈ V * and for even i, ((e i , s i ), (e i+1 , s i+1 )) ∈ T , while for odd i, (s i , s i+1 ) ∈ SM.R D ei,ei+1 . Given such a micro execution of M with e 0 = e ∈ E and e n = x ∈ X, we have (s</p><formula xml:id="formula_9">0 , s n ) ∈ R D e,x .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2. (Operational semantics)</head><p>The operational semantics of the mode M consists of its control points E ∪ X, its variables V and relations R C and R D e,x .</p><p>The operational semantics of a mode defines a transition system R over the states of the mode. We write (e 1 , s 1 )</p><formula xml:id="formula_10">o →(e 2 , s 2 ) if (s 1 , s 2 ) ∈ R D e1,e2</formula><p>, and (dx, s 1 )</p><formula xml:id="formula_11">f →(dx, s 2 ) if (s 1 , f) ∈ R C ,</formula><p>f is defined on the interval [0, t] and f (t) = s 2 . We extend R to include environment steps. An environment step begins at an exit point of the mode and ends at an entry point. It represents changes to the global variables of the mode by other components while the mode is inactive. Private variables of the mode are unaffected by environment steps. Thus there is an environment step (x, s) ε →(e, t) whenever x ∈ X, e ∈ E, and s[V p ] = t[V p ]. We let λ range over F V ∪ {o, ε}. An execution of a mode is now a path through the graph of R:</p><formula xml:id="formula_12">(e 0 , s 0 ) λ1 →(e 1 , s 1 ) λ2 → . . . λn →(e n , s n ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Trace semantics</head><p>To be able to define a refinement relation between modes, we consider a trace semantics for modes. A trace of the mode is a projection of its execution onto the global variables of the mode. That is, a trace is obtained from each execution by replacing every s i with s i [V g ], and every f in transition labels with f [V g ]. We denote the set of traces of a mode M by L M .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3. (Trace semantics for modes)</head><p>The trace semantics for M is given by its control points E and X, its global variables V , and its set of its traces L M .</p><p>In defining compositional and hierarchical semantics, one has to decide, what details of the behavior of lower-level components are observable at higher levels. In our approach, the effect of a descrete step that updates only local variables of a mode is not observable by its environment, but stoppage of time introduced by such step is observable. For example, consider two systems, one of which is always idle, while the other updates a local variable every second. These two systems are different, since the second one does not have flows more than one second long. Defining a modular semantics in a way that such distinction is not made seems much more difficult.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Agents</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Syntax Definition 4. (Agent) An agent T M, V, I consists of a set of variables V , a set of initial states, and a set of top-level modes T M.</head><p>The top-level modes collectively define behavior of the agent. The set V is partitioned into local variables V l and global variables V g . We require that T M.V ⊆ V , V g ⊆ T M.V g ; that is, all global variables originate in some mode. The set of initial states I ⊆ Q V specifies possible initializations of the variables of the agent. A primitive agent has a single top-level mode. Composite agents have many top-level modes and are constructed by parallel composition of other agents as described below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Semantics</head><p>An execution of an agent follows a trajectory, which starts in one of the initial states and is a sequence of flows interleaved with discrete updates to the variables of the agent. An execution of A is constructed from the relations R C and R D of its toplevel modes. For a fixed initial state s 0 , each mode M ∈ T M starts out in the state (init M , s M ), where init M is the non-default entry point of M and s 0 [M.V ] = s M . Note that as long as there is a mode M whose control state is at init M , no continuous steps are possible. However, any discrete step of such mode will come from R D initM ,dx and bring the control state of M to dx. Therefore, any execution of an agent A = T M, V, I with |T M| = k will start with exactly k discrete initialization steps. At that point, every top-level mode of A will be at its default exit point, allowing an alternation of continuous steps from R C and discrete steps from R D de,dx . The choice of a continuous step involving all modes or a discrete step in one of the modes is left to the environment. Before each discrete step, there is an environment step, which takes the control point of the chosen mode from dx to de and leaves all the private variables of all top-level modes intact. After that, a discrete step of the chosen mode happens, bringing control back to dx. Thus, an execution of</p><formula xml:id="formula_13">A with |T M| = k is a sequence s 0 o →s 1 o → . . . s k λ1 →s k+1 λ2 → . . . such that -for every 0 ≤ i &lt; k, there is M ∈ T M such that (s i [M.V ], s i+1 [M.V ]) ∈ M.R D initM ,dx .</formula><p>That is, the first k steps initialize the top-level modes of A. -for every i ≥ k, one of the following holds:</p><p>• s i f →s i+1 such that f is defined on [0, t] and f (t) = s i+1 , and for every mode</p><formula xml:id="formula_14">M ∈ T M, (s i [M.V ], f[M.V ]) ∈ M.R C</formula><p>; that is, the step is a continuous step, in which every mode takes part; → s n is a trace of A. A similar statement is true for agents with multiple top-level modes.</p><formula xml:id="formula_15">• s i ε →s i+1 such that for every mode M ∈ T M, s i [M.V p ] = s i+1 [M.V p ]; that is, the step is an environment step; • s i o →s i+1 with i &gt; k, there is M ∈ T M such that (s i [M.V ], s i+1 [M.V ]) ∈ M.R D de</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Operations on agents</head><p>Variable hiding. The hiding operator makes a set of agent variables private. Given an agent A = T M, V, I , the agent</p><formula xml:id="formula_16">A\{V h } = T M, V , I with V l = V l ∪ V h , V g = V g -V h . A trace of A, projected onto the set of global variables of A\{V h }, is a trace of A\{V h }.</formula><p>Variable renaming. Variable renaming replaces a set of variables in an agent A with another set of variables. Let</p><formula xml:id="formula_17">V 1 = {x 1 , . . . , x n }, V 2 = {y 1 , . . . , y n } be indexed sets of variables with V 1 ⊆ A.V . Then, A[V 1 := V 2 ] is an agent with the set of global variables (A.V g -V 1 ) ∪ V 2 .</formula><p>Semantics of the variable renaming operator is given by renaming the variables in the traces of the agent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Parallel composition. The composition of the two agents</head><formula xml:id="formula_18">A 1 ||A 2 is an agent A = T M, V, I defined as follows:A.T M = A 1 .T M ∪ A 2 .T M, A.V g = A 1 .V g ∪ A 2 .V g , A.V l = A 1 .V l ∪ A 2 .V l , and if s ∈ A.I then s[A 1 .V ] ∈ A 1 .I and s[A 2 .V ] ∈ A 2 .I.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Compositionality results</head><p>We show that our semantics is compositional for both modes and agents. First, the set of traces of a mode can be computed from the definition of the mode itself and the semantics of its submodes. Second, the set of traces of a composite agent can be computed from the semantics of its sub-agents. For the lack of space, we omit the proofs and concentrate on intuitions for the results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Compositionality of modes</head><p>In order to show that our trace semantics for modes is compositional, we need to be able to define the semantics of a mode only in terms of the semantics of its submodes. Compositional Trace Construction. First, we show that every trace of a mode can be constructed using the traces of the submodes. Theorem 1. The set of traces of a mode M can be computed from the set of traces of its submodes, its closed transition relation c(T) and the set of constraints Cons. </p><formula xml:id="formula_19">... N 1 &lt; M k M k M 1 1 M 1 M M M C 1 N 1 k &lt; N k &lt; N 1 &lt; &lt; C M 1 M k M k C 2 C 2</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 3. Compositionality rules for modes</head><p>Theorem 1 relies on the following observation. Given a submode N of M , we can "project" a trace σ of M onto N and obtain a trace of N . This projection will 1) restrict all data states and flows to the global variables of N , 2) replace every subsequence of σ where N is inactive into a single environment step, and 3) convert continuous steps of M into continuous steps of N by removing transitions from N.dx to M.dx and from M.de to N.de. The critical point in proving this observation is that, whenever the control state is at dx of M , and N is the active submode of M , N has its control state at N.dx, since only default exit transitions and the identity transition of the mode can end at dx. Mode Refinement. The trace semantics leads to a natural notion of refinement between modes: a mode M refines N if it has the same global variables and control points, and every trace of M is a trace of N . Definition 6. (Refinement) A mode M and a mode N are said to be compatible if M.V g = N.V g , M.E=N.E and M.X=N.X. Given two compatible modes M and N , M refines N , denoted M N , if L M ⊆L N . The refinement rule is explained visually in Figure <ref type="figure">3</ref>, left. If we consider a submode N within a mode M , the remaining submodes of M and the transitions of M can be viewed as an environment or mode context for N . In other words, a context for N 1 . . . N k is a mode M [G 1 , . . . G k ] with holes or most general submodes G i , 1&lt;i&lt;k that have the same interface as N i , have no local variables and put no constraints on the update of global variables. Two contexts are said to be compatible if they are compatible as modes and they also are compatible on their holes. A visual representation of this rule is shown in Figure <ref type="figure">3</ref>, right. The compositionality rules allow us to decompose the proof obligation into refinement of submodes in the most general context, and refinement of contexts under the most general submode. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>For a finite index set I, we write {M</head><formula xml:id="formula_20">i | i ∈ I} {N i | i ∈ I} if M i N i for each i ∈ I.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Compositionality of agents</head><p>An agent is, in essence, a set of top level modes that interleave their discrete transitions and synchronize their flows, the compositionality results for modes lift in a natural way to agents too. The operations on agents are compositional with respect to refinement. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>. , y n } be indexed sets of variables with</head><formula xml:id="formula_21">V 1 ⊆ A.V and let V h ⊆ A.V . Then A\{V h } B\{V h }, A[V 1 := V 2 ] B[V 1 := V 2 ] and A 1 ||A 2 B 1 ||B 2</formula><p>In our example, Tank||Controller Tank||Controller' by Theorem 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusions</head><p>We have presented a hierarchical modular semantics for hybrid systems. The proposed semantics is compositional both with respect to the system architecture (parallel</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Closed modes</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>The refinement operator is compositional with respect to the encapsulation: Theorem 2. (Submode compositionality) Given a mode N , suppose SM SN and let M = N [SM/SN ]. Then M N .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Definition 7 .</head><label>7</label><figDesc>(Context traces) An execution of a mode context C with holes G 1 . . . G k is a path (e 0 , s 0 ) λ1 →(e 1 , s 1 ) λ2 → . . . λn →(e n , s n ) through the graph of R of C with λ i = for each e i , e i+1 such that e i is in C.X and e i+1 is in C.E or e i is in G j .E and e i+1 is in G j .X, for 1&lt;j&lt;k. A trace of C is obtained by projecting an execution on its global variables. As with modes, the set of traces of a context C is denoted by L C and refinement is defined by language inclusion. Given a context C with holes G 1 , . . . G k and a set of modes N 1 , . . . N k such that N i G i for 1&lt;i&lt;k, we write C[N 1 , . . . N k ] the mode obtained by filling the holes G i of C with N i . Contexts are also compositional. Theorem 3. (Context compositionality) Let C 1 and C 2 be compatible contexts with holesG 1 . . . G k . If C 1 C 2 then C 1 [N 1 , . . . , N k ] C 2 [N 1 , . . . , N k ]for any set N i , 1&lt;i&lt;k of modes compatible with the holes, i.e., N i G i for all i.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Refinement example</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Definition 8 .</head><label>8</label><figDesc>(Refinement) An agent A and an agent B are said to be compatibleif A.V g = B.V g . Agent A refines a compatible agent B, denoted A B, if L A ⊆L B .Theorem 4. (Agent compositionality)Given compatible agents such thatA B, A 1 B 1 and A 2 B 2 . Let V 1 = {x 1 , . . . , x n }, V 2 = {y 1 , . .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>shows the behavior of the agent Controller. The top-level mode of Controller has two submodes, Normal and Emergency. We do not show the details of the mode Emergency. It is activated when the level enters the critical region.</figDesc><table><row><cell>Normal</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>local analog real</cell><cell>t</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Compute</cell><cell></cell></row><row><cell cols="2">local discrete real rate</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>local discrete real est</cell><cell></cell></row><row><cell cols="2">t 0 level, infusion Compute e x global analog real</cell><cell>level dx</cell><cell cols="2">Emergency de [2,10] ∉</cell><cell></cell><cell>de</cell><cell cols="3">est d(infusion) = est-1 ... rate ComputeHigh global discrete real rate global analog real level, infusion ... dx</cell></row><row><cell cols="2">t=10 d(infusion) = rate dx de Maintain {t&lt;10} ∈ [2,10]} {level d(t) = 1</cell><cell cols="2">de level ∈ [4,8]</cell><cell>dx</cell><cell>e</cell><cell>de</cell><cell>est level ≥ 5 ... level &lt; 5 ComputeLow rate d(infusion) = est+1</cell><cell>...</cell><cell>dx</cell><cell>x</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>,dx ; that is, the step is a discrete step by one of the modes.Note that environment steps in agents and in modes are different. In an agent, an environment step may contain only discrete steps, since all agents participate in every continuous step. The environment of a mode can engage in a number of continuous steps while the mode is inactive.</figDesc><table><row><cell cols="6">Definition 5. (Trace semantics for agents) A trace of A is an execution of A, pro-</cell></row><row><cell cols="6">jected onto the set of its global variables. The denotational semantics of an agent</cell></row><row><cell cols="2">consists of its set of global variables and its set of traces.</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="5">Let A be a primitive agent and (init, s 0 ) →(dx, s 1 ) o →(c 2 , s 2 ) λ1 → . . . λ2</cell><cell>λn-1 → (c n , s n ) be</cell></row><row><cell>a trace of its top-level mode. It is easy to see that s 0</cell><cell>o →s 1</cell><cell>λ1 →s 2</cell><cell>λ2 → . . .</cell><cell cols="2">λn-1</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Other treatments of interrupts can be handled equally well within the proposed framework. For example,<ref type="bibr" target="#b1">[2]</ref> discuss weak interrupts in a similar setting.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p><ref type="bibr" target="#b1">2</ref> Charon refines the set of global variables further according to allowed read/write access, but we won't make such a distinction in this paper for clarity of presentation.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>The semantics does not depend on how sets of flows are specified. Here, we chose one of the possible ways.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>agents and their subagents) and the system behavior (modes and their submodes). We have introduced the notion of refinement between the system components -both modes and agents -and showed that, in the proposed semantics, composition of components preserves refinement.</p><p>We are currently working to build upon the presented compositionality results and provide assume-guarantee proof rules for hybrid systems, extending the results of <ref type="bibr" target="#b1">[2]</ref>. The proposed semantics have been used in the modeling language Charon <ref type="bibr" target="#b2">[3]</ref> and its toolkit, currently under development by the authors. For further details, see http://www.cis.upenn.edu/mobies/charon/.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This research was supported in part by NSF CCR-9988409, ARO DAAG55-98-1-0466, DARPA ITO MOBIES F33615-00-C-1707, DARPA ITO MARS program, grant no. 130-1303-4-534328-xxxx-2000-0000, and ONR N00014-97-1-0505 (MURI).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The algorithmic analysis of hybrid systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Courcoubetis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Halbwachs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Nicollin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Olivero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sifakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yovine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">138</biblScope>
			<biblScope unit="page" from="3" to="34" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Modular refinement of hierarchic reactive machines</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Grosu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th Annual ACM Symposium on Principles of Programming Languages</title>
		<meeting>the 27th Annual ACM Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="390" to="402" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Modular specifications of hybrid systems in Charon</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Grosu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Hur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hybrid Systems: Computation and Control, Third International Workshop</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1790</biblScope>
			<biblScope unit="page" from="6" to="19" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Modularity for timed and hybrid systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CONCUR &apos;97: Eighth International Conference on Concurrency Theory</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1243</biblScope>
			<biblScope unit="page" from="74" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Unified Modeling Language User Guide</title>
		<author>
			<persName><forename type="first">G</forename><surname>Booch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Jacobson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rumbaugh</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Addison Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Overview of the Ptolemy project</title>
		<author>
			<persName><forename type="first">J</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Goel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hylands</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kienhuis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Muliadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Neuendorffer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Reekie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Smyth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tsay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Xiong</surname></persName>
		</author>
		<idno>UCB/ERL M99/37</idno>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
		<respStmt>
			<orgName>University of California at Berkeley</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">SHIFT: a formalism and a programming language for dynamic networks of hybrid automata</title>
		<author>
			<persName><forename type="first">A</forename><surname>Deshpande</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Göllu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Varaiya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hybrid Systems V, LNCS 1567</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A Modular Visual Model for Hybrid Systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Grosu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Stauner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Broy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FTRTFT&apos;98: Formal Techniques in Real Time and Fault Tolerant Systems</title>
		<title level="s">LNCS</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1486</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Statecharts: A visual formalism for complex systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="231" to="274" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Masaccio: a formal model for embedded components</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCS 00: Theoretical Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1872</biblScope>
			<biblScope unit="page" from="549" to="563" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
		<title level="m">Communicating Sequential Processes</title>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Hybrid I/O automata</title>
		<author>
			<persName><forename type="first">N</forename><surname>Lynch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Segala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Vaandrager</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Weinberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hybrid Systems III: Verification and Control</title>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1066</biblScope>
			<biblScope unit="page" from="496" to="510" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">From timed to hybrid systems</title>
		<author>
			<persName><forename type="first">O</forename><surname>Maler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Real-Time: Theory in Practice</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">600</biblScope>
			<biblScope unit="page" from="447" to="484" />
		</imprint>
	</monogr>
	<note>REX Workshop</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A Calculus of Communicating Systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">92</biblScope>
			<date type="published" when="1980">1980</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
