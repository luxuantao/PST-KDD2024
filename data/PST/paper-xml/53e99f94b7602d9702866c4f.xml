<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Proving pointer programs in Hoare Logic</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Richard</forename><surname>Bornat</surname></persName>
							<email>richard@dcs.qmw.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution" key="instit1">Queen Mary and Westfield College</orgName>
								<orgName type="institution" key="instit2">University of London</orgName>
								<address>
									<postCode>LONDON E1 4NS</postCode>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Proving pointer programs in Hoare Logic</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">EBB47EAB1E45FD8E7673195321A5A3D2</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:18+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>It is possible, but difficult, to reason in Hoare logic about programs which address and modify data structures defined by pointers. The challenge is to approach the simplicity of Hoare logic's treatment of variable assignment, where substitution affects only relevant assertion formulae. The axiom of assignment to object components treats each component name as a pointerindexed array. This permits a formal treatment of inductively defined data structures in the heap but tends to produce instances of modified component mappings in arguments to inductively defined assertions. The major weapons against these troublesome mappings are assertions which describe spatial separation of data structures. Three example proofs are sketched.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The power of the Floyd/Hoare treatment of imperative programs <ref type="bibr" target="#b9">[8]</ref> <ref type="bibr" target="#b12">[11]</ref> lies in its use of variable substitution to capture the semantics of assignment: simply, R E</p><p>x , the result of replacing every free occurrence of variable x in R by formula E, is the precondition which guarantees that assignment x E : = will terminate in a state satisfying R. <ref type="foot" target="#foot_0">1</ref> At a stroke difficult semantic questions that have to do with stores and states are converted into simpler syntactic questions about first-order logical formulae.</p><p>We encounter several difficulties when we attempt to use a similar approach to deal with programs which manipulate and modify recursive data structures defined by pointers. The first difficulty, whose solution has been known for some time, is aliasing: distinct and very different pointer formulae may refer to the same object. The second difficulty is the treatment of assertions which include inductive formulae describing heap data structures. The final difficulty is the complexity of the proofs: not only do we have to reason formally about sets, sequences, graphs and trees, we have to make sure that the locality of assignment operations is reflected in the treatment of assertions about the heap.</p><p>For all of these reasons, Hoare logic isn't widely used to verify pointer programs. Yet most low-level and all object-oriented programs use heap pointers freely. If we wish to prove properties of the kind of programs that actually get written and used, we shall have to deal with pointer programs on a regular basis. © Springer-Verlag; to appear in Proceedings of <ref type="bibr">MPC 2000</ref> In one situation program verification is a practical necessity. The idea of 'proofcarrying code' (see, for example, Necula and Lee <ref type="bibr" target="#b23">[22]</ref> and Appel and Felty <ref type="bibr" target="#b0">[1]</ref>) is that programs should be distributed along with a proof of their properties, the proof to be checked by each user before the program is used. Machine checkers are simple, reliable and fast, so if appropriate proofs can be provided we won't have to spend ages reading the fine print before running our latest downloaded system extension.</p><p>Proof-carrying code is a long way off, but being able to deal effectively with pointer programs will take us a step along the way.</p><p>This paper is therefore about verifying the properties of programs. It is not about proof development, but it is not intended as a challenge to those who prefer program refinement to program verification. Once we can make reliable proofs about imperative pointer algorithms, surely the mechanisms developed to support proof can be used in aid of other activities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Background</head><p>This paper was inspired by the work of Morris, who put forward in 1981 <ref type="bibr" target="#b22">[21]</ref> axioms for assignment to object components, described a mechanism for dealing with inductively defined data structures and presented a semi-formal proof of the Schorr-Waite graph marking algorithm. Earlier still, Burstall presented in 1972 <ref type="bibr" target="#b5">[6]</ref> a treatment of list-processing algorithms and pointed out the analogy between the treatment of array element and object components; his Distinct Non Repeating List Systems made possible succinct and convincing proofs of list and tree algorithms. Recently Reynolds <ref type="bibr" target="#b25">[24]</ref> revisited Burstall's work, refining the treatment of spatial separation between objects and data structures in the heap and extending its range of application, but working with forward rather than backward reasoning.</p><p>Attempts have been made to apply Hoare logic to pointer programs by incorporating a model of the store, or part of the store, into the assertion logic. Luckham and Suzuki <ref type="bibr" target="#b20">[19]</ref>, Leino <ref type="bibr" target="#b19">[18]</ref> and Bijlsma <ref type="bibr" target="#b2">[3]</ref>, for example, identify a subsection of the heap with each pointer type. Kowaltowski <ref type="bibr" target="#b17">[16]</ref> includes the entire heap.</p><p>Other work recognises the analogy between array element and object component assignment but doesn't do so effectively: both Hoare and Wirth <ref type="bibr" target="#b14">[13]</ref> and Gries and Levin <ref type="bibr" target="#b11">[10]</ref>, for example, give an axiom for object-component assignment which deals only with the simplest non-pointer cases and neglects entirely to deal with pointer aliasing.</p><p>Cousot <ref type="bibr" target="#b6">[7]</ref> gives a brief survey of other work, most of which is semantic in character and does not address the practical concerns of program verification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Notation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I write → ∧ ∨ ¬</head><p>, , , for logical implication, conjunction, disjunction and negation; = means equal by definition; @ is append (sequence concatenation); / ∩ is disjointness of sequences; ∈ is sequence and/or set membership. E F x is the result of substituting © Springer-Verlag; to appear in Proceedings of MPC 2000 formula F for every free occurrence of variable x in formula E. A B E ⊕ a is a mapping which is everywhere the same as A, except at B which it maps to E. I use ⇒ f to define f-linked sequence data structures from section 6 onwards.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The Problem of Aliasing</head><p>The Hoare logic treatment of assignment is sound when we are sure that distinct variable names refer to distinct storage locations; it can mislead if that assurance is lost. Aliasing, which occurs when distinct formulae describe the same storage location, comes in at least the following range of flavours.</p><p>• Parameter aliasing is the best known and probably the most difficult to deal with. It arises during the execution of procedures and functions, when a call-by-reference parameter (a var parameter in Pascal <ref type="bibr" target="#b15">[14]</ref>, for example) stands for a storage location outside the procedure which is also nameable in another way from within the procedure. [ ] are the same storage location just when I J = as integers.</p><p>• Pointer aliasing, analysed below, arises when an object (a node, a record) can be referred to indirectly via a pointer value.<ref type="foot" target="#foot_1">1</ref> • Overlap aliasing occurs when storage locations can contain storage locations, as when an object is updatable by assignment, simultaneously updating all of its components, and those components are each separately updatable storage locations. • View aliasing occurs when the same area of store can be addressed in different ways, as with Pascal variant records, C <ref type="bibr" target="#b16">[15]</ref> union types, or C casting.</p><p>Aliasing is caused by identity or overlap of lvalues (addresses of objects in the store, see Strachey <ref type="bibr" target="#b27">[26]</ref>), but both subscript and pointer aliasing can be dealt with by comparing rvalues (contents of storage locations). That makes them in principle tractable in the Floyd/Hoare tradition, which deals entirely with rvalues. Parameter, overlap and view aliasing are outside the scope of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Subscript Aliasing</head><p>Distinct formulae indexing the same array will be equivalent as lvalues if the rvalues of their subscript expressions are equal. The Pascal program fragment</p><formula xml:id="formula_0">b[i]:=b[j]+1; if b[i]=b[j]</formula><p>then writeln(output, "aliased!") else writeln(output, "distinct") © Springer-Verlag; to appear in Proceedings of MPC 2000 will print aliased! when i=j, or distinct when i&lt;&gt;j.</p><p>Following McCarthy and Painter <ref type="bibr" target="#b21">[20]</ref> and Hoare and Wirth <ref type="bibr" target="#b14">[13]</ref>, there's a wellknown solution to subscript aliasing. Even though, in every practical implementation of a programming language, an array is a collection of separately addressable storage locations, it can be treated as if it was a single variable containing a mapping from indices to rvalues. ) [ ]</p><formula xml:id="formula_1">a = if then else fi I J E b J = [ ] (</formula><p>) .</p><p>This interpretation of array element assignment is a complete solution to the problem of subscript aliasing, though it must be used carefully with concurrent assignments in case there are aliases in the set of assigned locations. It resolves the problem entirely by the rvalue comparison I J = in the reduction rule, even though aliasing is between lvalues b I [ ] and b J [ ].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Pointer Aliasing</head><p>In practice a computer memory is a giant array, and memory addresses -the primitive mechanism underlying lvalues and pointers -are its indices. Whenever two distinct occurrences of pointer values are equal, we have pointer aliasing. Consider, for example, the problem (part of the in-place list-reversal example below) of moving an element from the head of one tl-linked list r to the head of a similar list p, using assignment to heap object components. If we write it as a sequence of non-concurrent assignments 1 we must use an auxiliary variable q and a sequence of at least four instructions, one of which alters a pointer in the heap. This is one solution: q r r r tl qtl p p q : : :</p><formula xml:id="formula_2">: = = = = ;</formula><p>. ; . ;</p><p>At every intermediate stage of execution of this program there is more than one way to refer to particular objects in the store. After the first assignment, q and r are the same pointer; after the second, q.tl and r; after the third, q.tl and p; after the last, p and q. If the p and r lists aren't disjoint collections of objects, still more aliasing may be produced.</p><p>It's tempting to treat the heap as a pointer-indexed array of component-indexed objects, perhaps subdividing it by object type into sub-arrays (see, for example, Luckham and Suzuki <ref type="bibr" target="#b20">[19]</ref> and Leino <ref type="bibr" target="#b19">[18]</ref>). But in practice this has proved awkward to deal with. First, it means there has to be a translation between object-component formulae in the program on the one hand and array-indexing formulae in assertions on the other. Second, it forces us towards 'global reasoning': every object component assignment seems to affect every assertion which has to do with the heap. By contrast the Floyd-Hoare treatment of assignment to a variable concentrates attention on assertions that involve that variable, leaving others untouched, making steps of 'local reasoning' whose restriction to particular formulae matches the locality of assignment<ref type="foot" target="#foot_2">1</ref> I do not consider concurrent assignment in this paper. © Springer-Verlag; to appear in Proceedings of MPC 2000 to a single variable. Third, our assertions about the content of the heap usually need to be expressed inductively, using auxiliary definitions which can easily hide aliases.</p><p>Even though these difficulties might in principle be overcome, it feels like the wrong thing to do: we don't program with a memory array in mind but rather in terms of distinct variables, arrays, objects and components, and our reasoning should as far as possible operate at the same level as our thinking.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">The Treatment of Subscript Aliasing</head><p>In <ref type="bibr" target="#b22">[21]</ref> Morris introduced an assignment rule for assignment to components of heap objects which generalised Burstall's treatment <ref type="bibr" target="#b5">[6]</ref> of hd/tl structures. He gave a treatment of inductively defined data structures using the notion of paths between objects, and presented a proof of the Schorr-Waite graph-marking algorithm <ref type="bibr" target="#b26">[25]</ref> which seems far closer to a proof of the original than other published treatments <ref type="bibr" target="#b10">[9]</ref>[28].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Morris's Treatment</head><p>Morris treats a language which is like Java <ref type="bibr" target="#b1">[2]</ref> in that it has pointer-aliasing but no parameter-aliasing, and no whole-object assignment. Program (stack) variables like x, y, p, q can hold pointers to objects in the heap. Objects (in the heap) have components indexed by names like e, f, g, h and are referred to using dot-suffix notation, for example p.e.e.f.</p><p>Because there is no whole-object assignment, aliasing is only of components of objects. Because there is no arithmetic on component names we know immediately, when e and f are distinct component names and no matter what the values of A and B, that A.e can't be the same lvalue as B.f. Similarly, we know that A.e and B.e will be the same lvalue just when the rvalues A and B are equal. 1 Lvalue-aliasing of object components can therefore be detected by identity of component name and rvalue comparison of pointers.</p><p>These insights made it possible to define a rule for object-component assignment which avoids mentioning the memory array altogether:</p><formula xml:id="formula_3">Q R Q A f E R E A f → { } = { } / .</formula><p>. :</p><formula xml:id="formula_4">Object component substitution R E A f</formula><p>/ . is just like variable substitution except when it is dealing with object component references. Morris's axioms appear to be:</p><formula xml:id="formula_5">B g B g E A f f g . ˆ.</formula><p>/ .</p><p>( ) = ( )</p><formula xml:id="formula_6">and distinct B f A B E B f E A f . ˆif then else . fi / , ( ) = =</formula><p>Formally, this treatment deals only with single occurrences of component names in object component formulae -p.hd and p.tl are dealt with correctly, for example, but © Springer-Verlag; to appear in Proceedings of MPC 2000 p.hd.tl isn't -so it is valid only with a restricted programming language and a restricted vocabulary of assertion logics. There are similar axioms for assignment to array elements, similarly flawed</p><formula xml:id="formula_7">-b i [ ] is dealt with, but not b b i [ ] [ ] . 1</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Calculating Object-Component Assignment Axioms</head><p>It is possible to calculate object-component substitution axioms which work without restriction in Morris's target language. Since objects can't overlap, we can treat the heap as a pointer-indexed collection of objects, each of which is a name-indexed collection of components. An object-component reference A . f in a heap H corresponds to a double indexing, once of the heap and once of the object.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>! " ! "</head><formula xml:id="formula_8">H H H A f A f . = [ ] [ ]</formula><p>Assigning a value to A.f replaces the object H A [ ] with a new mapping and therefore the heap becomes a new mapping as well:</p><formula xml:id="formula_9">! " ! " ! " ! " ! " H H H H H H H H F F A A f E E A f / . = ′ ′= ⊕ ( ) [ ] ⊕ ( )     , where a a</formula><p>When f and g are distinct component names: © Springer-Verlag; to appear in Proceedings of MPC 2000</p><formula xml:id="formula_10">! " ! " ! " ! " H H H H H H B g B g B g B g E A f E A f . . / . / . ( ) = ′ = ′ ′ [ ] [ ] ′ [ ] [ ] = = ( ) [ ] ⊕ ( )     [ ] [ ] ⊕ H H H H H H ! " ! " ! " ! " A A f E B g E A f a a / . = = [ ] ⊕ ( ) [ ]     [ ] if then else fi ! " ! " ! " ! " ! " H H H H H H H A B A f E B g E A f E A f / . / . a = = [ ] ⊕ ( ) [ ] [ ] [ ] if then else fi ! " ! " ! " ! " ! " H H H H H H H A B A f E g B g E A f E A f / . / . a = = [ ] [ ] [ ] [ ] if then else fi ! " ! " ! " ! " H H H H H H A B A g B g E A f E A f / . / . = = [ ] [ ] [ ] [ ] if then else fi ! " ! " ! " ! " H H H H H H A B B g B g E A f E A f E A f / . / . / . = [ ] [ ] = ( ) H H ! " ! " B g B g E A f E A f / . / . . With identical component names: ! " ! " ! " ! " H H H H H H B f B f B f B f E A f E A f . . / . / . ( ) = ′ = ′ ′ [ ] [ ]= ′ [ ] [ ] = ⊕ ( ) [ ] ⊕ ( )     [ ] [ ] H ! " ! " ! " ! " H H H H H A A f E B f E A f a a / .</formula><formula xml:id="formula_11">= = [ ] ⊕ ( ) [ ]     [ ] if then else fi ! " ! " ! " ! " ! " H H H H H H H A B A f E B f E A f E A f / . / . a = = [ ] ⊕ ( ) [ ] [ ] [ ] if then else fi ! " ! " ! " ! " ! " H H H H H H H A B A f E f B f E A f E A f / . / . a = = ( ) if then else fi ! " ! " ! " ! " H H H H A B E B f E A f E A f / . / . . = = ( ) ! " H if then else fi A B E B f E A f E A f / . / . .</formula><p>In each case the calculated equivalence leads to an axiom which is identical to Morris's except that B on the right-hand side of the axiom is replaced by B E A f / . .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">The Component-as-Array Trick</head><p>The axioms for object component substitution, following an assignment A f E . := , for distinct component names f and g, are</p><formula xml:id="formula_12">B g B g E A f E A f . ˆ. / . / .</formula><p>( ) = ( )</p><formula xml:id="formula_13">B f A B E B f E A f E A f E A f . ˆ. / . / . / . ( ) = = ( ) if then else fi</formula><p>The standard treatment of an assignment b I</p><formula xml:id="formula_14">E [ ] = : gives us for distinct arrays b and c c J c J b I E b b I E b [ ] = [ ] ⊕ ⊕ a a b J b I E J I J E b J b I E b b I E b b I E b b I E b [ ] = ⊕ ( ) [ ] = = [ ] ⊕ ⊕ ⊕ ⊕ a a a a a if then else fi</formula><p>It is clear from the correspondence between these treatments that object-component substitution is formally equivalent to a treatment of object components as pointerindexed arrays. That is, assignment to component f of an object pointed to by A can be treated as if it were an assignment to the A-indexed component of an array f, and access to the f component of an object pointed to by A as selection of the Ath component of an array f. This observation is certainly not novel: Burstall gives an equivalent in <ref type="bibr" target="#b5">[6]</ref>, and it may be that Morris intended this reading in <ref type="bibr" target="#b22">[21]</ref>. It is worth stating clearly, however, to clarify what seems otherwise to be imperfectly understood 'folk knowledge'.</p><p>The advantages of the component-as-array treatment are considerable. First of all, it is obvious that it enables the calculation of weakest preconditions. Second, it means that we don't need a new structural induction to deal with object component substitution: a considerable advantage when mechanising proof and proof-checking. Finally, and most importantly in the context of this paper, it makes possible a formal treatment of object component substitution into inductively defined formulae.</p><p>I feel it's necessary, despite its advantages, to emphasise that the treatment is doubly a trick. It's a trick built on the array-as-mapping trick of McCarthy and Painter. It's violently at odds with our understanding of how heaps work in practice. It isn't clear how much of it would survive a relaxation of the restrictions we have imposed on our programming language. © Springer-Verlag; to appear in Proceedings of MPC 2000</p><formula xml:id="formula_15">Q R Q x E R E x → { } = { } : Q R Q A f E R f A E f → { } = { } ⊕ a</formula><p>. : </p><formula xml:id="formula_16">Q S R R R Q S R { } ′ { } ′ → { } { } Q P P B S P P B R P B t P B t vt S t vt Q B S R → ∧ { } { } ∧ ¬ → ∧ → &gt; ∧ ∧ = { } &lt; { } { } { } 0 while do od Q B S R Q B S R Q B S S R then else then else ∧ { } { } ∧ ¬ { } { } { } { } if then else fi Q S1 Q Q S2 R Q S1 S2 R { } ′ { } ′ { } { } { } { } ;</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Restricted Global Reasoning</head><p>If we treat the heap as a global array, and convert all our object component assignments to heap-array element assignments, then we have global reasoning, because substitution of a new mapping for the heap array affects every assertion about any part of the heap. By contrast the Floyd-Hoare treatment of variable assignment gives us local reasoning: only those assertions which mention the assigned variable are affected by substitution. Object component substitution and the component-as-array trick each offer a restricted global reasoning. Some locality is achieved effortlessly, when formulae which only mention component f aren't affected by assignment to component g. But on the other hand the interaction of assignment with inductive definitions, discussed below, needs careful treatment if a global reasoning explosion is to be avoided.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Hoare-Triple Rules</head><p>I consider a language which has assignment to variables and object components, while-do-od, if-then-else-fi and instruction sequence (fig. <ref type="figure" target="#fig_2">1</ref>). The usual caveats apply to the while-do-od rule: vt must be a fresh variable, t must be an integer-valued function of the state. It is useful to include a postcondition-strengthening rule.</p><formula xml:id="formula_17">Component indexing A B C E . ⊕ ( ) a is equivalent to if then else fi A C E A B = ( )</formula><p>. . I omit from the rules anything which requires definedness of formulae. Definedness is especially important in pointer-manipulating programs, because nil is such a dangerous value -often in use, of pointer type, and yet not dot-suffixable. Nevertheless, it would add little to the discussion in this paper to deal with definedness, if only because my examples don't attempt to traverse nil pointers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Three Small Examples</head><p>Cycles in the heap show pointer aliasing in its rawest form. Three small mechanical proofs, calculated in Jape <ref type="bibr" target="#b4">[5]</ref>, are shown in full detail except for trivial implications. The proof (fig. <ref type="figure">2</ref>) consists of a use of the assignment rule (line 5) followed by three applications of component-indexing simplification on lines 4, 3 and 2.</p><p>Next, a multi-step cycle established by a sequence of two assignments. The proof (fig. <ref type="figure">3</ref>) consists of an application of the sequence rule (line 9), two applications of the assignment rule (lines 8 and 5) and various uses of componentindexing simplification. Note that we can't simplify q b c a p q . . . ⊕ ( ) a on line 6, but the mapping can be eliminated on line 3, once q.b.c has been simplified to p.</p><p>If we make the same cycle with the same instructions, but executed in the reverse order (fig. <ref type="figure">4</ref>), neither of the mappings generated by the assignment rule on line 8 can be eliminated immediately, but they are dealt with eventually, on lines 4 and 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Substitution and Auxiliary Definitions</head><p>When we make proofs of programs which manipulate heap objects using pointers, our assertions will usually call upon auxiliary definitions of data structures. Auxiliary definitions are useful for all kinds of reasons: they allow us to parameterise important assertions in user-defined predicates, they let us define inductive calculations, they shorten descriptions. But the Floyd/Hoare mechanism, even in the absence of pointer aliasing, has difficulty with assertions which contain arbitrary auxiliary defined formulae (henceforth adfs).</p><p>If, for example, we define a predicate F ẑ x z</p><formula xml:id="formula_18">( ) = = ( )</formula><p>then F y ( ) both asserts that y has the same value as x and contains an implicit occurrence of x. Substitution deals only with explicit occurrences, so the variable assignment rule would seem to allow us to conclude mistakenly</p><formula xml:id="formula_19">F : F y x x y ( ) { } = + ( ) { }<label>1</label></formula><p>The difficulty would disappear if we were to insist that adfs are expanded from their definitions before we use substitution. That would not merely be inconvenient but impossible in general, because inductive definitions can expand indefinitely. If we insist, however, that definitions are program-variable closed -that is, that they have no free occurrences of variable names which can be the target of substitution -then we can deal with them in unexpanded form.</p><p>For example, we might define F , û v u v</p><formula xml:id="formula_20">( )= =</formula><p>and the assignment rule would correctly calculate</p><formula xml:id="formula_21">F , : F , x y x x x y + ( ) { } = + ( ) { } 1 1</formula><p>The problem of auxiliary definitions of heap data structures is not quite so easy to solve. Reynolds <ref type="bibr" target="#b24">[23]</ref> deals with assertion procedures, but his intentions and his approach are quite distinct from that developed below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Inductive Auxiliary Definitions of Data Structures</head><p>Pointer-linked data-structure definitions are usually inductively defined. Indeed it is difficult to see how we could do without induction when specifying programs which manipulate data structures via pointers. Making them program-variable closed doesn't deal with object component assignment, but the component-as-array trick allows us to make them component-array closed as well.</p><p>Following Burstall, Morris and Reynolds, an example data structure which uses a component array parameter is the sequence of objects <ref type="foot" target="#foot_4">1</ref> A B f ⇒ generated by starting © Springer-Verlag; to appear in Proceedings of MPC 2000 For various reasons (not least the fact that nil doesn't point to an object), B isn't included in the sequence. The definition is both program-variable and componentarray closed: it mentions nothing but constants and its parameters A, B and f. The sequence it generates isn't necessarily a list -that is, a finite sequence with no repetitions -because cycles in the heap may mean that we never reach B. It will not be defined if we attempt to traverse a nil pointer before reaching B.</p><formula xml:id="formula_22">A B A B A A f B f f ⇒ = = ⇒ ( ) ˆ@ . if then else fi</formula><p>If we consider objects with hd and tl components, as in the list reversal and list merge examples below, then p tl ⇒ nil can represent what we normally think of as 'the list p' (fig. <ref type="figure">6</ref>). If p and q point to distinct objects, then p q tl ⇒ describes a list fragment, the sequence of objects linked by tl components starting with the one pointed to by p up to but not including the one pointed to by q (fig. <ref type="figure">7</ref>). In each of these examples I have assumed that the data structure is acyclic. What imperative graph, tree and list algorithms all seem to do is to work with disjoint bits of data structures, nibbling away at the edges, moving a node from here to there, swinging pointers, altering values in exposed components. The locality of assignment means that changes made in one area of the heap don't affect objects elsewhere. But because pointer aliasing is always a possibility, our reasoning must continually take into account the possibility that the location we are altering is referred to under another name. In practice we take that possibility into account most often in order to dismiss it. Our logic must make this easy to do, and we must choose our assertions to exploit this capability. Substitution into x y f ⇒ , as a result of the assignment A f E . := , generates x y</p><p>f A E ⇒ ⊕ a . That expands to give a formula which contains indefinitely many occurrences of the mapping</p><formula xml:id="formula_23">f A E ⊕ a , i n x f A E . ⊕ ( ) a , x f A E f A E . . ⊕ ( ) ⊕ ( )</formula><p>a a , and so on. This explosion of effects, produced by an assignment which affects only a single location, must either be avoided or effectively dealt with. It arises with any inductive auxiliary definition which has a componentarray parameter.</p><p>By contrast, assignment is operationally local. Consider, for example the p q tl ⇒ data structure of fig. <ref type="figure">7</ref>. Executing p tl q . := will swing the pointer in the first box to point at the last, changing the data structure to that in fig. <ref type="figure">8</ref>.</p><p>Only one component of the heap changes because of the assignment. The challenge is to imitate this simplicity in our reasoning, to avoid an explosion of mappings and combat what Hoare and Jifeng <ref type="bibr" target="#b13">[12]</ref> call 'the complexity of pointer-swing'.</p><p>In this particular case the result of substitution is easy to unravel:</p><formula xml:id="formula_24">p q p q tl tl p q tl tl p q ⇒ ( ) = ⇒ ⊕ ⊕ a a = = ⊕ ( )⇒ ⊕</formula><p>if then else fi p q p p tl p q q tl p q @ . a a = = ⇒ ⊕ if then else fi p q p q q tl p q @ a © Springer-Verlag; to appear in Proceedings of MPC 2000</p><formula xml:id="formula_25">= = if then else fi p q p @ = = if then else fi p q p</formula><p>Not every example is so straightforward. Consider the effect of the assignment x tl y . := on the postcondition x x tl ≠ ∧ ⇒ ( ) nil list nil , where the list predicate 1 asserts that a sequence is finite and non-repetitive. We may proceed with substitution, expansion and simplification as before: What's surprising is that lists and sequences aren't a special case. Spatial separation is exactly what we need to deal in general with inductively defined heap data structures. Any data structure in a finite heap depends on the component values of a finite set of objects. If we assign to a component of an object outside that set, the data structure can't be affected. Faced with an adf whose arguments include a mapping B A E ⊕ a , therefore, we can either expand it until all the affected objects are exposed -as, for example, we expanded x tl x y ⇒ ⊕ a nil above -or we can show that because of spatial separation the mapping is never used, no matter how far we expand the formula -as in the case of y tl x y ⇒ ⊕ a nil above -or we can do both steps, one after the other -or we are stuck for the moment, and we have to leave the mapping alone.</p><formula xml:id="formula_26">x x x x tl tl x y tl tl x y ≠ ∧ ⇒ ( ) ( ) = ≠ ∧ ⇒ ( ) ⊕ ⊕ nil list nil nil list nil a a = ≠ ∧ = ⊕ ( )⇒ ( ) ⊕ x x x</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Spatial Separation Examples</head><p>Spatial separation of a data structure and an object A can always be expressed as A S ∉ , where S is a set of objects whose component values define the data structure.</p><p>In straightforward cases, like the ⇒ f definition of fig. <ref type="figure">5</ref>, the set of objects is just the data structure itself.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Offset Sequences. Consider the definition</head><formula xml:id="formula_27">A B A B Af f Ag B f g f g ˙˙ˆ. . @ . ˙, , ⇒ = = ⇒ if</formula><p>then else fi © Springer-Verlag; to appear in Proceedings of MPC 2000</p><p>The formula p q hd tl ˙˙, ⇒ describes a sequence of objects not necessarily linked together, and offset by two steps from p q tl ⇒ (fig. <ref type="figure">9</ref>). Assignment to A.hd or A.tl may alter the sequence, but the sets of objects which support the description differ between cases, and neither of them is the sequence itself.</p><p>Ordered Sequences. The predicate olist f asserts that a particular sequence of objects is ordered by ≤ ( ) in its f component:</p><formula xml:id="formula_28">olist olist olist @ , @ ˆolist @ . . olist @ f f f f f A R A B S R A A f B f B S ( )= ( )∧ ≤ ∧ ( )</formula><p>The sequence of objects S which olist f S ( ) asserts is ordered don't have to be linked together in the heap. An assignment A f E . := doesn't affect the assertion just when A S ∉ .</p><p>If we combine definitions then we have to be careful. The assertion olist nil hd tl</p><p>x ⇒ ( ) uses both the olist f and the ⇒ f definitions to state that a particular linked sequence in the heap is ordered: the assertion is unaffected by A tl E . := when A x tl / ∈ ⇒ nil -because that is the condition which makes sure that the sequence x tl ⇒ nil remains the same -and unaffected by A hd E . := in exactly the same circumstances, even though that assignment doesn't alter the objectsequence itself.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Cyclic Graphs. The set of nodes in a directed binary graph reachable through a pointer A is</head><formula xml:id="formula_29">A A A Al Ar l r l r l r * ˆnil . * . * , , , = = { } { }∪ ∪ if then else fi</formula><p>The assignment p l q . := , given the postcondition p p l r ≠ ∧ ( ) nil G * , , where G is some predicate, will generate the precondition p p q pr l p q r l p q r</p><formula xml:id="formula_30">≠ ∧ { }∪ ∪ ( ) ⊕ ⊕ nil G * . * , , a a</formula><p>We can expect our graphs to be cyclic, so the occurrences of the mapping l p q ⊕ a in this formula will give us problems.</p><p>In this case it is helpful to rewrite the definition to make spatial separation easier to establish. It's simple to calculate reachable nodes using a directed acyclic graph (DAG), breaking cycles by including an exclusion set S in the definition:</p><formula xml:id="formula_31">A A A S A Al Ar l r S l r S A l r S A * nil . * . * , , , , , , = = ∨ ∈ { } { }∪ ∪ ∪{ } ∪{ } if then else fi</formula><p>This automatically gives spatial separation between the root node A and the subgraphs generated from the child nodes A.l and A.r. Now the assignment p l q . := . given the postcondition p p S p l r S ≠ ∧ ∉ ∧ ( ) nil G * , , , will generate p p S p q pr l p q r S p l p q r S p</p><formula xml:id="formula_32">≠ ∧ ∉ ∧ { }∪ ∪ ( ) ⊕ ∪ { } ⊕ ∪ { } nil G * . * , , , , a a</formula><p>When A S ∈ the graph B l r S * , , won't include A -that is, we have spatial separation. .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Heap Reasoning and Structural Reasoning</head><p>We can make assertions about a value represented by a heap data structure which are about the value itself and which don't involve knowledge of the heap. If it's a sequence we may remark about its length, its non-cyclic nature, the non-occurrence of 0 elements in its hd components, and so on. If it's a tree we may want to talk about its height, the balance between its subtrees, the ordering of its tips, and so on. If it's a graph we may remark about its spanning tree, its connectedness, its colouring, and so on. If we are careful, 'pure' structural reasoning can carry much of the weight of a specification and proof. On the other hand, spatial separation concerns require our heap data structure definitions to be written to expose information about the objects that support particular data structures. It seems, therefore, that specifications ought to be written at three separate levels:</p><p>1. Remarks about the contents of particular variables and objects.</p><p>2. Inductive definitions of data structures, including rules which interpret nonhiding assertions. 3. The specification of the problem, in terms of (1) and (2). We have to make our definitions carefully, both to fit our problem and to permit the easiest and most local forms of reasoning. The ⇒ f definition of fig. <ref type="figure">5</ref> is good for acyclic sequences, and makes it easy to reason about assignments near the head of a sequence. It's less good (see the list merge example below) when we assign to the tail of a sequence. It's not very good at all if the sequence can be cyclic, and in that case it seems reasonable to devise a special adf which deals easily with cycles.</p><p>It is interesting that remarks about individual heap cells -'pictures of memory'seem relatively unimportant in this treatment, in contrast to Reynolds <ref type="bibr" target="#b25">[24]</ref>. On the other hand, spatial separation of data structures, a clear echo of Burstall's DNRLS <ref type="bibr" target="#b5">[6]</ref> and Reynolds' spatial conjunction, is an essential part of every proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">A Worked Example: In-Place List-Reversal</head><p>The in-place list-reversal algorithm (fig. <ref type="figure" target="#fig_8">10</ref>) is the lowest hurdle that a pointeraliasing formalism ought to be able to jump. Burstall deals with it in <ref type="bibr" target="#b5">[6]</ref> with essentially the same specification as that below. In the invariant I need append (@) and rev, and I need to be able to say that a particular cell-sequence S is a list: that is, it is finite length and has no repetitions. I can only reverse finite sequences. I need disjointness ( / ∩) of sequences.</p><p>@ ˆ@ @ @ ˆ@ @ S S S S S T U S T U</p><formula xml:id="formula_33">= = ( )= ( ) rev ˆrev list list rev @ rev @rev = = ∧ → ( )= A A A B A B B A / ∩ / ∩ = ≠ / ∩ = / ∩ ( ) / ∩ = / ∩ ( )∧ / ∩ ( ) S A B A B S T T S S T U S U T U @ ˆlist list list @ ˆlist list A S T S T S T ( )= ∧ ∧ / ∩</formula><p>For proof of termination of any list algorithm, it's necessary to do arithmetic on lengths of lists. I haven't attempted a mechanical treatment: instead I've appealed to some obvious facts. list length @ length length @ list : length</p><formula xml:id="formula_34">S A S S A S S n n S n → ( )&gt; ( )&gt; → ∃ ≥ ∧ = ( )<label>0 0</label></formula><p>I use the ⇒ f definition (fig. <ref type="figure">5</ref>) to describe sequences in the heap. It's possible to prove by induction on the length of finite sequences that</p><formula xml:id="formula_35">list B C A B C B C B C tl tl tl A E tl ⇒ ( )∧ / ∩ ⇒ ( ) → ⇒ = ⇒ ( ) ⊕ a</formula><p>-a fact that is appealed to several times in the proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.2">Specification</head><p>The algorithm is given in variable p a pointer to a tl-linked list S.</p><formula xml:id="formula_36">Q p p S tl tl ˆlist nil nil = ⇒ ( )∧ ⇒ =</formula><p>The invariant of the loop is that there is a tl-linked list from p to nil, a similar but distinct list from r to nil, and the reverse of the r list, followed by the p list, is the reverse of the original input.</p><formula xml:id="formula_37">P p r p r r p S tl tl tl tl tl tl ˆlist nil list nil nil nil rev nil @ nil rev = ⇒ ( )∧ ⇒ ( )∧ ⇒ / ∩ ⇒ ∧ ⇒ ( ) ⇒ =      </formula><p>The loop measure is the length of the r list. On termination the p list is the reverse of the original input.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R p S tl ˆnil rev = ⇒ =</head><p>This specification doesn't say that on termination the hd components of S are what they originally were, though it is obvious from the program that this is so. It would be easy to change the specification to make this point by adding hd HD = to precondition, invariant and postcondition, but it would be just a drop in the ocean of the frame problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.3">Semi-Formal Proofs</head><p>These proofs are written backwards: postcondition first, working towards precondition and several substitution steps are compressed into one. The machinechecked proofs available from the web site <ref type="bibr" target="#b3">[4]</ref>, calculated with the aid of Jape <ref type="bibr" target="#b4">[5]</ref>, are less compressed.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Initialisation</head><formula xml:id="formula_38">( ) ∧ ⇒ ( ) ∧ ⇒ / ∩ ⇒ ∧ ⇒ ( ) ⇒           ⊕ ⊕ ⊕ ⊕ ⊕ ⊕ a a</formula><formula xml:id="formula_39">( )∧ ⇒ ( )∧ ⇒ / ∩ ⇒ ∧ ⇒ ( ) ⇒ = ∧ ≠          </formula><p>© Springer-Verlag; to appear in Proceedings of MPC 2000 Q q p p hd q hd r p p p tl r q q q tl s r P p q q p p hd q hd s tl p p p tl s tl q q q tl { } = ∨∨ ≠ ∧∧ ≤ ( ) </p><formula xml:id="formula_40">= = = = = { } ≠ ∨ ≠ = ∨∨ ≠ ∧∧ ≤ ( ) = = = = if then</formula><formula xml:id="formula_41">( )∧ ⇒ ( )∧ ⇒ / ∩ ⇒ ∧ ⇒ ( ) ⇒ = ∧ ≠ ∧ ⇒ ( )=          </formula><p>The While Loop P r q r r r tl q tl p p q R { } ≠ = = = { } while do ; . ; . ; := od nil : : :</p><p>Not shown: it appeals to the invariant and measure proofs above, and is otherwise straightforward sequence calculation.</p><p>The Whole Algorithm Q r p p r q r r r tl q tl p p q R { } </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">An Illustration: In-Place List Merge</head><p>The proof of in-place list reversal above is no advance on Burstall's version <ref type="bibr" target="#b5">[6]</ref>. Inplace list merge (fig. <ref type="figure" target="#fig_2">11</ref>) is a more challenging problem, because it works at the tail end of a list. The tests in the program are designed to avoid traversal of nil pointers:</p><formula xml:id="formula_42">A B ∨∨ is equivalent to if then else fi A B true ( ) ; A B ∧∧ is equivalent to if then else fi A B false ( ) .</formula><p>© Springer-Verlag; to appear in Proceedings of MPC 2000</p><p>The program is given two disjoint ordered tl-linked nil-terminated lists via pointers p and q, at least one of which is not empty.</p><formula xml:id="formula_43">Q p S P q S Q p q p q p q tl tl hd tl hd tl tl tl ˆnil nil olist nil olist nil nil nil nil nil = ⇒ = ∧ ⇒ = ∧ ⇒ ( )∧ ⇒ ( )∧ ⇒ / ∩ ⇒ ∧ ≠ ∨ ≠ ( )       Writing A B f ⇒ + for A B B f ⇒ @</formula><p>, the invariant states that we can put the list fragment r s tl ⇒ + before either the p list or the q list to produce an ordered result; that fragment joined with the two lists is a permutation of the original input; and the p and q lists remain disjoint. In order to prove that the result on termination is what we wish, it also has to assert the non-occurrence of nil in the fragment r s tl ⇒ + and a linkage between the s object and the one or other of the lists. P r s p r s q r s p q SP SQ p q r s s tl p s tl q hd tl hd tl tl tl ˆolist @ nil olist @ nil perm @ nil@ nil, @ nil nil nil . .</p><formula xml:id="formula_44">= ⇒ ⇒ ( ) ∧ ⇒ ⇒ ( ) ∧ ⇒ ⇒ ⇒ ( ) ∧ ⇒ / ∩ ⇒ ∧ ∉ ⇒ ∧ = ∨ = ( )             + + + +</formula><p>The measure is the sum of the lengths of the p and q lists.</p><formula xml:id="formula_45">t p q tl tl ˆlength( nil@ nil) = ⇒ ⇒</formula><p>On termination r points to an ordered tl-linked nil-terminated list which is a permutation of the original input. -each of which is implied by the invariant plus the if guard -then a bit of finite expansion, plus the fact that</p><formula xml:id="formula_46">A B A B f B E f ⇒ = ⇒ ⊕ + + a makes it possible to show that r p tl s p ⇒ ⊕ + a = r s p tl ⇒ + @</formula><p>The rest of the proof is straightforward manipulation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11">An Illustration: Graph Marking</head><p>The Schorr-Waite algorithm is the first mountain that any formalism for pointer aliasing should climb. It's dealt with semi-formally by Morris <ref type="bibr" target="#b22">[21]</ref> and mechanically by Suzuki <ref type="bibr" target="#b28">[27]</ref>; Kowaltowski <ref type="bibr" target="#b18">[17]</ref> gives a wonderful informal proof in pictures of a Throughout the marking process the stack p is a list, and every node on the stack is marked. Every node in the original graph is reachable from the tip t and/or the stack. Unmarked nodes in the graph are reachable from the tip and/or the right sub-nodes of elements of the stack. If a node is marked then it's in the graph; if it's not marked then its control bit is unchanged; if it's not on the stack then its left and right components are as they were originally. If a node is on the stack then we can reconstruct its left and right components by considering its predecessor node and its control bit. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>P</head><formula xml:id="formula_47">∧ ∀ ∈ ↑ ( ) → ( ) ∧ ( ) ∪ ( ) = ∧∀ → ∈ ( ) ∧ ∀ ∈ ∧¬ → ∈ ( ) ∪ { } { } { } U r r m l r c l r c l r c l r c x p x x m x c x iC x p x l x iL x r x iR x y x y p t p , ,<label>, , , , , , = , , , , ↑ ( )</label></formula><formula xml:id="formula_48">{ } ( ) ∈ ↑ ( ) { }             ∧ ∀ ¬ → = ( ) ∧ / ∈ ↑ → = ∧ = ( ) ( ) ∧ ∀ ( )∈ ↑ ↑ ( )<label>set : . . . . . . . , : , @ |||</label></formula><formula xml:id="formula_49">= ∧ = = ∧ =                                   if then else fi x c<label>( ) , , , , , , , , → →</label></formula><p>x l x iL y x iR y x iL x r x iR . . . . . . .</p><p>The measure of the loop is a triple of the number of unmarked nodes in the graph, the number of nodes on the stack with control bit set to true, and the length of the stack.</p><p>On termination all and only the original graph is marked. Unmarked nodes have an unchanged control bit, and the left and right components are as they were on input. The marvellous character of the algorithm is not that it reaches every node -a simple recursion would do that -but that it does so without using a stack, modifying © Springer-Verlag; to appear in Proceedings of MPC 2000 nodes it has passed through and -most marvellously of all -restoring them afterwards. Corresponding parts of the proof are large. We have to prove in the SWING arm, for example, that  </p><formula xml:id="formula_51">} ∪ = ∪ = ∪<label>, , , , , , , , , , ∪{ } ∪{</label></formula><p>That gives enough spatial separation to make it easy to prove that the nodes of the original graph are always reachable. It's a little harder to show that the unmarked nodes are always directly reachable: we have to show when dealing with the PUSH arm, for example, that t nil t m list p  The proof that the stack is invariantly a list sometimes has to deal with some superficially frightening formulae. The SWING arm, for example, generates p l p t r p p l c p true ↑ ⊕ ⊕ ⊕ a a a , ., but, with a single step of expansion, plus p c . from the guard and p ≠ nil and list , , p l r c ↑ ( ) from the invariant, this simplifies to p l r c ↑ , , .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="12">Conclusion</head><p>Burstall showed a way towards practical proofs of pointer programs which relatively few have followed. This paper shows that it is possible to reason in Hoare logic about small but moderately complicated pointer programs, using the principle of spatial separation and whatever data structure and other auxiliary definitions suit the problem.</p><p>Burstall's DNLRS mechanism achieved local reasoning by restricting itself to particular data structures and particular problems. The treatment of general data structures in this paper doesn't yet approach the elegance of his solution: it substitutes first, tidies up second, and remains rather low-level. To make it more elegant and more practically useful, it will be necessary to make the substitution mechanism mimic the locality of assignment, dealing only with genuine potential aliases and ignoring those which can be dealt with by spatial separation assumptions. If we can do this for a wide range of problems, building on a relatively small collection of data structure inductions, this goal may perhaps be reached.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>a state satisfying R. Array element access is resolved by comparing indices, so that b I E J ⊕ (</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>1</head><label></label><figDesc>In examples Morris deals with multiple occurrences of component names or array names by sometimes introducing nested substitutions, sometimes introducing constants -replacing b may be that his less than formal statement of the mechanism is misleading.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Hoare-triple rules</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>©{→ 5 Fig. 2 . 1 1 9 Fig. 3 . 1 1 9 Fig. 4 .</head><label>52193194</label><figDesc>Fig. 2. A single-step cycle</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>p d q b c p p a q p a b c a b c d .. . : ; . : . . .. . ..</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 5 .Fig. 6 .Fig. 7 .</head><label>567</label><figDesc>Fig. 5. An inductive definition of f-linked sequences in the heap p</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>©Fig. 8 . 7</head><label>87</label><figDesc>Fig. 8. Effect of the assignment p tl q. := on the sequence p q tl ⇒</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>Formally we have the equivalence (provable by induction on the height of finite DAGs) © Springer-Verlag; to appear in Proceedings of MPC 2000</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>©QFig. 10 .</head><label>10</label><figDesc>Fig. 10. The in-place list-reversal algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>Verlag; to appear in Proceedings of MPC 2000</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>Problems arise during the proof in showing and exploiting spatial separation between the input lists p tl ⇒ nil and q tl ⇒ nil on the one hand, and the list fragment r s tl ⇒ + on the other. For example, moving the invariant backward through the sequence s tl p p p tl s s tl . : ; : . ; : . = = = -the course of the loop, given that the guard in the if-then-else-fi is true -produces several instances of the fearsome formula r</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>©</head><label></label><figDesc>Springer-Verlag; to appear in Proceedings of MPC 2000 Specification. The graph reachable from the root is iG. The whole of the heap is unmarked. Initial values of the control-bit mapping, the left and right subnode mappings, are iC, iL and iR.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>DAGs based on the definitions above are finite height, given a finite heap (provable by induction on the difference between the restriction set S and the heap). That permits inductive proof of all kinds of interesting equivalences, including, for example</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>for the most part straightforward, but it's tedious manipulation. In Burstall's phrase, a great deal of work for such a simple matter.From the DAG definition it's possible to prove that t</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Offset sequence with different support sets for different components</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>affected by assignment</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>to tl component</cell></row><row><cell></cell><cell>p</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>q</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">hd</cell><cell></cell><cell cols="2">tl</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="3">nil list</cell><cell></cell><cell>if</cell><cell></cell><cell></cell><cell cols="2">nil</cell><cell cols="5">then else</cell><cell>xt l x @ .</cell><cell>a</cell><cell>y</cell><cell>tl x y a</cell><cell>nil</cell><cell>fi</cell></row><row><cell>= ≠ x</cell><cell cols="3">∧ nil list</cell><cell>(</cell><cell>if</cell><cell>x</cell><cell>=</cell><cell cols="2">nil</cell><cell cols="5">then else</cell><cell>x</cell><cell>@</cell><cell>⇒ y tl x y ⊕ a</cell><cell>nil</cell><cell>fi</cell><cell>)</cell></row><row><cell>= ≠ x</cell><cell cols="3">∧ nil list</cell><cell>(</cell><cell>x</cell><cell cols="2">@</cell><cell cols="5">⇒ y tl x y ⊕</cell><cell>nil</cell><cell>)</cell><cell>affected by assignment to hd component</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>the sequence p</cell><cell>hd tl ˙˙, ⇒</cell><cell>q</cell></row><row><cell></cell><cell cols="2">Fig. 9.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">therefore, y</cell><cell>⇒</cell><cell>tl</cell><cell cols="2">nil</cell><cell cols="7">y = ⇒ ⊕ tl x E a</cell><cell>nil</cell><cell>circumstances, for any formula E . (This is easily shown</cell></row><row><cell cols="15">formally by induction on the length of finite sequences.) We might, that is, be content</cell></row><row><cell cols="15">to assume separation of objects in the heap, and to prove the simpler precondition x x y x y tl tl ≠ ∧ / ∈ ⇒ ∧ ⇒ ( ) nil nil list @ nil</cell></row><row><cell cols="15">Note that the assumption ought to hold, because if x does point into y tl ⇒ nil -that is, if y tl ⇒ nil y x x tl tl ⇒ ⇒ @ nil -then we don't have a non-repeating</cell></row><row><cell cols="14">sequence and the precondition is false: x x y tl x y ≠ ∧ ⇒ ( ) ⊕ nil list @ nil a</cell></row><row><cell>= ≠ x</cell><cell cols="3">∧ nil list</cell><cell>(</cell><cell>x</cell><cell cols="2">@</cell><cell>y</cell><cell cols="2">⇒</cell><cell cols="2">⊕ tl x y a</cell><cell cols="2">x x @</cell><cell>⇒</cell><cell>⊕ tl x y a</cell><cell>nil</cell><cell>)</cell></row><row><cell>= ≠ x</cell><cell cols="3">∧ nil list</cell><cell>(</cell><cell>x</cell><cell cols="2">@</cell><cell>y</cell><cell cols="2">⇒</cell><cell>tl</cell><cell cols="3">x x @ @</cell><cell>y</cell><cell>⇒</cell><cell>⊕ tl x y a</cell><cell>nil</cell><cell>)</cell></row><row><cell cols="15">What's being appealed to by adding x y tl ∉ ⇒ nil to the precondition, thereby</cell></row><row><cell cols="15">eliminating a mapping, is the principle of spatial separation. There is a set of objects whose components help define the meaning of y tl ⇒ nil , and if the object x points to isn't one of that set, then the assignment x tl E . := can't have any effect on y tl ⇒ nil . In practice spatial-separation assertions like x y tl ∉ ⇒ nil aren't plucked out of the</cell></row><row><cell cols="15">air -they are found in invariants, as shown in the list reversal, list merge and graph</cell></row><row><cell cols="9">marking examples below.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="15">1 Defined by heap-independent axioms: see section 9.1.</cell></row><row><cell cols="15">© Springer-Verlag; to appear in Proceedings of MPC 2000</cell></row></table><note><p><p>a Without further information we can go no further, but we can be sure that this is the weakest precondition, because all we've done is to use component-as-array substitution, expand a definition and evaluate a conditional.</p>We've by no means achieved local reasoning yet, because there is a mapping tl x y ⊕ a in the argument to an inductively defined auxiliary formula. Observe, however, that when x doesn't point to any of the components of y tl ⇒ nil , assignment to x.tl can't affect the meaning of that formula. In those</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>I neglect definedness conditions throughout this paper.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1"><p>In languages such as C<ref type="bibr" target="#b16">[15]</ref> which allow pointers to stack components, pointer aliasing is used to imitate parameter aliasing. The obvious implementation of call by reference depends on the use of pointers. Pointer aliasing and parameter aliasing are, therefore, closely related. But at source language level they are distinct phenomena.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_2"><p>I assume, for simplicity, that distinct types of object use distinct component names.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_3"><p>© Springer-Verlag; to appear in Proceedings of MPC 2000</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_4"><p>It's helpful to think of this formula as generating a sequence of objects, but of course it actually generates a sequence of pointer values.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements. This work springs from discussions with (in temporal order) Keith Clarke, Peter O'Hearn, Dave Streader, Stefano Guerrini, Samin Ishtiaq, Hayo Thielecke, Edmund Robinson and Cristiano Calgagno 1 at QMW, fuelled by the QMW Verified Bytecode project [EPSRC GR/L54578]. Tony Hoare first pointed me to Morris's work, and John Reynolds emphasised the importance of Burstall's. Uday Reddy and Richard Bird impressed upon me the usefulness of the component-as-array trick. Jape is a joint effort with Bernard Sufrin, and the developments which support the Jape-rendered proofs in this document arose out of discussions between us.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>© Springer-Verlag; to appear in Proceedings of MPC 2000 Q t root p P p t tm t tm p c q t t p p pr t r q q t t pr pr pl pl q pc   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definitions. The stack starting at A:</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>if then else fi</head><p>The binary DAG reachable from A which contains only unmarked nodes and none of the objects in set S:</p><p>Two sequences zipped together:</p><p>Converting sequences and DAGs to sets: set ˆset ŝet ˆset , , ˆset set set @ ˆset set</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Appel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Felty</surname></persName>
		</author>
		<title level="m">A Semantic Model of Types and Machine Instructions for Proof-Carrying Code 27th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL &apos;00)</title>
		<imprint>
			<date type="published" when="2000-01">January 2000</date>
			<biblScope unit="page" from="243" to="253" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">The Java programming language</title>
		<author>
			<persName><forename type="first">K</forename><surname>Arnold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gosling</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Calculating with Pointers</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bijlsma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="191" to="205" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Machine-checked proofs of list reversal, list merge</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bornat</surname></persName>
		</author>
		<ptr target="http://www.dcs.qmw.ac.uk/~richard/pointers" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Animating formal proof at the surface: the Jape proof calculator</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bornat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Sufrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Computer Journal</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="177" to="192" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Some techniques for proving correctness of programs which alter data structures</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Burstall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Machine Intelligence</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Michie</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="23" to="50" />
			<date type="published" when="1972">1972</date>
			<publisher>American Elsevier</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Methods and Logics for Proving Programs</title>
		<author>
			<persName><forename type="first">P</forename><surname>Cousot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Models and Semantics</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Van Leeuwen</surname></persName>
		</editor>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Volume B of Handbook of Theoretical Computer Science</title>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>Elsevier</publisher>
			<biblScope unit="page" from="843" to="993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">1 Calcagno was on loan from Genova</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Assigning meaning to programs</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Floyd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Symp. in App. Math</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="19" to="32" />
			<date type="published" when="1967">1967</date>
			<publisher>American Mathematical Society</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The Schorr-Waite graph marking algorithm</title>
		<author>
			<persName><forename type="first">D</forename><surname>Gries</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="223" to="232" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Assignment and procedure call proof rules</title>
		<author>
			<persName><forename type="first">D</forename><surname>Gries</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Levin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="564" to="579" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">An axiomatic basis for computer programming</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="576" to="580" />
			<date type="published" when="1969">1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Jifeng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">A Trace Model for Pointers and Objects. Object-Oriented Programming 13th European Conference (ECOOP &apos;99)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1628</biblScope>
			<biblScope unit="page" from="1" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">An Axiomatic Definition of the Programming Language Pascal</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Wirth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="335" to="355" />
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">K</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Wirth</surname></persName>
		</author>
		<title level="m">Pascal user manual and report</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">W</forename><surname>Kernighan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Ritchie</surname></persName>
		</author>
		<title level="m">The C programming language</title>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Data Structures and Correctness of Programs</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kowaltowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="283" to="301" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Examples of Informal but Rigorous Correctness Proofs for Tree Traversing Algorithms</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kowaltowski</surname></persName>
		</author>
		<idno>TR-DCC-92-10</idno>
		<imprint>
			<pubPlace>Brazil</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of Campinas</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Leino</surname></persName>
		</author>
		<title level="m">Toward Reliable Modular Programs</title>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
		<respStmt>
			<orgName>California Institute of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD Thesis</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Verification of Array, Record, and Pointer Operations in Pascal</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Luckham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Suzuki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems, Examples of Informal but Rigorous Correctness Proofs for Tree Traversing Algorithms</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="226" to="244" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Correctness of a Compiler for Arithmetic Expressions</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mccarthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Painter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Symposium in Applied Mathematics</title>
		<meeting>Symposium in Applied Mathematics</meeting>
		<imprint>
			<date type="published" when="1967">1967</date>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="33" to="41" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A general axiom of assignment. Assignment and linked data structure. A proof of the Schorr-Waite algorithm</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Morris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theoretical Foundations of Programming Methodology (Proceedings of the 1981 Marktoberdorf Summer School</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Broy</surname></persName>
		</editor>
		<editor>
			<persName><surname>Schmidt</surname></persName>
		</editor>
		<meeting><address><addrLine>Reidel</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="25" to="51" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<author>
			<persName><forename type="first">G</forename><surname>Necula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Safe, Untrusted Agents using Proof-Carrying Code. Mobile Agents and Security</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1419</biblScope>
			<biblScope unit="page" from="61" to="91" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Reynolds</surname></persName>
		</author>
		<title level="m">The Craft of Programming</title>
		<imprint>
			<publisher>Prentice-Hall International</publisher>
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Reasoning about Shared Mutable Data Structure, given at the symposium in celebration of the work of C</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Reynolds</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">A.R. Hoare</title>
		<imprint>
			<date type="published" when="1999-09">September 1999</date>
			<pubPlace>Oxford</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">An efficient machine-independent procedure for garbage collection in various list structures</title>
		<author>
			<persName><forename type="first">H</forename><surname>Schorr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M</forename><surname>Waite</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="501" to="506" />
			<date type="published" when="1967">1967</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Towards a Formal Semantics</title>
		<author>
			<persName><forename type="first">C</forename><surname>Strachey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Language Description Languages for Computer Programming</title>
		<editor>
			<persName><forename type="first">T</forename><forename type="middle">B</forename><surname>Steel</surname><genName>Jr</genName></persName>
		</editor>
		<imprint>
			<publisher>North-Holland</publisher>
			<date type="published" when="1964">1964</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Automatic verification of programs with complex data structure</title>
		<author>
			<persName><forename type="first">N</forename><surname>Suzuki</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1976">1976</date>
			<pubPlace>Stanford</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">PhD Thesis</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">The correctness of the Schorr-Waite list marking algorithm</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Topor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="211" to="221" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
