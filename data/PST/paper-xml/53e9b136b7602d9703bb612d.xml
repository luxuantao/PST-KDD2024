<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Maximum Coverage Problem with Group Budget Constraints and Applications</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Chandra</forename><surname>Chekuri</surname></persName>
							<email>chekuri@research.bell-labs.com</email>
							<affiliation key="aff0">
								<orgName type="institution">Bell Labs</orgName>
								<address>
									<addrLine>600 Mountain Avenue Murray Hill</addrLine>
									<postCode>07974</postCode>
									<region>NJ</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Amit</forename><surname>Kumar</surname></persName>
							<email>amitk@cse.iitd.ernet.in</email>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science and Engineering IIT Delhi</orgName>
								<address>
									<postCode>110016</postCode>
									<country key="IN">India</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Maximum Coverage Problem with Group Budget Constraints and Applications</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">462E4D6853F97BA2F2677759F7C44C7B</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:27+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We study a variant of the maximum coverage problem which we label the maximum coverage problem with group budget constraints (MCG). We are given a collection of sets S = {S1, S2, . . . , Sm} where each set Si is a subset of a given ground set X. In the maximum coverage problem the goal is to pick k sets from S to maximize the cardinality of their union. In the MCG problem S is partitioned into groups G1, G2, . . . , G . The goal is to pick k sets from S to maximize the cardinality of their union but with the additional restriction that at most one set be picked from each group. We motivate the study of MCG by pointing out a variety of applications. We show that the greedy algorithm gives a 2-approximation algorithm for this problem which is tight in the oracle model. We also obtain a constant factor approximation algorithm for the cost version of the problem. We then use MCG to obtain the first constant factor approximation algorithms for the following problems: (i) multiple depot k-traveling repairmen problem with covering constraints and (ii) orienteering problem with time windows when the number of time windows is a constant.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In this paper we are interested in a variant of the set cover problem and its maximization version, the maximum coverage problem. The set cover problem is the following: we are given a ground set X of n elements and a set of subsets S = {S 1 , S 2 , . . . , S m } such that for 1 ≤ i ≤ m, S i ⊆ X. The objective is to find a minimum number of sets from S such that their union is X. In the cost version of the set cover problem each set S i has a cost c(S i ) and we seek a minimum cost collection of sets to cover all the elements of X. The maximum coverage problem is a close relative of the set cover problem. We are given a ground set X and S = {S 1 , S 2 , . . . , S m } of subsets of X. In addition we are given an integer k and the goal is to pick at most k sets from S such that the size of their union is maximized. In the profit version of the maximum coverage problem the items in X have profits and the goal is to maximize the profit of items picked.</p><p>Set cover and maximum coverage problems are fundamental algorithmic problems that arise frequently in a variety of settings. Their importance is partly due to the fact that many covering problems can be reduced to these problems. The greedy algorithm that iteratively picks the set that covers the maximum number of uncovered elements is a (ln n + 1) approximation for the set cover problem and an e e-1 approximation<ref type="foot" target="#foot_0">1</ref> for the maximum coverage problem <ref type="bibr" target="#b14">[15]</ref>. Feige <ref type="bibr" target="#b11">[12]</ref> showed that these ratios are optimal unless N P is contained in quasipolynomial time. In a number of applications the set system is implicitly defined and the number of sets is exponential in the number of elements. However, the greedy algorithm can still be applied if a polynomial time oracle that returns a set with good properties is available.</p><p>In this paper, motivated by several applications, we study a variant of the maximum coverage problem that we call the maximum coverage problem with group budget constraints (MCG). We start with a simple motivating example, the multiple knapsack problem (MKP), and the analysis of the greedy algorithm for that problem in <ref type="bibr" target="#b8">[9]</ref>. MKP is a generalization of the classical knapsack problem to several knapsacks: we are given n items, where item i has a size s i and a profit p i ; we are also given m knapsacks potentially of different capacities b 1 , b 2 , . . . , b m . The objective is to find a maximum profit subset of items that can be feasibly packed into the given set of knapsacks. We first consider the case where all the knapsacks have the same capacity b. For simplicity, in the following discussion, we assume that we have an exact algorithm to solve the single knapsack problem. We can apply the following greedy algorithm: pick an unused knapsack and use the single knapsack algorithm to pack it optimally with a subset of items from the remaining items. It is easy to show, via standard set cover style arguments, that this algorithm gives an e e-1 approximation <ref type="bibr" target="#b8">[9]</ref>. That the greedy algorithm gives this ratio can also be seen via a reduction to the maximum coverage problem as follows. Let S be the set of all distinct subsets of the items that can be feasibly packed into a knapsack of size b. The MKP problem can be rephrased as a maximum coverage problem on this implicit exponential sized set system and we are required to pick m sets. The greedy algorithm that we described for the MKP can be seen to be the greedy algorithm for maximum coverage problem on the implicit set system above where the oracle is the optimal single knapsack algorithm.</p><p>Now we consider instances of MKP in which the knapsack sizes could be different. In this case too we can define a greedy algorithm, however since the knapsacks are not identical, it is not a priori clear in which order to consider them. In <ref type="bibr" target="#b8">[9]</ref> it is shown that irrespective of the ordering, the greedy algorithm results in a 2-approximation. Once again it is instructive to understand the implicit set system. Let S i be set of distinct subsets of items that can be feasibly packed into a knapsack of size b i and let S = ∪ i S i . It is clear that if the knapsacks are not identical, we no longer have a maximum coverage problem although the greedy algorithm still gives a constant factor approximation algorithm. The problem we have is the following: we are required to choose at most one set from each of the S i and cover as many elements as possible by the union of sets picked.</p><p>Motivated by MKP and other problems that we consider later in this paper, we define a variant of the maximum coverage problem that provides an abstraction for covering problems that have groups of sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Maximum Coverage with Group Budgets (MCG):</head><p>We are given subsets S 1 , S 2 , . . . , S m of a ground set X. We are also given sets G 1 , . . . , G , each G i being a subset of {S 1 , . . . , S m }. We call G i a group. By making copies of sets, if necessary, we can assume that the groups G i are disjoint from each other. We define two versions of the problem, the cardinality version and the cost version.</p><p>In the cardinality version, we are given an integer k, and an integer bound</p><formula xml:id="formula_0">k i for each group G i . A solution is a subset H ⊆ {S 1 , . . . , S m } such that |H| ≤ k and |H ∩ G i | ≤ k i for 1 ≤ i ≤ .</formula><p>The objective is to find a solution such that the number of elements of X covered by the sets in H is maximized. In fact, we can assume without loss of generality that all k i are equal to 1. Otherwise, we can make k i copies of each group G i .</p><p>In the cost version, we associate a cost c(S j ) with each set S j . Further, we are given a budget B i for group G i , 1 ≤ i ≤ , and an overall budget B. A solution is a subset H ⊆ {S 1 , S 2 , . . . , S m } such that the total cost of the sets in H is at most B. Further for any group G i , the total cost of the sets in H ∩ G i can be at most B i . The objective is to find such a subset H to maximize the size of the union of sets in H.</p><p>In many applications, m, the number of given subsets of X, is exponential in n and the sets are defined implicitly. In such cases we require a polynomial time oracle with some desirable properties. We now make this more precise. In the cardinality version, we assume there exists an oracle A that takes as input, a subset X of X, and an index i. A(X , i) outputs a set S j ∈ G i such that |S j ∩ X | is maximized over all sets in G i . We also work with approximate oracles. A is an α-approximate oracle if A(X , i) outputs a set</p><formula xml:id="formula_1">S j ∈ G i such that |S j ∩ X | ≥ 1 α max D∈Gi |D ∩ X |.</formula><p>For the cost version, we shall assume we are given an oracle B that takes as input a subset X of X and a group index i. B(X , i) outputs a set S j ∈ G i such that |Sj ∩X | c(Sj ) is maximized -we shall assume that all sets in G i have cost at most B i . As with the cardinality case we also work with approximate oracles.</p><p>We note that the maximum coverage problem is a special case of the cardinality case of MCG and the budgeted maximum coverage problem <ref type="bibr" target="#b16">[17]</ref> is a special case of the cost version of MCG.</p><p>In this paper we show that a simple greedy algorithm gives a constant factor approximation for both the cardinality and the cost versions of MCG. The analysis differs from the usual analysis for the maximum coverage problem and is based on the analysis for MKP in <ref type="bibr" target="#b8">[9]</ref>. For the cardinality version we show that greedy gives a 2-approximation and our analysis is tight. For the cost version we obtain a 12-approximation. The greedy algorithm works in the oracle model as well and in fact this is the main thrust of the paper and leads to the applications that we mention below.</p><p>We note that for the cardinality version, an e e-1 -approximation is achievable if the input is given in an explicit form. This ratio is achieved by rounding an LP relaxation either by the pipage rounding technique of Ageev and Sviridenko <ref type="bibr" target="#b0">[1]</ref> or the probabilistic rounding technique of Srinivasan <ref type="bibr" target="#b17">[18]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Set Cover with Group Budgets (SCG):</head><p>We define the set cover problem with group constraints. We only consider the cardinality version in this paper, it is easy to extend it to the cost case. We are given a ground set X of n items and a set S = {S 1 , S 2 , . . . , S m } of subsets of X. The set S is partitioned into groups G 1 , G 2 , . . . , G . The objective is to find a subset H of S such that all elements of X are covered by sets in H and max i=1 |H ∩ G i | is minimized. Note that if we have a single group containing all sets then the problem is the same as the set cover problem. Elkin and Kortsarz <ref type="bibr" target="#b9">[10]</ref> seem to be the first to consider this problem for its applications and they call it the multiple set cover problem. They present an O(log n) approximation using a randomized rounding of a natural linear programming relaxation. Kortsarz <ref type="bibr" target="#b15">[16]</ref> asked if there is a combinatorial algorithm for this problem. From the 2-approximation bound on Greedy we obtain a simple combinatorial (log n + 1) algorithm for SCG. It also has the advantage of working in the oracle model.</p><p>We consider two problems for which we design the first constant factor approximation algorithms by using reductions to instances of MCG in the oracle model. We describe them next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Multiple Depot k-Traveling Repairmen Problem:</head><p>The k-traveling repairmen problem was considered by Fakcharoenphol, Harrelson, and Rao <ref type="bibr" target="#b10">[11]</ref>. Their problem is the following. We are given a finite metric space on a set of nodes V induced by an edge weighted undirected graph G, and k not necessarily distinct vertices s 1 , s 2 , . . . , s k from V . A feasible solution to the problem is a set of k tours T 1 , . . . , T k , with tour T i starting at s i such that every vertex in V is visited by one of the tours. Given a feasible solution, we define the latency of a vertex as the time at which it gets visited by one of these tours. The objective is to minimize the sum of the latencies of the vertices in V . The problem models the case where k-repairmen are available at the k locations (depots) and we need to visit all the sites that have repairs. The goal is to minimize the average waiting time of the sites. If k = 1, the problem is the same as the the minimum latency problem for which a constant factor approximation was first given by Blum et al. <ref type="bibr" target="#b4">[5]</ref>. The current best approximation ratio for the minimum latency problem is 3.59 <ref type="bibr" target="#b7">[8]</ref>. In <ref type="bibr" target="#b10">[11]</ref> a constant factor approximation algorithm is presented for the k-traveling repairmen problem when all the repairmen start at the same vertex s, that is s 1 = s 2 = . . . = s k = s. In the same paper <ref type="bibr" target="#b10">[11]</ref>, the generalization of the k-traveling repairmen problem to the case with multiple sources (depots) is left as an open problem. We obtain a constant factor approximation for this problem. We also obtain constant factor approximation algorithms for several generalizations as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Orienteering (or TSP) with Time Windows:</head><p>The orienteering problem is defined as follows. We are given a metric space on a set of vertices V , a starting vertex s and a budget B. A feasible solution is a tour starting at s and having length at most B. The objective is to maximize the number of vertices covered by this tour. Blum et al. <ref type="bibr" target="#b6">[7]</ref> gave the first constant factor approximation algorithm for this problem in general graphs, they obtained a ratio of 5 which has recently been improved to 3 in <ref type="bibr" target="#b5">[6]</ref>. Previously, a 2 + -approximation was known for the case when the metric was induced by points in the Euclidean plane <ref type="bibr" target="#b1">[2]</ref>.</p><p>In this paper we consider the more general problem where we associate a window [r v , d v ] with each vertex v. A vertex v can be visited only in the time interval [r v , d v ]. We shall say that r v is the release time of v and d v is the deadline of v. The objective, again, is to find a path that starts at s and maximizes the number of vertices visited, however we can only visit a vertex within its time window. This problem models a variety of situations when technicians or robots have to visit a number of different locations in a time period. The problem is referred to by different names in the literature including prize collecting traveling salesman problem with time windows and TSP with deadlines. Tsitsikilis <ref type="bibr" target="#b18">[19]</ref> showed that this problem is strongly NP-complete even when the metric space is a line. Bar-Yehuda et al. <ref type="bibr" target="#b3">[4]</ref> gave an O(log n) approximation when the vertices lie on a line. Recently Bansal et al. <ref type="bibr" target="#b5">[6]</ref> gave an O(log 2 n) for the general problem. In this paper we consider the case when the number of distinct time windows, k, is a fixed constant independent of the input. We give a constant factor approximation algorithm for this problem using a reduction to MCG and using the algorithm in <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b5">6]</ref> as an oracle.</p><p>The thrust of this paper is the definition of MCG and its applications. In this extended abstract we have not attempted to optimize the constants that can be achieved for the problems we consider. We defer this to the final version of the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Greedy Algorithm for MCG</head><p>In this section we show that simple greedy algorithms give constant factor approximation ratios for MCG. First we consider the cardinality version of the problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Cardinality Version</head><p>We can assume without loss of generality that the number of groups ≥ k. We work in the oracle model and assume that we have an α-approximate oracle. The greedy algorithm we consider is a natural generalization of the greedy algorithm for the maximum coverage problem. It iteratively picks sets that cover the maximum number of uncovered elements, however it considers sets only from those groups that have not already had a set picked from them. The precise algorithm is stated below.</p><p>Algorithm Greedy H ← ∅, X ← X. For j = 1, 2, . . . , k do For i = 1, . . . , do If a set from G i has not been added to</p><formula xml:id="formula_2">H then A i ← A(G i , X ) Else A i ← ∅ EndFor r ← argmax i |A i | H ← H ∪ {A r }, X ← X -A r EndFor Output H.</formula><p>By renumbering the groups, we can assume that Greedy picks a set from group G j in the jth iteration. Let opt denote some fixed optimal solution and let i 1 &lt; i 2 &lt; . . . &lt; i k be the indices of the groups that opt picks sets from. We set up a bijection π from {1, 2, . . . , k} to {i 1 , i 2 , . . . , i k } as follows. For 1 ≤ h ≤ k, if h ∈ {i 1 , i 2 , . . . , i k } then we require that π(h) = h. We choose π to be any bijection that respects this constraint.</p><p>Let C j be the set that Greedy picks from G j , and let O j be the set that opt picks from G π(j) . We let A j = A j -∪ j-1 h=1 A h denote the set of new elements that Greedy adds in the jth iteration. Let C = ∪ j A j and O = ∪ j O j denote the number of elements that Greedy and opt pick.</p><formula xml:id="formula_3">Lemma 1. For 1 ≤ j ≤ k, |A j | ≥ 1 α |O j -C|.</formula><p>Proof. If O j -C = ∅ there is nothing to prove. When Greedy picked A j , the set O j was available to be picked. Greedy did not pick O j because |A j | was at least</p><formula xml:id="formula_4">1 α |O j -∪ j-1 h=1 A h |. Since ∪ j-1 h=1 A h ⊆ C, the lemma follows.</formula><p>Theorem 1. Greedy is an (α + 1)-approximation algorithm for the cardinality MCG with an α-approximate oracle.</p><p>Proof. From Lemma 1, we have that</p><formula xml:id="formula_5">|C| = j |A j | ≥ j 1 α |O j -C| ≥ 1 α (| ∪ j O j | -|C|) ≥ 1 α (|O| -|C|).</formula><p>Hence |C| ≥ 1 α+1 |O|.</p><p>Corollary 1. If k = , Greedy is an (α + 1)-approximation algorithm even if it is forced to pick sets from an adversarially chosen ordering of the groups.</p><p>Proof. If k = , the permutation π is the identity permutation. In this case Lemma 1 holds again.</p><p>Easy examples show that our analysis of the Greedy algorithm is tight. In fact, in the oracle model, the ratio of 2 cannot be improved. When the set system is available as part of the input, the problem is hard to approximate to within a factor of e e-1 via a reduction from the maximum coverage problem. As we mentioned earlier, a matching ratio can be obtained via linear programming <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b17">18]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A log n + 1 Approximation for SCG:</head><p>We observe that the 2-approximation bound for MCG can be used to obtain a log n + 1 approximation for SCG as follows. We simply guess the optimal value λ * , that is there is an optimal cover H * such that max i |H * ∩G i | ≤ λ * . We then create an instance of MCG by having a budget of λ * on each group G i . Greedy covers at least 1/2 the elements in X. Iterating Greedy log n + 1 times results in a solution that covers all elements. In each iteration the number of sets added from any given group is upper bounded by λ * . Hence, when all elements are covered, the number of sets added from any group is at most (log n + 1)λ * .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Cost Version</head><p>We now consider the cost version of MCG. We give a greedy algorithm for this problem which is similar in spirit to the one for the cardinality case but differs in some technical details. The algorithm that we describe below may violate the cost bounds for the groups or the overall cost bound B. We will later show how to modify the output to respect these bounds. We work in the oracle model again. Recall that the oracle A, given a set of elements X and an index i returns a set S ∈ G i that approximately minimizes the ratio max D∈Gi |D∩X | c(D) . The algorithm is described in more detail below. We assume without loss of generality that</p><formula xml:id="formula_6">B ≤ i=1 B i . Algorithm CostGreedy H ← ∅, X ← X. Repeat For i = 1, 2, . . . , l do If c(H ∩ G i ) &lt; B i then A i ← A(X , G i ). Else A i ← ∅. EndFor r ← argmax i |Ai| c(Ai) H ← H ∪ {A r }, X ← X -A r . Until (c(H) ≥ B). Output H.</formula><p>Note that H need not obey the budget requirements. Define H i = H ∩ G i . For a set S chosen by the algorithm, define X(S) as the extra set of elements in X that are covered at the time S is added to H. Define X(H i ) = ∪ S∈Hi X(S). Similarly, X(H) is the set of elements covered by the algorithm. Let opt be some fixed optimal solution to the given problem instance. Let O be the set of sets chosen by opt.</p><formula xml:id="formula_7">Define Y i = O ∩ G i . We call an index i good if c(H ∩ G i ) ≤ B i ,</formula><p>that is the algorithm did not exceed the budget for G i . Otherwise we call i bad. We omit proofs the following lemmas in this version.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 2. If i is bad, then |X(H</head><formula xml:id="formula_8">i )| ≥ 1 α A∈Yi |A -X(H)|. Corollary 2. |X(H)| ≥ 1 α+1 | ∪ i:i bad ∪ A∈Yi A|. Lemma 3. |X(H)| ≥ 1 α+1 | ∪ i: i good ∪ A∈Yi A|.</formula><p>From Corollary 2 and Lemma 3, it follows that X(H) ≥ 1 2(α+1) opt. But H does not respect all the budget constraints. We partition H into three subsets H 1 , H 2 , H 3 . H 3 is the last set picked by our algorithm. H 2 contains those sets S which when added to H caused the budget of some group G i to be violatedhowever we do not include the set in H 3 . H 1 contains all the remaining sets in H. It is easy to see that H 1 , H 2 and H 3 do not violate the budget constraints. Further, one of these three sets must be covering at least 1/3 the number of elements covered by H. Thus we get the following theorem.</p><p>Theorem 2. The algorithm CostGreedy is a 6(α + 1)-approximation algorithm for the cost version of MCG.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Applications of MCG</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The k-Traveling Repairmen Problem</head><p>Recall from Section 1 that in the k-traveling repairmen problem we are given a metric space on a set of nodes V induced by an edge weighted undirected graph G. We are given a set of k source vertices in V , call them s 1 , s 2 , . . . , s k . A feasible solution to the problem is a set of k tours, one tour starting at each source s i , such that every vertex in V is visited by one of the tours. Given a feasible solution, we define the latency of a vertex as the time at which it gets visited by one of these tours. The objective is to minimize the sum of the latencies of the vertices in V .</p><p>We give the first constant factor approximation algorithm for the multiple depot k-traveling repairmen problem. We define a related problem, which we call the budgeted cover problem, as follows. The input to the problem is a subset V of V and a positive integer B. A solution is a set of k tours, one tour starting at each source s i , such that no tour has length more than B. The objective is to maximize the number of vertices of V covered by these tours. We can view this problem in the framework of MCG as follows. The ground set is the set of vertices in V . For each source s i , we have a collection of sets S i 1 , . . . , S i i : each set corresponds to a distinct tour of length at most B beginning at s i . There are k groups, one group for each source vertex s i . The group G i corresponding to</p><formula xml:id="formula_9">s i is {S i 1 , . . . , S i i }.</formula><p>Clearly, the cardinality version of MCG for this set system is the same as the budgeted cover problem for the original graph. From Section 2 we will get a constant factor approximation algorithm for the budgeted cover problem provided we have the following oracle A.</p><p>The oracle A should be able to solve the budget-MST problem. In this problem, we are given a graph G = (V, E), a source s ∈ V and a budget B. A solution is a tour starting at s and having cost at most B. The objective is to maximize the number of vertices covered by the tour. Unfortunately the budget-MST problem is NP-hard. However, by using the algorithm for the i-MST problem <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b2">3]</ref>, we can obtain a polynomial time algorithm, A, which covers opt vertices and costs at most β • B. Here β &gt; 1 is the approximation ratio for the i-MST problem. Hence, if we are willing to violate the budget constraint by a factor of β we can cover as many vertices as the optimal solution.</p><p>It follows from Theorem 1 that we can get a polynomial time algorithm for the budgeted cover problem which covers at least half as many vertices as the optimum, and constructs k tours, each tour of length at most βB. We call this algorithm C.</p><p>We can now describe our algorithm for the traveling k-traveling repairmen problem. Our algorithm works in phases. We assume without loss of generality that all distances are at least 1. Let V j be the set of uncovered vertices at the beginning of phase j (so V 0 = V ). In phase j, we cover as many vertices as possible so that the budget of each tour is about 2 j . More precisely, we do the following Algorithm Visit(j) : For p = 1, 2 do Run C on the budget cover problem instance with inputs V j and 2 j . Remove from V j the covered vertices.</p><p>This describes phase j. We invoke the subroutine Visit(j) with increasing values of j until all vertices are covered. Given a source s i , we have constructed several tours starting from s i . We just stitch them together starting in the order these tours were found by the algorithm. Clearly, our algorithm produces a feasible solution. It remains to prove that it is a constant factor approximation algorithm.</p><p>We begin with some notation. Fix an optimal solution opt. Let O j denote the set of nodes in opt's solution which have latency at most 2 j . Let C j be the set of nodes visited by our algorithm by the end of phase j. Proof. Let R j denote O j -C j-1 . Let A j be the set of nodes covered by Visit(j) when p = 1. Theorem 1 implies that |A j | ≥ 1 2 |R j |. One more application of this theorem when p = 2 gives the desired result.</p><p>The rest of the proof goes along the same lines as in <ref type="bibr" target="#b10">[11]</ref>. Let n j be the set of nodes in opt whose latency is more than 2 j . Let n j be the set of nodes in our tour which do not get visited by the end of phase j. Lemma 5. n j ≤ 1  4 n j-1 + 3 4 n j .</p><p>Proof. From Lemma 4 it is easy to see that</p><formula xml:id="formula_10">n j ≤ n j-1 -3/4|O j -V j-1 |. Clearly, |O j | = n -n j and |V j-1 | = n -n j-1 .</formula><p>Combining these proves the lemma.</p><p>The total latency of the tours obtained by our algorithm is upper bounded by j 4β2 j n j and that produced by the tours in the optimal solution is lower bounded by j 2 j-1 n j . From Lemma 5 we obtain that</p><formula xml:id="formula_11">j 2 j n j ≤ 1 2 j 2 j-1 n j-1 + 3 4 j 2 j n j which implies that j 2 j n j ≤ 3 j 2 j-1 n j .</formula><p>This proves that our algorithm yields a 12β approximation. We can improve the ratio by using ideas from <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b7">8]</ref>; we defer the details to the final version. We can also obtain constant factor approximations for each of the following generalizations: (i) each vertex v can be serviced only by a given subset S v of repairmen, (ii) each vertex v has a service time p v that the repairmen needs to spend at the vertex, and (iii) each vertex v has a weight w v and the objective is to minimize the sum of the weighted latencies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The Orienteering Problem with Time Windows</head><p>We now consider the orienteering problem with time windows. We assume that the number of distinct time windows is some fixed constant k. We use, as a subroutine, the algorithm of Bansal et al. <ref type="bibr" target="#b5">[6]</ref> which provides a 3-approximation for the case when there is a single time window [0, D] for all vertices and the tour is required to start at a vertex s and end at a vertex t. In the rest of the section we use β to denote the approximation ratio for the single deadline case. All our ratios will be expressed as functions of β. Let ∆ be the maximum distance in the metric space. We begin by describing approximation algorithms for two special cases: (1) when all release times are zero, and (2) when all deadlines are the same.</p><p>Release Times Are Zero: We consider the special case when r v = 0 for all nodes v. Let d 1 &lt; d 2 &lt; . . . &lt; d k be the k distinct deadlines. Let V i denote the set of vertices whose deadline is d i . Let P * be the tour constructed by some optimal solution. Define v * 0 as the source vertex s. ). Since ∆ need not be polynomially bounded, the number of guesses is not polybounded. We omit details on how to use a polynomial number of guesses. Now, we define k groups G 1 , . . . , G k as follows. G i is the set of all paths on the vertex set The oracle needed for this instance is an algorithm for the orienteering problem where the time windows for all the nodes are of the form [0, D], hence we can use the algorithm of Blum et al. <ref type="bibr" target="#b6">[7]</ref> or Bansal et al. <ref type="bibr" target="#b5">[6]</ref>. From Corollary 1 we obtain a a (β + 1)-approximation algorithm for the case of k deadlines. The running time of the algorithm is O(n 2k ∆ k T ) where T is the running time of the approximation algorithm for the single deadline case. Single Deadline: We now consider the special case when all deadlines are the same, say D but the release dates can be different. Consider any feasible tour P which starts at s and ends at a vertex u. Let the length of P be (P ). Suppose we reverse the tour, i.e., we view the tour as a path P r starting at u and ending at s. If P visits a vertex v at time t, then P r visits v at time (P )-t. So r v ≤ t ≤ (P ) implies that 0 ≤ (P )t ≤ (P )r v . Thus, we can view this tour as one in which the release time of a vertex is 0 and the deadline is (P )r v . Therefore, if we could guess the length of the optimal path P * and the last vertex u * in this path, then we could just use the algorithm mentioned in the previous section. Thus, we can get a (β + 1)-approximation algorithm for this problem as well. The running time of the algorithm increases by a factor of ∆ from the algorithm for single release date. k Time Windows: Now we address the case where there are both release times and deadlines. Let r 1 &lt; r 2 &lt; . . . &lt; r k be the k distinct release time and let d 1 &lt; d 2 &lt; . . . &lt; d k be the k distinct deadlines. Let P * be the tour constructed by the optimal solution. As before let v * i be the last vertex in P * to be visited before d i and let t * i be the time at which v * i is visited. Recall that V i is the set of vertices with deadline d i . We define group G i to be the set of tours that start at v * i-1 at t * i-1 and end at v * i by t * i . The vertices that a tour in G i can visit are constrained to be in V i ∪ V i+1 ∪ . . . ∪ V k . Lemma 6 trivially generalizes to this setting to yield a γ approximation provided we have an oracle for the MCG instance. Consider a group G i . The vertices all have a deadline at least as large as t * i , hence we have a single deadline. The vertices might have different release times, however there are at most k distinct release times. Hence the oracle needed for G i can be obtained from the algorithm described above for this case that has an approximation ratio of β + 1. Thus, once again applying Theorem 1 we can obtain a (β + 2)-approximation algorithm for the case of k time windows. Theorem 3. Given a β-approximation algorithm for the orienteering problem with a single time window for all vertices, there is a (β + 2)-approximation algorithm for the orienteering problem with at most k distinct time windows that runs in time polynomial in (n∆) k .</p><formula xml:id="formula_12">V i ∪ V i+1 ∪ • • • ∪ V k which originate at v * i-</formula></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Lemma 4 .</head><label>4</label><figDesc>Visit(j) covers at least 3 4 |O j -C j-1 | vertices.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>For 1 ≤ i ≤ k, let v * i as the last vertex in the tour P * which is visited by the deadline d i . It is possible that Hence the total number of guesses is O(n 2k ∆ k</figDesc><table><row><cell>v  *  i = v  *  i for two distinct indices i and i . Suppose v  *  i is visited at time t  *  i , then it follows that that t  *  i ≤ d i . Our algorithm first guesses the vertices v  *  1 , v  *  2 , . . . , v  *  k and the time instances t  *  1 , t  *  2 , . . . , t  *  k . Note that t  *  i ≤ n∆.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>1 and end at v * i with the additional constraint that the length of the path is at most t * Consider the instance of the MCG with groups defined as above where we need to pick exactly one set from each group. A γ-approximation algorithm for this problem instance implies the same for the corresponding orienteering problem.Proof. Suppose we are given a solution to the MCG which picks paths P 1 , . . . , P k from the corresponding groups. If we stitch these tours sequentially, it is easy to see that we get a path which satisfies the deadlines of the vertices visited by the individual paths. Therefore the number of vertices covered by this tour is|P 1 ∪ P 2 ∪ • • • ∪ P k |.Further, if we consider the tour P * , we can get a solution to the MCG which covers |P * | vertices. This proves the lemma.</figDesc><table><row><cell>Thus, it is enough to approximate the MCG induced by the guess of v  *  1 , . . . , v  *  k and t  *  1 , . . . , t  *  k .</cell></row></table><note><p>it * i-1 . Lemma 6.</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>In this paper approximation ratios for both minimization and maximization problems will be greater than or equal to 1.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank Moses Charikar for suggesting that we write a paper about MCG. We thank Chris Harrelson for pointing out a mistake.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Pipage Rounding: a New Method of Constructing Algorithms with Proven Performance Guarantee</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ageev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sviridenko</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>To appear in J. of Combinatorial Optimization</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Resource-constrained geometric network optimization</title>
		<author>
			<persName><forename type="first">E</forename><surname>Arkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Narasimhan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SoCG</title>
		<meeting>SoCG</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A 2 + approximation for the k-MST problem</title>
		<author>
			<persName><forename type="first">S</forename><surname>Arora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Karakostas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SODA</title>
		<meeting>SODA</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">On Approximating a Geometric Prize-Collecting Traveling Salesman Problem with Time Windows</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bar-Yehuda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Even</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sahar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ESA</title>
		<meeting>of ESA</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The minimum latency problem</title>
		<author>
			<persName><forename type="first">A</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Chalasani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Coppersmith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pulleyblank</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Raghavan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sudan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of STOC</title>
		<meeting>STOC</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Approximation Algorithms for Deadline-TSP and Vehicle Routing with Time-Windows</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bansal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chawla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Meyerson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of STOC</title>
		<meeting>of STOC</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Approximation Algorithms for Orienteering and Discounted-Reward TSP</title>
		<author>
			<persName><forename type="first">A</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chawla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Karger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lane</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Meyerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maria</forename><surname>Minkoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of FOCS</title>
		<meeting>of FOCS</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Paths, trees and minimum latency tours</title>
		<author>
			<persName><forename type="first">K</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Godfrey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Talwar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of FOCS</title>
		<meeting>of FOCS</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A PTAS for the Multiple Knapsack Problem</title>
		<author>
			<persName><forename type="first">C</forename><surname>Chekuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Khanna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of SODA</title>
		<meeting>of SODA</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Approximation Algorithm for the Directed Telephone Multicast Problem</title>
		<author>
			<persName><forename type="first">M</forename><surname>Elkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kortsarz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ICALP</title>
		<meeting>of ICALP</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The k-Traveling Repairmen Problem</title>
		<author>
			<persName><forename type="first">J</forename><surname>Fakcharoenphol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Harrelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SODA</title>
		<meeting>SODA</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A Threshold of ln n for Approximating Set Cover</title>
		<author>
			<persName><forename type="first">U</forename><surname>Feige</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="634" to="652" />
			<date type="published" when="1998-07">July 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A 3-approximation for the minimum tree spanning k vertices</title>
		<author>
			<persName><forename type="first">N</forename><surname>Garg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of FOCS</title>
		<meeting>FOCS</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">An improved approximation ratio for the minimum latency problem</title>
		<author>
			<persName><forename type="first">M</forename><surname>Goemans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kleinberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SODA</title>
		<meeting>SODA</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Approximation Algorithms for NP-Hard Problems</title>
		<editor>D. Hochbaum</editor>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>PWS Publishing Company</publisher>
			<pubPlace>Boston</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Personal communication</title>
		<author>
			<persName><forename type="first">G</forename><surname>Kortsarz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003-07">July 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The Budgeted Maximum Coverage Problem</title>
		<author>
			<persName><forename type="first">S</forename><surname>Khuller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Naor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">70</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="39" to="45" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Distributions on level-sets with Applications to Approximation Algorithms</title>
		<author>
			<persName><forename type="first">A</forename><surname>Srinivasan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of FOCS</title>
		<meeting>of FOCS</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Special Cases of Traveling Salesman Problem and Repairmen Problems with Time Windows</title>
		<author>
			<persName><forename type="first">J</forename><surname>Tsitsikilis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Networks</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="263" to="291" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
