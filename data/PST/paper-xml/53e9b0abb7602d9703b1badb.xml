<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Temporal XML: modeling, indexing, and query processing</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2007-07-07">7 July 2007</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Flavio</forename><surname>Rizzolo</surname></persName>
							<email>flavio@cs.toronto.edu</email>
						</author>
						<author>
							<persName><forename type="first">Alejandro</forename><forename type="middle">A</forename><surname>Vaisman</surname></persName>
							<email>avaisman@dc.uba.ar</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">Center for Information Technology</orgName>
								<orgName type="institution">University of Toronto</orgName>
								<address>
									<addrLine>40 St. George St</addrLine>
									<postCode>M5S 2E4</postCode>
									<settlement>Bahen, Toronto</settlement>
									<region>ON</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Universidad de Chile and Universidad de Buenos Aires</orgName>
								<address>
									<addrLine>Ciudad Universitaria</addrLine>
									<settlement>Pabellon I, Buenos Aires</settlement>
									<country key="AR">Argentina</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Temporal XML: modeling, indexing, and query processing</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2007-07-07">7 July 2007</date>
						</imprint>
					</monogr>
					<idno type="MD5">2693D13B6DBBAD1DEA3E6A3EAFB81DAD</idno>
					<idno type="DOI">10.1007/s00778-007-0058-x</idno>
					<note type="submission">Received: 31 May 2006 / Accepted: 24 March 2007 /</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T03:54+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>XML</term>
					<term>Temporal databases</term>
					<term>Semistructured data</term>
					<term>Structural summaries</term>
					<term>XPath 1 National Basketball Association, a professional basketball league</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper we address the problem of modeling and implementing temporal data in XML. We propose a data model for tracking historical information in an XML document and for recovering the state of the document as of any given time. We study the temporal constraints imposed by the data model, and present algorithms for validating a temporal XML document against these constraints, along with methods for fixing inconsistent documents. In addition, we discuss different ways of mapping the abstract representation into a temporal XML document, and introduce TXPath, a temporal XML query language that extends XPath 2.0. In the second part of the paper, we present our approach for summarizing and indexing temporal XML documents. In particular we show that by indexing continuous paths, i.e., paths that are valid continuously during a certain interval in a temporal XML graph, we can dramatically increase query performance. To achieve this, we introduce a new class of summaries, denoted TSummary, that adds the time dimension to the well-known path summarization schemes. Within this framework, we present two new summaries: LCP and Interval summaries. The indexing scheme, denoted TempIndex, integrates these summaries with additional data structures. We give a query processing strategy based on TempIndex and a type of ancestor-descendant encoding, denoted temporal interval encoding. We present a persistent implementation of TempIndex, and a comparison against a system based on</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The topic of representing, querying and updating temporal information has received little attention in the XML literature. Nevertheless, time is present in almost any real-world application, especially in web and e-business applications. In this paper we will show how temporal database concepts <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b51">52]</ref> can be applied to define, query and manage temporal XML documents, i.e., XML documents that can be navigated across time.</p><p>The graph depicted in Fig. <ref type="figure">1</ref> is an abstract representation of a temporal XML document for a portion of the NBA 1 database. We will be using this example throughout the paper. The league is composed of franchises that maintain teams, and each team has a set of players that may change over time. Some franchises may have players directly associated to them, not included in teams. The database also records some statistics for each player. Note some of the dynamics that this example graph models: players move from one franchise to another, usually from year to year, while their statistics change from match to match. For instance, in this database, node 14 represents player Williams. The dashed line between nodes 2 and 14, labeled <ref type="bibr">[0,</ref><ref type="bibr" target="#b21">22]</ref>, indicates that he played for the Orlando Magic between instants '0' and Fig. <ref type="figure">1</ref> Temporal XML document for a portion of the NBA database <ref type="bibr">'22'</ref>. After that, he moved to the Toronto Raptors (a team corresponding to this franchise is represented by node 5), where he is currently playing. This is represented by the solid line joining nodes 5 and 14, labeled <ref type="bibr" target="#b22">[23,</ref><ref type="bibr">Now]</ref>. Notice that in spite of the change of franchise, there is only one node for each player, which contains all the player's information. Thus, regardless of the franchise he played for, the graph shows that Williams scored 22 points throughout his career. As another example, node 24 represents player Garrity, who scored 15 points between instants '0' and '10', and 12 points since then. In the next sections we will describe in detail the components of Fig. <ref type="figure">1</ref>.</p><p>The information contained in the abstract representation of a temporal document presented in Fig. <ref type="figure">1</ref> allows to traverse the history of the NBA stored using this single document. We can then (a) query the state of the database at a certain point in time (technically, a snapshot of the document); or (b) pose temporal queries like "players who played for the Toronto Raptors continuously since at least the year 2000" or "name of the players who were with the Orlando Magic when McGrady joined the franchise for the first time". For these kinds of queries we provide in Sect. 7 an indexing scheme and in Sect. 8 efficient query evaluation techniques.</p><p>Other approaches (based on versioning) store only the information at some point in time, and use edit scripts and diff algorithms to reconstruct the histories of the document. In Sect. 2 we discuss the different ways of tackling this problem, and show that our approach can do better than versioning, mainly when we expect frequent updates that may cause a query to span over many versions.</p><p>In the first part of this work we address the problem of modeling and implementing temporal features in XML documents. We begin by defining an abstract model for temporal XML documents as a graph with annotated edges of two kinds: containment edges, describing element nesting and attribute values, and reference edges describing IDREF to ID references. Both kinds of edges are annotated with temporal elements (actually, for the sake of clarity, we will work with single intervals). Next, we study consistency conditions for temporal XML documents based on our data model (although our approach is general enough to be extended to other data models). We present algorithms for checking consistency, study their computational complexity, and discuss solutions for fixing inconsistencies. To the best of our knowledge, this is the first contribution on consistency of temporal XML documents, although this has been studied for non-temporal XML in <ref type="bibr" target="#b19">[20]</ref>. In addition, we discuss different ways of mapping the abstract temporal model into a concrete XML document and, finally, introduce TXPath, a query language that extends XPath for supporting temporal queries.</p><p>In the second part of the paper we present a framework for structural summaries of temporal XML documents, and study an indexing scheme, denoted TempIndex, introduced in previous work <ref type="bibr" target="#b36">[37]</ref>. Several structural summaries have been proposed in order to optimize path query evaluation over nontemporal data graphs. Some recent works on structural summaries in the XML context include <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b37">38,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b44">45]</ref>. Most of these proposals keep record of the paths in the XML data by summarizing path information in different ways. They construct a concise representation of the XML nodes based on their labels, usually a labeled graph. Although indexing label paths on temporal documents helps to reduce the search space, our experiments show that computing paths within a given time interval is quite expensive even in the presence of traditional path indexes. One possible solution is to integrate the temporal dimension into the indexing scheme in order to obtain better performance. TempIndex accomplishes this integration by summarizing label paths together with temporal intervals and continuous paths (paths that are valid continuously during a certain interval). Finally, we sketch a language for updates in XML, and show how consistency checking affects the definition of update operators. This paper considerably updates and extends the work presented in <ref type="bibr" target="#b36">[37]</ref>. Section 2 has been expanded, providing a better comparison of our model with other proposals. Section 3 gives a more detailed discussion of the data model. Section 4 is completely new, presenting an in-depth study of temporal consistency issues. Section 5 is also new. Sections 7 and 8 have been substantially modified: the notion of structural summary, and the introduction of the TSummary class of summaries give a totally new framework for the indexing scheme. Last, but not least, we now present a persistent implementation, which allows managing larger documents, and makes the results presented in Sect. 10 much more relevant and significant.</p><p>The remainder of the paper is organized as follows: in Sect. 2 we review previous efforts in temporal semistructured/XML data and non-temporal structural summaries indexes. In Sect. <ref type="bibr" target="#b2">3</ref> we introduce the temporal data model. Section 4 presents an in-depth study of the consistency conditions required by the data model, algorithms for checking these conditions, and methods for fixing (if needed) inconsistent documents. Section 5 presents four alternatives for mapping the abstract representation to a concrete XML document. TXPath is introduced in Sect. <ref type="bibr" target="#b5">6</ref>. We present the TSummary framework and the TempIndex scheme in Sect. 7, and Sect. 8 explains how to use this scheme in query processing. Section 9 discusses updates in temporal XML documents, and update management in TempIndex. Implementation and testing results are presented in Sect. <ref type="bibr" target="#b9">10</ref>. We conclude in Sect. 11.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related work</head><p>Temporal relational databases. Temporal relational database management has been extensively studied in the literature, including data models <ref type="bibr" target="#b51">[52]</ref> and query languages <ref type="bibr" target="#b9">[10]</ref> (like TSQL2 <ref type="bibr" target="#b50">[51]</ref>). However, most proposals in the relational database framework require complex extensions to SQL, and commercial databases provide only limited built-in support for temporal information management.</p><p>Temporal semistructured databases. A model for managing historical semistructured data was proposed by Chawathe et al. <ref type="bibr" target="#b5">[6]</ref>. They extend the Object Exchange Model (OEM) <ref type="bibr" target="#b6">[7]</ref> with the ability to represent updates and to keep track of them by means of "deltas". However, they do not apply this work to XML. Along the same lines, Oliboni et al. <ref type="bibr" target="#b39">[40]</ref> proposed a graphical data model and query language for semistructured data supporting transaction time, by means of attaching an interval of validity to the objects of the model. Dyreson et al. <ref type="bibr" target="#b17">[18]</ref> went further, allowing annotations on the edges of the database graph that can refer not only to valid or transaction times, but other kinds of metadata as well.</p><p>Temporal XML. In the last few years, many proposals have addressed the problem of maintaining versions of XML documents. Grandi <ref type="bibr" target="#b25">[26]</ref> provides a good index to bibliography on temporal aspects in the Web. Updates to XML in a nontemporal framework has been first studied by Tatarinov et al. <ref type="bibr" target="#b52">[53]</ref>. They proposed a language for updating XML documents as an extension to XQuery <ref type="bibr" target="#b58">[59]</ref>. A model for granting access to temporal XML documents was introduced by De Capitani <ref type="bibr" target="#b13">[14]</ref>; however, the focus here is the authorization model, not the temporal features of the document. Grandi and Mandreoli <ref type="bibr" target="#b26">[27]</ref> presented an infrastructure for managing temporal web documents. Amagasa et al. <ref type="bibr" target="#b1">[2]</ref> introduced a temporal data model based on XPath, but not a model for updates, nor a query language taking advantage of the temporal model. Dyreson <ref type="bibr" target="#b16">[17]</ref> proposed an extension to XPath with support for transaction time by means of the addition of several temporal axes for specifying temporal directions. Their focus is on document versioning over the web in the absence of explicit timestamps. Manukyan et al. <ref type="bibr" target="#b34">[35]</ref> attempted formalizing temporal constituents of XML documents. They do not address querying temporal XML documents, neither discuss implementation issues. Chien et al. <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b8">9]</ref> proposed update and versioning schemes for XML. First, they presented an edit-based schema <ref type="bibr" target="#b7">[8]</ref> in which the most current version of the document is maintained, and reverse edit scripts that allow moving backward in version time. They later moved to a scheme where version management is performed by keeping references to the maximal unchanged subtree in the previous version <ref type="bibr" target="#b8">[9]</ref>, sharing unchanged elements among versions. The main difference between their approach and ours is that we maintain a single temporal document from which versions can be extracted when needed. We believe this is better for scenarios where changes are frequent and only affect a few elements of the document. In this situation, creating a new physical version each time an update occurs may lead to large overheads when processing temporal queries that span multiple versions. A similar approach was followed by Marian et al. <ref type="bibr" target="#b35">[36]</ref>. Their goal was detecting, managing and notifying changes in web data warehouses of XML data in the context of the Xyleme project <ref type="bibr" target="#b0">[1]</ref>, a project aimed at building a dynamic World Wide Web data warehouse. The idea here is that Xyleme periodically refreshes its data and computes the changes using a diff algorithm. All nodes are assigned a Xyleme ID, which is independent of the ID attributes that the document may contain. It follows that Xyleme's goals and requirements differ from ours. Wang and Zaniolo have also proposed solutions for the Web Warehousing problem <ref type="bibr" target="#b54">[55,</ref><ref type="bibr" target="#b55">56]</ref>. In <ref type="bibr" target="#b54">[55]</ref> they proposed a valid time model that represents successive versions of a document as an XML document (implementing a temporally grouped data model) which is then queried using XQuery or any other XML query language. The latter is the strongest point of this approach. They provide versioning using the special attributes vstart and vend (and, in a subsequent paper <ref type="bibr" target="#b55">[56]</ref> tstart and tend, for handling also transaction time). Their work shows some examples of the kinds of queries that could be addressed with this approach, but there is neither an in-depth study of the model, nor experimental results supporting their claims. Wang et al. <ref type="bibr" target="#b56">[57,</ref><ref type="bibr" target="#b57">58]</ref> used a similar concept for managing and querying historical databases. They take advantage of the fact that a temporally grouped data model fits well into the XML data model. Thus, they map historical databases to so-called H-documents. This approach allows posing queries in XQuery and evaluate them using a relational database. They provide preliminary experimental results over a very simple example. Although this work overrides the problem of having multiple versions of the same document, and allows querying with any standard XML query language, it is not clear how general this solution is (i.e. how it can be efficiently applied to more involved situations), given the limited semantics of the data model. It seems that the temporal grouping assumption may limit the model to handle particular cases, where no relationships between complex objects change (like in our NBA example). Nothing is said about query optimization using index structures appropriate for temporal information, and updates are only vaguely discussed in <ref type="bibr" target="#b55">[56]</ref>.</p><p>Gergatsoulis and Stavrakas <ref type="bibr" target="#b23">[24]</ref> introduced a model for representing changes using an extension to XML denoted Multidimensional XML (MXML), where dimensions are applied to elements and attributes. Queries are not addressed in this work, but the authors claim that queries can be posed after a reduction from MXML to XML.</p><p>Our proposal has similarities with the work of Buneman et al. <ref type="bibr" target="#b4">[5]</ref>. In this work, the authors study data structures specifically suited for keeping historical information about scientific data. They provide a versioning scheme allowing storing all the information in a single document (i.e., the authors also acknowledge the need for avoiding edit scripts when changes are frequent). Seminal in many senses, we think the proposal is limited to relevant although very specific situations and data formats. The authors also present timestamp trees, an efficient indexing scheme that allows obtaining a version of the document at some point in time. The proposal supports documents where the changes consist in addition of information, and is not oriented to documents where the relationships between objects change, or when updates are of a kind other than the insertion of elements. Moreover, the scheme requires that each node in the graph representation of the temporal document must be uniquely identified by the path in which it occurs and the values of its subelements (following the concept of XML keys discussed in <ref type="bibr" target="#b3">[4]</ref>). The authors conclude that, if the document does not have a key system, the proposal requires a diff algorithm, turning it into a conventional Source Control Code System (SCCS). Also, the work is oriented to queries asking for document snapshots or histories of elements, which are only a portion of the queries a temporal database must support. The indexing scheme is also oriented to these kinds of queries. Finally, the issue of handling document order is not considered in the paper. We believe the model proposed in the present paper, although having some features in common with the work of Buneman et al., considerably extends and improves their work, overriding its many constraints.</p><p>Also close to our ideas, Gao et al. <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b22">23]</ref> introduced τ XQuery, an extension to XQuery supporting valid time while maintaining the data model unchanged. Queries are translated into XQuery and evaluated by an XQuery engine. Even for simple temporal queries, this approach results in long XQuery programs. Moreover, translating a temporal query into a non-temporal one makes it more difficult to apply query optimization and indexing techniques particularly suited for temporal XML documents. We would like to make it clear here that we do not compare the expressiveness of τ XQuery against TXPath (the language we propose), we only point out the different approach. TXPath is not aimed at being a working temporal query language, but a tool for giving insight into the problems that appear when querying temporal XML data that is stored using different models.</p><p>It is worth noticing that none of the approaches commented above provides an in-depth study of the problems of working with inconsistent temporal XML documents. Moreover, most of these proposals only define vague consistency conditions for the data models that support them. This is a subject overlooked so far in temporal XML, although in the last few years the topic has been addressed in the non-temporal XML framework (see for example <ref type="bibr" target="#b19">[20]</ref>). An important contribution of our work is the study of different ways of tackling consistency in temporal XML documents.</p><p>Structural summaries for XML. Structural summaries for XML data have been proposed in recent years in order to optimize path query evaluation. Most of these proposals keep record of the paths in the XML data by summarizing path information in different ways. They construct a concise representation of the XML nodes based on their labels, usually a labeled graph. Examples of those are region inclusion graphs (RIGs) <ref type="bibr" target="#b12">[13]</ref>, representative objects (ROs) <ref type="bibr" target="#b38">[39]</ref>, dataguides <ref type="bibr" target="#b24">[25]</ref>, reversed dataguides <ref type="bibr" target="#b33">[34]</ref>, 1-index, 2-index and T-index <ref type="bibr" target="#b37">[38]</ref>, and more recently, ToXin <ref type="bibr" target="#b45">[46]</ref>, A(k)-index <ref type="bibr" target="#b32">[33]</ref>, F&amp;B-Index and F+B-Index <ref type="bibr" target="#b30">[31]</ref>, and HOPI <ref type="bibr" target="#b48">[49]</ref>. Dataguides and ROs group nodes into sets according to the label paths incoming to them (each node may appear more than once in the dataguide if the document instance is not just a tree). RIGs, 1-index, T-index, ToXin, F&amp;B-Index, and F+B-Index, on the other hand, partition the data nodes into equivalence classes (called extents in the literature) so that each node appears only once in the summary. The partition is computed in different ways: according to the node labels (RIGs), the label paths incoming to the nodes (1-index, ToXin, A(k)-index), the label paths going out from the nodes (reversed dataguides), or all of the above (F&amp;B-Index and F+B-Index). The length of the paths in the summary also varies: ToXin, 1-index and F&amp;B-Index summarize paths of any length, whereas A(k)index and F+B-Index are synopsis of paths of a fixed length. HOPI is the only proposal designed specifically for graph data instances: it materializes the 2-hop cover of the graph.</p><p>Other summaries are augmented with statistical information of the instance for selectivity estimation, including path/branching distribution (XSKETCH <ref type="bibr" target="#b40">[41,</ref><ref type="bibr" target="#b41">42]</ref>, fXSK-ETCH <ref type="bibr" target="#b14">[15]</ref>) and value distribution (XCLUSTER <ref type="bibr" target="#b42">[43]</ref>). Another proposal contains statistical information for approximate query processing (TREESKETCH <ref type="bibr" target="#b43">[44]</ref>).</p><p>A few adaptive summaries like APEX <ref type="bibr" target="#b10">[11]</ref>, D(k)-index <ref type="bibr" target="#b44">[45]</ref>, and M(k)-index <ref type="bibr" target="#b28">[29]</ref> use dynamic query workloads to determine the subset of incoming paths to be summarized. APEX is a synopsis of frequently used paths of any length. D(k)-index and M(k)-index, in contrast, summarize variablelength paths based on both the workload and local similarity (the length of each path depends on its location in the XML instance). In addition, updates to structural indexes have been studied in <ref type="bibr" target="#b31">[32]</ref> and <ref type="bibr" target="#b60">[61]</ref>. It is important to note that although using a non-temporal summary reduces the search space for TXPath queries it does not help with the temporal semantics of the query evaluation.</p><p>In previous work <ref type="bibr" target="#b36">[37]</ref> we addressed the problem of indexing temporal XML documents and introduced TempIndex, an indexing scheme for continuous paths that improves temporal query performance. In the second part of this paper we discuss TempIndex in detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Temporal XML data model</head><p>First we define a (fairly standard) graph model of an XML document, and then we extend it to a temporal model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">XML documents</head><p>For our purposes, an XML document is a directed labeled graph. We distinguish several classes of nodes:</p><p>-A distinguished node r, the root of the document, such that r has no incoming edges, and every node in the graph is reachable from r. -Element nodes: labeled with an element tag, and containing outgoing links to attribute nodes, value nodes, and other element nodes.</p><p>Each node is uniquely identified by an integer, the node number, and is described by a string, the node label. Edges in the document graph are constrained to be either containment edges or reference edges. A containment edge e c (n i , n j ) joins two nodes n i and n j such that: (a) n i is either r or an element node, and n j is an attribute node, a value node or another element node; or (b) n i is an attribute node, and n j is a value node containing the value for the attribute. Attribute nodes must have exactly one outgoing containment edge (to the attribute's value). A reference edge e r (n i , n j ) links an attribute node n i of type REF, with an element node n j . Finally, node and edge types in our model allow mixed content, i.e. an element node may have different kinds of child nodes, including more than one value node.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Temporal XML documents</head><p>The mechanism we use for adding the time dimension to document graphs consists in labeling edges with intervals. We consider time as a discrete, linearly ordered domain. An ordered pair [a, b] of time points, with a ≤ b, denotes the closed interval from a to b. A set of such intervals is called a temporal element. In what follows we will only consider that edges are labeled with single intervals instead of temporal elements. Later in the paper we will justify this decision. As is common in temporal databases, the current time point will be represented with the distinguished word 'Now'. The document creation instant will be denoted t 0 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Time labels</head><p>We extend the document graph model with temporal labels. A temporal label is an interval T e c labeling a containment edge e c or reference edge e r , respectively. The meaning of this label is that given an edge e c between nodes n i and n j , T e c will represent the time period where the element represented by n j was contained in the element represented by n i . In this paper we will work with the transaction time of the containment relation. Although we do not deal with valid time, it could be addressed in an analogous way. Moreover, we will show that a slight modification to the updates we propose would suffice for supporting a limited notion of valid time. For a reference edge e r , T e r represents the transaction time of the reference. Edges labeled with temporal labels will be called temporal edges. In general, if an edge e is labeled with a temporal label T e , we will use T e .T O and T e .F RO M to refer to the endpoints of the interval T e . We say that two temporal labels T e i and T e j are consecutive if T e j .F RO M = T e i .T O + 1. Note that working with single 123 intervals instead of temporal elements (i.e., sets of intervals) imposes some constraints to the model, which are discussed in Sect. 3.3. Definition 1 (current nodes and edges) A temporal containment (reference) edge such that T e .T O = N ow is called a current containment (reference) edge. A node is called current if one of its incoming containment edges is current. (As we will see below, at most one incoming containment edge can be current.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Attribute nodes</head><p>In the XML data model, attributes must be unique. This limitation influences the way a temporal data model supports these kinds of nodes. We may (a) disallow attributes to vary over time; (b) treat them as elements of a special kind. We chose the second option. From a formal modeling point of view, we make no difference between an attribute and an element node (except that attribute nodes cannot contain other elements). From a practical point of view, we will define a special element, denoted &lt;ATTRIBUTE&gt;. Consider, for example, an element &lt;person&gt; representing a woman, with an attribute called last name; the value for this attribute will change if she marries. This will be treated as follows. (We will explain the syntax later in the paper). At instant t 0 the element &lt;person&gt; looks like &lt;person name="Maria"&gt; &lt;ATTRIBUTES&gt; &lt;last name Time:From="0" Time:To="Now"&gt; Perez &lt;/last name&gt; &lt;/ATTRIBUTES&gt; &lt;/person&gt; ... After marrying at time t 1 , the element will contain: &lt;person name="Maria"&gt; &lt;ATTRIBUTES&gt; &lt;lastname Time:From="0" Time:To="t1-1"&gt; Perez &lt;/last name&gt; &lt;last name Time:From="t1" Time:To="Now"&gt; Perez-Gomez &lt;/last name&gt; &lt;/ATTRIBUTES&gt; &lt;/person&gt; ...</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.3">Temporal data model for XML</head><p>We are now ready to formally define a temporal XML document. First, we introduce the notion of lifespan of a node. Definition 2 (lifespan of a node) The lifespan of a node n, denoted li f espan(n), is the union of the temporal elements of all the containment edges incoming to the node. The lifespan of the root is the interval [t 0 , N ow].</p><p>Example 1 Consider our running example, the NBA database of Fig. <ref type="figure">1</ref>. The fact that McGrady played for the Orlando Magic between instant '21' and the current time, is represented by the current containment edge <ref type="bibr" target="#b1">(2,</ref><ref type="bibr" target="#b15">16)</ref>. The lifespan of node 16 is the union of the elements [0,20] (the temporal label of the incoming containment edge between nodes 5 and 16) and <ref type="bibr" target="#b20">[21,</ref><ref type="bibr">Now]</ref> (the label of the current incoming containment edge). To simplify the figures, we omit all temporal labels of the form [t 0 , N ow].</p><p>The definitions above, imply some consistency conditions that a graph must satisfy in order to be a temporal XML document. The following definition spells these conditions out. Definition 3 (temporal XML document) A Temporal XML Document is a document graph augmented with temporal labels, that satisfies the following conditions:</p><p>1. The union of the temporal labels of the containment edges outgoing from a node is contained in the lifespan of the node. 2. The temporal labels of the containment edges incoming to a node are consecutive. 3. For any time instant t, the sub-graph composed by all containment edges e c such that t ∈ T e c is a tree with root r. We call this subgraph a snapshot of the document at time t, denoted D(t). 4. For any containment edge e c (n i , n j , T e c ), if n j is a node of type ID, the time label of e c is the same as the lifespan of n i ; moreover, if there are two elements in the document with the same value for an ID attribute, both elements are the same. In other words, the ID of a node remains constant for all the snapshots of the document. 5. For any containment edge e c (n i , n j , T e c ), if n j is an attribute of type REF, such that there exists a reference edge e r (n j , n k , T e r ), then T e c = T e r holds. 6. Let e r (n i , n j , T e r ) be a reference edge. Then, T e r ⊆ li f espan(n j ) holds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Discussion</head><p>We will discuss some characteristics of the model, and some assumptions we have made.</p><p>The second condition in Definition 3 implies that we will be working with plain intervals instead of temporal elements (i.e. sets of intervals). This assumption simplifies the presentation and makes the implementations more efficient. Our definitions and theorems can be, however, extended to the case of temporal elements. There are, of course, semantic and practical consequences of our decision. For example, suppose we want to represent the fact that Michael Jordan played for the Chicago Bulls between 1996 and 1998 (i.e., there is a node for the Bulls, another one for Jordan, and an edge between them, labeled with the interval <ref type="bibr">[1996,</ref><ref type="bibr">1998]</ref>); then he retired, and after a year he resumed his career. As the model requires that the edges incoming to a node must be consecutive, we cannot represent this situation adding an edge labeled <ref type="bibr">[2000, Now]</ref>. A solution could be to create a parent node for 'retired' players, with an edge to the Jordan's node (labeled <ref type="bibr">[1999,</ref><ref type="bibr">1999]</ref>), and then, again an edge from the Chicago Bulls' node to the Jordan node, labeled <ref type="bibr">[2000, N ow]</ref>. We can see that this solution does not generate a significant problem (we may even think, in this case, that it could be a natural way of representing the situation). Another solution, more syntactically oriented (and more likely to be used if the non-consecutiveness came from an inconsistency in the document), can be to duplicate the node with temporal gaps in the labels of its incoming edges. An abstract example is shown in Fig. <ref type="figure" target="#fig_0">2</ref>.</p><p>Remark 1 There is no condition preventing more than one edge between the same two nodes. If they are consecutive, we assume they are coalesced into a single node.</p><p>Note that the first constraint in Definition 3 implies that, even though containment edges can only represent containment relations of the same kind in a particular instant, this containment relationship can be a different one in another instant. For example, in the NBA document, a node for McGrady has incoming containment edges from the "team" and "franchise" elements. For any other relationship occurring at the same time we need to use reference edges.</p><p>The constraint of having a unique ID throughout the whole history of the document allows overriding many of the restrictions present in <ref type="bibr" target="#b4">[5]</ref>. However, it introduces other kinds of problems. Let us suppose that in our running example we would like to represent the same information in a different way, namely with the franchises elements "below" the player nodes (e.g., below the McGrady node we find the Raptors and Magic nodes, with the corresponding temporal labels over the containment edges). The problem here is that the ID attribute would not identify a franchise node (two instances of the same franchise, in the same snapshot, will have different IDs). In this case, even though temporal queries could be answered, we are losing the desirable property of having all the information for a franchise in the same node. Here, the temporal key for a franchise should be the value node containing its name. In the remainder of the paper we will assume that all documents comply with the constraint that, in each snapshot, containment relationships are many-to-one from child to parent nodes (like in Fig. <ref type="figure">1</ref>). In other words, all nodes in a path of containment edges are relative keys (in a snapshot) in the sense of <ref type="bibr" target="#b3">[4]</ref>. This, along with the ID constraint, allows identifying a node throughout the document's history.</p><p>Definition 4 (current subtree) We denote D c the subgraph of the temporal XML document D containing no reference edges. Given a temporal XML document D, and a current node n, the current subtree of n, is the subtree of D c (N ow) with root n.</p><p>In the remainder of the paper, for the sake of simplicity, we will consider only containment edges, although all the concepts can be extended to consider also reference edges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 5 (continuous path and maximal continuous path)</head><p>A continuous path (cp) with interval T from node n 1 to node n k in a temporal document graph is a sequence (n 1 , . . . , n k , T ) of k nodes and an interval T such that there is a sequence of containment edges of the form e 1 (n 1 , n 2 , T 1 ), e 2 (n 2 , n 3 , T 2 ), . . . , e k (n k-1 , n k , T k ), such that T = i=1,k T i . We say there is a maximal continuous path (mcp) with interval T from node n 1 to node n k if T is the union of a maximal set of consecutive intervals T i such that there is a continuous path from n 1 to n k with interval T i .</p><p>Example 2 Consider Fig. <ref type="figure" target="#fig_3">3</ref> An interesting property of mcps is that they can be computed visiting each node only once. We will take advantage of this property for query processing (see Sect. 8). Let us consider two nodes n 1 , n k . Let N be the set of nodes n i,i =1,i =k such that there is a continuous path from n 1 to n i , with interval T n i , and there is a containment edge from n i to n k , with label T e i . Thus, each continuous path from n 1 to n k will have interval T i = T n i ∩ T e i . The union of the intervals of these continuous paths will be the interval of the mcp between n 1 and n k , if the intervals are consecutive. This means that all mcps in a graph can be computed visiting each node only once, starting from the root. For example, in Fig. <ref type="figure" target="#fig_3">3</ref> Fig. <ref type="figure" target="#fig_3">3</ref> Maximal continuous path know the interval of the mcp between f 1 and p 1 we can compute the mcp from f 1 to g 1 , without visiting the ancestors of p 1 . In what follows, except when noted, we will assume that all mcp's are computed from the root.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Document order</head><p>In a non-temporal XML document there is a total order between the nodes. A temporal document does not necessarily impose a total order among its nodes, but for any instant t there must be a total order, denoted &lt; t , among the nodes of each snapshot D(t) of document D at time t. In general, for any pair of nodes n 1 and n 2 , we may have n 1 &lt; t 1 n 2 , and n 2 &lt; t 2 n 1 , in two different instants t 1 and t 2 . However, we can show that there is an interval during which the relative order between n 1 and n 2 does not change. If T 1 is the interval on a continuous path from the root to n 1 , and similarly T 2 for n 2 , then the ordering between n 1 and n 2 is the same for any instant t in the interval T 1 ∩ T 2 . This is formalized in the following proposition.</p><p>Proposition 1 Let D be a temporal XML document; n 1 and n 2 two nodes in D; p 1 = (r, . . . , n 1 , T 1 ) and p 2 (r, . . . , n 2 , T 2 ) two continuous paths to n 1 and n 2 with intervals T 1 and T 2 , respectively; then, either n 1 &lt; t n 2 for every t ∈ T 1 ∩ T 2 , or n 2 &lt; t n 1 in every such t.</p><p>Proof By definition of cp (Definition 5) and the third condition of temporal XML document (Definition 3), we know that p 1 is the only path of containment edges to n 1 during interval T 1 . (If there were another path of containment edges p 1 to n 1 during any instant t in T 1 , then the subgraph composed by all containment edges would not be a tree at instant t.) The same argument can be made about p 2 and n 2 during interval T 2 . In particular, p 1 and p 2 are the only paths of containment edges reaching n 1 and n 2 , respectively, during T 1 ∩ T 2 . Thus, during the entire interval T 1 ∩ T 2 , either n 1 &lt; t n 2 or n 2 &lt; t n 1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Consistency of temporal XML documents</head><p>Temporal XML documents, as defined in Sect. 3.2, are subject to continuous updates, which will be studied later in the paper. Such updates must take as input (and return) a consistent XML document. More often than not we will need to check if a temporal document is consistent or not, instead of working with documents built from scratch using update operations. Thus, a study of the cost of such operation is required together with efficient algorithms (not only for checking, but for fixing inconsistencies as well). We will first give consistency conditions for temporal XML documents based on the model presented in the previous section; then, we will propose algorithms for verifying them and give their complexity. In Sect. 9 we will see how this concepts interplay with the update operators that modify a temporal XML document. Definition 6 below, states the possible inconsistencies in a Temporal XML document.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 6 (inconsistencies in a temporal XML document)</head><p>The following are the inconsistencies that may violate the conditions stated in Definition 3.</p><p>(i) There is an outgoing containment edge whose temporal label is outside the node's lifespan. (ii) The temporal labels of the containment edges incoming to a node are not consecutive. Here, the inconsistency may be due to (a) a gap in the temporal labels of some incoming edges; or (b) an overlapping of the temporal labels of some incoming edges. (iii) There is a cycle in some document's snapshot. (iv) There exist more than one node with the same value for the ID attribute.</p><p>In what follows we will refer to these types of inconsistencies as inconsistencies of type (i), type (ii), and so on. We will not study ID attributes (we will limit ourselves to temporal issues here). Thus, inconsistencies of type (iv) will not be addressed. (a) Given that computing I I is, typically, an expensive operation, we have decided to divide the process in two parts: (a) check if the document presents an inconsistency; (b) fix the inconsistency (for this, computing the inconsistency interval is necessary). The user will decide if she wants to execute part (b).</p><formula xml:id="formula_0">root root n1 n3 [0,Now] n2 [0,t1] [t5,Now] [0,Now] (b) (c) n3 n2 n1 [t2,t3] [t2,t6] [t2,t6] [t4,t6]</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Checking consistency</head><p>In this section we will study the complexity of checking consistency in Temporal XML documents, and give an algorithm for such task.</p><p>Throughout this section we will use the following notion of order: given two intervals T 1 and</p><formula xml:id="formula_1">T 2 , if T 1 .T O &gt; T 2 .T O we will say that T 1 succeeds T 2 , denoted T 1 T 2 . Anal- ogously, if T 1 .T O &lt; T 2 .T O, we say that T 1 precedes T 2 , denoted T 1 ≺ T 2 .</formula><p>Our algorithm for checking consistency will use the following proposition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 2 Let D be a Temporal XML document where every node has at most one incoming containment edge in every time instant t; if there is a cycle in some interval I I in D, then, there exists a node n i such that T mcp (n i ) = li f espan(n i ), where T mcp (n i ) is the temporal interval of the mcp between the root and node n i .</head><p>Proof Assume that there is a cycle in document D during an interval I I . Let n i be a node belonging to such cycle. Thus, by definition, we know that li f espan(n i ) ⊃ I I ; however, T mcp (n i ) ∩ I I = φ; if this were not the case, there would be some t such that a path between the root and the node exists, and there cannot exist a node with more than one parent at any instant t.</p><p>We will use this property to check consistency condition (iii). If the property does not hold (assuming that there are no inconsistencies of other types), then, there is a cycle in the document. Algorithm 1 computes the lifespan of a node. Algorithm 1 (computing the lifespan of a node)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>INPUT: A node n OUTPUT: I = [F RO M, T O]; Time interval of the lifespan of the node, or null if I cannot be computed .</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TimeInterval lifespan(node n){</head><p>1. Initialize a list of temporal labels L to null; 2. I = null; 3. for each edge e incident to n with label T e do 4.</p><p>Append (T e ) to L; 5. Sort L; //using the order relation defined above</p><formula xml:id="formula_2">6. I = L[1]; 7. for each i between 1 and length(L) -1 do 8. if L[i].T O + 1 = L[i + 1].F RO M then 9.</formula><p>Return null; 10.</p><formula xml:id="formula_3">I = I ∪ L[i + 1]; 11. end for; 12. Return I }</formula><p>It can be shown that the lifespan of a node can be computed with complexity</p><formula xml:id="formula_4">O(2deg in (n) + deg in (n) * log(deg in (n))) = O(deg in (n)(log(deg in (n)) + 2)) ≈ O(deg in (n) * log(deg in (n)))</formula><p>where deg in (n) is the number of edges incident to n. In the worst case (this considers the case in which all edges are incident to the node), the order of the algorithm is O(|E| * log(|E|)); in the average case all nodes have the same number of incoming edges, i.e. . In the best case (when each node has only one incoming edge) the lifespan is computed in constant time.</p><p>The following algorithm checks inconsistencies of types (i) and (ii). Algorithm 2 (checks inconsistencies of types (i) and (ii))</p><formula xml:id="formula_5">INPUT: A temporal XML document D OUTPUT: True if D has no inconsistencies of types (i) and (ii); False otherwise. boolean checkNodeConsistency(document D) { (1) for each node n in D do (2) I = lifespan(n); (3)</formula><p>if is null(I ) and n is not the root then (4)</p><p>Return False; <ref type="bibr" target="#b4">(5)</ref> for each edge e outgoing from n do <ref type="bibr" target="#b5">(6)</ref> if T e is not in I then <ref type="bibr" target="#b6">(7)</ref> Return False; <ref type="bibr" target="#b7">(8)</ref> end for; (9) end for; <ref type="bibr" target="#b9">(10)</ref>Return T r ue;} Lines 5 to 7 check inconsistencies of type (i), line 3 checks the occurrence of inconsistencies of type (ii) (if the intervals of the incoming edges are not consecutive Algorithm 1 returns null).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>123</head><p>We can see that the main loop iterates at most |V | times (the number of nodes in the document). Lines 2 and 3 check inconsistencies of type (i), computing the lifespan of n, with order O(deg in (n </p><formula xml:id="formula_6">) * log(deg in (n))), as explained above. In total, n∈|V | deg in (n) * log(deg in (n)).</formula><formula xml:id="formula_7">n = f irst(nodes) (6) if !ended(n) then (7) labelList = [T e</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>where e is an edge incoming to n and !traver sed(e)] (8)</head><p>for each e outgoing from n do <ref type="bibr" target="#b8">(9)</ref> if !traver sed(e) then <ref type="bibr" target="#b9">(10)</ref> if T e ∩ T e = φ for some e in labelList then <ref type="bibr" target="#b10">(11)</ref> usable(e) = False <ref type="bibr" target="#b11">(12)</ref> else <ref type="bibr" target="#b12">(13)</ref> usable(e) = T rue <ref type="bibr" target="#b13">(14)</ref> end if; <ref type="bibr" target="#b14">(15)</ref> end for; <ref type="bibr" target="#b15">(16)</ref> end if; <ref type="bibr" target="#b16">(17)</ref> for each edge e(n, n f ) and !traver sed(e) do <ref type="bibr" target="#b17">(18)</ref> if (usable(e)||ended(n)) then <ref type="bibr" target="#b18">(19)</ref> traver sed(e) = T rue <ref type="bibr" target="#b19">(20)</ref> if traver sed(e) = T rue, ∀e incoming to n f then <ref type="bibr" target="#b20">(21)</ref> Append n f to nodes <ref type="bibr" target="#b21">(22)</ref> ended(n f ) = T rue <ref type="bibr" target="#b22">(23)</ref> else <ref type="bibr" target="#b23">(24)</ref> if !visited(n f ) then <ref type="bibr" target="#b24">(25)</ref> Append n f to nodesW ait <ref type="bibr" target="#b25">(26)</ref> visited(n f ) = T rue <ref type="bibr" target="#b26">(27)</ref> end if; <ref type="bibr" target="#b27">(28)</ref> end if; <ref type="bibr" target="#b28">(29)</ref> end if; <ref type="bibr" target="#b29">(30)</ref> end for; <ref type="bibr" target="#b30">(31)</ref> if empt y(nodes) and !empt y(nodesW ait) then <ref type="bibr" target="#b31">(32)</ref> n = First (nodesW ait) <ref type="bibr" target="#b32">(33)</ref> Append n to nodes <ref type="bibr" target="#b33">(34)</ref> visited(n) = False <ref type="bibr" target="#b34">(35)</ref> end if; <ref type="bibr" target="#b35">(36)</ref> end while; <ref type="bibr" target="#b36">(37)</ref> for each node n in D do <ref type="bibr" target="#b37">(38)</ref> if !ended(n) <ref type="bibr" target="#b38">(39)</ref> Return False; (40) end for <ref type="bibr" target="#b40">(41)</ref> Return T r ue } In Algorithm 3, functions traver sed(e) and ended(n) apply to edges and nodes, respectively. A node is ended when all its incoming edges have been traversed. The intuition behind this notion is that, since we are treating isolated inconsistencies, all the edges outgoing from an ended node are usable (i.e., can be traversed). There are two queues: (a) nodes, which holds all nodes such that all of their incoming edges have already been traversed, and (b) nodesWait holding the nodes that have been visited but have incoming edges not yet traversed (the visited function is used to indicate this). Note that if the document is a tree, the latter queue will always be empty. If the two queues are empty, and all nodes are ended, the document contains no cycle. Conversely, if unended nodes remain, there is a cycle in the document.</p><p>Example 4 Let us suppose a graph with nodes root, n 1 and</p><formula xml:id="formula_8">n 2 . The edges are e 1 (r oot, n 1 , [T 1 , T 2 ]), e 2 (n 1 , n 2 , [T 2 , T 4 ]), and e 3 (n 2 , n 1 , [T 3, T 4]). Clearly, there is a cycle in [T 3 , T 4 ] between n 1 and n 2 . When the algorithm reaches n 1 in [T 1 , T 2 ],</formula><p>the node is stored in nodes Wait since n 1 is not ended. Then, as the queue nodes becomes empty, n 1 is removed from nodes-Wait and added to nodes. Also, visited(n 1 ) is set to False. However, when the usability of the edge is checked in line <ref type="bibr" target="#b9">(10)</ref> of the algorithm, there is a non-empty intersection between the temporal labels, and the edge e 3 is not "usable". Thus, there are no more edges to traverse, and remaining unended nodes exist. Then, the document must contain a cycle.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1 Algorithm 3 finds all temporal cycles in the graph, does not loop indefinitely, and only returns False if it finds a cycle.</head><p>Proof 1. The algorithm has a finite number of loops. In each main loop the algorithm visits only edges (not yet traversed) outgoing from a node, and adds to a list the nodes such edges are incident to. When all possible edges have been traversed, no node will be added, and the algorithm will stop.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">(a)</head><p>The algorithm finds all cycles in the graph. Let us suppose there a cycle in the graph and it is not detected by the algorithm (i.e., T rue is returned).</p><p>Let n 1 . . . n k be the nodes in the cycle and T the cycle's interval. Since the algorithm returned T rue, all nodes were "ended", including n 1 . . . n k , meaning that these nodes were visited in T (because, in order to be ended, all incoming edges must be traversed in the whole interval). Let n 1 be the first node visited in T ; it should have been reached from a node n whose incoming edges in T were already traversed. As n 1 was the first one to be visited in such interval, it follows that n does not belong to the cycle; thus, n 1 has a parent outside T and another one inside it, which is a contradiction, because of the precondition stating that no inconsistencies of other kind pre-existed in the document. (b) The algorithm returns False only if there is a cycle.</p><p>Let us suppose there is at least one node n 1 such that ended(n 1 ) = False and no cycle was found. As there cannot be inconsistencies of type i, all edges incoming to n 1 have a temporal label inside the lifespan of the starting node. Let e 1 (n 1 , n 2 , T T ) be an untraversed edge incoming to n 1 ; then, n 2 must be not ended too (i.e., there is at least one not visited incoming edge within T ). Thus, there is a path of unended nodes in T ∩ T ; however, as there are no cycles, all nodes appear only once in the path. Thus, when the algorithm reaches the root (by definition there are no edges incoming to the root), all of its outgoing edges must have been traversed. This is a contradiction, given that, either there are no "not ended" nodes, or there is a cycle in the document.</p><p>We now study the complexity of Algorithm 3. Each node can be visited more than once, depending on the number of incoming edges. The best case is the one where no temporal cycles exist. In this case, lines 6-11 will never be executed. Lines 5 and 6 are of constant order, and the loop in line 17 is executed deg out (n) times; all operations are of constant order, resulting in order deg out (n). Lines 31-34 are also of constant order. The final loop is performed |v| times in the worst case, and the operations are of constant order. Finally, we have:</p><formula xml:id="formula_9">n∈|V | deg out (n) + |V | ≈ O(|E| + |V |).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Fixing inconsistent documents</head><p>In the previous section we provided efficient algorithms that allow the user to quickly check if the document presents inconsistencies. In this section we will discuss how we can correct these inconsistencies. For each kind of inconsistency [(of types (i), (ii) and (iii)]), we study possible fixing procedures. Of course, there are semantic implications for each of the solutions proposed here that the user must be aware of. If these implications are unacceptable for the user, she may just choose dropping the document instead of fixing it. We will study isolated inconsistencies, that is, we assume that everything happens as if the inconsistency under study is the only one in the document. The following definitions will be used in the remainder of this section.  Note that step 4 in Definition 8 performs a duplication of the node from which the deleted edge outgoes. The next example illustrates the situation.   Definition 10 [youngest (oldest) incoming edge] We will denote youngest edge incoming to a node n, y e (n), an edge whose temporal label is the largest (according to the notation above) among all the temporal labels of the edges incoming to n. Analogously the oldest edge incoming to a node n, o e (n), is an edge whose temporal label precedes all the labels of the edges incoming to n.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Inconsistencies of type (i)</head><p>In this case, the temporal label of an edge outgoing from a node is outside the lifespan of the node. We will say that an edge e is inconsistent if its temporal label is outside the lifespan of the inconsistent node (i.e. the origin node of e). For inconsistencies of type (i), the interval of inconsistency I I is the maximum interval within the temporal label of e that is not included in the lifespan of the inconsistent node. Note that I I could actually be a set of intervals (for instance, if the lifespan of the inconsistent node is properly included in the temporal label of the inconsistent edge). In this section we will study the problems introduced by an inconsistent edge. We study two ways of fixing the problem: (a) correction by expansion (expanding the lifespan of the inconsistent node); In this solution, we expand the inconsistent node's lifespan until it covers the violating interval. We may take the youngest or oldest incoming edge, and modify its temporal label in a way such that it covers the whole label of the inconsistent edge. If I I li f espan(n) then we must consider y e (n); if li f espan(n) I I , we must consider o e (n). Note that even though in Example 6 we only expanded one temporal label, this may not be the usual case: the modified interval may fall outside the lifespan of the origin node of the inconsistent edge. Thus, the inconsistency may recursively propagate upward in the path, until a consistent state is reached. To make these concepts more formal, we define the concepts of path of youngest parents and path of oldest parents. We will generically denote these paths expansion paths.</p><formula xml:id="formula_10">root n2 n1 [0,t1] [0,Now] root n2 n1 [0,t1] [0,Now] n3 [t6,Now] [0,t5] n3 [t6,Now] [t2,t10] [t2,Now] [0,t5]</formula><p>Definition 11 (expansion paths) We call youngest parent of a node n, the origin node of y e (n). Analogously, we denote oldest parent of a node the origin node of o e (n). A path of oldest (youngest) parents between two nodes n i , n j is a path where each node is the youngest (oldest) parent of the next node in the path. We denote these paths expansion paths.</p><p>It can be shown that all sub-paths of a path of youngest (oldest) parents are also paths of youngest (oldest) parents.</p><p>Example 7 For the graph in the right hand side of Fig. <ref type="figure" target="#fig_8">7</ref>, the path of youngest parents for node n 3 is (n 3 , n 1 , n 2 , r oot). The path of oldest parents for the same node is (n 3 , n 2 , r oot).</p><p>The problem with the solution by expansion is twofold: on the one hand, we do not really know if the containment relation actually existed in the new interval. An expert user (or curator) will be needed to define this. On the other hand, the expansion may introduce a cycle [i.e., an inconsistency of type (iii)]. In this case, expansion will not be a possible solution. We characterize the latter situation defining the Instant of Maximal Path Expansion (IMPE). The idea is that if we expand the interval beyond the IMPE, a cycle will be produced.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 12 [instant of maximal path expansion (IMPE)]</head><p>Let P = (n 1 , n 2 , . . . n f ) be an expansion path between n 1 and n f , and let e i (n i , n i+1 , T i ), with 1</p><formula xml:id="formula_11">≤ i ≤ f -1, be the edges in this path. Let m = min{T 1 .T O, . . . , T f -1 .T O} and M = max{T 1 .F RO M, . . . , T f -1 .F RO M}. Let L = [(n f , . . . , n 1 , T 1 ), . . ., (n f , . . . , n f -1 , T f -1 ) be a list of mcps such that (n f , . . . , n k , T k ) is an mcp from node n f to node n k , with 1 ≤ k ≤ f -1.</formula><p>We define the Instant of Maximal Path Expansion of P, denoted I M P E(P) as:</p><formula xml:id="formula_12">IMPE(P) = ⎧ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎨ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎩ the maximum instant t such that t ≥ m and [m, t] ∩ T j = φ ∀ j ∈ 1 . . . f -1, if P is a path of youngest parents. minimum instant t such that t ≤ M and [t, M] ∩ T j = φ ∀ j ∈ 1 . . . f -1, if P is a path of oldest parents.</formula><p>The intuition behind this definition is that, in the case of a path of youngest parents for instance, the IMPE of a path P = (n 1 , . . . , n f ) is an instant greater than the minimum ending point of the intervals in an expansion path, and less than the starting point of the intervals of all mcps starting from a node reachable from n f , and ending at node n 1 .</p><p>Example 8 Figure <ref type="figure" target="#fig_4">8</ref> shows a graph with the expansion path (actually a path of youngest parents) (n 2 , n 4 , n 5 ). Node I violates consistency condition of type (i). A solution for this could be to expand the lifespan of I . In this case, IMPE(n 2 , n 4 , n 5 ) = 24, because t = 24 is greater than the minimum ending time of the intervals in the expansion path, and less than the interval of the mcp between I and n 2 . Thus, expanding to t = 25 would introduce a cycle. Then, the inconsistency cannot be solved by means of lifespan expansion.</p><p>Theorem 2 Let D be a document with an inconsistence of type (i) in a node n. Then, the IMPE is the maximum instant to which an edge interval in an expansion path can be expanded without introducing a cycle in the document.  Proof We will study the case of a path of youngest parents. (The case of a path of oldest parents is analogous.) Let us assume that we expand an interval until the IMPE, and a cycle is generated. Then, this implies that there is a path in some instant t ∈ [min(T i .T O), I M P E] (see <ref type="bibr">Definition 12)</ref>, between (a) n f and n i for some n i in the path of youngest parents; (b) n j and n i for some n i , n j in the path of youngest parents. In case (a), this would imply t ∈ T k i , for some mcp(n f , n k , T k i ), contradicting the definition of IMPE. In case (b), before the expansion, n i and n j were consistent before the expansion, thus, t ∈ li f espan(n i ) ∧ t ∈ li f espan(n j ) holds, implying that the cycle was pre-existent.</p><p>(b) Correction by reduction. The main idea of this solution is to modify the temporal label of the inconsistent edge, in a way such that it lies within the lifespan of the starting node of such edge. It may even be necessary to delete this edge if its temporal label does not intersect the lifespan of the inconsistent node. Although not cycles can be introduced by this solution, it may introduce new inconsistencies of type (i) in the ending node of the modified edge if this node has outgoing edges that cover the interval that has to be reduced; moreover, inconsistencies of type (ii) may also be introduced if the deleted interval was not in one of the lifespan's extremes.</p><p>The algorithm for this solution proceeds as follows: it first deletes the edge in the interval of inconsistency. Then, it visits the node at the end of this edge and repeats the process until a consistent document is obtained. The number of iterations required by this solution is given by: n∈V deg out (n) ≈ O(|E|). Finally, in the worst case, inconsistencies of type (ii) must be fixed (with order |E| 2 , see below), yielding an order of</p><formula xml:id="formula_13">O(|E| + |E| 2 ) ≈ O(|E| 2 ).</formula><p>Example 9 Figure <ref type="figure" target="#fig_12">9a</ref> and<ref type="figure">b</ref> show a graph where the correction by reduction approach generates new inconsistencies of type (i) and (ii). In Fig. <ref type="figure" target="#fig_12">9a</ref>, reducing to <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b49">50]</ref> the interval of the edge (n 2 , n 3 ) introduces a gap in node n 3 . In Fig. <ref type="figure" target="#fig_12">9b</ref>, the same correction will make the temporal label of the edge (n 3 , n 4 ) lie outside the lifespan of node n 3 .</p><p>(c) Expansion versus. reduction The discussion above showed that both fixing procedures, i.e., correction by expansion or correction by reduction may propagate upward or downward in cascade, respectively. For example, in the case of Fig. <ref type="figure" target="#fig_8">7</ref>, assume that the label of the edge (r oot, n 2 ) is [0, Inconsistencies of type (ii) As we already explained, these kinds of inconsistencies occur when some edges incoming to a node are not consecutive. This may be caused by: (a) overlapping of temporal labels, involving two or more of them; (b) the union of the temporal labels of the edges incoming to a node presents a temporal gap. For fixing overlapping it suffices just to delete one of the violating edges in the interval of inconsistency. Fixing the gaps has more than one possible solution: (a) physically delete all incoming edges until the gap is closed; (b) expand the temporal labels of the edges, in order to close the gap (this could be performed expanding the temporal labels of one or more of the edges involved); (c) treat the inconsistency from a syntactic point of view, duplicating the violating node in a way such that the resulting incoming and outgoing edges have consistent temporal labels. This duplication is based on the same concepts underlying the fourth step of Definition 8.</p><p>The first two options have the following problem: they may introduce new inconsistencies of type (i) (for example, if the violating node is n, and there is an edge e(n i , n, T e ), and T e is expanded to T e , the latter label may be outside the lifespan of n i . Thus, we think the third option is the best one, if the node created is semantically equivalent and syntactically consistent. Figure <ref type="figure" target="#fig_14">10</ref> shows a gap inconsistency in node n fixed by node duplication at time instant 9. Note that in this case, duplication eliminates the gap between the time label of the edges incoming to n.</p><p>The algorithm for fixing inconsistencies of type (ii) visits all the document's nodes looking for gaps or overlapping. If an overlapping is found, one of the edges involved is deleted in the interval where the overlapping is produced. If a gap if found, the algorithm performing node duplication is called. Each time a node n is visited, the calling to the node duplication algorithm is performed deg in (n) times. This gives the algorithm an order of O(|E|) 2 .</p><p>Inconsistencies of type (iii) Inconsistencies of type (iii) involve cycles occurring in some interval(s) of the document's lifespan. In this case, again, we have more than one possible way of fixing the inconsistency, basically consisting in deleting (according to Definition 8) edges within the cycle. We may: -delete all containment edges involved in a cycle during the inconsistency interval I I (i.e., in this case, the interval when the cycle occurs). This can be performed (a) by deleting (within I I ) all the subgraphs with root in each of the nodes in the cycle; or (b) by expanding the expansion path (see <ref type="bibr">Definition 11)</ref> for each node belonging to the cycle. -delete (within the interval of inconsistency) one of the edges in the cycle. Given that this would introduce an inconsistency of type (i), this solution is only possible if there is at least one node n in the cycle with more than one incoming containment edge e c (n i , n, T e ) such that T e lies outside I I . Thus, besides deleting the edge, T e must be expanded in order to prevent introducing a new inconsistence.</p><p>Example 10 Figure <ref type="figure" target="#fig_15">11</ref> shows the two alternatives for fixing an inconsistency of type (iii). In Fig. <ref type="figure" target="#fig_15">11b</ref> all edges involved in the cycle are deleted during I I = [0, 15]. In Fig. <ref type="figure" target="#fig_15">11c</ref>, the cycle was eliminated by only deleting the edge incoming to n 1 in the interval [0, 15], and expanding the temporal label of the remaining edge incoming to n 1 (i.e., the label is now [0, 35]), in order to avoid an inconsistency of type (i).</p><p>Algorithm 4 performs cycle elimination by deleting all the edges within the interval of inconsistency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 4 (fixing an inconsistency of type (iii))</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>INPUT: A document D, with a cycle C in an interval T c . OUTPUT: a legal temporal XML document</head><formula xml:id="formula_14">Fixcycle(D, C, T c ) { (1) n c = a node in C (2) nodes_stack = [n c ] (3) while node_stack is not empty do (4) n = node_stack.pop() (5) visited(n) = T rue (6)</formula><p>for each edge e = (n, n d , T e ) outgoing from n, T c ∩ T e = φ do <ref type="bibr" target="#b6">(7)</ref> delete e in T c <ref type="bibr" target="#b7">(8)</ref> if n d has no other incoming edges and T e ⊆ T c then <ref type="bibr" target="#b8">(9)</ref> delete the subtree with root n d <ref type="bibr" target="#b9">(10)</ref> else <ref type="bibr" target="#b10">(11)</ref> if !visited(n d ) <ref type="bibr" target="#b11">(12)</ref> node_stack.push(n d ); <ref type="bibr" target="#b12">(13)</ref> end if <ref type="bibr" target="#b13">(14)</ref> end for <ref type="bibr" target="#b14">(15)</ref> end while <ref type="bibr" target="#b15">(16)</ref> Fix possible inconsistencies of type ii. <ref type="bibr" target="#b16">(17)</ref> return D } Line ( <ref type="formula">16</ref>) fixes all possible inconsistencies (basically gaps) that could have been introduced by a sequence of edge eliminations. Successive deletions of edges incoming to the same node may cause more than one gap when the labels of these edges were not at the beginning or the end of the node's lifespan. This would result in many node duplications. Thus, we decided to postpone node duplication to the end of the algorithm, because if the edges that are deleted have consecutive intervals the gaps could be solved in one single step (i.e., with just one node duplication). Figure <ref type="figure" target="#fig_16">12</ref> shows an example of this: the regular procedure for deleting edges (n 6 , n 5 ), (n 2 , n 5 ) and (n 3 , n 5 ) implies three node duplications, in that order. Instead, if we just delete the edges and leave the action of fixing the gaps to be performed at the end of the whole process, we would have to perform just one node duplication and obtain the same end result (i.e., node n 5 and a copy of it, with intervals [0, 1] and [20, N ow] respectively). The algorithm has an order O(|E| 2 ) due to this last step.</p><p>The algorithm for eliminating a single edge in the cycle essentially picks a node n in the cycle such that n has at least another incoming edge with temporal label not in the cycles' interval T c . The algorithm then deletes the edge incoming to n in T c and expands (if possible, i.e., using the notion of IMPE introduced above) the lifespan of n including T c in this lifespan, to avoid inconsistencies of type (i).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Model implementation</head><p>The abstract temporal model introduced in Sect. 3.2 can be encoded into a concrete XML document in many ways. We distinguish between non-replicated representations, where each node of the graph is represented by a single XML element or attribute, and replicated representations, where a node is represented by multiple elements or attributes. In the non-replicated representations, the nesting relationship of the resulting document is used to encode the "oldest" containment edges, while the remaining containment edges are represented by references. In the top-down version, the references go from parent to child, while in the bottom-up version they go from child to parent. Experiments we performed showed that the non-replicated representation outperforms the other ones in terms of space. Moreover, the replicated representations have some semantic issues we will briefly discuss. Thus, we will focus on the top-down non-replicated representation, which we will describe in detail in this section. For completeness of analysis we will give a quick idea of the other ones.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Non-replicated representations</head><p>The non-replicated representation comes in two flavors: (a) top-down, and (b) Bottom-up.</p><p>(a) Top-down. The root of the graph maps to the root element of the document. For each element node there will be an element in the document, tagged with the label of the node. If the element node has a containment edge to a value node, the corresponding value is included in the element. For each attribute node there will be an attribute in the document, and its value will be the unique value node associated to the attribute node. If the attribute is of type REF, the value of the attribute will be the ID of the node being referenced.</p><p>Let e(n i , n j , T e ) be one of the containment edges incoming to a node n j . The element elem n i representing n i in the XML document will physically include the element elem n j , tagged with the interval T e . Thus, there will be only one element representing n j in the document. For each node n k in the remaining edges e(n k , n j , T e k ) incoming to n j , a distinguished reference attribute denoted IN with the value of the ID in elem n j and label T e k will be placed in the element elem n k .</p><p>The containment edges to be physically encoded in the XML document can be selected in many different ways. In general, we can chose a time instant t and for each containment edge e(n i , n j , T e ) such that t ∈ T e , physically include n j in n i (this is equivalent to taking a snapshot of the graph at time t and generate the XML document representing this snapshot); other containment edges incoming to n j (if they exist) will be referenced as explained above. All nodes n j such that t is not included in T e , must be added afterward. As another alternative, we could take a different time instant t j for each node n j and physically include n j in n i if there is a containment edge e(n i , n j , T e ) and t j ∈ T e . Following this approach, in the work presented here we physically encoded the "oldest" containment edges.</p><p>Example 11 For the sake of clarity, in the following examples we will use a simplified syntax for the XML documents resulting from the various mappings. For instance, we use the notation &lt;franchise ID='1'[0,N ow]&gt; to mean that the time interval associated with this element is [0,Now]. (Note that we use integers to represent time points instead of actual date/time values, also for simplicity). In an actual implementation, we define a namespace and create three new attributes: 'FROM'(the starting point of the interval), 'TO'(the ending point of the interval), and 'IN' (the reference to a contained element). In Sect. 5.4 we describe the implementation of temporal features in more detail.</p><p>Figure <ref type="figure" target="#fig_17">13</ref> depicts a portion of the document resulting from mapping the graph in Fig. <ref type="figure">1</ref>. Here, attributes o f ID type have no temporal tag. Let us consider the second player element, with temporal interval [0,20]. The "oldest" containment edge approach has been chosen, resulting in the inclusion of this player in the &lt;team&gt; element corresponding to the Toronto Raptors. The construct &lt;player[21,N ow] IN='16'/&gt; represents a current containment edge going from node '2' to node '16' with time label <ref type="bibr">[21,N ow]</ref>. This means that the information about this player is physically encoded in the element with ID = '16'.</p><p>(b)Bottom-up. In the top-down representation we picked the oldest containment edge to be represented by physical inclusion, while the others were represented by references from parent to child. We could instead have the references going from child to parent. For example, instead of placing a reference to node '16' between instants '21' and 'Now', we place a reference from the player to his current franchise. The </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Node-replicating representation</head><p>A third alternative to the representation described above avoids using the 'IN' reference. This implementation requires transforming the original graph into a tree of containment edges. This is performed, in short, recursively creating k copies of each node n with k (k &gt; 1) incoming containment edges. This process is similar to the one described in Definition 8 and transforms the temporal XML document into a tree of containment edges. Figure <ref type="figure" target="#fig_18">14</ref> shows a portion of the graph for the NBA database with node replication, where the node for player with ID='14' has been duplicated, denoting '14 ' the new ID. As a convention, for each node with node number n that is duplicated, we denote its new versions n . Note that the lifespan of node 12 (the interval [0, N ow]) has been split into intervals [0, 22] and <ref type="bibr">[23, N ow]</ref>. This shows the biggest weakness of this approach: node replication is not appropriate when the value nodes contain data that aggregates over time. In Fig. <ref type="figure" target="#fig_18">14</ref>, we have assigned values 12 and 10 to nodes 12 and is replica, respectively, assuming that the value associated to the original node (22 goals in this case) is partitioned proportionally to the lifespan of the nodes involved in the replication.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Node-edge representation</head><p>A fourth way of implementing a temporal XML document is to store the edges and nodes of the graph in a way similar to the edge XML-to-relational mapping <ref type="bibr" target="#b20">[21]</ref>. The idea is to list the nodes and the edges in the graph, using attributes for their Fig. <ref type="bibr" target="#b14">15</ref> Implementation of temporal attributes validity intervals and other features like references or attributes. For instance, there are two elements, NODE and EDGE, that define the nodes and the edges respectively. Additionally, there are two attributes, Origin and End (defined within a namespace), that represent the node numbers that are the endpoints of each edge. Finally, a Type attribute defines the type of the node being represented (i.e. element, attribute or value nodes).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Implementation of temporal attributes</head><p>As we commented above, the syntax for intervals and distinguished references introduced in the temporal document was simplified for the sake of the paper's clarity. In a real implementation, we need to define a namespace and create three new attributes: 'FROM'(the starting point of the interval),'TO'(the ending point of the interval), and 'IN' (the reference to a contained element). We denote this namespace 'Time', and its associated URI is defined as 'http://www.cs. toronto.edu/db/time'. Attributes 'Time:FROM' and 'Time: TO' introduce potential attribute duplication in a tag. Thus, we adopted the solution explained in Sect. 3. Figure <ref type="figure" target="#fig_22">15</ref> shows an example. Note that for references of type IN, we defined a special attribute 'Time:IN', included in the tags of the types of the element being referenced (see for example, tags &lt;team&gt; and &lt;player&gt;).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Snapshots</head><p>In temporal relational databases it is often relevant to compute snapshots of the data. In temporal XML we would like to be able to reconstruct a document as of a given time instant. We call this a document snapshot. In Sect. 6 we will distinguish this concept from the notion of snapshot query. In this section we briefly show how to compute a document snapshot (at time t) of a temporal document implemented as described in Sects. 5.1 (using the top-down alternative) and 5.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Snapshots in a non-replicated implementation</head><p>The following procedure computes a document snapshot as of a time instant t, when the temporal document is implemented using the top-down non-replicated implementation.</p><p>-There is a non-annotated tag T in D(t) for every tag T in D annotated with a temporal element T e where: (a) t ∈ T e ; (b) T is not contained in any tag T 1 such that there exists a distinguished reference of type IN to T 1 at time t (see <ref type="bibr">Example 12)</ref>. -For every reference r annotated with a temporal element T e such that t ∈ T e included in an element satisfying condition (b) above, there is a non-annotated reference r in D(t). -For every attribute a = v (where v is the value associated to a) annotated with a temporal element T e such that t ∈ T e included in an element satisfying condition (b) above, there is a non-annotated attribute a in D(t). -If within a tag T in D there is a tag T 1 with a reference R of the form IN = v to an element with ID = v (also with tag T 1 ) such that for the temporal element labeling R, call it T r , t ∈ T r holds, include in D(t) the complete element being referenced (i.e., T 1 ) as the last subelement within tag T, excluding the sub-elements with temporal labels T i where t ∈ T r . Finally, replace IN = v with ID = v in T 1 . -The former are the only transformation rules applying to the document.</p><p>Example 12 We will give an example of the procedure above, using the document in Fig. <ref type="figure" target="#fig_17">13</ref>. When taking a snapshot at time '24', the tag &lt;player[0,20] ID='16'. . . &gt; neither verifies condition (a), nor condition (b). The tag &lt;name[0, N ow]&gt; McGrady &lt;/name&gt; verifies condition (a) but not condition (b), which prevents its inclusion in the snapshot (inside the player tag). However, notice that there is a tag &lt;player[21, N ow] IN='16'. . . &gt; (T 1 in the fourth step above), included in the franchise tag with ID='2' (tag T above). Thus, because of the fourth step of the algorithm, the snapshot will have an element &lt;player ID='16'. . . &gt;. Also, all the sub-elements of &lt;player[0,20] ID='16'. . . &gt; will be included in the &lt;franchise&gt; tag (note that all the sub-elements are labeled [0, N ow] in the document, and that a snapshot does not have temporal labels).</p><p>A portion of the resulting snapshot is shown in Fig. <ref type="figure" target="#fig_19">16</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Snapshots in a node-replicating implementation</head><p>Taking a snapshot at time t of a temporal document implemented as described in Sect. 5.2 just requires scanning the document and placing a tag for every tag in D annotated with a temporal element T e such that t ∈ T e . Analogously, an attribute and/or reference must be created for each attribute and/or reference associated with a temporal element including t.</p><p>The node-replicating implementation requires only one pass through the document for computing a document snapshot, while the non-replicated implementation requires at least two, the first one for finding the references, and the second one for generating the snapshot. This is compensated by the size of the produced document, which, due to node duplication, is two to three times larger than an equivalent document with no duplicates. As a result, computing a document snapshot in both representations takes, on the average, approximately the same time. In Sect. 10 we provide experimental results on snapshot computation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">TXPath: a temporal extension to XPath</head><p>One of the motivations for proposing a temporal data model is to support query languages that make complex queries easy to express. For example, consider the query "players who played for the Toronto Raptors continuously since at least the year 2000." In this section we introduce TXPath, a temporal query language that extends XPath 2.0 <ref type="bibr" target="#b59">[60]</ref> with temporal operators in order to enable this kind of query. As we only intend to show the main ideas of this extension, we will not discuss the details or standard temporal database issues like temporal comparisons and granularity, that are treated in the usual way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Syntax and semantics</head><p>In non-temporal XPath 2.0, the meaning of a path expression is the sequence of nodes, at the end of each path, that matches the expression. In TXPath, the meaning is a sequence of (node,interval) pairs such that the node has been at the end of a matching path continuously during that interval (i.e., at the end of a continuous path).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 17 Formal semantics of TXPath</head><p>We stay as close as possible to the XPath syntax, extending it with temporal operators. We specify the TXPath semantics adapting the formal XPath semantics introduced by Wadler <ref type="bibr" target="#b53">[54]</ref>. The meaning of an XPath expression is specified with respect to a context node; we extend this to a context pair of a node and a time interval. We define three semantic functions: S, Q and Q T such that S[[ p]]x denotes the sequence of pairs (node, interval) (or values, as we will see below) selected by pattern p when x is the context pair. The boolean expression Q[[q]]x denotes whether or not the qualifier q is satisfied when the context pair (node, interval) is x. Finally, another boolean expression Q T [[q T ]]x denotes whether or not a temporal condition q T is satisfied. For the sake of brevity, in Fig. <ref type="figure" target="#fig_8">17</ref> we only show the most common TXPath constructs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 13</head><p>The expression //player, applied to the document in Fig. <ref type="figure" target="#fig_3">3</ref>, will return the sequence ( p1, [95, N ow]), ( p2, [99, N ow]), ( p3, [98, N ow])).</p><p>With respect to our running example, the query "players who have played for the Toronto Raptors continuously since the year 2000" reads in TXPath: //franchise[name='Raptors']//player[@from≤2000 and @to='Now']</p><p>We use the XPath construct @from to refer to the starting point of the interval associated with each node in the answer, and similarly for @to.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">TXPath by example</head><p>We will briefly present and discuss the main features of TXPath, in order to give the idea of the kinds of queries that can be supported.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Coalescing sequences</head><p>In temporal queries it is often useful to coalesce sets of overlapping intervals. We define the coalesce operation over a sequence of pairs (value(node), interval), where value(node) stands for the value associated to a value node, to generate a new sequence where all maximal sets of overlapping intervals are coalesced into single intervals when the values are the same. For example, given a sequence S=((2, <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b4">5]</ref>), <ref type="bibr">(2,[3,8]</ref>), <ref type="bibr">(4,[12,16]</ref>), <ref type="bibr">(4,[14,18]</ref>)), coalesce(S) returns the sequence ((2, <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b7">8]</ref>), (4, <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b17">18]</ref>)). Given an arbitrary sequence of pairs, we extend the XPath distinct-values operator to group all pairs that have the same node component and coalesce the resulting subsequence. For example, the query "goals scored by Carter whenever a change in his scoring occurred" is expressed as distinct-values(//player[name='Carter']//goals)</p><p>This query only returns one pair (goal, interval) for each sequence of k consecutive or overlapping seasons where Carter scored the same number of goals, instead of the k pairs that would be returned without using the distinct-values statement.</p><p>Aggregation XPath 2.0 has aggregate operators that can be applied to a sequence of nodes to compute its sum, average, etc. In addition, we can take advantage of these operators by applying them to sequences of time points, as the next example shows. The query "name of the players who were with the Orlando Magic when McGrady joined the franchise for the first time" is expressed in TXPath as In the query above, min returns the minimum time instant in the result set, and this value is used to qualify the results in the next part of the query. Snapshots In Sect. 5 we discussed document snapshots based on the different implementations of the abstract temporal data model. Obtaining a document snapshot means reconstructing a temporal XML document as of a given time instant. In order to express document snapshots in TXPath we would need to introduce user-defined functions like the ones supported in XQuery. On the other hand, snapshot queries can be expressed in TXPath within the framework given by the syntax and formal semantics introduced in Sect. 6.1. A snapshot query at a time instant t is simply a query that retrieves a portion of a document as of t. The query returns a sequence of pairs (node, interval) such that the interval contains the instant t.</p><p>An example of a snapshot query is "Give me the player nodes for players with the Toronto Raptors on October 10th, 2001". This query reads in TXPath:</p><p>NBAdb/franchise[name='Raptors']//players [@from ≥ '10/10/01' and @to ≤ '10/10/01']</p><p>Assuming that the date 10 October 2001 is represented by instant 15, the result of this query over the database of Fig. <ref type="figure">1</ref> is the sequence ((6, [0, 20]), (10, [0, N ow]), <ref type="bibr">(16, [0, 20]</ref>)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">The notion of "Now"</head><p>It is a well-known fact in temporal databases, that using a current time variable has several implications which require the definition of a precise semantics <ref type="bibr" target="#b11">[12]</ref>. Since our model follows the transaction time approach, the problems arising from the use of Now are considerably reduced compared with a valid time data model. The main reason for this is that in valid time databases timestamps are provided by the user, while in transaction time databases these values are usually built-in, i.e., provided by the database management system (DBMS).</p><p>The semantics adopted for Now in this work is the one proposed in <ref type="bibr" target="#b11">[12]</ref>. Therefore, the meaning of the current time variable is that, if the ending point of a temporal label is T.T O = N ow, the edge is valid from T.T O (the starting point of the label) until the timestamped element is updated, yielding the so-called until changed semantics. This will become evident in Sect. 9, where we discuss updates. A direct consequence of this decision is that T.F RO M can never be stamped with Now, as it could be the case in valid time databases.</p><p>From the language point of view, we have decided that the syntax for representing the current time variable uses the distinguished constant 'Now'. At the implementation level, for simplicity we have defined the maxint value for representing the end of time (some systems use '999-12-31' for representing this value). Also, a current-date function is applied when needed, that is, when 'Now' is found in a query, or maxint is found in the database.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Structural summaries for temporal XML</head><p>As we mentioned in Sect. 1, efficiently querying temporal XML documents requires the ability to find the paths in the graph that were valid at a given time (i.e. the continuous paths in the document). This ability is not provided by traditional path summaries. Our proposal for a new class of summaries, which we call TSummary, adds the time dimension to the usual path summarization by considering continuous paths to element or value nodes. TSummary is the theoretical framework behind TempIndex, our indexing scheme for temporal XML data <ref type="bibr" target="#b36">[37]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Summarizing continuous paths</head><p>Structural summaries are data structures used to locate specific fragments of the XML data, such as nodes, paths and subtrees. By accessing relevant data directly they help to avoid sequential scans of entire documents during query evaluation. Since our goal is to optimize TXPath query evaluation, the (temporal) XML fragments we want to summarize are continuous paths. A TSummary includes a graph that describes the continuous paths in the temporal document in a concise way. Nodes in the temporal document are partitioned into equivalence classes. Each node in a TSummary graph will have associated to it one such equivalence class, which we call the temporal mapping (or tmap) of the summary node.</p><p>Like in non-temporal XML, a concise representation of the nodes based on their labels is a useful summarization of the temporal XML graph structure. The first TSummary we will present in this work is the LCP summary which summarizes labels of continuous paths from the root. Traditional path indices <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b37">38]</ref> often define equivalence classes of nodes that belong to paths with the same label. In contrast, the LCP Summary defines equivalence classes of nodes that belong to cp's from the root with the same label. Since we also need to summarize temporal intervals, we will define a summary that describes cp's regardless of their labels. One way of doing that is to cluster together nodes that belong to cp's from the root with the same length. This is in fact the definition of another TSummary, the interval summary.</p><p>We introduce next our formalization of temporal summaries we will use in the remainder of the paper. Since we need for the edge structure of the summary to somehow describe the structure of the temporal document, there has to be a relationship between the summary edges and the temporal XML graph edges. This relationship is given by the following property.</p><p>Property 1 (edge property) A temporal summary S D has the edge property iff its edges are defined by edge as follows:</p><formula xml:id="formula_15">edge := { s, s | ∃ s, n, I ∈ tmap ∧ ∃ s , n , I ∈ tmap ∧ ∃e c (n, n , I e ) ∈ D}</formula><p>That is, there is an edge between two nodes in the summary iff there is a containment edge between any two nodes in their temporal mappings.</p><p>In order to define our first TSummary, we will need the notion of label of a continuous path. The standard notion of label paths can be easily extended to continuous paths as follows. Let p = (n 1 , . . . , n k , T ) be a continuous path with interval T . The label path of p, or continuous label path λ( p) is the concatenation of the labels of the n i in p.</p><p>We are able to introduce now the LCP summary, a TSummary that summarizes labels of continuous paths from the root. Note that tmap defines a partition of T Node where two pairs belong to the same equivalence class iff they have incoming continuous paths with the same labels. Also note that there is a one-to-one mapping between the equivalence classes defined by tmap and the summary nodes in T Sum.</p><p>The following example shows the LCP summary for the NBA database fragment of Fig. <ref type="figure">1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 14</head><p>The LCP summary graph G S = (T Sum, edge, Label, λ) for the NBA database is shown on the left side of Fig. <ref type="figure" target="#fig_23">18</ref>, where T Sum = {s 1 , . . . , s 13 }, edge is defined by the edges in the figure, Label = {NBA, franchise, name, last, team, player, stats, goals}, and λ is defined by the label assigned to each node in the figure. In addition, the tmap relation of the LCP summary S D is given by the following table: Since cp's in the LCP summary are clustered by label, we need additional summaries to describe the intervals and to capture the node ordering &lt; t at any given instant (as defined in Proposition 1). In order to do that, we will introduce next a TSummary based on the notion of temporal depth. Definition 16 (temporal depth) Consider a temporal XML document D. For each node n in D such that there exists a For each temporal depth k, we define the nodes that are valid at that depth during an interval I as follows.</p><formula xml:id="formula_16">tmap s 1 0, [0, N ow] s 2 1, [0, N ow] s 2 2, [0, N ow] s 2 3, [0, N ow] s 3 4, [0, N</formula><p>Definition 17 (node validity) A node n is valid at temporal depth k in an interval I iff there exists an interval I such that δ(n, I ) = k and I ⊆ I .</p><p>Based on the notions of temporal depth and node validity we introduce next the interval summary, a TSummary that clusters together nodes that belong to cp's from the root with the same length. Note that δ(n, I ) defines an equivalence relation between the nodes in the temporal XML graph where for each pair n, I in a class the length of the continuous path from the root to n is the same.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 15</head><p>The interval summary graph G S = (T Sum , edge , Label , λ ) for the NBA database is shown on the right side of Fig. <ref type="figure" target="#fig_23">18</ref>. Since the difference in labels does not matter here, several LCP summary nodes may "collapse" into one in the interval summary. For instance, nodes s 3 , s 4 and s 10 of the LCP summary are represented by node s 2 in the interval summary. This also impacts on the definition of tmap for the interval summary S D : all pairs n, I that belong to nodes s 3 , s 4 and s 10 in S D (see tmap definition in Example 14) belong to node s 2 in S D .</p><p>Whereas the LCP summary provides a combined label path + temporal clustering, the interval summary is in fact a pure temporal clustering. This kind of clustering does not consider node labels or label paths and therefore can be used for efficiently selecting nodes based solely on their intervals. This functionality is useful for computing document snapshots and for some stages in the evaluation of TXPath queries (see Sect. 8.2).</p><p>There are many proposals in the literature for indexing temporal intervals. Some of them are based on the methods proposed by Bozkaya et al. <ref type="bibr" target="#b2">[3]</ref> and Salzberg et al. <ref type="bibr" target="#b46">[47]</ref>, where a B+ tree indexes the FROM value in the intervals being indexed, and each internal node is augmented with the information of the maximum TO value in an interval of the corresponding subtree. These proposals are "indexing" schemes rather than summaries. That is, they provide low level index structures and access methods for optimization. In contrast, TSummaries are high level descriptions of the temporal data which are in turn implemented by indexing schemes. In the next section we provide a description of our own indexing scheme, TempIndex, but TSummaries could also be implemented by combining other well-known interval indexes and access methods like the ones mentioned above.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">TempIndex: an indexing scheme for temporal XML</head><p>In order to optimize TXPath query evaluation, we need to integrate LCP and interval summaries in an effective way. In addition to the summaries themselves, we need indexes, access methods and additional data structures with information about the hierarchical relationships between nodes in a temporal XML documents. We present here TempIndex (introduced in previous work <ref type="bibr" target="#b36">[37]</ref>), an indexing scheme that integrates LCP and interval summaries with additional indexes for efficient navigation.</p><p>For representing the structural relationship between nodes in different equivalence classes we define what we call CP tables. Each CP table is associated to a summary edge and stores the parent-child relationship between document nodes in the two equivalence classes of the end-points of such edge. In addition, CP tables contain the interval of the continuous paths ending at the child equivalence class. The information contained in the CP tables is used during query evaluation to traverse continuous paths with a given label and interval (see Sect. 8 for more details). Note that nodes 17 ("McGrady") and 30 ("Williams") appear in both tables but with different intervals. This happens because we are indexing cp's rather than nodes, and both nodes have two cp's ending at them.</p><p>For each temporal depth k, we will define a table called δ k table, listing the nodes that are valid at certain intervals and their relative order. These intervals are obtained by taking all the intervals that label some continuous path of length k and partitioning them as needed to obtain a set of pairwisedisjoint intervals. This is formalized with the notion of interval partition.</p><p>Definition 20 (interval partition) The interval partition P of a set of intervals I 1 . . . I n is the smallest set of intervals P = P 1 . . . P m such that all the P i 's in P are pairwise disjoint and P contains a partition of every interval I j .</p><p>Definition 21 (δ k tables) Consider a temporal XML document D. For each temporal depth k in D there is a table called δ k table. Each tuple t in a δ k table has two temporal attributes, from, to, and a list-valued attribute valid. Let I 1 . . . I n be all the intervals such that there is a cp of length k labeled by one of the I j 's, and P 1 . . . P m be the interval partition of I 1 . . . I n . Each P k is represented by a tuple t in δ k .</p><p>The t.valid attribute contains the list of all nodes at temporal depth k that are valid in the interval [t.from, t.to). The nodes in t.valid are ordered by the order relation defined in the interval [t.from, t.to]. (Note that, according to Proposition 1, this order relation is always defined for all nodes in [t.from, t.to]). Tuples in the δ k tables are indexed by from and to.</p><p>Algorithm 5 (construction of δ k tables) The δ k table construction algorithm starts by creating a temporary event table with two attributes, node and instant. For each tuple s k , n, I in the tmap relation, where n (and s k ) are at depth k, two tuples t' and t" are created in the event table as follows:</p><formula xml:id="formula_17">t'.node = n t'.instant = I.FROM t".node = n t".instant = I.TO</formula><p>The event table is then sorted by the instant attribute (and the instant order &lt; t when it is defined, i.e. when two or more tuples have the same instant attribute value t). Next the algorithm traverses the event table in ascending order adding and removing nodes from the valid node list. Nodes in the valid list are kept in the order defined in their intersection interval. Each entry in the event table represents a change in some node's state (from valid to not valid and viceversa). Therefore, for each tuple in the event table the algorithm checks whether the node is already in the valid list or not. If the node is in the list it means that the entry in the table corresponds to the end of its interval and therefore the node has to be removed from the valid list. If the node is not yet in the list, then the entry corresponds to the beginning of its interval and thus the node has to be added to the list. In addition, for each tuple in the event table the algorithm also checks if it is the last one in the table or if its instant attribute is different from the next. In both cases a tuple old-instant, instant-1, valid_list is added to the δ k table, and no tuple is added otherwise.</p><p>Example 17 We will apply the δ table construction algorithm to the s 5 node of the interval summary in Fig. <ref type="figure" target="#fig_23">18</ref>. The tmap relation for s 5 is the following: From the tmap relation for s 5 the following event table is constructed: Note that the order in which the nodes appear in the event table does not necessarily represent the instant order &lt; t . (For example, node '11' appears before node '19' in the temporal document at instant '0', rather than after it.) The instant order &lt; t will be taken into account when the nodes are inserted in the valid list. Let us now begin to traverse the event table. The first node we find is '19' with instant '0'. We check if '19' is in the valid list. Since it is not (in fact the valid list is still empty at this point), we conclude that '0' corresponds to the beginning of '19's interval and we add it to the valid list. Likewise we add nodes '11' and '9'. Since the next tuple has a different instant value, we can now add the entry 0, {9, 11, 19} to the δ 5 table. Next we find node '19' with instant '20' and when we look it up in the valid list we find it. Thus we conclude that '20' corresponds to the end of '19's interval and hence we remove '19' from the list. We process the rest of the event table in a similar fashion and we get the following δ 5 The δ 5 table contains the interval partition of intervals [23, N ow], [0, 20], [0, N ow], which are the intervals of node s 5 according to tmap.</p><formula xml:id="formula_18">δ 5 event</formula><p>The δ k tables can be used for computing snapshots efficiently. When creating a snapshot at time i we simply have to find the tuple t in the δ k tables such that i is contained in t's interval. In addition, the δ k tables support efficient retrieval of all nodes that are valid during a given interval. In the next section we will explain query processing using the CP and δ k tables in detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Space requirements</head><p>The size of the index is proportional to the number of cp's. Our experiments in Sect. 10 show that, for the NBA database, the number of cp's is about three times the number of nodes in the temporal graph. We support three types of updates, insertion, deletion and modification. When the XML graph is a tree, i.e. before any update is performed, for each edge in the temporal graph there is one tuple in the CP tables. Furthermore, since there is only one interval of relevance, [0, Now], there is only one tuple t in each δ k and the list of its valid nodes contains all nodes at temporal depth k. As updates are performed, the number of cp's in the document -and consequently the number of tuples in the tables -increases. The tables affected by an update are those that index descendants of a node at the update point, so the closer the update is to the root, the larger the increase in the index size. Occasionally, an update may also create a new partition in a δ k table, in which case the nodes from the last partition that are still valid in the new partition have to be replicated.</p><p>There are several ways to reduce the space requirements for the index. In many applications, we expect most updates to occur close to the leaves, so that the size of the index will grow linearly in the size of the document. Our experiments so far confirm that expectation: the main-memory representation of TempIndex has a size comparable to that of the DOM representation (see Sect. 10) for all document sizes tested.</p><p>Another typical property of temporal applications is that there is a great deal of skew in the distribution of queries, with recent instants being accessed more frequently than older ones. In a space-constrained situation we could exploit this property by limiting how far the temporal window extends back in time, and periodically reindexing to take this into account.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Evaluating TXPath queries using TempIndex</head><p>In this section we will introduce the query evaluation algorithms which are based on our ancestor-descendant encoding.</p><p>8.1 Ancestor-descendant encoding for temporal XML So far we have used node numbers for identifying nodes in the XML graph. However, we will show that we can encode nodes in a more efficient way in order to improve the performance of some TXPath queries. We devised the temporal interval encoding, which is an ancestor-descendant encoding inspired by the interval scheme first presented by Santoro and Khatib <ref type="bibr" target="#b47">[48]</ref>. In this scheme, the leaves of a tree are numbered from left to right and each internal node is labeled with a pair of numbers corresponding to its smallest and largest leaf descendants.</p><p>All known ancestor-descendant encoding schemes (see <ref type="bibr" target="#b29">[30]</ref> for a recent survey) are variations of Santoro and Khatib's interval scheme. The average label length of these class of schemes has an upper bound of 2 log n, n being the number of nodes in the XML graph. In our index, the integration of the encoding with other index structures allows us to encode the ancestor-descendant relationship using only one number The main idea for the temporal interval encoding is based on taking advantage of three facts: (a) again, we are indexing continuous paths, not just nodes; (b) the intervals of all the continuous paths in which a node n participates are disjoint; (c) the graph representing a snapshot of a temporal XML document is acyclic. Thus, we can encode the nodes in a way such that each node has as many encodings as continuous paths it is part of.</p><p>In order to formally define the temporal interval encoding, we need to define first a total order relation among nodes at different intervals.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 22</head><p>Let p 1 = (r oot, . . . , v, T 1 ) and p 2 = (r oot, . . . , w, T 2 ) be continuous paths in D. The partial order relation ≺ T is defined as follows:</p><formula xml:id="formula_19">1. If T 1 ∩ T 2 = φ then v ≺ [0,N ow] w iff T 1 .F RO M &lt; T 2 .F RO M. 2. If T 1 ∩ T 2 = φ then v ≺ T w iff v &lt; t w for every t ∈ T ,</formula><p>where &lt; t is the order relation at instant t.</p><p>Definition 23 (temporal interval encoding) Let ≺ T be the order relation from Definition 22, and let succ ≺ (n, T ) be the successor function in ≺ T of node n at interval T ⊆ T (a node may have different successors at different intervals).</p><p>In addition, let gap(n, T ) be a function assigning an arbitrary integer to each node n in a given interval T (the gap function represents the "integer gap" between two consecutive encodings). The temporal interval encoding function τ is defined over pairs n, T such that there is a cp p = (r oot, . . . , n, T ), as follows: τ ( n , T ) = τ ( n, T )+ gap(n, T ) where T is an interval such that succ ≺ (n, T ) = n , and τ ( n , T ) = 0 otherwise.</p><p>The gap function is designed to specify how much "room" we want to leave between encodings for future updates. For instance, in the temporal encoding of Fig. <ref type="figure" target="#fig_26">19</ref>, there is only one gap assignment to the node with encoding 6, which is the following: gap( <ref type="formula">6</ref> For representing the structural relationship between nodes in different equivalence classes using the temporal interval encoding we define what we call TCP tables. TCP tables are CP tables where nodes are represented by the temporal interval encoding. Since temporal encoding does not require explicitly representing nodes' parents, in the TCP tables the parent attribute is dropped. In contrast to CP tables, a TCP table is associated to a summary node rather than an edge. This number encodes the node in the interval [0, 22], when it was a descendant of node 60. For the interval <ref type="bibr">[23, N ow]</ref>, the node's number is 30, because it became a descendant of 1.</p><p>In other words, there are two continuous paths (with disjoint intervals) from the root to the node, and for each one of them we use a different encoding. Note that these differ-ent node numbers do not imply a larger number of tuples in the TCP tables with respect to the CP tables, because there is always one tuple for each continuous path, as in the encoding used before. For instance, consider the LCP summary graph shown in Fig. <ref type="figure" target="#fig_23">18</ref>  These tables are the CP tables from Example 16 but with temporal encoding and without the parent attribute. Note that nodes with "McGrady" and "Williams" values appear in both tables but with different intervals and temporal encodings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Query evaluation</head><p>The evaluation of a TXPath query is divided into stages based on its filter sections. The filter sections of a TXPath query (also called filters) are the expressions that appear between brackets in the query. A filter is a predicate which is applied to the pairs node, interval that are at the end of the cp's that match the path expression before it. For simplicity, we consider in this section TXPath expressions without nested filters. After each filter section, the evaluation of the rest of the query continues only for those pairs (node, interval) that satisfy the filter.</p><p>We decompose each TXPath query into a sequence of calls to six evaluation functions: getParent(Label), getDescendants(Label), getChildren(Label), getAncestors(Label), valFilter(valPred) and tempFilter(TempPred), where Label is a node label, valPred is a value predicate, and tempPred is temporal predicate. Each function is evaluated on a list of tmap tuples s, n, I and returns another list of tmap tuples. In order to return a TXPath answer, the summary node s is dropped from the s, n, I tuples so that the list returned contains only pairs (n, I ), just as the TXPath semantics requires. We illustrate next through and example how a TXPath query is evaluated using the evaluation functions and a Temp-Index. We will follow the top-down evaluation presented in Example 19 on the LCP and interval summary graphs of Fig. <ref type="figure" target="#fig_23">18</ref> and the NBA example with the temporal encoding of Fig. <ref type="figure" target="#fig_26">19</ref>. The evaluation begins by adding the tuple s 1 , 0, [0, N ow] to list, which contains the root elements of the XML document and the LCP summary graph. Then the evaluation continues by searching for the descendants of the summary root with label "franchise", which is s 2 , and then its children with label "name", which is s 3 . Since we have not filter out anything yet, list contains at this point all tuples in the TCP The next step is selecting the node that has the "Raptors" value (node 2), so that list is reduced now to the tuple (2, [0, N ow]). The evaluation continues by going back to summary node s 2 in order to obtain the "franchise" node that corresponds to the name "Raptors". For this we will need the TCP table <ref type="table">of</ref>  The parent node of 2 is the node with the biggest temporal encoding smaller than 2 in the s 2 TCP table, which is 1. Then, the tuple s 2 , 1, [0, N ow] is now assigned to list (the previous tuples are removed).</p><p>Since we have filtered out tuples from the TCP tables involved, we will need the entire encoding interval of node 1 to continue evaluating the descendants. The encoding interval will be used to determine exactly what nodes of all descendant TCP tables are in fact descendants of node 1. The right end of the interval is obtained from the delta 1 table </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Temporal updates</head><p>In this section we describe the updates allowed over a temporal XML document. We will admit three kinds of changes over the document: insertion of a new node, deletion (in the sense of temporal databases) of a node, and update of containment edges. As usual, we will represent a labelled edge as a tuple e(n i , n f , [t i , t f ]), where n i and n f are the initial and final nodes, and [t i , t f ] represents the interval of validity of the edge. Alternatively, as a shorthand, we will use T e for denoting this interval. We will also describe how these updates are propagated to our temporal indexing scheme (assuming the temporal interval encoding). Finally, we will discuss how the concepts explained in Sect. 4 interplay with the updating process.</p><p>Since our model deals only with transaction time, all updates occur at the current time instant, denoted t c . However, the update operators may be extended, allowing, if needed, some limited form of retroactive updating, without changing other characteristics of the model. We will discuss this issue below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.1">Insertion</head><p>The insertion of a new node in a temporal XML document requires specifying the new node n to be inserted, and a current node n (i.e., a node with an incoming containment edge where T e c .T O = N ow). The new node n , and a containment edge from n to n with temporal label [t c , N ow] are added to the graph. The DDL (Data Definition Language) syntax for insertion, along the lines of Tatarinov et al. <ref type="bibr" target="#b52">[53]</ref> This update is processed as follows (assume for simplicity that t c is the instant 120 and that the new node is w with interval [120, N ow]). We begin by evaluating the path expression in the first line, which returns the node with encoding 15, label stats and interval [0, N ow]. (In this discussion, we will use encodings to identify nodes when possible.) Then, we locate the last (and only) child of 15 at current time, which is 16. At this point (before the insertion) the successor of 16 at interval The final step is to update the TCP and δ i tables. Since there is no node in the summary graph for w , we add a new node labeled minutes to the summary graph and create a new TCP table. Next, we insert the tuple 11, 120, N ow, 33.2 into the new TCP table. Finally, we update the δ 5 table by adding a tuple r with r. f rom = 120 at the end and the other attributes of r are set as follows. Let us denote l the last tuple in δ 5 immediately before the insertion of r. Thus, r becomes the last tuple in δ 5 , with r. f rom = 120, r.to = N ow, and r.valid = l.valid ∪ {23}. Finally, we set l.to = 119. We are assuming that updates are performed over a consistent document, and must leave this document in a consistent state. In the case of insertion of a node n, the new node has only one incoming edge, meaning that inconsistencies of type ii cannot occur. Also, the inserted node has no outgoing edges. Therefore, consistency conditions of types i (temporal label outside the lifespan of the node) and iii (cycles) cannot be introduced.</p><p>We commented above that the data model allows a limited form of retroactive update. We will briefly clarify this notion. Suppose we want to insert a new player node to the Orlando Magic franchise (i.e., an insertion below node 60 in Fig. <ref type="figure" target="#fig_26">19</ref>). Since the lifespan of node 60 is [0, N ow], instead of giving the new node the lifespan [t c , N ow], we could specify any temporal label included in [0, N ow]. We only need to add a statement to the operator's syntax, indicating the lifespan of the new node. Given that we only deal with transaction time, a complete discussion of this topic is beyond the scope of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.2">Deletion</head><p>We can delete (in the temporal database sense) attribute nodes (except attributes of type ID), element nodes, and reference edges from a temporal XML document. Again, we only allow current objects to be deleted. Informally, when deleting a node n at time t d , 'Now' is replaced by t d in T e c .T O. The same occurs with all the containment edges in the current subtree of n (the subtree with root n where all the edges e c have T e c .T O = N ow). Reference edges are deleted by setting T e r .T O = t d in the temporal label of the edge. Notice that no consistency checking is required. Thus, this operation will always leave the document in a consistent state.</p><p>Like in the case of insertion discussed above, a retroactive deletion could be implemented if the consistency conditions of the model are satisfied. For example, in Fig. <ref type="figure" target="#fig_26">19</ref> we could delete node 86 at any instant between 17 and N ow.</p><p>Example 22 we want to 'delete' all statistics for Williams (node 30 in Fig. <ref type="figure" target="#fig_26">19</ref>). The DDL for this update will be:</p><formula xml:id="formula_20">FOR $ p IN /NBAdb//player[name='Williams'] DELETE node $ p//stats</formula><p>The deletion is processed as follows. Again, we assume that deletion can only occur at the present time.</p><p>We begin by processing the path expression in the first line using the summaries, returning node 30 along with its interval. The next step is the delete operation, which involves 'deleting' the subtree with root 32 at time '120'. In order to do that, we first replace the tuple 32, 23, N ow in the TCP table of s 8 with 32, 23, 120 . Next, we replace 33, 23, N ow in the TCP table of s 9 with 33, 23, 120 . Finally, we update the δ 4 and δ 5 tables by inserting a new tuple r (recall that the table is ordered according to the attribute instant), with r. f rom = 120, r.to = N ow, and l.to = 119, where l is last tuple of each table. In addition, we set r.valid = l.valid -{32}, for δ 4 and r.valid = l.valid -{33}, for δ 5 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.3">Edge updates</head><p>We will finish our discussion of temporal updates with updates of containment edges. Let D be a temporal XML document; n and n i two current nodes in D such that there exists a current containment edge from n i to n. Let us consider another current node n j , not in a current subtree of n; intuitively, a temporal update at instant t c says that from t c on, the parent of node n will be n j .</p><p>Example 23 Suppose player "Garrity" starts playing for the Toronto Raptors at the present time (instant '120'): We begin by processing the path expression in the first line using the summaries, returning node 82 along with its interval. As we are using temporal interval encoding, all the nodes in the subtree with root 82 (including node 82 itself) must be given a new node number. In this example, let us assume the following number assignments: 82 → 42, 83 → 43, 84 → 44, 85 → 45, 86 → 46. Next, we insert the tuple 42, 121, N ow in the T C P table of s 5 , and we replace the tuple 82, 0, N ow with 82, 0, 120 in the TCP table of s 10 . In addition, we insert the tuple 43, 121, N ow, Garrit y in the TCP table of s 6 , and replace the tuple 83, 0, N ow, Garrit y with 83, 0, 120, Garrit y in the TCP table of s 11 . For the remaining elements, we perform an analogous procedure and update the affected δ k tables.</p><p>Consistency checking gets a little more involved in this case. Besides verifying that the new parent node is current, we need to check consistency condition (iii), i.e., that no cycle is introduced by the update (in the case of updates performed over current nodes, this limits to check that no cycles are introduced at the current instant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">Experiments</head><p>In this section we will show how indexing temporal intervals and continuous paths improves TXPath query evaluation. We compare TempIndex with other two systems: a traditional, non-temporal structural summary and a DOM-based structure. We have picked ToXin <ref type="bibr" target="#b45">[46]</ref> as a representative of the the systems that are based on non-temporal path summaries. We choose this particular system for convenience, since it is easily available to us; but we believe the results would not be substantially different using any other structural summaries proposal discussed in Sect. 2. The second comparison will be against a DOM representation of the base data without any kind of summary.</p><p>Although using a non-temporal summary reduces the search space for TXPath queries-compared to the DOM approach-it does not help with the temporal semantics of the query evaluation. ToXin has data structures that summarizes specific fragments of the XML data, such as nodes, paths and subtrees, and thus avoid sequential scans of entire documents during query evaluation. However, like all traditional structural summaries, it materializes paths rather than continuous paths; therefore, both ToXin and DOM have to compute all continuous paths on-the-fly during query evaluation time. Our experiments show how important indexing the temporal structure of the data base is for evaluating TXPath queries.</p><p>TempIndex is implemented in Java 2 and uses Berkeley DB Java Edition <ref type="bibr" target="#b49">[50]</ref> as persistent storage. This is a substan-tial difference with respect to the implementation presented in <ref type="bibr" target="#b36">[37]</ref>, which was a pure main-memory system. In the current TempIndex implementation all data structures are loaded into main-memory during query evaluation and update processing, and are saved to disk afterwards. This allows us to run queries on databases much larger than the main-memory available by loading and saving different index fragments during evaluation time. We have also optimized the internal representation of time intervals and attributes, with the consequent reduction in the index size with respect to <ref type="bibr" target="#b36">[37]</ref> (Fig. <ref type="figure" target="#fig_28">20</ref>).</p><p>For all our experiments we use query processing time as the performance metric. We evaluate the performance of the three systems on a set of seven query templates, as shown in Fig. <ref type="figure" target="#fig_0">21</ref>. Query templates that contain value and interval selections (Q3-Q6) were tested with ten different actual queries with various combinations of values and intervals. For those four queries we report the average results. The results for the SN template are also an average of computing ten document snapshots at ten different instants.</p><p>Templates Q1 and Q2 are TXPath retrieval queries without interval constraints. Even though the intervals are not specified in the expression, these are still TXPath queries and thus the answers are pairs node, interval . Templates Q3 and Q4 have interval constraints. Half of the queries tested for Q3 and Q4 were snapshot queries, i.e., queries where the interval 'I' was actually a time instant. Remember that in Sect. 6 we distinguished snapshot queries from the document reconstruction as of a given time instant, which we denoted document snapshot(reported in the SN template). A document snapshot represents the state of the database at a given point in time. In other words, it is a query of the form "Give the state of the NBA database as of 10 October 1995". Therefore, while the answer to queries Q1 to Q4 are node, interval pairs, the answer to a document snapshot is an XML document. Finally, Q5 and Q6 are TXPath update queries, as described in Sect. 9.</p><p>We run our benchmark queries over the NBA database, which we consider to be a representative example of temporal data. We loaded the data from the NBA web site (www. nba.com) into a relational database (Microsoft SQL Server 2000.) From this database we produced five documents of 20, 40, 60, 80, and 100 MB. We ran all queries over the five documents and the results are reported in Figs. <ref type="bibr">22, 23, 24, 25, 26, 27, 28.</ref> For the experiments we used a Pentium 4 PC at 2 Ghz with 1GB of RAM memory and a 60 B hard drive. We report the number of nodes and continuous paths in the temporal documents, as well as the number of summary nodes in TempIndex in Fig. <ref type="figure" target="#fig_12">29</ref>. The size of the query answer for each query is shown in Fig. <ref type="figure" target="#fig_3">30</ref>.</p><p>In all retrieval queries TempIndex performed faster than ToXin. The TempIndex speed-up against ToXin ranged from a minimum of nine times (document snapshot-20 MB) to a maximum of 220 times (Q2-100 MB). Since both systems summarize label paths and values, the difference in performance can be mostly attributed to the summarization of continuous paths. Q2 is one of the fastest in TempIndex but one of the slowest in ToXin. The reason for that is that the answer to Q2 is a whole class of continuous paths in the temporal index, which is very easy to find and retrieve using the TempIndex summary graph. Although in ToXin we can narrow the search by following only those label paths that match the regular expression in the query, we still have to compute all continuous paths over them. The document snapshots, in contrast, require heavy computation even for TempIndex. We can still narrow the search considerably by using the interval index to locate the classes corresponding to the instant in time we are looking for. However, once these classes are found we have to reconstruct an entire document navigating back and forth over them. That being said, TempIndex still is almost one order of magnitude faster than ToXin and DOM. Since a non-temporal path summary is not very efficient for temporal document reconstruction, the snapshot computation performance of ToXin and DOM are quite similar.</p><p>Queries Q1 and Q2 do not contain either interval or value selection predicates and have relatively large answer sets. However, keep in mind that not having interval predicates does not mean that the temporal semantics is not present: the continuous paths always have to be computed in order to return TXPath query answers. This is the reason behind the two orders of magnitude difference in performance between ToXin and TempIndex for queries Q1 and Q2.</p><p>The answer sets of Q1 are closer to the root and smaller than those of Q2. This affects the query processing time in ToXin because the continuous paths to be computed are fewer and much shorter in Q1 than in Q2, with the consequent impact on query evaluation (Q2 queries take almost twice the time than Q1 ones). In contrast, since the DOM implementation is not aware of the label path structure of the data graph, it requires the traversal of the whole temporal graph in order to match the regular expression on both Q1 and Q2. Consequently, the difference in query processing time between Q1 and Q2 is minimal in DOM.</p><p>Queries Q3 and Q4 require the additional computation of value and interval selection, which is reflected in the Temp-Index results. In contrast, the size of the answer set and the length of the continuous paths seems to have a bigger impact on ToXin performance than the selection operations, and almost no impact at all in DOM. The reason for that seems to be that ToXin spends most of the query processing time on continuous path computations, while DOM does it on data graph traversal.</p><p>Update queries Q5 (insert) and Q6 (delete) require label path traversal in order to locate the update point. Since no continuous path computation is involved, the difference between ToXin and TempIndex is minimal. In contrast, the DOM implementation has to traverse the whole temporal graph in order to locate the update point, with the consequent time difference against both ToXin and TempIndex.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11">Conclusion</head><p>In this paper we studied the problem of modeling and querying temporal data in XML. We first proposed an abstract data model for temporal XML, and compare this model against other proposals, pointing out benefits and limitations. We discussed four different alternatives for implementing the abstract data model as temporal XML documents. Based on our data model we studied the problem of validating temporal XML documents against the temporal constraints that the data model imposes. This problem has been overlooked in other proposals of temporal data models for XML. We gave algorithms for checking the presence of temporal inconsistencies in a document and fixing them, and studied the algorithms' complexity.</p><p>We also studied the problem of indexing temporal XML documents. For this, we first introduced a temporal XML query language denoted TXPath, that extends the semantics of XPath 2.0 to return sequences of (node, interval) pairs instead of just sequences of nodes. The indexing scheme we proposed is based on the materialization of continuous paths instead of paths. A new class of summaries, denoted TSummaries, that adds the time dimension to the usual path summarization schemes, serves as framework to our indexing scheme. We presented two new kinds of summaries: LCP and Interval summaries. The indexing scheme, denoted TempIndex, integrates these summaries, also including other data structures.</p><p>We compared the performance of a persistent implementation of TempIndex, against a traditional non-temporal structural summary (ToXin), and a DOM-based structure. This comparison highlights the benefits of materializing continuous paths. TempIndex ran one order of magnitude faster than ToXin and DOM, for snapshots. For retrieval queries, TempIndex ran, on the average, from 10 to 210 times faster than the other schemes. In addition, we sketched a language for updates, and showed that the cost of updating the index is compatible with real-world requirements.</p><p>Future work includes extending the study of new classes of Temporal Summaries, for their application to different settings. We also believe that our work on consistency issues can be a good starting point for studying and reasoning about constraints with indeterminate dates, of the types presented in <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b27">28]</ref>. The problem of reasoning about temporal constraints in XML is still under-explored.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 a</head><label>2</label><figDesc>Fig. 2 a A gap in lifespan of node n1; b A possible solution</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Definition 7 (Example 3</head><label>73</label><figDesc>interval of inconsistency) Let I be one of the inconsistencies of Definition 6, the Interval of Inconsistency of I , denoted I I , is the closed interval where the inconsistency occurs. The notion of interval of inconsistency is local to I , meaning that there are as many I I 's in a document as inconsistencies occur in it. Figure4 a-cshow examples of intervals of inconsistency for types (i) to (iii), respectively. In Fig.4a II = [T 4 , N ow] (the temporal label of edge outgoing from n 1 lies outside the lifespan of the node); in Fig. 4b I I = [T 2 , T 4 ] (a gap in node n 2 ); in Fig. 4c there is a cycle in every snapshot within the interval I I = [T 4 , T 6 ].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4 a</head><label>4</label><figDesc>Fig. 4 a Inconsistency of type (i); b Inconsistency of type (ii); c Inconsistency of type (iii)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Algorithm 3 (</head><label>3</label><figDesc>For the average case, deg in (n) equals |E| |V | , yielding: |E| * log |E| |V | . Lines 5 to 7 compose a loop that repeats for each edge outgoing from a visited node, performing operations of constant order. This, for the average case, results in complexity O |V | * |E| |V | . The algorithm's order is then: O E * log |E| |V | + 1 . The next algorithm checks for cycles in a temporal labeled graph. finds cycles in a document) INPUT: A temporal XML document D, such that checkNodeConsistency(D) = true OUTPUT: True if D has no cycles, otherwise False boolean checkCycles(D){ (1) Queue nodes = get Root (D) (a queue, initialized with the root of D) (2) Queue nodesWait = [ ] (empty queue of nodes) (3) Set traver sed(e), usable(e), visited(n) and ended(n) to False, for all edges e and nodes n in D. (4) while !empt y(nodes) do (5)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Definition 8 (</head><label>8</label><figDesc>deleting edges in temporal XML) Let D be a Temporal XML document, e be a containment edge of the form e(n, m, T e ) and let I = [I.F RO M, I.T O] be a temporal interval. The deletion of e in the interval I is defined as follows: 1. If I.F RO M ≤ T e .F RO M ≤ T e .T O ≤ I.T O, then physically delete e. 2. If T e .F RO M &lt; I.F RO M ≤ T e .T O ≤ I.T O, then make T e .T O = I.F RO M -1. 3. If I.F RO M ≤ T e .F RO M ≤ I.T O &lt; T e .T O, then make T e .F RO M = I.T O + 1. 4. If T e .F RO M &lt; I.F RO M ≤ I.T O &lt; T e .T O, then (a). Create a new node n c (b). Replace T e in e by [T e .F RO M, I.F RO M -1] and create a new edge e (n c , m, [I.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Example 5</head><label>5</label><figDesc>Figure 5 shows a deletion of edge e(n, n 2 , [20, N ow]) at instant t = 35. Since T e .F RO M &lt; 35 &lt; T e .T O, we performed node duplication (following step 4 in Definition 8) as follows: we created a copy of n, denoted n c , and the edge (n c , n 2 , [36, N ow]); we also replaced (n, n 2 , [20, N ow]) by (n, n 2 , [20, 34]) [step 4(b)]. According to step 4 (f), the edge (r, n, [0, N ow]) has been replaced by (r, n, [0, 34]), and a new edge (r, n c , [35, N ow]) was created. Definition 9 (temporal label expansion and reduction) Given a containment edge e(n i , n j , T e ), an expansion of T e to an instant t is performed making T e .T O = t, if t &gt; T e .T O, and T e .F RO M = t, if t &lt; T e .F RO M. Reducing the temporal label T e to an interval T ⊂ T e implies deleting e in the intervals [T e .F RO M, T . F RO M -1], [T .T O + 1, T e .T O].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 Fig. 5</head><label>65</label><figDesc>Fig. 5 Deleting the edge (n, n 2 , [20, N ow]) at t = 35, using node duplication root</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 6</head><label>6</label><figDesc>Fig.<ref type="bibr" target="#b5">6</ref> Original graph, and graph after expansion at t 10</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 7</head><label>7</label><figDesc>Fig. 7 Example of inconsistency of type (i) and solution by expansion</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Example 6</head><label>6</label><figDesc>Figure 7  shows that node n 1 presents an inconsistency of type i (the youngest edge incoming to n 3 has temporal label [t 6 , N ow], and the lifespan of n 1 is [0, t 10 ]). Then, I I = [t 11 , N ow]. The right hand side of the picture shows the solution, expanding the youngest edge incoming to n 1 i.e., e(n 2 , n 1 , T ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 8</head><label>8</label><figDesc>Fig. 8 Instant of maximal path expansion</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 9</head><label>9</label><figDesc>Fig. 9 Correction by reduction</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>t 10 ] instead of [0, N ow]. Fixing by expansion the inconsistency over n 1 as explained in Example 6, would propagate the inconsistency to node n 2 . On the other hand, a correction by reduction may propagate downward and also introduce gaps [inconsistencies of type (ii)], as Example 9 shows. In order to compare options (a) and (b), a simple metric could be used, namely the number of changes needed to fix the problem, where a change could be: (a) the expansion of an interval; (b) the reduction of an interval; (c) the duplication of a node; (d) the deletion of an edge.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig. 10</head><label>10</label><figDesc>Fig. 10 Node duplication for fixing a gap inconsistency</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Fig. 11</head><label>11</label><figDesc>Fig. 11 Fixing an inconsistency of type (iii) (cycle)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Fig. 12</head><label>12</label><figDesc>Fig. 12 Commutativity of gap elimination</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Fig. 13</head><label>13</label><figDesc>Fig. 13 Top-down non-replicated representation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Fig. 14</head><label>14</label><figDesc>Fig. 14 Portion of the NBA database with duplicated nodes</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>Fig. 16</head><label>16</label><figDesc>Fig. 16 Snapshot of the document of Fig. 13 at t = '24'</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head></head><label></label><figDesc>let $m= min(//franchise[name='Magic']// player[name='McGrady']/@from) return //franchise[name='Magic']//player[$m ≥ @from and $m ≤ @to]/name</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head>Definition 13 (</head><label>13</label><figDesc>temporal summary) Consider a temporal XML document D and the set T Node of pairs n, I such that n is a node in D, I is an interval, and there is a continuous path p from the root of D to n with interval I . A temporal summary of D, S D = (T Sum, tmap, edge, Label, λ), is a structure where -TSum is a set of summary nodes defined as follows: Sum = {s | s, n, I ∈ tmap}; -tmap is a relation defined as follows: -Each pair n, I is associated to only one summary node. That is, s, n, I ∈ tmap ⇒ ¬∃s = s | s , n, I ∈ tmap; -Every document node is associated to some summary node. That is, ∀ n, I ∈ T Node : ∃s ∈ T Sum | s, n, I ∈ tmap; We say that a pair n, I ∈ T Node is in the temporal map of a node s ∈ T Sum iff s, n, I ∈ tmap. -edge is a relation in TSum × TSum that represents the edges in S D ; -λ is a labelling function that assigns names to nodes in TSum by mapping T Sum → Label. Definition 14 (temporal summary graph) Consider a temporal summary S D = (T Sum, tmap, edge, Label, λ). The tuple G S = (T Sum, edge, Label, λ) is the summary graph of S D .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head>Definition 15 (</head><label>15</label><figDesc>LCP summary) Consider a temporal XML document D and the set T Node of pairs n, I such that n is a node in D, I is an interval, and there is a continuous path p from the root of D to n with interval I . A temporal summary of D S D = (T Sum, tmap, edge, Label, λ) is an LCP summary iff -S D has the edge property; -Two document nodes belong to the tmap of the same summary node iff they are at the end of continuous paths from the root with the same label : ∀ n, I , n , I ∈ T Node, s ∈ T Sum : s, n, I , s, n , I ∈ tmap ⇔ {λ( p) | p = (r, . . . , n, I )} = {λ( p ) | p = (r, . . . , n , I )}. -Label is the set of node labels in the temporal document; -∀ s, n, I ∈ tmap : λ(s) := λ(n).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head>Fig. 18</head><label>18</label><figDesc>Fig. 18 Temporal summary graphs</figDesc><graphic coords="22,56.59,56.33,227.08,188.80" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head>Definition 18 (</head><label>18</label><figDesc>interval summary) Consider a temporal XML document D and the set T Node of pairs n, I such that n is a node in D, I is an interval, and there is a continuous path p from the root of D to n with interval I . A temporal summary of D, S D = (T Sum, tmap, edge, Label, λ) is an interval summary iff -S D has the edge property; -Two document nodes belong to the tmap of the same summary node iff they have the same temporal depth: ∀ n, I , n , I ∈ T Node, s ∈ T Sum : s, n, I , s, n , I ∈ tmap ⇔ δ(n, I ) = δ(n , I ). -Label = {0, . . . , m}, where m is the length of the longest cp in the document; -∀ s, n, I ∈ tmap : λ(s) := δ(n, I ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_25"><head>12 ,</head><label>12</label><figDesc>[23, N ow]    s<ref type="bibr" target="#b4">5</ref> 19, [0, 20]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_26"><head>Fig. 19</head><label>19</label><figDesc>Fig.<ref type="bibr" target="#b18">19</ref> Indexing intervals with temporal interval encoding</figDesc><graphic coords="25,184.26,56.38,360.00,183.72" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_27"><head></head><label></label><figDesc>, [0, 20]) = 1 (the next encoding is 7 for the [0, 20] interval). In contrast, the node 16 has three different gap assignments: gap(16, [0, 20]) = 4 (the next encoding for the [0, 20] interval is 20), gap(16, [21, 22]) = 44 (the next encoding for the [21, 22] interval is 60), and gap(16, [23, N ow]) = 14 (the next encoding for the [23, N ow] interval is 30).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_28"><head>Example 20</head><label>20</label><figDesc>Consider again the query of Example 19, expressed in TXPath as //franchise[name='Raptors']//player/name[@from≥20]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_29"><head>[ 23 ,</head><label>23</label><figDesc>N ow] is 30. The next step is to insert w by updating the order relation as follows: change the interval in which the successor of 16 is 30 from [23, N ow] to [23, 119], set w as successor of 16 during [120, N ow], and set 30 as successor of w during [120, N ow]. The update continues with the gap function. We have that gap(16, [23, N ow]) = 14 before the update. Then, we set gap(16, [120, N ow]) = 7, gap(16, [23, 119]) = 14, and then delete gap(16, [23, N ow]) = 14 because it is no longer valid. Next, we assign an encoding to w with τ as follows: τ ( w , [120, N ow] ) = τ ( 16, [0, N ow] ) +gap(16, [120, N ow]). Thus, τ ( w , [120, N ow] ) = 16 + 7 = 23.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_30"><head></head><label></label><figDesc>FOR /NBAdb//player[name='Garrity'] SET PARENT /NBAdb/franchise[name='Raptors']/team</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_31"><head>Fig. 20 Fig. 23</head><label>2023</label><figDesc>Fig. 20 Main-memory data structures sizes</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_32"><head>Fig. 26</head><label>26</label><figDesc>Fig. 24 Query Q3 -log scale</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_33"><head>Fig. 28 Fig. 29 Fig. 30</head><label>282930</label><figDesc>Fig. 27 Query Q6: -log scale</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="2,181.27,56.58,362.88,185.52" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>T O + 1, T e .T O]). (c). Remove every edge e j (n, n j , T e j ) outgoing from n for which I.F RO M ≤ T e j .F RO M and create a new edge e j (n c , n j , T e j ). (d). For every edge e j (n, n j , T e j ) outgoing from n for which T e</figDesc><table /><note><p>j .F RO M &lt; I.F RO M ≤ T e j .T O replace T e j in e j by [T e j .F RO M, I.F RO M -1] and create a new edge e j (n c , n j , [I.F RO M, T e j .T O). (e). Remove every edge e i (n i , n, T e i ) incident to n for which I.F RO M ≤ T e i .F RO M and create a new edge e i (n i , n c , T e i ). (f). For every edge e i (n i , n, T e i ) incident to n such that T e i .F RO M &lt; I.F RO M ≤ T e i .T O replace T e i in e i by [T e i .F RO M, I.F RO M -1] and create a new edge e i (n i , n c , [I.F RO M, T e i .T O]).</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>Definition 19 (CP tables) Consider the summary S D of a temporal XML document D. For each edge e = (s 1 , s 2 ) in the temporal summary graph G S there is a CP table in which each tuple t has attributes parent, node, from and to such that there is a continuous path from the root of d to t.node with interval [t.from, t.to] via t.parent. When t.node has a value v associated to it, the CP table has an extra attribute named value, where t.value = v. Tuples in the CP tables are sorted by node. Example 16 Consider the summary graphs shown in Fig. 18, which correspond to the summaries of Examples 14 and 15. The CP tables of edges (s 10 , s 11 ) and (s 5 , s 6 ) are the following:</figDesc><table><row><cell></cell><cell cols="3">Edge (s 10 , s 11 ) CP table</cell><cell></cell></row><row><cell cols="3">parent node from</cell><cell>to</cell><cell>value</cell></row><row><cell>16</cell><cell>17</cell><cell>21</cell><cell cols="2">N ow "McGrady"</cell></row><row><cell>24</cell><cell>23</cell><cell>0</cell><cell>N ow</cell><cell>"Garrity"</cell></row><row><cell>14</cell><cell>30</cell><cell>0</cell><cell>22</cell><cell>"Williams"</cell></row><row><cell></cell><cell cols="3">Edge (s 5 , s 6 ) CP table</cell><cell></cell></row><row><cell cols="3">parent node from</cell><cell>to</cell><cell>value</cell></row><row><cell>6</cell><cell>7</cell><cell>0</cell><cell>2 0</cell><cell>" O a k l e y "</cell></row><row><cell>10</cell><cell>8</cell><cell>0</cell><cell>N ow</cell><cell>-</cell></row><row><cell>16</cell><cell>17</cell><cell>0</cell><cell>20</cell><cell>"McGrady"</cell></row><row><cell>14</cell><cell>30</cell><cell>23</cell><cell>N ow</cell><cell>"Williams"</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>table :</head><label>:</label><figDesc></figDesc><table><row><cell></cell><cell>δ 5 table</cell><cell></cell></row><row><cell>from</cell><cell>to</cell><cell>valid</cell></row><row><cell>0</cell><cell>1 9</cell><cell>{9, 11, 19}</cell></row><row><cell>20</cell><cell>22</cell><cell>{9, 11}</cell></row><row><cell>23</cell><cell cols="2">N ow {9, 11, 12}</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head></head><label></label><figDesc>Definition 24 (TCP tables) Consider the summary S D . For each node s in the temporal summary graph G S there is a TCP table in which each tuple t has attributes node, from and to such that there is a continuous path from the root of d to t.node with interval [t.from, t.to]. When t.node has a value v associated to it, the TCP table has an extra attribute named value, where t.value= v. Tuples in the TCP tables are sorted by node. Example 18 Consider for instance Fig. 19. The player node corresponding to 'Williams' has initially been encoded as 61.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head></head><label></label><figDesc>and the NBA example with the temporal encoding of Fig.19. The TCP tables of nodes s 11 and s 6 are the following:</figDesc><table><row><cell></cell><cell cols="3">Node s 11 TCP table</cell></row><row><cell cols="2">node from</cell><cell>to</cell><cell>value</cell></row><row><cell>71</cell><cell>21</cell><cell cols="2">N ow "McGrady"</cell></row><row><cell>83</cell><cell>0</cell><cell>N ow</cell><cell>"Garrity"</cell></row><row><cell>62</cell><cell>0</cell><cell>22</cell><cell>"Williams"</cell></row><row><cell></cell><cell cols="3">Node s 6 TCP table</cell></row><row><cell cols="2">node from</cell><cell>to</cell><cell>value</cell></row><row><cell>8</cell><cell>0</cell><cell>20</cell><cell>"Oakley"</cell></row><row><cell>13</cell><cell>0</cell><cell>N ow</cell><cell>-</cell></row><row><cell>21</cell><cell>0</cell><cell>20</cell><cell>"McGrady"</cell></row><row><cell>31</cell><cell>23</cell><cell>N ow</cell><cell>"Williams"</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head></head><label></label><figDesc>Example 19  Consider the query "name of players who have played for the Toronto Raptors continuously since instant 20" which is expressed in TXPath as//franchise[name='Raptors']//player/name[@from≥20]This query can be evaluated top-down with the evaluation functions as follows: Get δ x where x is the temporal depth of n during the interval I . 1.2. For each interval i such that (i, valid) is in δ x and i satisfies temp Pred 1.2.1. Assign to out List all tuples (s, n, I ) such that n is in valid and there is a tuple t in the TCP table of s such that t.node = n and I = (t. f rom, t.to).</figDesc><table><row><cell>1.1. 3. Return out List.</cell><cell>list.add(root); list = list.getDescendants("franchise");</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head></head><label></label><figDesc>table of node s 3 (without the values):</figDesc><table><row><cell></cell><cell cols="3">Node s 3 TCP table</cell></row><row><cell cols="2">node from</cell><cell>to</cell><cell>value</cell></row><row><cell>2</cell><cell>0</cell><cell>N ow</cell><cell>"Raptors"</cell></row><row><cell>80</cell><cell>0</cell><cell>N ow</cell><cell>"Magic"</cell></row><row><cell>91</cell><cell>0</cell><cell cols="2">N ow "San Antonio"</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13"><head></head><label></label><figDesc>s 2 :</figDesc><table><row><cell cols="3">Node s 2 TCP table</cell></row><row><cell cols="2">node from</cell><cell>to</cell></row><row><cell>1</cell><cell>0</cell><cell>N ow</cell></row><row><cell>60</cell><cell>0</cell><cell>N ow</cell></row><row><cell>90</cell><cell>0</cell><cell>N ow</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_14"><head></head><label></label><figDesc>, the node next to 1 in the valid list of the appropriate interval (the only one in this case). The next step consist in obtaining all nodes with temporal encodings between 1 and 60 from the corresponding TCP tables. For that we first find the descendant "player" nodes in the LCP summary graph (s 5 and s 10 ), and then their "name" children (s 6 and s 11 ). The TCP tables of s 6 and s 11 are the following:From these tables we select all nodes between 1 and 60 and add them to list, which now contains s 6 , 8, [0, 20] , s 6 , 13, [0, N ow] , s 6 , 21, [0, 20] , s 6 , 31,[23, N ow]  . The last step consists of filtering list by selecting only those tuples t that have t.FROM ≥ 20, and this ends the evaluation.</figDesc><table><row><cell></cell><cell></cell><cell>δ 1 table</cell><cell></cell></row><row><cell cols="2">from</cell><cell>to</cell><cell>valid</cell></row><row><cell>0</cell><cell cols="3">N ow {1, 60, 90}</cell></row><row><cell cols="4">by taking 60Node s 11 TCP table</cell></row><row><cell cols="3">node from to</cell><cell>value</cell></row><row><cell>71</cell><cell>21</cell><cell cols="2">N ow "McGrady"</cell></row><row><cell>83</cell><cell>0</cell><cell cols="2">N ow "Garrity"</cell></row><row><cell>62</cell><cell>0</cell><cell>22</cell><cell>"Williams"</cell></row><row><cell></cell><cell cols="3">Node s 6 TCP table</cell></row><row><cell cols="2">node from</cell><cell>to</cell><cell>value</cell></row><row><cell>8</cell><cell>0</cell><cell>20</cell><cell>"Oakley"</cell></row><row><cell>13</cell><cell>0</cell><cell>N ow</cell><cell>-</cell></row><row><cell>21</cell><cell>0</cell><cell>20</cell><cell>"McGrady"</cell></row><row><cell>31</cell><cell>23</cell><cell>N ow</cell><cell>"Williams"</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_15"><head></head><label></label><figDesc>, is PathExpression returns pairs node, interval . For each pair such that interval.T O = N ow, a new node is added as a child of node, with path label given by Child-Expression. If the new node is a value node, the VALUE keyword allows indicating the corresponding value. This keyword is omitted when inserting an element node. For each current node v in the output of the previous step, let w be the new child to be inserted with interval [t Set gap(w , T 2 ) = gap(w, T )gap(w, T 1 ) 2.3.3. Set gap(w, T 3 ) = gap(w, T ) 2.3.4. Delete gap(w, T ) 2.4. Since succ ≺ (w, T 1 ) = w , then at this point the encoding of w at interval [t Get l, the last tuple in δ i . 4.2. Set l.to = t c -1. 4.3. Add a new tuple r s.t. r. f rom = t c , r.to = N ow, r.valid = l.valid ∪ {w }.</figDesc><table><row><cell>FOR $p IN //player[name/last='Carter']/stats</cell></row><row><cell>INSERT $ p/minutes</cell></row><row><cell>VALUE '33.2'</cell></row><row><cell>FOR variable IN PathExpression</cell></row><row><cell>INSERT ChildExpression</cell></row><row><cell>[VALUE value]</cell></row><row><cell>Algorithm 8 (InsertNode)</cell></row><row><cell>INPUT: Document D, Summary S, inser t_statement.</cell></row><row><cell>OUTPUT: Updated Document D and Summary S.</cell></row><row><cell>1. Evaluate PathExpression in inser t_statement with evalua-</cell></row><row><cell>tion functions from Sect. 8.2.</cell></row><row><cell>2. 3. Update the corresponding T C P tables, creating a new table if</cell></row><row><cell>required (i.e., if there is no table associated to the label that appears</cell></row><row><cell>in ChildExpression).</cell></row><row><cell>4. Update the corresponding δ i tables as follows</cell></row><row><cell>4.1. Example 21 Let us consider the following expression eval-</cell></row><row><cell>uated on Fig. 19 database:</cell></row></table><note><p>c , N ow] 2.1. Get w, the last child of v at current time t c which has a current interval [t w , N ow]. Let w a node in D such that succ ≺ (w, T ) = w for some interval T . 2.2. Insert w into D and S by updating the order relation and the successor function as follows: succ ≺ (w, T 1 ) = w , succ ≺ (w , T 2 ) = w , and succ ≺ (w, T 3 ) = w . (Note that intervals T 1 , T 2 , and T 3 are a partition of the former interval T and that succ ≺ (w, T ) = w is no longer pertinent.) 2.3. Update the gap function for w and w as follows 2.3.1. Set gap(w, T 1 ) = gap(w, T )DIV 2, where DIV is the integer division 2.3.2. c , N ow] is assigned as follows: τ ( w , [t c , N ow] ) = τ ( w, [t w , N ow] ) + gap(w, T 1 )</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>The work presented in this paper is the continuation of a research project started jointly with our beloved friend and mentor Alberto O. Mendelzon, who sadly passed away in June 2004. We are grateful to the reviewers for their hard work and invaluable insights which helped to greatly improve the paper. We would also like to thank Mariana Zerega, who collaborated in the implementation of many of the algorithms presented in this work, and Marcela Campo, for her help with the algorithms presented in Sect. 4. Alejandro Vaisman was partially supported by the Millennium Nucleus Center for Web Research, Grant P04-67-F, Mideplan, Chile.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>list = list.getChildren("name"); list = list.valFilter('Raptors'); list = list.getParent("franchise"); list = list.getDescendants("player"); list = list.getChildren("name"); list = list.tempFilter("from ≥ 20");</p><p>If the number of nodes satisfying the last predicate ("from ≥ 20") is smaller than those satisfying the first predicate ('Raptors'), it might be better in terms of performance to choose a bottom-up query plan like the following: Query plans that are a blend of top-down and bottom-up evaluations are also possible.</p><p>We present next algorithms for computing functions getDescendants(Label) and tempFilter(temp-Pred) on a TempIndex using the temporal interval encoding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 6 (getDescendants)</head><p>INPUT: in List, Label. OUTPUT: out List.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">For each s such that (s, n, I ) is in in List</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.">Get the descendants of s in the summary graph with label</head><p>Label and add them to s N odes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>For each s in s N odes </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Cluet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ferran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-C</forename><surname>Rousset</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Xyleme project</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="225" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A temporal data model for XML documents</title>
		<author>
			<persName><forename type="first">T</forename><surname>Amagasa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yoshikawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Uemura</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of DEXA Conference</title>
		<meeting>DEXA Conference</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="334" to="344" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Indexing valid time intervals</title>
		<author>
			<persName><forename type="first">T</forename><surname>Bozkaya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ozsoyoglu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of DEXA Conference</title>
		<meeting>DEXA Conference</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="541" to="550" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Keys for XML</title>
		<author>
			<persName><forename type="first">P</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Davidson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Netw</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="473" to="487" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Archiving scientific data</title>
		<author>
			<persName><forename type="first">P</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Khanna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Tajima</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2002 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 2002 ACM SIGMOD International Conference on Management of Data<address><addrLine>Madison, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Managing historical semistructured data</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chawathe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theory and Practice of Object Systems</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="143" to="162" />
			<date type="published" when="1999">1999</date>
			<publisher>Wiley</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The TSIMMIS project: integration of heterogeneous information sources</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chawathe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">G</forename><surname>Molina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ireland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Papakonstantinou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ullman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proeedings of 100th Anniversary Meeting of the Information Processing Society of Japan</title>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="7" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Version management of XML documents</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chien</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Tsotras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zaniolo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third International Workshop on the Web and Databases</title>
		<meeting>the Third International Workshop on the Web and Databases<address><addrLine>Dallas, TX</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="75" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Efficient management of multiversion documents by object referencing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chien</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Tsotras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zaniolo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th International Conference on Very Large Data Bases</title>
		<meeting>the 27th International Conference on Very Large Data Bases<address><addrLine>Rome, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="291" to="300" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Temporal query languages: a survey</title>
		<author>
			<persName><forename type="first">J</forename><surname>Chomicki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st International Conference on Temporal Logic</title>
		<meeting>the 1st International Conference on Temporal Logic</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">827</biblScope>
			<biblScope unit="page" from="506" to="534" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">APEX: An adaptive path index for XML data</title>
		<author>
			<persName><forename type="first">C.-W</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-K</forename><surname>Min</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Shim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2002 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 2002 ACM SIGMOD International Conference on Management of Data</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="121" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">On the semantics of &quot;now&quot; in databases</title>
		<author>
			<persName><forename type="first">J</forename><surname>Clifford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Dyreson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Isakowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">T</forename><surname>Snodgrass</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Datab. Syst</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="171" to="214" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Optimizing queries on files</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Consens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Milo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1994 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 1994 ACM SIGMOD International Conference on Management of Data</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="301" to="312" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">An authorization model for temporal XML documents</title>
		<author>
			<persName><forename type="first">S</forename><surname>De Capitani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SAC&apos;02</title>
		<meeting>SAC&apos;02<address><addrLine>Madrid, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="1088" to="1093" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Fractional XSKETCH synopses for XML databases</title>
		<author>
			<persName><forename type="first">N</forename><surname>Drukh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Polyzotis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">N</forename><surname>Garofalakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Matias</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Second International XML Database Symposium</title>
		<meeting>Second International XML Database Symposium<address><addrLine>XSym</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004">2004. 2004</date>
			<biblScope unit="page" from="189" to="203" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Supporting valid-time indeterminacy</title>
		<author>
			<persName><forename type="first">C</forename><surname>Dyreson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Snodgrass</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Datab. Syst</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="57" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Observing transaction-time semantics with TTX-Path</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Dyreson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of WISE 2001</title>
		<meeting>WISE 2001</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="193" to="202" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Capturing and querying multiple aspects of semistructured data</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Dyreson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Bolen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Jensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th VLDB Conference</title>
		<meeting>the 25th VLDB Conference</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="290" to="301" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m">Temporal Databases: Research and Practice. In: LNCS 1399</title>
		<editor>
			<persName><forename type="first">O</forename><surname>Etzion</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Jajodia</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Sripada</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Integrity constraints for XML</title>
		<author>
			<persName><forename type="first">W</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Siméon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">66</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="254" to="291" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Storing and querying XML data using a RDBMS</title>
		<author>
			<persName><forename type="first">D</forename><surname>Florescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kossmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Data Eng. Bull</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="27" to="34" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Syntax, semantics and query evaluation in the τ XQuery temporal XML query language</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Snodgrass</surname></persName>
		</author>
		<idno>TR-72</idno>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
	<note type="report_type">Time Center Technical Report</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Temporal slicing in the evaluation of XML queries</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Snodgrass</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th International Conference on Very Large Data Bases</title>
		<meeting>the 29th International Conference on Very Large Data Bases<address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="632" to="643" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Representing changes in XML documents using dimensions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gergatsoulis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Stavrakas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First Symposium on XML databases</title>
		<meeting>the First Symposium on XML databases<address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">XSym 2003. 2003</date>
			<biblScope unit="page" from="208" to="222" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Dataguides: enabling query formulation and optimization in semistructured databases</title>
		<author>
			<persName><forename type="first">R</forename><surname>Goldman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd International Conference on Very Large Data Bases</title>
		<meeting>the 23rd International Conference on Very Large Data Bases</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="436" to="445" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Introducing an annotated bibliography on temporal and evolution aspects in the world wide web</title>
		<author>
			<persName><forename type="first">F</forename><surname>Grandi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Rec</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="4" to="86" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">The valid web: an XML/XSL infrastructure for temporal management of web documents</title>
		<author>
			<persName><forename type="first">F</forename><surname>Grandi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Mandreoli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Advances in Information Systems</title>
		<meeting>the International Conference on Advances in Information Systems</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="294" to="303" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Effective representation and efficient management of indeterminate dates</title>
		<author>
			<persName><forename type="first">F</forename><surname>Grandi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Mandreoli</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="164" to="169" />
		</imprint>
	</monogr>
	<note>In: TIME&apos;01</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Multiresolution indexing of XML for frequent queries</title>
		<author>
			<persName><forename type="first">H</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th International Conference on Data Engineering</title>
		<meeting>the 20th International Conference on Data Engineering</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="683" to="694" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A comparison of labeling schemes for ancestor queries</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kaplan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Milo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Shabo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the thirteenth annual ACM-SIAM Symposium on Disete Algorithms</title>
		<meeting>the thirteenth annual ACM-SIAM Symposium on Disete Algorithms</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="954" to="963" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Covering indexes for branching path queries</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kaushik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bohannon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Naughton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">F</forename><surname>Korth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2002 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 2002 ACM SIGMOD International Conference on Management of Data</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="133" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Updates for structure indexes</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kaushik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bohannon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Naughton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Shenoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th International Conference on Very Large Data Bases</title>
		<meeting>the 28th International Conference on Very Large Data Bases</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="239" to="250" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Exploiting local similarity for indexing paths in graph-structured data</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kaushik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Shenoy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bohannon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Gudes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th International Conference on Data Engineering</title>
		<meeting>the 18th International Conference on Data Engineering</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="129" to="140" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">XMILL: an efficient compressor for XML data</title>
		<author>
			<persName><forename type="first">H</forename><surname>Liefke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2000 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 2000 ACM SIGMOD International Conference on Management of Data</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="153" to="164" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Temporal XML</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">G</forename><surname>Manukyan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Kalinichenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ADBIS</title>
		<meeting>ADBIS<address><addrLine>Vilnius, Lithuania</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="581" to="590" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Change-centric management of versions in an XML warehouse</title>
		<author>
			<persName><forename type="first">A</forename><surname>Marian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Cobena</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Mignet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th VLDB Conference</title>
		<meeting>the 27th VLDB Conference<address><addrLine>Rome, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="581" to="590" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Indexing temporal XML documents</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">O</forename><surname>Mendelzon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Rizzolo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vaisman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th International Conference on Very Large Databases</title>
		<meeting>the 30th International Conference on Very Large Databases<address><addrLine>Toronto, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="216" to="227" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Index structures for path expressions</title>
		<author>
			<persName><forename type="first">T</forename><surname>Milo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th International Conference on Database Theory</title>
		<meeting>the 7th International Conference on Database Theory</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="277" to="295" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Representative objects: concise representations of semistructured, hierarchial data</title>
		<author>
			<persName><forename type="first">S</forename><surname>Nestorov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Wiener</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Chawathe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th International Conference on Data Engineering</title>
		<meeting>the 13th International Conference on Data Engineering</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="79" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Temporal aspects of semistructured data</title>
		<author>
			<persName><forename type="first">B</forename><surname>Oliboni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Quintarelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Tanca</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eight International Symposium of Temporal Representation and Reasoning</title>
		<meeting>the Eight International Symposium of Temporal Representation and Reasoning</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="119" to="127" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Statistical synopses for graph-structured XML databases</title>
		<author>
			<persName><forename type="first">N</forename><surname>Polyzotis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">N</forename><surname>Garofalakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2002 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 2002 ACM SIGMOD International Conference on Management of Data</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="358" to="369" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Structure and value synopses for XML data graphs</title>
		<author>
			<persName><forename type="first">N</forename><surname>Polyzotis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">N</forename><surname>Garofalakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th International Conference on Very Large Data Bases</title>
		<meeting>the 28th International Conference on Very Large Data Bases</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="466" to="477" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">XCLUSTER synopses for structured XML content</title>
		<author>
			<persName><forename type="first">N</forename><surname>Polyzotis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">N</forename><surname>Garofalakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd International Conference on Data Engineering</title>
		<meeting>the 22nd International Conference on Data Engineering</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Approximate XML query answers</title>
		<author>
			<persName><forename type="first">N</forename><surname>Polyzotis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">N</forename><surname>Garofalakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">E</forename><surname>Ioannidis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2004 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 2004 ACM SIGMOD International Conference on Management of Data</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="263" to="274" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">D(k)-index: an adaptive structural summary for graph-structured data</title>
		<author>
			<persName><forename type="first">C</forename><surname>Qun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">W</forename><surname>Ong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2003 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 2003 ACM SIGMOD International Conference on Management of Data</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="134" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Indexing XML data with ToXin</title>
		<author>
			<persName><forename type="first">F</forename><surname>Rizzolo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">O</forename><surname>Mendelzon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 4th International Workshop on the Web and Databases</title>
		<meeting>4th International Workshop on the Web and Databases</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="49" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Comparison of access methods for timeevolving data</title>
		<author>
			<persName><forename type="first">B</forename><surname>Salzberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Tsotras</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="158" to="221" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Labelling implicit routing in networks</title>
		<author>
			<persName><forename type="first">N</forename><surname>Santoro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Khatib</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. J</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="5" to="8" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">HOPI: an efficient connection index for complex XML document collections</title>
		<author>
			<persName><forename type="first">R</forename><surname>Schenkel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Theobald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Weikum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th Conference on Extending Database Technology</title>
		<meeting>the 9th Conference on Extending Database Technology</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="237" to="255" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<ptr target="http://www.sleepycat.com/products/bdbje.html" />
		<title level="m">Sleepycat Software: Berkeley DB Java Edition</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<title level="m" type="main">The TSQL2 Temporal Query Language</title>
		<author>
			<persName><forename type="first">R</forename><surname>Snodgrass</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Dordnecht</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<title level="m">Temporal Databases: Theory, Design and Implementation</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Tansel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Clifford</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Gadia</surname></persName>
		</editor>
		<meeting><address><addrLine>Benjamin/Cummings, Reading</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Updating XML</title>
		<author>
			<persName><forename type="first">I</forename><surname>Tatarinov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ives</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Halevy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Weld</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGMOD Conference</title>
		<meeting>ACM SIGMOD Conference<address><addrLine>Santa Barbara, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="413" to="424" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">A formal semantics of patterns in XSLT</title>
		<author>
			<persName><forename type="first">P</forename><surname>Wadler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Markup Technologies</title>
		<meeting><address><addrLine>Philadelphia</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="183" to="202" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Temporal queries in XML document archives and web warehouses</title>
		<author>
			<persName><forename type="first">F</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zaniolo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th International Symposium on Temporal Representation and Reasoning (TIME&apos;03)</title>
		<meeting>the 10th International Symposium on Temporal Representation and Reasoning (TIME&apos;03)<address><addrLine>Cairns, Australia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="47" to="55" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">XBiT: an XML-based bitemporal data model</title>
		<author>
			<persName><forename type="first">F</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zaniolo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd International Conference on Conceptual Modeling</title>
		<meeting>the 23rd International Conference on Conceptual Modeling<address><addrLine>Shanghai, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="810" to="824" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Efficient XML-based techniques for archiving, querying and publishing the histories of relational databases</title>
		<author>
			<persName><forename type="first">F</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zaniolo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Time Center TeEchnical Report</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Temporal XML? SQL strikes back</title>
		<author>
			<persName><forename type="first">F</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zaniolo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIME&apos;05)</title>
		<meeting>the 12th International Symposium on Temporal Representation and Reasoning (TIME&apos;05)<address><addrLine>Burlington, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="47" to="55" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<monogr>
		<author>
			<orgName type="collaboration">World Wide Web Consortium</orgName>
		</author>
		<ptr target="http://www.w3.org/TR/2002/WD-xque-ry-20021115" />
		<title level="m">XQuery 1.0: An XML Query Language</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<monogr>
		<author>
			<orgName type="collaboration">World Wide Web Consortium</orgName>
		</author>
		<ptr target="http://www.w3.org/TR/2003/WD-xpath20-20030502" />
		<title level="m">XML Path Language XPath</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page">0</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Inemental maintenance of XML structural indexes</title>
		<author>
			<persName><forename type="first">K</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Stanoi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2004 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 2004 ACM SIGMOD International Conference on Management of Data</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="491" to="502" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
