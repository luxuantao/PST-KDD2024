<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Continual Queries for Internet Scale Event-Driven Information Delivery</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Ling</forename><surname>Liu</surname></persName>
							<email>lingliu@cc.gatech.edu</email>
							<affiliation key="aff0">
								<orgName type="department">College of Computing</orgName>
								<orgName type="institution">Georgia Institute of Technology</orgName>
								<address>
									<addrLine>801 Atlantic Dr</addrLine>
									<postCode>30332</postCode>
									<settlement>Atlanta</settlement>
									<region>GA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Calton</forename><surname>Pu</surname></persName>
							<email>calton@cc.gatech.edu</email>
							<affiliation key="aff0">
								<orgName type="department">College of Computing</orgName>
								<orgName type="institution">Georgia Institute of Technology</orgName>
								<address>
									<addrLine>801 Atlantic Dr</addrLine>
									<postCode>30332</postCode>
									<settlement>Atlanta</settlement>
									<region>GA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Wei</forename><surname>Tang</surname></persName>
							<email>wtang@cc.gatech.edu</email>
							<affiliation key="aff0">
								<orgName type="department">College of Computing</orgName>
								<orgName type="institution">Georgia Institute of Technology</orgName>
								<address>
									<addrLine>801 Atlantic Dr</addrLine>
									<postCode>30332</postCode>
									<settlement>Atlanta</settlement>
									<region>GA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Continual Queries for Internet Scale Event-Driven Information Delivery</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">6F153EF3FC03A4BD12C2C88285C4D1D3</idno>
					<note type="submission">received 15 May 1998; revised 17 Sept. 1998.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:06+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Index termsÐDistributed information systems</term>
					<term>Internet scale information delivery</term>
					<term>World Wide Web technology</term>
					<term>distributed triggers</term>
					<term>event monitoring</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>AbstractÐIn this paper we introduce the concept of continual queries, describe the design of a distributed event-driven continual query systemÐOpenCQ, and outline the initial implementation of OpenCQ on top of the distributed interoperable information mediation system DIOM <ref type="bibr" target="#b21">[22]</ref>, <ref type="bibr" target="#b19">[20]</ref>. Continual queries are standing queries that monitor update of interest and return results whenever the update reaches specified thresholds. In OpenCQ, users may specify to the system the information they would like to monitor (such as the events or the update thresholds they are interested in). Whenever the information of interest becomes available, the system immediately delivers it to the relevant users; otherwise, the system continually monitors the arrival of the desired information and pushes it to the relevant users as it meets the specified update thresholds. In contrast to conventional pull-based data management systems such as DBMSs and Web search engines, OpenCQ exhibits two important features: 1. it provides push-enabled, eventdriven, content-sensitive information delivery capabilities, and 2. it combines pull and push services in a unified framework. By eventdriven we mean that the update events of interest to be monitored are specified by users or applications. By content-sensitive, we mean the evaluation of the trigger condition happens only when a potentially interesting change occurs. And, by push-enabled, we mean the active delivery of query results or triggering of actions without user intervention.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION 1.Motivation</head><p>W ITH the ongoing advance of the World Wide Web (WWW or the web), everyone can publish information on the web independently at any time. While the flexibility and autonomy of information production and sharing is phenomenal, it is equally daunting to navigate, collect, process, and track data in this dynamic and open information space. The problem is aggravated when source information changes constantly and unpredictably. As a result, users have to frequently poll the web sites of interest and fuse the newly updated information manually to keep track of changes of interest, which is a great pain.</p><p>As more aspects of business and commerce migrate online, there is increasing interest in having software systems execute and interoperate over the Internet. Execution and interoperation at Internet scale imply a degree of loose coupling and heterogeneity among the components. A promising architectural style for distributed, loosely coupled, heterogeneous software systems is a structure based on push-enabled event generation, observation (event detection and condition triggering), and notification. Eventdriven information delivery systems becomes increasingly important because it offers system-supported update monitoring, event-driven information delivery, and it provides timely response (or alert) to critical situations, while reducing the time users spend hunting for the updated information and avoiding unnecessary traffic on the net. The technology to support event-based systems is well developed for local area networks (e.g., Field's Msg <ref type="bibr" target="#b30">[31]</ref>, Softbench's BMS <ref type="bibr" target="#b9">[10]</ref>, Yeast <ref type="bibr" target="#b15">[16]</ref>) and for active databases (e.g., <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b27">[28]</ref>, <ref type="bibr" target="#b33">[34]</ref>, <ref type="bibr" target="#b39">[40]</ref>), but off-the-shelf software is still premature for Internet scale applications. Hence new technologies are needed to support the construction of Internet-scale, event-driven software systems.</p><p>Recently there have been a small number of proposals and initial prototypes for Internet-scale event facilities, such as OMG CORBA Event Service <ref type="bibr" target="#b28">[29]</ref> and the TINA Notification Service <ref type="bibr" target="#b8">[9]</ref>. But the definitions of these facilities address only a limited portion of the full problem space. Furthermore, most of the implementations of CORBA Object Request Brokers are quite low level, missing the semantics of applications. Therefore, we design and develop a new facility for event observation and notification using distributed triggers, in the context of the Continual Queries project, to better serve the need of Internet-scale applications.</p><p>In this paper, we describe the concept of continual queries and a distributed event-driven information delivery system, OpenCQ, that is designed for supporting continual queries. Continual Queries (CQ) are standing queries that monitor update of interest and return results whenever the update reaches specified thresholds. Continual queries can be specified over system built-in as well as user-defined operations. OpenCQ is a distributed continual query system for event-driven information delivery, equipped with distributed event observation, notification, and triggering facility. In OpenCQ, users may specify to the system the information they would like to monitor (such as the events or the update thresholds they are interested in). Whenever the information of interest becomes available, the system immediately delivers it to the relevant users; otherwise, the system continually monitors the arrival of the desired information and pushes it to the relevant users as it meets the specified update thresholds. In contrast to conventional pull-based data management systems (such as DBMSs, Web Search Engines) where the scope of a query is limited to past and present data, in OpenCQ, the scope of a query in a event-driven continual query system includes past, present, and future data. For example, a query ªGive me the timeseries of water temperature at Tansy Pt. during the last month,º is a typical query in a pull-based DBMS, which is defined over the time-series of water temperature at Tansy Pt. that are available up to the moment when this query is issued. In contrast, a request, ªReport to me in the next four weeks the time-series of water temperature at Tansy Pt. every day at 10:00 a.m.,º is a continual query in the OpenCQ continual query system. It has a query component asking for the time-series of water temperature at Tansy Pt., a trigger condition, 10:00 a.m. everyday, and a stop condition, the next four weeks. The scope of this continual query covers the time-series of water temperature at the installation time of this continual query, plus the time-series of water temperature changes that may arrive in the future.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Overview of OpenCQ</head><p>The ultimate goal of the OpenCQ research is to develop a toolkit for Internet-scale update monitoring with eventdriven evaluation and delivery. Our framework is organized around five abstract models, each of which focuses on a different dimension of concern in the design.</p><p>. An object model, which characterizes the information producers (that generate events) and the consumers (that receive notifications about events). Both userdefined objects and system-defined objects are components of the object model. An object can be a hardware or a software component, e.g., a clock, a file, a program, a process, or a communication packet. The entities that receive notifications about events are also objects. The object model incorporates the standard notion of encapsulation of functionality. . An event model, which characterizes distributed events and a time model. Events may be defined in the time dimension (e.g., every 10 minutes or 10 a.m. everyday) or in the information space (e.g., currents at a station in the Columbia River estuary exceed 3 m/s or IBM stock price drop by 10 percent). Events are either primitive or composite. Primitive events are further characterized as being predefined or user-defined. Predefined events can be automatically detected by the server, in particular, the server polls the system environment for their occurrences. User-defined primitive events must be registered in the server by a user or a program such that the server can have information about the semantics of user-defined events in order to detect their occurrences automatically. The time model concerns the temporal and causal relationships between events and notifications and addresses the problems of synchroniz-ing clocks across distributed systems as well as associating times with events in distributed systems. According to this event model, an event can be uniquely characterized by the identity of the object of interest involved in the event, the identity of the operation, the identity of the invoker, and the time of occurrence of the event. An event is observable if some object other than the object of interest and the invoker can detect the occurrence of the event; and it is up to the object of interest to determine which of its events can be observable. . An observation model, which defines the mechanisms by which event occurrences and patterns of event occurrences are observed. We refer to the objects who observe or detect the update events of interest the event observer or event detector. The observation model addresses issues such as: <ref type="bibr" target="#b0">1</ref>. what mechanisms can we use to achieve the observation of an event, 2. how event-specific information is to be requested and observed, 3. what kinds of event patterns need to be specified, 4. how should event patterns be recognized and observed, 5. in which way observation tasks are partitioned among observers, 6. how event-specific information is used to select events for notification, and 7. when, where, and how event observation objects (observers) are created and destroyed. . A notification model, which defines the mechanisms that users or applications use to express interest in events and receive notifications. In OpenCQ we use the continual query specification language to express the update event monitoring requests. We treat notifications as independent communications between event detectors (observers) and recipients. This becomes particularly important when there are multiple independent observers involved. . A resource model, which defines where in the Internet the observation and notification components are located, and how resources for the computations are allocated and accounted. Typically each information source will be wrapped in a resource model that establishes the correspondence between local resource entities and OpenCQ objects defined in the object model. We can view the resource models as the wrappers to the information sources. For those data sources that have no built-in trigger facility as those in RDBMSs, their wrappers have to provide base event detection capability.</p><p>To illustrate the concepts of these five models, let us consider the example of forecasting currents at the mouth of the Columbia River as an aid to navigation. The entity Columbia River and the entity Forecast Currents are conceptual level objects that we are interested in monitoring, thus they are elements of the object model. If we are interested in monitoring the Columbia River forecast currents every 15 minutes during ebb tide, then the event entity 15 minutes and the constraint ebb are the elements of the event model. If the monitoring condition is, whenever the maximum forecast current at the mouth exceeds 3 m/s, then the base event consists of updates of the maximum forecast current and the condition is such current exceeding 3 m/s. The observation model watches the circulation forecasts and enters the notification model when the maximum currents reaches 3 m/s. The resource model describes the results obtained from forecast data sources for the geographic region at the mouth of the Columbia River. One of the most popular notification mechanisms is by email whenever the event of interest is detected or observed, but in the case of this example it could also be a broadcast at a marine radio frequency.</p><p>We believe that by incorporating distributed events and triggers into the query evaluation and search process, the information quality, system scalability, and query responsiveness can be greatly improved.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Scope and Organization of the Paper</head><p>OpenCQ presents an extensible architecture for Internet scale event-driven information delivery systems. We envision that the five models and their coordination policies will provide a useful reference framework for in-depth study of the efficiency, performance, scalability of distributed trigger facility and distributed event detection facility. However, due to the complexity involved, we restrict the initial system development effort to the specification of continual queries, and the design and implementation of event observation model, in particular the event detection and trigger condition evaluation upon the occurrences of events of interest. In this paper, we report our initial experience with the development of OpenCQ system with the emphasis on the execution semantics of continual queries and the event observation model. We discuss the specification of continual queries and the event model only to the extend that is required for understanding of the observation model. We will report on our development of the OpenCQ object model, notification model, and resource model in other forthcoming reports.</p><p>The rest of the paper is organized as follows: We describe the concept of continual queries and outlines the execution process of a continual query in Section 2. In Section 3, we outline the OpenCQ continual query specification language and illustrate the continual query (CQ) specification, in particular CQ trigger definitions, through a number of examples. We discuss the execution semantics of continual queries, in particular the initial design of the OpenCQ event observation model, in Section 4. Section 5 presents the implementation design and implementation architecture of the first prototype of the OpenCQ continual query system. Section 6 discusses performance evaluation issues. We conclude with an overview of related work in Section 7, and a summary and directions for future work in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">CONTINUAL QUERIES</head><p>Continual queries are standing queries that monitor updates and return results whenever the updates have reached specified thresholds. A continual query consists of three key components: query, trigger, and stop condition. In contrast to ad hoc queries in conventional DBMSs or web search engines or query systems, a continual query, issued once, runs continually over the set of information sources.</p><p>Whenever its trigger condition becomes true, the new result since the previous execution of the query will be returned. The trigger part of a continual query specifies events or situations to be monitored. We distinguish primitive events from conditional (logical) events and allow events to be composed of other events. We use primitive events to model basic database operations (such as INSERT, DELETE, UPDATE), basic time events (such as at 10:00 a.m., September 15, 1998, every 10 minutes, and after a hour), or signals from arbitrary processes. We use conditional events to model various conditional situations to be monitored. We provide a rich set of event composition operators (such as logic operators: conjunction, disjunction, negation; and execution dependency operators: serial, serial alternative, parallel, parallel alternative) to support composition of events.</p><p>Continual queries can be useful both to external applications and as a convenient mechanism for implementing push-based data delivery functions beyond conventional storage, retrieval, and update of data in conventional DBMSs. Some examples of pull-based functionality can be implemented in a unified way using continual queries and are described in this section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Continual Query Concept</head><p>A continual query is defined by a triple (, q , Stop), consisting of a normal query (e.g., written in SQL), a trigger condition q , and a termination condition Stop. q and Stop in general may depend on many different parameters, in the sequel we omit their parameters for clarity. The initial execution of a continual query is performed as soon as it is installed. The first run of is performed over past and present data represented by the state of information sources, and the whole result obtained by executing is returned to the user. The subsequent executions of are performed whenever a new update event occurs (is signaled) and the trigger condition q becomes true. For each execution of , only the new query matches since the previous execution are returned to the user unless specified otherwise. Thus continual queries are defined over past, present, and future data, whereas the domain of pull queries is limited to past and present data.</p><p>Continual Semantics. Let us denote the result of running query on database state i as i . We define the result of running a continual query g as a sequence of query answers f I Y P Y F F F Y n g obtained by running query on the sequence of database states i Y I i n, at each given state i i b H, i is triggered by q XStop.</p><p>The basic events that cause continual queries to fire may be standard database operations such as INSERT, DELETE, UPDATE, or the events that cause clock signals (e.g., check the balance of all bank accounts at 5:00 p.m. everyday), or any user-or application-generated signals (e.g., a failure signal from a diagnostic routine on a hardware component). Furthermore, the trigger conditions to be monitored may be complex, and may be defined not only on single data values or individual database states, but also on sets of data objects (e.g., the total of orders of items exceeds the current inventory level), transitions between states (e.g., the new position of the ship is closer to the destination than the old position), trends and historical data (e.g., the output of the sensor increased monotonically over the past two hours).</p><p>In OpenCQ we support two types of trigger conditions: time-based trigger condition and content-based trigger condition. Three types of temporal events are supported for time-based trigger condition: 1. absolute points in time, defined by the system clock (e.g., 7:30:00 p.m., <ref type="bibr">March 30, 1998)</ref>; 2. regular time interval (e.g., execute every Monday or every two weeks) or irregular time interval (e.g., execute every first day of the month); 3. relative temporal event (e.g., 50 seconds after event A occurred). A content-based trigger condition can be expressed in terms of a database query, a built-in situation assessment function, or a user-defined method. Examples include: a simple condition on the database state (e.g., execute whenever a deposit of $10,000 is made), an aggregate function on the database state (e.g., execute when a total of $1 million of deposits have been made, or execute when the stock price of IBM drops 5 percent), and a relationship between a previous query result and the current database state (e.g., execute when a total of 1 million dollars of deposits have been made since the previous execution of ). One extreme case of content-based trigger is immediate: report to me whenever a change to the source data occurs. In addition, composite events made up from these primitive events (e.g., the serial sequence of two events: Event B occurs after event A) are also supported.</p><p>The Stop condition specifies the termination condition of a continual query. Stop conditions can be specified in terms of time-based or content-based event expressions. Both the trigger condition q and the termination condition Stop are evaluated prior to each subsequent execution of the query component .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Continual Query Examples</head><p>We below provide two continual query examples, one uses time-based triggering event and one uses content-based triggering event.</p><p>Example 1. Given a continual query, ªReport to the manager every day at 6:00 p.m. all the banking activities of the day for those customers whose total withdraws reach $2,000.º It is expressed as follows:</p><p>Create Continual queries, at the first glance, may seem to bear resemblance to ECA rules in active databases <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b27">[28]</ref>. One might view continual queries as a subset of ECA rules. However, they are quite different not only in functionality coverage and usage perspective but also in execution model and implementation architecture. In this section we briefly discuss the subtle differences between continual queries and ECA rules.</p><p>First, update events in ECA rules are explicitly specified by the users, whereas update events in continual queries are implicitly implied in the trigger condition, and derived by the system during the installation phase of the continual queries. Recall Example 2 given in Section 2.2. At the installation phase of the continual query inventory_monitoring, the update events identification module identifies three basic update events to be relevant to the trigger condition of the given continual query. They are UPDATE qty_on_hand (item), UPDATE qty_on_order(item), UPDATE threshold(item) for item in Item_Inventory. This means that any update on qty_on_hand, qty_on_order or threshold will signal the evaluation of the trigger condition ªqty_on_hand qty_on_order `threshold.º However, using ECA rules, one may specify the follow rule:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Event:</head><p>Update qty_on_hand(item) Condition: qty_on_hand(item) + qty_on_order(item) &lt; threshold(item) Action: submit_order(item)</p><p>Note that this ECA rule has the same trigger condition as the continual query in Example 2. However, this rule means that the condition is evaluated only when the update on qty_on_hand occurs, even though the updates on qty_on_order or threshold may equally be possible to cause the violation of the trigger condition ªqty_on_hand + qty_on_order &lt; threshold.º In short, ECA rules provide flexibility to allow users to explicitly specify what update events are of interest at will, rather than restricting the update events to those that have direct impact on the trigger condition within the same rule. Such flexibility, however, may results in passing over the situations that should be alerted according to the trigger condition.</p><p>Second, continual queries require explicit specification of termination condition. In the absence of Stop condition, a system default value (such as one year) will be used. Introducing termination condition as a necessary component of continual queries guarantees that alerts or update reports will send only to the right users at right time or under the specific constraints. While ECA rules terminate a rule execution by requiring users to manually delete the rule from the rule base. No system controlled termination is provided. We consider the support for system-controlled termination condition as a desirable and practical capability for an event-driven active information delivery system.</p><p>Thirdly, although situation monitoring is one of the canonical applications of ECA rules, they are designed as building blocks for general purpose active database systems or production rule systems <ref type="bibr" target="#b39">[40]</ref> in centralized data management systems, whereas continual queries are specifically designed for update monitoring in distributed event-driven information delivery systems. Continual queries emphasize on effective and specialized support for personalized update monitoring. For readers who are familiar with the program specialization systems <ref type="bibr" target="#b38">[39]</ref>, <ref type="bibr" target="#b29">[30]</ref>, popular in OS and PL communities, there is a close analogy between continual queries and program specialization. If we view program specialization as a means for improving program performance and obtaining better control of program behavior and consistency, then continual queries can be seen as an interesting and effective specialization of ECA rules, which aims at providing more efficient support for personalized update monitoring in distributed open environments such as the Internet.</p><p>Last but not least, actions in ECA rules can be update events which may in turn trigger the same rule again, directly or indirectly (i.e., the cascading effects of rules); whereas actions fired, when the trigger condition of a continual query is evaluated to be true, are restricted to the execution of the same query expression, the change notification functions, and the methods to compute the differential result; They are side-effect free actions with respect to the data set over which the trigger condition and query component are defined. This feature simplifies many complex issues in ECA Rules, especially those related to the consistency and concurrency issues in advanced transaction management. Such simplification allows us to focus on addressing the issues that are specific to update monitoring and push-based information delivery. We provide a further discussion on active databases and other related work in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">CONTINUAL QUERY SPECIFICATION</head><p>We have implemented OpenCQ continual query system, based on the concept of continual queries introduced in Section 2. In what follows, we will describe how continual queries are defined (in this section), installed (activated), and executed (in Section 4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Specification Semantics</head><p>Continual queries, like all other forms of data, are treated as first class objects. There is a continual query entity type, and every continual query is an instance of this type. The difference between continual query entity type and other entity types is that OpenCQ understands the semantics of continual queries and invokes a particular operationÐfire automatically. The functions that define the key components of the structure of a continual query are:</p><p>. Continual query identifier (cqid). Like any other entity, each continual query (CQ) has a unique entity identifier. Such identifier is generated by the system after the installation of the CQ is successful and the first run of the CQ is fired. . Continual query name. This is a user-defined and optional attribute. . Trigger condition. The trigger component specifies the event that causes OpenCQ to fire the subsequent executions of the continual query (CQ). Typed formal parameters may be defined for the event; these parameters are bound to actual arguments when the next execution of this CQ is fired. . Stop condition. The Stop condition specifies the termination semantics of the continual query. It is described by an event expression. Both time-based events and content-based events can be used. . Query component. The query is one of the sideeffect free actions to be executed when the trigger condition is evaluated to be true and the Stop condition is not met. The execution coupling mode between the trigger condition and the query action can be specified explicitly at the continual query installation time to override the system default (see Section 4 for further detail).</p><p>Both Trigger and Stop conditions are specified in terms of event expressions. We distinguish between primitive events, composite events, and conditional events. A primitive event is either a basic update event (such as UPDATE qty_on_hand(item)) or a temporal event (such as every Monday, 9:00:00 p.m., <ref type="bibr">March 2, 1998)</ref>. A conditional event is a conjunction or a disjunction of events, of which at least one of the component events is a conditional event. An atomic conditional event is an event of the form attribute_name &lt;comparison_op&gt; value, such as ªstock.price &gt; 100.º A composite event is defined by an event composition expression following the BNF syntax below: A complete BNF description of the OpenCQ event specification language and the formal semantics of continual query specification model, including the specification of primitive and composite events, and the algorithm for decomposing the trigger condition components into basic update events and conditional events, are beyond the scope of this paper. Readers who are interested in further details may refer to our technical reports <ref type="bibr" target="#b26">[27]</ref>, <ref type="bibr" target="#b36">[37]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Specification Syntax</head><p>Syntactically, continual queries are defined by specifying trigger condition components in the SQL-like FROM and WHERE clauses, by specifying Stop condition in temporal event expressions, and by specifying query components in the SQL-like SELECT-FROM-WHERE clauses. Users may give each of their continual queries a meaningful name (such as banking_activity_sentinel in Example 1). Continual queries may be defined across a set of data sources that are autonomous and possibly heterogeneous in nature. These data sources may be structured, semistructured, or unstructured. Mediators and wrappers are used to decompose the query or trigger condition according to the number of data sources used to evaluate the query or the trigger condition. Details for distribution aspect of the query processing and trigger condition evaluation are beyond the scope of this paper, and will be addressed in a forthcoming technical report.</p><p>Below, we provide some examples of continual queries written in SQL-like expression enhanced with user-defined or system built-in functions. We first define a continual query weather_watch that monitors weather condition updates in the region from port of Savannah in Georgia to Fort Stewart Military Reservation every 20 minutes and send mail to Todd using the function send_mail whenever the specified update event on weather condition is detected. Suppose that this continual query is defined over a semi-structured data sourceÐthe national weather services center Web site (www.nws.nova.gov)Ðand the continual query name is specified in the Create CQ clause. The trigger condition is specified in the Trigger clause, the termination condition is specified in the Stop clause, and the query component is specified in the Query clause. Here is the specification of this continual query: This continual query specifies the request for monitoring updates on weather conditions at the region from port of Savannah to Fort Stewart every 20 minutes, and detects the update on weather condition at this region using a temporal event detector. Whenever an update event is signaled, the system takes the action of noning Todd by email and delivering the updated result using a specific web URL pointer.</p><formula xml:id="formula_0">Create</formula><p>Note that the action of displaying the updates of weather condition at the specified Savannah region, and the action of reporting to Todd by sending mail is implicitly inferred by the system, based on either the fact that Todd is the owner (creator) of this continual query Savannah_weather_watch or the fact that the creator of this continual query has entered a special request that the update results be sent also to his/her manager, Todd, at the CQ installation time.</p><p>Interesting to note is that the trigger condition and the query component in a continual query both can be specified in SQL-like expressions. When the trigger condition is defined over the same set of objects as the query component, the FROM clause may be omitted (recall Example 2). Here is an example where the trigger condition is defined over a set of object classes that are different from those over which the query component is defined: This continual query amounts to saying that ªmonitoring the weather condition between port of Savannah and Fort Stewart in the next three months, provide me with a list of alternative plans whenever the weather condition changes in the region between Port of Savannah and Fort Stewart Reservation.º Note also that the Transportation_plan may be stored in a relational DBMS (e.g., Oracle), a structured data source, and the weather information is available from the NWS Web site, a semistructured data source.</p><formula xml:id="formula_1">Create CQ</formula><p>Another interesting feature of OpenCQ is to allow users to specify their trigger conditions using system built-in functions in addition to the common string comparison operators such as CONTAINS, LIKE, and algorithmic operators `Y Y bY !Y Y T . For example, the OpenCQ system built-in functions for trigger specification include increased by x percent, denoted as INCRBYPERC() ! x, and decreased by y percent, denoted by DECRBYPERC( ) ! y, where and are field names of the source data items. Using these system built-in functions, the continual query, ªNotify me in the next two weeks whenever the stock price of Bayer drops by 5 percent,º can be expressed conveniently as follows:</p><p>Create CQ Bayer_Stock_watch as Query:</p><p>SELECT company_symbol, stock_price, hi_last_wk, lo_last_wk FROM Stock WHERE company_name = `Bayer AG'; Trigger: company_name = `Bayer AG' AND DECRBYPERC(stock_price) &gt;= 5; Stop:</p><p>9:00:00 am, Oct. <ref type="bibr" target="#b25">26,</ref><ref type="bibr">1998</ref> Generally speaking, in specifying a continual query, the Query clause, Trigger condition clause, and Stop condition clause are essential and thus mandatory. When there is nothing entered for the Stop condition, a default value (e.g., two weeks) is used. When nothing is filled in the Query clause, an error message is generated. When the trigger condition is empty, the default is set to a time-based trigger at a default time interval (say everyday). In addition, one can specify other optional properties for a continual query, such as timing constraints, contingency plans, and external events. Timing constraints include deadlines, priorities/urgencies or value functions. Contingency plans describe alternative actions to be executed in case the timing constraints cannot be met.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">CONTINUAL QUERY EXECUTION SEMANTICS</head><p>We have explained how one defines continual queries in the previous section. We now describe the implementation of how the OpenCQ system triggers and executes continual queries.</p><p>It is well known that in a conventional pull-based DBMS user application programs are executed when explicitly requested to do so. Execution of such programs typically results in the processing of a sequence of transactions, where each transaction is a unit of consistency and recovery. The system guarantees atomicity (all updates issued by the transaction are installed in the database or none are), serializability (the concurrent interleaved execution of a set of transactions is equivalent to a serial no-interleaved execution), and durability (once a transaction is committed, its updates will never be rolled back). In contrast, a continual query system must evaluate installed continual queries under system control (not user or application control). More concretely, once a continual query is installed, the system must decide how to detect the update events of interest, how to evaluate the trigger condition, and when to fire the subsequent execution of the query component, and how should the execution of these tasks be treated with respect to user transactions? This section is is an attempt to answer these questions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">A Quick Look at Continual Query Execution</head><p>Before entering the details on the execution semantics of continual queries, let us first take a quick look at the execution process of a continual query.</p><p>Recall the continual semantics described in Section 2.1, it specifies that, for each continual query g i , denoted by Y q Y Stop, the first execution of g i is activated by the installation of the g i , without going through the evaluation process of the condition q XStop; whereas the subsequent executions of this continual query are fired only when the condition q XStop becomes true. More concretely, when a continual query g i is entered (installed) the first time, the following activation actions take place:</p><p>. g i is registered with a unique continual query identifier (cqid); . For the first run of g i , the query component will be modified by rewriting to include the portion of the trigger condition q , which is defined over the same set of object classes as the query component .</p><p>Let us refer to this modified query component as H ; . Rather than activated by the condition evaluation manager, the first run of g i is fired by the continual query activation manager (see Section 4.3 for further detail), which executes the modified query component H . There is no verification on trigger condition or stop condition. The first run of g i will return the whole answer of H , and cached the answer as the previous execution result of g i ; . The trigger condition q is activated in the sense that the update events of interest are identified, each associated with a conditional event; and the trigger activation variables (such as transaction coupling mode, dependency coupling mode, schedule coupling mode, and execution coupling mode) are initialized. The subsequent runs of g i will be fired whenever the trigger condition q is evaluated to be true, and the termination condition Stop is not expired. Each subsequent execution of g i proceeds as follows:</p><p>. Step 1: Update Events Identification.</p><p>This step is to identify the update events of interest from the trigger condition expression of g i . It is done by decomposing the trigger condition q into a list of q triplets, each triple consists of a basic update event, an atomic conditional event, and a connector to the next triple in the list. . Step 2: Update Events Detection.</p><p>This step is to decide when to detect the changes and what to detect for the given trigger condition, and which event detectors should be used. For each triple generated in the step 1, the atomic condition is evaluated when the basic update event is signaled. . Step 3: Logical Events (Condition) Evaluation.</p><p>This step is carried out by the condition evaluation manager, which first select a triplet from the list of q triplets generated in step 1, if the connector is an AND connector (or an OR connector), the AND logical event detector (the OR event detector) is invoked; if the connector is WHERE, the next triplet in the list will be used as an add-on condition to the basic update event component of this triplet; and so on. (For further detail, see Section 4.4). . Step 4: Differential Query Execution and Result Delivery.</p><p>If the condition evaluation in step 3 returns a true value, then the following predefined actions are scheduled to execute: 1. fire the next execution of the query component , 2. compute the difference between the current run of and the result of the previous run, 3. notify the user of the arrival of new updates of interest, and 4. deliver the differential result to the user.</p><p>A walkthrough example is provided in Section 4.4 to illustrate this process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Basic Coupling Modes</head><p>Continual queries in practice are often defined over multiple, autonomous and possibly heterogeneous data sources. The local update transactions are usually orthogonal to the continual queries specified over the same set (or a subset) of data. Furthermore, both trigger condition evaluation component and query component of a continual query are sideeffect free transactions. Due to the autonomy and distribution of data sources and the side-effect free nature of continual queries, it is not only important but also practical to allow a more flexible execution model.</p><p>A flexible execution model allows trigger condition evaluation and query execution to be broken off into different execution threads from the triggering transaction (the transaction that carried out the update operations). More concretely, it should be possible to allow the continual query evaluation to be separated from the (triggering) transaction that carried out the actual updates. This would allow the triggering transaction to commit earlier, and would potentially increase concurrency and reduce wasted work (rollback of incomplete transactions after a crash). The OpenCQ execution model for continual queries uses the notion of coupling modes to provide this flexibility.</p><p>In OpenCQ we support four basic coupling modes: transaction coupling mode: separate or same; execution coupling mode: asynchronous or synchronous; dependency coupling mode: causally dependent or causally independent; and schedule coupling mode: immediate or deferred. We view the execution model of each continual query to consist of the following four participating transactions:</p><p>1. the triggering transaction that carries out the update operations, 2. the update event detection transaction that detects if the data of interest has been updated, 3. the trigger condition evaluation transaction that evaluates the condition based on the newly updated data, 4. the transaction that carries out the subsequent execution of the query component and sends out the alerts or change notification messages.</p><p>Such arrangement provides more flexibility for utilizing multiple execution threads and parallel execution for continual query processing, which are critical techniques to the effectiveness and responsiveness of an event-driven distributed information delivery system.</p><p>In OpenCQ, it is possible that the coupling case for transaction types 1. and 2. may be different from the coupling case for transaction types 2. and 3. as well as the coupling case for transaction types 3. and 4.</p><p>We illustrate the meanings of each coupling mode using the coupling scenario for transaction types 2. and 3., which relates to the trigger condition part of the continual queries. For the trigger condition part of a continual query, the coupling mode specifies when the condition is to be evaluated relative to the triggering event (i.e., the update event being monitored):</p><p>. Transaction coupling mode: separate or same. The transaction coupling mode separate means that the condition evaluation triggered by the update event runs as a separate transaction with respect to the transaction that detects the update events of interest.</p><p>The transaction coupling mode same means that the condition evaluation triggered by the update event runs either as part of the transaction for detecting the update event in the case that the updates performed by the triggering transaction are local operations, or as part of the triggering transaction in the case that the updates are performed by the same user or application program who installed the continual query.</p><p>. Execution coupling mode: asynchronous or synchronous. The asynchronous coupling mode means that the update event detection transaction may run in parallel with the trigger condition evaluation transaction.</p><p>The synchronous coupling model means that if the trigger condition evaluation transaction is triggered by the transaction that detected the update events, then the trigger condition evaluation transaction is executed, and the execution control returns to the `triggering' transaction only after the condition evaluation transaction is committed. . Dependency Coupling Mode: casually dependent or casually independent. The casually dependent coupling mode means that the trigger condition evaluation transaction can be scheduled only after the `triggering' transaction that detected the update events has committed.</p><p>The casually independent coupling mode means that the scheduler is free to schedule the trigger condition evaluation transaction independently of the update event detection transaction when the update transaction is local. . Schedule Coupling Mode: immediate or deferred.</p><p>The schedule coupling mode immediate means that the trigger condition evaluation transaction is fired as soon as the triggering transaction commits. When the updates are carried out by a global update transaction issued by the same user or application program, the triggering transaction refers to this global update transaction. When the updates are carried out by local transactions or other remote and autonomous transactions, the triggering transaction refers to the update event detection transaction. By looking into the semantics implication of these coupling modes, we come to the following conclusion: The schedule coupling mode deferred must be used in conjunction with the same transaction coupling mode. This mode means that the CQ trigger condition evaluation is fired at the end of the update event detection transaction and before it commits. The same transaction coupling mode can be used only in conjunction with synchronous execution coupling. The deferred schedule mode is applicable only in conjunction with the same transaction coupling mode. However, the immediate schedule mode can be used in conjunction with both same and separate transaction couplings. Also both dependency couplings are applicable only to separate transaction coupling, immediate schedule coupling, and asynchronous execution coupling.</p><p>In a similar manner, we may illustrate the possible coupling cases for transaction types 1. and 2., the event detection part of the CQ, and for transaction types 3. and 4., the query scheduling part of the CQ. For the query scheduling part of a CQ, each coupling case specifies when the subsequent run of the query component is to be fired relative to the trigger condition evaluation transaction.</p><p>In OpenCQ we allow users to define their applicationspecific coupling modes for any of the three pairs of the participating transaction types. In the absence of userspecified coupling modes, the system default coupling case will be used. The default coupling modes between transaction 1. and transaction 2. are separate, asynchronous, causally independent. The default coupling modes between transaction 2. and transaction 3. are separate, synchronous, causally dependent, and so are the coupling modes between transaction 3. and transaction 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Continual Installation</head><p>Once a continual query g i , denoted by (Y q Y Stop), is defined, the user may install it directly to the OpenCQ continual query system. At the installation time, the Install module of the client manager takes the continual query and passes it to the OpenCQ continual query server. The server activates it using the activate command. The activation process consists of the following three main tasks:</p><p>1. Making this continual query a persistent object and generating a unique identifier (cqid) for it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Modifying the expression of the query component to</head><p>incorporating the trigger condition semantics. This task is accomplished by checking if the trigger condition component q and the query component are defined over the same set of data, i.e., DataSet() = DataSet( q ), where DataSet() is the set of instance variables used in and DataSet( q ) is the set of instance variables used in q X . If yes, merge the trigger condition into the WHERE clause of the query component , and denote the modified query expression as H , execute H instead of for the first run of g i , and cache the answer as the previous run result. . If not, identify if there is a common part of the data set shared by q and , i.e., checking if DataSet() DataSet( q ) T Y, if yes, merge the common portion of the q into the query component , and denote the modified query component by H ; otherwise, let H X ; then perform the following two actions: 1. execute H for the first run of g i and cache the answer as the previous run result of the query component; 2. fetch the other portion of q , i.e., DataSet( q ) À DataSet(), and cache the result for the subsequent trigger condition evaluation of the g i X 3. Initializing the execution attributes and data structures used for event detection and condition evaluation of this given CQ. This task includes decomposing the user-specified CQ trigger condition into a set of triplets, each triple is described by a basic update event, an atomic conditional event, and a connector; and setting up the initialization for the transaction coupling mode, the dependency coupling mode, the schedule coupling mode, and the execution coupling mode (recall Section 4.2).</p><p>The Activate command also returns a handle that will be used to deactivate this continual query when its termination condition is expired. Users can use the activate command to define the coupling modes according to application specific requirements. The syntax of the activate command is given below:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Activate &lt;cqid&gt; define communication protocol between &lt;trans1&gt; and &lt;trans2&gt; TransactionCoupling = same | separate ExecutionCoupling = synchronous | asynchronous DependencyCoupling = causally dependent | causally independent ScheduleCoupling = immediate | deferred</head><p>Once a continual query is activated, it runs continually following the communication protocol defined by the specific coupling case. The continual query is terminated when its Stop condition is evaluated to be true. To terminate an installed continual query, the command Deactivate &lt;cqid&gt; is invoked, which removes from the OpenCQ system catalog the corresponding continual query object identified by cqid, deactivates the related event detectors that are still active, and sends to the owner of this CQ a notification that this CQ is expired.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Event Detection</head><p>The event detection model is also called event observation model. It defines the mechanisms by which event occurrences and patterns of event occurrences are observed. There are two classes of event observation methods:</p><p>. Synchronous observation, in which the fact of an event occurrence is communicated explicitly to and in synchronization with the event observer. The database triggers built-in as components of commercial RDBMSs such as Oracle, Informix, and Sybase are examples of this kind. . Polling, in which the observer periodically checks for the occurrence of an event. The main task of event detection manager is to decide what to detect, when to detect, and how to detect. The decision is made based on the update events identified from the trigger condition specification and the types of the events to be detected. As discussed in Section 3.1, the trigger condition part of a continual query may be a primitive event, such as a temporal event: every two days or every first day of the month; an atomic conditional event: the stock price is greater than 100 (price &gt; 100); or a composite event, which is formed by an event composition expression of the form ªi I &lt;event_op&gt; i P º, where i I and i P are primitive or composite events. Typical examples of composite events are Stock.price(IBM) DECRBYPERC 5 OR Stock.price(Intel) DECRBYPERC 5 keyword CONTAINS `Java' OR keyword CONTAINS `JDBC' qty_on_hand(item) &gt; threshold(item) qty_on_hand(item) + qty_on_order &gt; threshold(item)</p><p>Each primitive event is detected by using a primitive event detector, which is either a basic temporal event detector or an atomic conditional event detector. An operation signal is defined for the event entity type, and is executed by the event detector components of the system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.1">Time-Based Event Detection</head><p>For time-based continual queries, a temporal event detector, or so-called time-based event detector, is used, which translates the time-based trigger condition into a clock event and installs the clock event script to the OpenCQ clock daemon. Whenever the clock event occurs, the trigger condition is signaled. Thus the subsequent execution of the query component is fired. A distinct feature of time-based continual queries is the use of user-controlled polling for update monitoring.</p><p>There are two key implementation techniques useful for time-based event detection: The first technique is to design a generic transformation program that takes the userdefined time condition and transforms it into a clock event expressed in the clock event scripting language; the clock manager (daemon) will then take over the control and trigger the update event detection according to the clock event installed; whenever the update event is signaled, the continual query manager will call the query evaluator to fire the subsequent run of the query component, and call the change notification manager to deliver the change notification message as well as the update result. The second technique is to develop a clock event manager which, on one hand, provides a scripting language to allow users to specify an arbitrary clock event and the action to be taken if the clock event occurs, and on the other hand, provides triggering capability so that it can fire the specified action (e.g., invoke a program) when a specific clock event is signaled.</p><p>The implementation of a clock manager is a systemspecific decision. One may either choose to design a clock manager specifically for this purpose, or reuse the clock manager provided by an operating system (such as Cron by Unix and Scheduler by NT). In the first prototype of the OpenCQ system, we make use of Cron as the clock manager. We are considering to write our own clock manager in the next prototype release to further enhance the efficiency of the system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.2">Content-Based Event Detection</head><p>In contrast to time-based continual queries, the contentbased continual queries use the system-controlled polling or synchronous approach for update monitoring. Thus, there are more than one strategies possible for implementation of the CQ trigger condition monitoring and event detection.</p><p>In order to carry out the content-based event detection, the first thing we need to do is to identify what update events are of interest to the given continual query. As mentioned in the continual query activation procedure (recall Section 4.3), for each installed continual query (, q , Stop), its trigger condition q is decomposed into a list of q triplets, each triple is described by a basic update event, an atomic conditional event, and a connector. For example, if the trigger condition is ªStock.price(IBM) DECRBYPERC 5 OR Stock.price(Intel) DECRBYPERC 5,º then the following triplets are generated: For the trigger condition: qty_on_hand(item) &gt; threshold(item), two triplets are generated. They are: (qty_on_hand, true, &gt;) and (threshold, true, END). Note that the connector WHERE means that the next triple is not an update event of interest but a constraint on the current update event. In this case, UPDATE on the stock price is the event we would like to monitor, and the condition Stock.company = IBM is simply a constraint, saying that we are only interested in monitoring UPDATE on the stock price of IBM but not other companies' stock prices. Now, we can determine what to detect based on the basic update events identified by the list of q triplets. For trigger condition ªkeyword CONTAINS `Java' OR keyword CONTAINS `JDBC',º if the condition field name keyword is mapped to Document.title and Document.abstract available at the corresponding data source(s), then the basic events of interests are INSERT and DELETE operations on Documents objects, and UPDATE operations on Document.title and Document.abstract.</p><formula xml:id="formula_2">(</formula><p>The next question is how to detect, namely we need to decide which mechanisms may be used to detect the changes made by the update operations, possibly from some transactions that are local to the data source; In OpenCQ, we distinguish between the data sources that have built-in trigger capability such as the data sources managed by trigger-enabled RDBMSs (incl. Oracle, DB2, Informix, and Sybase) and the data sources that have no built-in trigger capability such as most of the web sites and file systems.</p><p>. For the data sources with built-in trigger facility, the OpenCQ system may install the database triggers on the data columns or objects of interest. Whenever there is an update, the database transaction that carries out this update will send an update signal to the corresponding CQ wrapper. We provide the host-specific trigger installation program (such as Oracle trigger installation program) to install triggers on those data objects and data columns that are accessible to the OpenCQ continual query system. . For the data sources with no built-in trigger facility, we use system-controlled polling with systemdefined interval (such as every 30 seconds). We detect the events of interest by comparing the two snapshots generated from two different polling time points, find what has been inserted, or modified, or removed. The richness of the update operations to be used in the difference computation varies among different Diff programs <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b41">[42]</ref>. The current implementation of the OpenCQ uses the Xdiff program which compares two XML snapshots. The detail of the Xdiff design is beyond the scope of this paper. Important to note is that the capabilities of database trigger supported in commercial DBMSs today are not sufficient, particularly in those cases where remote installation of customized database triggers is required. In these situations, a system-controlled polling will be used in conjunction with the database triggers. Our experience tells that not all the RDBMSs allow database triggers to be installed by a remote program through JDBC. In the first prototype of OpenCQ, we implement the content-based event detection using the system-controlled periodic polling for those database sources that do not provide built-in trigger facility in their APIs for remote access (e.g., JDBC or Oraperl for Oracle database sources). Now, let us walk through the event detection process. Given a continual query g i defined by (Y q Y Stop). Suppose that the trigger condition q has been transformed into a list of q triplets, denoted by TripleSet(cqid, q ). To simplify the steps (that) we need to walk through, let us assume that the connectors we use in this walkthrough are the most commonly used ones, namely WHERE, AND, OR, END. For each triplet in TripletSet(cqid, q ), we form a event detection query, denoted by detet , which is to be submitted to the relevant data sources to detect if an update is occurred.</p><p>. For a triple of the form XeY Xe5vY AND or XeY Xe5vY OR or XeY Xe5vY END, where denotes the object class, eY f are instance variables of , and 5 is the comparison operator, let prev denote the value of instance variable e contained in the result of previous execution of the given CQ. Thus, the corresponding event detection query detet is expressed as SELECT A FROM T where A T prev.</p><p>. For a triplet of the form XeY Xe5wY WHERE, we fetch the next triple, say XfY Xf5wY END from the remaining list of TripletSet(cqid, q ). Thus, the event detection query detet is expressed as SELECT T.A, S.B FROM T, S WHERE S.B 5 w AND T.A T prev.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Condition Evaluation</head><p>In principle, one may want to detect all the update events of interest before starting the trigger condition evaluation process. In practice, the CQ trigger condition evaluation is carried out in conjunction with the process of basic update event detection, to guarantee the efficiency of the condition evaluation. For example, if a condition is of the form Xe5v e Xf5v f , and if the event detection query over the triplet XeY XeX5v e Y AND returns empty answer, then we can conclude that the trigger condition is false without looking into the second triplet XfY Xf5v f Y END. Now, let us walk through the condition evaluation process for a continual query g i defined by (Y q Y Stop). Let TripleSet(cqid, q ) denotes the list of q triplets generated by the CQ activation process. Simiar to the discussion on event detection, we simplify the steps we need to walk through by assuming that the connectors used in this walkthrough are WHERE, AND, OR, END. The condition evaluation process of g i proceeds as follows:</p><p>. Step 1: It starts by selecting a triple in Triple-Set(cqid, q ), and then check the connector type of this triple: . Step 2: If it is an END connector, then this contentbased trigger condition is evaluated to be true, and the subsequent query execution is fired. . Step 3: If it is an WHERE connector, let us denote the selected triple as XeY Xe5vY WHERE, and the next triplet is fetched from the remaining list of Triple-Set(cqid, q ), denoted by XfY Xf5wY AND, then the update event detection query detet is expressed as SELECT T.A, S.B FROM T, S WHERE S.B 5 w AND T.A T prev. If detet returns a nonempty answer, it means the update event has occurred; go to step 6. If detet returns an empty answer, we can conclude that the corresponding trigger condition is false. . Step 4: If it is an AND connector, let us denote the selected triple as XeY Xe5vY AND, then the update event detection query detet is expressed by SELECT T.A FROM T where T.A T prev. If the answer to this query detet is empty, then the condition evaluation is false. Otherwise (i.e., if the answer is nonempty), go to step 6. . Step 5: If it is an OR connector, let us denote the selected triple as XeY Xe5vY OR, then the update event detection query detet is the same as the case for an AND connector, i.e., SELECT T.A FROM T where T.A T prev. However, unlike the AND connector case, if the answer to this query detet is nonempty, then we conclude that the condition evaluation is true. Otherwise (i.e., the answer is empty), we need to go to step 6.</p><p>. Step 6: Select another triplet from the remaining list of triplets in TripleSet(cqid, q ), and go back to step 2.</p><p>Obviously, the richer set of event composition operators is used, the more sophisticated the event detection process will be. A complete description of event composition operators and their formal semantics is beyond the scope of this paper. (Refer to <ref type="bibr" target="#b23">[24]</ref> for further details.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Issues on Efficient Condition Evaluation</head><p>Users and application programs may define as many continual queries as they wish. Once these continual queries are installed, they run continually as long-running sideeffect free transactions with checkpoints. (Each time the trigger condition is evaluated to be true and the query is fired is referred to as a checkpoint.) Despite all the query components, each from one installed continual query, the set of all trigger conditions forms a potentially large set of predefined queries (i.e., event detection queries) that have to be evaluated efficiently. Furthermore, the trigger condition component of a continual query may be more sophisticated than the query component when the update monitoring threshold is defined over several different object classes and uses special operators (such as INCRBYPERC) that are not supported by the data sources upon which the condition is evaluated. Several techniques have been identified as being useful for performance optimization of the condition evaluation:</p><p>. The first technique is Multiple Condition Optimization and also called multiple query optimization in the literature <ref type="bibr" target="#b35">[36]</ref>. This technique represents conditions (and the events that signal the condition evaluation) by condition evaluation graphs, which resemble the query graphs commonly used in query processing.</p><p>The leave nodes of the graph are triples of the form Y Y À, where corresponds to a set of entity instances before the update, corresponds to the set of instances inserted into by the update, and À the set of instances deleted from by the update. The internal nodes correspond to operators of some convenient algebra into which the query language can be compiled (e.g., select, project, join). The key idea of multiple condition evaluation consists of identifying common subgraphs, and evaluating these subconditions once for a whole set of queries, instead of once for every query <ref type="bibr" target="#b31">[32]</ref>, <ref type="bibr" target="#b35">[36]</ref>. For a continual query system, the common subconditions may be detected at the algebraic level due to the distribution and autonomy of data sources, whereas in a centralize data base system the common subconditions may also be detected at the lower level (e.g., use common access paths). The multiple query evaluation problem is complicated by the need to ensure that the conditions will have to be evaluated simultaneously; e.g., they are triggered by the same update event.</p><p>. The second technique is Incremental Condition Evaluation. A main task of continual query evaluation is to determine whether the answer to a previous execution of the query component (say at time t) has changed as a result of some update event to some of the query's operands at time t H . Let be a query defined over an entity set , and ensY t be the answer to the query at time t. Let H minus À union ). A brute force method for computing the change in Y t would be to compute ensY t H H , and then the symmetric difference of ensY t and ensY t H . Incremental evaluation computes this symmetric difference directly from Y À , and . Sometimes is also needed when involves joins <ref type="bibr" target="#b24">[25]</ref>. Many algorithms have been proposed in view materialization research for incremental maintenance of materialized views (see Section 7 for reference), and may be directly deployable for incremental condition evaluation in the continual query systems.</p><p>An extreme case of incremental condition evaluation is the situation where it may be possible to infer that there is no change in a query's answer with respect to an update event without evaluating the query. Put differently, we can ignore an update event i at t H with respect to the execution of query at t, if we can tell that the symmetric difference between ensY t and ensY t H is empty by looking only at the update event i and query expression . A trivial example is the update event that modifies a data object that is irrelevant to the query . A less trivial example is an update that modifies the Intel stock price to a higher value; clearly, this update event is ignoble with respect to the trigger condition stock.price(Intel) DECRBYPERC 5.</p><p>Also, more opportunities for optimization may arise out of the interplay between the event detection, the condition evaluation, and the subsequent execution of the query component. Generally speaking, more work is needed to develop heuristics and cost models that the condition monitor can use to explore the trade-offs and benefits of these tactics and algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">SYSTEM ARCHITECTURE</head><p>The OpenCQ continual query system deals with a new class of objects: continual queries. The architecture for such a system adds functions to the data/object manager and possibly transaction manager, and introduces some new components: a continual query manager, a condition evaluator and a variety of event detectors for the different types of events to be detected (recall Section 4). The data/object manager must now support the definition, storage, and retrieval of continual queries. The transaction manager is expected to implement the execution model, including the support for nested transactions, various coupling modes, and causality constraints.</p><p>OpenCQ proposes a three-tier architecture: client, server, and wrapper/adapter. This architecture is motivated by the need for providing efficient support to composite event detection and complex condition monitoring of installed continual queries, and the need for sharing information among structured, semistructured, and unstructured remote data sources. A sketch of the OpenCQ system architecture is given in Fig. <ref type="figure" target="#fig_2">1</ref>.</p><p>The client tier currently has four components: 1. the form manager that provides the CQ clients with fill-in forms to register and install their continual queries; 2. the registration manager which allows clients to register the OpenCQ system with valid user id and password, and return the clients a confirmation on their registration; 3. the client and system administration services which provide utilities for browsing or updating installed continual queries, for testing time-based and contentbased CQ triggers, and for tracing the performance of update monitoring of source data; 4. the Client manager which coordinates different client requests and invokes different external devices. For instance, once a continual query request is issued, the client manager will parse the form request and construct the three key components of a continual query (, q , Stop), before storing it in the OpenCQ system repository. Although not a direct part of the OpenCQ development, one could imagine valueadded update monitoring services such as posting a continual query request in natural language through typing, voice or hand-writing or multimodals combined.</p><p>Recall the example given earlier: ªNotify me whenever IBM stock price rises by 5 percent.º By hooking up the CQ client with an English language text recognizer, or hand-writing recognizer, or voice recognizer, we can parse this request and automatically generate the query, the CQ trigger, and the Stop condition for this request. The results can be returned to the user also by multiple modes, such as by email, fax, phone, bulletin posting, or displaying signals on users' desktop screens.</p><p>The second tier is the OpenCQ server which consists of three main components: a continual query (CQ) manager with event-driven delivery, a trigger condition evaluation manager, and the event detectors (including time-based event detector using clock event manager and contentbased event detector). The CQ manager is responsible to coordinate with the trigger condition evaluator and event detectors to monitor updates of interest, and coordinate with OpenCQ wrappers and adapters to track the new updates to the source data. The trigger condition evaluation manager is in charge of evaluating the trigger condition for each installed continual query whenever the update events of interest are detected and signaled by the event detectors. We build the time-based event detector on top of the Cron clock event manager in the first prototype of OpenCQ. The content-based event detector is built based on the primitive event detector and a set of specialized event detectors, each designed for a particular event composition operator.</p><p>In addition, the OpenCQ server uses the query evaluator, an extension of the DIOM query scheduler, for execution of the query whenever the trigger condition q is evaluated to be true. It also provides a guard for the Stop condition to guarantee the semantic consistency of the continual query (, q , Stop). The key components of this query evaluator include: the query router <ref type="bibr" target="#b22">[23]</ref>, <ref type="bibr" target="#b20">[21]</ref>, the query planner <ref type="bibr" target="#b19">[20]</ref>, <ref type="bibr" target="#b21">[22]</ref> and the query result assembler. The query router is a key technology that enables the OpenCQ continual query system to scale up in order to handle thousands of different information sources. When the user poses a query, the query router examines the query and determines which sites contain information that is relevant to the user's request. Consequently, instead of contacting all the available data sources, the CQ evaluator only contacts the selected sites that can actually contribute to the query.</p><p>The third tier is the CQ wrappers/adapters tier. The CQ manager, on behalf of the event detectors and the query evaluator, talks to each information source using a CQ wrapper. A wrapper is needed for each data source because individual data sources may have different ways of accessing data and different formats for representing query results. The expected functionality of an ordinary wrapper is to translate the query into the format understood by the remote site. As the result comes back, the wrapper packages (translates) the response from the corresponding data source site into the OpenCQ object format used by the CQ system. In addition to the common data wrapping capability, a CQ wrapper installs the source-specific event detector (a database trigger detector for RDBMS sources, a system-controlled polling event detector for data sources with no built-in triggers on update operations), which, on behalf of the OpenCQ server, continually watches the update events at the corresponding data source site(s), and signals the CQ manager whenever an update event of interest occurs.</p><p>Depending on the need of applications, the client tier, the wrapper tier, and the server tier, including the continual query manager, the trigger condition evaluation manager, and the variety of event detectors, as well as the query evaluator, could all be located on a single host machine, or distributed in different combinations among several computers connected through local or wide area networks. OpenCQ uses the most flexible client-server arrangement which is customizable with respect to the particular system requirement of the applications. For example, in the first version of the prototype, we have the client tier running remotely, and the OpenCQ server running on a relatively powerful host machine, where we also maintain a library of all the current CQ wrappers including their source capability profiles.</p><p>A detailed description of OpenCQ's components and interfaces is beyond the scope of this paper. However, we below walk through each of the main components of OpenCQ by briefly tracing how the continual query firing process proceeds:</p><p>. Step 1: An update event occurs and is signaled by an event detector. . Step 2: The CQ manager determines which continual queries are fired by the event. For each of these activated continual queries, the CQ manager calls on the corresponding wrapper managers to obtain the data that must be passed to condition evaluation manager, and possibly the query evaluator. . Step 3: If any of the continual queries that are fired by the event have the immediate coupling mode for condition evaluation, then the CQ manager calls on the transaction manager to create a subtransaction for condition evaluation, and then passes the event signal to the trigger condition evaluator. . Step 4: The condition evaluator determines which continual queries are to be fired and returns a list of cqid s to the CQ manager. After condition evaluation is completed, the CQ manager calls the transaction manager to terminate the subtransaction. . step 5: The CQ manager determines which of the continual queries to be fired have the immediate coupling mode for their query execution. The CQ manager calls on the transaction manager to create concurrent subtransactions for each of these continual queries. Then, the CQ manager calls on the wrapper manager(s) to execute the query in the corresponding subtransaction(s).</p><p>The online demo of the OpenCQ system can be accessed using any JavaScript-enabled Web browser through the following URL http://www.cse.ogi.edu/DISC/CQ/demo. Fig. <ref type="figure" target="#fig_3">2</ref> shows the screen shot of an example continual query which requires alternative transportation routes whenever the weather condition between Fort Stewart, Georgia, and the port of Savannah, Georgia, becomes severe (e.g., temperature below 32 F, Wind speed is higher than 15 knots, visibility is less than 0.5 miles, or pressure changes more than 20 hPa in 20 minutes). This continual query involves two types of data sources, one is the transportation data sources (e.g., database sources in this example) and another is the weather watch sources (e.g., noaa.org Web site in this example). Fig. <ref type="figure" target="#fig_1">3</ref> shows the execution trace of the installation of this continual query. Due to the space restriction, readers who are interested in more detailed description of the first prototype implementation of OpenCQ may refer to <ref type="bibr" target="#b25">[26]</ref>, <ref type="bibr" target="#b36">[37]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">PERFORMANCE EVALUATION ISSUES</head><p>We have presented a design and selection of alternative architectures and algorithms for a distributed event-driven information delivery system that supports continual queries. Research on event-driven continual query systems must be accompanied by a careful performance evaluation effort. For the OpenCQ project, such effort is under way. The goal of the first effort is rather modest, that is to verify that a continual query system can indeed outperform a pull-based passive data delivery system for applications that require time-constrained update monitoring. Toward this objective, a simple condition monitor and a small situation monitoring application were implemented using C, Perl, JDK1.1, JDBC, and Oracle 8.0. Three types of data sources are used in this prototype: 1. an Oracle database which is remotely accessible through SQL, OraPERL, and SQLNet; and a Microsoft SQL server database which is remotely accessible through JDBC and SQL; 2. a collection of semistructured Unix files which are accessible through Java Applets and Java Servelets; 3. a World Wide Web HTML source which is accessible through our html wrapper and filter utility. We are planning to do a simple experiment, making a comparison between user polling and continually monitoring using continual queries. We expect (with confidence) that this simple experiment will verify the hypothesis that eventdriven data delivery system can outperform (ad hoc) polling over a pull-based passive data delivery system when the number of objects being updates and monitored is proportionally large.</p><p>We are also interested in planning careful controlled experiments for comparing the performance of alternative condition evaluation tactics, as well as effort on studying architectural alternatives for the distributed event-driven continual query systems and their impact on performance, and possibly building a performance testbed for studying the extent to which the final design of the OpenCQ continual query system is able to meet or exceed the processing requirements of a distributed time-constrained update monitoring and event-driven information delivery system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">RELATED WORK</head><p>The concept of continual queries was motivated and evolved by the increasing demand on event-driven information delivery. It was also inspired by the work on continuous queries by Terry et al. <ref type="bibr" target="#b37">[38]</ref> at the early stage of the development. Comparing with the proposal in Terry et al. <ref type="bibr" target="#b37">[38]</ref>, there are a number of functionality differences. First, their proposal made several assumptions that seriously restricted the applicability of their technique to the Internet. Perhaps the most significant assumption is the limitation of database updates to append-only, disallowing deletions and modifications. Since this assumption is used in their query transformation algorithm, it has been difficult to relax it <ref type="bibr" target="#b1">[2]</ref>, when following their definition of continuous queries. Second, the specification model for update monitoring is purely time-based. Also there is no clean separation of query and trigger condition in the specification.</p><p>Furthermore, there has been considerable research done in the monitoring of information changes in databases and Web-based search systems. Powerful database techniques such as active databases, materialized Views, and database triggers have been developed. The design of OpenCQ continual query system is also inspired by the research in these fields. We below briefly review each of these fields. The following discussion should not be seen as a critique of these techniques. Rather, these techniques have been proposed primarily for ªdata-centricº environments, where data is well organized and controlled. When applied to an open information universe such as the Internet, these assumptions no longer hold (see <ref type="bibr" target="#b18">[19]</ref> for a summary of desired system properties in the Internet), and some of the techniques do not easily extend to scale up to the open distributed interoperable environment.</p><p>. Active Database: Most of active database systems <ref type="bibr" target="#b39">[40]</ref> provide facilities <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b27">[28]</ref>, <ref type="bibr" target="#b33">[34]</ref> that allow users to specify, in the form of rules, actions to be performed following changes of database state. Despite their conceptual generality, rules have been so far supported in a fairly restrictive form in practical systems, for example, by built-in triggers in relational database management systems such as Oracle, Sybase, and Informix (see a further discussion On Commercial database trigger below). Active queries, introduced in Alert <ref type="bibr" target="#b33">[34]</ref>, is yet another form of ECA rules. Active queries are more sophisticated than database triggers, since they can be defined on multiple tables, on views, and can be nested within other active queries. However, active queries heavily rely on the use of active tables as system built-in capability and a number of concrete extensions to a particular systemÐIBM Starburst DBMS <ref type="bibr" target="#b11">[12]</ref>.</p><p>. Materialized View: Materialized views store a snapshot of selected database state. When a database is updated, the materialized view must be refreshed to reflect the updates. A naive solution is to rematerialize the view from the base data. In contrast, incremental update algorithms are believed to carry lower execution cost if changes to the database are moderate <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b16">[17]</ref>. Three approaches have been described previously.</p><p>The first approach refreshes the view immediately after each update to the base table <ref type="bibr" target="#b2">[3]</ref>. The second defers the refresh until a query is issued against the view <ref type="bibr" target="#b32">[33]</ref>. The third refreshes the view periodically <ref type="bibr" target="#b16">[17]</ref>. The main trade-off in choosing among these approaches is the staleness of the view data vs. the cost of updating it. Most of the algorithms in the literature <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b10">[11]</ref> work in a centralized database environment, in which the materialized view and its base tables co-reside. The study on distributed materialized view management has been primarily focused on determining the optimal refresh sources and timing for multiple views defined on the same base data <ref type="bibr" target="#b34">[35]</ref>. Other works on distributed environments include quasi-copies for replication <ref type="bibr" target="#b0">[1]</ref> and update anomalies in data warehouses <ref type="bibr" target="#b42">[43]</ref>.</p><p>. An interesting feature of gQ is to allow users to subscribe to the change notification system through a query subscription service and then to be notified of changes whenever changes of certain kind occurs, or by weekly or daily report, or by explicit request. A key feature that distinguishes the continual query system OpenCQ from these Web-based change monitoring systems is its fine-grained support for content-sensitive, event-driven information delivery and its unified framework that combines pull and push through the support of both polling and filtering based on the user or application requests. For example, the OpenCQ system, to our knowledge, is the only system that is able to install complex content-based continual queries such as, ªNotify me whenever the stock prices of IBM and of AT&amp;T both drop more than 5 percent.º</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSION</head><p>We have introduced continual queries (CQ), described a detailed design of OpenCQÐa distributed event-driven information delivery system that supports continual queries, and outlined a prototype implementation of OpenCQ. In summary, CQ strikes a conceptual balance between event-condition-action (ECA) models on one end of spectrum and CORBA event services on the other. ECA models are very powerful, but difficult to implement in large-scale heterogeneous systems such as the Internet. In contrast, CORBA event services are relatively simple to implement but miss application semantics. CQs focus on information update monitoring with notification (instead of generic actions as in ECA) but provide a rich event model including both time events and content triggers.</p><p>OpenCQ is a distributed event-driven information delivery system that implements CQs in a three-tier architecture (client, server, and wrapper). The key components of OpenCQ server are: a CQ manager, a trigger condition evaluator, and a variety of event detectors. The CQ manager is responsible for coordination tasks and communications between the client/server tiers and server/wrapper tiers. The condition evaluator and event detectors are responsible for monitoring updates according to specified update thresholds of interest and the time constraints. We have developed various continual query indexing techniques <ref type="bibr" target="#b26">[27]</ref> to improve the performance and scalability of the continual query system. An initial experiment is being conducted in the Conquer prototype over a selection of Web data sources. The client tier manages the repository of CQ information and GUIs. The wrapper tier handles the heterogeneous data sources for the server. This three-tier architecture decomposes the Internet data flow into modular components, enabling the OpenCQ system to be adaptable and scalable in the presence of constant changes in the information space. We have implemented the first prototype of OpenCQ to demonstrate the feasibility of the architecture. It builds on top of the distributed interoperable information mediation system DIOM <ref type="bibr" target="#b21">[22]</ref>, <ref type="bibr" target="#b19">[20]</ref> powered by the extensible semiautomatic wrapper generation toolkit XWrap <ref type="bibr" target="#b17">[18]</ref>.</p><p>Our work on the continual query system for update monitoring continues. Several issues need to be further explored, including experimentation to evaluate the performance of alternative architectures and algorithms, recovery of CQs in the presence of failures at either CQ server or CQ client, performance improvement by incorporating research results and techniques for incremental query evaluation and multiple query optimization into the CQ event detection and condition evaluation process.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>conditional_event ::= &lt;atomic_conditional_event&gt; &lt;logic_op&gt; &lt;conditional_event&gt; basic_update_event ::= &lt;db_operations&gt; | &lt;external_signals&gt; logic_op ::= &lt;conjunction&gt; | &lt;disjunction&gt; | &lt;not&gt; comparison_op ::= &lt;string_op&gt; | &lt;algorithmic_op&gt; | &lt;built_in_op&gt; | &lt;user_defined_op&gt; temporal_event ::= &lt;absolute_time&gt; | &lt;regular_interval&gt; | &lt;irregular_interval&gt; db_operations ::= UPDATE | INSERT | DELETE event_op ::= &lt;logic_op&gt; | &lt;user_defined_op&gt; | &lt;system_built_in_op&gt;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Example 3 .</head><label>3</label><figDesc>Given the trigger condition ªStock.price(IBM) DECRBYPERC 5 OR stock.price(Intel) DECRBYPERC 5,º the basic events of interests are UPDATE operations on Stock.price and Stock.company, as well as INSERT and DELETE operations on the object class Stock.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Architecture of an event-driven continual query system.</figDesc><graphic coords="13,26.19,48.17,516.19,386.31" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Continual query installation: an example.</figDesc><graphic coords="15,26.19,48.17,516.19,504.17" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. The execution trace of a continual query installation</figDesc><graphic coords="16,26.19,48.17,516.19,504.17" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>Commercial database triggers. Conceptually a database (built-in) trigger is an event±condition± action (ECA) rule in a restrictive form. Commercial DBMSs have been introducing support for database triggers at various levels, mainly due to the customers' need for better support for integrity constraints. In the SQL standard, checking of constraints, such as price &gt; 0 or referential integrity constraints, is triggered by the DBMS. Users can specify whether constraints are to be checked at the end of each SQL statement. However, support for triggers in SQL standard is limited. The trigger events can only be built-in SQL operations (update, insert, delete) on a single base table. The triggers can be specified only on a single base table. Triggers over views are not allowed. Database triggers can only be part of the triggering transactions and triggers can not be nested. For instance, Unlike continual queries, Sybase allows only one trigger to be associated with an operation on a table. The action part of the trigger is limited to a sequence of SQL statements. Further, triggering is restricted to one level where triggered actions themselves do not cause triggers to be fired. . Web-Based Tools and Systems. In addition to the Continual Queries project, there are several systems developed towards monitoring source data changes. One type of systems is the extension of Web search engines or search software by monitoring the URL changes and notifying the users when the URLs of the data sources of interest have changed. A representative system is the URL-Minder (http:// www.netmind.com/). Another interesting type of change notification tools includes the news filtering services that harness news items and news groups (such as SIFT [41] and Pointcast), and the domainspecific change monitoring services, each targets at a specific domain of interest. Examples of the domainspecific change monitoring service include FedEx Opportunity which watches the United States funding news on multiple Web sites and emails the users the list of new funding announcements whenever the funding news of specific interests arrive, Amazon.com which provides notification service for new books of interest, and E*Trade.com which sends out alert messages whenever the stock prices of interest reaches specified thresholds. The third type of projects is the content change detection over HTML pages, such as the gQ [7] project at Stanford.</figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>The authors would like to acknowledge John Biggs and Wei Han for implementing the CQ wrapper for html data sources and the CQ Weather Watch server, and Dave Buttler for implementing the CQ wrappers to bibliography files and the CQ Bibliography server, on top of the CQ event detectors and condition evaluation manager. This research is partially supported by DARPA Contract No. MDA972-97-1-0016, and grants from Intel and Boeing.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Ling Liu received her PhD degree in 1993 from Tilburg University. In August 1999, she is joining the College of Computing at the Georgia Institute of Technology, after having served as an associate professor at the Oregon Graduate Institute of Science and Technology (OGI). At OGI, she was the co-PI and technical lead of the Continual Queries project described in this paper. Her current research interests are in Internet-scale distributed information systems, multidatabase systems, multimedia, object-oriented systems, data mining and data warehousing, and software evolution. In addition to the CQ project, she also led the Distributed Interoperable Object Model (DIOM) project and its applications to largescale interoperable database systems, and the transactional support for complex workflow activities (TAM) project. Before joining OGI in 1997, she was an assistant professor in the Department of Computing Science of the University of Alberta in Canada. She has published more than 60 papers in international journals and conference proceedings; has served on more than 15 program committees; and is currently an associate editor of ACM SIGMOD Record. She is a member of the IEEE and the IEEE Computer Society.</p><p>Calton Pu received his PhD degree from the University of Washington in 1986. He is joining the College of Computing at the Georgia Institute of Technology in August 1999, after having served as a professor at the Oregon Graduate Institute of Science and Technology. At OGI, he had two research focuses and a number of collaborations. First, he worked on next-generation operating system kernels to achieve high performance, adaptiveness, security, and modularity, using program specialization, software feedback, and domain-specific languages. This area included projects such as Synthetix, Immunix, Microlanguages, and Microfeedback, applied to distributed multimedia and system surviva- </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">R</forename><surname>Alonso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Barbara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Garcia-Molina</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ªData Caching Issues in an Information Retrieval System,º ACM Trans. Database Systems</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="359" to="384" />
			<date type="published" when="1990-09">Sept. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><surname>Barbara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Alonso</surname></persName>
		</author>
		<title level="m">ªProcessing Continuous Queries in General Environments,º technical report</title>
		<meeting><address><addrLine>Princeton, N.J.</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993-06">June 1993</date>
		</imprint>
		<respStmt>
			<orgName>Matsushita Information Technology Laboratory</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Blakeley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Larson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Tompa</surname></persName>
		</author>
		<title level="m">ªEfficiently Updating Materialized Viewsº Proc. ACM SIGMOD Int&apos;l Conf. Management of Data</title>
		<meeting><address><addrLine>Washington, D.C.</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986-05">May 1986</date>
			<biblScope unit="page" from="61" to="71" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">ªBuilding an Integrated Active OODBMSs: Requirements, Architecture, and Design Decisions</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Buchmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zimmermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Blakeley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wells</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 11th Int&apos;l Conf. Data Eng</title>
		<meeting>11th Int&apos;l Conf. Data Eng</meeting>
		<imprint>
			<date type="published" when="1995-02">Feb. 1995</date>
			<biblScope unit="page" from="117" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">ªArchitectures and Monitoring Techniques for Active Databases: An Evaluation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chakravarthy</surname></persName>
		</author>
		<idno>TR-92-041</idno>
		<imprint>
			<date type="published" when="1992">1992</date>
			<pubPlace>Gainesville, Fla</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Univ. of Florida</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Chakravarthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Krishnaprasad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Anwar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kim</surname></persName>
		</author>
		<title level="m">ªComposite Events for Active Databases: Semantics, Contexs, and Detection,º Proc. 20th Int&apos;l Conf. Very Large Data Bases</title>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">ªManaging and Querying Changes in Semi-Structured Data</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chawathe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. ACM SIGMOD Conf</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Chawathe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rajaraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Garcia-Molina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
		<title level="m">ªChange Detection in Hierarchically Structured Information,º Proc. ACM SIGMOD Conf</title>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">INA Notification Service Description</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">I N A</forename><surname>Consortium</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996-07">July 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<author>
			<persName><forename type="first">C</forename><surname>Gerety</surname></persName>
		</author>
		<author>
			<persName><surname>Softbench</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">A New Generation of Software Development Tools</title>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page" from="48" to="59" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Mumick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Subrahmanian</surname></persName>
		</author>
		<title level="m">ªMaintaining Views Incrementally,º Proc. ACM SIGMOD Int&apos;l Conf. Management of Data</title>
		<meeting><address><addrLine>Washington, D.C.</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993-05">May 1993</date>
			<biblScope unit="page" from="157" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lohman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mcpherson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wilms</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lapis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Lindsay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Pirahesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Carey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shekita</surname></persName>
		</author>
		<title level="m">ªStarburst Mid-Flight: As the Dust Clears,º IEEE Trans. Knowledge and Data Eng</title>
		<imprint>
			<date type="published" when="1990-03">Mar. 1990</date>
			<biblScope unit="page" from="377" to="388" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Haertel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Hayes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tamllman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Tower</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Eggert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Davison</surname></persName>
		</author>
		<title level="m">ªThe GNU Diff Program,º Texinfo system documentation available</title>
		<imprint/>
	</monogr>
	<note>by anonymous ftp at prep.ai.mit.edu</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">ªA Performance Analysis of View Materialization Strategies</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">N</forename><surname>Hanson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD Int&apos;l Conf. Management of Data</title>
		<meeting>ACM SIGMOD Int&apos;l Conf. Management of Data<address><addrLine>San Francisco, Calif</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987-05">May 1987</date>
			<biblScope unit="page" from="440" to="453" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Kiffer</surname></persName>
		</author>
		<title level="m">ªEdiffÐA Comprehensive Interface to Diff for Emacs 19</title>
		<imprint/>
	</monogr>
	<note>º available by anonymous ftp at cs.sunnysb.edu</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">ªYeast: A General Purpose Event</title>
		<author>
			<persName><forename type="first">B</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Rosenblum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Action Systemº IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="845" to="857" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName><forename type="first">B</forename><surname>Lindsay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Mohan</surname></persName>
		</author>
		<title level="m">ªA Snapshot Differential Refresh Algorithm,º Proc. ACM SIGMOD Int&apos;l Conf. Management of Data</title>
		<meeting><address><addrLine>Washington, D.C.</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986-05">May 1986</date>
			<biblScope unit="volume">53</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pu</surname></persName>
		</author>
		<title level="m">ªXwrap: An XML-Based Wrapper Generation Toolkit,º technical report</title>
		<imprint>
			<date type="published" when="1998-10">Oct. 1998</date>
		</imprint>
		<respStmt>
			<orgName>OGI/CSE</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pu</surname></persName>
		</author>
		<title level="m">ªThe Distributed Interoperable Object Model and Its Application to Large-Scale Interoperable Database Systems,º Proc. ACM Int&apos;l Conf. Information and Knowledge Management (CIKM &apos;95)</title>
		<meeting><address><addrLine>Baltimore, Md</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995-11">Nov. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">ªAn Adaptive Object-Oriented Approach to Integration and Access of Heterogeneous Information Sources,º Distributed and Parallel Databases: An Int</title>
		<author>
			<persName><forename type="first">L</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">l J</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<author>
			<persName><forename type="first">L</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ªDynamic Query Processing in Diom</title>
		<imprint>
			<date type="published" when="1997-09">Sept. 1997</date>
			<biblScope unit="volume">20</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">ªA Dynamic Query Scheduling Framework for Distributed and Evolving Information Systems</title>
		<author>
			<persName><forename type="first">L</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE 16th Int&apos;l Conf. Distributed Computing Systems</title>
		<meeting>IEEE 16th Int&apos;l Conf. Distributed Computing Systems<address><addrLine>Baltimore, Md</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-05">May 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Pu ªA Metadata Approach to Improving Query Responsiveness</title>
		<author>
			<persName><forename type="first">L</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Second IEEE Metadata Conf</title>
		<meeting>Second IEEE Metadata Conf<address><addrLine>Maryland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-04">Apr. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pu</surname></persName>
		</author>
		<title level="m">ªComplex Event Specification and Event Detection for Continual Queries,º technical report, OGI/CSE</title>
		<meeting><address><addrLine>Portland, Ore</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998-03">Mar. 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Barga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Zhou</surname></persName>
		</author>
		<title level="m">ªDifferential Evaluation of Continual Queries,º Proc. IEEE 16th Int&apos;l Conf. Distributed Computing Systems</title>
		<meeting><address><addrLine>Hong Kong</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-05">May 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Biggs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Buttler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Benninghoff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">H</forename><surname>Yu</surname></persName>
		</author>
		<title level="m">ªCQ: A Personalized Update Monitoring Toolkit,º Proc. ACM SIGMOD Conf</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">ªConquer: A Continual Query System for Update Monitoring in the WWW,º Int</title>
		<author>
			<persName><forename type="first">L</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">l J. Computer Systems, Science, and Eng., special issue on WWW semantics</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><surname>Mccarthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Dayal</surname></persName>
		</author>
		<title level="m">ªThe Architecture of an Active Database Management System,º Proc. ACM SIGMOD Int&apos;l Conf. Management of Data</title>
		<imprint>
			<date type="published" when="1989-05">May 1989</date>
			<biblScope unit="page" from="215" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Common Object Request Broker: Architecture and Specification,º Object Management Group, Object Request Broker Task Force</title>
		<author>
			<persName><forename type="first">ªthe</forename><surname>Omg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">Revision 2.0, 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Pu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Autrey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Consel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Cowan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Inouye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Kethana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Walpole</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Zhang</surname></persName>
		</author>
		<title level="m">ªOptimistic Incremental Specialization: Streamlining a Commercial Operating System,º Proc. 15th Symp. Operating Systems Principles</title>
		<meeting><address><addrLine>Colorado</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995-12">Dec. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Reiss</surname></persName>
		</author>
		<title level="m">ªConnecting Tools Using Message Passing in the Field Environment,º IEEE Software</title>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="57" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">ªAnatomy of a Modular Multiple Query Optimizer</title>
		<author>
			<persName><forename type="first">A</forename><surname>Rosenthal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Chakarvarthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Very Large Data Bases</title>
		<meeting>Int&apos;l Conf. Very Large Data Bases</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">ªPreliminary Design of ADMS+: A Workstation-Mainframe Integrated Architecture for Database Management Systems</title>
		<author>
			<persName><forename type="first">N</forename><surname>Roussopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 12th Int&apos;l Conf. Very Large Data Bases</title>
		<meeting>12th Int&apos;l Conf. Very Large Data Bases<address><addrLine>Kyoto, Japan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986-08">Aug. 1986</date>
			<biblScope unit="page" from="355" to="364" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">ªAlert: An Architecture for Transforming a Passive DBMS into an Active DBMS</title>
		<author>
			<persName><forename type="first">U</forename><surname>Schreier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Pirahesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Mohan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Very Large Data Bases</title>
		<meeting>Int&apos;l Conf. Very Large Data Bases<address><addrLine>Barcelona, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991-09">Sept. 1991</date>
			<biblScope unit="page" from="469" to="478" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Segev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Fang</surname></persName>
		</author>
		<title level="m">ªCurrency-Based Updates to Distributed Materialized Views,º Proc. Sixth Int&apos;l Conf. Data Eng</title>
		<meeting><address><addrLine>Los Alamitos, Calif.</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990-02">Feb. 1990</date>
			<biblScope unit="volume">512</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">ªMultiple Query Optimization</title>
		<author>
			<persName><forename type="first">T</forename><surname>Sellis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Systems</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<author>
			<persName><forename type="first">W</forename><surname>Tang</surname></persName>
		</author>
		<title level="m">ªPersonalized Update Monitoring Toolkit Using Continual Queries</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
		<respStmt>
			<orgName>Dept. of Computing Science, Univ. of Alberta</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">MSc thesis</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">ªContinuous Queries Over Append-Only Databases</title>
		<author>
			<persName><forename type="first">D</forename><surname>Terry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Nichols</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Oki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD Int&apos;l Conf. Management of Data, pp. 321±330</title>
		<meeting>ACM SIGMOD Int&apos;l Conf. Management of Data, pp. 321±330<address><addrLine>San Diego</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992-01">Jan. 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">N</forename><surname>Volanschi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Consel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Muller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Cowan</surname></persName>
		</author>
		<title level="m">ªDeclarative Specialization of Object-Oriented Programs,º Proc. OOPSLA Conf</title>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Active Datanase Systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ceri</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Morgan Kaufmann</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">W</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Garcia-Molina</surname></persName>
		</author>
		<title level="m">ªSIFTÐA Tool for Wide Area Information Dissemination,º Proc. Usenix Technical Conf</title>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="177" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">ªSimple Fast Algorithms for the Editing Distance Between Trees and Related Problems</title>
		<author>
			<persName><forename type="first">K</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Shasha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Computing</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">6</biblScope>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhuge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Garcia-Molina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hammer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
		<title level="m">ªView Maintenance in a Warehousing Environment,º Proc. ACM SIGMOD Int&apos;l Conf. Management of Data</title>
		<meeting><address><addrLine>San Jose, Calif</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995-05">May 1995</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
