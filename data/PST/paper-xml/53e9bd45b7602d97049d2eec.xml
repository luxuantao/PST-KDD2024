<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A generalization of Paillier&apos;s public-key system with applications to electronic voting</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2010-09-30">30 September 2010</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ivan</forename><surname>Damgård</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Mads</forename><surname>Jurik</surname></persName>
						</author>
						<author>
							<persName><forename type="first">•</forename><surname>Jesper</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Buus</forename><surname>Nielsen</surname></persName>
						</author>
						<author>
							<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Nielsen</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Basic Research in Computer Science (BRICS)</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Centre of the Danish National Research Foundation</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Aarhus University</orgName>
								<address>
									<settlement>Århus</settlement>
									<country key="DK">Denmark</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A generalization of Paillier&apos;s public-key system with applications to electronic voting</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2010-09-30">30 September 2010</date>
						</imprint>
					</monogr>
					<idno type="MD5">D99A4262D2C3EEA38E72BEA2085C0FD3</idno>
					<idno type="DOI">10.1007/s10207-010-0119-9</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T05:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Public-key encryption</term>
					<term>Electronic voting</term>
					<term>Homomorphic encryption</term>
					<term>Zero-knowledge</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We propose a generalization of Paillier's probabilistic public-key system, in which the expansion factor is reduced and which allows to adjust the block length of the scheme even after the public key has been fixed, without losing the homomorphic property. We show that the generalization is as secure as Paillier's original system and propose several ways to optimize implementations of both the generalized and the original scheme. We construct a threshold variant of the generalized scheme as well as zero-knowledge protocols to show that a given ciphertext encrypts one of a set of given plaintexts, and protocols to verify multiplicative relations on plaintexts. We then show how these building blocks can be used for applying the scheme to efficient electronic voting. This reduces dramatically the work needed to compute the final result of an election, compared to the previously best known schemes. We show how the basic scheme for a yes/no vote can be easily adapted to casting a vote for up to t out of L candidates. The same basic building blocks can also be adapted to provide receipt-free elections, under appropriate physical assumptions. The scheme for 1 out of L elections can be optimized such that for a certain range of the other parameter values, the ballot size is logarithmic in L.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In <ref type="bibr" target="#b15">[16]</ref>, Paillier proposes a new probabilistic encryption scheme based on computations in the group Z * n 2 , where n is an RSA modulus. This scheme has some very attractive properties, in that it is homomorphic, allows encryption of many bits in one operation with a constant expansion factor, and allows efficient decryption. In this paper, we propose a generalization of Paillier's scheme using computations modulo n s+1 , for any s ≥ 1. We also show that the system can be simplified (without degrading security) such that the public key can consist of only the modulus n. This allows instantiating the system such that the block length for the encryption can be chosen freely for each encryption, independently of the size of the public key, and without losing the homomorphic property. The generalization also allows reducing the expansion factor from 2 for Paillier's original system to almost 1. We prove that the generalization is as secure as Paillier's original scheme. We also provide a number of ways to optimize both the encryption and decryption operations, in particular a new algorithm for encryption which, compared to a naive implementation of Paillier's original scheme, saves a factor of 4 in computing time. In general, it saves a factor of 4s compared to a straightforward implementation of the generalized system.</p><p>We propose a threshold variant of the generalized system, allowing a number of servers to share knowledge of the secret key, such that any large enough subset of them can decrypt a ciphertext, while smaller subsets have no useful information. We prove in the random oracle model that the scheme is as secure as a standard centralized implementation.</p><p>We also propose a zero-knowledge proof of knowledge allowing a prover to show that a given ciphertext encodes a given plaintext. From this we derive other tools, such as a protocol showing that a ciphertext encodes one out of a number 123 of given plaintexts. Finally, we propose a protocol that allows verification of multiplicative relations among encrypted values without revealing extra information.</p><p>We look at applications of this to electronic voting schemes. A large number of such schemes are known, but the most efficient one, at least in terms of the work needed from voters, is by Cramer et al. <ref type="bibr" target="#b6">[7]</ref>. This protocol provides in fact a general framework that allows usage of any probabilistic encryption scheme for encryption of votes, if the encryption scheme has a set of "nice" properties, in particular it must be homomorphic. The basic idea of this is straightforward: each voter broadcasts an encryption of his vote (by sending it to a bulletin board) together with a proof that the vote is valid. All the valid votes are then combined to produce an encryption of the result, using the homomorphic property of the encryption scheme. Finally, a set of trustees (who share the secret key of the scheme in a threshold fashion) can decrypt and publish the result.</p><p>Paillier pointed out already in <ref type="bibr" target="#b15">[16]</ref> that since his encryption scheme is homomorphic, it may be applicable to electronic voting. In order to apply it in the framework of <ref type="bibr" target="#b6">[7]</ref>, however, some important building blocks are missing: one needs an efficient proof of validity of a vote, and also an efficient threshold variant of the scheme, so that the result can be decrypted without allowing a single entity the possibility of learning how single voters voted.</p><p>These building blocks are precisely what we provide here. Thus, we immediately get a voting protocol. In this protocol, the work needed from the voters is of the same order as in the original version of <ref type="bibr" target="#b6">[7]</ref>. However, the work needed to produce the result is reduced dramatically, as we now explain. With the El-Gamal encryption used in <ref type="bibr" target="#b6">[7]</ref>, the decryption process after a yes/no election produces g R mod p, where p is prime, g is a generator and R is the desired result. Thus, one needs to solve a discrete log problem in order to find the result. Since R is bounded by the number of voters M, this is feasible for moderate size Ms. But it requires ( √ M) exponentiations and may certainly be something one wants to avoid for largescale elections. The problem becomes worse, if we consider an election where we choose between L candidates, L ≥ 2. The method given for this in <ref type="bibr" target="#b6">[7]</ref> is exponential in L in that it requires time ( √ M L-<ref type="foot" target="#foot_0">1</ref> ), and so is prohibitively expensive for elections with large L.</p><p>In the scheme we propose below, this work can be removed completely. Our decryption process produces the desired result directly. Moreover, we can scale easily to larger values of M and L without choosing new keys, just by going to a larger value of s.</p><p>We also give ways to implement efficiently constraints on voting that occur in real elections, such as allowing to vote for precisely t out of the L candidates, or to vote for up to t of them. In each of these schemes, the size of a single ballot is O(k • L), where k is the bit length of the modulus used. 1 We propose a variant using a different technique where ballots have size O(max(k, L log M) • log L). Thus for k ≥ L log M, this is much more efficient, and even optimal up to a constant factor, since with less than log L bits one cannot distinguish between the L candidates. Furthermore, this scheme requires only 1 decryption operation, even whenL &gt; 2.</p><p>Some of the results in this paper were presented in preliminary form in <ref type="bibr" target="#b7">[8]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related work</head><p>In work independent from, but earlier than ours, Fouque et al. <ref type="bibr" target="#b9">[10]</ref> proposed the first threshold version of Paillier's original scheme. Like our threshold scheme, <ref type="bibr" target="#b9">[10]</ref> uses an adaptation of Shoup's threshold RSA scheme <ref type="bibr" target="#b16">[17]</ref>, but beyond this the techniques are somewhat different, in particular because we construct a threshold version for our generalized cryptosystem (and not only Paillier's original scheme). In <ref type="bibr" target="#b9">[10]</ref>, voting was also pointed out as a potential application; however, no suggestion was made there for protocols to prove that an encrypted vote is correctly formed, something that is of course necessary for a secure election in practice.</p><p>In work done concurrently with and independent from ours, Baudron et al. <ref type="bibr" target="#b1">[2]</ref> propose a voting scheme somewhat similar to ours. Their work can be seen as being complementary to ours in the sense that their proposal is more oriented toward the system architectural aspects of a large-scale election and less toward optimization of the building blocks. To compare to their scheme, we first note that there the modulus length k must be chosen such that k -1 &gt; L log M. The scheme produces ballots of size O(k • L). An estimate with explicit constants is given in <ref type="bibr" target="#b1">[2]</ref> in which the dominating term in our notation is 9k L.</p><p>Because our voting scheme uses the generalized Paillier cryptosystem, k can be chosen independently from L , M, in particular the scheme can scale to any size of election, even after the keys have been generated. But if we choose k as in <ref type="bibr" target="#b1">[2]</ref>, i.e., k -1 &gt; L log M, then the ballots we produce have size O(k • log L). Working out the concrete constants involved, one finds that our complexity is dominated by the term 10k log L. So already for moderate size elections we have gained a significant factor in complexity compared to <ref type="bibr" target="#b1">[2]</ref>.</p><p>In <ref type="bibr" target="#b13">[14]</ref>, Hirt and Sako propose a general method for building receipt-free election schemes, i.e., protocols where votebuying or vote-coercing is not possible because voters cannot prove to others how they voted. Their method can be applied to make a receipt-free version of the scheme from <ref type="bibr" target="#b6">[7]</ref>. It can also be applied to our scheme, with the same efficiency gain as in the non-receipt-free case.</p><p>When using the threshold version of our scheme, we assume for simplicity a trusted dealer for setting up the keys initially, and we assume that the modulus used is a safe prime product, similar to what is done in Shoup's paper <ref type="bibr" target="#b16">[17]</ref>. In <ref type="bibr" target="#b8">[9]</ref>, Damgård and Koprowski propose techniques by which one can drop these restrictions from Shoup's scheme, at the expense of an extra intractability assumption. The same idea can be easily applied to our scheme thus producing a scheme without a trusted dealer and using a general RSA modulus. The threshold version of our scheme can also be used for general secure multiparty computation as shown by Cramer, Damgård and Nielsen in <ref type="bibr" target="#b2">[3]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">A generalization of Paillier's probabilistic encryption scheme</head><p>The public-key cryptosystem we describe here uses computations modulo n s+1 where n is an RSA modulus and s is a natural number smaller than p and q. It contains Paillier's scheme <ref type="bibr" target="#b15">[16]</ref> as a special case by setting s = 1. Consider a modulus n = pq, p, q odd primes, where gcd(n, φ(n)) = 1. When p, q are large and randomly chosen, this will be satisfied except with negligible probability. Such an n will be called admissible in the following. For such an n, Z * n s+1 as a multiplicative group is a direct product G × H , where G is cyclic of order n s and H is isomorphic to Z * n . This follows directly from the Chinese remainder theorem and the fact that Z * p s+1 is cyclic of order ( p -1) p s . Thus, the factor group Ḡ = Z * n s+1 /H is also cyclic of order n s . For an arbitrary element a ∈ Z * n s+1 , we let ā = a H denote the element represented by a in the factor group Ḡ. Below we show that n + 1 has order n s in Z * n s+1 , so concretely we have that G = n + 1 and H = {r n s mod n s+1 |r ∈ Z * n s+1 } and Z * n s+1 = G H.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 1</head><p>For any admissible n and s &lt; p, q, the element n + 1 has order n s in Z * n s+1 .</p><p>Proof For any integer i ≥ 0, consider the integer</p><formula xml:id="formula_0">(1 + n) i = i j=0 i j n j . This number is 1 modulo n s+1 if and only if i j=1 i j n j-1 is 0 modulo n s .</formula><p>Clearly, this is the case if i = n s , so it follows that the order of 1 + n is a divisor in n s , i.e., it is a number of form p α q β , where α, β ≤ s. Let a = p α q β be the order of n + 1, and consider a term a j n j-1 in the sum a j=1 a j n j-1 . We claim that each such term is divisible by a: this is trivial if j &gt; s, and for j ≤ s, it follows since by assumption in the lemma, j! can not have p or q as prime factors, and so a must divide a j . Now assume for contradiction that a = p α q β &lt; n s . Without loss of generality, we can assume that this means α &lt; s. We argued above that (n + 1) a mod n s+1 = 1 implies that n s divides a j=1 a j n j-1 . Dividing both these numbers by a, we see that p must divide the number a j=1 a j n j-1 /a. On the other hand, however, the first term in this sum after division by a is 1, and all the rest are divisible by p, so the number is in fact 1 modulo p, and we have a contradiction.</p><p>Since then the order of H is relatively prime to n s the above lemma implies immediately that the element 1 + n := (1+n) H ∈ Ḡ is a generator of Ḡ, except possibly for s ≥ p, q. So the cosets of H in Z * n s+1 are</p><formula xml:id="formula_1">H, (1 + n)H, (1 + n) 2 H, . . . , (1 + n) n s -1 H,</formula><p>which leads to a natural numbering of these cosets. The following lemma captures the structure of Z * n s+1 in a more concrete way: Lemma 2 For any admissible n and s &lt; p, q, the map ψ s :</p><formula xml:id="formula_2">Z n s × Z * n → Z * n s+1</formula><p>given by (x, r ) → (1 + n) x r n s mod n s+1 is an isomorphism, where</p><formula xml:id="formula_3">ψ s (x 1 + x 2 mod n s , r 1 r 2 mod n) = ψ s (x 1 , r 1 )ψ s (x 2 , r 2 ) mod n s+1 . Proof Let π : Z * n → Z * n s+1</formula><p>be given by r → ψ s (0, r ) = r n s mod n s+1 . By the above enumeration of the cosets of H , it is enough to prove that π(r 1 r 2 mod n) = π(r 1 )π(r 2 ) mod n s+1 and that π maps Z * n injectively to H . First, it is clear that π(r ) ∈ H . By looking at the binomial expansion, it is easy to see that r n s ≡ (r + n) n s (mod n s+1 ). This proves the homomorphic property directly and by the pigeon hole principle implies that π is injective. This lemma gives us the following encoding of the cosets:</p><formula xml:id="formula_4">(1 + n) i = ψ s (i, Z * n ).</formula><p>The final technical observation we need is that ψ can be inverted given the factorization of n. In particular, taking discrete logarithms base n + 1 in Ḡ is easy given the factorization.</p><p>Theorem 1 For any admissible n and s &lt; p, q, the map ψ s :</p><formula xml:id="formula_5">Z n s × Z * n → Z * n s+1</formula><p>given by (x, r ) → (1 + n) x r n s mod n s+1 can be inverted in polynomial time given λ(n), the least common multiple of p -1 and q -1.</p><p>Proof We first show how to find i from (1 + n) i mod n s+1 . If we define the function L() by L(b) = (b -1)/n then clearly we have</p><formula xml:id="formula_6">L((1 + n) i mod n s+1 ) = i + i 2 n + • • • + i s n s-1 mod n s .</formula><p>We now describe an algorithm for computing i from this number.</p><p>The general idea of the algorithm is to extract i part by part, so that we first extract i 1 = i mod n, then i 2 = i mod n<ref type="foot" target="#foot_1">2</ref> and so forth. It is easy to extract i 1 = L((1 + n) i mod n 2 ) = i mod n. Now we can extract the rest by the following induction step: In the jth step, we know i j-1 . This means that i j = i j-1 + k * n j-1 for some 0 ≤ k &lt; n. If we use this in</p><formula xml:id="formula_7">L((1 + n) i mod n j+1 ) = i j + i j 2 n + • • • + i j j n j-1 mod n j .</formula><p>We can notice that each term i j t+1 n t for j &gt; t &gt; 0 satisfies that i j t+1 n t = i j-1 t+1 n t mod n j . This is because the contributions from k * n j-1 vanish modulo n j after multiplication by n. This means that we get:</p><formula xml:id="formula_8">L((1 + n) i mod n j+1 ) = i j-1 + k * n j-1 + i j-1 2 n + • • • + i j-1 j n j-1 mod n j .</formula><p>Then, we just rewrite that to get what we wanted</p><formula xml:id="formula_9">i j = i j-1 + k * n j-1 = i j-1 + L((1 + n) i mod n j+1 ) -i j-1 + i j-1 2 n + • • • + i j-1 j n j-1 mod n j = L((1 + n) i mod n j+1 ) - i j-1 2 n + • • • + i j-1 j n j-1 mod n j .</formula><p>This equation leads to the following algorithm: i := 0; for j:= 1 to s do begin t 1 := L(a mod n j+1 ); t 2 := i; for k:= 2 to j do begin i := i -1;</p><formula xml:id="formula_10">t 2 := t 2 * i mod n j ; t 1 := t 1 -t 2 * n k-1 k! mod n j ; end i := t 1 ; end</formula><p>Assume now that we are given c = (1+n) i r n s mod n s+1 . We show how to find i and r given λ. To find i compute</p><formula xml:id="formula_11">c λ = (1 + n) iλ mod n s r n s λ mod n s λ = (1 + n) iλ mod n s .</formula><p>Then using the above algorithm find iλ mod n s and extract i. Now compute r n s = c(1 + n) -i mod n s+1 and compute a such that aλ + 1 = 0 mod n s . This is possible because gcd(λ, n s ) = 1. Then (r n s ) aλ+1 n s mod n = r aλ+1 mod n = (r λ ) a r mod n = r mod n = r.</p><p>We are now ready to describe our cryptosystem. In fact, for each natural number s, we can build a cryptosystem DJN s , as follows:</p><p>Key generation On input the security parameter k, choose an admissible RSA modulus n = pq of length k bits. 2  Also choose an element g ∈ Z * n s+1 such that g = (1 + n) j x mod n s+1 for a known j relatively prime to n and x ∈ H . This can be done, e.g., by choosing j, x at random first and computing g; some alternatives are described later. Let λ be the least common multiple of p -1 and q-1. By the Chinese Remainder Theorem, choose d such that d mod n ∈ Z * n and d = 0 mod λ. Any such choice of d will work in the following. In Paillier's original scheme d = λ was used, which is the smallest possible value. However, when making a threshold variant, other choices are better-we expand on this in the following section. Now the public key is n, g while the secret key is d. Encryption The plaintext set is Z n s . Given a plaintext i, choose a random r ∈ Z * n , and let the ciphertext be E(i, r ) = g i r n s mod n s+1 . Decryption Given a ciphertext c, first compute c d mod n s+1 .</p><p>Clearly, if c = E(i, r ), we get</p><formula xml:id="formula_12">c d = (g i r n s ) d = ((1 + n) ji x i r n s ) d = (1 + n) jid mod n s (x i r n s ) d mod λ = (1 + n) jid mod n s .</formula><p>Now apply the algorithm from the proof of Theorem 1 to compute jid mod n s . Applying the same method with c replaced by g clearly produces the value jd mod n s , so this can either be computed on the fly or be saved as part of the secret key. In any case, we obtain the cleartext by</p><formula xml:id="formula_13">( jid) • ( jd) -1 = i mod n s .</formula><p>Clearly, this system is additively homomorphic over Z n s , that is, the product of encryptions of messages i, i is an encryption of i + i mod n s .</p><p>To facilitate comparison with Paillier's original system, we have kept the above system description as close as possible to that of Paillier. In particular, the description allows choosing g in a variety of ways. However, as we shall see, semantic security of the system is equivalent to a particular computational assumption, no matter how we choose g, in particular we may as well simplify matters and choose g = n + 1 always. This also allows a more efficient implementation. Therefore, in the following sections, when we refer to DJN s , we usually mean the above system with g = n + 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Security</head><p>There are two basic flavors or strengths of security that one may consider, namely -Is the scheme one-way, i.e., is it hard to compute the plaintext from the ciphertext? -Is the scheme semantically secure, i.e., does any information at all about the plaintext leak, given the ciphertext?</p><p>We give first a short informal discussion on one-wayness and then look at semantic security in more detail.</p><p>The homomorphic property of the scheme means that the problem of computing the plaintext from the ciphertext (and the public key) is random self-reducible: given any ciphertext c and public key n, g, one may choose i ∈ Z n s , j ∈ Z * n s , r, r ∈ Z * n at random and try to decrypt the ciphertext c = cg i r n s mod n s+1 with respect to public key n, g where g = g j r n s mod n s+1 . If this succeeds, one can find the original plaintext by multiplying by j and subtracting i modulo n s . Note that (c , g ) is a random (ciphertext, generator) pair, no matter how c, g were chosen. So any algorithm that can break a non-trivial fraction of the ciphertexts and choices of g can also break a random instance with significant probability. This motivates calling our scheme one-way if it is hard to find the plaintext given a random public key n, g and a random ciphertext c.</p><p>We have Proposition 1 If for some t the scheme DJN t is one-way, then DJN s is one-way for any s &gt; t. Especially, DJN s is one-way for any s if Paillier's original scheme C S 1 is oneway.</p><p>Proof Assume that s &gt; t and that DJN t is one-way. Assume for the sake of contradiction that DJN s is not one-way. Then given a public key n, g and a ciphertext c t from DJN t , we can transform this to a decryption problem in DJN s instead.</p><p>Concretely, this means we consider c t as a number modulo n s+1 (instead of n t+1 ), and choose as the public generator a random number g ∈ Z * n s+1 , such that g mod n t+1 = g. We then randomize c t (modulo n s+1 ) as described above. This produces a random instance of the decryption problem in DJN s , so by assumption we can find the plaintext m in DJN s corresponding to c t . We have of course that m ∈ Z n s , and now clearly m mod n t is the plaintext corresponding to c t in DJN t , so that DJN t is not one-way either.</p><p>If we want to claim that a cryptosystem "hides" the plaintext in any reasonable sense, the one-way assumption is essentially the weakest possible assumption one can make. In <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr">Catalano et al.</ref> show that this assumption for DJN 1 implies that one can make a semantically secure system hiding a logarithmic number of bits per ciphertext in the original system and that a somewhat stronger assumption implies a system hiding a linear number of bits per ciphertext. It is easy to generalize these results to DJN s . None of the schemes constructed this way will be homomorphic, however.</p><p>The semantic security of our schemes can be based on the following assumption, introduced by Paillier in <ref type="bibr" target="#b15">[16]</ref>, the decisional composite residuosity assumption (DCRA):</p><p>Conjecture 1 Let A be any probabilistic polynomial time algorithm, and assume A gets n, x as input. Here, n has k bits and is chosen as described above, and x is either random in</p><formula xml:id="formula_14">Z * n 2 or it is a random nth power in Z * n 2 (that is, a random element in the subgroup H defined earlier). A outputs a bit b. Let p 0 (A, k) be the probability that b = 1 if x is random in Z * n 2 and p 1 (A, k) the probability that b = 1 if x is a random nth power. Then, | p 0 (A, k) -p 1 (A, k) | is negligible in k.</formula><p>Here, "negligible in k" as usual means smaller than 1/ f (k) for any polynomial f () and all large enough k.</p><p>We now discuss the semantic security of DJN s . There are several equivalent formulations of semantic security. We will use the following: Definition 1 An adversary A against a public-key cryptosystem gets the public key pk generated from security parameter k as input and outputs a message m. Then, A is given an encryption under pk of either m or a message chosen uniformly in the message space, and outputs a bit. Let p 0 (A, k), respectively, p 1 (A, k) be the probability that A outputs 1 when given an encryption of m, respectively a random encryption. Define the advantage of A to be Adv</p><formula xml:id="formula_15">(A, k) = |p 0 (A, k) -p 1 (A, k)|. The cryptosystem is semantically secure if for any probabilistic polynomial time adversary A, Adv(A, k) is negligible in k.</formula><p>In <ref type="bibr" target="#b15">[16]</ref>, Paillier showed that his cryptosystem (which is equivalent in security to our DJN 1 ) is semantically secure if and only if DCRA holds. This holds for any choice of g and follows easily from the fact that given a ciphertext c that is either random or encrypts a message i, we have that cg -i mod n 2 is either random in Z * n 2 or a random nth power. In particular, assuming DCRA, one may choose g = n + 1 always without degrading security. We now show that security of DJN s is equivalent to DCRA: Theorem 2 For any s, the cryptosystem DJN s is semantically secure if and only if the DCRA is true. This holds even if s is allowed to increase polynomially in the security parameter.</p><p>Proof From a ciphertext in DJN s , one can obtain a ciphertext in DJN 1 by reducing modulo n 2 , this implicitly reduces the message modulo n. It is therefore clear that if DCRA fails, then DJN s cannot be secure for any s.</p><p>For the converse, we assume that DJN s is not secure and we start by showing a relation between security of DJN s and that of DJN t for values of t &lt; s.</p><p>The message space of DJN s is Z n s . Thus, any message m can be written in n-adic notation as an s-tuple (m s , m s-1 , . . . , m 1 ), where each m i ∈ Z n and m = s-1 i=0 m i+1 n i . Let D n (m s , . . . , m 1 ) be the distribution obtained by encrypting the message (m s , . . . , m 1 ) under public key n. If one or more of the m i are replaced by * s, this means that the corresponding position in the message is chosen uniformly in Z n before encrypting. Now, assume for simplicity that s is even, consider any adversary A against DJN s , and assume that Adv(A, k) ≥ 1/ f (k) for some polynomial f () and infinitely many values of k. For any such value, we can assume without loss of generality that we have</p><formula xml:id="formula_16">p 0 (A, k) -p 1 (A, k) ≥ 1/ f (k).</formula><p>Suppose we make a public key n from security parameter k, show it to A, get a message (m s , . . . , m 1 ) from A and show A a sample of D n ( * , . . . , * , m s/2 , . . . , m 1 ). Let q(A, k) be the probability that A now outputs 1. Of course, we must have</p><formula xml:id="formula_17">p 0 (A, k) -q(A, k) ≥ 1 2 f (k) or q(A, k) -p 1 (A, k) ≥ 1 2 f (k) ( * )</formula><p>and one of these cases must be true for infinitely many values of k. In the first case in ( * ), we can make a successful adversary against DJN s/2 , as follows: we get the public key n, show it to A, get (m s , . . . , m 1 ), and return (m s , . . . , m 1+s/2 ) as output. We will get a ciphertext c that either encrypts (m s , . . . , m 1+s/2 ) in DJN s/2 , or is a random ciphertext. If we consider c as an element in Z * n s+1 , we know it is an encryption of some plaintext, which must have either (m s , . . . , m 1+s/2 ) or s/2 random elements in its least significant positions. Hence, c n s/2 mod n s+1 is an encryption of (m s , . . . , m 1+s/2 , 0, . . . , 0) or ( * , . . . , * , 0, . . . , 0). We then make a random encryption d of (0, . . . , 0, m s/2 , . . . , m 1 ), give c n s-1 d mod n s+1 to A and return the bit A outputs. Now, if c encrypts (m s , . . . , m 1+s/2 ), we have shown to A a sample of D n (m s , . . . , m 1 ), and otherwise a sample of D n ( * , . . . , * , m s/2 , . . . , m 1 ). So by assumption on A, this breaks DJN 1 with an advantage of 1/2 f (k) for infinitely many k.</p><p>In the second case of ( * ), we can also make an adversary against DJN s/2 , as follows: we get the public key n, show it to A, and get a message (m s , . . . , m 1 ). We output (m s/2 , . . . , m 1 ) and get back a ciphertext c that encrypts in DJN s/2 either (m s/2 , . . . , m 1 ) or something random. If we consider c as a number modulo n s+1 , we know that the corresponding plaintext in DJN s has either (m s/2 , . . . , m 1 ) or random elements in the least significant s/2 positions-and something unknown in the top positions. We make a random encryption d of ( * , . . . , * , 0, . . . , 0), show cd mod n s+1 to A and return the bit A outputs. If c encrypted (m s/2 , . . . , m 1 ), we have shown A a sample from D n ( * , . . . , * , m s/2 , . . . ., m 1 ), and otherwise a sample from D n ( * , . . . , * ). So again this breaks DJN s/2 with an advantage of 1/2 f (k) for infinitely many k.</p><p>To sum up, we have: for any adversary A against DJN s , s even, there exists an adversary A against DJN s/2 , such that Adv(A , k) ≥ 1/2 f (k) for infinitely many k. Similarly, for odd s, we can show existence of an adversary against either DJN (s+1)/2 or DJN (s-1)/2 with advantage at least 1/2 f (k) for infinitely many k.</p><p>Repeated use of this result shows that for any adversary A against DJN s , there exists an adversary against DJN 1 with advantage at least 1/2s f (k) for infinitely many k. Thus, since s is polynomially bounded as a function of k, DJN 1 is not semantically secure, and this contradicts Paillier's original result.</p><p>From the point of view of exact security analysis, one can note that from the proof above, it follows that the maximal advantage with which DJN s can be broken is at most a factor of 2s larger than the corresponding advantage for DJN 1 . Thus, there is no great security risk in using large values of s, if one believes that DJN 1 is secure in the first place.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Adjusting the block length</head><p>As mentioned, we may choose g = n + 1 always without losing security, and the public key may then consist only of the modulus n. This means that we can decide on a value for s at any point after the keys have been generated, or even let the sender decide on the fly when he encrypts a message. Concretely, the system will then work as follows:</p><p>Key generation Choose an admissible RSA modulus n = pq. Now the public key is n while the secret key is λ, the least common multiple of ( p -1) and (q -1). Encryption Given a plaintext i represented as a non-negative integer, choose an s such that i &lt; n s , choose a random r ∈ Z * n , and let the ciphertext be</p><formula xml:id="formula_18">E(i, r ) = (1 + n) i r n s mod n s+1 . Decryption Given a ciphertext c, compute c λ mod n s+1</formula><p>(note that from the length of c, one can decide the correct value of s except with negligible probability). Clearly, if c = E(i, r ), we get</p><formula xml:id="formula_19">c λ = ((1 + n) i r n s ) λ = (1 + n) iλ mod n s (r n s ) λ mod λ = (1 + n) iλ mod n s+1</formula><p>Now apply the algorithm from Theorem 1 to compute iλ mod n s and get the message by multiplying by λ -1 modulo n s .</p><p>It is an immediate corollary to Proposition 1 and Theorem 2 that the above scheme is one-way if DJN 1 is one-way respectively is semantically secure if the DCRA holds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Some optimizations and implementation issues</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">An alternative encryption function</head><p>Let ψ s : Z n s × Z * n → Z * n s+1 be the isomorphism given by (x, r ) → (1 + n) x r n s mod n s+1 in Lemma 2. In the above, we encrypt an element i ∈ Z n s by a random element from the coset (1</p><formula xml:id="formula_20">+ n) i = ψ s (i, Z * n ). This element is chosen as c = ψ s (i, r ) for random r ∈ Z * n .</formula><p>Note that if we reduce a ciphertext modulo n, we obtain:</p><formula xml:id="formula_21">c mod n = (1 + n) x r n s mod n = r n s mod n</formula><p>The Jacobi symbol modulo n is easy to compute, even without the factors (see e.g. <ref type="bibr" target="#b0">[1]</ref>), and since n s is odd and the Jacobi symbol is multiplicative, we see that from c = ψ s (i, r ), we can compute the Jacobi symbol of r efficiently. Further, by multiplying c by a number of form ψ s (0, r ), where r is an arbitrary constant with the same Jacobi symbol as r , we obtain a ciphertext c = ψ s (i, r ) = ψ s (i, r r), where r is guaranteed to have Jacobi symbol 1. It easily follows that the cryptosystem which is like DJN s , except that we restrict r to have Jacobi symbol 1, is exactly as secure as DJN s , under any notion of security. We now exploit this to obtain an alternative and more efficient encryption function.</p><p>Using standard techniques, we can generate a random RSA modulus n = pq with known p and q such that p = 3 mod 4, q = 3 mod 4, gcd( p -1, q -1) = 2. This means that the subgroup of quadratic residues SQ(n) is cyclic and has odd order, say α. We can also ensure that all elements in this subgroup -except for a negligible fraction -are generators. This can be done by picking p, q such that all prime factors in p -1, q -1 except 2 are sufficiently large. One extreme special case of this is when n is a safe prime product, which is an option we use later for the threshold version of the scheme.</p><p>Let Z * n [+] be the elements with Jacobi symbol 1 in Z * n . We have that Z * n [+] contains SQ(n), has order 2α and is also cyclic. Finally, -1 ∈ Z * n [+] \ SQ(n) by choice of n. All this implies that if we choose at random x ∈ Z * n and let h = -x 2 mod n then, except with negligible probability,</p><formula xml:id="formula_22">h = Z * n [+]</formula><p>. This then allows us to generate a uniformly random element r from Z * n [+] as h a mod n, where a is a uniformly random integer from [0, (p -1)(q -1)/2). However, since ( p -1)(q -1)/2 is the secret key, this would allow only the owner of the secret key to encrypt, which would of course be useless. We can remedy this by using a result from <ref type="bibr" target="#b10">[11]</ref>. Let (n, h) be generated as above. Let a be a uniformly random integer from [0, (p -1)(q -1)/2) and let a be a uniformly random element from [0, 2 k/2 ). Then by <ref type="bibr" target="#b10">[11,</ref><ref type="bibr">Theorem 3.2]</ref> the random variables (n, h, h a mod n) and (n, h, h a mod n) are computationally indistinguishable assuming the intractability of factoring, which is implied by the DCRA. This means that even though h a mod n is not a uniformly random element from Z * n [+], it cannot be distinguished from a uniformly random element from Z * n [+] by any polynomial time algorithm, which suffices for our application. This gives us the following cryptosystem DJN s .</p><p>Key generation Choose an admissible RSA modulus n = pq of length k bits, where p ≡ q ≡ 3 (mod 4), gcd( p-1, q-1) = 2, and such that a random square generates SQ(n) except with negligible probability. Choose a generator h of Z n [+] as described earlier. Now the public key is (n, h) while the secret key is λ = ( p -1)(q -1)/2, the least common multiple of ( p -1) and (q -1). Encryption Given a plaintext i ∈ Z n s choose a random a ∈ Z 2 k/2 and let the ciphertext be</p><formula xml:id="formula_23">Ẽ(i, a) = (1 + n) i (h a mod n) n s mod n s+1 = E(i, h a mod n). Decryption As before.</formula><p>The following theorem follows directly from the fact that h a mod n is pseudo random in Z * n under DCRA, that h can be generated given just n, and that the security of DJN s is unchanged when restricting the randomness to Jacobi symbol 1.</p><p>Theorem 3 For any s, the cryptosystem DJN s is semantically secure if and only if the DCRA is true. This holds even if s is allowed to increase polynomially in the security parameter.</p><p>From an exact security point of view, one should be aware that in order to argue the security, we are using the DCRA twice: first to argue that DJN s is as secure as DJN s (namely h a mod n is pseudo random) and then to argue that DJN s is secure. This means that if we want to build instances of DJN s that can be broken with advantage no larger than instances of DJN s with security parameter k, we need to use moduli that are somewhat longer than k bits. How much longer depends on exactly how strong assumptions we are willing to make, and on the complexity of the reduction in the result of <ref type="bibr" target="#b10">[11]</ref>. This may partly eliminate the efficiency advantage we show below for DJN s . On the other hand, this issue can be completely avoided by using more randomness, namely we choose a as a random number modulo n/2, instead of a random k/2-bit number. Then, h a mod n will be statistically close to a random element in h , without any assumptions, and up to a negligible term, we have the same security for this variant of DJN s as for DJN s . This will only cost a factor of 2 in performance of the encryption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Optimizations of encryption and decryption</head><p>Encryption. While encrypting, instead of computing (1 + n) m directly, we can compute it according to:</p><formula xml:id="formula_24">(1 + n) m = 1 + mn + m 2 n 2 + • • • + m s n s mod n s+1 .</formula><p>This trades an exponentiation with a O(n s ) size exponent for O(s) multiplications by calculating the binomials using:</p><formula xml:id="formula_25">m j = m j -1 m -j + 1 j .</formula><p>In the ith step, we calculate m i n i mod n s+1 , and since there is a multiplication by n i it is enough to calculate the binomial modulo n s-i+1 . To further optimize the computations the ( j!) -1 n j can be precomputed. The pseudo algorithm for calculating the (n + 1) m part of the encryption looks like this (where precomp is an array of the precomputed values, precomp[ j] := ( j!) -1 n j mod n s+1 ):</p><formula xml:id="formula_26">c := 1 + mn; tmp := m; for j:= 2 to s do begin tmp := tmp • (m -j + 1) mod n s-j+1 ; c := c + tmp • precomp[ j] mod n s+1 ; end</formula><p>In the cryptosystem DJN s the elements from H is generated as (h a mod n) n s mod n s+1 which, if computed naively, certainly leads to no optimization. However, a simple observation allows us to reduce the number of steps used in this computation. Let h s = h n s mod n s+1 . Then using the isomorphism from Theorem 1, we have</p><formula xml:id="formula_27">(h a mod n) n s mod n s+1 = ψ s (0, h a mod n) = ψ s (0, h) a = h a s mod n s+1 It follows that Ẽ(i, a) = (1 + n) i h a</formula><p>s mod n s+1 . If we precompute and save h s , then using standard methods for exponentiation with a fixed base, h a s mod n s+1 can be computed by an expected number of k/4 multiplications modulo n s+1 and hence the entire encryption can be done in k/4 + 2s multiplications. Compared to a straightforward implementation of DJN s with the same k value, where 2 full scale exponentiations are made, this saves a factor of about 4s in computing time, and in particular this is four times as fast as Paillier's original system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Decryption.</head><p>The technique of precomputing factors in binomial coefficients to make encryption faster also applies to the corresponding computations in decryption (see the algorithm in the proof of Theorem 1). Also in the same way as with encryption, we can exploit the fact that the algorithm involves modular multiplication of a variable by a power of n, which means the value of that variable only needs to be known modulo a smaller power of n.</p><p>Another thing that can be optimized is the use of the L function. In the algorithm from Theorem 1, the L function is calculated once per iteration of the for-loop. Instead of doing this we can calculate the largest of these: L(a mod n s+1 ) and use the property that L(a mod n j+1 ) = L(a mod n s+1 ) mod n j . This means that we can remove all but 1 of the division and the modular reductions we make are smaller.</p><p>The standard trick of splitting the computations up and doing them modulo relatively prime parts of the modulus can also be used here with the moduli p j and q j in the jth run of the outer loop. One should be aware though that we need to use different L functions for p and q, namely L q (a) = ((a -1 mod q s+1 )/q) • p -1 mod q s and L p (a) = ((a -1 mod p s+1 )/ p) • q -1 mod p s .</p><p>In this case, decryption can be speeded up by precomputing p j , q j for 1 ≤ j ≤ s, and the n k-1 k! -1 mod p j , n k-1 k! -1 mod q j for 2 ≤ k ≤ j ≤ s.</p><p>Performance evaluations. In Tables <ref type="table" target="#tab_0">1</ref> and<ref type="table" target="#tab_1">2</ref>, the generalized cryptosystem is compared to the El-Gamal and RSA crypto systems. The table is focused on a fixed plaintext size and variable size of security parameter for the generalized cryptosystem. This comparison corresponds to a scenario where you need a certain fixed plaintext size (for instance a largescale election) and it might be sufficient with a smaller security parameter. It shows that if the security parameter doesn't need to have the same size as the encryption block then a significant performance improvement can be achieved.</p><p>In Table <ref type="table">3</ref>, there is a comparison with the number of milli-seconds it takes to encrypt a bit using the same security parameter, but a variable block size. It shows that using El-Gamal and the generalized cryptosystem achieves almost the same rates of encryption. It also shows-as expectedthat the encryption time per bit increases somewhat with larger s values. Thus, if small ciphertext expansion and large block size is important, this can be achieved at a reasonable performance penalty; but if speed is the only important parameter, s = 1 is the best choice. 5 Some building blocks</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">A threshold variant of the scheme</head><p>What we are after in this section is a way to distribute the secret key to a set of servers, such that any subset of at least w of them can do decryption efficiently, while less than w have no useful information. Of course this must be done without degrading the security of the system. In <ref type="bibr" target="#b16">[17]</ref>, Shoup proposes an efficient threshold variant of RSA signatures. The main part of this is a protocol that allows a set of servers to collectively and efficiently raise an input number to a secret exponent modulo an RSA modulus n. A little more precisely: on input a, each server returns a share of the result, together with a proof of correctness. Given sufficiently many correct shares, these can be efficiently combined to compute a d mod n, where d is the secret exponent.</p><p>As we explain below, it is quite simple to transplant this method to our case, thus allowing the servers to raise an input number to our secret exponent d modulo n s+1 . So we can solve our problem by first letting the servers help us compute E(i, r ) d mod n s+1 . Then if we use g = n+1 and choose d such that d = 1 mod n s and d = 0 mod λ, the remaining part of the decryption is easy to do without knowledge of d.</p><p>We warn the reader that this is only secure for the particular choice of d we have made, for instance, if we had used Paillier's original choice d = λ, then seeing the value E(i, r ) d mod n s+1 would allow an adversary to compute λ and break the system completely. However, in our case, the exponentiation result can safely be made public, since it contains no trace of the secret λ.</p><p>A more concrete description: Compared to <ref type="bibr" target="#b16">[17]</ref> we still have a secret exponent d, but there is no public exponent e, so we will have to do some things slightly differently toward the end of the decryption process. We will assume that there are l decryption servers, and a majority of these are needed to make a correct decryption. We will use as modulus n a product of safe primes, i.e., n = pq, where p, q, p = ( p -1)/2, q = (q -1)/2 are primes.</p><p>We will need as a subroutine a zero-knowledge proof that for given values u, ũ, v, ṽ ∈ Z * n s+1 , it holds that log u ( ũ) = log v ( ṽ). Here, it is guaranteed that all values are in the group of squares modulo Z * n s+1 , and that v generates the entire group of squares. Note that this group is always cyclic of order n s p q , since n is a product of safe primes.</p><p>A protocol for this can be easily derived from the corresponding one in <ref type="bibr" target="#b16">[17]</ref>, and works as follows:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Protocol for equality of discrete logs</head><p>Input: u, ũ, v, ṽ ∈ Z * n s+1 . Private input for P : y such that y = log u ( ũ) = log v ( ṽ) (in our application, the length of y will be at most (s + 1)k bits, where k is the modulus length).</p><p>1. P chooses a number r at random of length (s + 2)k + t bits and sends a = u r mod n s+1 , b = v r mod n s+1 to the verifier V . Here, t is a (secondary) security parameter. 2. V chooses a random challenge e of length t bits. 3. P sends to V the number z = r + ey and V checks that</p><formula xml:id="formula_28">u z = a ũe mod n s+1 , v z = b ṽe mod n s+1 .</formula><p>This protocol can be made non-interactive using the Fiat-Shamir heuristic and a hash function H : the prover computes a, b as above, sets e = H (a, b, u, ũ), computes the reply z as above and defines the proof to be (e, z). To verify such a proof, one checks that e = H (u z ũ-e , v z ṽ-e , u, ũ).</p><p>Note that we do not need to include v, ṽ in the input to H because in our application, they are fixed and chosen by an honest dealer. Assuming the random oracle model, i.e., replacing H by a random function, one can show soundness and zero-knowledge of this protocol. This is done in exactly the same way as in <ref type="bibr" target="#b16">[17]</ref> since, like Shoup, we are working in a cyclic group with only large prime factors in its order. We leave the details to the reader.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Key generation</head><p>Key generation starts out as in <ref type="bibr" target="#b16">[17]</ref>: we find 2 primes p and q, that satisfies p = 2 p + 1 and q = 2q + 1, where p and q are primes and different from p and q. We set n = pq and m = p q . We decide on some s &gt; 0, thus the plaintext space will be Z n s . We pick d to satisfy d = 0 mod m and d = 1 mod n s . Now we set w such that 2w -1 ≤ and make the polynomial f (X ) = w-1 i=0 a i X i mod n s m, by picking a i (for 0 &lt; i &lt; w) as random values from {0, . . . , n s * m -1} and a 0 = d. The secret share of the i'th authority will be s i = f (i) for 1 ≤ i ≤ l and the public key will be (n, s). For verification of the actions of the decryption servers, we need the following fixed public values: v, generating the cyclic group of squares in Z * n s+1 and for each decryption server a verification key v i = v s i mod n s+1 , where = l!.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Encryption</head><p>To encrypt a message M, a random r ∈ Z * n is picked and the ciphertext is computed as c = (n + 1) M r n s mod n s+1 . As seen in the previous schemes, a generator h can be chosen to improve efficiency. Since this only affects the encryption it will not affect the security of the threshold decryption scheme.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Share decryption</head><p>The ith authority will compute c i = c 2 s i , where c is the ciphertext. Along with this will be a zero-knowledge proof as described above that log c 4 (c 2 i ) = log v (v i ), which will convince us, that he has indeed raised to his secret exponent s i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Share combining</head><p>If we have the required w (or more) number of shares with a correct proof, we can combine them into the result by taking a subset S of w shares and combine them to</p><formula xml:id="formula_29">c = i∈S c 2λ S 0,i i mod n s+1 where λ S 0,i = i ∈S\i -i i -i ∈ Z.</formula><p>The value of c will have the form c = c 4 2 f (0) = c 4 2 d . Noting that 4 2 d = 0 mod λ and 4 2 d = 4 2 mod n s , we can conclude that c = (1 + n) 4 2 M mod n s+1 , where M is the desired plaintext, so this means we can compute M by applying the algorithm from Theorem 1 and multiplying the result by ( <ref type="formula">4</ref>2 ) -1 mod n s . Compared to the scheme proposed in <ref type="bibr" target="#b9">[10]</ref>, there are some technical differences, apart from the fact that <ref type="bibr" target="#b9">[10]</ref> only works for the original Paillier version modulo n 2 : in <ref type="bibr" target="#b9">[10]</ref>, an extra random value related to the public element g is part of the public key and is used in the share combining algorithm. This is avoided in our scheme by the way we choose d and thus we get a slightly shorter public key and a slightly simpler decryption algorithm.</p><p>The system as described requires a trusted party to set up the keys. This may be acceptable as this is a once and for all operation, and the trusted party can delete all secret information as soon as the keys have been distributed. However, using multiparty computation techniques, it is also possible to do the key generation without a trusted party, in particular, ideas from <ref type="bibr" target="#b8">[9]</ref> can be used to give a reasonably efficient solution.</p><p>Note that the key generation phase requires that a value of the parameter s is fixed. This means that the system will be able to handle messages encrypted modulo n s +1 , for any s ≤ s, simply because the exponent d satisfies d = 1 mod n s , for any s ≤ s. But it will not work if s &gt; s. If a completely general decryption procedure is needed, this can be done as well: If we assume that λ is secret-shared in the key set-up phase, the servers can compute a suitable d by running a secure protocol that first inverts λ modulo n s to get some x as result, and then computes the product d = xλ (over the integers). This does not require generic multiparty computation techniques, but can be done quite efficiently using techniques from <ref type="bibr" target="#b17">[18]</ref>. Note that, while this does require communication between servers, it is not needed for every decryption, but only once for every value of s that is used.</p><p>We can now show in the random oracle model that this threshold version is as secure as a centralized scheme where one trusted player does the decryption, <ref type="foot" target="#foot_2">3</ref> in particular the threshold version is secure relative to the same complexity assumption as the basic scheme. This can be done in a model where a static adversary corrupts up to w -1 players from the start. Concretely, we have: Theorem 4 Assume the random oracle model and a static adversary that corrupts up to w -1 players from the beginning. Then we have: Given any ciphertext, the decryption protocol outputs the correct plaintext, except with negligible probability. Given an oracle that on input a ciphertext returns the corresponding plaintext, the adversary's view of key generation and of the decryption protocol can be efficiently simulated with a statistically indistinguishable distribution.</p><p>The proof follows very closely the corresponding proof in <ref type="bibr" target="#b16">[17]</ref>. So here we only sketch the basic ideas: correctness of the scheme is immediate assuming that the adversary can contribute incorrect values for the c i 's with only negligible probability. This, in turn, is ensured by soundness of the zeroknowledge proofs given for each c i .</p><p>For the simulation, we start from the public key n. Then, we can simulate the shares s i 1 , . . . , s i w-1 of the bad players by choosing them as random numbers modulo n s+1 . This will be statistically indistinguishable from the real values which are chosen modulo n s p q . Since d is fixed by the choice of n, this means that the shares of uncorrupted players and the polynomial f are now fixed as well, in particular we have f (i 1 ) = s i 1 , . . . , f (i w-1 ) = s i w-1 . But d, f are not easy for the simulator to compute.</p><p>However, if we simulate v by choosing it as a ciphertext with known plaintext m 0 , i.e., v = (n + 1) m 0 r 2n s mod n s+1 , we can also compute what v f (0) would be, namely</p><formula xml:id="formula_30">v f (0) = v d mod n s+1 = (1 + n) m 0 mod n s+1 . Let S be the set 0, i 1 , . . . , i w-1 of w indices, and let λ S j,i = i ∈S\i j -i i -i</formula><p>be the Lagrange coefficients for interpolating the value of a polynomial in point j (times ) from its values in points in S.</p><p>Then, we can compute correct values of v j for uncorrupted players as</p><formula xml:id="formula_31">v j = i∈S (v f (i) ) λ S j,i .</formula><p>When we get a ciphertext c as input, we ask the oracle for the plaintext m. This allows us to compute</p><formula xml:id="formula_32">c d = (1 + n) m mod n s-1 .</formula><p>Again this means we can interpolate and compute the contributions c i from the uncorrupted players. Finally, the zero-knowledge property is invoked to simulate the proofs that these c i are correct.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Some auxiliary protocols</head><p>Suppose a prover P presents a skeptical verifier V with a ciphertext c and claims that it encodes plaintext i, or more precisely that he knows r such that c = E(i, r ). A trivial way to convince V would be to reveal also the random choice r , then V can verify himself that c = E(i, r ) = (1 + n) i r n s mod n s+1 . However, for use in the following, we need a solution where no extra useful information is revealed.</p><p>It is easy to see that this is equivalent to convincing V that c(1 + n) -i mod n s+1 is an encryption of 0, or equivalently that it is an n s th power. So we now propose a protocol for this purpose, which is a simple generalization of the one from <ref type="bibr" target="#b12">[13]</ref>.</p><p>We note that this and the following protocols are not zero-knowledge as they stand, only honest verifier zeroknowledge. However, first zero-knowledge protocols for the same problems can be constructed from them using standard methods and secondly, in our applications, we will always be using them in a non-interactive variant based on the Fiat-Shamir heuristic, which means that we cannot obtain zeroknowledge, we can, however, obtain security in the random oracle model. As for soundness, we prove that the protocols satisfy so called special soundness (see <ref type="bibr" target="#b3">[4]</ref>), which in particular implies that they satisfy standard knowledge soundness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Protocol for n s th powers</head><formula xml:id="formula_33">Input: n, u. Private Input for P : v ∈ Z * n , such that u = E(0, v).</formula><p>1. P chooses r at random in Z * n and sends a = E(0, r ) to V . 2. V chooses e, a random t bit number, and sends e to P. 3. P sends z = r v e mod n to V. V checks that u, a, z are prime to n and that E(0, z) = au e mod n s+1 , and accepts if and only if this is the case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>It is now simple to show</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 3</head><p>The above protocol is complete, honest verifier zero-knowledge, and satisfies that from any pair of accepting conversations (between V and any prover) of form (a, e, z), (a, e , z ) with e = e , one can efficiently compute an v such that u = E(0, v), provided 2 t is smaller than the smallest prime factor of n.</p><p>Proof For completeness, we just plug into the equation that V checks, by Lemma 2 we get au e = E(0, r )E(0, v) e = E(0, r v e mod n) = E(0, z) mod n s+1 . For honest verifier simulation, the simulator chooses a random z ∈ Z * n , a random e, sets a = E(0, z)u -e mod n s+1 and outputs (a, e, z). This is easily seen to be a perfect simulation.</p><p>For the last claim, observe that since the conversations are accepting, we have E(0, z) = au e mod n s+1 and E(0, z ) = au e mod n s+1 , so we get E(0, z/z mod n) = u e-e mod n s+1 .</p><p>Since ee is prime to n by the assumption on 2 t , choose α, β such that αn s + β(ee ) = 1. Let ū = u mod n and set v = ūα (z/z ) β mod n. Notice that u n s mod n s+1 = E(0, u mod n) = E(0, ū). We then get E(0, v)= E(0, ū) α E(0, z/z ) β = u αn s u β(e-e ) = u mod n s+1 , so that v is indeed the desired n s th root of u.</p><p>In our application of this protocol, the modulus n will be chosen by a trusted party or by a multiparty computation such that n has two prime factors of roughly the same size. Hence, if k is the bit length of n, we can set t = k/2 and be assured that a cheating prover can make the verifier accept with probability ≤ 2 -t .</p><p>The lemma immediately implies, using the techniques from <ref type="bibr" target="#b3">[4]</ref>, that we can build an efficient proof that an encryption contains one of two given values, without revealing which one it is: given the encryption C and the two candidate plaintexts i 1 , i 2 , prover and verifier compute u 1 = C/g i 1 mod n s+1 , u 2 = C/g i 2 mod n s+1 , and the prover shows that either u 1 or u 2 encrypt 0 and also proves knowledge of one of the corresponding n s th roots. This can be done using the following protocol, where we assume without loss of generality that the prover knows v 1 such that u 1 = E(0, v 1 ), and where M denotes the honest verifier simulator for the n s -power protocol above: Protocol 1-out-of-2 n s th power Input: n, u 1 , u 2 . Private Input for P : v 1 , such that u 1 = E(0, v 1 ).</p><p>1. P chooses r 1 at random in Z * n . He invokes M on input n, u 2 to get a conversation a 2 , e 2 , z 2 . He sends a 1 = E(0, r 1 ), a 2 to V . 2. V chooses s, a random t bit number, and sends s to P. 3. P computes e 1 = se 2 mod 2 t and z 1 = r 1 v e 1 1 mod n. He then sends e 1 , z 1 , e 2 , z 2 to V . 4. V checks that s = e 1 + e 2 mod 2 t , E(0, z 1 ) = a 1 u e 1 1 mod n s+1 , E(0, z 2 ) = a 2 u e 2 2 mod n s+1 , and u 1 , u 2 , a 1 , a 2 , z 1 , z 2 are relatively prime to n. He accepts if and only if this is the case.</p><p>The proof techniques from <ref type="bibr" target="#b3">[4]</ref> and Lemma 3 immediately imply Lemma 4 Protocol 1-out-of-2 n s 'th power is complete, honest verifier zero-knowledge, and satisfies that from any pair of accepting conversations (between V and any prover) of form (a 1 , a 2 , s, e 1 , z 1 , e 2 , z 2 ), (a 1 , a 2 , s , e 1 , z 1 , e 2 , z 2 ) with s = s , one can efficiently compute v, such that either u 1 = E(0, v) or u 2 = E(0, v), provided 2 t is less than the smallest prime factor of n.</p><p>Our final building block allows a prover to convince a verifier that three encryptions contain values a, b and c such that c = ab mod n s . For this, we propose a protocol inspired by a similar construction found in <ref type="bibr" target="#b4">[5]</ref>.   The protocols from this section can be made non-interactive using the standard Fiat-Shamir heuristic of computing the challenge from the first message using a hash function. This can be proved secure in the random oracle model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Protocol Multiplication-mod-n s</head><p>Furthermore, although the protocols here have been phrased so that they can be used to prove statements on values encrypted in DJN s , they can also be directly used in the same way for values encrypted under the more efficient variant DJN s . This follows from the fact that if for a given u ∈ Z * n s+1 , you know i, ṽ such that u = Ẽ(i, ṽ), we have that u = E(i, h ṽ mod n), in other words you can efficiently compute v such that u = E(i, v). Thus, a prover can use u in any of the above protocols pretending it was encrypted using DJN s . Note that this applies to both ciphertexts that are input to the protocols, and those that are generated by the prover during executions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Efficient electronic voting</head><p>In <ref type="bibr" target="#b6">[7]</ref>, a general model for elections was used, which we briefly recall here: we have a set of voters V 1 , . . . , V M , a bulletin board B, and a set of tallying authorities A 1 , . . . , A v . The bulletin board is assumed to function as follows: every player can write to B, and a message cannot be deleted once it is written. All players can access all messages written, and can identify which player each message comes from. This can all be implemented in a secure way for instance using an already existing public-key infrastructure and server replication to prevent denial of service attacks. We assume that the purpose of the vote is to elect a winner among L candidates and that each voter is allowed to vote for t &lt; L candidates.</p><p>In the following, h will denote a fixed hash function used to make non-interactive proofs according to the Fiat-Shamir heuristic. Also, we will assume throughout that an instance of the threshold version of Paillier's scheme with public key n, g has been set up, with the A i 's acting as decryption servers. We will assume that n s &gt; M L , which can always be made true by choosing s or n large enough.</p><p>The notation Proof P (S), where S is some logical statement will denote a bit string created by player P as follows: P selects the appropriate protocol from the previous section that can be used to interactively prove S. He computes the first message a in this protocol, computes e = h(a, S, I D(P)) where I D(P) is his user identity in the system and, taking the result of this as the challenge from the verifier, computes the answer z. Then Proof P (S) = (e, z). The inclusion of I D(P) in the input to h is done in order to prevent vote duplication. To check such a proof, note that all the auxiliary protocols are such that from S, z, c one can easily compute what a should have been, had the proof been correct. For instance, for the protocol for n s powers, the statement consists of a single number u modulo n s+1 , and the verifier checks that z n s = au e mod n s+1 , so we have a = z n s u -e mod n s+1 . Once a is computed, one checks that e = h(a, S, I D(P)).</p><p>A protocol for the case L = 2 is now simple to describe. This is equivalent to a yes/no vote and so each vote can be thought of as a number equal to 0 for no and 1 for yes: 1. Each voter V i decides on his vote v i , he calculates E i = E(v i , r i ), where r i is randomly chosen. He also creates</p><formula xml:id="formula_34">Proof V i (E i or E i /(1 + n) is an encryption of 0)</formula><p>based on the 1-out-of-2 n s th power protocol. He writes the encrypted vote and proof to B. 2. Each A j does the following: first set E = 1. Then for all i: check the proof written by V i on B and if is it valid, then E := E • E i mod n s+1 . Finally, A j executes his part of the threshold decryption protocol, using E as the input ciphertext, and writes his result to B. 3. From the messages written by the A j s, anyone can now reconstruct the plaintext corresponding to E (possibly after discarding invalid messages). Assuming for simplicity that all votes are valid, it is evident that</p><formula xml:id="formula_35">E = i E(v i , r i ) = E( i v i mod n s , i r i mod n). So the decryption result is i v i mod n s which is i v i since n s &gt; M.</formula><p>Security of this protocol (in the random oracle model) can be proved based on the security results we have shown for the sub-protocols used and based on semantic security of Paillier's encryption scheme. Since the voting schemes in this paper play the role of example applications of our cryptosystem and auxiliary protocols we do not give a formal proof here. However, in <ref type="bibr" target="#b11">[12]</ref>, Groth presents a full proof of security for our voting scheme according to the definition of Canetti.</p><p>There are several ways to generalize this to L &gt; 2. Probably, the simplest way is to hold L parallel yes/no votes as above. A voter votes 1 for the candidates he wants, and 0 for the others. This means that V i will send L votes of the following form (where j = 1, . . . , L):</p><formula xml:id="formula_36">E i j = E(v i j , r i j ), Proof V i (E i j orE i j /(1 + n) is an encryption of 0).</formula><p>To prove that he voted for exactly t candidates, he also writes to B the number j r i j mod n. This allows the talliers to verify that j E(v i j , r i j ) is an encryption of t. This check is sufficient, since all individual votes are proved to be 0 or 1. It is immediate that decryption of the L results will give the number of votes each candidate received.</p><p>The size of a vote in this protocol is seen to be O(Lk), where k is the bit length of n, by simple inspection of the protocol. The protocol requires L decryption operations. As a numeric example, suppose we have k = 1,000, M = 64,000, L = 64, s = 1 and we use challenges of 80 bits in the proofs. Then, a vote in the above system has size about 32 KB.</p><p>We note that this easily generalizes to cases where voters are allowed to vote for up to t candidates: one simply introduces t "dummy candidates" in addition to the actual L. We then execute the protocol as before, but with t + L candidates. Each voter places the votes he does not want to use on dummy candidates.</p><p>A more efficient method for large t is to add only 1 dummy candidate who is to receive all unused votes. Each voter must still prove that the product of all his encryptions decrypts to t. So it is sufficient to prove in addition that the number of votes on the dummy candidate is small enough in order that a reduction modulo n s cannot take place when the votes of this voter are added. This can be done by taking the bit string representing the number of votes on the dummy candidate: b 0 , . . . , b l where 2 l ≤ t &lt; 2 l+1 . The voter then makes encryptions e i j = E(b j 2 j , r i j ) for all 0 ≤ j ≤ l and makes a proof for each of these: Proof V i (e i j ore i j /(1 + n) 2 j is an encryption of 0).</p><p>The votes for the dummy candidate can then be calculated as E i L = l i=0 e i . Then, it is verified as above that L i=0 E i j is the encryption of t. This only uses L + 1 blocks and L + log t proofs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">A variant with smaller vote size</head><p>If the parameters are such that L log 2 M &lt; (k -1) • s and t = 1, then we can do significantly better than above. These conditions will be satisfied in many realistic situations, such as for instance in the numeric example above.</p><p>The basic idea is the following: a vote for candidate j, where 0 ≤ j &lt; L, is defined to be an encryption of the number M j . Each voter will create such an encryption and prove its correctness as detailed below. When all these encryptions are multiplied we get an encryption of a number of form a = L j=0 a j M j mod n s , where a j is the number of votes cast for candidate j. Since L log 2 M &lt; (k-1)•s so that M L &lt; n s , this relation also holds over the integers, so decrypting and writing a in M-ary notation will directly produce all the a j 's. It remains to describe how to produce an encryption hiding a number of form M j , for some 0 ≤ j &lt; L, and prove it was correctly formed. We do this in the following two subsections.</p><p>We note that this idea generalizes to t &gt; 1, at some loss of efficiency: we simply allow each voter to cast t votes, each of the form just described. If we want to prevent voters from voting for the same candidate t times, we can use the homomorphic property to compute encryptions of all pairwise differences of votes, and the voter must prove that these are all non-zero. To show that m is non-zero, given the encryption E(m, r ), the voter provides an encryption E(m -1 mod n s , r ) and uses the multiplication-mod-n s protocol to prove that the product of the two plaintexts is 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The case of L = 2 l+1</head><p>For simplicity, we will first describe how to prove correctness of a vote in the case where L is of the form L = 2 l+1 for some l, and treat the general case below. Let b 0 , . . . , b l be the bits in the binary representation of j, i.e., j = b 0 2 0 + b 1 2 1 + • • • + b l 2 l . Then, clearly we have M j = (M 2 0 ) b 0 • . . . • (M 2 l ) b l . Each factor in this product is either 1 or a power of M. This is used in the following algorithm for producing the desired proof (where P denotes the prover):</p><p>1. P computes encryptions e 0 , . . . , e l of (M 2 0 ) b 0 , . . . , (M 2 l ) b l . For each i = 0, . . . , l he also computes Proof P (e i /(1 + n)ore i /(1 + n) M 2 i is an encryption of 0). 2. Let F i = (M 2 0 ) b 0 • . . . • (M 2 i ) b i , for i = 0, . . . , l.P computes an encryption f i of F i , for i = 1, . . . , l. We set f 0 = e 0 . Now, for i = 1, . . . , l, P computes Proof P (Plaintexts corr. to f i-1 , e i , f i satisfy</p><formula xml:id="formula_37">F i-1 • (M 2 i ) b i = F i mod n s ),</formula><p>based on the multiplication-mod-n s protocol. The encryption f l is the desired encryption.</p><p>It is straightforward to verity from the e i , f i and all the proofs computed that f l is an encryption of a number of form M j . Furthermore, simply because there are l + 1 encryptions e 0 , . . . , e l each determining one bit of j, it is clear that 0 ≤ j &lt; 2 l+1 = L.</p><p>It is straightforward to see that a vote in this system will have length O(k log L) bits (still assuming, of course, that L log 2 M ≤ (k -1) • s).</p><p>With parameter values as in the numeric example before, a vote will have size about 7 KB, a factor of almost 5 better than the previous system. Moreover, we need only 1 decryption operation as opposed to L before.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The case of general L</head><p>If L is not of the nice form we assumed above, we may attempt to adapt the above solution as follows: first define l by: 2 l+1 is the smallest 2-power with 2 l+1 &gt; L, and then run the above protocol with no further changes. There are two drawbacks to this idea: first, it allows voters to vote for nonexisting candidates, namely js for which L ≤ j &lt; 2 l+1 , and second this also implies that we must have 2 l+1 log 2 M ≤ (k -1) • s, otherwise we may get overflow when votes are added, and the result will be incorrect. If we could prevent voters from voting for non-existing candidates, we would only need L log 2 M ≤ (k -1) • s, so this simple-minded solution may force us to have a block length larger than what is strictly necessary, in the worst case almost twice as large.</p><p>One way to get around this is to add an extra step to the verification of a vote where, given the encryptions e 0 , . . . , e l determining the bits of j, the voter proves in zero-knowledge that j &lt; L.</p><p>To this end, first recall that we defined j = b 0 2 0 + b 1 2 1 + • • • + b l 2 l , and that for each encryption e i that is</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Input: n, g, e a , e b , e c Private Input for P : a, b, c, r a , r b , r c such that c = ab mod n and e a = E(a, r a ), e b = E(b, r b ), e c = E(c, r c ) 1. P chooses random values d ∈ Z n s , r d , r db ∈ Z * n and sends to V encryptions e d = E(d, r d ), e db = E(db, r db ). 2. V chooses e, a random t-bit number, and sends it to P. 3. P opens the encryption e e a e d = E(ea + d mod n s , r e a r d mod n) by sending f = ea + d mod n s and z 1 = r e a r d mod n. Finally, P opens the encryption e f b (e db e e c ) -1 = E(0, r f b (r db r e c ) -1 mod n) by sending z 2 = r f b (r db r e c ) -1 mod n.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>, and generates the right distribution because the values f, z 1 , z 2 , e are also independent and random in the real conversation. For the last claim, note first that since encryptions uniquely determine plaintexts, there are fixed values a, b, c, d contained in e a , e b , e c , e d , and a value x contained in e db . The fact that the conversations given are accepting implies that f = ea + d mod n s , f = e a + d mod n s , f bxec = 0 = f bxe c mod n s . Putting this together, we obtain ( ff )b = (ee )c mod n s or (ee )ab = (ee )c mod n s . Now, since (e-e ) is invertible modulo n s by the assumption on 2 t , we can conclude that c = ab mod n s (and also compute a, b and c).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1</head><label>1</label><figDesc>Comparison with 2048 bit plaintext size, using java implementation</figDesc><table><row><cell></cell><cell>El-Gamal</cell><cell cols="2">Generalized Paillier</cell><cell>RSA</cell></row><row><cell></cell><cell></cell><cell>s = 1</cell><cell>s = 2</cell><cell></cell></row><row><cell>Security</cell><cell>2048</cell><cell>2048</cell><cell>1024</cell><cell>2048</cell></row><row><cell>Ciphertext size</cell><cell>4096</cell><cell>4096</cell><cell>3072</cell><cell>2048</cell></row><row><cell>Expansion factor</cell><cell>2</cell><cell>2</cell><cell>1.5</cell><cell>1</cell></row><row><cell>Encryption (ms)</cell><cell>1980</cell><cell>1969</cell><cell>578</cell><cell>8</cell></row><row><cell>Decryption (ms)</cell><cell>996</cell><cell>1030</cell><cell>312</cell><cell>272</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2</head><label>2</label><figDesc>Comparison with 4096 bit plaintext size, using java implementation</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell>El-Gamal</cell><cell cols="2">Generalized Paillier</cell><cell></cell><cell>RSA</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>s = 1</cell><cell>s = 2</cell><cell>s = 3</cell><cell>s = 4</cell></row><row><cell></cell><cell></cell><cell>Security</cell><cell>4096</cell><cell>4096</cell><cell>2048</cell><cell>1366</cell><cell>1024</cell><cell>4096</cell></row><row><cell></cell><cell></cell><cell>Ciphertext size</cell><cell>8192</cell><cell>8192</cell><cell>6144</cell><cell>5462</cell><cell>5120</cell><cell>4096</cell></row><row><cell></cell><cell></cell><cell>Expansion factor</cell><cell>2</cell><cell>2</cell><cell>1.5</cell><cell>1.33</cell><cell>1.25</cell><cell>1</cell></row><row><cell></cell><cell></cell><cell>Encryption (ms)</cell><cell>15205</cell><cell>15264</cell><cell>4397</cell><cell>2370</cell><cell>1591</cell><cell>32</cell></row><row><cell></cell><cell></cell><cell>Decryption (ms)</cell><cell>7611</cell><cell>7779</cell><cell>2290</cell><cell>1281</cell><cell>873</cell><cell>2001</cell></row><row><cell cols="4">Table 3 Ms per bit encrypted/decrypted on a 750 MHz Pentium III</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">using java implementation</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="3">Security parameter El-Gamal Generalized Paillier</cell><cell>RSA</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>s = 1 s = 2 s = 4</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Encryption</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>1024</cell><cell>0.264</cell><cell>0.262 0.284 0.387</cell><cell>0.002</cell><cell></cell><cell></cell><cell></cell></row><row><cell>2048</cell><cell>0.967</cell><cell>0.955 1.067 1.480</cell><cell>0.004</cell><cell></cell><cell></cell><cell></cell></row><row><cell>4096</cell><cell>3.711</cell><cell>3.705 4.146 5.755</cell><cell>0.008</cell><cell></cell><cell></cell><cell></cell></row><row><cell>8192</cell><cell>14.467</cell><cell>14.507 16.244 22.617</cell><cell>0.015</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Decryption</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>1024</cell><cell>0.132</cell><cell>0.149 0.153 0.214</cell><cell>0.039</cell><cell></cell><cell></cell><cell></cell></row><row><cell>2048</cell><cell>0.489</cell><cell>0.503 0.559 0.780</cell><cell>0.132</cell><cell></cell><cell></cell><cell></cell></row><row><cell>4096</cell><cell>1.865</cell><cell>1.898 2.128 2.958</cell><cell>0.486</cell><cell></cell><cell></cell><cell></cell></row><row><cell>8192</cell><cell>7.286</cell><cell>7.349 8.244 11.461</cell><cell>1.854</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc><ref type="bibr" target="#b3">4</ref>. V verifies that the openings of encryptions in the previous step were correct, that all values sent by P are relatively prime to n, and accepts if and only if this was the case. , e db , e, f, z 1 , z 2 ), (e d , e db , e , f , z 1 , z 2 ) with e = e , one can efficiently compute the plaintexts a, b, c corresponding to e a , e b , e c such that c = ab mod n s , provided 2 t is smaller than the smallest prime factor in n.Proof Completeness is clear by inspection of the protocol. For honest verifier zero-knowledge, observe that the equations checked by V are e e a e d = E( f, z 1 ) mod n s+1 and e f b (e db e e c ) -1 = E(0, z 2 ) mod n s+1 . From this, it is clear that we can generate a conversation by choosing first f, z 1 , z 2 , e at random, and then computing e d , e db that will satisfy the equations. This only requires inversion modulo n s+1</figDesc><table><row><cell>Lemma 5 Protocol Multiplication-mod-n s is complete, hon-</cell></row><row><cell>est verifier zero-knowledge, and satisfies that from any pair of</cell></row><row><cell>accepting conversations (between V and any prover) of form</cell></row><row><cell>(e d</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>All complexities given here assume that the length of challenges for the zero-knowledge proofs is at most k.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Strictly speaking, we also need that s &lt; p, q, but this is insignificant since in practice, s will always be much smaller than p, q</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>In fact the random oracle will be needed only to ensure that the noninteractive proofs of correctness of shares will work. Doing these proofs interactively instead would allow us to dispense with the random oracle.</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>provided, it is shown that it encrypts M b i 2 i . Define β i = (M 2 i -1) -1 mod n s . It is now easy to see that</p><p>is an encryption of b i in DJN 1 , and furthermore a verifier can compute this value without interaction, from already public information. Going to DJN 1 means that the complexity of the protocol to follow becomes independent of s. From this point, there are several ways to proceed, we sketch one simple option here: Let L be represented by bits B 0 , . . . , B l . We can now exploit the following fact:</p><p>and 0 otherwise. Since B i is public, the verifier can compute an encryption of d i from e i without interaction. Clearly, the product</p><p>It is also easy to see that by providing encryptions of the values</p><p>and of the D i 's, the prover can show that the encryptions of the D i 's contain correct values, using 2l multiplication proofs. Finally, the prover needs to show that one of the D i = 1 for some i. This can be done by a trivial generalization of the one-of-two protocol we showed earlier. In total, this solution will have complexity O(k log L) bits (assuming that L log 2 M ≤ (k-1)•s). This is asymptotically the same as before, but with a larger constant. We note that Lipmaa et al. in <ref type="bibr" target="#b14">[15]</ref> have recently proposed a conceptually simpler solution for general L, which is more efficient than ours by a constant factor.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A simple secure unpredictable pseudo-random number generator</title>
		<author>
			<persName><forename type="first">L</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Shub</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="364" to="383" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Practical multi-candidate election scheme</title>
		<author>
			<persName><forename type="first">O</forename><surname>Baudron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P.-A</forename><surname>Fouque</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pointcheval</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Poupard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Stern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of PODC</title>
		<meeting>PODC</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Multiparty computation from threshold homomorphic encryption</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cramer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Nielsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EuroCrypt</title>
		<meeting>EuroCrypt</meeting>
		<imprint>
			<publisher>Springer Verlag LNCS</publisher>
			<date type="published" when="2001">2001. 2045</date>
			<biblScope unit="page" from="280" to="300" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Proofs of partial knowledge</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cramer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Schoenmakers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Crypto 94</title>
		<meeting>Crypto 94</meeting>
		<imprint>
			<publisher>Springer Verlag LNCS</publisher>
			<biblScope unit="page">839</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Efficient multiparty computations secure against an adaptive adversary</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cramer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dziembowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hirt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Rabin</surname></persName>
		</author>
		<idno>LNCS series 1592</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EuroCrypt 99</title>
		<meeting>EuroCrypt 99</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<biblScope unit="page" from="311" to="326" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The bit security and Paillier&apos;s encryption scheme and its applications</title>
		<author>
			<persName><forename type="first">D</forename><surname>Catalano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Howgrave-Graham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EuroCrypt</title>
		<meeting>EuroCrypt</meeting>
		<imprint>
			<publisher>Springer Verlag LNCS</publisher>
			<date type="published" when="2001">2001. 2045</date>
			<biblScope unit="page" from="229" to="243" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A secure and optimally efficient multi-authority election scheme</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cramer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Schoenmakers</surname></persName>
		</author>
		<idno>LNCS series 1233</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EuroCrypt 97</title>
		<meeting>EuroCrypt 97</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<biblScope unit="page" from="103" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A generalisation, a simplification and some applications of Paillier&apos;s probabilistic public-Key system</title>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jurik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Public Key Cryptography</title>
		<meeting>Public Key Cryptography</meeting>
		<imprint>
			<publisher>Springer Verlag LNCS series</publisher>
			<date type="published" when="1992">2001. 1992</date>
			<biblScope unit="page" from="119" to="136" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Practical threshold RSA signatures without a trusted dealer</title>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Koprowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EuroCrypt</title>
		<meeting>EuroCrypt</meeting>
		<imprint>
			<publisher>Springer Verlag LNCS</publisher>
			<date type="published" when="2001">2001. 2045</date>
			<biblScope unit="page" from="152" to="165" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Sharing decryption in the context of voting or lotteries</title>
		<author>
			<persName><forename type="first">P.-A</forename><surname>Fouque</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Poupard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Stern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Financial Crypto</title>
		<meeting>Financial Crypto</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">On the Security of Modular Exponentiation with Application to the Construction of Pseudorandom Generators. Cryptology ePrint Archive, record</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Rosen</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
		<imprint>
			<date type="published" when="2000-12">2000/064. 2000, Dec</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Extracting Witnesses from Proofs of Knowledge in the Random Oracle Model</title>
		<author>
			<persName><forename type="first">J</forename><surname>Groth</surname></persName>
		</author>
		<idno>nr. 2002/002</idno>
		<imprint/>
	</monogr>
	<note type="report_type">Eprint archive report</note>
	<note>Manuscript (2001, Dec</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A practical zero-knowledge protocol fitted to security microprocessor minimizing both transmission and memory</title>
		<author>
			<persName><forename type="first">L</forename><surname>Guillou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-J</forename><surname>Quisquater</surname></persName>
		</author>
		<idno>LNCS series 330</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EuroCrypt 88</title>
		<meeting>EuroCrypt 88</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<biblScope unit="page" from="123" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Efficient receipt-free voting based on homomorphic encryption</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hirt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sako</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EuroCrypt 2000</title>
		<meeting>EuroCrypt 2000</meeting>
		<imprint>
			<publisher>Springer Verlag LNCS</publisher>
			<biblScope unit="page">1807</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Secure Vickrey Auctions without Threshold Trust</title>
		<author>
			<persName><forename type="first">H</forename><surname>Lipmaa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Asokan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Niemi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Eprint archive</title>
		<imprint>
			<biblScope unit="page">95</biblScope>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Public-key cryptosystems based on composite degree residue classes</title>
		<author>
			<persName><forename type="first">P</forename><surname>Paillier</surname></persName>
		</author>
		<idno>LNCS series 1592</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EuroCrypt 99</title>
		<meeting>EuroCrypt 99</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<biblScope unit="page" from="223" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Practical threshold signatures</title>
		<author>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Euro-Crypt</title>
		<meeting>Euro-Crypt</meeting>
		<imprint>
			<publisher>Springer Verlag LNCS series</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page">1807</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Non-cryptographic fault-tolerant computing in a constant number of rounds</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bar-Ilan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Beaver</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Principles of Distributed Computation</title>
		<meeting>the ACM Symposium on Principles of Distributed Computation</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="201" to="209" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
