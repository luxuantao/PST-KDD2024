<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main"></title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">A11995D5DB1576E2EFA7F95909EB13E6</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:19+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract/>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Embryonics: A New Methodology for Designing Field-Programmable Gate Arrays with Self-Repair and Self-Replicating Properties Daniel Mange, Member, IEEE, Eduardo Sanchez, Member, IEEE, André Stauffer, Member, IEEE, Gianluca Tempesti, Member, IEEE, Pierre Marchal, Member, IEEE, and Christian Piguet</p><p>Abstract-The growth and the operation of all living beings are directed through the interpretation, in each of their cells, of a chemical program, the DNA string or genome. This process is the source of inspiration for the Embryonics (embryonic electronics) project, whose final objective is the conception of very large scale integrated circuits endowed with properties usually associated with the living world: self-repair (cicatrization) and self-replication. We will begin by showing that any logic system can be represented by an ordered binary decision diagram (OBDD), and then embedded into a fine-grained field-programmable gate array (FPGA) whose basic cell is a multiplexer with programmable connections. The cellular array thus obtained is perfectly homogeneous: the function of each cell is defined by a configuration (or gene) and all the genes in the array, each associated with a pair of coordinates, make up the blueprint (or genome) of the artificial organism. In the second part of the project, we add to the basic cell a memory and an interpreter to, respectively, store and decode the complete genome. The interpreter extracts from the genome the gene of a particular cell as a function of its position in the array (its coordinates) and thus determines the exact configuration of the relative multiplexer. The considerable redundancy introduced by the presence of a genome in each cell has significant advantages: self-replication (the automatic production of one or more copies of the original organism) and self-repair (the automatic repair of one or more faulty cells) become relatively simple operations. The multiplexer-based FPGA cell and the interpreter are finally embedded into an electronic module; an array of such modules make it possible to demonstrate self-repair and self-replication. Index Terms-Embryonic electronics, field-programmable gate arrays (FPGA's), multiplexer-based FPGA's, ordered binary decision diagrams, self-repairing FPGA's, self-replicating FPGA's.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Toward Embryonics</head><p>A HUMAN being consists of approximately 60 trillion (60 10 12 ) cells. At each instant, in each of these 60 trillion cells, the genome, a ribbon of 2 billion characters, is decoded to produce the proteins needed for the survival of the organism. This genome contains the ensemble of the genetic inheritance of the individual and, at the same time, the instructions for both the construction and the operation of the organism. The parallel execution of 60 trillion genomes in as many cells occurs ceaselessly from the conception to the death of the individual. Faults are rare and, in the majority of cases, successfully detected and repaired. This process is remarkable for its complexity and its precision. Moreover, it relies on completely discrete processes: the chemical structure of DNA (the chemical substrate of the genome) is a sequence of four bases, usually designated with the letters A (adenine), C (cytosine), G (guanine), and T (thymine).</p><p>Our research is inspired by the basic processes of molecular biology <ref type="bibr" target="#b15">[16]</ref>. By adopting certain features of cellular organization, and by transposing them to the two-dimensional (2-D) world of integrated circuits on silicon, we will show that properties unique to the living world, such as selfreplication and self-repair, can also be applied to artificial objects (integrated circuits).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Objectives and Strategy</head><p>Our final objective is the development of very large scale integrated (VLSI) circuits capable of self-repair and selfreplication. These two properties seem particularly desirable for complex artificial systems meant for hostile (nuclear plants) or inaccessible (space) environments. Self-replication allows the complete reconstruction of the original device in case of a major fault, while self-repair allows a partial reconstruction in case of a minor fault.</p><p>Section II introduces the fundamental features of the Embryonics project (for embryonic electronics), which is based on a general hypothesis, defining the silicon environment in which the quasi-biological development occurs, and on three features, which roughly mimic the process of cellular development: multicellular organization, cellular differentiation, and cellular division.</p><p>To represent and implement a given digital system on a FPGA we select, in Section III, an efficient and universal representation: the ordered binary decision diagram (OBDD). We will show that the use of such a representation greatly simplifies the realization of a new family of FPGA's, based on a fine-grained cell. This cell, called MUXTREE, contains essentially a multiplexer with one control variable and a nontrivial programmable connection network. Section IV describes in detail the MUXTREE cell, which in fact constitutes the application layer of the FPGA, and its 20 configuration bits. According to our biological approach, these 20 bits are the gene of the cell and all the genes of a given digital system are its genome.</p><p>Section V introduces the two configuration layers which will perform the computation of the gene of each cell. The first layer computes the coordinates of a given cell from the coordinates of its neighbors. The second layer determines, from the complete genome and from the local coordinates of the cell, its gene. This is the equivalent of the process of cellular differentiation, and is implemented through the use a very simple binary decision machine, which we call NANOPASCALINE, charged with the execution of the GENOME program. Finally, Section VI briefly describes the realization of the cellular division process, that is, the duplication of the genome of a mother cell into one or two neighboring daughter cells.</p><p>The final cell, made up of an application layer (MUX-TREE) and two configuration layers (NANOPASCALINE), is finally embedded into a demonstration module: the BIODULE. Section VII shows that any given digital system implemented by an array of BIODULES is endowed with the properties of self-repair and self-replication. Section VIII illustrates the limitations of the current project and outlines the ongoing research, aimed at the development of an integrated circuit endowed with quasi-biological properties.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. THE FOUNDATIONS OF EMBRYONICS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. The General Hypothesis about the Environment</head><p>The general hypothesis describes the environment in which the quasi-biological development occurs. In the framework of electronics, it consists of a finite (but as large as desired) 2-D space of silicon, divided into rows and columns. The intersection of a row and a column defines a cell, and all cells have an identical structure, i.e., an identical network of connections and an identical set of logic operators. The physical space or cellular array is therefore homogeneous, that is, made up of absolutely identical cells: only the state of a cell can differentiate it from its neighbors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. First Feature: Multicellular Organization</head><p>The first feature is that of multicellular organization: the artificial organism is divided into a finite number of cells [Fig. <ref type="figure" target="#fig_0">1(a)</ref>], where each cell realizes a unique function, determined by a number called the gene of the cell. Fig. <ref type="figure" target="#fig_0">1(a)</ref> illustrates the example of a simple artificial organism, an up-down counter, realized with nine cells, each cell being defined by a different gene (a five-digit hexadecimal number). The calculation of these genes will be analyzed in detail later.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Second Feature: Cellular Differentiation</head><p>Let us call genome the set of all the genes of an artificial organism, where each gene is characterized by its value and In summary, storing the whole genome in each cell makes this cell universal: it can realize any gene of the genome, given the proper coordinates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Third Feature: Cellular Division</head><p>At startup, the mother cell [Fig. <ref type="figure" target="#fig_0">1(b)</ref>], arbitrarily defined as having coordinates , holds the one and only copy of the genome. At time , the genome of the mother cell is copied into the two neighboring (daughter) cells to the north and to the east. The process then continues until the 2-D space is completely programmed. In our example, the furthest cell is programmed at time .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. SYNTHESIS OF ORDERED BINARY DECISION DIAGRAMS (OBDD)</head><p>To fit our demands, we needed to find a method capable of generating, starting from a set of specifications, the configu-ration for a homogeneous network of cells, where each cell is defined by an identical architecture and a usually distinct function (gene).</p><p>To meet our requirements, we have selected a particular representation: the ordered binary decision diagram (OBDD). This representation, with its well-known intrinsic properties such as canonicity <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b3">[4]</ref>, was chosen for two main reasons [see, for example, Fig. <ref type="figure" target="#fig_1">2(c</ref>)]: on one hand, it is a graphical representation which exploits well the 2-D space and immediately suggests a physical realization on silicon; on the other hand, its structure leads us to a natural decomposition into cells realizing a logic test (a diamond), easily implemented by a multiplexer.</p><p>We will illustrate the handling of ordered binary decision diagrams through a simple example, an up-down counter. Our choice will lead us to define our new FPGA as a homogenous array where each cell contains a programmable multiplexer with one control variable, implementing precisely a logic test. Such an FPGA is said to be fine-grained.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Example of a Modulo-4 Up-Down Counter</head><p>As an example, let us consider the realization of the abovementioned modulo-4 up-down counter, defined by the following sequences: for (counting up); for (counting down) <ref type="bibr" target="#b0">(1)</ref> This definition is equivalent to the two state tables of Fig. <ref type="figure" target="#fig_1">2</ref>(a), defining the future states and .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Ordered Binary Decision Trees and Diagrams</head><p>We define a complete (or canonical) binary decision tree as a tree for variables having branches corresponding to the possible input states; for the tree of Fig. <ref type="figure" target="#fig_1">2(b),</ref><ref type="figure">representing</ref> , we have and . Each test element of the tree is represented by a diamond and defined by a test variable: it has a single input, a "true" output (test variable equal to "1") and a "complemented" output (test variable equal to "0"), identified by a small circle. The leaf elements, represented as squares, define the output value of the given function ( in our example).</p><p>In our case, the use of Karnaugh maps for simplifying trees <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref> shows that no simplification of is possible (Fig. <ref type="figure" target="#fig_1">2(a)</ref>: there is no block, i.e., no pattern formed by adjacent "0"'s or "1"'s). On the other hand, the Karnaugh map for [Fig. <ref type="figure" target="#fig_1">2(a)</ref>] reveals one block of four "0"'s and one block of four "1"'s, which gives us to the minimal simplified tree of Fig. The sharing of identical subtrees implies the convergence of branches of the tree and its transformation into a new representation: the binary decision diagram (BDD). Finally, the sharing of a subtree (ST0) belonging to the two functions and and the permutation of the "0" and "1" outputs of certain diamonds lead us to the final diagram of Fig. <ref type="figure" target="#fig_1">2(c</ref>), which represents a forest of binary decision diagrams.</p><p>In the above discussion, we have implied that the binary decision diagrams and trees were ordered, that is, characterized by a fixed position for the test variables: at the lower level, at the middle level, and at the upper level. Using Bryant's notation <ref type="bibr" target="#b3">[4]</ref>, we will write <ref type="bibr" target="#b1">(2)</ref> It can be observed that all logic systems, combinational or sequential, of variables will require a cellular network of rows. On the other hand, the minimal number of columns will depend on the simplification method adopted to obtain the ordered binary decision diagrams from the original specifications. For problems of up to six variables, the Karnaugh map allows a relatively simple manual computation <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref>. Beyond six variables, more complex analytical methods require the use of a computer <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b4">[5]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Hardware Implementation</head><p>Our design decision has been to implement directly the ordered binary decision diagrams on silicon, and to build our fine-grained basic cell around a test element (a diamond). Such an implementation is possible if one replaces each test element with a 2-to-1 multiplexer, keeps the same interconnection diagram, and assigns the values of the leaf elements to the corresponding multiplexer inputs <ref type="bibr" target="#b7">[8]</ref>. Fig. <ref type="figure" target="#fig_1">2(d)</ref> shows the direct multiplexer implementation of the up-down counter. The two state functions and are available at the outputs of the top multiplexers: the ordered diagrams of Fig. <ref type="figure" target="#fig_1">2(c</ref>) are read bottom-up in Fig. <ref type="figure" target="#fig_1">2(d)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. A NEW FIELD-PROGRAMMABLE GATE ARRAY BASED ON A MULTIPLEXER CELL</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. General Remarks</head><p>A simple examination of Fig. <ref type="figure" target="#fig_1">2</ref>(d) allows us to identify the main features of the programmable cell, henceforth referred to as MUXTREE (for multiplexer tree).</p><p>• Each of the two inputs of the multiplexer (labeled "0" and "1") will be programmable. The input will be either a logic constant ("0" or "1") or the output of the multiplexer of one of the neighboring cells to the south, southeast, or southwest. • The output of the multiplexer will be, therefore, connected to the inputs of the multiplexers in the neighboring cells to the north, northeast, and northwest. • The realization of sequential systems requires the presence, in each cell, of a synchronous memory element, a -type flip-flop, which will allow, in our example, to obtain directly the values and (instead of and ) needed for the display and for the retroaction of the secondary variables.</p><p>• Long-distance connections are necessary to connect a cell to any other cell in the array. In our example, the variable (itself obtained at the output of the mentioned flip-flop) must be brought back to the inputs of the multiplexers of the middle row of cells. This type of connection demands a system of universal buses, running through the entire array. In brief, the heart of the cell remains the 2-to-1 multiplexer, optionally followed by a flip-flop. Inputs and outputs are programmable and can be connected either to immediate neighbors, according to a topology proper to binary decision diagrams (where information flows from the bottom to the top), or to faraway cells through a network of perfectly symmetric universal buses.</p><p>To facilitate the detailed description of the MUXTREE cell, we will separate it into two levels: the logic level, that is, the basic multiplexer and its immediate connections, and the connection level, that is, the bus network for faraway connections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Description of the Logic Level</head><p>The MUXTREE cell (Fig. <ref type="figure" target="#fig_3">3</ref>) is based on a 2-to-1 multiplexer (in the lower part of the test block TB) and a -type flip-flop (in the memory block MB) for clocked sequential behavior. Connections to the inputs of the main multiplexer are defined using the 8-to-1 multiplexers of the connection block CB. The 6 bits LEFT2:0 and RIGHT2:0 select one out of eight inputs for the left and right branches of the main multiplexer. The second 2-to-1 multiplexer of TB selects one of the east buses (EOBUS, EIBUS) to control the main multiplexer. The 2-to-1 multiplexer of the output block OB allows the connection of the output of the main multiplexer or the output of the flip-flop to the north output (NOUT). A switch block SB, described in Section IV-C, provides interconnections between the input buses (NIBUS, EIBUS, SIBUS, WIBUS), as well as the output NOUT, and the output buses (NOBUS, EOBUS, SOBUS, WOBUS). Finally, the field-program bit REG (Fig. <ref type="figure" target="#fig_3">3</ref>) controls the combinational or sequential behavior of the cell, while the field-program bit PRESET determines if an action on the INIT signal implies an asynchronous set or reset of the flip-flop.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Description of the Bus Level and Global Representation</head><p>In order to implement long connections, the bus network includes one switch block SB per cell. Fig. <ref type="figure">4</ref>(a) symbolizes the interconnection possibilities between the four input and four output oriented buses. All connections are possible, with the exception only of "U-turns." Fig. <ref type="figure">4</ref>(b) shows the internal realization of the block. This realization, which also allows the north output (NOUT) to be connected to the four output buses, is realized using four 4-to-1 multiplexers. Each multiplexer is controlled by two field-program bits selecting one of the four possible inputs (the other directions input buses and the north output NOUT).  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Application: Modulo-4 Up-Down Counter</head><p>It can be immediately seen that the counter described by the ordered decision diagrams of Fig. <ref type="figure" target="#fig_1">2(c</ref>) can be realized using an array of three lines and three columns (that is, by a total of nine MUXTREE cells).</p><p>Fig. <ref type="figure" target="#fig_1">2(c</ref>) is modified and leads to the final diagram [Fig. <ref type="figure">5(a)</ref>] where we have the following:</p><p>• the use of two -type flip-flops, symbolized with a square around the corresponding diamonds, generates the variables and in place of and ; • a cell is completely unused, while another cell is used exclusively as a direct connection (transmission of ). Using the bus level notation defined in a detailed description of the MUXTREE cell <ref type="bibr" target="#b10">[11]</ref>, we can then draw the connection layout of the counter [Fig. <ref type="figure">5(b)]</ref>.</p><p>Combining the information of Fig. <ref type="figure">5</ref>(a) and (b) allows us to compute manually the 17 control bits of each gene, according to the format defined in Fig. <ref type="figure" target="#fig_3">3</ref>, and finally produces the genome of Fig. <ref type="figure" target="#fig_0">1(a)</ref>. For all indifferent conditions (conditions), the corresponding bits were set to "0."</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Conclusion</head><p>Thanks to the conception of the new family of fieldprogrammable gate arrays (FPGA's) MUXTREE, we are currently able to realize any given logic system using a completely homogeneous cellular network. This realization is simplified by the direct mapping of the ordered binary decision diagrams onto the array. Thus, we have satisfied the general hypothesis on the environment described in Section II-A, as well as the first feature of the Embryonics project, that is, multicellular organization [Section II-B and Fig. <ref type="figure" target="#fig_0">1(a)</ref>].</p><p>The manual computation of the genes can be very awkward. Two software tools (running on an Apple Macintosh) have been devised to overcome this problem. The first is a graphical editor, capable of determining the individual 20-bit genes for the MUXTREE implementation of any given function  represented by an OBDD. The second is a numerical simulator, allowing the functional verification of the implementation.</p><p>To this date, two physical realizations of arrays of MUX-TREE cells have been implemented. The first consists of 20 programmable ACTEL 1020A circuits, realizing a homogeneous surface of cells. The second, realized in collaboration with the CMP-Grenoble (Circuits multi projets, Prof. B. Courtois), is an integrated circuit MUXCHIP consisting of cells. The chip was fabricated at an SGS-Thomson Microelectronics facility <ref type="bibr" target="#b5">[6]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. CELLULAR DIFFERENTIATION: GENOME INTERPRETATION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. A Hierarchical Overview</head><p>Rather than describing our final cell as a whole, we will, for the sake of simplicity, decompose it in three components or layers (Fig. <ref type="figure" target="#fig_5">6</ref>) and describe each of these layers separately. The top layer is used to compute the local coordinates of the cell, usually by adding 1 to the coordinate of the western neighbor and to the coordinate of the southern neighbor. The middle layer contains a random access memory (RAM) and is used to store the entire genome: the memory stores a single gene per address, i.e., per pair of coordinates . Finally, the selected gene controls the bottom layer, which contains the functional cell (i.e., the MUXTREE cell defined in the preceding section).</p><p>During normal operation, the top (address computation) and middle (genome) layers are fixed and the values they compute ( and coordinates, gene GENE19:0) are constant. We will say that these two layers, which are in fact configuration layers, are idle during operation. Modifications can only be effected at initialization (programming of the FPGA) or during the self-repair and self-replication processes.</p><p>On the other hand, the bottom layer is the operational part or application layer. Its values usually change with time. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Microprogrammed Realization</head><p>In all living beings, the genome is executed sequentially by a chemical processor, the ribosome. Drawing inspiration from this biological process, we will use a microprogram to compute the local coordinates and and to extract from our artificial genome, as a function of the coordinates, the gene GENE19:0.</p><p>The artificial genome [for our example, that of the up-down counter of Fig. <ref type="figure" target="#fig_0">1(a)</ref>] can be considered as a truth table (or look-up table) whose input states are the coordinates or addresses and , and whose output states are the genes GENE19:0.</p><p>If we express the values of the coordinates and in pure binary code, using the logic variables and , we may apply the traditional simplification methods for binary decision trees <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref>, and we finally obtain the structured subprogram GENE of Fig. <ref type="figure" target="#fig_6">7</ref>(a), represented symbolically in the program of Fig. <ref type="figure" target="#fig_6">7(c)</ref>.</p><p>Assuming that the mother cell has coordinates we observe the following (Fig. <ref type="figure" target="#fig_5">6</ref>):</p><p>• each cell computes its horizontal coordinate as a function of the horizontal coordinate of its western neighbor;</p><p>• each cell computes its vertical coordinate as a function of the vertical coordinate of its southern neighbor; • the sequence of horizontal coordinates is incremented and limited to a cycle by the width of the cellular array; • the sequence of vertical coordinates is incremented and limited to a cycle by the height of the cellular array.</p><p>We can then write two subprograms realizing the expressions mod</p><p>(3) mod <ref type="bibr" target="#b3">(4)</ref> where in the example of the up-down counter [Fig. <ref type="figure" target="#fig_0">1(a)</ref>].</p><p>If we express the coordinates and in pure binary code, using the logic variables and , the simplification of the binary decision tree generates the structured subprogram of Fig. <ref type="figure" target="#fig_6">7(b</ref>). An identical computation can be performed on the coordinate described by <ref type="bibr" target="#b3">(4)</ref>.</p><p>Merging the subprogram GENE [Fig. <ref type="figure" target="#fig_6">7</ref>(a)] and the two subprograms which implement the increment of as in ( <ref type="formula">3</ref>) and of as in ( <ref type="formula">4</ref>) generates the final structured microprogram or genome for the example of the up-down counter [Fig. <ref type="figure" target="#fig_6">7(c)]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. NANOPASCAL: A High-Level Language for Structured Microprogramming</head><p>We will now define a programming language particularly well suited for the description, the interpretation and the duplication of the genome. This language, called NANOPASCAL for historical reasons, consists in fact of an absolutely minimal subset of the MODULA-2 language <ref type="bibr" target="#b14">[15]</ref>.</p><p>The NANOPASCAL language is described by the syntactic diagram of Fig. <ref type="figure" target="#fig_8">8(a)</ref>, where we can count seven distinct terminal symbols (ovals), which make up the instructions of the language (5)</p><p>The pseudo-instruction begin is in fact never executed, and simply indicates the start of the program. The instruction end forces an unconditional jump to address "0" (this is in fact the only jump implemented by the language). The NOP (No operation) instruction represents the execution of a neutral operation. The assignment do realizes the synchronous transfer REG OUT of a constant OUT in a register REG of address . Since no jumps are allowed by the language, all of the instructions making up the conditional construct if then else (where is a test variable and and are assignments) are read, and the execution of or depends on the value of a signal EXEC (for EXECUTE) which, in turn, depends on the preceding values of the test variable .</p><p>As an example, Fig. Writing the microprogram for a relatively large genome can be a bothersome endeavor. Therefore, we have developed two software tools which successively allow the following:</p><p>• the compilation, starting from the truth table of the genome (Fig. <ref type="figure" target="#fig_0">1</ref> • the translation of the above-mentioned mnemonic program into a binary program directly executable by the interpreter (Section V-D).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. NANOPASCALINE: An Interpreter for the NANOPASCAL Language</head><p>Fig. <ref type="figure" target="#fig_9">9</ref>(a) suggests a possible format and operating code (OPC) for the six types of executable instructions of the NANOPASCAL language defined in (5). These six types of instruction are executed by a binary decision machine or interpreter of the NANOPASCAL language (NANOPASCALINE). It consists mainly of the following elements [Fig. <ref type="figure" target="#fig_9">9(a)</ref>].</p><p>• A program memory RAM of 256 words of 8 bits.</p><p>• An address counter (CNT), whose output is the memory address ADR; ADR is incremented at each clock period (there are no jumps, with the exception of the instruction end which assures the jump to the address ADR 0 through the signal SYNCLR 1). • Eight assignment registers of 4 bits each ( : GENE19:0; : coordinates ; : display). The selection of one register out of eight is made by a demultiplexer DMUX and will only be effective if both the following two conditions are met: 1) an instruction do (signal DO=1) is being decoded and 2) the order of execution EXEC=1 is set. This last signal is crucial, and its value depends on the sequence of values of the test variable computation of the value of EXEC is performed by the stack STK described below.</p><p>• A stack STK of eight levels of 1 bit for the computation of the signal EXEC. If we call STK <ref type="bibr" target="#b0">[1]</ref> the variable of the top level of the stack, and STK <ref type="bibr">[2, ,8</ref>] the values of the levels below, then the table of Fig. <ref type="figure" target="#fig_9">9</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Conclusion</head><p>Our choice for the execution of the NANOPASCAL language is thus the following: the interpreter executes linearly all the instructions of the microprogram by incrementing the address ADR of the memory. The synchronous assignments REG OUT are executed only if the signal EXEC, generated by the stack, is one. This choice provides two main advantages:</p><p>• the time of execution of the microprogram GENOME is constant and the same for all the cells; • the duplication of the microprogram of a mother cell into an daughter cell can be executed in parallel with its interpretation (cellular division). The time of execution of such a program is obviously greater than that of an equivalent program with jumps. This drawback is less important in our case, since the GENOME microprogram is active only during the configuration of the FPGA, and not during its operation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. CELLULAR DIVISION: DUPLICATION OF THE GENOME</head><p>The duplication of the GENOME microprogram is accomplished automatically, in parallel with its interpretation. A register, controlled by the configuration clock CCK, is associated with the RAM in the NANOPASCALINE interpreter of each cell. At each rising edge of CCK, an instruction of the GENOME microprogram is copied into the cell through one of the SDATA or WDATA inputs selected by a physical jumper, manually set before start-up [Fig. <ref type="figure" target="#fig_12">11(b)</ref>]. The copy of the instruction is then available on both of the NDATA and EDATA outputs.</p><p>The GENOME microprogram is thus duplicated in permanence, resulting in a great simplicity of wiring and an excellent reliability, since an eventual transient fault (copy error) during a cycle will be corrected in the next cycle. In the symbol of the NANOPASCALINE interpreter [Fig. <ref type="figure" target="#fig_12">11(b)]</ref>, <ref type="bibr">KO</ref> 1 characterizes a faulty cell.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. SELF-REPLICATION AND SELF-REPAIR PROPERTIES</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Self-Replication</head><p>The self-replication of an artificial organism, for example the up-down counter of Fig. <ref type="figure" target="#fig_0">1</ref>(a), rests on two hypotheses: 1) there exists a sufficient number of spare cells (unused cells at the right hand side of the array, at least three columns of three cells for our example) and 2) the calculation of the coordinates produces a cycle [ in Fig. <ref type="figure" target="#fig_6">7(b)</ref>]. As the same pattern of coordinates produces the same pattern of genes, self-replication can be easily accomplished if the microprogram GENOME, associated to the homogeneous network of cells, produces several occurrences of the basic pattern of coordinates [ and/or in Fig. <ref type="figure" target="#fig_0">1(a)</ref>]. In our example, the repetition of the horizontal coordinate pattern, i.e., the production of the pattern [Fig. <ref type="figure" target="#fig_11">10</ref>(a)], produces one copy, the daughter automaton, of the original or mother automaton. Given a sufficiently large space, the self-replication process can be repeated for any number of specimens, both in the and the axes. For a given cell, the dimensions of the artificial organism are limited in the first place by the coordinate space ( and , that is, at most 256 cells in our implementation), and then by the dimensions of the RAM which will contain the GENOME microprogram (256 words of 8 bits in our case).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Self-Repair</head><p>Even if our long-term objective is the development of very large scale integrated circuits, we have started by realizing a demonstration system, based on artificial digital cells called BIODULES [Fig. <ref type="figure" target="#fig_12">11(a)</ref>]. In this context, the existence of a fault is decided by the human user by pressing the KILL button of a cell. Therefore, fault detection and fault location, two features which will be indispensable in the final system, where they will be implemented using BIST (builtin self-test) techniques <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b10">[11]</ref>- <ref type="bibr" target="#b12">[13]</ref>, are not present in the BIODULES.</p><p>To implement self-repair, we have chosen, favoring simplicity, the following process [Figs. <ref type="figure" target="#fig_11">10(b</ref>) and 11(a)]:</p><p>• pressing the KILL button identifies the faulty cell;</p><p>• the entire column to which the faulty cell belongs is considered faulty, and is deactivated (column in Fig. <ref type="figure" target="#fig_11">10</ref> Finally, it should be mentioned that the final BIODULE [Fig. <ref type="figure" target="#fig_12">11(a)</ref>] also realizes the series-parallel conversion of the data (DATA) and of the coordinates at the input, and the opposite conversion at the output. This conversion minimizes the number of connections between each BIODULE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. CONCLUSION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Results</head><p>The first result of our research is the development of a new family of FPGA's called MUXTREE and based on a fine-grained cell containing a multiplexer with one control variable. The original features of this FPGA are essentially the following:</p><p>• a completely homogenous organization of the cellular array; • an integration of the routing into each cell, both for the short-and long-distance (bus) connections; • a cell architecture allowing the direct mapping of binary decision diagrams onto the array. The FPGA satisfies both the general hypothesis (Section II-A) and the first feature of the Embryonics project, that of multicellular organization (Section II-B). Two physical implementations have been realized: a prototype array of 240 cells, itself implemented using FPGA's of the ACTEL family, and a complementary metal-oxide-semiconductor (CMOS) integrated circuit containing 64 cells.</p><p>The second result is the realization of a quasi-biological cell based on an application layer (the MUXTREE cell) and two configuration layers computing, as a function of the local coordinates and of the genome, the specific gene controlling the application layer MUXTREE. The configuration layers are realized using a binary decision machine called NANOPAS-CALINE, which interprets the GENOME microprogram. The three layers of application and of configuration are finally embedded into a complete cell, implemented using an FPGA and a RAM, and then built as a demonstration module called BIODULE. We then show that an array of BIODULES satisfies the second and third features of the Embryonics project (Sections II-C and -D: cellular differentiation and division) and that it is endowed with the properties of self-replication and self-repair.</p><p>The interest of self-repair is immediately obvious, as this property allows the repair of isolated faults, for example, the fault of a single cell. The importance of self-replication is less evident, and can be justified by the following:</p><p>• the complete reconstruction of a device, in case of massive faults; • the automatic realization of homogeneous 2-D cellular automata, by repetition of the same basic cell; • the simplicity of moving a device in the cellular array by the simple alteration of the coordinates of the mother cell.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Future Perspectives</head><p>The main drawback of the BIODULE cell is the lack of balance between the application layer (MUXTREE), which realizes the universal function with a single variable, and the configuration layers (NANOPASCALINE), which store and interpret a rather complex microprogram. The development of a new coarse-grained FPGA cell will aim at correcting this imbalance <ref type="bibr" target="#b10">[11]</ref>. The second drawback of the BIODULE, which is primarily a demonstration system, is the absence of a system for the detection and location of faults. While such a system could be implemented using relatively wellknown techniques, we are trying to exploit the peculiar features of FPGA's (homogeneous cellular organization, possibility of reconfiguration) to obtain a BIST realization capable of being embodied into the integrated circuit which will finally have to possess all the computational power of an array of BIODULES <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b10">[11]</ref>- <ref type="bibr" target="#b12">[13]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Historical and Theoretical Perspectives</head><p>The early history of the theory of self-replicating machines is basically the history of John von Neumann's thinking on the matter <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b13">[14]</ref>. Von Neumann's automaton is in accord with the general hypothesis outlined in Section II-A, as each of its elements is a finite state machine with 29 states. In his historic work <ref type="bibr" target="#b13">[14]</ref>, von Neumann successively showed that a possible configuration (a set of elements in a given state) of his automaton can implement a universal constructor endowed with the three following properties: constructional universality, self-replication of the universal constructor and self-replication of a universal calculator. In biology, the cell is the smallest part of a living being containing the complete blueprint of the being, the genome. On the basis of this definition, it can be shown that von Neumann's automaton is a unicellular organism, since it contains a single copy of the genome, i.e., the description of the universal constructor and computer <ref type="bibr" target="#b10">[11]</ref>. Each element of the automaton is thus a part of the cell, or, in biological terms, a molecule. Von Neumann's automaton, therefore, is a molecular automaton, and universal construction and self-replication are complex processes, as they are caused by the interaction of thousands of elements, the molecules, each one realized by a finite state machine with 29 states.</p><p>Arbib <ref type="bibr" target="#b2">[3]</ref> was the first to suggest a truly "cellular" automaton, in which every cell contains a complete copy of the genome, and a hierarchical organization, where each cell is itself decomposed into smaller and regular parts, the "molecules." Following this concept, the automaton we propose is a multicellular organism, as each of its elements contains a copy of the genome [nine copies in the case of the up-down counter of Fig. <ref type="figure" target="#fig_0">1(a)</ref>]. Each element of our automaton is thus a cell in the biological sense, and our automaton is truly a multicellular automaton. Self-replication and self-repair are straightforward processes, as the BIODULE cell has been conceived especially to carry out globally the operations of cellular differentiation and division.</p><p>The property of universal computation, that is, the possibility of realizing, repairing, and replicating a universal Turing machine, can theoretically be verified with the BIODULE cell. But the implementation of such a machine will be strongly simplified by the creation of a second generation of cells, coarse-grained <ref type="bibr" target="#b9">[10]</ref>.</p><p>The property of universal construction poses problems of a different nature, since it requires (always according to von Neumann) that BIODULE cells be able to implement artificial organisms of any dimension. The finite dimensions of our cells (memories, registers, etc.) are, for the moment, preventing us from meeting this requirement, a challenge which remains one of our main concerns and which could be solved, according to Arbib's suggestion, by decomposing a cell into molecules.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. The three features of embryonics applied to the example of an up-down counter. (a) Multicellular organization with a nine-gene genome. (b) Cellular differentiation with the complete genome in every cell and cellular division copying the genome of the mother cell into daughter cells (t1 1 1 1 t4: clock periods).</figDesc><graphic coords="2,305.40,231.84,252.48,156.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Modulo-4 up-down counter. (a) State table (Karnaugh map). (b) Canonic (Q1+) and minimal (Q0+) binary decision trees. (c) Ordered binary decision diagrams for Q1+ and Q0+. (d) Multiplexer implementation of the OBDD's.</figDesc><graphic coords="3,332.40,508.86,198.48,137.52" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 11 (</head><label>11</label><figDesc>b) summarizes the input and output signals of the MUXTREE cell. In order to facilitate the hexadecimal representation of its gene, the 17 field-program bits of the cell are organized as a 20-bit data GENE19:0 (Fig.3).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. MUXTREE cell. (a) Detailed architecture (the switch block SB is described in Fig. 4). (b) The 20-bit data GENE19:0 with P = PRESET, R = REG, and EB = EBUS.</figDesc><graphic coords="5,138.54,400.02,323.04,61.44" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 4 .Fig. 5 .</head><label>45</label><figDesc>Fig. 4. The switch block SB. (a) Interconnection possibilities. (b) Detailed architecture.</figDesc><graphic coords="6,44.40,182.22,248.40,177.24" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Hierarchical overview of the three layers and the corresponding block schemes of the final embryonic cell.</figDesc><graphic coords="6,305.10,59.58,252.96,231.84" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Computation and genome representation. (a) Gene computation, (b) X coordinate computation, and (c) up-down counter genome.</figDesc><graphic coords="7,138.78,412.86,322.56,99.36" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>8(b) shows the shape of the mnemonic program GENOME, realizing choosen parts of the final microprogram [Fig. 7(a) and (b)] in the syntax of the NANOPAS-CAL language.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. NANOPASCAL language. (a) Syntactic diagram and (b) microprogram GENOME.</figDesc><graphic coords="8,355.92,210.66,151.44,272.52" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. NANOPASCALINE: NANOPASCAL interpreter. (a) Detailed architecture with format and operation code (OPC) for the six instructions of the language. (b) Stack operation table.</figDesc><graphic coords="9,118.86,519.66,362.40,80.16" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>(b) describes the global operation of the stack. The logic product execution of the assignment instructions do REG OUT depends therefore on the succession of values of the test variable . • A multiplexer MUX which selects one out of 16 test variable . • A decoder DEC, controlled by the five bits of the operating code OPC4:0, which will generate the signals controlling the address counter CNT (signal END), the demultiplexer DMUX (signal DO) and the STK (signals IF, ELSE, and ENDIF). In conclusion, our NANOPASCALINE is limited to the computation of artificial organisms composed of at most MUXTREE cells.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. Properties of the up-down counter. (a) Self-replication and (b) self-repair.</figDesc><graphic coords="10,337.08,242.22,189.12,177.24" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. BIODULE: demonstration artificial digital cell. (a) The front panel and (b) detailed architecture.</figDesc><graphic coords="11,43.86,312.42,249.36,317.28" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>(b) in the example of the up-down counter); • all the functions of the application layer (MUXTREE) and of the configuration layers (NANOPASCALINE) of the column are shifted by one column to the right. Obviously, this process requires as many spare columns, to the right of the array, as there are columns to repair [one spare column in the example of Fig. 10(b)]. It also implies some modifications to the application and configuration layers, so as to add the capability of jumping the faulty column and shifting to the right all or part of the original cellular array [Fig. 11(b)].</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Manuscript received October 18, 1995; revised May 18, 1998. This work was supported by the Swiss National Science Foundation under Grants 21-36'200.92 and 20-39'391.93. D. Mange, E. Sanchez, A. Stauffer, and G. Tempesti are with the Logic Systems Laboratory, Swiss Federal Institute of Technolgy, Lausanne CH 1015 Switzerland. P. Marchal and C. Piguet are with the Centre suisse d'électronique et de microtechnique SA, Neuchâtel CH 2007 Switzerland. Publisher Item Identifier S 1063-8210(98)05984-8.</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">No-overhead BIST for FPGA&apos;s</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abramovici</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Stroud</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1st IEEE Int. On-Line Testing Workshop</title>
		<meeting>1st IEEE Int. On-Line Testing Workshop</meeting>
		<imprint>
			<date type="published" when="1995-07">July 1995</date>
			<biblScope unit="page" from="90" to="92" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Binary decision diagrams</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Akers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="509" to="516" />
			<date type="published" when="1978-06">June 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Arbib</surname></persName>
		</author>
		<title level="m">Theories of Abstract Automata</title>
		<meeting><address><addrLine>Englewood Cliffs, NJ</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="1969">1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Symbolic boolean manipulation with ordered binarydecision diagrams</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Bryant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="293" to="318" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Digital Systems with Algorithm Implementation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Davio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Deschamps</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Thayse</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983">1983</date>
			<publisher>Wiley</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Muxchip</title>
		<author>
			<persName><forename type="first">S</forename><surname>Durand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Logic Syst. Lab., Swiss Federal Inst. Technol</title>
		<imprint>
			<date type="published" when="1994-10">Oct. 1994</date>
			<pubPlace>Lausanne, Switzerland</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Advanced automation for space missions</title>
	</analytic>
	<monogr>
		<title level="m">Proc. Nasa Conf</title>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Freitas</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><forename type="middle">P</forename><surname>Gilbreath</surname></persName>
		</editor>
		<meeting>Nasa Conf</meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page">2255</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Microprogrammed Systems: An Introduction to Firmware Theory</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mange</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Chapman and Hall</publisher>
			<pubPlace>London, U.K.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Teaching firmware as a bridge between hardware and software</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mange</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Educ</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="152" to="157" />
			<date type="published" when="1993-03">Mar. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Von Neumann revisited: A turing machine with self-repair and self-replication properties</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mange</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Madon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Stauffer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Tempesti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Robot. Autonomous Syst</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="35" to="58" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Bio-Inspired Computing Machines</title>
		<editor>D. Mange and M. Tomassini</editor>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>Polytechniques et Universitaires Romandes Press</publisher>
			<pubPlace>Lausanne, Switzerland</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Logic Design Principles with Emphasis on Testable Semicustom Circuits</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">J</forename><surname>Mccluskey</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
			<publisher>Prentice Hall</publisher>
			<pubPlace>Englewood Cliffs, NJ</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A robust multiplexer-based FPGA inspired by biological systems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Tempesti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mange</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Stauffer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Syst. Architecture</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="719" to="733" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Theory of Self-Reproducing Automata</title>
		<author>
			<persName><forename type="first">J</forename><surname>Neumann</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1966">1966</date>
			<publisher>University of Illinois Press</publisher>
			<pubPlace>Urbana, IL</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Programming in MODULA-2, 2nd ed</title>
		<author>
			<persName><forename type="first">N</forename><surname>Wirth</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983">1983</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>Berlin, Germany</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">The Triumph of the Embryo</title>
		<author>
			<persName><forename type="first">L</forename><surname>Wolpert</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
			<publisher>Oxford University Press</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
