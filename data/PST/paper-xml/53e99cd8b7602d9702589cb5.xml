<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Antichains and compositional algorithms for LTL synthesis</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2011-03-22">22 March 2011</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Emmanuel</forename><surname>Filiot</surname></persName>
							<email>efiliot@ulb.ac.be</email>
							<affiliation key="aff0">
								<orgName type="department">Département d&apos;Informatique</orgName>
								<orgName type="institution">Université Libre de Bruxelles</orgName>
								<address>
									<addrLine>Bld du Triomphe</addrLine>
									<postCode>212, 1050</postCode>
									<settlement>Brussels</settlement>
									<region>CP</region>
									<country key="BE">Belgium</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">Département d&apos;Informatique</orgName>
								<orgName type="institution">Université Libre de Bruxelles</orgName>
								<address>
									<addrLine>Bld du Triomphe</addrLine>
									<postCode>212, 1050</postCode>
									<settlement>Brussels</settlement>
									<region>CP</region>
									<country key="BE">Belgium</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Naiyong</forename><surname>Jin</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Département d&apos;Informatique</orgName>
								<orgName type="institution">Université Libre de Bruxelles</orgName>
								<address>
									<addrLine>Bld du Triomphe</addrLine>
									<postCode>212, 1050</postCode>
									<settlement>Brussels</settlement>
									<region>CP</region>
									<country key="BE">Belgium</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">Département d&apos;Informatique</orgName>
								<orgName type="institution">Université Libre de Bruxelles</orgName>
								<address>
									<addrLine>Bld du Triomphe</addrLine>
									<postCode>212, 1050</postCode>
									<settlement>Brussels</settlement>
									<region>CP</region>
									<country key="BE">Belgium</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">Département d&apos;Informatique</orgName>
								<orgName type="institution">Université Libre de Bruxelles</orgName>
								<address>
									<addrLine>Bld du Triomphe</addrLine>
									<postCode>212, 1050</postCode>
									<settlement>Brussels</settlement>
									<region>CP</region>
									<country key="BE">Belgium</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jean-François</forename><surname>Raskin</surname></persName>
							<email>jraskin@ulb.ac.be</email>
							<affiliation key="aff0">
								<orgName type="department">Département d&apos;Informatique</orgName>
								<orgName type="institution">Université Libre de Bruxelles</orgName>
								<address>
									<addrLine>Bld du Triomphe</addrLine>
									<postCode>212, 1050</postCode>
									<settlement>Brussels</settlement>
									<region>CP</region>
									<country key="BE">Belgium</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">J.-F</forename><surname>Raskin</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Département d&apos;Informatique</orgName>
								<orgName type="institution">Université Libre de Bruxelles</orgName>
								<address>
									<addrLine>Bld du Triomphe</addrLine>
									<postCode>212, 1050</postCode>
									<settlement>Brussels</settlement>
									<region>CP</region>
									<country key="BE">Belgium</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Antichains and compositional algorithms for LTL synthesis</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2011-03-22">22 March 2011</date>
						</imprint>
					</monogr>
					<idno type="MD5">1DB3E514942D94D38908B55969E0600E</idno>
					<idno type="DOI">10.1007/s10703-011-0115-3</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:44+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>realizability and synthesis</term>
					<term>Automata on infinite words</term>
					<term>Compositional algorithms</term>
					<term>Antichain algorithms</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper, we present new monolithic and compositional algorithms to solve the LTL realizability problem. Those new algorithms are based on a reduction of the LTL realizability problem to a game whose winning condition is defined by a universal automaton on infinite words with a k-co-Büchi acceptance condition. This acceptance condition asks that runs visit at most k accepting states, so it implicitly defines a safety game. To obtain efficient algorithms from this construction, we need several additional ingredients. First, we study the structure of the underlying automata constructions, and we show that there exists a partial order that structures the state space of the underlying safety game. This partial order can be used to define an efficient antichain algorithm. Second, we show that the algorithm can be implemented in an incremental way by considering increasing values of k in the acceptance condition. Finally, we show that for large LTL formulas that are written as conjunctions of smaller formulas, we can solve the problem compositionally by first computing winning strategies for each conjunct that appears in the large formula. We report on the behavior of those algorithms on several benchmarks. We show that the compositional algorithms are able to handle LTL formulas that are several pages long.</p><p>This paper extends the results of the two following previous papers <ref type="bibr" target="#b12">[10,</ref><ref type="bibr" target="#b13">11]</ref> by the authors.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Contributions</head><p>In this paper, our contributions are threefold. First, we phrase a Safraless decision procedure for the LTL realizability and synthesis problem directly in the formalism of infinite word automata. Second, we identify structural properties in the underlying automata constructions that allow us to define an antichain algorithm for solving the LTL realizability problem. This is in line with our previous works in <ref type="bibr" target="#b8">[6]</ref><ref type="bibr" target="#b9">[7]</ref><ref type="bibr" target="#b10">[8]</ref><ref type="bibr" target="#b27">25]</ref> that use subsumption to obtain efficient implementations of several variants of subset constructions. Third, we study compositional algorithms to solve safety games, and we show how they can be used to develop compositional algorithms for solving the realizability and synthesis problems of large and structured LTL specifications.</p><p>Safraless procedure Our Safraless procedure uses Universal Co-Büchi Word automata, UCW. While solving the emptiness problem is easy for nondeterministic automata, solving the universality problem is easy for universal automata: a UCW A accepts all the words in ω if all cycles in A reachable from an initial state only contain non final states. <ref type="foot" target="#foot_0">5</ref> As a direct consequence, A is universal if and only if all paths starting from initial states in A can visit at most n times a final state, where n is the number of states in A. So universality easily reduces to safety for UCW. This simple property can be exploited in synthesis as follows: if a Moore machine M (representing a strategy) with m states defines a language (the outcome of the strategy) included in the language of a UCWA with n states, denoted by L uc (A), i.e., L(M) ⊆ L uc (A), then every run on the words generated by M contains at most 2mn final states of A. As a consequence, a strategy represented by a Moore machine that enforces a language defined by a UCW also enforces a stronger specification defined by the same automaton where the acceptance condition is strengthened to a so called "2mn-co-Büchi": a run is accepting if it passes at most 2mn times by a final state. Those automata are called Universal k-co-Büchi automata, denoted by UK CW. The language of A with this acceptance condition is denoted by L uc,k (A).</p><p>Using the result by Safra <ref type="bibr" target="#b29">[27]</ref>, we know that the size of a Moore machine that realizes a language defined by a UCWA can be bounded by some value K ∈ N, which is at most exponential in the size of A. This gives a reduction from the general problem to the problem of the realizability of a UK CW specification. Contrarily to general UCW specifications, universal K-co-Büchi specifications are safety conditions, and they can easily be made deterministic. The ideas underlying our construction are similar to the ones used in the reduction from UCT to safety tree automata proposed in <ref type="bibr" target="#b30">[28]</ref>.</p><p>Antichain and incremental algorithm The realizability and synthesis problems of an LTL formula φ can thus be reduced to a game whose winning objective is expressed by a UCWA φ , where A φ is the UCW that accepts all the models of formula φ. The acceptance condition of this automata can be strengthened to a K-co-Büchi condition and made deterministic using an extension of the classical subset construction. When applied to a universal automaton A with set of states Q, the classical subset construction consists in building a new automaton A whose states are subsets of Q. Thus, each state of A encodes the set of states of A that are active at each level of the run tree. In the case of K-co-Büchi automata, one needs additionally to remember how many times final states have been visited on the branches that lead to each active state. Clearly only the maximal number (up to K + 1) of visits to final states among all the branches that reach q has to be remembered. So, we need one counter, that counts up to K + 1, for each state of the automaton A φ . To implement this approach in practice, we face two difficulties. First, the automaton A φ can be exponentially larger than φ, and so its determinization can be doubly-exponentially larger than φ. Second, the maximal value K ∈ N that we need to consider in theory is also doubly exponential in the size of the formula φ. To overcome those two difficulties, we study the structure of the underlying automata constructions, and we develop the following two heuristics.</p><p>First, we show that the set of states of the deterministic automaton is partially ordered. The underlying partial order can be used to define an efficient data-structure to compactly represent and efficiently manipulate the game positions of the associated safety game. This allows us to develop an antichain algorithm, in the spirit of <ref type="bibr" target="#b10">[8]</ref>, to efficiently compute the winning positions in the safety game.</p><p>Second, for all UCWA, and for all k 1 , k 2 ∈ N, if k 1 ≤ k 2 then L uc,k 1 (A) ⊆ L uc,k 2 (A). So, instead of solving the safety game associated with the specification L uc,K (A φ ) (for the theoretical bound K given by the Safra's construction), we adopt an incremental approach, and we solve the games underlying L uc,i (A φ ) for increasing values of i, i = 0, 1, 2, . . . , K. As soon as one of this game can be won by Player 1, we know that the formula is realizable because L uc,i (A φ ) ⊆ L uc,K (A φ ) ⊆ L uc (A φ ). For unrealizable specification, this approach is not reasonable. This is why we consider in parallel the games associated with the specifications L uc,i (A ¬φ ) for increasing values of i, i = 0, 1, 2, . . . , K , and decide if Player 2 has a winning strategy in those games. <ref type="foot" target="#foot_1">6</ref> As LTL games are determined <ref type="bibr" target="#b23">[21]</ref>, we know that if Player 1 cannot realize φ, then Player 2 can realize ¬φ. In practice, we will see that for all the LTL formulas that we consider in our benchmarks, one of the specifications L uc,i (A φ ) or L uc,i (A ¬φ ) is realizable for a small value of i (less than 3 in all our experiments). This incremental algorithm has been implemented in a prototype of tool called Acacia. We have applied it to a set of benchmarks provided with the tool Lily and compared the performances of the two approaches on those benchmarks.</p><p>Compositional algorithm Large LTL formulas are often written as conjunctions of smaller formulas. We show that if the LTL formula has the form = φ 1 ∧ φ 2 ∧ • • • ∧ φ n , i.e., a conjunction of LTL sub-specifications, then G( ), the safety game underlying the formula (as sketched above), can be constructed and solved compositionally. The compositional algorithms are able to handle formulas that are several pages long while non-compositional algorithms are limited to much smaller formulas.</p><p>The compositional algorithms rely on the following nice property of safety games: for any safety game G, there exists a function that maps each position s of Player 1 to the set of all actions that are safe to play in s. We call this function the master plan of Player 1 in G. It encompasses all the winning strategies of Player 1. If is the master plan of G then we denote by G[ ] the game G where the behavior of Player 1 is restricted by .</p><p>To compute the winning positions of a safety game G 12 = G 1 ⊗ G 2 defined as the composition of two sub-games, we compute the master plans for the local games G 1 and G 2 before composition. Let 1 (resp. 2 ) be the master plan for G 1 (resp. G 2 ), then the winning positions in G 12 are the same as the winning positions in G 1 [ 1 ]⊗G 2 [ 2 ]. We develop backward and forward algorithms that exploit this property.</p><p>Sometimes, the LTL formula is given in the following form: m i=1 ψ i → n j =1 φ j where ψ i are hypothesis that are made on the environment of the system to control, and φ j are guarantees that the controller has to ensure. For those formulas, we show how to rewrite them in order to apply the compositional algorithms and how to simplify the formula that we obtain after rewriting.</p><p>We have implemented the two compositional algorithms in our prototype Acacia and we provide an empirical evaluation of their performances on the set of benchmarks on which we have evaluated the monolithic incremental approach sketched before, and on a realistic case study taken from the IBM RuleBase tutorial <ref type="bibr" target="#b16">[14]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related works</head><p>The first solution <ref type="bibr" target="#b26">[24]</ref> to the LTL realizability and synthesis problem was based on Safra's procedure for the determinization of Büchi automata <ref type="bibr" target="#b29">[27]</ref>.</p><p>Following <ref type="bibr" target="#b21">[19]</ref>, the method proposed in our paper can be coined "Safraless" approach to the realizability and synthesis of LTL as it avoids the determinization (based on Safra's procedure) of the automaton obtained from the LTL formula. Our approach relies on a reduction to safety games, as in <ref type="bibr" target="#b30">[28]</ref>. There, the construction is used to justify a reduction of the emptiness of universal co-Büchi tree automata to the SAT problem. In turn, this reduction is used to obtain a semi-algorithm for the distributed synthesis problem which is undecidable. Our algorithms are not reductions to SAT but fixed-point algorithms that can be implemented compositionally and symbolically using antichains. Recently, Ehlers <ref type="bibr" target="#b11">[9]</ref> has also implemented this reduction with a fixed point algorithm using BDDs and not antichains.</p><p>In <ref type="bibr" target="#b21">[19]</ref>, Kupferman and Vardi proposed the first Safraless approach that reduces the LTL realizability problem to Büchi games, which has been implemented in the tool Lily <ref type="bibr" target="#b17">[15]</ref>, their algorithm is incremental as the algorithm proposed in that paper. In <ref type="bibr" target="#b19">[17]</ref>, a compositional approach to LTL realizability and synthesis is proposed. Their algorithm is based on a Safraless approach that transforms the synthesis problem into a Büchi and not a safety game as in our case. There is no notion like the master plan for Büchi games. To the best of our knowledge, their algorithm has not been implemented.</p><p>In <ref type="bibr" target="#b6">[4]</ref>, the idea of checking the realizability of ψ by Player 1 in parallel with the realizability of ¬ψ by Player 2 is also proposed. Nevertheless, the procedure there is only complete for ω-regular specifications that are definable by deterministic Büchi automata.</p><p>In <ref type="bibr">[3,</ref><ref type="bibr" target="#b25">23]</ref>, an algorithm for the realizability problem for a fragment of LTL, known as GR <ref type="bibr">(1)</ref>, is presented and evaluated on the case study of <ref type="bibr" target="#b16">[14]</ref>. The specification into the GR(1) fragment for this case study is not trivial to obtain and so the gain in term of complexity <ref type="foot" target="#foot_2">7</ref>comes with a cost in term of expressing the problem in the fragment. Our approach is different as we want to consider the full LTL logic. In our opinion, it is important to target full LTL as it often allows for writing more declarative and more natural specifications.</p><p>In <ref type="bibr" target="#b31">[29]</ref>, the authors also consider LTL formulas of the form</p><formula xml:id="formula_0">= φ 1 ∧ φ 2 ∧ • • • ∧ φ n .</formula><p>They propose an algorithm to construct compositionally a parity game from such LTL specifications. Their algorithm uses a variant of Safra's determinization procedure and additionally tries to detect local parity games that are equivalent to safety games (because the associated LTL subformula is a safety property). For efficiently solving the entire game, they use BDDs.</p><p>In <ref type="bibr" target="#b18">[16]</ref>, a compositional algorithm is proposed for reasoning about network of components to control under partial observability. The class of properties that they consider is safety properties and not LTL properties. They propose a backward algorithm and no forward algorithm.</p><p>The implementation supporting the approaches described in <ref type="bibr" target="#b31">[29]</ref> and <ref type="bibr">[3]</ref> uses BDDs while our tool Acacia does not. While our algorithms could have been implemented with BDDs (see <ref type="bibr" target="#b11">[9]</ref> for such an implementation), we deliberately decided not to use them for two reasons. First, to fairly compare our Safraless approach with the one proposed in <ref type="bibr" target="#b21">[19]</ref> and implemented in Lily, we needed to exclude BDDs as Lily does not use them. Second, several recent works on the efficient implementation of decision procedures based on variants of the subset construction show that antichain based algorithms may outperform BDD-based implementations by several orders of magnitude, see <ref type="bibr" target="#b8">[6,</ref><ref type="bibr" target="#b9">7]</ref> for more details.</p><p>Outline The rest of the paper is structured as follows. Section 2 recalls the formal definitions of LTL, the realizability problem, universal automata operating on infinite words, and Moore machines to represent finite memory strategies. Section 3 recalls formal definitions for safety games, and two algorithms to solve them, one that operates backward and one that operates forward. Section 4 shows how the realizability problem of a ω-regular language defined by a universal automaton with co-Büchi acceptance condition can be reduced to the realizability problem of a language defined by the same automaton but with a K-co-Büchi acceptance condition. Section 5 uses this reduction to associate with each LTL formula a safety game. Section 6 studies the structure underlying this safety game to define an incremental antichain algorithm to solve the realizability problem. Section 7 evaluates the algorithms proposed in Sect. 6 on a large number of benchmarks. Section 8 introduces the compositional algorithms for solving the realizability problem of large LTL formulas given as conjunctions of smaller formulas. Section 9 evaluates the compositional algorithms on the benchmarks of Sect. 7, and on a larger, scalable, and more realistic example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">LTL and realizability problem</head><p>Linear Temporal Logic (LTL) The formulas of LTL are defined over a set of atomic propositions P . The syntax is given by the grammar:</p><formula xml:id="formula_1">φ ::= p|φ ∨ φ|¬φ|X φ|φ U φ p ∈ P</formula><p>The notations true, false, φ 1 ∧ φ 2 , ♦φ and φ are defined as usual. In particular, ♦φ = true U φ and φ = ¬♦¬φ. LTL formulas φ are interpreted on infinite words w = σ 0 σ 1 σ 2 • • • ∈ (2 P ) ω via a satisfaction relation w |= φ inductively defined as follows:</p><formula xml:id="formula_2">(i) w |= p if p ∈ σ 0 ; (ii) w |= φ 1 ∨ φ 2 if w |= φ 1 or w |= φ 2 ; (iii) w |= ¬φ if w |= φ; (iv) w |= X φ if σ 1 σ 2 . . . |= φ, and (v) w |= φ 1 U φ 2 if there is n ≥ 0 such that σ n σ n+1 . . . |= φ 2 and for all 0 ≤ i &lt; n, σ i σ i+1 . . . |= φ 1 .</formula><p>Given a LTL formula φ, we note [[φ]] the set of infinite words w s.t. w |= φ.</p><p>LTL realizability and synthesis As mentioned in the introduction, the realizability problem for LTL is best seen as a game between two players. Each of the players is controlling a subset of the set P of propositions on which the LTL formula is constructed. Accordingly, unless otherwise stated, we partition the set of propositions P into I the set of input signals that are controlled by Player 2 (the environment), and O the set of output signals that are controlled by Player 1 (the controller). It is also useful to associate this partition of P with the three following alphabets: = 2 P , 1 = 2 O , and 2 = 2 I . We denote by ∅ the empty set.</p><p>The realizability game is played in turns. Player 1 starts by giving a subset o 0 of propositions, Player 2 responds by giving a subset of propositions i 0 , then Player 1 gives o 1 and Player 2 responds by i 1 , and so on. This game lasts forever and the output of the game is the infinite word</p><formula xml:id="formula_3">(i 0 ∪ o 0 )(i 1 ∪ o 1 )(i 2 ∪ o 2 ) • • • ∈ ω .</formula><p>The players play according to strategies. A strategy for Player 1 is a (total) mapping λ 1 : ( 1 2 ) * → 1 while a strategy for Player 2 is a (total) mapping λ 2 : 1 ( 2 1 ) * → 2 . The outcome of the strategies λ 1 and λ 2 is the word outcome</p><formula xml:id="formula_4">(λ 1 , λ 2 ) = (o 0 ∪ i 0 )(o 1 ∪ i 1 ) • • • such that o 0 = λ 1 ( ), i 0 = λ 2 (o 0 ) and for all j ≥ 1, o j = λ 1 (o 0 i 0 . . . o j -1 i j -1 ) and i j = λ 2 (o 0 i 0 . . . o j -1 i j -1 o j ).</formula><p>Given an LTL formula φ (the specification), the realizability problem is to decide whether there exists a strategy λ 1 of Player 1 such that for all strategies λ 2 of Player 2, outcome(λ 1 , λ 2 ) |= φ. If such a strategy exists, we say that the specification φ is realizable. If an LTL specification is realizable, there exists a finite-state strategy that realizes it <ref type="bibr" target="#b26">[24]</ref>. The synthesis problem is to compute a finite-state strategy that realizes the LTL specification.</p><p>Example 1 Let I = {q}, O = {p} and ψ = p U q. The formula ψ is not realizable. As q is controlled by the environment, he can decide to leave it always false and the outcome does not satisfy φ. However ♦q → (p U q) is realizable. The assumption ♦q states that q will hold at some point, and so, one of the possible winning strategies for Player 1 is to always assert p.</p><p>Infinite word automata An infinite word automaton over the finite alphabet is a tuple A = ( , Q, q 0 , α, δ) where Q is a finite set of states, q 0 ∈ Q is the initial state, α ⊆ Q is a set of final states and δ ⊆ Q × × Q is a transition relation. For all q ∈ Q and all σ ∈ , we let δ(q, σ ) = {q |(q, σ, q ) ∈ δ}. We let |A| = |Q| + |δ| be the size of A. We say that A is</p><formula xml:id="formula_5">deterministic if ∀q ∈ Q • ∀σ ∈ • |δ(q, σ )| ≤ 1. It is complete if ∀q ∈ Q • ∀σ ∈ • δ(q, σ ) = ∅.</formula><p>In this paper, unless otherwise stated and w.l.o.g., the automata are complete. A run of A on a word</p><formula xml:id="formula_6">w = σ 0 σ 1 • • • ∈ ω is an infinite sequence of states ρ = ρ 0 ρ 1 • • • ∈ Q ω such that ρ 0 = q 0 and ∀i ≥ 0 • ρ i+1 ∈ δ(ρ i , σ i ).</formula><p>We denote by Runs A (w) the set of runs of A on w. We denote by Visit(ρ, q) the number of times the state q occurs along the run ρ. We consider three acceptance conditions (a.c.) for infinite word automata. A word w is accepted by A if (depending on the a.c.):</p><formula xml:id="formula_7">Non-deterministic Büchi: ∃ρ ∈ Runs A (w) • ∃q ∈ α • Visit(ρ, q) = ∞ Universal Co-Büchi: ∀ρ ∈ Runs A (w) • ∀q ∈ α • Visit(ρ, q) &lt; ∞ Universal K-Co-Büchi: ∀ρ ∈ Runs A (w) • q∈α Visit(ρ, q) ≤ K</formula><p>The set of words accepted by A with the non-deterministic Büchi a.c. is denoted by L b (A), and with this a.c. in mind, we say that A is a non-deterministic Büchi word automaton, NBW for short. Similarly, we denote respectively by L uc (A) and L uc,K (A) the set of words accepted by A with the universal co-Büchi and universal K-co-Büchi a.c. respectively. With those interpretations, we say that A is a universal co-Büchi automaton (UCW) and that the pair (A, K) is a universal K-co-Büchi automaton (UKCW) respectively. By duality, we have clearly L b (A) = L uc (A), for any infinite word automaton A. Finally, note that for any 0</p><formula xml:id="formula_8">≤ K 1 ≤ K 2 , we have that L uc,K 1 (A) ⊆ L uc,K 2 (A) ⊆ L uc (A).</formula><p>Infinite automata and LTL It is well-known (see for instance <ref type="bibr" target="#b32">[30]</ref>) that NBWs subsume LTL in the sense that for all LTL formula φ, there is an NBWA φ (possibly exponentially larger) such that L b (A φ ) = {w|w |= φ}. Similarly, by duality it is straightforward to associate an equivalent UCW with any LTL formula φ: take A ¬φ with the universal co-Büchi a.c., so</p><formula xml:id="formula_9">L uc (A ¬φ ) = L b (A ¬φ ) = {w|w |= ¬φ} = {w|w |= φ}.</formula><p>To reflect the game point of view of the realizability problem, we introduce the notion of turn-based automata to define the specification. A turn-based automaton A over the input alphabet 2 and the output alphabet 1 is a tuple A = ( 2 , 1 , Q 2 , Q 1 , q 0 , α, δ 2 , δ 1 ) where Q 2 , Q 1 are finite sets of input and output states respectively, q 0 ∈ Q 1 is the initial state, α ⊆ Q 2 ∪ Q 1 is the set of final states, and</p><formula xml:id="formula_10">δ 2 ⊆ Q 2 × 2 × Q 1 , δ 1 ⊆ Q 1 × 1 × Q 2 are</formula><p>the input and output transition relations respectively. It is complete if for all q 2 ∈ Q 2 , and all σ 2 ∈ 2 , δ 2 (q 2 , σ 2 ) = ∅, and for all q 1 ∈ 1 and all σ 1 ∈ 1 , δ 1 (q 1 , σ 1 ) = ∅. As for usual automata, in this paper we assume that turn-based automata are always complete. Turn-based automata still run on words from ω as follows: a run on a word w = (o</p><formula xml:id="formula_11">0 ∪ i 0 )(o 1 ∪ i 1 ) • • • ∈ ω is a word ρ = ρ 0 ρ 1 • • • ∈ (Q 1 Q 2 ) ω</formula><p>such that ρ 0 = q 0 and for all j ≥ 0, (ρ 2j , o j , ρ 2j +1 ) ∈ δ 1 and (ρ 2j +1 , i j , ρ 2j +2 ) ∈ δ 2 . All the acceptance conditions considered in this paper carry over to turn-based automata. Turn-based automata with acceptance conditions C are denoted by tbC, e.g. tbNBW. Every UCW (resp. NBW) with state set Q and transition set is equivalent to a tbUCW (resp. tbNBW) with |Q| + | | states: the new set of states is Q ∪ , final states remain the same, and each transition r = q σo∪σ i ---→ q ∈ where σ o ∈ 1 and σ i ∈ 2 is split into a transition q σo -→ r and a transition r</p><formula xml:id="formula_12">σ i -→ q .</formula><p>Moore machines LTL realizability is equivalent to LTL realizability by a finite-state strategy <ref type="bibr" target="#b26">[24]</ref>. We use Moore machines to represent finite-state strategies. A Moore machine M with input alphabet 2 and output alphabet 1 is a tuple ( 2 , 1 , Q M , q 0 , δ M , g M ) where Q M is a finite set of states with initial state q 0 , δ M :</p><formula xml:id="formula_13">Q M × 2 → Q M is a (total) transition function, and g M : Q M → 1 is a (total) output function. We extend δ M to δ * M : * 2 → Q M inductively as follows: δ * M ( ) = q 0 and δ * M (uσ ) = δ M (δ * M (u), σ ). The language of M, denoted by L(M), is the set of words w = (o 0 ∪ i 0 )(o 1 ∪ i 1 ) • • • ∈ ω P such that for all j ≥ 0, δ * M (i 0 . . . i j -1 ) is defined and o j = g M (δ * M (i 0 . . . i j -1 )). In particular, o 0 = g M (δ * M ( )) = g M (q 0</formula><p>). The size of a Moore machine is defined similarly as the size of an automaton.</p><p>As for every LTL formula φ we can construct a tbUCWA φ such that L uc (A φ ) =[[φ]], the LTL realizability problem reduces to decide, given a tbUCWA over inputs 2 and outputs 1 , whether there is a non-empty Moore machine M such that L(M) ⊆ L uc (A). If L(M) ⊆ L uc,K (A) for some K, we say that the tbUK CW(A, K) is realizable. Example 2 (Running example) Figure <ref type="figure" target="#fig_0">1</ref>(a) represents a tbUCW equivalent to the formula (r → X (♦g)), <ref type="foot" target="#foot_3">8</ref> where r is an input signal and g is an output signal. States of Q 1 are denoted by circles while states of Q 2 are denoted by squares. State q 4 is denoted by a square because it is a final state. The transitions on missing letters are going to an additional sink non-final state that we do not represent for the sake of readability. If a request r is never granted, then a run will visit the final state q 4 infinitely often.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Safety games</head><p>In this section, we provide a definition of safety games that is well-suited to support our synthesis methods detailed in the following sections. Player 1 will play the role of the system while Player 2 will play the role of the environment. This is why, as the reader will see, our definition of games is asymmetric. In those games, Players move alternatively. (i) S 1 is the set of Player 1 positions, S 2 is the set of Player 2 positions, S 1 ∩ S 2 = ∅. We let S = S 1 S 2 . (ii) 1 : S 1 → 2 Moves 1 is a function that assigns to each position of Player 1 the subset of moves that are available in that position. For Player 2, we assume that all the moves in Moves 2 are available in all the positions s ∈ S 2 . (iii) 1 : S 1 × Moves 1 → S 2 is a partial function that maps a pair (s, m) to the position reached from s when Player 1 chooses m ∈ 1 (s). 2 : S 2 × Moves 2 → S 1 is a function that maps (s, m) to the position reached from s when Player 2 chooses m.</p><p>We define the partial function as the union of the partial function 1 and the function 2 . Unless stated otherwise, we fix for the sequel of this section a turn-based game</p><formula xml:id="formula_14">G = (S 1 , S 2 , 1 , 1 , 2 ) on moves Moves = Moves 1 Moves 2 .</formula><p>Given a function</p><formula xml:id="formula_15">: S 1 → 2 Moves 1 , the restriction of G by is the game G[ ] = (S 1 , S 2 , 1 , 1 , 2 ) where for all s ∈ S 1 , 1 (s) = 1 (s) ∩ (s) and 1 equals 1 on the domain restricted to the pairs {(s, m) | s ∈ S 1 ∧ m ∈ 1 (s)}, i.e., G[ ] is as G but with the moves of Player 1 restricted by .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Rules of the game</head><p>The game on G is played in rounds and generates a finite or an infinite sequence of positions that we call a play. In the initial round, the game is in some position, say s 0 , and we assume that Player 1 owns that position. Then if 1 (s 0 ) is non-empty Player 1 chooses a move m 0 ∈ 1 (s 0 ), and the game evolves to position s 1 = 1 (s 0 , m 0 ), otherwise the game stops. If the game does not stop then the next round starts in s 1 . Player 2 chooses a move m 1 ∈ Moves 2 and the game proceeds to position s 2 = 2 (s 1 , m 1 ). The game proceeds accordingly either for an infinite number of rounds or it stops when a position s ∈ S 1 is reached such that 1 (s) = ∅. Player 1 wins if the game does not stop otherwise Player 2 wins (safety winning condition). Our variant of safety games are thus zero-sum games as usual. In particular, the positions s ∈ S 1 such that 1 (s) = ∅ are the safe positions of Player 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Plays and strategies</head><p>We now define formally the notions of play, strategy, outcome of a strategy and winning strategies. Given a sequence ρ = s 0 s 1 . . . s n . . . ∈ S * ∪ S ω , we denote by |ρ| its length (which is equal to ω if ρ is infinite). Given a non-empty sequence ρ, we denote by first(ρ) the first element of ρ, and if ρ is finite, we denote by last(ρ) its last element.</p><p>A play in G is a finite or infinite sequence of positions ρ = s 0 s 1 . . . s n . . . ∈ S * ∪ S ω such that: (i) if ρ is finite then last(ρ) ∈ S 1 and 1 (last(ρ)) = ∅; (ii) ρ is consistent with the moves and transitions of G, i.e., for all i, 0 ≤ i ≤ |ρ|, we have that</p><formula xml:id="formula_16">s i+1 = (s i , m) for some m ∈ 1 (s i ) if s ∈ S 1 , or m ∈ Moves 2 if s ∈ S 2 .</formula><p>We denote by Plays(G) the set of plays in G.</p><p>Given a set of finite or infinite sequences L ⊆ S * ∪ S ω , we write Pref j (L), j ∈ {1, 2}, for the set of prefixes of sequences in L that end up in a position of Player j . Let ⊥ be such that ⊥ ∈ Moves. A strategy for Player 1 in G is a function λ 1 : Pref 1 (Plays(G)) → Moves 1 ∪ {⊥} which is consistent with the set of available moves, i.e., for all ρ ∈ Pref i (Plays(G)), we have that:</p><formula xml:id="formula_17">(i) λ 1 (ρ) ∈ 1 (last(ρ))∪{⊥}, and (ii) λ 1 (ρ) = ⊥ only if 1 (last(ρ)) = ∅. A strategy for Player 2 in G is a function λ 2 : Pref 2 (Plays(G)) → Moves 2 .</formula><p>Note that a Player 2's strategy never contains ⊥ as all the moves of Player 2 are allowed at any position, whereas the moves of Player 1 are restricted by 1 .</p><p>A play ρ = s 0 s 1 . . . s n . . . ∈ Plays(G) is compatible with a strategy λ j of Player j (j ∈ {1, 2}), if for all i, 0 ≤ i &lt; |ρ|, if s i ∈ S j then s i+1 = j (s i , λ j (s 0 s 1 . . . s i )).We denote by outcome(G, s, λ j ) the subset of plays in Plays(G) that are compatible with the strategy λ j of Player j , and that start in s. We denote by outcome(G, s, λ 1 , λ 2 ) the unique play that is compatible with both λ 1 and λ 2 , and starts in s.</p><p>The winning plays for Player 1 are those that are infinite, i.e., Win 1 (G) = Plays(G) ∩ S ω , or equivalently those that never reach an unsafe position s ∈ S 1 of Player 1, i.e., a position</p><formula xml:id="formula_18">s such that 1 (s) = ∅. A strategy λ 1 is winning in G from s ini iff outcome(G, s ini , λ 1 ) ⊆ Win 1 (G)</formula><p>or equivalently, if the plays compatible with λ 1 are infinite. We call a turn-based game with such a winning condition in mind a safety game. We denote by WinPos 1 (G) the subset of positions s ∈ S in G for which there exists λ 1 such that outcome(G, s, λ 1 ) ⊆ Win 1 (G).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Games with initial position</head><p>A safety game with initial position is a pair (G, s ini ) where s ini ∈ S 1 ∪ S 2 is a position of the game structure G called the initial position. The set of plays in (G, s ini ) are the plays of G starting in s ini , i.e., Plays(G, s ini ) = Plays(G) ∩ s ini • (S * ∪ S ω ). All the previous notions carry over to games with initial positions.</p><p>We now recall two classical algorithms to solve safety games. One explores the game backward while the other explores it in a forward fashion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Backward algorithm for solving safety games</head><p>The classical fixpoint algorithm to solve safety games relies on iterating the following monotone operator over sets of game positions, see <ref type="bibr" target="#b14">[12]</ref> for example. The safety games we defined alternate between positions of Player 1 and positions of Player 2. We define two operators Pre 1 : 2 S 2 → 2 S 1 and Pre 2 : 2 S 1 → 2 S 2 such that for all X 1 ⊆ S 1 , Pre 2 (X 1 ) are the positions from which Player 2 cannot avoid reaching X 1 in one step. For all X 2 ⊆ S 2 , Pre 1 (X 2 ) are the positions from which Player 1 can reach S 2 in one step. We also define CPre :</p><formula xml:id="formula_19">2 S 1 → 2 S 1 as Pre 1 • Pre 2 : Pre 1 (X 2 ) = {s ∈ S 1 | ∃m ∈ 1 (s), 1 (s, m) ∈ X 2 } Pre 2 (X 1 ) = {s ∈ S 2 | ∀m ∈ Moves 2 , 2 (s, m) ∈ X 1 } CPre = Pre 1 • Pre 2</formula><p>Now, we define the following sequence of subsets of positions:</p><formula xml:id="formula_20">W 0 = {s ∈ S 1 | 1 (s) = ∅} W i = W i-1 ∩ CPre(W i-1 ) for all i ≥ 1</formula><p>Denote by W the fixpoint of this sequence. It is well known that W = WinPos 1 (G).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Forward algorithm for solving safety games</head><p>We describe an algorithm that computes the winning positions in a safety game in a forward fashion, starting from the initial position of the game. The algorithm explores the positions of the game and once a position is known to be losing, this information is back propagated to the predecessors. A position of Player 1 is losing (for Player 1) iff it has no successors or all its successors are losing. A position of Player 2 is losing (for Player 1) iff one of its successors is losing. For solving safety games, we use an variant of OTFUR algorithm of <ref type="bibr" target="#b7">[5]</ref> (Algo 1) based on an algorithm of <ref type="bibr" target="#b22">[20]</ref>. At each step, the algorithm maintains an under-approximation Losing of the set of losing positions.</p><p>The algorithm has a waiting-list Waiting for reachable position exploration and reevaluation of positions. In particular, an edge is put in the waiting-list if it is the first time it has been reached, or the status of its target position has changed. The latter case means that when the information that a position is losing is known, this information is back-propagated to all its predecessors. A set Passed records the visited positions. Finally, a set Depend stores the edges (s, s ) which need to be reevaluated when the value of s changes. At each step, the algorithm picks an edge e = (s, s ) in the waiting list. If its target s has never been visited, one checks whether this target is obviously losing (when it has no successors). In this case, we add e in the waiting list for reevaluation. This amounts to back propagate the information on s . Otherwise we add all the successors of s in the waiting list for reevaluation. If s has already been visited, then we compute the value of s. If s is losing, this information is back propagated to the positions whose safeness depends on s.</p><p>The overall complexity of this algorithm is linear in the size of the game, as every edge is added at most twice to the waiting list. We refer the reader to <ref type="bibr" target="#b7">[5,</ref><ref type="bibr" target="#b22">20]</ref> for the formal proof of its correctness, expressed by the following theorem: Theorem 1 After termination of Algorithm 1, the set of positions s such that ¬Losing[s] is equal to the winning positions (for Player 1) reachable from the initial position.</p><p>4 From UCW to UK CW realizability In this section, we reduce the realizability problem with a specification given by a turn-based universal co-Büchi automaton (tbUCW) to a specification given by a turn-based universal K-co-Büchi automaton (tbUKCW). A variant of this lemma expressed on universal co-Büchi tree automata has been proved in <ref type="bibr" target="#b30">[28]</ref>.</p><p>Lemma 1 Let A be a tbUCW over inputs 2 and outputs 1 with n states, and M be a Moore machine over inputs 2 and outputs 1 with m states. Then</p><formula xml:id="formula_21">L(M) ⊆ L uc (A) iff L(M) ⊆ L uc,2mn (A).</formula><p>Proof The back direction is obvious since L uc,k (A) ⊆ L uc (A) for all k ∈ N. We sketch the forth direction. Informally, the infinite paths of M starting from the initial state define words that are accepted by A. Therefore in the product of M and A, there is no cycle visiting a final state of A, which allows one to bound the number of visited final states by the number of states in the product. More formally, we first transform M into a tbNBWA M such that L(M) = L b (A M ). It suffices to copy every state of M and to define the transitions as follows: if q i -→ q is a transition of M with i ∈ 2 , and the output of q is o ∈ 1 , then we transform this transition into the two A M transitions q o -→ q c and q c i -→ q where q c is a fresh state  denoting a copy of q. All states of A M are set to be final, so that L b (A M ) is exactly the set of traces of infinite paths of A M (viewed as an edge-labeled graph) starting from the initial state. By hypothesis, L b (A M ) ⊆ L uc (A). Note that A M has 2m states. Let Q be the set of states of A, Q A M the set of states of A M and A × A M the product of A and A M , i.e. the automaton over 2 ∪ 1 whose set of states is Q × Q A M , initial states are pairs of initial states, and transitions have the form (q, p) σ -→ (q , p ) for all transitions</p><formula xml:id="formula_22">* := s ∈ S 1 ∧ m∈ 1 (s),s = 1 (s,m) Losing[s ] ∨ s ∈ S 2 ∧ m∈Moves 2 ,s = 2 (s,</formula><formula xml:id="formula_23">q σ -→ q of A and p σ -→ p of A M . Since L b (A M ) ⊆ L uc (A), there is no cycle in A × A M</formula><p>reachable from an initial state and that contains a state (q, p) where q ∈ Q is final. Indeed, otherwise there would exist an infinite path in A × A M , visiting (q, p) infinitely often. Every infinite word obtained as a trace of this path would be accepted by A M but not by A (since there would be a run on it visiting q infinitely often). Therefore the runs of A on words accepted by A M visit at most 2nm final states, where n (resp. 2m) is the number of states of A (resp. A M ).</p><p>The following result is proved in Theorem 4.3 of <ref type="bibr" target="#b21">[19]</ref>, as a small model property of universal co-Büchi tree automata. We also prove it here for the sake of self-containedness.</p><p>Lemma 2 Given a realizable tbUCWA over inputs 2 and outputs 1 with n states, there exists a non-empty Moore machine with at most n 2n+2 + 1 states that realizes it. Proof We first sketch the proof. In the first step, we show by using Safra's determinization of NBWs that A is equivalent to a turn-based deterministic and complete parity automaton A d . Using a result from <ref type="bibr" target="#b24">[22]</ref>, we know that A d has at most m := 2n 2n+2 + 2 states. We then view A d has a turn-based two-player parity game G(A d ) (with at most m states) such that A d (or equivalently A) is realizable iff Player 1 has a winning strategy in G(A d ). It is known that parity games admit memoryless strategies <ref type="bibr" target="#b14">[12]</ref>. Therefore if A d is realizable, there exists a strategy for Player 1 in G(A d ) that can be obtained by removing all but one outgoing edge per Player 1's state. We can finally transform this strategy into a Moore machine with at most n 2n+2 + 1 states that realizes A d (and A).</p><p>More formally, the proof uses the parity acceptance condition for automata and for games. Given an automaton B with state set Q B , a parity acceptance condition is given by a mapping c from Q B to N. A run ρ is accepting if min{c(q)|q ∈ Inf(ρ)} is even, where Inf(ρ) is the set of q ∈ Q that appear infinitely many times along ρ. Final states are not needed in B for this acceptance condition. We denote by L par,c (B) the language accepted by B under the parity acceptance condition c.</p><p>Given a turn-based two-player game G = (S 1 , S 2 , s 0 , ), the parity winning condition is given by a mapping c : S 1 ∪ S 2 → N. In that case, for all i ∈ {1, 2}, a strategy</p><formula xml:id="formula_24">λ i for Player i is winning if Outcome G (λ i ) ⊆ {π ∈ (S 1 S 2 ) ω | min{c(s)|s ∈ Inf(π )} is even}. Let A = ( 1 , 2 , Q 1 , Q 2 , q 0 , α, δ 1 , δ 2 ). We let Q = Q 1 ∪ Q 2 and δ = δ 1 ∪ δ 2 .</formula><p>Let A OI be the automaton ( , Q, q 0 , α, δ). We denote by m :</p><formula xml:id="formula_25">( 1 2 ) ω → ω the function that maps any word w = o 0 i 0 o 1 i 1 . . . to m(w) = (o 0 ∪i 0 )(o 1 ∪i 1 ) . . . . Note that m admits an inverse de- noted by m -1 . We have that m(L b (A OI )) = L b (A) (*)</formula><p>. By Safra's determinization, there exists a deterministic parity automaton D OI with a parity condition c such that L par,c (D OI ) = L b (A OI ). Moreover, by <ref type="bibr" target="#b24">[22]</ref>, we can assume that D OI has at most n 2n+2 states. Since L par,c (D OI ) ⊆ ( 2 1 ) ω , it is easy to transform D OI into a deterministic turn-based parity automaton D with a parity condition c such that L par,c (D OI ) = m -1 (L par,c (D)): it suffices to take the product with the two-states automaton that accepts ( 1 2 ) ω (let i and o its two states). The states of the product are therefore pairs (q, p) with q a state of D OI and p ∈ {i, o}, and we let c (q, p) = c(q). Note that D has at most 2n 2n+2 states. From equality (*) and the equalities L par,c (D OI ) = m -1 (L par,c (D)) and L par,c (D OI ) = L b (A OI ), we get L par,c (D) = L b (A). Then we complete the automaton D by adding two dead states and get a complete deterministic turn-based automaton A d (with at most 2n 2n+2 + 2 states). Finally, we take the dual parity condition c d = c +1 which increments the value of each state by 1, so that</p><formula xml:id="formula_26">L par,c d (A d ) = ω -L par,c (D) = ω -L b (A), from which we get L uc (A) = L par,c d (A d ). Let A d = ( 1 , 2 , Q d I , Q d O , q 0 , δ d 2 , δ d 1 ) and Q d = Q d I ∪ Q d O . We now view A d has a turn- based two-player parity game G(A d ) = (Q d 0 , Q d 2 , q 0 , ): Q d 1</formula><p>are Player 1's states (q 0 being the initial state) while Q d 2 are Player 2's states, and we put a transition (q, p) ∈ from a state q ∈ Q d to a state p ∈ Q d if there exists σ ∈ 2 ∪ 1 and a transition q σ -→ p in A d . Since A d has at most 2n 2n+2 + 2 states, G(A d ) has also at most 2n 2n+2 + 2 states.</p><p>The specification A d is realizable (or equivalently A is realizable) iff Player 1 has a winning strategy in G(A d ). Therefore if A is realizable, Player 1 has a winning strategy in G(A d ) given by a mapping γ from</p><formula xml:id="formula_27">Q d 1 to Q d 2 such that Outcome G(A d ) (γ ) are words ρ over (Q d 1 Q d 2</formula><p>) ω such that min{c(q)|q ∈ Inf(ρ)} is even. Moreover, those words correspond to accepting runs of A d on words over . Therefore the strategy γ can easily be used to define a Moore machine M such that L(M) ⊆ L par,c (A d ) = L uc (A): first we assume that is totally ordered. The machine M is defined as follows: Q d 1 are its states, q 0 is the initial state, the output function g is defined by g(q) = min{σ o |(q, σ o , γ (q)) ∈ δ d 1 }, for all q ∈ Q d 1 , and finally we put a transition q σ i -→ q , for all q, q ∈ Q d 1 , and all</p><formula xml:id="formula_28">σ i ∈ 2 if γ (q) σ i -→ q ∈ δ d 2 .</formula><p>Note that the transition relation of M is a (total) function since A d is complete, and has less than (2n 2n+2 + 2)/2 = n 2n+2 + 1 states.</p><p>The following theorem states that we can reduce the realizability of a tbUCW specification to the realizability of a tbUKCW specification.</p><p>Theorem 2 Let A be a tbUCW over 2 , 1 with n states and K = 2n(n 2n+2 + 1). Then A is realizable iff (A, K) is realizable.</p><p>Proof If A is realizable, by Lemma 2, there is a non-empty Moore machine M with m states (m ≤ n 2n+2 + 1) realizing A. Thus L(M) ⊆ L uc (A) and by Lemma 1, it is equivalent to L(M) ⊆ L uc,2mn (A). We can conclude since L uc,2mn (A) ⊆ L uc,K (A) (2mn ≤ K). The converse is obvious as L uc,K (A) ⊆ L uc (A).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">From UK CW realizability to safety games</head><p>In the last section, we reduced the tbUCW realizability problem to the tbUKCW realizability problem. In this section, we reduce this new problem to a safety game. It is based on the determinization of tbUKCWs into complete turn-based deterministic 0-Co-Büchi automata, which can obviously be viewed as safety games.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Determinization of</head><formula xml:id="formula_29">UKCW Let A be a tbUKCW ( 1 , 2 , Q 1 , Q 2 , q 0 , α, 1 , 2 ) with K ∈ N. We let Q = Q 1 ∪Q 2 and = 1 ∪ 2 .</formula><p>It is easy to construct an equivalent complete turnbased deterministic 0-co-Büchi automaton det(A, K). Intuitively, it suffices to extend the usual subset construction with counters, for all q ∈ Q, that count (up to K + 1) the maximal number of accepting states which have been visited by runs ending up in q. We set the counter of a state q to -1 when no run on the prefix read so far ends up in q. The final states are the sets in which a state has its counter greater than K. For any n ∈ N, [n] denotes the set {-1, 0, 1, . . . , n}. Formally, we let det(A, K) = ( 1 , 2 , F 1 , F 2 , F 0 , α , δ 1 , δ 2 ) where:</p><formula xml:id="formula_30">F 1 = {F |F is a mapping from Q 1 to [K + 1]} F 2 = {F |F is a mapping from Q 2 to [K + 1]} F 0 = q ∈ Q 1 → -1 i fq = q 0 (q 0 ∈ α) otherwise α = {F ∈ F 2 ∪ F 1 |∃q, F (q) &gt; K} succ(F, σ ) = q → max{min(K + 1, F (p) + (q ∈ α))|q ∈ (p, σ ), F (p) = -1} δ 1 = succ| F 1 × 1 δ 2 = succ| F 2 × 2</formula><p>where max ∅ = -1, and (q ∈ α) = 1 if q is in α, and 0 otherwise. The automaton det(A, K) has the following properties:</p><p>Proposition 1 Let A be a tbUCW and K ∈ N. Then det(A, K) is deterministic, complete, and L uc,0 (det(A, K)) = L uc,K (A).</p><p>Reduction to a safety game Finally, we define the game G(A, K) as follows: it is det(A, K) where input states are viewed as Player 2's states and output states as Player 1's states. Formally, we define G(A, K) = (F 1 , F 2 , 1 , 1 , 2 , F 0 ) over the set of moves Moves 1 = 1 and Moves 2 = 2 , where F 0 is the initial position. The set of available moves in a Player 1's position are defined via a successor function succ. An action σ 1 ∈ Moves 1 is available for Player 1 in a position F ∈ S 1 if the counters of F and succ(F, σ 1 ) do not exceed K. More formally, σ 1 ∈ 1 (F ) iff for all p ∈ Q 1 and all q ∈ Q 2 , F (p) ≤ K and succ(F, σ 1 )(q) ≤ K. The transition function 1 is defined by 1 (F, σ ) = succ(F, σ ) for all F ∈ S 1 and all σ ∈ 1 (s). The function 2 is defined by 2 (F, σ 2 ) = succ(F, σ 2 ) for all F ∈ S 2 and all σ 2 ∈ Moves 2 .</p><p>As an obvious consequence of Theorem 2 and Proposition 1, we get:</p><p>Theorem 3 (Reduction to a safety game) <ref type="foot" target="#foot_4">9</ref> Let A be a tbUCW over inputs 2 and outputs 1 with n states (n &gt; 0), and let K = 2n(n 2n+2 + 1). The specification A is realizable iff Player 1 has a winning strategy in the game G(A, K).</p><p>Proof Suppose that A is realizable. By Theorem 2 and Proposition 1, (A, K) is also realizable, as well as det(A, K). Thus there is exists a non-empty Moore machine M over inputs 2 and outputs 1 such that L(M) ⊆ L uc,0 (det(A, K)). We now construct a winning strategy γ for Player 1 in G(A, K). Intuitively, Outcome G(A,K) (γ ) will correspond to runs of det(A, K) on words of L(M). Therefore, since L(M) ⊆ L uc,0 (det(A, K)), Outcome G(A,K) (γ ) won't visit final states. For the sake of clarity, we view this Moore machine as a (total) mapping λ : * 2 → 1 . First assume that 1 and 2 are totally ordered by some order ≺. We define a strategy γ in G(A, K) inductively on its outcome. First, γ (F 0 ) = λ( ), where is the empty sequence. Clearly, since λ is winning, λ( ) is an available move in F 0 . Then, for any finite outcome </p><formula xml:id="formula_31">H = F 1 0 F 2 0 . . . F 2 m-1 F 1 m ∈ (F 1 F 2 ) * F 1 of</formula><formula xml:id="formula_32">≤ i ≤ m, σ I i = min{σ |succ(F 2 i-1 , σ ) = F 1 i }. We let γ (H ) = λ(w(H )).</formula><p>It is easy to prove by induction that λ(w(H )) is an available move at position F 1 m (this is because λ is winning and generates outcomes that are accepted by det(A, K)). The strategy λ is clearly winning since it always chooses moves that are available, so that its outcomes are all infinite.</p><p>Conversely, suppose that Player 1 has a winning strategy γ in G(A, K). It is known that we can assume that γ is memoryless <ref type="bibr" target="#b14">[12]</ref>. So let γ be a mapping from F 1 to 1 . We construct a winning strategy for the controller, represented as a Moore machine</p><formula xml:id="formula_33">M γ = ( 1 , 2 , F 1 , F 0 , δ γ , γ ). Its state set is F 1 with initial state F 0 ; for all F ∈ F 1 , the output of F is γ (F ); for all F ∈ F 1 ,</formula><p>and all σ i ∈ 2 , the transition function is defined by</p><formula xml:id="formula_34">δ γ (F, σ i ) = δ 2 (δ 1 (F, γ (F )), σ i ).</formula><p>Since γ is winning, it is clear by construction that all states of M γ reachable from the initial state are non-final. Therefore L(M γ ) ⊆ L uc,0 (det(A, K)) = L uc (A). Moreover, the transition relation of M γ is a (total) function, as det(A, K) is complete. Since there is a winning strategy γ in G(A, K), it means that G(A, K) is non-empty, and so is M γ , which concludes the proof.</p><p>Associating a safety game with an LTL formula φ is done as follows: (1) construct a UCWA φ equivalent to φ, (2) construct G(A φ , K), denoted as G(ψ, K) in the sequel, where K = 2n(n 2n+2 + 1) and n is the number of states of A φ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Incremental algorithm</head><p>In practice, for checking the existence of a winning strategy for Player 1 in the safety game, we rely on an incremental approach. We use the following property of UK CWs: for all</p><formula xml:id="formula_35">k 1 , k 2 • 0 ≤ k 1 ≤ k 2 • L uc,k 1 (A) ⊆ L uc,k 2 (A) ⊆ L uc (A)</formula><p>. So, the following theorem which is a direct consequence of the previous property allows us to test the existence of strategies for increasing values of K:</p><p>Theorem 4 For all tbUCWsA, for all k ≥ 0, if Player 1 has a winning strategy in the game G(A, k) then the specification defined by A is realizable. Unrealizable specifications The incremental algorithm is not reasonable to test unrealizability. Indeed, with this algorithm it is necessary to reach the bound 2n(n 2n+2 + 1) to conclude for unrealizability. To obtain a more practical algorithm, we rely on the determinacy of ω-regular games (a corollary of the general result by Martin <ref type="bibr" target="#b23">[21]</ref>).</p><p>Theorem 5 For all LTL formulas φ, either (i) there exists a Player 1's strategy λ 1 s.t. for all Player 2's strategies λ 2 , outcome(λ 1 , λ 2 ) |= φ, or there exists a Player 2's strategy λ 2 s.t. for all Player 1's strategies λ 1 , outcome(λ 1 , λ 2 ) |= ¬φ.</p><p>So, when an LTL specification φ is not realizable for Player 1, it means that ¬φ is realizable for Player 2. To avoid in practice the enumeration of values for K up to 2n(n 2n+2 + 1), we propose the following algorithm. First, given the LTL formula φ, we construct two UCWs: one that accepts all the models of φ, denoted by A φ , and one that accepts all the models of ¬φ, denoted by A ¬φ . Then we check realizability by Player 1 of φ, and in parallel realizability by Player 2 of ¬φ, incrementing the value of K. When one of the two processes stops, we know if φ is realizable or not. In practice, we will see that either φ is realizable for Player 1 for a small value of K or ¬φ is realizable for Player 2 for a small value of K. In the next section, we show that the game G(A, K) has a nice structure that allows to compactly represent and efficiently manipulate sets of winning positions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Antichain-based symbolic algorithms</head><p>In the previous section, we have shown how to reduce the realizability problem of a UCWA with n states to a family of safety game G(A, k) for 0 ≤ k ≤ 2n(n 2n+2 + 1). From now on, we fix some k ∈ N. In this section, we show that the positions of the game G(A, k) can be partially ordered. We also show that the sets of positions manipulated during the backward algorithm for safety games (see Sect. 3) are downward closed for this order. This allows to compactly represent those sets by the antichain of their maximal elements. Therefore it is not necessary to construct explicitly the game G(A, k), which may be very large even for small values of k. We also show that the forward algorithm for safety games can also benefit from the particular structure of G(A, k). <ref type="figure">A,</ref><ref type="figure">k</ref>) is defined by the tuple (F 1 , F 2 , 1 , 1 , 2 , F 0 ) over the set of moves 1 for Player 1 (controller) and 2 for Player 2 (environment). We also let F = F 1 ∪ F 2 , and we denote by safe ⊆ F the set of counting functions whose counters do not exceed k.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Recall that G(</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Ordering of game positions We define the relation ⊆</head><formula xml:id="formula_36">F 2 × F 2 ∪ F 1 × F 1 by F F iff ∀q, F (q) ≤ F (q).</formula><p>It is clear that is a partial order. Intuitively, if Player 1 can win from F then she can also win from all F F , as it is somehow more difficult to stay below the bound k from F than from F . Formally, is a game simulation relation in the terminology of <ref type="bibr">[2]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Closed sets and antichains</head><formula xml:id="formula_37">A set S ⊆ F is closed for , if ∀F ∈ S • ∀F F • F ∈ S.</formula><p>We usually omit references to if clear from the context. Let S 1 and S 2 be two closed sets, then S 1 ∩ S 2 and S 1 ∪ S 2 are closed. The closure of a set S ⊆ F , denoted by ↓S, is the set</p><formula xml:id="formula_38">S = {F ∈ F | ∃F ∈ S • F F }.</formula><p>Note that for all closed sets S ⊆ F , ↓S = S. A set L ⊆ F is an antichain if all elements of L are incomparable for . Let S ⊆ F , we denote by S the set of maximal elements of S, that is S = {F ∈ S | ∃F ∈ S • F = F ∧ F F }, it is an antichain. If S is closed then ↓ S = S, i.e. antichains are canonical representations for closed sets. Similarly, we denote by S and ↑S the minimal elements of S and its upward closure, respectively. Since the size of a state F ∈ F is in practice much smaller than the number of elements in the antichains, we consider that comparing two states is in constant time.</p><p>Proposition 2 Let L 1 , L 2 ⊆ F be two antichains and F ∈ F , then:</p><formula xml:id="formula_39">(i) ↓L 1 ∪ ↓L 2 = ↓ L 1 ∪ L 2 , this antichain can be computed in time O((|L 1 | + |L 2 |) 2 )</formula><p>and its size is bounded by</p><formula xml:id="formula_40">|L 1 | + |L 2 |, (ii) ↓L 1 ∩ ↓L 2 = ↓ L 1 L 2 ,</formula><p>where F 1 F 2 : q → min(F 1 (q), F 2 (q)), this antichain can be computed in time</p><formula xml:id="formula_41">O(|L 1 | 2 × |L 2 | 2</formula><p>) and its size is bounded by</p><formula xml:id="formula_42">|L 1 | × |L 2 |, (iii) ↓L 1 ⊆ ↓L 2 iff ∀F 1 ∈ L 1 •∃F 2 ∈ L 2 •F 1 F 2 , which can be established in time O(|L 1 |× |L 2 |), (iv) F ∈ ↓L 1 can be established in time O(|L 1 |).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Backward algorithm for safety games with antichains</head><p>The image of a closed set S by the functions Pre 2 , Pre 1 , and CPre are closed sets: Lemma 3 For all closed sets S 1 , S 2 ⊆ F 2 , S 3 ⊆ F 1 , the sets Pre 1 (S 1 ), CPre(S 2 ), and Pre 2 (S 3 ) are closed.</p><p>As a consequence, all the sets manipulated by the backward fixpoint algorithm are closed sets, and can therefore be compactly represented by the antichain of their maximal elements. Next, we show how to manipulate those sets efficiently.</p><p>Let us now turn to the computation of controllable predecessors. Let F ∈ F , and σ ∈ 2 ∪ 1 . We denote by (F, σ ) ∈ F the function defined by:</p><formula xml:id="formula_43">(F, σ ) : q ∈ Q → min{max(-1, F (q ) -(q ∈ α))|(q, σ, q ) ∈ δ}.</formula><p>Note that since A is complete, the argument of min is a non-empty set. The function is not the inverse of the function succ, as succ has no inverse in general. Indeed, it might be the case that a state F ∈ F has no predecessors or has more than one predecessor H such that succ(H, σ ) = F . However, we prove the following:</p><p>Proposition 3 For all F, F ∈ F ∩ safe, and all σ ∈ 2 ∪ 1 ,</p><formula xml:id="formula_44">(i) F F =⇒ (F, σ ) (F , σ ), (ii) F F =⇒ succ(F, σ ) succ(F , σ ), (iii) F (succ(F, σ ), σ ), (iv) succ( (F, σ ), σ ) F .</formula><p>Proof We establish the four items as follows:</p><p>(i) It holds as max(-1, F (q)q ∈ α) ≤ max(-1, F (q)q ∈ α), ∀q ∈ Q.</p><p>(ii) It holds as min(K + 1, F (q ) + q ∈ α) ≤ min(K + 1, F (q ) + q ∈ α), ∀q ∈ Q.</p><p>(iii) Let q ∈ Q. We show that for all q ∈ δ(q, σ ), F (q) ≤ succ(F, σ )(q ) -(q ∈ α). This will be sufficient to conclude since it implies that F (q) ≤ max(-1, succ(F, σ )(q ) -(q ∈ α)), for all q ∈ δ(q, σ ), and therefore that F (q) ≤ (succ(F, σ ), σ )(q). So let q ∈ δ(q, σ ), and let I (q ) = {q |(q , σ, q ) ∈ δ, F (q ) = -1}. Since (q, σ, q ) ∈ δ, we have q ∈ I (q ). We know that succ(F, σ )(q ) = max{min(K + 1, F (q ) + q ∈ α)|q ∈ I (q )}. Since q ∈ I (q ), succ(F, σ )(q ) ≥ min(K + 1, F (q) + q ∈ α). If F (q) + q ∈ α ≤ K + 1, then succ(F, σ )(q ) -(q ∈ α) ≥ F (q). The case F (q) + (q ∈ α) is impossible since F (q) ≤ K, as F ∈ safe.</p><p>(iv) Let q ∈ Q. We first show that for all q such that (q , σ, q) ∈ δ and (F, σ )(q ) = -1, (F, σ )(q ) ≤ F (q) -(q ∈ α). This will be sufficient to conclude since it implies that min(K + 1, (F, σ )(q ) + (q ∈ α)) ≤ F (q), for all q such that (q , σ, q) ∈ δ, and therefore that succ( (F, σ ), σ )(q) ≤ F (q). So let q such that (q , σ, q) ∈ δ and (F, σ )(q ) = -1. Let I (q ) = {q |(q , σ, q ) ∈ δ}. Since (q , σ, q) ∈ δ, we have q ∈ I (q ). We know that (F, σ )(q ) = min{max(-1 , F (q ) -(q ∈ α))|q ∈ I (q )}. Since q ∈ I (q ), we get (F, σ )(q ) ≤ max(-1, F (q) -(q ∈ α)). The case F (q) -(q ∈ α) &lt; -1 is impossible, since otherwise we would have (F, σ )(q ) = -1, which contradicts the hypothesis. Therefore max(-1, F (q) -(q ∈ α)) = F (q) -(q ∈ α) and (F, σ )(q ) ≤ F (q) -(q ∈ α).</p><p>Example 4 We illustrate point (iii) of the Proposition 3 on the example of Fig. <ref type="figure" target="#fig_0">1</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(a). Let us consider the position</head><formula xml:id="formula_45">[q 3 → 1]. While succ([q 2 → 0, q 4 → 1], r) = [q 3 → 1], we have that ([q 3 → 1], r) = [q 2 → 1, q 4 → 1], i.e., ([q 3 → 1], r) returns the largest possible prede- cessor of [q 3 → 1] by r, so succ([q 2 → 0, q 4 → 1], r) (succ([q 2 → 0, q 4 → 1], r), r).</formula><p>For all S ⊆ F and σ ∈ 2 ∪ 1 , we denote by Pre(S, σ ) = {F |succ(F, σ ) ∈ S} the set of predecessors of S. The set of predecessors of a closed set ↓F is closed and has a unique maximal element (F, σ ):</p><formula xml:id="formula_46">Lemma 4 For all F ∈ F ∩ safe and σ ∈ 2 ∪ 1 , Pre(↓F, σ ) = ↓ (F, σ ).</formula><p>Proof Let H ∈ Pre(↓F, σ ). Hence succ(H, σ ) F . By Proposition 3(i), we have (succ(H, σ ), σ ) (F, σ ), from which we get H (F, σ ), by Proposition 3(iii). Conversely, let H (F, σ ). By Proposition 3(ii), succ(H, σ ) succ( (F, σ ), σ ). Since by Proposition 3(iv), succ( (F, σ ), σ ) F , we get succ(H, σ ) F .</p><p>We can now use the previous result to compute the controllable predecessors:</p><formula xml:id="formula_47">Proposition 4 Let A be a tbUK CW. Given two antichains L 1 , L 2 such that L 1 ⊆ F 2 ∩ safe and L 2 ⊆ F 1 ∩ safe: Pre 1 (↓L 1 ) = σ ∈ 1 Pre(↓L 1 , σ ) = σ ∈ 1 ↓{ (F, σ )|F ∈ L 1 } Pre 2 (↓L 2 ) = σ ∈ 2 Pre(↓L 2 , σ ) = σ ∈ 2 ↓{ (F, σ )|F ∈ L 2 } Pre 1 (↓L 1 ) can be computed in time O(| 1 | × |A| × |L 1 |), and Pre 2 (↓L 2 ) can be computed in time O((|A| × |L 2 |) | 2 | ).</formula><p>As stated in the previous proposition, the complexity of our algorithm for computing the Pre 2 is worst-case exponential. We establish as a corollary of the next proposition that there is no polynomial times algorithm for computing Pre 2 unless P = NP. Given a graph G = (V , E), a set of vertices W is independent iff no pairs of elements in W are linked by an edge in E. We denote by</p><formula xml:id="formula_48">IND(G) = {W ⊆ V | ∀{v, v } ∈ E • v ∈ W ∨ v ∈ W }</formula><p>the set of independent sets in G. The problem "independent set" asks given a graph G = (V , E) and an integer 0 ≤ k ≤ |V |, if there exists an independent set in G of size larger than k. It is known to be NP-complete.</p><p>Proposition 5 Given a graph G = (V , E), we can construct in deterministic polynomial time a UK CWA, with K = 0, and an antichain L such that</p><formula xml:id="formula_49">IND(G) = ↓Pre 2 (Pre 1 (Pre 1 ((L))).</formula><p>Proof We start by a simple remark. Let A be tbUKCW with input states Q 2 and output states Q 1 . When k = 0, Player 2's locations in G(A, k) are exactly the subsets of Q 2 and Player 1's locations are the subsets of Q 1 , and the partial order corresponds to set inclusion. Now, let us consider for each e = {v, v } ∈ E the antichain (for ⊆) L {v,v } = {V \ {v}, V \ {v }}, L compactly represents all the subsets of V that are independent of the edge {v, v }. Clearly IND(G) = {v,v }∈E ↓L {v,v } . As a direct consequence of the NP completeness of the independent set problem, there cannot exist a polynomial time algorithm to compute the antichain for this intersection unless P = NP. Indeed, this antichain contains the maximal independent sets. Now, we show how to construct a UK CWA and an antichain of subsets of states L such that Pre 2 (Pre 1 (Pre 1 (L)) is exactly IND(G). We can assume that V is totally ordered by some order, and for all edges e = {v, v } ∈ E, we denote by π 1 (e) the minimal element of e and by π 2 (e) its maximal element. Now, the set of state of the automaton is structured in four layers:</p><formula xml:id="formula_50">S 3 = {ok, ko} belongs to Player 2, S 2 = {(v, e, i) | v ∈ V , e ∈ E, i ∈ {1, 2}} belongs to Player 1, S 1 = {(v, e) | v ∈ V , e ∈ E} belongs to Player 1. Finally, S 0 = {v | v ∈ V }</formula><p>belongs to Player 2. Note that we do not make players strictly alternate here to simplify the exposition, it is easy to add a layer between the two actions of Player 1 to make the automaton turn-based. In those additional states, Player 2 would have only one action and the operation Pre 2 would simulate the identity. The objective of Player 1 is to ensure that the control ends up in state ok ∈ S 3 , so we take L = {{ok}}. Now, we explain how to put transitions between states and compute Pre 2 (Pre 1 (Pre 1 (((L))). The transitions from S 2 and S 3 are {((v, e, i), (e, i), ok)</p><formula xml:id="formula_51">| π i (e) = v} ∪ {((v, e , i), (e, i), ko) | π i (e) = v ∨ e = e )}, it is easy to verify that Pre 1 (L) is equal to ↓ e∈E {{(v, e, 1) | v = π 1 (e)}, {(v, e, 2) | v = π 2 (e)}.</formula><p>The transitions from S 1 to S 2 are {( <ref type="figure">(v,</ref><ref type="figure">e),</ref><ref type="figure">i,</ref><ref type="figure">(v,</ref><ref type="figure">e,</ref><ref type="figure">i</ref>) </p><formula xml:id="formula_52">) | i ∈ {1, 2} ∧ v ∈ V ∧ e ∈ E}.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>((L))).</head><p>Corollary 1 There is no polynomial time algorithm to compute the Pre 2 operation on antichains unless P = NP.</p><p>Note that this negative result is not a weakness of antichains. Indeed, it is easy to see from the proofs of those results that any algorithm based on a data structure that is able to represent compactly the set of subsets of a given set has this property.</p><p>Synthesis If a UCWA is realizable, it is easy to extract from the greatest fixpoint computation a Moore machine that realizes it. Let F * 2 and F * 1 be the two sets obtained by the greatest fixpoint computation. In particular, F * 2 and F * 1 are downward-closed and Pre</p><formula xml:id="formula_53">1 (F * 2 ) = F * 1 , Pre 2 (F * 1 ) = F * 2 .</formula><p>By definition of Pre 1 , for all F ∈ F * 1 , there exists σ F ∈ such that succ(F, σ F ) ∈ F * 2 , and this σ F can be computed. From this we can extract a Moore machine whose set of states is F * 1 , the output function maps any state F ∈ F * 1 to σ F , and the transition function, when reading some σ ∈ 2 , maps F to a state F ∈ F * 1 such that succ(succ(F, σ F ), σ ) F (it exists by definition of the fixpoint and by monotonicity of succ). The initial state is some state F ∈ F * 1 such that F 0 F (it exists if the specification is realizable). Let M be this Moore machine. For any word w accepted by M, it is clear that w is also accepted by det(A, K), as succ is monotonic and</p><formula xml:id="formula_54">F * 1 ⊆ safe. Therefore L(M) ⊆ L uc,0 (det(A, K)) = L uc,K (A) ⊆ L uc (A).</formula><p>Theorem 6 Let F * 2 and F * 1 be the two sets obtained by the greatest fixpoint computation of the backward algorithm, if F 0 ∈ F * 1 , then there exists a Moore machine with less than | F * 1 | states that encodes a winning strategy for Player 1 in the underlying safety game.</p><p>Example We apply the antichain algorithm on the game of Fig. <ref type="figure" target="#fig_0">1(b)</ref>. Remember that I = {r} and O = {g}, so that 2 = {∅, {r}} and 1 = {∅, {g}}. We denote counting functions in brackets and omit the states that map to -1. Note that some counting functions of the game do not appear in the picture as they are not reachable. We start the computation from the set of safe positions S 1 = {[q 1 → 0, q 3 → 1], [q 1 → 0, q 3 → 0], [q 1 → 0]} represented by the antichain {[q 1 → 0, q 3 → 1]}. One application of Pre 2 on S 1 returns the set S 2 = ↓[q 2 → 0, q 4 → 1]. Then one application of Pre 1 on S 2 returns the set S 1 . Therefore, we reach the fixpoint S 2 in one application of CPre.</p><p>From this fixpoint, we can compute a Moore machine. Let</p><formula xml:id="formula_55">F 1 = [q 1 → 0, q 3 → 1] and F 2 = [q 2 → 0, q 4 → 1]. Notice that S 0 = ↓F 1 and S 1 = ↓F 2 .</formula><p>The Moore machine has only one state F 1 . We then look at controller moves from F 1 that lead to a winning position. There is only one move {g}, which leads to the position [q 2 → 0]. This position is subsumed by F 2 , from which whatever the environment does, the next position is F 1 . Therefore there is a loop from F 1 to F 1 in the Moore machine, for the two possible moves of the environment: {r} and ∅. It is depicted in Fig. <ref type="figure">2</ref>. Therefore the controller strategy obtained with our procedure is to always output a grant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Forward algorithm for safety games with antichains</head><p>The forward algorithm of Sect. 3 can be used to solve the game G(A, k). As for the backward algorithm, it is not necessary to construct the game explicitly. Indeed, during the execution Fig. <ref type="figure">2</ref> Moore machine of the OTFUR algorithm, the successors of a position F , which is a counting function, can be computed on demand via the successor function succ. Compared to the backward algorithm, the forward algorithm has the following advantage: it computes only the winning positions F (for Player 1) which are reachable from the initial position. We now show how to optimize this algorithm with antichains. We describe several optimizations.</p><p>Optimization 1: Antichain of losing positions Let denote by L the set of losing positions for Player 1 in G(A, k). Clearly, this set is upward closed. Indeed if Player 1 is not able to win in some position F , then she cannot win from any position where one or several counters of F have been increased. Therefore L can be represented by the antichain of its minimal elements. We can compute L incrementally during the execution of the OTFUR algorithm. For this we maintain an antichain L of (minimal) losing positions computed so far, i.e. at each step of the algorithm L = {F |Losing[F ] = true} . This set is updated each time a new position is known to be losing. We can use this information to prune the search space. Indeed, when we pick an edge (s, s ) in the waiting list, if s has never been visited before and s ∈ ↑L, then we can directly set Losing[s ] = true and we do not need to add the successors of s in the waiting list. If s has never been visited and s ∈ ↑L, then among the successors s of s , we add in the waiting list only those which are not in ↑L. Finally if s has already been visited, we check that s ∈ ↑L. In this case we do not need to inspect the successors of s.</p><p>Optimization 2: Minimal and maximal successors Let F be a position of G(A, k) owned by Player 1 (the controller). Clearly, F is losing (for the controller) iff all its minimal successors are losing. We get the dual of this property when F is a position owned by Player 2 (the environment). In this case F is losing (for the controller) iff one of its maximal successors is losing. Therefore to decide whether a position is losing, depending on whether it is a controller or an environment position, we have to visit its minimal or its maximal successors only. At line 11, this is done by adding to the waiting list only the edges (s , s ) such that s is a minimal (or maximal) successor of s . In the case of a position owned by the controller, we can do even better. Indeed, we can add only one minimal successor in the waiting list at a time. If it turns out that this successor is losing, we add another minimal successor. Among the minimal successors, the choice is done as follows: we prefer to add an edge (s , s ) such that s has already been visited. Indeed, this potentially avoids unnecessary developments of new parts of the game.</p><p>We call FORWARD_ALL the method which consists of the OTFUR algorithm with optimization 1. We call FORWARD_EXI the method which consists of the OTFUR algorithm with optimizations 1 and 2. The difference between the two methods in the context of a compositional reasoning is discussed in depth in the following section. Informally, FOR-WARD_ALL computes the set of all reachable winning positions of the game, while FOR-WARD_EXI computes only a subset of it, as some pruning methods are used. However this subset is sufficient to decide whether the formula is realizable or not.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Performance evaluation on the monolithic approach</head><p>In this section, we briefly present our implementation Acacia and compare it to Lily <ref type="bibr" target="#b17">[15]</ref>. Acacia is a prototype implementation of the backward and forward antichain algorithms for LTL synthesis. To achieve a fair comparison, Acacia is written in Perl as Lily. Given an LTL formula and a partition of its propositions into inputs and outputs, Acacia tests realizability of the formula. If it is realizable, it outputs a Moore machine representing a winning strategy for the output player, <ref type="foot" target="#foot_5">10</ref> otherwise it outputs a winning strategy for the input player. As Lily, Acacia runs in two steps. The first step builds a tbUCW for the formula, and the second step checks realizability of the automaton. As Lily, we borrow the LTL-to-tbUCW construction procedure from Wring <ref type="bibr" target="#b32">[30]</ref> and adopt the automaton optimizations from Lily, so that we can exclude the influence of automata construction to the performance comparison between Acacia and Lily. <ref type="foot" target="#foot_6">11</ref>Comparison with Kupferman-Vardi's approach (implemented in Lily) In <ref type="bibr" target="#b21">[19]</ref>, the authors give a Safraless procedure for LTL synthesis. It is a three steps algorithm: (i) transform an LTL formula into a universal co-Büchi tree automaton (UCT) A that accepts the winning strategies of the system, (ii) transform A into an alternating weak tree automaton B (AWT) such that L(B) = ∅ iff L(A) = ∅, (iii) transform B into an equivalent Büchi tree automaton C (NBT) and test its emptiness. This latter problem can be seen as solving a game with a Büchi objective. This approach differs from our approach in the following points. First, in <ref type="bibr" target="#b21">[19]</ref>, the authors somehow reduce the realizability problem to a game with a Büchi objective, while our approach reduces it to a game with a safety objective. Second, our approach allows one to define a natural partial order on states that can be exploited by an antichain algorithm, which is not obvious in the approach of <ref type="bibr" target="#b21">[19]</ref>. Finally, in <ref type="bibr" target="#b21">[19]</ref>, states of AWT are equipped with unique ranks that partition the set of states into layers. States which share the same rank are either all accepting or all non-accepting. The transition function allows one to stay in the same layer or to go in a layer with lower rank. A run is accepting if it gets stuck in a nonaccepting layer. While our notion of counters looks similar to ranks, it is different. Indeed, the notion of rank does not constrain the runs to visit accepting states a bounded number of times (bounded by a constant). This is why a Büchi acceptance condition is needed, while counting the number of visited accepting states allows us to define a safety acceptance condition. Therefore the bound k we use in our approach and the rank are different notions. It is possible to construct examples for which our bound is exponentially larger than the rank of Lily.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Results</head><p>We carried out experiments on a Linux platform with a 3.2 GHz CPU (Intel i7) and 12 GB of memory. We compared Acacia and Lily on the test suite included in Lily, and on other examples derived from Lily's examples, as detailed in the sequel. Let consider Table <ref type="table" target="#tab_1">1</ref>. Formula size gives the sizes of the formulas. They correspond to the number of atomic propositions and connectives. For realizability tests, Lily and Acacia construct the same tbUCW. However to check unrealizability, the methods differ, which results in different tbUCW. Indeed, while we check realizability by the environment of the negated specification, where the system does the first move, Lily checks realizability by the environment of the negated specification, where the environment does the first move. Therefore Lily takes as input the negated formula where every occurrence of an output signal σ is replaced by X σ . The number of states (column tbUCW state) as well as the time to construct the tbUCW (column tbUCW Time(s)) are given in the table (for unrealizable specifications, we put this time in parenthesis for Lily). We consider different algorithms for testing realizability: Lily, the backward antichain algorithm, and two versions of the forward algorithm, FORWARD_ALL and FORWARD_EXI respectively, described in the previous section. For all the methods, we give the time to check for realizability (column Check time(s)). The column |Moore machine| gives the size of the synthesized Moore machine. We also give the rank used in Lily and the bound k (column k) needed for our methods (it is common to the three methods we use). Finally, the timeout is fixed to 1 hour, and is denoted by &gt; t. When the execution runs out of memory, we denote it by &gt; m. (including the tbUCW construction), the improvement in time complexity compared to Lily is less impressive, because the time to construction the automaton is often much bigger than the realizability check time. However it was not expected that this first step would have been the bottleneck of the approach. Indeed in the classical approach of <ref type="bibr" target="#b26">[24]</ref>, the foreseen bottleneck is clearly the second step, which relies on Safra's determinization. In the following sections, we will focus on a compositional approach that overcomes this problem, as indeed in this approach the formulas are divided into smaller specifications for which we can construct the automaton independently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Compositional safety games and LTL synthesis</head><p>In this section, we define compositional safety games and develop two compositional algorithms to solve such games. Compositional reasoning on safety games are supported by the existence of a most permissive strategy, that we formalized under the notion of master plan.</p><p>Master plan Let G = (S 1 , S 2 , 1 , 1 , 2 ) be a safety game on a finite set of moves Moves = Moves 1 Moves 2 . Let W be the winning positions of G for Player 1. Let 1 : S 1 → 2 Moves 1 be defined as follows: for all s ∈ S 1 , 1 (s) = {m ∈ 1 (s) | 1 (s, m) ∈ W } i.e., 1 (s) contains all the moves that Player 1 can play in s in order to win the safety game. We call 1 the master plan of Player 1 and we write it MP(G). The following lemma states that MP(G) can be interpreted as a compact representation of all the winning strategies of Player 1 in the game G: Lemma 5 For all strategies λ 1 of Player 1 in G, for all s ∈ S, λ 1 is winning in G from s iff λ 1 is a strategy in (G[MP(G)], s) and λ 1 (s) =⊥.</p><p>The master plan associated with a game can be computed in a backward fashion by using variants of the CPre operator and sequence W defined in Sect. 3. The variant of CPre considers the effect of some Player 1's move followed by some Player 2's move. Let CPre : (S 1 → 2 Moves 1 ) → (S 1 → 2 Moves 1 ) be defined as follows. For all s ∈ S 1 , let: Remark 1 It should be noted that each i in Algorithm 2 can be replaced by the full master plan without changing the output of the forward algorithm. Indeed, it is easy to see that Reach(G[MP Reach (G, s ini )], s ini ) = Reach(G[MP(G)], s ini ). So, we can mix the backward and forward algorithms. For instance, we can compute locally the master plan of each G i using the backward algorithm of Sect. 6, and then check global realizability using the OTFUR algorithm.</p><formula xml:id="formula_56">CPre( )(s) = m ∈ (s) | ∀m ∈ Moves 2 : ( 2 ( 1 (s, m), m )) = ∅ .</formula><p>Compositional LTL synthesis We show how to define compositionally the safety game associated with an LTL formula when this formula is given as a conjunction of subformulas i.e., ψ = φ 1 ∧ φ 2 ∧ • • • ∧ φ n . We first construct for each subformula φ i the corresponding tbUK CWA φ i on the alphabet of ψ , <ref type="foot" target="#foot_7">13</ref> and their associated safety games G(φ i , K). The game G(ψ, K) for the conjunction ψ is isomorphic to the game i=n i=1 G(φ i , K). To establish this result, we rely on a notion of product at the level of turn-based automata.</p><formula xml:id="formula_57">Let A i = ( 2 , 1 , Q i 2 , Q i 1 , q i 0 , α i , δ i 2 , δ i 1 )</formula><p>for i ∈ {1, 2} be two turn-based automata, then their product A 1 ⊗ A 2 is the turn-based automaton defined as</p><formula xml:id="formula_58">( 2 , 1 , Q 1 2 Q 2 2 , Q 1 1 Q 2 1 , Q 1 ini Q 2 ini , α 1 α 2 , δ 1 2 δ 2 2 , δ 1 1 δ 2 1</formula><p>). As we use universal interpretation i.e., we require all runs to respect the accepting condition, it is clear that executing the A 1 ⊗ A 2 on a word w is equivalent to execute both A 1 and A 2 on this word. So w is accepted by the product iff it is accepted by each of the automata. Proposition 6 Let A 1 and A 2 be two UCW on the alphabet 1 2 , and K ∈ N:</p><formula xml:id="formula_59">(i) L uc (A 1 ⊗ A 2 ) = L uc (A 1 ) ∩ L uc (A 2 ), (ii) L uc,K (A 1 ⊗ A 2 ) = L uc,K (A 1 ) ∩ L uc,K (A 2 ).</formula><p>As the state space and transition relation of A 1 ⊗ A 2 is the disjunct union of the space spaces and transition relations of A 1 and A 2 , the determinization of A 1 ⊗ A 2 for a fixed K ∈ N is equivalent to the synchronized product of the determinizations of A 1 and A 2 for that K, and so we get the following theorem.</p><formula xml:id="formula_60">Theorem 9 Let ψ = φ 1 ∧ φ 2 ∧ • • • ∧ φ n , K ∈ N, G(ψ, K) is isomorphic to i=n i=1 G(φ i , K).</formula><p>Assume from now on that we have fixed some K ∈ N. In order to solve the game G(ψ, K), in practice we first solve locally the subgames G(φ i , K) by computing their master plans, or their reachable master plans, and then compute the master plan of their composition. In particular, to compute the master plan of a local game, we can use the backward algorithm described in Sect. 6 with the optimizations based on antichains. Indeed, the antichain of winning positions provides a compact representation of the master plan. In particular, let F be some Player 1's position in some safety game G(ψ, K) and let W be the antichain of maximal winning positions (for Player 1). Then:</p><formula xml:id="formula_61">MP(G(ψ, K))(F ) = ∅ if F ∈ ↓W {σ ∈ 1 |succ(F, σ ) ∈ ↓W } otherwise.</formula><p>To compute the master plan of reachable positions, we can use the forward OTFUR algorithm. However only the optimization which maintains an antichain of losing positions (see Sect. 6) can be used in the forward algorithm. Indeed, the optimization based on the minimal and maximal successors are used to prune the search space. Although it works when one wants to decide if there is a winning strategy, it is not correct to use it for computing the master plan (which is a representation of all the winning strategies) as some parts of the safety game may be ignored by the pruning strategy. In practice, we can use the FORWARD_ALL or BACKWARD algorithms for the local intermediate games and the FORWARD_EXI algorithm for the global game.</p><p>Dropping assumptions Even if it is natural to write large LTL specifications as conjunctions of subformulas φ 1 ∧ • • • ∧ φ n , formulas of the following form are often used:</p><formula xml:id="formula_62">i=n i=1 ψ i → j =m j =1 φ j</formula><p>where ψ i 's formalize a set of assumptions made on the environment (Player 2) and φ j 's formalize a set of guarantees that the system (Player 1) must enforce. In this case, we rewrite the formula into the logical equivalent formula</p><formula xml:id="formula_63">j =m j =1 i=n i=1 ψ i → φ j</formula><p>which is a conjunction of LTL formulas as needed for the compositional construction described above. As logical equivalence is maintained, realizability is maintained as well. The formulas of the form j =m j =1 (( i=n i=1 ψ i ) → φ j ) are larger than the original formula as assumptions are duplicated. However the subformulas ( i=n i=1 ψ i ) → φ j , j ∈ {1, . . . , m} are usually such that to guarantee φ j , Player 1 does not need all the assumptions on the left of the implication. It is thus tempting to remove those assumptions that are locally unnecessary in order to get smaller local formulas. In practice, we apply the following rule. Let ψ 1 ∧ ψ 2 → φ be a local formula such that ψ 2 and φ do not share common propositions then we replace ψ 1 ∧ ψ 2 → φ by ψ 1 → φ. This simplification is correct in the following sense: if the formula obtained after dropping some assumptions in local formulas is realizable then the original formula is also realizable. Further, a Player 1's strategy to win the game defined by the simplified formula is also a Player 1's strategy to win the game defined by the original formula. This is justified by the fact that the new formula logically implies the original formula i.e. ψ 1 → φ logically implies ψ 1 ∧ ψ 2 → φ. However, this heuristic is not complete because the local master plans may be more restrictive than necessary as we locally forget about global assumptions that exist in the original formula. We illustrate this on two examples.</p><p>Let I = {req}, O = {grant} and φ = ( ♦req) → ♦grant. In this formula, the assumption ♦req is not relevant to the guarantee ♦grant. Realizing φ is thus equivalent to realizing ♦grant. However, the set of strategies realizing φ is not preserved when dropping the assumption. Indeed, the strategy that outputs a grant after each req realizes φ but it does not realize ♦grant, as this strategy relies on the behavior of the environment. Thus dropping assumption is weaker than the notion of open implication of <ref type="bibr" target="#b15">[13]</ref>, which requires that the strategies realizing φ have to realize ♦grant.</p><p>As illustrated by the previous example, dropping assumption does not preserve the set of strategies that realize the formula. Therefore, it can be the case that a realizable formula cannot be shown realizable with our compositional algorithm after locally dropping assumptions. In addition, it can be the case that a formula becomes unrealizable after dropping local assumptions. Consider for instance the formula φ = ♦req → ( ♦grant ∧ (X (¬grant) U req)). This formula is realizable, for instance by the strategy which outputs a grant iff the environment signal at the previous tick was a req. Other strategies realize this formula, like those which grant a request every n req signal (n is fixed), but all the strategies that realize φ have to exploit the behavior of the environment. Thus there is no strategy realizing the conjunction of ♦grant and φ. Consequently, when we decompose φ into ♦req → ♦grant and ♦req → (X (¬grant) U req), we must keep ♦req in the two formulas.</p><p>Nevertheless, in our experiments, the dropping assumption heuristic is very effective and almost always maintains compositional realizability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Experiments: Compositional approach</head><p>As the monolithic methods, the compositional algorithms have been implemented in our prototype ACACIA. The performances are evaluated on the examples provided with the tool LILY and on a larger specification of a buffer controller inspired by the IBM rulebase tutorial <ref type="bibr" target="#b16">[14]</ref>. Some results are reported on Table <ref type="table" target="#tab_4">3</ref>.</p><p>Lily's test cases and a parametric example First, we compare the performances of the new compositional algorithms with the best results of the monolithic approach, which are the ones obtained via the monolithic FORWARD_EXI method. This is done on Lily's realizable examples among 1 to 23 and the parametric examples 3.1 to 3.7. For the compositional approach, we use the backward fixpoint algorithm to solve the local safety games, and the forward method FORWARD_EXI to solve the global game. The formula tested for the comparison with previous works are of moderate size. It should be noted that for larger formulas, it is often not possible to construct the UCW at all, and so the monolithic algorithm are not applicable. <ref type="foot" target="#foot_8">14</ref>In those benchmarks, the formulas are of the form i=n i=1 ψ i → j =m j =1 φ j where i=n i=1 ψ i are a set of assumptions and j =m j =1 φ j are a set of guarantees. We decompose such formula into several pieces ( i=n i=1 ψ i ) → φ j , as described in the previous section. We consider different methods for checking realizability: a monolithic approach and two compositional approaches. The second realizability method is the same as the first but includes the dropping assumption (DA) heuristic when it is applicable. For each of the method, we give the size of the constructed automata and the time to construct them. We also give the time for realizability checking (including the strategy synthesis), and finally the total time (the best total time is in bold face). Let us mention that when applying our compositional algorithm, we construct a tbUCW for each conjunct ( i=n i=1 ψ i ) → φ j . Therefore the column |tbUCW| refers to the size of tbUCW by monolithic approach and i (|tbUCW i |) refers to the sum of sizes of tbUCW corresponding to the sub-specifications of the decomposition.</p><p>On small examples, we can see that the benefit of the compositional approach is not big (and in some cases the monolithic approach is even better). However for bigger formulas (demo 3.2 to 3.7), decomposing the formulas decreases the time to construct the automata, and the total realizability time is therefore better. Now, we evaluate the benefit of dropping assumptions (last group of columns). For those experiments, we only consider the subset of formulas for which this heuristic can be applied. Our dropping heuristic does not work for demo 9 as it becomes unrealizable after the application of dropping assumptions. As we see in the table, the benefit of dropping assumptions is important and is growing with the size of the formulas that are considered. The compositional algorithms outperform the monolithic ones when combined with dropping assumptions. They also show promises for better scalability. This is confirmed by our next benchmark.</p><p>A realistic case study Now, we consider a set of realistic formulas. All those formulas are out of reach of the monolithic approach as even the Büchi automaton for the formula cannot be constructed with state of the art tools. The generalized buffer (GenBuf) originates from the IBM's tutorial for her RuleBase verification tool. The benchmark has also the nice property that it can be scaled up by increasing the number of receivers in the protocol. A detailed description of the case study is given in the Appendix as well as our LTL formalization. In this case study, the formulas are of the form i=n i=1 ψ i → φ i and so they are readily amenable to our compositional algorithms.</p><p>In this case study, formulas are large: for example, the sum of the number of states in the UCW of the components is 96 for gb(s 2 , r 2 ), and 2399 states for gb(s 2 , r 7 ). Note that the tool Wring cannot handle gb(s 2 , r 2 ) monolithically.</p><p>This case study allows us to illustrate the effect of different strategies for exploiting associativity of the product operation. In particular, we use different ways of parenthesizing the local games. In all those examples, the local games and intermediate combination of local games are solved with the backward antichain algorithm, while the last compositional step (at the top) is done with the FORWARD_EXI method. In each strategy we first compute the master plan of each sub-formula. Then the column Flat refers to the strategy that check global realizability directly. The column Binary refers to the strategy that computes global realizability incrementally using the binary tree of sub-formulas. Finally, the column Heuris- tic refers to the strategy that computes global realizability incrementally using a specific tree of sub-formula defined by the user. <ref type="foot" target="#foot_9">15</ref> The column UCW_OPT refers to the time to optimize the automata with Lily's optimizations (this time was included in the UCW time in Table <ref type="table" target="#tab_3">2</ref>). The last column in Table <ref type="table" target="#tab_3">2</ref> gives the size of the Moore machines that are constructed by our algorithm. Those machines are small when compared to the tbUCW from which they are constructed. For example, the Moore machine that encodes a winning strategy for Player 1 in the largest example (gb_s2_r7) has 149 states while the tbUCW for the specification has 2399 states. This is striking as in theory, the winning strategies could be exponentially larger than the tbUCW of their specification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix: Description of the generalized buffer controller</head><p>The generalized buffer (GenBuf) originates from the IBM's tutorial for her RuleBase verification tool.</p><p>Figure <ref type="figure">4</ref> illustrates the interface of a controller. To focus on its control flow, we abstract away the data buses DI and DO. And we do not connect it with a FIFO which is present in Anzu. Except those, our controller shares with RuleBase and Anzu the same interface.</p><p>The interface between GenBuf and the senders is a 4-phase handshaking protocol described below:</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1</head><label>1</label><figDesc>Fig.1UCW and safety game for the formula φ ≡ (r → X ♦g)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Algorithm 1 : 1 for 4 e 5 if s ∈ Passed then 6 Passed 9 if</head><label>114569</label><figDesc>OTFUR<ref type="bibr" target="#b7">[5]</ref> algorithm for safety games Data: G, s ini //Initialization Passed := {s ini }; Depend(s ini ) := ∅; all position s do Losing[s] := false;2 Waiting := {(s ini , s )|∃m ∈ 1 (s ini ) : s = 1 (s ini , m)};3 //Saturation while Waiting = ∅ ∧ ¬Losing[s ini ] do = (s, s ) := pop(Waiting); := Passed ∪ {s }; 7 Losing[s ] := s ∈ S 1 ∧ 1 (s ) = ∅; 8 Depend[s ] := {(s, s )}; Losing[s ] then 10 Waiting := Waiting ∪ {e}; //add e for reevaluation 11 else 12 Waiting := Waiting ∪ {(s , s )|∃m ∈ (s ) : s = (s , m)};</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>γ of length m, we associate H with the word w(H ) defined as follows: w(H ) = σ I 1 . . . σ I m where for all 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Example 3</head><label>3</label><figDesc>Figure 1(b)  represents the safety game G(φ, 1) where φ = (r → X ♦g). Positions are pairs of states of the UCW with their counter values. Player 1's positions are denoted by circles while Player 2's positions are denoted by squares. The unavailable move of Player 1 from position (q 2 , 0) is denoted by a dashed arrow. It goes to a position where a counter exceeds the value K. Any winning strategy in this game is a strategy which chooses the moves attached to plain arrows, as indeed Player 1 wins the game iff she never follows the dashed arrow.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>As states of S 1 belongs to Player 1 the controllable configurationsPre 1 (Pre 1 ((L)) are ↓ e∈E {{(v, e) | v = π 1 (e)}, {(v, e) | v = π 2 (e)}}. The transitions from S 0 to S 1 are {(v, e, (v, e)) | v ∈ V ∧ e ∈ E}.As states in S 0 belongs to Player 2, we have that ↓Pre 2 (Pre 1 (Pre 1 ((L))) = IND(G), indeed Player 2 can decide to verify any edge for independence, so only independent set of vertices can be in Pre 2 (Pre 1 (Pre 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 3</head><label>3</label><figDesc>Fig.3Two games and their common master plan of reachable positions Player 2. We assume that G 1 , G 2 contains only winning actions, i.e.G i = G i [MP(G i )] for i = 1, 2.The master plan of reachable positions for G 1 ⊗ G 2 corresponds to plain arrows. Dashed arrows are those which have been traversed during the OTFUR algorithm but have been removed due to back-propagation of information about losing positions. From node A, A the move o 3 is not a common move, therefore o 3 is not available in the product. However o 2 is available in both games and leads to C and C respectively. Similarly, o 1 is available in both games and goes to B, B . From B, B one can reach D, D by i 1 but from D, D there is no common action. Therefore D, D is unsafe. Since one of the successor of B, B is unsafe and B, B is owned by Player 2, B, B is declared to be unsafe as well. All the remaining moves are winning in the G 1 ⊗ G 2 , as they are winning both in G 1 and G 2 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1</head><label>1</label><figDesc>Performance comparison on tests included in Lily</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Lily</cell><cell></cell><cell cols="2">k Backward</cell><cell cols="4">Forward_ALL Forward_EXI</cell></row><row><cell>Examples</cell><cell>Realizable (y/n)</cell><cell>Formula size</cell><cell>tbUCW states</cell><cell>tbUCW Time (s)</cell><cell>Rank</cell><cell>Check time (s)</cell><cell>|Moore machine|</cell><cell>Check time (s)</cell><cell>|Moore machine|</cell><cell>Check time (s)</cell><cell>|Moore machine|</cell><cell>Check time (s)</cell></row><row><cell>3</cell><cell>y</cell><cell>32</cell><cell>20</cell><cell>0.49</cell><cell>1</cell><cell>0.12</cell><cell>0 2</cell><cell cols="2">0.00 2</cell><cell>0.01</cell><cell>2</cell><cell>0.01</cell></row><row><cell>5</cell><cell>y</cell><cell>41</cell><cell>26</cell><cell>0.72</cell><cell>1</cell><cell>0.27</cell><cell>0 2</cell><cell cols="2">0.00 3</cell><cell>0.02</cell><cell>3</cell><cell>0.01</cell></row><row><cell>6</cell><cell>y</cell><cell>45</cell><cell>37</cell><cell>1.22</cell><cell>1</cell><cell>0.42</cell><cell>0 3</cell><cell cols="2">0.02 4</cell><cell>0.04</cell><cell>5</cell><cell>0.02</cell></row><row><cell>7</cell><cell>y</cell><cell>47</cell><cell>22</cell><cell>0.60</cell><cell>1</cell><cell>0.13</cell><cell>0 2</cell><cell cols="2">0.00 3</cell><cell>0.02</cell><cell>3</cell><cell>0.01</cell></row><row><cell>8</cell><cell>y</cell><cell>11</cell><cell>7</cell><cell>0.04</cell><cell>1</cell><cell>0.01</cell><cell>0 1</cell><cell cols="2">0.00 1</cell><cell>0.00</cell><cell>1</cell><cell>0.00</cell></row><row><cell>9</cell><cell>y</cell><cell>21</cell><cell>13</cell><cell>0.13</cell><cell>1</cell><cell>0.02</cell><cell>1 2</cell><cell cols="2">0.01 3</cell><cell>0.00</cell><cell>3</cell><cell>0.00</cell></row><row><cell>10</cell><cell>y</cell><cell>19</cell><cell>18</cell><cell>0.28</cell><cell>1</cell><cell>0.05</cell><cell>0 1</cell><cell cols="2">0.01 1</cell><cell>0.00</cell><cell>1</cell><cell>0.00</cell></row><row><cell>12</cell><cell>y</cell><cell>19</cell><cell>14</cell><cell>0.14</cell><cell>1</cell><cell>0.03</cell><cell>0 1</cell><cell cols="2">0.00 2</cell><cell>0.01</cell><cell>1</cell><cell>0.00</cell></row><row><cell>13</cell><cell>y</cell><cell>11</cell><cell>7</cell><cell>0.00</cell><cell>1</cell><cell>0.01</cell><cell>1 2</cell><cell cols="2">0.00 3</cell><cell>0.01</cell><cell>2</cell><cell>0.01</cell></row><row><cell>14</cell><cell>y</cell><cell>29</cell><cell>14</cell><cell>0.11</cell><cell>1</cell><cell>0.01</cell><cell>1 3</cell><cell cols="2">0.00 2</cell><cell>0.01</cell><cell>2</cell><cell>0.01</cell></row><row><cell>15</cell><cell>y</cell><cell>35</cell><cell>16</cell><cell>0.06</cell><cell>1</cell><cell>0.01</cell><cell>2 6</cell><cell cols="2">0.02 6</cell><cell>0.02</cell><cell>6</cell><cell>0.00</cell></row><row><cell>16</cell><cell>y</cell><cell>60</cell><cell>21</cell><cell>0.22</cell><cell>1</cell><cell>0.60</cell><cell>3 20</cell><cell cols="2">0.31 17</cell><cell cols="2">0.22 17</cell><cell>0.07</cell></row><row><cell>17</cell><cell>y</cell><cell>47</cell><cell>17</cell><cell>0.16</cell><cell>1</cell><cell>0.13</cell><cell>2 7</cell><cell cols="2">0.04 6</cell><cell>0.19</cell><cell>3</cell><cell>0.03</cell></row><row><cell>18</cell><cell>y</cell><cell>77</cell><cell>22</cell><cell>0.34</cell><cell>1</cell><cell>1.02</cell><cell>2 19</cell><cell cols="2">0.21 18</cell><cell cols="2">1.82 11</cell><cell>0.11</cell></row><row><cell>19</cell><cell>y</cell><cell>33</cell><cell>18</cell><cell>0.31</cell><cell>3</cell><cell>1.86</cell><cell>2 3</cell><cell cols="2">0.01 4</cell><cell>0.06</cell><cell>4</cell><cell>0.01</cell></row><row><cell>20</cell><cell>y</cell><cell>71</cell><cell>105</cell><cell>2.67</cell><cell>1</cell><cell>0.56</cell><cell>0 1</cell><cell cols="2">0.01 6</cell><cell>0.30</cell><cell>2</cell><cell>0.01</cell></row><row><cell>21</cell><cell>y</cell><cell>99</cell><cell>27</cell><cell>7.38</cell><cell>1</cell><cell>0.88</cell><cell>0 25</cell><cell cols="2">0.22 64</cell><cell cols="2">0.34 64</cell><cell>0.28</cell></row><row><cell>22</cell><cell>y</cell><cell>58</cell><cell>45</cell><cell>7.08</cell><cell>1</cell><cell>0.51</cell><cell>1 4</cell><cell cols="2">0.03 4</cell><cell>0.06</cell><cell>4</cell><cell>0.02</cell></row><row><cell>23</cell><cell>y</cell><cell>21</cell><cell>14</cell><cell>0.02</cell><cell>1</cell><cell>0.02</cell><cell>0 2</cell><cell cols="2">0.00 3</cell><cell>0.01</cell><cell>3</cell><cell>0.00</cell></row><row><cell>1</cell><cell>n</cell><cell>25</cell><cell>16</cell><cell>0.11</cell><cell>-</cell><cell>0.01</cell><cell>1 1</cell><cell cols="2">0.00 2</cell><cell>0.00</cell><cell>2</cell><cell>0.01</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>(0.08)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>2</cell><cell>n</cell><cell>25</cell><cell>43</cell><cell>0.78</cell><cell>-</cell><cell>0.01</cell><cell>3 1</cell><cell cols="2">0.02 7</cell><cell>0.07</cell><cell>6</cell><cell>0.01</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>(0.07)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>4</cell><cell>n</cell><cell>35</cell><cell>55</cell><cell>1.37</cell><cell>1</cell><cell>0.28</cell><cell>2 3</cell><cell cols="2">0.03 10</cell><cell>0.11</cell><cell>7</cell><cell>0.02</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>(0.86)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>11</cell><cell>n</cell><cell>13</cell><cell>9</cell><cell>0.02</cell><cell>-</cell><cell>0.01</cell><cell>0 1</cell><cell cols="2">0.00 4</cell><cell>0.00</cell><cell>4</cell><cell>0.00</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>(0.64)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">3.2 y</cell><cell>56</cell><cell>36</cell><cell>0.94</cell><cell>1</cell><cell>3.42</cell><cell>0 4</cell><cell cols="2">0.02 4</cell><cell>0.18</cell><cell>2</cell><cell>0.00</cell></row><row><cell cols="2">3.3 y</cell><cell>80</cell><cell>56</cell><cell>1.80</cell><cell>1</cell><cell cols="2">226.82 0 8</cell><cell cols="2">0.15 8</cell><cell>3.37</cell><cell>2</cell><cell>0.02</cell></row><row><cell cols="2">3.4 y</cell><cell>104</cell><cell>84</cell><cell>3.12</cell><cell>-</cell><cell>&gt;t</cell><cell>0 16</cell><cell cols="2">1.24 16</cell><cell>70</cell><cell>2</cell><cell>0.04</cell></row><row><cell cols="2">3.5 y</cell><cell>128</cell><cell>128</cell><cell>4.74</cell><cell>-</cell><cell>&gt;t</cell><cell>0 32</cell><cell cols="2">9.94 32</cell><cell>1808</cell><cell>2</cell><cell>0.14</cell></row><row><cell cols="2">3.6 y</cell><cell>152</cell><cell>204</cell><cell>10.2</cell><cell>-</cell><cell>&gt;t</cell><cell>0 64</cell><cell>100</cell><cell>-</cell><cell>&gt;m</cell><cell>2</cell><cell>0.46</cell></row><row><cell cols="2">3.7 y</cell><cell>176</cell><cell>344</cell><cell>26.5</cell><cell>-</cell><cell>&gt;t</cell><cell cols="2">0 128 660</cell><cell>-</cell><cell>&gt;m</cell><cell>2</cell><cell>2.35</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Comments Lily's test suite includes examples 1 to 23. Except examples 1, 2, 4, and 11, they are all realizable. In the test suite, demo 3 describes a scheduler. We have taken a scalability test by introducing more clients. In Table 1, from 3.4 to 3.7, when the number of clients reached 4, Lily ran over-time (&gt; 3600 seconds). However, Acacia managed in finishing the check within the time bound. Clearly, the FORWARD_EXI method is most efficient. When considering Lily's examples 1 to 23 and the total time to check realizability</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2</head><label>2</label><figDesc>Performance comparison of the different compositional algorithms implemented in Acacia on Lily's benchmark</figDesc><table><row><cell></cell><cell cols="2">Monolithic</cell><cell></cell><cell></cell><cell cols="2">Compositional</cell><cell></cell><cell></cell><cell cols="3">Compositional + DA</cell><cell></cell></row><row><cell></cell><cell cols="2">FORWARD_EXI</cell><cell></cell><cell></cell><cell cols="3">FORWARD_EXI(global)</cell><cell></cell><cell cols="4">FORWARD_EXI(global)</cell></row><row><cell></cell><cell cols="2">FORWARD_EXI</cell><cell></cell><cell></cell><cell cols="3">BACKWARD(local)</cell><cell></cell><cell cols="3">BACKWARD(local)</cell><cell></cell></row><row><cell>Examples</cell><cell>|tbUCW| (states)</cell><cell>tbUCW Time (s)</cell><cell>Check Time (s)</cell><cell>Total time (s)</cell><cell>i |tbUCW i |</cell><cell>tbUCW Time (s)</cell><cell>Check Time (s)</cell><cell>Total time (s)</cell><cell>i |tbUCW i |</cell><cell>tbUCW Time (s)</cell><cell>Check Time (s)</cell><cell>Total time (s)</cell></row><row><cell>3</cell><cell>2 0</cell><cell>0 .49</cell><cell>0.01</cell><cell>0.5</cell><cell>28</cell><cell>0.40</cell><cell>0.01</cell><cell>0.41</cell><cell>17</cell><cell>0.06</cell><cell>0.00</cell><cell>0.06</cell></row><row><cell>5</cell><cell>2 6</cell><cell>0 .71</cell><cell>0.01</cell><cell>0.72</cell><cell>42</cell><cell>0.70</cell><cell>0.02</cell><cell>0.72</cell><cell>34</cell><cell>0.40</cell><cell>0.02</cell><cell>0.42</cell></row><row><cell>6</cell><cell>3 7</cell><cell>1 .22</cell><cell>0.02</cell><cell>1.24</cell><cell>57</cell><cell>1.14</cell><cell>0.03</cell><cell>1.17</cell><cell>45</cell><cell>0.79</cell><cell>0.06</cell><cell>0.85</cell></row><row><cell>7</cell><cell>2 2</cell><cell>0 .60</cell><cell>0.01</cell><cell>0.61</cell><cell>41</cell><cell>0.66</cell><cell>0.02</cell><cell>0.68</cell><cell>33</cell><cell>0.40</cell><cell>0.02</cell><cell>0.42</cell></row><row><cell>9</cell><cell>1 3</cell><cell>0 .13</cell><cell>0.00</cell><cell>0.13</cell><cell>31</cell><cell>0.26</cell><cell>0.00</cell><cell>0.26</cell><cell>na</cell><cell>na</cell><cell>na</cell><cell>na</cell></row><row><cell>13</cell><cell>7</cell><cell>0.00</cell><cell>0.01</cell><cell>0.01</cell><cell>4</cell><cell>0.01</cell><cell>0.00</cell><cell>0.01</cell><cell>na</cell><cell>na</cell><cell>na</cell><cell>na</cell></row><row><cell>14</cell><cell>14</cell><cell>0.11</cell><cell>0.01</cell><cell>0.12</cell><cell>27</cell><cell>0.77</cell><cell>0.01</cell><cell>0.78</cell><cell>15</cell><cell>0.03</cell><cell>0.00</cell><cell>0.03</cell></row><row><cell>15</cell><cell>16</cell><cell>0.06</cell><cell>0.00</cell><cell>0.06</cell><cell>22</cell><cell>0.11</cell><cell>0.03</cell><cell>0.14</cell><cell>na</cell><cell>na</cell><cell>na</cell><cell>na</cell></row><row><cell>16</cell><cell>21</cell><cell>0.22</cell><cell>0.07</cell><cell>0.29</cell><cell>45</cell><cell>0.20</cell><cell>0.14</cell><cell>0.34</cell><cell>na</cell><cell>na</cell><cell>na</cell><cell>na</cell></row><row><cell>17</cell><cell>17</cell><cell>0.16</cell><cell>0.03</cell><cell>0.19</cell><cell>23</cell><cell>0.16</cell><cell>0.05</cell><cell>0.21</cell><cell>na</cell><cell>na</cell><cell>na</cell><cell>na</cell></row><row><cell>18</cell><cell>22</cell><cell>0.34</cell><cell>0.11</cell><cell>0.45</cell><cell>45</cell><cell>0.35</cell><cell>0.16</cell><cell>0.51</cell><cell>na</cell><cell>na</cell><cell>na</cell><cell>na</cell></row><row><cell>19</cell><cell>18</cell><cell>0.31</cell><cell>0.01</cell><cell>0.32</cell><cell>27</cell><cell>0.25</cell><cell>0.03</cell><cell>0.28</cell><cell>27</cell><cell>0.26</cell><cell>0.01</cell><cell>0.27</cell></row><row><cell>20</cell><cell>105</cell><cell>2.67</cell><cell>0.01</cell><cell>2.68</cell><cell>154</cell><cell>2.43</cell><cell>0.03</cell><cell>2.46</cell><cell>101</cell><cell>1.52</cell><cell>0.02</cell><cell>1.54</cell></row><row><cell>21</cell><cell>27</cell><cell>7.38</cell><cell>0.28</cell><cell>7.66</cell><cell>43</cell><cell>1.40</cell><cell>0.52</cell><cell>1.92</cell><cell>44</cell><cell>0.55</cell><cell>0.51</cell><cell>1.06</cell></row><row><cell>22</cell><cell>45</cell><cell>7.08</cell><cell>0.02</cell><cell>7.1</cell><cell>80</cell><cell>10.26</cell><cell>0.05</cell><cell>10.31</cell><cell>49</cell><cell>1.51</cell><cell>0.13</cell><cell>1.64</cell></row><row><cell>3.2</cell><cell>36</cell><cell>0.94</cell><cell>0.00</cell><cell>0.94</cell><cell>40</cell><cell>0.79</cell><cell>0.02</cell><cell>0.81</cell><cell>na</cell><cell>na</cell><cell>na</cell><cell>na</cell></row><row><cell>3.3</cell><cell>56</cell><cell>1.80</cell><cell>0.02</cell><cell>1.82</cell><cell>60</cell><cell>1.21</cell><cell>0.06</cell><cell>1.27</cell><cell>na</cell><cell>na</cell><cell>na</cell><cell>na</cell></row><row><cell>3.4</cell><cell>84</cell><cell>3.12</cell><cell>0.04</cell><cell>3.16</cell><cell>80</cell><cell>1.63</cell><cell>0.10</cell><cell>1.73</cell><cell>na</cell><cell>na</cell><cell>na</cell><cell>na</cell></row><row><cell>3.5</cell><cell>128</cell><cell>3.52</cell><cell>0.12</cell><cell>3.64</cell><cell>100</cell><cell>2.04</cell><cell>0.17</cell><cell>2.21</cell><cell>na</cell><cell>na</cell><cell>na</cell><cell>na</cell></row><row><cell>3.6</cell><cell>204</cell><cell>10.22</cell><cell>0.46</cell><cell>10.68</cell><cell>120</cell><cell>2.40</cell><cell>0.39</cell><cell>2.79</cell><cell>na</cell><cell>na</cell><cell>na</cell><cell>na</cell></row><row><cell>3.7</cell><cell>344</cell><cell>26.48</cell><cell>2.35</cell><cell>28.82</cell><cell>140</cell><cell>2.96</cell><cell>1.02</cell><cell>3.98</cell><cell>na</cell><cell>na</cell><cell>na</cell><cell>na</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3</head><label>3</label><figDesc>Performance comparison on a scalability test for the forward methods Diagram of a buffer controller connected with 2 senders and 2 receivers</figDesc><table><row><cell></cell><cell>k</cell><cell></cell><cell></cell><cell></cell><cell>FLAT</cell><cell>BINARY</cell><cell>HEURISTIC</cell><cell></cell></row><row><cell></cell><cell></cell><cell>|tbUCW|</cell><cell>tbUCW Time (s)</cell><cell>UCW_OPT Time (s)</cell><cell>Check Time (s)</cell><cell>Check Time (s)</cell><cell>Check Time (s)</cell><cell>|Moore machine|</cell></row><row><cell>gb_s2_r2</cell><cell>2</cell><cell>91</cell><cell>4.83</cell><cell>0.08</cell><cell>0.84</cell><cell>0.99</cell><cell>0.98</cell><cell>54</cell></row><row><cell>gb_s2_r3</cell><cell>2</cell><cell>150</cell><cell>8.52</cell><cell>0.17</cell><cell>7.33</cell><cell>36.27</cell><cell>6.99</cell><cell>63</cell></row><row><cell>gb_s2_r4</cell><cell>2</cell><cell>265</cell><cell>15.64</cell><cell>0.53</cell><cell>36.88</cell><cell>125.60</cell><cell>24.19</cell><cell>86</cell></row><row><cell>gb_s2_r5</cell><cell>2</cell><cell>531</cell><cell>26.48</cell><cell>2.11</cell><cell>154.02</cell><cell>266.36</cell><cell>70.41</cell><cell>107</cell></row><row><cell>gb_s2_r6</cell><cell>2</cell><cell>1116</cell><cell>50.70</cell><cell>14.38</cell><cell>889.12</cell><cell>1164.44</cell><cell>335.44</cell><cell>132</cell></row><row><cell>gb_s2_r7</cell><cell>2</cell><cell>2399</cell><cell>92.01</cell><cell>148.46</cell><cell>2310.74</cell><cell>&gt;t</cell><cell>1650.83</cell><cell>149</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_0"><p>Analysis of cycles in automata over infinite words has previously been exploited in bounded modelchecking, see<ref type="bibr" target="#b20">[18]</ref> for a formal treatment.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_1"><p>Note that in this game, Player 1 is first to play as in the original game.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_2"><p>GR(1) has a better worst-case complexity than full LTL.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_3"><p>Note that this tbUCW is equivalent to the tbNBW of the negation of the specification, i.e., the formula ♦(r ∧ ¬g). So, tools for translation of LTL to NBW can be used to obtain the UCW when applied to the negation of the specification.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_4"><p>An similar result expressed on co-Büchi tree automata can be found in<ref type="bibr" target="#b30">[28]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_5"><p>Note that the correctness of this Moore machine can be automatically verified by model-checking tools if desired.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11" xml:id="foot_6"><p>In Lily, this first step produces universal co-Büchi tree automata over 1 -labeled 2 -trees, which can easily be seen as tbUCWs over inputs 2 and outputs 1 . Although the two models are close, we introduced tbUCWs for the sake of clarity (as all our developments are done on construction for word automata).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="13" xml:id="foot_7"><p>It is necessary to keep the entire alphabet when considering the subformulas to ensure proper definition of the product of games that asks for components defined on the same set of moves.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="14" xml:id="foot_8"><p>This is the case for the larger formulas in the IBM case study below.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="15" xml:id="foot_9"><p>The input language of our tool allow us to specify sub-formula (spec-units) and composition rules to guide the incremental construction of the global winning strategy, see the Appendix.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Work supported by the projects: (i) QUASIMODO (FP7-ICT-STREP-214755), Quasimodo: "Quantitative System Properties in Model-Driven-Design of Embedded", http://www.quasimodo.aau.dk/, (ii) GASICS (ESF-EUROCORES LogiCCC), Gasics: "Games for Analysis and Synthesis of Interactive Computational Systems", http://www.ulb.ac.be/di/gasics/, (iii) Moves: "Fundamental Issues in Modelling, Verification and Evolution of Software", http://moves.ulb.ac.be, a PAI program funded by the Federal Belgian Gouvernment, and (iv) ECSPER (ANR-JC09-472677) and SFINCS (ANR-07-SESU-012), two projects supported by the French National Research Agency.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Consider the following sequence of functions: 0 = 1 , and i = CPre( i-1 ), i ≥ 1. This sequence stabilizes after at most O(|S|) iterations and we denote by the function on which the sequence stabilizes. Clearly, the value on which the sequence stabilizes corresponds exactly to the master plan of G:</p><p>Composition of safety games We now consider products of safety games. Let G i , i ∈ {1, . . . , n}, be n safety games G i = (S i 1 , S i 2 , i 1 , i 1 , i 2 ) defined on the same sets of moves Moves = Moves 1 Moves 2 . Their product, denoted by i=n i=1 G i , is the safety game 12 defined as follows: Backward compositional reasoning We now define a backward compositional algorithm to solve the safety game G ⊗ . The correctness of this algorithm is justified by the following simple lemmas. For readability, we express the properties for composed games defined from two components. All the properties generalize to any number of components. The first part of the lemma states that to compute the master plan of a composition, we can first reduce each component to its local master plan. The second part of the lemma states that the master plan of a component is the master plan of the component where the choices of Player 1 has been restricted by one application of the CPre operator. </p><p>1 , s i = s}. Given two functions 1 : S 1 → 2 Moves 1 and 2 : S 1 → 2 Moves 1 , we define 1 ∩ 2 as the function on domain S 1 such that for all s ∈ S 1 :</p><p>Based on Lemma 6, we propose the following compositional algorithm (Algo 2) to compute the master plan of a safety game defined as the composition of local safety games. First, compute locally the master plans of the components. Then compose the local master plans and apply one time the CPre operator to this composition. This application of CPre compute a new function that contains information about the one-step inconsistencies between local master plans. Project back on the local components the information gained by the function , and iterate. Correctness is asserted by Theorem 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 8</head><p>The value returned by Algorithm 2 is equal to MP(G ⊗ ). 12 Clearly, the product operation is associative up to isomorphism.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 2: Backward composition</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>. , s n ini )) return</head><p>Forward compositional reasoning When solving safety games, we may be interested only in computing winning strategies for a fixed starting position, say s ini . In this case, the value of the master plan is not useful for positions that are not reachable when playing winning strategies from s ini . So, we are interested in computing a master plan only for the winning and reachable positions. Given a game G and a state s ini , we denote by Reach(G, s ini ) the subset of positions that are reachable from s ini in G i.e., the position s such that there exists a finite sequence s 0 s 1 . . . s n with s 0 = s ini , s n = and for all i, 0 ≤ i &lt; n, there exists m ∈ 1 (s i ) ∪ Moves 2 such that s i+1 = (s i , m). The master plan of reachable positions for (G, s ini ), denoted by MP Reach (G, s ini ) is defined for all s ∈ S as follows:</p><p>The following lemma states that for a game defined compositionally, its master plan can also be defined compositionally. For readability we express the lemma only for two components but, as for the previous lemmas, it extends to any number of components:</p><p>Based on the previous lemma, Algorithm 3 shows how to compute the master plan of reachable positions of a safety game defined compositionally.</p><p>As composition of safety games is an associative operator, we can use variants of Algorithm 3 above where we first compose some of the components and compute their master plan of reachable positions before doing the global composition.</p><p>To efficiently compute the master plan of reachable positions of a game G, we can use the OTFUR algorithm defined in Sect. 6 (Algorithm 1). Indeed, at the end of the algorithm, the master plan which allows all moves that lead to a winning position is exactly MP Reach (G, s ini ). Figure <ref type="figure">3</ref> illustrates the result of the OTFUR algorithms applied on the product of two safety games G 1 , G 2 over the possible moves o 1 , o 2 , o 3 for Player 1 and i 1 , i 2 for</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 4 Behavior properties of GenBuf and its environment</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Properties of the behavior between GenBuf and the senders Assumption 1</head><p>The initial value of s2b_req(i) is low.</p><p>In the cycle following the assertion of b2s_ack(i), the sender should deassert the signal s2b_req(i).</p><p>The initial value of b2s_ack(i) is low. b2s_ack(i) = 0 Guarantee 2</p><p>When GenBuf can service the sender, it asserts b2s_ack(i). Immediate acknowledge is forbidden. Because the data of the sender are not valid until one step after the assertion of the request.</p><p>A Request from a sender shall always be acknowledged.</p><p>There is no acknowledge without a request.</p><p>Only one sender sends data at any one time.</p><p>Properties of the behavior between GenBuf and the receivers Assumption 4</p><p>The initial value of r2b_ack(i) is low.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>r2b_ack(i) = 0 Assumption 5</head><p>There is no acknowledge without a request.</p><p>A request from the buffer is always acknowledged.</p><p>The initial value of b2r_req(i) is low. b2r_req(i) = 0 Guarantee 6</p><p>A request is not lowered until it is served.</p><p>GenBuf will deassert its request to receiver i one cycle after the receiver i acknowledged the request.</p><p>GenBuf will not make two consecutive requests to any receiver, and guarantee round-robin scheduling. Suppose there are two receivers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Guarantee 9</head><p>GenBuf does not request two receivers simultaneously.</p><p>Property linking the sender side and the receiver side Guarantee 10 A request from the senders will always trigger a request to the receivers.</p><p>4. The end of the transaction is marked by GenBuf deasserting b2s_ack(i). A new transaction may begin one cycle after the deassertion of b2s_ack(i). GenBuf may hold b2s_ack(i) asserted for several cycles before eventually deasserting it.</p><p>The protocol between GenBuf and the receivers is similar, except that the GenBuf initiates the data transfer and it guarantees round-robin scheduling on the requests to the receivers.</p><p>Table <ref type="table">4</ref> lists the behavior properties of GenBuf and its environment. We present the formulas of gb(s 2 , r 2 ) as an example for the file format of Acacia'10. In this example, we define 4 components in terms of spec_unit. If all of them are realizable, the clause directed by group_order instructs Acacia'10 to continue along the parenthesized groups, like (sb_0 br_1) and (sb_1 br_0). The process halts whenever an unrealizable subgroup is encounted. The final step is to check the group which includes all the components.</p><p>assume G(b2r_req0=0 -&gt; X(r2b_ack0=0)); assume G(b2r_req0=1 -&gt; X(F(r2b_ack0=1))); b2r_req0=0; G(r2b_ack0=1 -&gt; X(b2r_req0=0)); G((b2r_req0=1 * r2b_ack0=0) -&gt; X(b2r_req0=1)); G((b2r_req0=1 * X(b2r_req0=0)) -&gt; X(b2r_req0=0 U (b2r_req0=0 * b2r_req1=1))); G((b2r_req0=0) + (b2r_req1=0) ); G((s2b_req0=1 + s2b_req1=1) -&gt; X(F(b2r_req0=1 + b2r_req1=1)));</p><p>assume G(b2r_req1=0 -&gt; X(r2b_ack1=0)); assume G(b2r_req1=1 -&gt; X(F(r2b_ack1=1))); b2r_req1=0; G(r2b_ack1=1 -&gt; X(b2r_req1=0)); G((b2r_req1=1 * r2b_ack1=0) -&gt; X(b2r_req1=1)); G((b2r_req1=1 * X(b2r_req1=0)) -&gt; X(b2r_req1=0 U (b2r_req1=0 * b2r_req0=1))); G((b2r_req0=0) + (b2r_req1=0) ); G((s2b_req0=1 + s2b_req1=1) -&gt; X(F(b2r_req0=1 + b2r_req1=1))); group_order = (sb_0 br_1) (sb_1 br_0);</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">When a sender, say sender i, has data to send, it initiates a transfer by asserting s2b_req(i) (Server to Buffer Request)</title>
		<imprint/>
	</monogr>
	<note>One cycle later, the sender puts the data on its data bus</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">When GenBuf can service the sender, it reads the data from the data bus and asserts b2s_ack(i)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">In the cycle following the assertion of b2s_ack(i), the sender should deassert the signal s2b_req(i)</title>
		<imprint/>
	</monogr>
	<note>From this point onwards, the data on the data bus is considered invalid. References</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Realizable and unrealizable specifications of reactive systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wolper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 16th international colloquium on automata, languages, and programming (ICALP). Lecture notes in computer science</title>
		<meeting>16th international colloquium on automata, languages, and programming (ICALP). Lecture notes in computer science<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">372</biblScope>
			<biblScope unit="page" from="1" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Alternating refinement relations</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Kupferman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th international conference on concurrency theory (CONCUR). Lecture notes in computer science</title>
		<meeting>the 9th international conference on concurrency theory (CONCUR). Lecture notes in computer science<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="163" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Specify compile, run: hardware from psl</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bloem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Galler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Jobstmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Piterman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Weiglhofer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Electron Notes Theor Comput Sci</title>
		<imprint>
			<biblScope unit="volume">190</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="3" to="16" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Co-ing büchi made tight and useful</title>
		<author>
			<persName><forename type="first">U</forename><surname>Boker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Kupferman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th IEEE annual symposium on logic in computer science (LICS)</title>
		<meeting>the 24th IEEE annual symposium on logic in computer science (LICS)<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="245" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Efficient on-the-fly algorithms for the analysis of timed games</title>
		<author>
			<persName><forename type="first">F</forename><surname>Cassez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Fleury</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lime</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th international conference on concurrency theory (CONCUR). Lecture notes in computer science</title>
		<meeting>the 16th international conference on concurrency theory (CONCUR). Lecture notes in computer science<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3653</biblScope>
			<biblScope unit="page" from="66" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Antichains: a new algorithm for checking universality of finite automata</title>
		<author>
			<persName><forename type="first">M</forename><surname>De Wulf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Doyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Raskin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th international conference on computer aided verification (CAV). Lecture notes in computer science</title>
		<meeting>the 18th international conference on computer aided verification (CAV). Lecture notes in computer science<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4144</biblScope>
			<biblScope unit="page" from="17" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Improved algorithms for the automata-based approach to model-checking</title>
		<author>
			<persName><forename type="first">L</forename><surname>Doyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Raskin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th international conference on tools and algorithms for the construction and analysis of systems (TACAS). Lecture notes in computer science</title>
		<meeting>the 13th international conference on tools and algorithms for the construction and analysis of systems (TACAS). Lecture notes in computer science<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4424</biblScope>
			<biblScope unit="page" from="451" to="465" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Antichain algorithms for finite automata</title>
		<author>
			<persName><forename type="first">L</forename><surname>Doyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Raskin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th international conference on tools and algorithms for the construction and analysis of systems (TACAS). Lecture notes in computer science</title>
		<meeting>the 16th international conference on tools and algorithms for the construction and analysis of systems (TACAS). Lecture notes in computer science<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6015</biblScope>
			<biblScope unit="page" from="2" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Symbolic bounded synthesis</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ehlers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd international conference on computer aided verification (CAV)</title>
		<meeting>the 22nd international conference on computer aided verification (CAV)<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6174</biblScope>
			<biblScope unit="page" from="365" to="379" />
		</imprint>
	</monogr>
	<note>Lecture notes in computer science</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">An antichain algorithm for LTL realizability</title>
		<author>
			<persName><forename type="first">E</forename><surname>Filiot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jin</forename><forename type="middle">N</forename><surname>Raskin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st international conference on computer aided verification (CAV). Lecture notes in computer science</title>
		<meeting>the 21st international conference on computer aided verification (CAV). Lecture notes in computer science<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5643</biblScope>
			<biblScope unit="page" from="263" to="277" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Compositional algorithms for LTL synthesis</title>
		<author>
			<persName><forename type="first">E</forename><surname>Filiot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jin</forename><forename type="middle">N</forename><surname>Raskin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th international symposium on automated technology for verification and analysis (ATVA). Lecture notes in computer science</title>
		<meeting>the 8th international symposium on automated technology for verification and analysis (ATVA). Lecture notes in computer science<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6252</biblScope>
			<biblScope unit="page" from="122" to="127" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Automata, logics, and infinite games: a guide to current research</title>
		<author>
			<persName><forename type="first">E</forename><surname>Grädel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Wilke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture notes in computer science</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Open implication</title>
		<author>
			<persName><forename type="first">K</forename><surname>Greimel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bloem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Jobstmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 35th international colloqium on automata, languages and programming (ICALP). Lecture notes in computer science</title>
		<meeting>the 35th international colloqium on automata, languages and programming (ICALP). Lecture notes in computer science<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5126</biblScope>
			<biblScope unit="page" from="361" to="372" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Rulebase tutorial, available at www.haifa.ibm</title>
		<author>
			<persName><surname>Ibm</surname></persName>
		</author>
		<ptr target=".com/projects/verification/rb_homepage/tutorial3/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Optimizations for LTL synthesis</title>
		<author>
			<persName><forename type="first">B</forename><surname>Jobstmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bloem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th international conference on formal methods in computer aided design (FMCAD)</title>
		<meeting>the 6th international conference on formal methods in computer aided design (FMCAD)<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="117" to="124" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Compositional control synthesis for partially observable systems</title>
		<author>
			<persName><forename type="first">W</forename><surname>Kuijper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Van De Pol</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th international conference on concurrency theory (CONCUR). Lecture notes in computer science</title>
		<meeting>the 20th international conference on concurrency theory (CONCUR). Lecture notes in computer science<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5710</biblScope>
			<biblScope unit="page" from="431" to="447" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Safraless compositional synthesis</title>
		<author>
			<persName><forename type="first">O</forename><surname>Kupferman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Piterman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th international conference on computer aided verification (CAV)</title>
		<meeting>the 18th international conference on computer aided verification (CAV)<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4144</biblScope>
			<biblScope unit="page" from="31" to="44" />
		</imprint>
	</monogr>
	<note>Lecture notes in computer science</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">On bounded specifications</title>
		<author>
			<persName><forename type="first">O</forename><surname>Kupferman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th international conference on logic for programming, artificial intelligence, and reasoning (LPAR). Lecture notes in computer science</title>
		<meeting>the 8th international conference on logic for programming, artificial intelligence, and reasoning (LPAR). Lecture notes in computer science<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="24" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Safraless decision procedures</title>
		<author>
			<persName><forename type="first">O</forename><surname>Kupferman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE symposium on foundations of computer science (FOCS)</title>
		<meeting>the IEEE symposium on foundations of computer science (FOCS)<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="531" to="542" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Simple linear-time algorithms for minimal fixed points</title>
		<author>
			<persName><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Smolka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th international colloqium on automata, languages and programming (ICALP). Lecture notes in computer science</title>
		<meeting>the 25th international colloqium on automata, languages and programming (ICALP). Lecture notes in computer science<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="53" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Borel determinacy</title>
		<author>
			<persName><forename type="first">D</forename><surname>Martin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ann Math</title>
		<imprint>
			<biblScope unit="volume">102</biblScope>
			<biblScope unit="page" from="363" to="371" />
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">From nondeterministic büchi and streett automata to deterministic parity automata</title>
		<author>
			<persName><forename type="first">N</forename><surname>Piterman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Log Methods Comput Sci</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Synthesis of reactive(1) designs</title>
		<author>
			<persName><forename type="first">N</forename><surname>Piterman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">'</forename><surname>Sa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th international conference on verification, model checking, and abstract interpretation (VMCAI). Lecture notes in computer science</title>
		<meeting>the 7th international conference on verification, model checking, and abstract interpretation (VMCAI). Lecture notes in computer science<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">3855</biblScope>
			<biblScope unit="page" from="364" to="380" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">On the synthesis of a reactive module</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rosner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM symposium on principles of programming languages (POPL)</title>
		<meeting>the ACM symposium on principles of programming languages (POPL)<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="179" to="190" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Algorithms for omega-regular games with imperfect information</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Raskin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Chatterjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Doyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Log Methods Comput Sci</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Modular synthesis of reactive systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Rosner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
		<respStmt>
			<orgName>Weizmann Institute of Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD dissertation</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">On the complexity of ω automata</title>
		<author>
			<persName><forename type="first">S</forename><surname>Safra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE symposium on foundations of computer science (FOCS)</title>
		<meeting>the IEEE symposium on foundations of computer science (FOCS)<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="319" to="327" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Bounded synthesis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Schewe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Finkbeiner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th international symposium on automated technology for verification and analysis (ATVA)</title>
		<meeting>the 5th international symposium on automated technology for verification and analysis (ATVA)<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4762</biblScope>
			<biblScope unit="page" from="474" to="488" />
		</imprint>
	</monogr>
	<note>Lecture notes in computer science</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Safety first: a two-stage algorithm for LTL games</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sohail</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Somenzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th international conference on formal methods in computer aided design (FMCAD)</title>
		<meeting>the 9th international conference on formal methods in computer aided design (FMCAD)<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="77" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Efficient büchi automata from LTL formulae</title>
		<author>
			<persName><forename type="first">F</forename><surname>Somenzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bloem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th international conference on computer aided verification (CAV)</title>
		<title level="s">Lecture notes in computer science</title>
		<meeting>the 12th international conference on computer aided verification (CAV)<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="248" to="263" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Church&apos;s problem and a tour through automata theory</title>
		<author>
			<persName><forename type="first">W</forename><surname>Thomas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pillars of Computer Science. Lecture notes in computer science</title>
		<imprint>
			<biblScope unit="volume">4800</biblScope>
			<biblScope unit="page" from="635" to="655" />
			<date type="published" when="2008">2008</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
