<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">On the Scale and Performance of Cooperative Web Proxy Caching</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<title level="a" type="main">On the Scale and Performance of Cooperative Web Proxy Caching</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">44B3F8E2BDF70D1538CE1F4EAECB1237</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:55+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>While algorithms for cooperative proxy caching have been widely studied, little is understood about the performance of cooperative caching in the Web environment as it scales to large client populations. This paper uses both tracebased analysis and analytic modelling to show the potential advantages and drawbacks of inter-proxy cooperation. With our traces, we evaluate quantitatively the performance-improvement potential of cooperation between 200 small-organization proxies within a university environment, and between two large-organization proxies handling 20,000 and 60,000 clients, respectively. With our model, we go beyond those populations to project the implications for cooperative caching in regions with millions of clients. Overall, we demonstrate that cooperative caching has performance benefits only within limited population bounds. We also use our model to examine the implications of future trends in Web-access behavior and traffic.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Cooperative caching -the sharing and coordination of cache state among multiple communicating caches -has been shown to improve the performance of file and virtualmemory systems in a high-speed local-area network environment <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b15">16]</ref>. For example, when a file-page miss occurs, the local file cache may transfer the page from the file cache on another node. Cooperative caching works in this environment, because network transfer time is much smaller than the disk access time required to service a miss.</p><p>In the context of the Internet, proxy caches have become commonplace to improve the performance of client browsers. Typically, the proxy sits above an entire company or organization. By caching requests for a group of users, a proxy can quickly return documents previously accessed by other clients. Ultimately, though, the hit rate of the proxy is a function of the size of the population it manages -a size often dictated by political, organizational, or geographic considerations. An obvious question, then, is whether multiple proxies should cooperate with each other in order to increase total client population, improve hit ra-tios, and reduce document-access latency. Whether such cooperative proxy caching will work depends on the sharing patterns of documents across organizations and the ratio of inter-proxy communication time to server fetch time.</p><p>Several cooperative-caching protocols have been proposed <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b29">30]</ref>; however, few studies have examined cooperative Web caching from a systemic viewpoint. As a result, we know neither the environments in which cooperative caching pays (if any) nor its potential performance benefits. Answering such questions has been difficult in the past, because studying proxy cooperation requires simultaneous traces from multiple proxies.</p><p>In this paper, we take a two-pronged approach to exploring the limits and potentials of cooperative proxy caching. As the first approach, we collect and analyze traces from two environments: a large university environment and the Microsoft corporation. As a key component of our university trace, we identify each client in terms of its membership in one of about 200 university departments or programs. This gives us the equivalent of a simultaneous trace of 200 diverse, independent organizations, permitting us to analyze document sharing among those organizations, and to measure the potential benefits of cooperation among organization-based proxies. We examine latency and bandwidth benefits of proxy caching for this data as well. We then use the Microsoft trace of employee traffic to the Internet to explore the potentials of cooperation between larger organizations. To do this, we analyze traces from Microsoft and the university that we collected over the same time period and processed with the same anonymization function. This permits a direct computation of the degree of document sharing, and hence the benefit of sharing, between two proxies handling tens of thousands of clients each.</p><p>As the second approach, we develop an analytic model of Web behavior in order to extend beyond the limits of our trace results. The model permits us to examine the impact of larger populations sizes, to explore the tradeoffs between various cooperative-caching schemes, and to speculate on the performance implications of future trends.</p><p>Our results show the benefits of cooperative caching among collections of small organizations. However, we show that cooperative caching is unlikely to have significant benefits for larger organizations or populations. That is, with current sharing patterns, there is little point in designing scalable cooperative-caching schemes; all reasonable schemes will have similar performance in the low-end population range where cooperative caching works. Thus, the crucial problem that must be solved to improve Web performance is to increase document cacheability.</p><p>The paper is organized as follows. The following section describes previous work and its relationship to our study. Section 3 describes our traces, and presents and analyzes data from the traces. Section 4 develops an analytic model of Web behavior and presents results gained from that model. Section 5 summarizes and concludes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>Web tracing and caching are highly active research areas. Recent studies of Web traffic include analyses of Web access traces from the perspective of browsers <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b24">25]</ref>, proxies <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b16">17]</ref>, and servers <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b3">4]</ref>. The earlier tracing studies were rather limited in request rate, number of requests, and diversity of population. The most recent tracing studies have been larger and generally more diverse. In addition to static analysis, some studies have also used trace-driven cache simulation to characterize the locality and sharing properties of these very large traces <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b16">17]</ref>, and to study the effects of cookies, aborted connections, and persistent connections on the performance of proxy caching <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b16">17]</ref>.</p><p>Researchers have studied the temporal locality of Web proxy traces and examined how hit-ratio depends, asymptotically, on cache size and the number of requests. Several interesting findings have been observed. First, it has been well-documented that for most traces, the relative frequency with which Web pages are requested follows a Zipf-like distribution <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b30">31]</ref>. Second, for infinite-sized caches, it has been shown empirically and analytically that the hit ratio for a Web proxy grows logarithmically with the client population of the proxy and the number of requests seen by the proxy <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b13">14]</ref>.</p><p>There has also been extensive work on cooperative Web caching as a technique to reduce access latency and bandwidth consumption. Cooperative Web caching proposals include hierarchical schemes like Harvest and Squid <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b28">29]</ref>, hash-based schemes <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b21">22]</ref>, directorybased schemes <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b25">26]</ref> and multicast-based schemes <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b31">32]</ref>. Although each of these research efforts included a performance evaluation of the protocols proposed and a discussion of algorithm scalability, none of these evaluations presented either empirical or analytical evaluations of the effectiveness of their schemes for large scale client populations as found in a wide-area setting.</p><p>In this paper, we expand on these previous research efforts. We use trace-based analysis to quantify the potential advantages and drawbacks of inter-proxy cooperation for small and medium-sized organizations. We use analytic modelling to examine cooperative-caching performance in wider-area environments. Our model is inspired by the model of Breslau et al. <ref type="bibr" target="#b4">[5]</ref>. We have augmented their assumptions with a model of document rate of change, client request rate, and a small number of other parameters that allow us to study the steady-state behavior of cooperativecaching schemes as a function of the characteristics of the population they serve.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Web Document Sharing and Proxy Caching</head><p>This section poses and answers a number of questions about the potentials of cooperative proxy caching. Before considering specific caching algorithms, we wish to explore the bounds of cooperative-caching performance. For example, key questions include:</p><p>1. What is the best performance one could achieve with "perfect" cooperative caching?</p><p>2. For what range of client populations can cooperative caching work effectively?</p><p>3. Does the way in which clients are assigned to caches matter?</p><p>4. What cache hit rates are necessary to achieve worthwhile decreases in document access latency?</p><p>To answer these questions quantitatively, we have collected and analyzed Web access data from two environments: (1) a large university, consisting of about 50,000 students, faculty, and staff, and (2) the Microsoft Corporation, consisting of about 40,000 employees. Most significant, the two traces were collected simultaneously and anonymized in the same way, allowing direct comparison of trace records, including URLs and server addresses. We use the university trace as a way to analyze document sharing by 200 small independent organizations within a diverse university; we use the university and Microsoft traces together as a way to analyze document sharing across two large organizations. In both environments, we examine the potential benefits of proxy cache coordination. This section presents results derived from this trace data; in Section 4, we will present an analytical model to extend beyond the limits of the trace to much larger populations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Trace Collection and Characteristics</head><p>While several well-known traces exist in the public domain <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b12">13]</ref>, they are often several years old and the information they contain is inadequate for our analysis. We therefore designed and implemented our own trace software and installed it on a computer connected to the outgoing switches though which all of our university's Internet traffic flows. The traces are anonymized, but the anonymization preserves certain key aspects of the data that we require. In particular, we anonymize client IP addresses, but first classify the client based on its "organizational" membership. This allows us to identify requests from different academic and administrative entities within the university (e.g., we classify each department as being a unique organization). We describe the use of this information later in this section.</p><p>We have been collecting University traces since October 1998; the trace used for this section was collected from May 7th through May 14th 1999, and therefore shows very recent access characteristics. Table <ref type="table" target="#tab_0">1</ref> gives the high-level details of this trace. As the table shows, we saw on the order of 83 million requests by 23,000 clients to 244,000 servers over the 7-day trace period. Using this data, we can determine upper bounds on the performance of any cooperative caching algorithm, which tells us whether proxy cooperation is worthwhile even in the best case in our environment.</p><p>We also processed traces collected by the proxies handling all outgoing traffic from Microsoft Corporation. These traces were collected on the same days that we collected our university trace. Our software anonymizes both traces using the same functions, so that URLs and server IP addresses in the two traces can be directly compared. Table <ref type="table" target="#tab_0">1</ref> shows that in the same period, we saw on the order of 100 million requests by 57,000 clients to 316,000 servers in the Microsoft trace.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The Impact of Population Size</head><p>In a cooperative-caching scheme, a proxy forwards a missing request to other proxies, hoping that (1) another proxy holds the requested document, and (2) that document can be returned faster than a request to the server. Whether such cooperation is worthwhile will depend on the number of proxies involved, their distances (inter-proxy communication latencies), their utilizations, the client popula- tions served, and the complexity of the protocols used.</p><p>In the end, the result of cooperative proxy caching is simply to increase the effective client population. That is, at best, a collection of cooperating caches will achieve the hit rate of a single proxy acting over the combined population of all of the proxies. In reality, the performance will be less than perfect, because proxies will not have perfect knowledge and will pay the overheads of interproxy communication latency. Examining a single toplevel proxy therefore gives us an upper bound on achievable cooperative-caching performance.</p><p>Figure <ref type="figure" target="#fig_0">1</ref> graphs hit rate vs. client population size for our traces. These results are consistent with previous studies <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b13">14]</ref>. The two lower lines on the graph show the behavior of the university population. The bottom line shows the "cacheable hit rate", which we define as the hit rate that a proxy would see if it had infinite storage and documents did not expire, while still taking into account the cacheability characteristics of the documents. Our decision about whether or not a document is cacheable is based on the Squid V2 implementation <ref type="bibr" target="#b28">[29]</ref>. The middle line in Figure <ref type="figure" target="#fig_0">1</ref> shows the "ideal hit rate" that would be achievable if all shared documents were cacheable. In the future, improvements to Web protocols may move the cacheable line closer to the ideal line. On the other hand, future changes in document characteristics may move the cacheable line in either direction. We explore these impacts in Section 4.</p><p>The top line in Figure <ref type="figure" target="#fig_0">1</ref> shows the ideal hit rate curve for the Microsoft trace. <ref type="foot" target="#foot_0">1</ref> It is interesting to note that the curve asymptote is about 15% higher than that of the University environment, an indication that document sharing within Microsoft is much higher than within the university. This indicates, not surprisingly, that the Microsoft population is much more homogeneous in its Web-access behavior than the university population.</p><p>From this simple figure, we can draw several key conclusions about cooperative caching. The graphs have a sharp knee at about 2500 clients. The steep increase in hit rate below that knee implies that a large potential benefit (hit rate increase) could exist from cooperative caching for multiple proxies with small client populations. For example, given 10 proxies, each handling a population of a few hundred clients, cooperative caching has the potential to significantly improve the hit ratio seen by the clients of those proxies. The improvement occurs by increasing the total population of each proxy from 200 to 2000 clients.</p><p>It is important to note that the total number of clients (below the knee) that can benefit from cooperative caching could easily be handled by a single proxy cache. Often this will not be possible, however, because decisions of proxy placement are based on political or geographical factors, such as company organization, location, and so on. While one organization may not trust another to proxy all of its requests, it may be willing to cooperate with other proxies for performance reasons.</p><p>Figure <ref type="figure" target="#fig_0">1</ref> also shows that hit rate increases only very slowly with client population once past the knee of the curve. It is therefore not clear whether cooperation caching will pay in this region, for proxies whose populations are already above a few thousand clients. We will explore this question in more detail below and in Section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Hit Rate vs. Latency and Bandwidth</head><p>While many caching studies focus on hit rate, in the Web environment it is ultimately latency, and not hit rate, that is crucial to clients. From the perspective of Internet service providers, hit rate translates into bandwidth savings over costly Internet links. These bandwidth savings can also reduce wide-area network congestion, potentially improving the performance of the Internet as a whole.</p><p>Figure <ref type="figure">2</ref> shows document latency in our university trace as a function of the number of clients using a proxy cache. The top three lines, from top to bottom, show mean lastbyte latency (1) as extracted from the trace (i.e., with no proxy), (2) with a proxy cache respecting cacheability, and (3) with an ideal proxy cache. The bottom three lines show median last-byte latency under the same three conditions. The three mean lines level out quickly, while the medians are essentially flat. This implies that caching will have little impact on mean and median latency beyond very small client populations.</p><p>In Figure <ref type="figure">2</ref>, the mean latency is much higher than the median due to many high-latency documents. Perhaps cooperative caching can reduce the percentage of these high latency documents. Figure <ref type="figure">3</ref> implies that this is not the case; it shows the percentage of documents with a lastbyte latency below 2 seconds for the three caching situations described above. The flatness and closeness of these lines demonstrates that neither cacheability nor increasing population will significantly reduce the number of highlatency documents. Our trace analysis indicates that these documents are slow due to network latency (e.g., from congestion, low-bandwidth links, long distances), document size, or both. As described below, shared documents tend to be smaller than non-shared documents, biasing misses towards larger documents that consequently take longer to download. Correlation studies indicate that round-trip time is not strongly correlated with sharing, and so requests that are misses are about equally likely to traverse slow networks as hits.</p><p>A final dimension is bandwidth. Figure <ref type="figure">4</ref> shows the byte hit rate as a function of client population for the university trace. Once again, we see a knee in the curve at around 2500 clients. Comparing these results to the hit rates given in Figure <ref type="figure" target="#fig_0">1</ref>, we can conclude that shared objects are smaller on average than other objects. Figure <ref type="figure">5</ref> shows the average bandwidth consumed as a function of client population for the three caching situations. We see that while caching reduces bandwidth consumption compared to no caching, there is no benefit to increased client population (i.e., there is no decrease in the slope of the bandwidth line).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Proxies and organizations</head><p>We produced Figures <ref type="figure" target="#fig_0">1</ref> and<ref type="figure">4</ref> by computing the hit rate of random subsets of clients at each population size; therefore, the figures assume that all clients are essentially iden- To answer this question is difficult, because it requires a simultaneous trace of a large number of proxies in the Internet. Such traces have not existed in the past. We have tried to answer the question in our university environment, using the university as a small-scale model of the broader networked community. The university consists of a large collection of diverse organizations, e.g., museums of art and natural history, schools of nursing and dentistry, and departments such as music, Scandinavian languages, and computer science. Think of each such organization as an independent business entity, with its own interests and focus, which would typically have its own proxy sitting on its connection to the Internet.</p><p>In fact, somewhat fortuitously, few organizations on our campus currently employ proxies; this permits us to see all outgoing client requests and their responses. In our tracing software, before anonymizing each client's IP address, we first classify that client as belonging to one of about 200 independent university organizations. In this way, we preserve organizational membership information, while protecting client identities. In effect, this gives us a simultaneous trace of Web requests from 200 organizations.</p><p>Figure <ref type="figure">6</ref> shows the ideal (left-hand bar) and cacheable (right-hand bar) hit rates for the 15 largest university organizations. The bars are labelled on the x-axis with the number of clients seen in the trace for each of the organi- The lower portion of each bar shows the hit rate that would be seen by a local proxy acting on behalf of that organization. The upper portion of the bar shows the improvement in hit rate that would be seen by that organization, if all of the university's organizations used perfectly cooperating proxies. For the ideal bars, the average hit rate per group is 52%. The average cooperative-caching hit rate, i.e., the rate that would be seen by a single proxy over all organizations or by a perfect cooperative-caching scheme, is 69%. For the cacheable hit rate bars, the average hit rate per group is 29%, and the cooperative hit rate is 38%. Therefore, if perfect cooperative caching were possible, it would achieve a significant improvement in hit rate for these proxies. Not surprisingly, the improvement is largest for smaller groups; these benefit most from the larger population created by cooperative caching.</p><p>An interesting question raised above is whether clients in our university population request documents randomly, or whether their access patterns are related in some way to those of other members of the same organization. To answer this question, we grouped clients from the university at random into organizations with the same sizes as the 200 real organizations, and compared local hit rates. Figure <ref type="figure" target="#fig_3">7</ref> shows a comparison of the hit rates for the 15 largest university and randomly assigned organizations. The result indicates that there is a small (about 4%) increase in hit rates, on average, for the real organizations, compared to the randomly-assigned organizations. Therefore, there is some locality in organizational membership, but the impact is not significant in this case.</p><p>A related question is whether a better grouping exists of clients to proxies, for example, based on each client's doc- ument interest profile. To examine this question, we conducted a clustering study. Using the trace data, we clustered clients based on their document access vectors, using a standard clustering algorithm (KMeans <ref type="bibr" target="#b17">[18]</ref>). This algorithm attempts to optimize intra-cluster sharing. The existence of such groupings within the university might imply the existence of an improved wide-area caching scheme based on clustering.</p><p>As with the university organizations, we compared the cluster-based client assignments to random assignments of clients into groups of the same size. Figure <ref type="figure" target="#fig_4">8</ref> compares the average hit rates across all clusters to the hit rates when the clusters are randomly populated. The graph shows curves for both the ideal and cacheable proxy simulations. As expected, the randomly-assigned clusters have a consistently lower hit rate than the optimally-clustered organizations. Somewhat surprisingly, however, the difference between the two assignments is just slightly more than the difference between the university and random organizations (about 5%). Again, there is some affinity in client access patterns, but the impact on hit rate is not significant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Impact of larger population size</head><p>We have seen that cooperative caching can increase hit rate, perhaps substantially, below the knee of the curve in Figure <ref type="figure" target="#fig_0">1</ref>. What happens above the knee, i.e., can cooperative caching be applied in a wide-area network? Figure <ref type="figure" target="#fig_5">9</ref> shows the university data from Figure <ref type="figure" target="#fig_0">1</ref>, plotted on a log scale for client population, and extrapolated linearly past the twenty thousand clients we measured.</p><p>This graph suggests a number of interesting conclusions. First, we notice that the slopes of the lines are simi- lar. This indicates that there is little correlation between sharing and the cacheability of documents. Second, the cacheability curve is limited by the fraction of requests to cacheable documents, which is 60% in our trace. In this case, cooperative caching among populations larger than 2.2 million do not increase the hit rate to cacheable documents. Third, even if all documents were cacheable, the ideal hit rate reaches a maximum at a population of 15 million users.</p><p>In Section 4 we will present an analytical model to look in more detail at the behavior of cooperative caching in large-scale environments. Within the context of our own traces, though, we can perform an interesting experiment to create a larger population. Suppose that we implemented cooperative caching between the university and the Microsoft proxies. From the point of view of the university proxy, this quadruples the size of the population it sees; from the point of view of the Microsoft proxy, this increases its population by 40%. What would be the impact of combining the two populations through cooperative caching?</p><p>As noted earlier, the Microsoft client population is more homogeneous than the university population, and therefore sees a higher degree of document sharing. Quantitatively, in the Microsoft trace, 83.8% of requests are to previously-requested documents; in the university trace, 62.6% of requests are to previously-requested documents. These statistics are the "ideal hit rates" that would be seen by a cache, if all documents were cacheable. But how much overlap is there to popular documents between the two populations? We looked at the most popular documents requested by each of the two populations, where we defined "most popular" to be those documents accessed more than 500 times. In the university trace, there were 7500 such documents, and in the Microsoft trace, there were 12,000 such documents. Looking at the 1000 most popular in each of the two populations, we see a 32% overlap; that is, of the 1000 most-popular documents accessed by Microsoft, 320 of them are also among the 1000 most popular accessed by the university. Therefore, many of the same documents are popular in both organizations.</p><p>To estimate the benefit of cooperative caching between the two organizations, we did the following analysis. We ran the university trace through a simulated university proxy; we then fed all misses to a second-level (cooperating) proxy preloaded with all of the objects seen in the Microsoft trace. Similarly, we ran the Microsoft trace simulating its proxy, with a second-level proxy preloaded with all objects seen by the University race. This gives us an idea of the maximum incremental hit-rate benefit each proxy would see if the two proxies would cooperate. Figure <ref type="figure" target="#fig_6">10</ref> shows the results of this measurement. From the figure, we see that the university proxy, whose effective population would increase 3.5-fold (from 23K to 80K clients), would see its ideal hit rate increase only 3.7%from 62.6% to 66.3%; its cacheable hit rate would increase only 2.9% -from 34.2% to 37.1%. The Microsoft proxy would see its ideal hit rate increase 3.3% -from 83.8% to 87.1%. These results are disappointing, but not surprising in retrospect. The reason for these very small increases is that the unpopular documents are universally unpopular; therefore, it is unlikely that a miss in one of these large populations will find the document in the other population's proxy. For the most-popular documents, cooperation does not help either, because only the first access (e.g., of the 500+ accesses to a popular document) has the potential to benefit from another population's proxy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Summary</head><p>In this section, we analyzed traces from two environments to explore the bounds of cooperative-caching performance. From this data, we saw that:</p><p>1. The behavior of cooperative caching is characterized by two different regions of the hit rate vs. population curve. For smaller populations, hit rate increases rapidly with population; it is in this region where cooperative caching can be used effectively. However, these population sizes can be handled by a single proxy. Therefore cooperative caching is only necessary to adapt to proxy assignments made for political or geographical reasons.</p><p>2. For larger populations (beyond the knee of the population vs. hit rate curve), cooperative caching is unlikely to provide significant benefit. We demonstrate this using our simultaneous traces of the Microsoft and university populations: a 4-fold increase to a large university population via cooperative caching netted only a 2.7% increase in cacheable hit rate.</p><p>3. Although there exist organizations with significant sharing rates and locality, such as the Microsoft population, our clustering study shows that cooperative caching specialized to interest groups is unlikely to be effective.</p><p>4. While some of these general trends have been observed before, the inevitable conclusion for cooperative caching has not been explicitly noted.</p><p>Despite these negative conclusions, it is still possible that cooperative caching will perform better, either in steady state or for different (possibly future) Web characteristics. In the domain where cooperative caching is effective, we also wish to understand which of the proposed cooperative-caching algorithms will be most effective. We explore these questions in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">An Analytic Model of Web Access</head><p>In Section 3 we considered the performance potential of cooperative caching using our trace data. In this Section, we extend these results analytically to better understand the steady-state performance of cooperative caching for large client populations, to examine the tradeoffs between various cooperative caching schemes, and to speculate on caching performance in the face of future trends.</p><p>Our basic approach is inspired by the model presented by Breslau et al. <ref type="bibr" target="#b4">[5]</ref>. We make the following assumptions about clients and documents.</p><p>There are N clients in the population. Clients are indistinguishable and act independently of one another.</p><p>The total number of documents is n. For simplicity, we model documents as indivisible, rather than compound, and assume that accesses to objects are independent.</p><p>The fraction of all requests that are for the i-th most popular document, or the "popularity" of this document, is denoted by p i . We will generally assume that documents follows a Zipf-like distribution <ref type="bibr" target="#b4">[5]</ref>,</p><p>i.e. that p i is proportional to 1=i , for some constant .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The distribution of time between requests made by the client population is exponential with parameter</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>N.</head><p>The distribution of time between changes to a document is exponential with parameter , and independent of document popularity, size and latency. Document change can be used to model either expiration or actual change.</p><p>The probability that a document requested is cacheable is p c . The average document size is E(S). Document size is independent of document popularity, latency, and rate of change.</p><p>For each document, the last-byte latency to the server that is home to that document has cumulative distribution function L(x), and average value E(L). Lastbyte latency is independent of document popularity, and document rate of change.</p><p>With these assumptions, we can compute a number of performance characteristics.</p><p>Assuming steady state, it is easily shown that for a single proxy cache serving a population of size N:</p><p>The steady state hit rate is</p><formula xml:id="formula_0">H N = p c C N ;</formula><p>where C N is the probability that a request is a hit given that it's cacheable. The steady-state cacheable hit rate to cacheable documents C N is</p><formula xml:id="formula_1">C N = X 1 i n p i Np i Np i + :</formula><p>Taking p i proportional to 1=i , a very close approximation to this sum is given by Z n x dx;</p><p>The first integral can be evaluated exactly for = 1 and numerically for other values of .</p><p>The probability that the last-byte latency to serve a request exceeds t time units, which we denote lat N (t), is given by lat N (t) = (1 ? H N )(1 ? L(t)):</p><p>This assumes zero latency for cache hits.</p><p>The average bandwidth savings per request due to proxy caching, measured in KBytes not transferred, is denoted B N , and is given by B N = H N E(S):</p><p>The expected amount of storage required in a proxy cache for a population of this size is nH N E(S). This is actually optimistic, as it assumes that only objects that are cacheable and have not expired or changed are cached.</p><p>The key difference between our model and that presented by Breslau et al. is that we consider steady-state behavior of caching systems as a function of population size in the presence of a document-change and client-requestrate model. Our goal in building the model is also rather different from the goals pursued by Breslau et al. Ultimately, we are using the model to understand the performance of large-scale cooperative-caching schemes in terms of hit rate, latency, bandwidth savings, and storage consumed.</p><p>We should note that although a number of the assumptions made here are unlikely to reflect reality, qualitatively the results of this model appear correct or even optimistic with respect to the performance of cooperative caching. We justify the independence assumptions we make by the fact that all the correlation coefficients (between each pair of document size, document popularity, first-byte latency, and document cacheability) computed from our trace are close to 0. However, we have also found that shared objects are more likely to be small and cacheable objects are more likely to have low latencies; both of these findings bode poorly for cooperative caching. Another unrealistic assumption is that the document rate of change is exponentially distributed. Our data shows that the median age of documents accessed is 71 days, but the median time between document changes for those documents that changed is 2 minutes. These numbers indicate that the document rate of change is a heavy-tailed distribution. We have not yet had the opportunity to correlate document rate of change with popularity, which could also significantly affect the results. We will present a more complete analysis of these issues in the final paper.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Performance of Large Scale Proxy Caching as predicted by this model</head><p>We begin by examining the predictions of the model using parameters extracted from our trace data. A key question to address is: given the client request rate, document rate of change, and document popularity distributions, how large a client population is needed to achieve a cache hit rate approaching p c , the fraction of cacheable documents in the Web. The model implies that if the Web were static (i.e., documents were not changing and new documents were not being generated), then any size population would eventually request all documents. For a Zipf popularity distribution with = 1, this would take O(n log 2 n) requests.</p><p>After this many requests, with sufficient storage for all these documents, all cacheable requests would thereafter become hits, and the cache hit rate would be p c .</p><p>It is important to observe that the storage needed to cache all cacheable objects in the Web is not intractable. Studies suggest that users access about 350 million Web documents. From our traces, we know that there are on average about four objects per document and that 50% of the objects accessed are uncacheable. Based on this, we can estimate that there are about 700 million cacheable objects in the Web. The average object from our trace has size 8KB, so we need 5.6 Terabytes of disk storage to cache everything. Given that single large-capacity modern disks have a 50GB capacity, this means that we need on the order of one hundred disks.</p><p>Unfortunately, the Web is not static, and therefore in order for a population of a given size to achieve a cache hit rate approaching p c , it must generate a cumulative request rate that substantially dominates both the growth rate and the object rate of change of Web objects.</p><p>Figure11 shows the steady-state hit rate for cacheable documents C N as a function of N, the population size, for four different values of document rate of change . We assume, as computed from our university trace, that the per-client request rate is 590 requests per day and that the popularity distribution is Zipf-like with parameter = 1:2. Our value is higher than the value observed in other traces, e.g., <ref type="bibr" target="#b4">[5]</ref> observed a value of = 0:8; therefore, in Figure <ref type="figure" target="#fig_10">12</ref> we show the same results for = 0:8. The figures show document change rates of one change every 10 days, one change per day, one change per hour, and one change every two minutes. As in Section 3, we see that all of these curves increase rapidly for small client populations and slowly for larger populations. Only for low document rate-of-change values does a small population generate a sufficient cumulative request rate to dominate object rate of change, and converge quickly to nearly perfect hit rate for cacheable documents. For larger values of , the requests are much more highly concentrated on a smaller subset of the documents, so that much smaller populations are needed to get close to the best possible hit rate.</p><p>Note that all of these curves must asymptote at 100%. However for high rates of change, particularly coupled with low values, enormous populations are required.</p><p>For example, for = 0:8, a hit rate of :95p c is achieved at population sizes of 3M and 90M, for document change rates of every one hour and every 2 minutes, respectively. For = 1:2, a hit rate of :95p c is achieved at population sizes of 840K and 25M for the same change rates.</p><p>How does hit rate translate into actual performance improvement? Hit rate determines the improvement in object access latency and the reduction in network bandwidth consumed by transmitting Web objects. These effects are shown in Figures <ref type="figure" target="#fig_0">13</ref> and<ref type="figure" target="#fig_0">14</ref>. Figure <ref type="figure" target="#fig_0">13</ref>    must grow linearly with to achieve a fixed hit rate. However, the ratio between the population size (or request rate) and document change rate, i.e., the slope of this line, increases rapidly the closer we wish to get to a hit rate of p c . For example, the slope of the line showing the population needed to achieve a hit rate of 0:95p c is 320,000! Similarly, the population needed to achieve a given hit rate varies inversely with the client request rate . When is very low, even large populations cannot dominate the object rate of change and therefore cannot keep the cache filled with up-to-date objects. On the other hand, when is extremely large, even small populations can maintain a filled, up-to-date cache.</p><p>Finally, we consider the effect of increasing n, the number of documents in the web. The property of Zipf-like distributions is that a large of the probability mass is concentrated on a relatively small fraction of the documents, and this remains true even as the number of documents increases. So, for example, the populations needed to achieve hit rates of 0:5p c , 0:75p c and 0:95p c increase by only 3%, 5% and 18% respectively as n is doubled (from the starting point of 1.3 billion documents). The populations needed to achieve hit rates of 0:5p c , 0:75p c and 0:95p c increase by 7%, 20% and 170% respectively when n is increased by a factor of 100.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Comparison of Cooperative Caching Schemes</head><p>The previous section explored the performance of large Web proxy caching systems, but ignored the question of how these systems are designed and organized. Proxy caching starts at the level of individual organizations, small and large. To achieve the performance of caching systems with large populations, some form of cooperative caching among these organizational proxies will have to be used. In this section, we extend the calculations from the model to understand the differences in performance between various cooperative-caching systems as a function of scale. We compare three basic schemes: a hierarchical caching system inspired by Squid <ref type="bibr" target="#b28">[29]</ref>, a flat hash-based caching system inspired by <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b21">22]</ref>, and a directory-based scheme inspired by Summary Cache <ref type="bibr" target="#b14">[15]</ref>. We evaluate these schemes at the scale of a City, a State, and a large region (the West Coast of the U.S.). Our results will show why there is little motivation to scale to a region larger than a medium-sized city.</p><p>The hierarchical caching system assumes a hierarchy of k levels of caches, with a fanout of d at each level, where the bottom-level caches serve as proxy caches for populations of size N k . A client's request is forwarded up the hierarchy until a cache hit occurs, or, if none occurs, the request is forwarded to the server. A copy of the requested object is then stored in all caches along the request path.</p><p>In what follows, we will assume that the top-level cache serves an overall population of size N 1 = N, each secondlevel cache serves a disjoint subpopulation of size N 2 , and on down to a set of k-th-level caches, each serving subpopulations of size N k . (Plainly, N i = N=d i?1 .) For simplicity, we assume fixed latencies between the caches in the hierarchy, where L i is the latency between level i + 1 and level i caches.</p><p>The hash-based caching system assumes a total of m caches cumulatively serving a population of size N. (We will assume m = d k from the hierarchical scheme.) We assume a fixed average latency of L c to transmit data from a random cache to a client in the population, and a hash function that maps URLs to one of the m caches uniformly at random. On a request by a client, the client hashes the URL and forwards the request to the corresponding cache C. If the cache stores the document, it is forwarded to the client. Otherwise, the request is forwarded to the server and a copy is returned to the client and to the cache C.</p><p>The advantages of such a scheme are that load is balanced across the proxy caches and only one copy of each document is stored in the entire cooperative caching system. Such schemes have been proposed primarily for use in a local-area setting, since for large populations, L c may be fairly large.</p><p>Finally, in the directory-based system, we assume a total of m caches cumulatively serving a population of size N.</p><p>In this system, the population is partitioned into subpopulations of size N=m, and each subpopulation is served by a single proxy cache. Each proxy cache maintains a directory that summarizes the set of documents stored at each of the other proxy caches in the system. When a client issues a request for a document, it is forwarded to its proxy cache.</p><p>If the proxy cache has the object it is transmitted directly to the client. Otherwise, the proxy cache checks its directory to see if another proxy cache in the system stores a copy of the document. If so, the request is sent to a random cache storing a copy, which then returns a copy of the document to the proxy cache and to the requesting client. We assume a latency of L l to transmit data from a proxy cache to a client it serves, and a latency of L c between proxy caches in the system.</p><p>To maintain the directories, each proxy cache periodically (every t time units) sends out an update about the contents of its cache. In particular, it multicasts the set of changes to document set since the last request. We ignore the overhead of these messages in our subsequent analysis. Table <ref type="table" target="#tab_2">2</ref> summarizes the performance of the three schemes, based on the model. (E(L) is the average latency to a server and E(S) is the average document size.)</p><p>We compare the performance of these schemes at a few different scales:</p><p>A cooperative caching scheme for a medium-sized City (population of N=0.5 million).</p><p>A cooperative caching scheme for a small State (population of N=5 million).</p><p>A cooperative caching scheme for the West Coast (population of N=50 million).</p><p>We assume that there are 50,000 clients behind each lowest-level proxy cache to reflect the fact that, from our trace, clients issue about 600 requests per day, and a fast proxy cache (e.g., <ref type="bibr" target="#b11">[12]</ref>) can handle 500 requests per second. Based on the populations given, this implies a total of m = 10 organizational proxy caches for the City, m = 100 organizational proxy caches for the State and m = 1000 organizational proxy caches for the West Coast. For the hierarchical scheme, we assume that d = 10, giving us a 2-level hierarchy for the City (a single top-level proxy cache on top of the 10 organizational caches), a 3level hierarchy for the State, and a 4-level hierarchy for the West Coast.</p><p>We assume that the average last-byte latency to transfer a document from an organizational proxy cache to a client is 10ms, between two random caches in the city is 50 ms, between two random caches in the state is 100ms and between two random caches on the West Coast is 500ms. These numbers represent a high-bandwidth environment, in which the average document size is 8KB. We estimate that 5 round trips between the sender and the receiver of the document are required to complete the transfer (due to TCP/IP protocol overhead).</p><p>Tables <ref type="table" target="#tab_4">3,</ref><ref type="table" target="#tab_5">4</ref> and 5 present the model results for the three cooperative-caching schemes assuming the basic trace parameters ( = 590 requests per day per client, = 1:2, = 1 change every 2 minutes, n = 1:4 billion objects, E(L) = 2sec and E(S) = 7:7KB.)</p><p>From these tables we draw a number of conclusions. First, we see that the bulk of the achievable benefit, in terms of latency savings, is already achieved at the scale of City-level cooperative caching. Indeed, the minimum possible average latency we could hope for is (1 ? p c )E(L), which for our parameters is 0.8 seconds. All three schemes already achieve a value close to this in the City. Second, broadening the region to increase population also increases inter-proxy latencies; as a result, a flat cooperative-caching scheme is no longer effective. For the West Coast, the average latency between proxy caches is sufficiently large that the performance of the flat hashbased and directory-based schemes is worse, in terms of document latency, than their performance at the level of the State, despite the 10x increase in population. Obviously, this problem could be solved by designing hierarchical variants of these two schemes.</p><p>In terms of request rate, we see that for all the schemes, the lowest-level proxy caches have similar request rates (though the directory scheme has a slightly higher value)dominated by the requests from clients served directly by that proxy. However, even at the scale of City-wide cooperative caching, the top-level cache in the hierarchical scheme is a bottleneck. Since request rate will be directly   correlated with queueing, the average latency that will be observed in the hierarchical scheme will be significantly higher than shown here, particularly as we scale up to the State or Coast level. Therefore, if scaling up to these levels is desirable (which is itself a questionable proposition at best), the load at the higher levels of the hierarchy must be distributed across multiple proxy caches. There are a number of fairly obvious and natural ways to do this. Finally, with respect to storage, we see that the hashbased scheme is the clear winner, since each document is only stored in one of the proxy caches and the load is balanced across the caches. We can conclude that if proxy caches are truly willing to cooperate, and the latencies between caches are not significant, proxy caches can cooperate to store the cacheable contents of the Web, thus amortizing storage costs efficiently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Summary</head><p>In this section, we developed an analytic model and used it to examine the steady-state performance of cooperativecaching schemes. Our model extends the results from our trace for a wider range of parameter values, including for example, document popularity and document rate of change. We show again that relatively small populations achieve most of the performance benefits of cooperative caching.</p><p>We also evaluate three alternative approaches to cooperative caching, and show that all three schemes perform well in the region where cooperative caching is advantageous (e.g., at the level of a medium-sized city). However, a hash-based scheme will achieve the best storage efficiency. In a broader area (e.g., the size of the West Coast), the increased latency of inter-proxy communica-tion overshadows the (very limited) benefits of increased population.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusions</head><p>This paper studied cooperative proxy caching in local-and wide-area environments. We use a combination of tracebased analysis and analytic modelling to evaluate cooperative caching, and proxy caching in general, at a wide range of population sizes, document characteristics, and access patterns. At a high level, our results show that:</p><p>1. In the absence of significant changes in client behavior, there is little point in continuing to expend effort on the design and evaluation of highly-scalable cooperative-caching schemes. The scale at which cooperative caching makes sense, e.g., up to the level of a medium-sized city, is sufficiently small that most reasonable schemes will achieve most of the benefit.</p><p>2. The largest benefit for cooperative caching is achieved for relatively small populations. This is demonstrated by our analysis of cooperation among small organizations within the university environment. Our simultaneous traces of the university and Microsoft confirmed the negligeable benefit of cooperative caching between organizations whose populations are already in the range of 20K clients. Scaling beyond such populations provides only marginal improvement, and therefore makes sense only in very high-bandwidth low-latency environments.</p><p>3. Performance at the population level at which cooperative caching works effectively is basically lim-</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Proxy cache request hit rate as a function of client population.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :Figure 3 :</head><label>23</label><figDesc>Figure 2: Mean request latency as a function of client population.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :Figure 5 :</head><label>45</label><figDesc>Figure 4: Proxy cache byte hit rate as a function of client population.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Comparison of the proxy hit rates for the 15 largest university and randomly-populated organizations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: The average local hit rate as a function of the number of clusters generated.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Proxy cache hit rate as a function of client population (log scale).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Hit rate benefit of cooperative-caching between university and Microsoft proxies.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Cacheable request hit rate as a function of client population ( = 1:2).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: Cacheable request hit rate as a function of client population ( = 0:8).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 13 :Figure 14 : 4 . 1 . 1</head><label>1314411</label><figDesc>Figure 13: Mean request latency as a function of client population.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 15</head><label>15</label><figDesc>Figure 15  shows the population needed to achieve a hit rate of 0:5p c and 0:75p c as a function of the document rate of change . It follows directly from the formula for C N that the population (or equivalently client request rate)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 15 :</head><label>15</label><figDesc>Figure 15: Population needed to obtain various cacheable hit rates as a function of document rate of change ( ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Overall trace statistics.</figDesc><table><row><cell>Parameter</cell><cell>University</cell><cell>Microsoft</cell></row><row><cell>HTTP Requests</cell><cell cols="2">82.7 million 100.6 million</cell></row><row><cell>HTTP Objects</cell><cell cols="2">18.4 million 12.6 million</cell></row><row><cell>Total Request Bytes</cell><cell>678 GB</cell><cell>(N/A)</cell></row><row><cell cols="2">Average Requests/Sec 137</cell><cell>222</cell></row><row><cell>Clients</cell><cell>22,984</cell><cell>56,987</cell></row><row><cell>Servers</cell><cell>244,211</cell><cell>316,041</cell></row><row><cell>Duration</cell><cell>7 days</cell><cell>5 days 6 hours</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>Cooperative-caching performance parameters.</figDesc><table><row><cell>Request Arrival Rate Average Request Latency Total</cell><cell>Hierarchical Ni(1 ? H N i+1 ) to level i (HN k+1 = 0) (1 ? HN 1 )E(L) 1 i k Li(HN i ? HN i+1 ) + P P 1 i k nd i?1 HN i E(S):</cell><cell>Hash-based N=m (1 ? HN)E(L) + HNLc: nHNE(S)</cell><cell>Directory-based N=m m (1 ? HN m )H N(1? 1 + N m ) (2nd term -requests from other proxies) (1 ? HN)E(L) +(1 ? HN m )H N(1? 1 m ) 2Lc +HN L l nmH N=m E(S)</cell></row><row><cell>Storage</cell><cell></cell><cell></cell><cell>(lower bound)</cell></row><row><cell>Consumed</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3 :</head><label>3</label><figDesc>Cooperative caching performance for the City.</figDesc><table><row><cell>Request Arrival</cell><cell cols="3">Hierarchical r1 = 1.37B/day 29.5M/day Hash-based Directory-based 37.7M/day r2 = 147M/day r3 = 29.5M/day</cell></row><row><cell>Rate</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Mean Request</cell><cell>0.892 secs</cell><cell>0.939 secs</cell><cell>0.944 secs</cell></row><row><cell>Latency</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Per-Proxy Storage</cell><cell>6.03 TB</cell><cell>602 GB</cell><cell>5.40 TB</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 4 :</head><label>4</label><figDesc>Cooperative caching performance for the State.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>We do not have the cacheable hit rate curve for the Microsoft trace, because that trace does not contain cacheability information. However, we will be able to obtain that information for the final version.</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Finally, we feel that in practice, cooperative-caching schemes on the scale of up to a medium-sized city could be possible, with many small organizations cooperating. We believe that this cooperation might be best achieved by using a small number of proxy caches (e.g., ten) at the second level of a cooperative-caching hierarchy, with a hashbased scheme used to distribute the load and storage requirements among these second-level caches. Such a system would achieve near optimal latency, bandwidth, and storage performance.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Measuring the behavior of a World Wide Web server</title>
		<author>
			<persName><forename type="first">Jussara</forename><surname>Almeida</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Virgilio</forename><surname>Almeida</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Yates</surname></persName>
		</author>
		<idno>96-025</idno>
		<imprint>
			<date type="published" when="1996-10">October 1996</date>
		</imprint>
		<respStmt>
			<orgName>Boston University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Characterizing reference locality in the WWW</title>
		<author>
			<persName><forename type="first">Virgilio</forename><surname>Almeida</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Azer</forename><surname>Bestavros</surname></persName>
		</author>
		<idno>96-011</idno>
		<imprint>
			<date type="published" when="1996-06">June 1996</date>
		</imprint>
		<respStmt>
			<orgName>Boston University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>Mark Crovella, and Adriana deOliveira</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Serverless network file systems</title>
		<author>
			<persName><forename type="first">T</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dahlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Neefe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Patterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Roselli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="1996-02">February 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Web server workload characterization: The search for invariants</title>
		<author>
			<persName><forename type="first">Martin</forename><forename type="middle">F</forename><surname>Arlitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carey</forename><forename type="middle">L</forename><surname>Williamson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the ACM SIGMETRICS &apos; 96 Conference</title>
		<meeting>of the ACM SIGMETRICS &apos; 96 Conference</meeting>
		<imprint>
			<date type="published" when="1996-04">April 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Web caching and Zipf-like distributions: Evidence and implications</title>
		<author>
			<persName><forename type="first">Lee</forename><surname>Breslau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pei</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Li</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Graham</forename><surname>Phillips</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE INFOCOM &apos; 99</title>
		<meeting>IEEE INFOCOM &apos; 99</meeting>
		<imprint>
			<date type="published" when="1999-03">March 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Web proxy caching: the devil is in the details</title>
		<author>
			<persName><forename type="first">Ramon</forename><surname>Caceres</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fred</forename><surname>Douglis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anja</forename><surname>Feldmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gideon</forename><surname>Glass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Rabinovich</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998-06">June 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Characterization of web proxy traffic and Wisconsin proxy benchmark 2.0</title>
		<author>
			<persName><forename type="first">Pei</forename><surname>Cao</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998-11">November 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Cost-aware WWW proxy caching algorithms</title>
		<author>
			<persName><forename type="first">Pei</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sandy</forename><surname>Irani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">of the USENIX Symposium on Internet Technologies and Systems, November</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A hierarchical Internet object cache</title>
		<author>
			<persName><forename type="first">Anawat</forename><surname>Chankhunthod</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><forename type="middle">B</forename><surname>Danzig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chuck</forename><surname>Neerdaels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">F</forename><surname>Schwartz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kurt</forename><forename type="middle">J</forename><surname>Worrell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 1996 USENIX Technical Conference</title>
		<meeting>of the 1996 USENIX Technical Conference</meeting>
		<imprint>
			<date type="published" when="1996-01">January 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Selfsimilarity in World Wide Web traffic: Evidence and possible causes</title>
		<author>
			<persName><forename type="first">Mark</forename><forename type="middle">E</forename><surname>Crovella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Azer</forename><surname>Bestavros</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the ACM SIGMETRICS &apos; 96 Conference</title>
		<meeting>of the ACM SIGMETRICS &apos; 96 Conference</meeting>
		<imprint>
			<date type="published" when="1996-04">April 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Characteristics of WWW client-based traces</title>
		<author>
			<persName><forename type="first">Carlos</forename><forename type="middle">R</forename><surname>Cunha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Azer</forename><surname>Bestavros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><forename type="middle">E</forename><surname>Crovella</surname></persName>
		</author>
		<idno>BU-CS-95-010</idno>
		<imprint>
			<date type="published" when="1995-07">July 1995</date>
		</imprint>
		<respStmt>
			<orgName>Boston University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">NetCache architecture and deployment</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Danzig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">3rd International WWW Caching Workshop</title>
		<imprint>
			<date type="published" when="1998-06">June 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Rate of change and other metrics: a live study of the World Wide Web</title>
		<author>
			<persName><forename type="first">Fred</forename><surname>Douglis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anja</forename><surname>Feldmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Balachander</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><surname>Mogul</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the USENIX Symposium on Internet Technologies and Systems</title>
		<meeting>of the USENIX Symposium on Internet Technologies and Systems</meeting>
		<imprint>
			<date type="published" when="1997-11">November 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The measured access characteristics of World Wide Web client proxy caches</title>
		<author>
			<persName><forename type="first">Brian</forename><surname>Duska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Marwood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">J</forename><surname>Feeley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the USENIX Symposium on Internet Technologies and Systems</title>
		<meeting>of the USENIX Symposium on Internet Technologies and Systems</meeting>
		<imprint>
			<date type="published" when="1997-11">November 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Summary cache: A scalable wide-area web cache sharing protocol</title>
		<author>
			<persName><forename type="first">Li</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pei</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jussara</forename><surname>Almeida</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrei</forename><forename type="middle">Z</forename><surname>Broder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIG-COMM &apos; 98</title>
		<meeting>ACM SIG-COMM &apos; 98</meeting>
		<imprint>
			<date type="published" when="1998-08">August 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Implementing global memory management in a workstation cluster</title>
		<author>
			<persName><forename type="first">M</forename><surname>Feeley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Morgan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pighin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Karlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Levy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Thekkath</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 15th ACM Symposium on Operating Systems Principles</title>
		<meeting>of the 15th ACM Symposium on Operating Systems Principles</meeting>
		<imprint>
			<date type="published" when="1995-12">December 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Performance of web proxy caching in heterogeneous bandwidth environments</title>
		<author>
			<persName><forename type="first">Anja</forename><surname>Feldmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ramon</forename><surname>Caceres</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fred</forename><surname>Douglis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gideon</forename><surname>Glass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Rabinovich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE INFO-COM &apos; 99</title>
		<meeting>IEEE INFO-COM &apos; 99</meeting>
		<imprint>
			<date type="published" when="1999-03">March 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Introduction to statistical pattern recognition</title>
		<author>
			<persName><forename type="first">K</forename><surname>Fukunaga</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990-06">June 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A caching relay for the world wide web</title>
		<author>
			<persName><forename type="first">Steven</forename><surname>Glassman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. First InternationalWorld Wide Web Conference</title>
		<meeting>First InternationalWorld Wide Web Conference</meeting>
		<imprint>
			<date type="published" when="1994-05">May 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">System design issues for Internet middleware services: Deductions from a large client trace</title>
		<author>
			<persName><forename type="first">Steven</forename><forename type="middle">D</forename><surname>Gribble</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><forename type="middle">A</forename><surname>Brewer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the USENIX Symposium on Internet Technologies and Systems</title>
		<meeting>of the USENIX Symposium on Internet Technologies and Systems</meeting>
		<imprint>
			<date type="published" when="1997-11">November 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Ucb home ip http traces</title>
		<author>
			<persName><forename type="first">Steven</forename><forename type="middle">D</forename><surname>Gribble</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><forename type="middle">A</forename><surname>Brewer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997-06">June 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Web caching with consistent hashing</title>
		<author>
			<persName><forename type="first">David</forename><surname>Karger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tom</forename><surname>Leighton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Danny</forename><surname>Lewin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alex</forename><surname>Sherman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International World Wide Web Conference</title>
		<meeting>the 8th International World Wide Web Conference</meeting>
		<imprint>
			<date type="published" when="1999-05">May 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Exploring the bounds of web latency reduction from caching and prefetching</title>
		<author>
			<persName><forename type="first">M</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Darrell</forename><forename type="middle">D E</forename><surname>Kroeger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">C</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><surname>Mogul</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the USENIX Symposium on Internet Technologies and Systems</title>
		<meeting>of the USENIX Symposium on Internet Technologies and Systems</meeting>
		<imprint>
			<date type="published" when="1997-11">November 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Maintaining strong cache consistency in the World Wide Web</title>
		<author>
			<persName><forename type="first">Chengjie</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pei</forename><surname>Cao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ICDCS &apos; 97</title>
		<meeting>of ICDCS &apos; 97</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">An empirical model of HTTP network traffic</title>
		<author>
			<persName><forename type="first">Bruce</forename><forename type="middle">A</forename><surname>Mah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE INFOCOM &apos; 97</title>
		<meeting>IEEE INFOCOM &apos; 97</meeting>
		<imprint>
			<date type="published" when="1997-04">April 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A new protocol for efficient transversal web caching</title>
		<author>
			<persName><forename type="first">Jean-Marc</forename><surname>Menaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Valerie</forename><surname>Issarny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michel</forename><surname>Banatre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 12th Int. Symp. on Distributed Computing</title>
		<meeting>of the 12th Int. Symp. on Distributed Computing</meeting>
		<imprint>
			<date type="published" when="1998-09">September 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Network behavior of a busy web server and its clients</title>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">C</forename><surname>Mogul</surname></persName>
		</author>
		<idno>95/5</idno>
		<imprint>
			<date type="published" when="1995-10">October 1995</date>
		</imprint>
		<respStmt>
			<orgName>Digital Equipment Corporation Western Research Laboratory</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Not all hits are created equal: Cooperative proxy caching over a wide area network</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Rabinovich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeff</forename><surname>Chase</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Syam</forename><surname>Gadde</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">3rd International WWW Caching Workshop</title>
		<imprint>
			<date type="published" when="1998-06">June 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<ptr target="http://squid.nlanr.net" />
		<title level="m">Squid internet object cache</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Design considerations for distributed caching on the internet</title>
		<author>
			<persName><forename type="first">Renu</forename><surname>Tewari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Dahlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Harrick</forename><surname>Vin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Kay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The 19th IEEE International Conference on Distributed Computing Systems</title>
		<imprint>
			<date type="published" when="1999-05">May 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Digital&apos;s web proxy traces</title>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">C</forename><surname>Mogul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M</forename><surname>Kroeger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Maltzahn</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996-08">August 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">The lsam proxy cache -a multicast distributed virtual cache</title>
		<author>
			<persName><forename type="first">Joe</forename><surname>Touch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">3rd International WWW Caching Workshop</title>
		<imprint>
			<date type="published" when="1998-06">June 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Cache array routing protocol v1</title>
		<author>
			<persName><forename type="first">Vinod</forename><surname>Valloppillil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keith</forename><forename type="middle">W</forename><surname>Ross</surname></persName>
		</author>
		<ptr target="ftp://ftp.isi.edu/internet-drafts/draft-vinod-carp-v1-03.txt" />
		<imprint>
			<date type="published" when="1998-02">February 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Adaptive web caching</title>
		<author>
			<persName><forename type="first">Lixia</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sally</forename><surname>Floyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Van</forename><surname>Jacobson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 1997 NLANR Web Cache Workshop</title>
		<meeting>of the 1997 NLANR Web Cache Workshop</meeting>
		<imprint>
			<date type="published" when="1997-06">June 1997</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
