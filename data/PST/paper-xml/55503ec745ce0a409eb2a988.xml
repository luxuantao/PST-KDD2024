<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Succinct Randomized Encodings and their Applications</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Nir</forename><surname>Bitansky</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Sanjam</forename><surname>Garg</surname></persName>
							<email>sanjamg@berkeley.edu</email>
						</author>
						<author>
							<persName><forename type="first">Huijia</forename><surname>Lin</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Rafael</forename><surname>Pass</surname></persName>
							<email>rafael@cs.cornell.edu</email>
						</author>
						<author>
							<persName><forename type="first">Sidharth</forename><surname>Telang</surname></persName>
							<email>sidtelang@cs.cornell.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Santa Barbara</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Cornell University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">Cornell University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Succinct Randomized Encodings and their Applications</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">49EE27B90F2B958838D53014E4C73D41</idno>
					<idno type="DOI">10.1145/2746539.2746574</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:45+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A randomized encoding allows to express a "complex" computation, given by a function f and input x, by a "simple to compute" randomized representation f (x) whose distribution encodes f (x), while revealing nothing else regarding f and x. Existing randomized encodings, geared mostly to allow encoding with low parallel-complexity, have proven instrumental in various strong applications such as multiparty computation and parallel cryptography.</p><p>This work focuses on another natural complexity measure: the time required to encode. We construct succinct randomized encodings where the time to encode a computation, given by a program Π and input x, is essentially independent of Π's time complexity, and only depends on its space complexity, as well as the size of its input, output, and description. The scheme guarantees computational privacy of (Π, x), and is based on indistinguishability obfuscation for a relatively simple circuit class, for which there exist instantiations based on polynomial hardness assumptions on multi-linear maps. We then invoke succinct randomized encodings to obtain several strong applications, including:</p><p>• Succinct indistinguishability obfuscation, where the obfuscated program iO(Π) computes the same function as Π for inputs x of apriori-bounded size. Obfus-</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>The notion of a randomized encoding, coined by Ishai and Kushilevitz <ref type="bibr" target="#b35">[35]</ref>, aims to trade the computation of a "complex" function f (x) for the computation of a "simpler" randomized function whose output distribution f (x) encodes f (x), but hides anything else regarding f and x. The "complexity" of computing f is shifted to a decoding procedure that extracts f (x) from f (x).</p><p>The privacy of the function f and input x is naturally captured by an efficient simulator Sim(f (x)), who given only the output f (x), produces a simulated encoding indistinguishable from f (x); privacy can be perfect, statistical, or computational, according to the attained indistinguishability. Capturing what it means to "simplify the computation of f (x)" may take quite different forms according to the complexity measure of interest. Most previous work have focused on computing the randomized encoding f (x) with lower parallel-time complexity than required for computing the original function f , and has been quite successful. In particular, all log-space computations were shown to have perfectly-private randomized encodings in NC 0 <ref type="bibr" target="#b35">[35,</ref><ref type="bibr" target="#b36">36,</ref><ref type="bibr" target="#b5">5]</ref>. When settling for privacy against computationally bounded adversaries, and assuming low-depth pseudo-random generators, the latter extends to arbitrary poly-time computations <ref type="bibr" target="#b6">[6]</ref>, which was already demonstrated in Yao's seminal work on garbling circuits <ref type="bibr" target="#b49">[49]</ref>. The constructed randomized encodings were in turn shown to have various strong applications to parallel cryptography, secure computation, verifiable delegation, and more (see <ref type="bibr" target="#b3">[3]</ref> for a survey).</p><p>Succinct Randomized Encodings. In this work, we focus on another natural complexity measure: the time required to compute f (x). Specifically, given the description of f and the input x, we would like to compute the encoding f (x) in time T that is significantly smaller than the time T required to compute f (x). Decoding time, in contrast, would be as large as T , perhaps with some tolerable overhead. For this goal to be achievable, f has to be given in some succinct representation that is smaller than T , and cannot be given by, say, a size-T circuit. Concretely, we focus on the natural case that f is represented by a succinct program Π, e.g., a Turing machine (TM) or a random-access machine (RAM).</p><p>Besides being interesting from a purely complexity-theoretic perspective, such succinct randomized encodings may have powerful applications analogous to those of the known randomized encodings. One such immediate application is private delegation of computation: a weak client that wishes to use the aid of a server to run a long computation Π on a short private input x, may quickly compute a succinct randomized encoding Π(x), and have the server decode the result Π(x), without the server learning anything regarding x (with a little more effort, we can even ensure privacy of the output, and be able to verify that the server computed correctly).</p><p>Beyond shifting computation from weak parties to strong parties, succinct randomized encodings may sometimes save in communication and computation altogether. For instance, one of the first demonstrated applications of randomized encodings <ref type="bibr" target="#b35">[35,</ref><ref type="bibr" target="#b36">36]</ref> was to achieve such savings in multi-party computation (MPC). Indeed, most known MPC solutions explicitly utilize the circuit C f (x1, . . . , xm) representing a function f (x1, . . . , xm), and the overhead they incur, e.g. in communication, may depend on the circuit size |C|. When the function f is succinctly represented by a program Π, we may have the parties compute first a succinct randomized Π(x1, . . . , xm), and only decode at the end, thereby making communication overhead proportional to the smaller circuit that computes Π. Furthermore, the effort of decoding (proportional to Π's running time) falls only on the parties that obtain the output. If the overhead of decoding is small, it may reduce the computational complexity of the MPC protocol as well. (For instance, now only a single party, rather than each one of the parties, has to invest resources proportional to the running time of f .) Do Succinct Randomized Encodings Exist? Under commonly believed complexity-theoretic assumptions, perfectlyprivate randomized encodings for all of P are unlikely to be computable too fast, e.g. in fixed polynomial time. <ref type="foot" target="#foot_0">1</ref> In contrast, restricting attention to privacy against computationallybounded adversaries, no lower bounds or barriers are known. In fact, succinct indistinguishability obfuscation (iO) for any model of computation (e.g., iO for Turing machines) would directly imply corresponding succinct randomized encodings. 2 Still, constructions of succinct iO <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b1">1]</ref>, or direct constructions of succinct randomized encodings <ref type="bibr" target="#b32">[32,</ref><ref type="bibr" target="#b30">30]</ref> are based on considerably strong computational assumptions such as extractable witness encryption, succinct noninteractive arguments, and differing-inputs obfuscation. In the language of <ref type="bibr" target="#b45">[45]</ref> these assumptions are not efficientlyfalsifiable; furthermore, in some cases they have been shown implausible <ref type="bibr" target="#b17">[17,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b24">24]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Contributions</head><p>Our core contribution is a succinct randomized encoding relying on (non-succinct) iO for circuits, for any class of a-priori bounded-space computations. That is, the time to encode depends on the space complexity of the computation, but is essentially independent of its time complexity. The construction, in fact, satisfies the enhanced guarantee of a succinct garbling schemes <ref type="bibr" target="#b49">[49,</ref><ref type="bibr" target="#b6">6,</ref><ref type="bibr" target="#b11">11]</ref>, with the extra feature that inputs can be encoded independently of the program and its complexity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1 (Main Theorem, Informally Stated).</head><p>Assume the existence of iO for P/poly and one-way functions. Then, for every polynomial s(•), there exists a succinct randomized encoding (or garbling scheme) for all polynomialtime programs Π with space-complexity S(n) ≤ s(n). Specifically, the time to encode depends polynomially on the size of Π, the lengths (n, m) of its input and output, and the space bound s(n), but only polylogarithmically on Π's runningtime.</p><p>On the Underlying Assumption: Assuming puncturable pseudorandom functions in NC 1 (known based on various hardness assumptions, such as the hardness of the learning with errors problem <ref type="bibr" target="#b15">[15]</ref>), and restricting attention to any class of computations with a-priori-bounded running time t(n), we can settle for iO for circuits in NC 1 with input size O(log(t(n)) (which is a poly(t(n))-time falsifiable assumption on its own). Obtaining iO for this class may be done based on qualitatively weaker assumptions; indeed, for any polynomial t(•) the construction of Gentry et al. <ref type="bibr" target="#b31">[31]</ref> would imply iO for the corresponding class based on a polynomial hardness assumption on multi-linear maps. <ref type="foot" target="#foot_2">3</ref>We then demonstrate the power of succinct randomized encodings in several applications, some new, and some analogous to previous applications of randomized encodings, but with new succinctness properties.</p><p>Application 1: Succinct Indistinguishability Obfuscation. Our first (and somewhat strongest) application of succinct randomized encodings is succinct iO for boundedspace computations. Indistinguishability here means that the (succinct) obfuscations of two programs that have the same output and running time on all inputs x of some aprioribounded length n are computationally indistinguishable. The construction is based on subexponential iO, whereas any form of succinct iO realized so far <ref type="bibr" target="#b1">[1,</ref><ref type="bibr" target="#b16">16,</ref><ref type="bibr" target="#b37">37]</ref> relies on differinginputs obfuscation in conjunction with succinct non-interactive arguments (which already entail strong succinctness properties); as mentioned before, these are considered very strong up to implausible in certain settings.</p><p>Theorem 2 (Informally Stated). Assume the existence of succinct randomized encodings for space-bounded programs, one-way functions, and iO for P/poly that are all subexponentially-secure. Then, for every polynomial s(•), there exists a succinct iO for all polynomial-time programs Π with space-complexity S(n) ≤ s(n), Specifically, the time to obfuscate Π depends polynomially on the size of Π, the input length n, and the space bound s(n), but only polylogarithmically on Π's running-time and output length m.</p><p>The theorem is somewhat the succinct analog of previous bootstrapping theorems <ref type="bibr">[4,</ref><ref type="bibr" target="#b19">19]</ref> who show how (non-succinct) randomized encodings and pseudo-random functions in NC 1 , together with obfuscation for NC 1 circuits, imply obfuscation for P/poly. Here, through succinct randomized encodings, we reduce iO for arbitrarily long computations to iO for circuits of fixed polynomial size.</p><p>Application 2: Succinct Functional Encryption and Reusable Garbling. The recent leap in the study of obfuscation has brought with it a corresponding leap in functional encryption (FE). Today, (indistinguishability-based) functional encryption for all circuits can be constructed from IO <ref type="bibr" target="#b23">[23,</ref><ref type="bibr" target="#b48">48]</ref>, or even from concrete (and efficiently falsifiable) assumptions on composite order multilinear graded-encodings <ref type="bibr" target="#b25">[25]</ref>. For models of computation with succinct representations, we may hope to have succinct FE, where a secret key skΠ, allowing to decryption Π(x) from an encryption of x, can be computed faster than the running time of Π. However, here the state-of-art was similar to succinct randomized encodings, or succinct iO, requiring essentially the same strong (non-falsifiable) assumptions.</p><p>One can replace iO for circuits, in the above FE constructions, with the succinct iO from Theorem 2, and obtain FE where computing skΠ is comparable to (succinctly) obfuscating Π. This, however, will require the same subexponential hardness of iO for circuits. Based on existing non-succinct functional encryption schemes, we show that succinct FE can be constructed without relying on subexponentially hard primitives.</p><p>Theorem 3 (Informally Stated). Assume the existence of succinct randomized encodings for space-bounded programs, one-way functions, and iO for P/poly. Then, for every polynomial s(•), there exists a succinct FE where a functional key skΠ could be generated for any polynomialtime program Π with space-complexity S(n) ≤ s(n), and can decrypt encryption of messages of apriori-bounded length. The time to derive skΠ depends polynomially on the size of Π, the input and output lengths (n, m), and space bound s(n), but only polylogarithmically on Π's running-time.</p><p>The scheme is selectively-secure. Assuming also puncturable pseudo-random functions in NC 1 , and the same assumptions on multi-linear maps made in <ref type="bibr" target="#b25">[25]</ref>, results in full (adaptive) security.</p><p>As observed in previous work <ref type="bibr" target="#b30">[30,</ref><ref type="bibr" target="#b20">20,</ref><ref type="bibr" target="#b33">33]</ref>, FE (even indistinguishability based) directly implies an enhanced version of randomized encodings known as reusable garbling. Here reusability means that an encoding consists of two parts: The first part Π is independent of any specific input, and only depends on the machine Π. Π can then be "reused" together with a second part x encoding any input x. We get succinct reusable garbling for space-bounded computations: encoding Π depends on the space, but is done once, subsequent input-encodings depend only on the input size n and not on space.</p><p>Application 3: Publicly Verifiable Delegation and succinct NIZKs. Succinct randomized encodings directly imply a one-round delegation scheme for polynomial-time computations with bounded space complexity. A main feature of the scheme is public-verifiability, meaning that given the verifier's message σ anyone can verify the proof π from the prover, without requiring any secret verification state. Previous publicly-verifiable schemes relied on strong knowledge assumptions <ref type="bibr" target="#b34">[34,</ref><ref type="bibr" target="#b12">12,</ref><ref type="bibr" target="#b21">21,</ref><ref type="bibr" target="#b13">13]</ref> or proven secure only in the random oracle model <ref type="bibr" target="#b43">[43]</ref>. <ref type="foot" target="#foot_3">4</ref> Another prominent feature of the scheme is that it guarantees input privacy for the verifier. (While this can generically be guaranteed with fully homomorphic encryption, the generic solution requires the prover to convert the computation into a circuit, which could incur quadratic blowup; in our solution, the complexity of the prover corresponds to decoding complexity, which could be made quasi-linear. See further discussion below.)</p><p>The delegation scheme is based only on randomized encodings (and one-way functions), and thus as explained above, can be based only on polynomial assumptions. Assuming also iO, we can make the verifier's message reusable; namely, the verifier can publish his message σ once and for all, and then get non-interactive proofs for multiple computations. <ref type="foot" target="#foot_4">5</ref>Theorem 4 (Informally Stated).</p><p>1. Assume the existence of succinct randomized encodings for space-bounded programs and one-way functions. Then, there exists a publicly-verifiable 2-message delegation scheme with input privacy where verifying a computation given by a program Π and input x, is polynomial in the size of Π, input length and output lengths (n, m), and the space S required to compute Π(x), but only polylogarithmic in Π's running-time.</p><p>2. Assuming also iO for P/poly, the verifier message σ is made reusable for computations with a-priori bounded space s(n). Furthermore, only the one-time generation of σ depends on s(n), whereas subsequent verification depends only on the input size n (and the security parameter).</p><p>Plugging in our succinct iO into the perfect non-interactive zero-knowledge (NIZK) arguments of Sahai-Waters <ref type="bibr" target="#b47">[47]</ref> directly yields a construction of perfect succinct NIZK for bounded-space NP from iO for P/poly and one-way functions that are both sub-exponentially-secure. The NIZK has a succinct common reference string whose size is independent of the time required to verify the NP statement to be proven, and only depends on the space, and the size of the input and witness (verification time depends only on the length of the statement as in <ref type="bibr" target="#b47">[47]</ref>).</p><p>iO for NC 1 is enough: We note that in all three theorems above, the assumption of iO for P/poly can replaced with assuming iO for NC 1 and puncturable pseudo-random functions in NC 1 . Indeed, in the above applications the obfuscated circuit is dominated by computing a succinct randomized encoding and a puncturable PRF. Here we can rely on the observation that randomized encodings can be composed <ref type="bibr" target="#b6">[6]</ref>. Concretely, we can consider an outer layer of a non-succinct shallow randomized encoding (like Yao <ref type="bibr" target="#b49">[49]</ref>) that computes an inner succinct randomized encoding.</p><p>Other Applications. We reinspect additional previous applications of (non-succinct) randomized encodings and note the resulting succinctness features. One application, briefly mentioned above, is to multiparty computation <ref type="bibr" target="#b35">[35,</ref><ref type="bibr" target="#b36">36]</ref>, where we can reduce the communication overhead from depending on the circuit size required to compute a multiparty function f (x1, . . . , xm) to depending on the space required to compute f , which can be much smaller. When focusing merely on communication this problem has by now general one-round solutions based on (multi-key) fully-homomorphic encryption <ref type="bibr" target="#b28">[28,</ref><ref type="bibr" target="#b9">9,</ref><ref type="bibr" target="#b41">41,</ref><ref type="bibr" target="#b22">22]</ref>. Succinct randomized encodings allow in addition to shift the work load to one party (the decoder) that obtains the output, without inducing extra rounds. (With one extra message, outputs to weak parties can also be delivered, while guaranteeing their privacy and correctness.)</p><p>Another application is to amplification of key-dependent message security (KDM). In KDM encryption schemes, semantic security needs to hold, even when the adversary obtains encryptions of functions of the secret key taken from a certain class F. Applebaum <ref type="bibr" target="#b2">[2]</ref> shows that any scheme that is KDM-secure with respect to some class of functions F can be made resilient to a bigger class F ⊇ F, if functions in F can be randomly encoded in F. Our succinct randomized encodings will essentially imply that KDM-security for circuits of any fixed polynomial size s(•) (such as the scheme of <ref type="bibr" target="#b10">[10]</ref>) can be amplified to KDM-security for functions that can be computed by programs with space S s(n), but could potentially have larger running time.</p><p>Dependence on the output length. As stated above, the size of our basic randomized encodings grows with the output of the underlying computation. Such dependence can be easily shown to be inherent as long as we require simulation-based security (using a standard incompressibility argument). Nevertheless, this dependence can be removed if we settle for a weaker indistinguishability-based guarantee saying that randomized encodings of two computations leading to the same output are indistinguishable. This guarantee, in fact, suffices, and allows removing outputdependence, in all of the applications above, except for the multi-party application (which requires simulation on its own).</p><p>Optimizing Decoding Time. While we have so far concentrated on how fast can a randomized encoding be computed, one may also be interested in optimizing the time and space complexity of decoding. Ideally the complexity of decoding should be as close as possible to that of the original computation. In our basic scheme, decoding Π(x) of a T -time S-space computation Π(x), where S is a-priori bounded by some polynomial s(n), requires roughly time T • poly(s(n)) and space poly(s(n)), while encoding takes only time poly(s(n)) (up to polynomial factors in the security parameter). This complexity is naturally inherited by all our applications of randomized encodings: for instance, the time to obfuscate a program Π is roughly poly(s(n)), and the time to evaluate the obfuscation (given by Theorem 2) on an input x is proportional to the decoding time for Π(x).</p><p>We show how to optimize our randomized encodings to improve decoding time to roughly T + s(n). This optimization further reduces the encoding time from poly(s(n)) to Õ(s(n)).</p><p>Proposition 1 (Improved Efficiency). Assume the existence of iO for P/poly and one-way functions. Then, for every polynomial s(•), there exists a succinct randomized encoding (or garbling scheme) for all polynomial-time RAM Π with space-complexity S(n) ≤ s(n). Specifically, the time to encode is quasi-linear in the size of Π, input length n, and the space bound s(n). The time to decode Π(x) is polynomial in the size of Π, and quasi-linear in the space bound s(n) and the time T for evaluating Π(x).</p><p>The improvement in encoding and decoding efficiency leads to improved efficiency for our applications of succinct randomized encoding. For instance, we obtain a succinct iO for bounded space RAM that takes time roughly s(n) to obfuscate, and T + s(n) to evaluate. Other applications such as FE, delegation, MPC directly inherit the improved decoding complexity (leading to better decryption time, prover efficiency, and computational complexity respectively).</p><p>We note that the above efficiency optimizations are inspired by a concurrent work of Canetti, Holmgren, Jain, and Vaikuntanathan <ref type="bibr" target="#b18">[18]</ref>, who constructed succinct iO for bounded space RAM, where evaluation takes time roughly T + s(n). We investigated these optimizations after being made aware that they achieve this feature.</p><p>Organization. In Section 2, we provide an overview of the main ideas and techniques behind our results. In Section 3, we discuss concurrent and subsequent related work. Most of the details and formal proofs are omitted from this extended abstract due to lack of space and can be found in the full version of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">TECHNIQUES</head><p>We next overview our construction of succinct randomized encodings for bounded space programs. Beyond iO, the main tool on which we rely is existing non-succinct randomized encodings, or more accurately their enhanced version of garbling schemes. As mentioned before, garbling schemes have the extra feature that the input x can be encoded separately of the program Π given a shared (short) string key <ref type="bibr" target="#b49">[49,</ref><ref type="bibr" target="#b11">11]</ref>. When considering (non-succinct) garbling, e.g. where Π is a circuit, a salient advantage of this separation is that the time to compute the encoded x depends on the length of x, but not on the typically larger running time (or circuit size) of Π. In contrast, the time to compute the encoded Π may be as large as its running time. This feature of "independent input encoding" is crucial for our construction.</p><p>We construct succinct randomized encodings, or in fact, succinct garbling schemes, in two steps: we first construct a non-succinct garbling scheme for bounded-space computations, with the property that the garbled program consists of many "small garbled pieces" that can be generated separately. In the second step, we use iO to "compress" the size of the garbled program, by providing an obfuscated program that takes an index as input and generates the "garbled piece" corresponding to that index. As a result, the final garbled program (namely the obfuscated program) is small and can be efficiently computed. It is only at evaluation time that the underlying non-succinct garbled program is unravelled, by running the obfuscated program on every index, and decoded.</p><p>The Non-succinct Garbling Scheme. We outline the non succinct garbling scheme for bounded computations, based on any one-way function. For concreteness, we shall focus on Turing machines. (The solution extends to any model of bounded-space computation, e.g. RAM, as long as a computation can be decomposed into a sequence of steps operating on one memory.)</p><p>A "trivial" approach towards such garbling is to simply transform any polynomial-time Turing machine into a circuit and then garble the circuit. While our construction in essence relies on this principle, it will in fact invoke garbling for "small" fixed-sized circuits. Concretely, we rely on the existence of a circuit garbling scheme satisfying two additional properties. First, we require that the shared string key, and thus also the input encoding, are generated independently of the circuit to be garbled (e.g., key is sampled at random and given to both the input-encoding and circuit-garbling procedures). Second, we require that encoded inputs can be simulated, given only the input size, whereas the garbled program is simulated using the result Π(x) of the computation (and the randomness used to simulate the encoded input). We refer to such schemes as garbling schemes with independent input encoding and note that Yao's basic scheme <ref type="bibr" target="#b49">[49]</ref> satisfies the two properties.</p><p>Our non-succinct garbling scheme now proceeds as follows. Let Π be a Turing machine with bounded space complexity s(•), running-time t(•), and inputs of length n. We construct a "chain" of t(n) garbled circuits that evaluate Π step by step. More precisely, we first generate keys key 1 , . . . , key t(n) for the t(n) garbled circuits. The j th garbled circuit (which is computed using key key j ) takes as input some state of Π and computes the next state (ie., the state after one computation step); if the next state is a final state, it returns the output generated by Π, otherwise it outputs an encoding of this new state using the next key key j+1 . (Note that after t(n) steps we are guaranteed to get to a final state and thus this process is well-defined.)</p><p>To encode the input, we simply encode the initial state of Π, including the input x, using key 1 . To evaluate the garbled program, we sequentially evaluate each garbled circuit, using the encodings generated in the previous one as inputs to the next one, and so on until the output is generated.</p><p>Security of the Non-Succinct Scheme: an Overview. To show that this construction is a secure (non-succinct) garbling scheme we need to exhibit a simulator that, given just the output y = Π(x) of the program Π on input x and the number of steps t * taken by Π(x), can simulate the encoded input and program. (The reason we provide the simulation with the number of steps t * is that we desire a garbling scheme with a "per-instance efficiency"-that is, the evaluation time is polynomial in the actual running-time t * and not just the worst-case running-time. To achieve such "per-instance efficiency" requires leaking the runningtime, which is why the simulator gets access to it.) Towards this, we start by simulating the t * th garbled circuit with the output being set to y; this simulation generates an encoded input conft * -1 and a garbled program Πt * .</p><p>We then iteratively in descending order simulate the j th garbled circuits Πj with the output being set to confj+1 generated in the previously simulated garbled circuit. We finally simulate the remaining j &gt; t * garbled circuits Πj with the output being set to some arbitrary output in the range of the circuit (e.g., the output y). The simulated encoded input is then conf1 and the simulated garbled program is ( Π1, . . . Π t(n) ). <ref type="foot" target="#foot_5">6</ref>To prove indistinguishability of the simulated garbling and the real garbling, we consider a sequence of hybrid experiments H0, . . . , H t(n) , where in Hj the first j garbled circuits are simulated, and the remaining t(n) -j garbled circuits are honestly generated. To "stitch together" the simulated circuits with the honestly generated ones, the j th garbled circuit is simulated using as output an honest encoding confj of the actual configuration confj of the TM Π after j steps.</p><p>It follows from the security of the garbling scheme that hybrids Hj and Hj+1 are indistinguishable and thus also H0 (i.e., the real experiment) and H t(n) .</p><p>Let us finally note a useful property of the above-mentioned simulation. Due to the fact that we rely on a garbling scheme with independent input encoding, each garbled circuit can in fact be independently simulated -recall that the independent input encoding property guarantees that encoded inputs can be simulated without knowledge of the circuit to be computed and thus all simulated encoded inputs conf1, . . . conf t(n) can be generated in an initial step. Next, the garbled circuits can be simulated in any order.</p><p>The Succinct Garbling Scheme: an Overview. We now show how to make this garbling scheme succinct. The idea is simple: instead of providing the actual garbled circuits in the clear, we provide an obfuscation of the randomized program that generates these garbled circuits. More precisely, we provide an iO of a program Π s,s (•) where s and s are seeds for a PRF F: Π s,s (j), given a "timestep" j ∈ [t(n)], generates the j th garbled circuit in the nonsuccinct garbling of Π using pseudo-random coins generated by the PRF with seed s and s . Specifically, it uses F(s, j) and F(s, j + 1) as randomness to generate key j and key j+1 (recall that the functionality of the j th circuit depends on key j+1 ), and uses F(s , j) as randomness for garbling the j th circuit. Now, the new succinct garbled program is the obfuscated program Λ $ ← iO(Π s,s ), and the encoding x of x remains the same as before, except that now it is generated using pseudo-random coins F(s, 1). Given such a garbled pair Λ and x, one can compute the output by gradually generating the non-succinct garbled program, one garbled circuit at a time, by computing Λ on every time step j, and evaluating the produced garbled circuit with x until the output is produced. (This way, the evaluation still has "per-instance efficiency".) Security of the Succinct Scheme: an Overview. Given that the new succinct garbled program Λ produces "pieces" of the non-succinct garbled program, the natural idea for simulating the succinct garbled program is to obfuscate a program that produces "pieces" of the simulated non-succinct garbled program. The above-mentioned "independent simulation" property of the non-succinct garbling (following from independent input encoding) enables to fulfill this idea.</p><p>More precisely, given an output y and the running-time t * of Π(x), the simulator outputs the obfuscation Λ of a program Π y,t * ,s,s that, given input j, outputs a simulated j th garbled circuit, using randomness F(s, j + 1) to generate confj+1 as the output, and F(s, j) and F(s , j) as the extra randomness needed to simulate the input confj and the garbled Πj. <ref type="foot" target="#foot_6">7</ref> The encoded input x is simulated as in the non-succinct garbling scheme, but using pseudo-random coins F(s, 1).</p><p>It is not hard to see that this simulation works if the obfuscation is virtually black-box secure, as (non-succinct) garbling security guarantees that the entire truth tables of the two programs Π s,s and Π y,t * ,s,s are indistinguishable given an encoding of x, when the hardwired PRF keys s, s are chosen at random. Our goal, however, is to show that iO suffices. Towards this goal, we consider a sequence of hybrid experiments H 0 , . . . , H t(n) with a corresponding sequence of obfuscated programs Π s,s 0 , . . . , Π s,s t(n) that "morph" gradually from the real Π to the fully simulated Π. Specifically, the program Π s,s j obfuscated in H j produces a non-succinct hybrid garbled program as in hybrid Hj in the proof of the non-succinct garbling scheme, except that pseudo-random coins are used instead of truly random coins. That is, for the first j inputs, Πj produces simulated garbled circuits, and for the rest of the inputs, it produces honestly gener-ated garbled circuits, having hardwired the true configuration confj+1.</p><p>To prove indistinguishability of any two consecutive hybrids H j and H j+1 , we rely on the punctured program technique of Sahai and Waters <ref type="bibr" target="#b47">[47]</ref> to replace pseudo-random coins F(s, j + 1), F(s , j + 1) for generating the j + 1 st simulated garbled circuit with truly random coins, and then rely on the indistinguishability of the simulation of the j + 1 st garbled circuit. A bit more concretely, at each step we puncture the seeds s, s only on the (three) points corresponding to the j + 1 st step, and hardwire instead the corresponding outputs generated by Π s,s j ; next, relying on the puncturing guarantee, we can sample these outputs using true independent randomness. At his point, we can already replace the real hardwired garbling with a simulated one. Finally, we go back to generating the hardwired value pseudorandomly as part of the circuit's logic, now identical to Π s,s j+1 , and "unpuncture" the seeds s, s . We note that each such step requires hardwiring a new (real) intermediate configuration confj+1 (used to simulate the j + 1 st garbling), but now the previous hardwired configuration confj can be "forgotten" and blowup is avoided.</p><p>iO for a Simple Class of Circuits is Enough. The obfuscated circuits in the construction are of a special kindtheir input size is O(log t(n)). Canetti et al. <ref type="bibr" target="#b19">[19]</ref> show that iO for NC 1 can be bootstrapped to obtain iO for all circuits, assuming puncturable PRFs in NC 1 <ref type="bibr" target="#b15">[15]</ref>, and incurring a security loss that is exponential in the size of the input. Accordingly, for polynomial t(n), it suffices to assume (polynomially-secure) iO for classes in NC 1 with logarithmic-size inputs.</p><p>Generalizing and Optimizing. The solution described above does not apply uniquely to Turing machines, but rather to any model of computation that can be divided into sequential steps using one memory, for instance random access machines (RAMs). Thus it directly gives a succinct garbling scheme for bounded space RAMs.</p><p>Also note that, in the described solution, we can in fact replace the underlying circuit garbling scheme, with any garbling scheme, as long as it admits independent input encoding. For instance, in the case the program Π is a RAM, we may use previous garbled RAM solutions <ref type="bibr" target="#b42">[42,</ref><ref type="bibr" target="#b29">29,</ref><ref type="bibr" target="#b26">26]</ref>. The benefit is that this allows optimizing the efficiency of our scheme. Indeed, in the solution described above, each step of the machine is translated to a garbled circuit of size O(s(n)) (up to polynomial factors in the security parameter), which means that the complexity of encoding is poly iO (s(n)), where poly iO (•) is the overhead due to obfuscation, and the complexity of decoding for a T -time computation Π(x) is at least T • poly iO (s(n)), which may be significantly larger than the original computation.</p><p>In contrast, known garbled RAM solutions provide a more efficient way of garbling RAMs than converting them into circuits, taking into consideration the RAM structure, and guaranteeing that encoding and decoding require essentially the same time and space as the original RAM computation. Aiming to leverage this efficiency in our solution, instead of partitioning a RAM computation into t(n) steps, each implemented by a circuit of size s(n), we can partition it to t(n)/s(n) pieces, where each piece is an s(n)-step RAM. The encoding and decoding time for each piece are essen-tially linear in its running time O(s(n)) (whereas a circuit implementing any such piece might be of size Ω(s(n) 2 )).</p><p>This modification on its own may still be insufficient; indeed, obfuscating the circuit that produces the garbled RAM may incur non-linear overhead poly iO (•), so that eventually decoding may take time poly iO (s(n)) • t(n)/s(n) which may be again as large as t(n) • s(n).</p><p>To circumvent this blowup, and as a result of independent interest, we show how to bootstrap any iO for circuits to one that has quasi-linear blowup. Overall, in the new solution, for a T -time S-space computation computation Π(x) where S &lt; s(n), encoding takes time Õ(s(n)) and decoding Π(x) takes time O(T + s(n)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Main Ideas behind the Applications</head><p>We briefly sketch the main ideas behind our main applications of succinct randomized encodings.</p><p>Succinct iO. The construction of succinct iO from randomized encoding and exponential iO for circuits is a natural instantiation of the bootstrapping approach suggested by Applebaum <ref type="bibr">[4]</ref>. There, the goal is to reduce obfuscation of general circuits to obfuscation of NC 1 circuits; our goal is to reduce obfuscation of programs with large running time (but bounded space) to obfuscation of significantly smaller circuits. To obfuscate a succinct program Π with respect to inputs of size at most n, we obfuscate a small circuit C Π,K that has a hardwired seed K for a PRF, and given input x, applies the PRF to x to derive randomness, and then computes a succinct randomized encoding of Π(x). The obfuscated iO(Π), given input x computes the encoding, decodes it, and returns the result.</p><p>The analysis in <ref type="bibr">[4]</ref> establishes security in case that the circuit obfuscator iO is virtually black-box secure. We show that if iO has 2 -λ ε -security for security parameter λ n ε , and the PRF is puncturable that is also 2 -λ ε -secure, then a similar result holds for iO (rather than virtual black-box). The proof is based on a general probabilistic iO argument, an abstraction recently made by Canetti et al. <ref type="bibr" target="#b19">[19]</ref>.</p><p>Succinct FE. The construction of succinct functional encryption follows rather directly by plugging in our randomized encodings into previous constructions of non-succinct functional encryption. Concretely, starting with the scheme of Gentry et al. <ref type="bibr" target="#b30">[30]</ref>, we can replace the non-succinct randomized encodings for RAM in their construction with our succinct randomized encodings, and obtain selectively-secure FE. <ref type="foot" target="#foot_7">8</ref> Alternatively, starting from the scheme of Garg et al. <ref type="bibr" target="#b25">[25]</ref>, we can replace randomized encodings for circuits in their construction with our succinct randomized encodings, and get an adaptively secure succinct FE scheme. (Here we also need to rely on the fact that succinct randomized encodings can be computed in low depth, which is required in their construction.) We note that in both cases, our succinct randomized encodings already satisfy the required security for their security proof to go through, and only the succinctness features change.</p><p>Publicly-Verifiable Delegation. Finally, we sketch the basic ideas behind the delegation scheme. The delegation scheme is pretty simple and similar in spirit to previous delegation schemes (in a weaker processing model) <ref type="bibr" target="#b7">[7,</ref><ref type="bibr" target="#b27">27,</ref><ref type="bibr" target="#b46">46,</ref><ref type="bibr" target="#b33">33]</ref>. To delegate a computation, given by Π and x, the verifier simply sends the prover a randomized encoding Π (x, r), where Π is a machine that returns r if and only if it accepts x, and r is a sufficiently long random string. The security of the randomized encoding implies that the prover learns nothing of r, unless the computation is accepting. The scheme can be easily made publicly verifiable by publishing f (r) for some one-way function f . Furthermore, the scheme ensures input-privacy for the verifier.</p><p>We then propose a simple transformation that can be applied to any delegation scheme in order to make the first verifier message reusable. The idea is natural: we let the verifier's first message be an obfuscation of a circuit C K that has a hardwired key K for a puncturable PRF, and given a computation (Π, x), applies the PRF to derive randomness, and generates a first message for the delegation scheme. Thus, for each new computation, a first message is effectively sampled afresh. Relying on iO and the security of the puncturable PRF, we can show that (non-adaptive) soundness is guaranteed. The transformation can also be applied to privately-verifiable delegation schemes, such as the one of <ref type="bibr" target="#b38">[38]</ref> and maintains soundness, even if the prover has a verification oracle.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">CONCURRENT AND SUBSEQUENT WORK</head><p>In concurrent work, Canetti, Holmgren, Jain, and Vaikuntanathan construct succinct iO for RAMs assuming subexponentially secure iO for P/poly. The complexity of their succinct iO is also such that obfuscation depends on an apriori bound on space, but not on the running time. This, in particular, implies a succinct randomized encoding with similar parameters.</p><p>The technique that they employ is quite different from ours, and requires stronger computational assumptions. Their main step is also the construction of a succinct garbling scheme for RAMs; however, their succinct garbling scheme is very different. At a high-level, in our solution, the obfuscation is only responsible for garbling (or encoding); the evaluation of the garbled components (or decoding) is done "externally" by the evaluator; encoding and decoding themselves are implemented using existing garbling schemes. In their solution, the obfuscation deals not only with encoding, but also with decoding, getting as input at every step the encrypted and authenticated current state of the computation. They implement this mechanism by designing a primitive that they call Asymmetrically Constrained Encapsulation, in a careful combination with an oblivious RAM scheme. (In our basic solution, oblivious RAMs are not needed as we rely on garbling for circuits, which are already an oblivious model of computation, but an inefficient one that touches all of the state in every step. In our optimizations, the use of oblivious RAM is abstracted by the underlying garbled RAMs, which are indeed implemented in <ref type="bibr" target="#b42">[42,</ref><ref type="bibr" target="#b29">29,</ref><ref type="bibr" target="#b26">26]</ref> using oblivious RAMs.)</p><p>A disadvantage of their approach is that the circuit deals with inputs of size proportional to the security parameter (due to encryption and authentication of state bits), whereas in our case the circuit just takes a logarithmic size index (representing a time point in the computation); as discussed above, iO for logarithmic length input seems to be a weaker assumption (in particular, it is falsifiable), and can be based on polynomial assumptions on multilinear maps. On the other hand, performing the entire evaluation "inside the obfuscation" as in their approach would eventually lead to a fully succinct solution in subsequent work (see below).</p><p>Full Succinctness. At first glance, our approach seems to suggest a natural way to achieve full succinctness, without any dependence on space. Instead of garbling a sequence of transition circuits, we can garble each gate in the circuit representation of the computation separately; indeed, the circuit corresponding to the computation can be succinctly represented by a small circuit that can output each gate and its corresponding neighbours. More accurately, as in the previous solution, we will garbled an augmented gate that encodes the output under the keys corresponding to its (constant number of) neighbours (towards the output gate). Again, garbling will be derandomized using a pseudorandom function.</p><p>This approach will, in fact, give a fully succinct garbling scheme if we assume virtual black-box security for the above "gate garbler", as once again the truth tables of a real and a simulated garbling will be computationally indistinguishable. However, assuming iO it is not clear how to achieve any advantage over the previous solution. Intuitively, whenever we invoke iO we cannot "forget" an intermediate value in the computation, before all the connected gates in the layer above are simulated (inducing new values to remember). In the worst-case, we are forced to remember an entire configuration.</p><p>In a beautiful subsequent work, Koppula, Lewko, and Waters <ref type="bibr" target="#b40">[40]</ref> construct fully-succinct randomized encodings from iO. Their solution takes a similar route to that of Canetti et al. <ref type="bibr" target="#b18">[18]</ref> in that each step of the computation is done "under the obfuscation". To overcome the space barrier, they introduce a clever "selective enforcement mechanism" that allows avoiding storage of the entire state, by storing a special purpose succinct commitment. In the analysis, this commitment can be indistinguishably replaced with a commitment that statistically binds some selected location in the memory corresponding to a given step of the computation, and is thus "iO-friendly" in their terminology.</p></div>			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Specifically, it can be shown that, for a language L, recognized by a given T (n)-time Turing machine Π, succinct randomized encodings with perfect-privacy computable in time t(n) T (n), would imply that L</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>has 2-message interactive proofs with a O(t(n))-time verifier, which already suggests that t(n) should at least depend on the space (or depth) of the computation. Furthermore, under commonly believed derandomization assumptions (used to show that AM ⊆ NP<ref type="bibr" target="#b39">[39,</ref><ref type="bibr" target="#b44">44]</ref>), the above would imply that L can be non-deterministically decided in time poly(t(n)), for some fixed polynomial poly. Thus, any speedup in encoding would imply related speedup by non-determinism, whereas significant speedup is believed to be unlikely.<ref type="bibr" target="#b2">2</ref> To encode (Π, x) simply obfuscate a program that given no input computes Π(x). This can be simulated from y = Π(x) by obfuscating a program that only performs dummy steps and outputs y.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>More generally, one of the challenges in basing iO on an efficient black-box reduction is that the reduction may have to exhaust the input space to check if the challenge circuits are functionally equivalent. In the above case, this can be done in time poly(t(n)).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>Notably, in the setting of private-verification Kalai, Raz, and Rothblum give a solution based on the subexponential learning with errors assumption<ref type="bibr" target="#b38">[38]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>Our transformation for reusing the verifier's message is, in fact, a generic one that can be applied to any delegation scheme, including privately-verifiable schemes (e.g.,<ref type="bibr" target="#b38">[38]</ref>). For privately-verifiable schemes, the transformation has an additional advantage: it removes what is known as the verifier rejection problem; specifically, in the transformed scheme, soundness holds even against provers with a verification oracle.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>This "layered" simulation strategy resembles that of Applebaum, Ishai, and Kushilevitz in the context of arithmetic garbling<ref type="bibr" target="#b8">[8]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_6"><p>Recall that simulating a garbled circuit requires both the output and the randomness for simulating the input encoding.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_7"><p>Formally, their construction is given in terms of garbling for RAM rather than randomized encodings, but these are actually used as randomized encodings, without making special use of independent input encoding.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements. We thank Boaz Barak and Guy Rothblum for their input regarding the plausibility of interactive proofs with fast verification (relevant to the plausibility of perfectly-private succinct randomized encodings). We thank Daniel Wichs for discussing several aspects of <ref type="bibr" target="#b30">[30]</ref>. We thank Stefano Tessaro for many delightful discussions in early stage of the project. Finally we thank the anonymous reviewers of STOC for their valuable comments.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>* Work supported in part by a Alfred P. Sloan Fellowship, Microsoft New Faculty Fellowship, NSF Award CNS-1217821, NSF CAREER Award CCF-0746990, NSF Award CCF-1214844, AFOSR YIP Award FA9550-10-1-0093, and DARPA and AFRL under contract FA8750-11-2-0211. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of the Defense Advanced Research Projects Agency or the US Government.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Differing-inputs obfuscation and applications</title>
		<author>
			<persName><forename type="first">P</forename><surname>Ananth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zhandry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="issue">689</biblScope>
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Key-dependent message security: Generic amplification and completeness</title>
		<author>
			<persName><forename type="first">B</forename><surname>Applebaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT 2011</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Paterson</surname></persName>
		</editor>
		<meeting><address><addrLine>Tallinn, Estonia; Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">May 15-19, 2011</date>
			<biblScope unit="volume">6632</biblScope>
			<biblScope unit="page" from="527" to="546" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Randomly encoding functions: A new cryptographic paradigm -(invited talk)</title>
		<author>
			<persName><forename type="first">B</forename><surname>Applebaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Information Theoretic Security -5th International Conference</title>
		<meeting><address><addrLine>Amsterdam, The Netherlands</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-05-21">2011. May 21-24, 2011. 2011</date>
			<biblScope unit="page" from="25" to="31" />
		</imprint>
	</monogr>
	<note>Proceedings</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Bootstrapping obfuscators via fast pseudorandom functions</title>
		<author>
			<persName><forename type="first">B</forename><surname>Applebaum</surname></persName>
		</author>
		<author>
			<persName><surname>Kaoshiung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">O C</forename><surname>Taiwan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -ASIACRYPT 2014 -20th International Conference on the Theory and Application of Cryptology and Information Security</title>
		<imprint>
			<date type="published" when="2014">December 7-11, 2014. 2014</date>
			<biblScope unit="page" from="162" to="172" />
		</imprint>
	</monogr>
	<note>Proceedings, Part II</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Cryptography in NC 0</title>
		<author>
			<persName><forename type="first">B</forename><surname>Applebaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">45th Annual Symposium on Foundations of Computer Science</title>
		<meeting><address><addrLine>Rome, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2004">Oct. 17-19, 2004</date>
			<biblScope unit="page" from="166" to="175" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Computationally private randomizing polynomials and their applications</title>
		<author>
			<persName><forename type="first">B</forename><surname>Applebaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Complexity</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="115" to="162" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">From secrecy to soundness: Efficient verification via secure computation</title>
		<author>
			<persName><forename type="first">B</forename><surname>Applebaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP 2010: 37th International Colloquium on Automata, Languages and Programming, Part I</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Abramsky</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Gavoille</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Kirchner</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Meyer Auf Der Heide</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Spirakis</surname></persName>
		</editor>
		<meeting><address><addrLine>Bordeaux, France; Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">July 6-10, 2010</date>
			<biblScope unit="volume">6198</biblScope>
			<biblScope unit="page" from="152" to="163" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">How to garble arithmetic circuits</title>
		<author>
			<persName><forename type="first">B</forename><surname>Applebaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">52nd Annual Symposium on Foundations of Computer Science</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</editor>
		<meeting><address><addrLine>Palm Springs, California, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2011">Oct. 22-25, 2011</date>
			<biblScope unit="page" from="120" to="129" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Multiparty computation with low communication, computation and interaction via threshold FHE</title>
		<author>
			<persName><forename type="first">G</forename><surname>Asharov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>López-Alt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Tromer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wichs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT 2012</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">D</forename></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Johansson</surname></persName>
		</editor>
		<meeting><address><addrLine>Cambridge, UK; Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">Apr. 15-19, 2012</date>
			<biblScope unit="volume">7237</biblScope>
			<biblScope unit="page" from="483" to="501" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Bounded key-dependent message security</title>
		<author>
			<persName><forename type="first">B</forename><surname>Barak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Haitner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Hofheinz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT 2010</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Gilbert</surname></persName>
		</editor>
		<meeting><address><addrLine>French Riviera; Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010-06-03">May 30 -June 3, 2010</date>
			<biblScope unit="volume">6110</biblScope>
			<biblScope unit="page" from="423" to="444" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Foundations of garbled circuits</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">T</forename><surname>Hoang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the ACM Conference on Computer and Communications Security, CCS&apos;12</title>
		<meeting><address><addrLine>Raleigh, NC, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012">October 16-18, 2012. 2012</date>
			<biblScope unit="page" from="784" to="796" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bitansky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Tromer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ITCS 2012: 3rd Innovations in Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</editor>
		<meeting><address><addrLine>Cambridge, Massachusetts, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2012-08-10">Jan. 8-10, 2012</date>
			<biblScope unit="page" from="326" to="349" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Recursive composition and bootstrapping for SNARKS and proof-carrying data</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bitansky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Tromer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">45th Annual ACM Symposium on Theory of Computing</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Roughgarden</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Feigenbaum</surname></persName>
		</editor>
		<meeting><address><addrLine>Palo Alto, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2013">June 1-4, 2013</date>
			<biblScope unit="page" from="111" to="120" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">On the existence of extractable one-way functions</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bitansky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Paneth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rosen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">46th Annual ACM Symposium on Theory of Computing</title>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Shmoys</surname></persName>
		</editor>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2014-06-03">May 31 -June 3, 2014</date>
			<biblScope unit="page" from="505" to="514" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Key homomorphic PRFs and their applications</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Lewi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">W</forename><surname>Montgomery</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Raghunathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO 2013, Part I</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</editor>
		<meeting><address><addrLine>Santa Barbara, CA, USA; Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">Aug. 18-22, 2013</date>
			<biblScope unit="volume">8042</biblScope>
			<biblScope unit="page" from="410" to="428" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">On extractability obfuscation</title>
		<author>
			<persName><forename type="first">E</forename><surname>Boyle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K.-M</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pass</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2014: 11th Theory of Cryptography Conference</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</editor>
		<meeting><address><addrLine>San Diego, CA, USA; Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">Feb. 24-26, 2014</date>
			<biblScope unit="volume">8349</biblScope>
			<biblScope unit="page" from="52" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Limits of extractability assumptions with distributional auxiliary input</title>
		<author>
			<persName><forename type="first">E</forename><surname>Boyle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pass</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="issue">703</biblScope>
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Succinct garbling and indistinguishability obfuscation for ram programs</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Holmgren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">47th Annual ACM Symposium on Theory of Computing</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Obfuscation of probabilistic circuits and applications</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tessaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theory of Cryptography -12th Theory of Cryptography Conference, TCC 2015</title>
		<meeting><address><addrLine>Warsaw, Poland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">March 23-25, 2015. 2015</date>
			<biblScope unit="page" from="468" to="497" />
		</imprint>
	</monogr>
	<note>Proceedings, Part II</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">On the achievability of simulation-based security for functional encryption</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Caro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Iovino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>O'neill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Paneth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Persiano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO 2013 -33rd Annual Cryptology Conference</title>
		<meeting><address><addrLine>Santa Barbara, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013">August 18-22, 2013. 2013</date>
			<biblScope unit="page" from="519" to="535" />
		</imprint>
	</monogr>
	<note>Proceedings, Part II</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Secure two-party computation with low communication</title>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Faust</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hazay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2012: 9th Theory of Cryptography Conference</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Cramer</surname></persName>
		</editor>
		<meeting><address><addrLine>Taormina, Sicily, Italy; Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">Mar. 19-21, 2012</date>
			<biblScope unit="volume">7194</biblScope>
			<biblScope unit="page" from="54" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Two-round secure MPC from indistinguishability obfuscation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Raykova</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2014: 11th Theory of Cryptography Conference</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</editor>
		<meeting><address><addrLine>San Diego, CA, USA; Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">Feb. 24-26, 2014</date>
			<biblScope unit="volume">8349</biblScope>
			<biblScope unit="page" from="74" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Candidate indistinguishability obfuscation and functional encryption for all circuits</title>
		<author>
			<persName><forename type="first">S</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Raykova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">54th Annual Symposium on Foundations of Computer Science</title>
		<meeting><address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2013">Oct. 26-29, 2013</date>
			<biblScope unit="page" from="40" to="49" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">On the implausibility of differing-inputs obfuscation and extractable witness encryption with auxiliary input</title>
		<author>
			<persName><forename type="first">S</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wichs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO 2014, Part I</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</editor>
		<meeting><address><addrLine>Santa Barbara, CA, USA; Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">Aug. 17-21, 2014</date>
			<biblScope unit="volume">8616</biblScope>
			<biblScope unit="page" from="518" to="535" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Fully secure functional encryption without obfuscation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zhandry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2014">2014/666, 2014</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Garbled RAM from one-way functions</title>
		<author>
			<persName><forename type="first">S</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Scafuro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">47th Annual ACM Symposium on Theory of Computing</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Non-interactive verifiable computing: Outsourcing computation to untrusted workers</title>
		<author>
			<persName><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Parno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO 2010</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Rabin</surname></persName>
		</editor>
		<meeting><address><addrLine>Santa Barbara, CA, USA; Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">Aug. 15-19, 2010</date>
			<biblScope unit="volume">6223</biblScope>
			<biblScope unit="page" from="465" to="482" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Fully homomorphic encryption using ideal lattices</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">41st Annual ACM Symposium on Theory of Computing</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Mitzenmacher</surname></persName>
		</editor>
		<meeting><address><addrLine>Bethesda, Maryland, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2009-06-02">May 31 -June 2, 2009</date>
			<biblScope unit="page" from="169" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Garbled RAM revisited</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Raykova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wichs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT 2014 -33rd Annual International Conference on the Theory and Applications of Cryptographic Techniques</title>
		<meeting><address><addrLine>Copenhagen, Denmark</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">May 11-15, 2014. 2014</date>
			<biblScope unit="page" from="405" to="422" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Outsourcing private ram computation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Raykova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wichs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">55th Annual Symposium on Foundations of Computer Science</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Indistinguishability obfuscation from the multilinear subgroup elimination assumption</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lewko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2014">2014/309, 2014</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">How to run turing machines on encrypted data</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">T</forename><surname>Kalai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Popa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Zeldovich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In CRYPTO</title>
		<imprint>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="536" to="553" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Reusable garbled circuits and succinct functional encryption</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">T</forename><surname>Kalai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Popa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Zeldovich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">45th Annual ACM Symposium on Theory of Computing</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Roughgarden</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Feigenbaum</surname></persName>
		</editor>
		<meeting><address><addrLine>Palo Alto, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2013">June 1-4, 2013</date>
			<biblScope unit="page" from="555" to="564" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Delegation of computation without rejection problem from designated verifier CS-Proofs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rubinstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2011">2011/456, 2011</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Randomizing polynomials: A new representation with applications to round-efficient secure computation</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">41st Annual Symposium on Foundations of Computer Science</title>
		<meeting><address><addrLine>Redondo Beach, California, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2000-12-14">Nov. 12-14, 2000</date>
			<biblScope unit="page" from="294" to="304" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Perfect constant-round secure computation via perfect randomizing polynomials</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automata, Languages and Programming, 29th International Colloquium, ICALP 2002</title>
		<meeting><address><addrLine>Malaga, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">July 8-13, 2002. 2002</date>
			<biblScope unit="page" from="244" to="256" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Public-coin differing-inputs obfuscation and its applications</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Pandey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theory of Cryptography -12th Theory of Cryptography Conference, TCC 2015</title>
		<meeting><address><addrLine>Warsaw, Poland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">March 23-25, 2015. 2015</date>
			<biblScope unit="page" from="668" to="697" />
		</imprint>
	</monogr>
	<note>Proceedings, Part II</note>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">How to delegate computations: the power of no-signaling proofs</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">T</forename><surname>Kalai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Raz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">D</forename><surname>Rothblum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">46th Annual ACM Symposium on Theory of Computing</title>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Shmoys</surname></persName>
		</editor>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2014-06-03">May 31 -June 3, 2014</date>
			<biblScope unit="page" from="485" to="494" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Graph nonisomorphism has subexponential size proofs unless the polynomial-time hierarchy collapses</title>
		<author>
			<persName><forename type="first">A</forename><surname>Klivans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Van Melkebeek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">31st Annual ACM Symposium on Theory of Computing</title>
		<meeting><address><addrLine>Atlanta, Georgia, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1999">May 1-4, 1999</date>
			<biblScope unit="page" from="659" to="667" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Indistinguishability obfuscation for turing machines with unbounded memory</title>
		<author>
			<persName><forename type="first">V</forename><surname>Koppula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Lewko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">47th Annual ACM Symposium on Theory of Computing</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">On-the-fly multiparty computation on the cloud via multikey fully homomorphic encryption</title>
		<author>
			<persName><forename type="first">A</forename><surname>López-Alt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Tromer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">44th Annual ACM Symposium on Theory of Computing</title>
		<editor>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Karloff</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Pitassi</surname></persName>
		</editor>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2012">May 19-22, 2012</date>
			<biblScope unit="page" from="1219" to="1234" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">How to garble RAM programs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT 2013, 32nd Annual International Conference on the Theory and Applications of Cryptographic Techniques</title>
		<meeting><address><addrLine>Athens, Greece</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013">May 26-30, 2013. 2013</date>
			<biblScope unit="page" from="719" to="734" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Computationally sound proofs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="1253" to="1298" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Derandomizing Arthur-Merlin games using hitting sets</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">B</forename><surname>Miltersen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">V</forename><surname>Vinodchandran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">40th Annual Symposium on Foundations of Computer Science</title>
		<meeting><address><addrLine>New York, New York, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1999">Oct. 17-19, 1999</date>
			<biblScope unit="page" from="71" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">On cryptographic assumptions and challenges (invited talk)</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO 2003</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</editor>
		<meeting><address><addrLine>Santa Barbara, CA, USA; Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">Aug. 17-21, 2003</date>
			<biblScope unit="volume">2729</biblScope>
			<biblScope unit="page" from="96" to="109" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">How to delegate and verify in public: Verifiable computation from attribute-based encryption</title>
		<author>
			<persName><forename type="first">B</forename><surname>Parno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Raykova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2012: 9th Theory of Cryptography Conference</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Cramer</surname></persName>
		</editor>
		<meeting><address><addrLine>Taormina, Sicily, Italy; Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">Mar. 19-21, 2012</date>
			<biblScope unit="volume">7194</biblScope>
			<biblScope unit="page" from="422" to="439" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">How to use indistinguishability obfuscation: Deniable encryption, and more</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of STOC 2014</title>
		<meeting>of STOC 2014</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">A punctured programming approach to adaptively secure functional encryption</title>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2014">2014/588, 2014</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Protocols for secure computations (extended abstract)</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">-C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">23rd Annual Symposium on Foundations of Computer Science</title>
		<meeting><address><addrLine>Chicago, Illinois</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1982-03-05">Nov. 3-5, 1982</date>
			<biblScope unit="page" from="160" to="164" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
