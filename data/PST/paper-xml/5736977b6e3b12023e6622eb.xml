<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Efficient Genome-Wide, Privacy-Preserving Similar Patient Query based on Private Edit Distance</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Xiaofeng</forename><forename type="middle">Shaun</forename><surname>Wang</surname></persName>
							<email>wangxiao@cs.umd.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Maryland</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution">Indiana University</orgName>
								<address>
									<settlement>Bloomington</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Yan</forename><surname>Huang</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Indiana University</orgName>
								<address>
									<settlement>Bloomington</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Yongan</forename><surname>Zhao</surname></persName>
							<email>yongzhao@indiana.edu</email>
							<affiliation key="aff1">
								<orgName type="institution">Indiana University</orgName>
								<address>
									<settlement>Bloomington</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Haixu</forename><surname>Tang</surname></persName>
							<email>hatang@indiana.edu</email>
							<affiliation key="aff1">
								<orgName type="institution">Indiana University</orgName>
								<address>
									<settlement>Bloomington</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Diyue</forename><surname>Bu</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Indiana University</orgName>
								<address>
									<settlement>Bloomington</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Efficient Genome-Wide, Privacy-Preserving Similar Patient Query based on Private Edit Distance</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">45280CFD928E90F36C20C0B8147ED9F2</idno>
					<idno type="DOI">10.1145/2810103.2813725</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T06:08+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Security and Protection Secure Computation</term>
					<term>Genomic Computation</term>
					<term>Edit Distance</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Edit distance has been proven to be an important and frequentlyused metric in many human genomic research, with Similar Patient Query (SPQ) being a particularly promising and attractive example. However, due to the widespread privacy concerns on revealing personal genomic data, the scope and scale of many novel use of genome edit distance are substantially limited. While the problem of private genomic edit distance has been studied by the research community for over a decade <ref type="bibr" target="#b5">[5]</ref>, the state-of-the-art solution <ref type="bibr" target="#b30">[30]</ref> is far from even close to be applicable to real genome sequences.</p><p>In this paper, we propose several private edit distance protocols that feature unprecedentedly high efficiency and precision. Our construction is a combination of a novel genomic edit distance approximation algorithm and new construction of private set difference size protocols. With the private edit distance based secure SPQ primitive, we propose GENSETS, a genome-wide, privacypreserving similar patient query system. It is able to support searching large-scale, distributed genome databases across the nation. We have implemented a prototype of GENSETS. The experimental results show that, with 100 Mbps network connection, it would take GENSETS less than 200 minutes to search through 1 million breast cancer patients (distributed nation-wide in 250 hospitals, each having 4000 patients), based on edit distances between their genomes of lengths about 75 million nucleotides each.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Consider a physician seeking the best clinic decision for her patients. Invaluable to the effort is the information how other similar patients respond to different therapies. As today's sequencing technologies have cut the cost of whole genome sequencing Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from Permissions@acm.org. CCS <ref type="bibr">'</ref> down to roughly $1000 per person <ref type="bibr" target="#b52">[52]</ref>, it is highly anticipated that genome-based Similar Patient Queries (SPQ) will be used to identify similar patients from a large number of Electronic Medical Records, through a health information exchange (HIE) system such as PatientsLikeMe (a patient powered resesarch network <ref type="bibr" target="#b1">[1]</ref>), or other emerging systems like the Memphis HIE, Indiana HIE and Illinois HIE. Among the indicators of genetic similarity, editdistance is one of the most important metrics, which is very useful in the biomedical research for the diagnosis and treatment of cancer, Alzheimer's disease, Schizophrenia, etc <ref type="bibr" target="#b44">[44,</ref><ref type="bibr" target="#b49">49,</ref><ref type="bibr" target="#b22">22,</ref><ref type="bibr" target="#b51">51]</ref>. Genome-wide Secure SPQ. Standing in the way of deploying a national-scale, genome-wide SPQ system, however, is the privacy and liability concerns in the dissemination of such data. While unauthorized disclosure of personal genome data could cause serious harm to patients, such as denial of insurance, employment and education opportunities or blackmail <ref type="bibr" target="#b29">[29]</ref>, getting proper authorizations from millions of patients to share their data is not easy, due to its complicated procedure. Further, searching disease data solely relying on signed agreements can be less realistic in the near future, particularly when it comes to the secondary use (e.g., biomedical research). As a result, in the absence of scalable techniques that enable data use without exposing its content to unauthorized parties, the chance for any SPQ system to be deployed in practice is remote, at least in the near future.</p><p>Addressing such privacy challenges in supporting SPQ over distributed genomic datasets seems right up the alley of Secure Multi-Party Computation (SMC). Despite continuous performance improvements of secure computation in recent years, the scalability and performance of the state-of-the-art edit-distance based SPQ is still far from usable in supporting SPQ queries: the most efficient SMC implementation can only compute the edit distance between two sequences of a few thousands of base pairs, at a cost of hours of computing time and tens of gigabytes of bandwidth consumption <ref type="bibr" target="#b30">[30]</ref>. This is completely off the scale expected for a nationwide SPQ system. Secure query at the national scale. To enable patients to benefit from the soon-to-be-available, enormous amount of clinic genomic data, we propose a suite of novel techniques to offer secure SPQ based on the edit distance metric. Our approach, called GENSETS (Genome-wide, Secure Patient Search), is capable of searching 250 hospitals each containing 4000 patients (totally 1 million patients) across the nation within 200 minutes, by securely thresholding the edit distances over real genome data from breast cancer patients (Section 4.1).</p><p>Underpinning GENSETS are a few key insights that enables a simple and effective edit-distance based SPQ design. First, we observe a unique feature in human genome sequences and exploit it in developing a highly accurate approximation of edit distance be-tween genomes. More specifically, variations across the genome sequences of two average human individuals (even those associated with different genetic diseases) are dominated by nuleotide substitutions, with sporadic insertions and deletions scattered across the genome. Second, leveraging a public reference genome (so the variations of one's private genome from the reference genome can be locally computed) and pre-computed private variations, the editdistance between two private genomes can be efficiently approximated using set difference size from the (much shorter) private variations. Third, the size of private set difference can be securely approximated (without ever computing the private set difference) using probabilistic algorithms; furthermore, secure thresholding on the size of private set difference can be computed even more efficiently without ever computing even the size of set difference.</p><p>Combining those key observations above, we convert the problem of private edit distance into a much simpler problem of approximating the size of set difference (Section 3.2). We showed, through running our prototype in realistic continental network environment, that the edit distance between the whole-genomes of two persons can be securely calculated in less than 40 seconds, at an error rate of 1.5%; while comparing the edit distance of two persons' wholegenomes with a threshold value can be done even faster, consuming less than 0.9 seconds to achieve 0.01% false positive/negative rate.</p><p>This secure SPQ primitive (based on secure edit-distance) can potentially be deployed to support two-stage queries, in which hospitals will group their patients into clusters so that the first stage query identifies (by computing private edit distance between the query and the cluster center, which is a patient in the cluster) candidate clusters that contain similar patients; while the second stage only searches similar patients in those candidate clusters.</p><p>We implemented the secure SPQ primitive and evaluated our approach over a real genome dataset consists of 105 breast cancer patients (data obtained from dbGaP/TCGA with IRB approval). We run SPQ experiments over a cross-country network. With a 100 Mbps network connection, GenSets can accurately execute a SPQ query in less than 200 minutes to search through 1 million patients distributed in 250 hospitals (assuming each hospital has 4000 patients' records and that at most 5 candidate hospitals are selected to continue to the second stage). This result shows that our techniques have moved secure SPQ, one of the most important application of HIE, close to practice use. Contributions. The contributions of the paper include:</p><p>• New techniques. We developed a new approach to realize secure SPQ based on whole-genome edit-distance, attaining unprecedented high performance. We achieved this by exploiting intrinsic features of human genome data and efficient probabilistic approximation algorithms. Specifically, we propose an efficient, scalable algorithm to approximate edit-distance for human genomes (Section 3.2), two efficient, probabilistic private set difference size protocols and an efficient, probabilistic private set difference size thresholding protocol (Section 3.4). These, together with a new two-step SPQ search scheme, moves the privacy-preserving SPQ closer to the national scale than it has ever been.</p><p>• Implementation and evaluation. We implemented our design and evaluated it in a large-scale experiment using realistic genome dataset. The experiments demonstrate a promising prospect of deploying privacy-preserving SPQ systems. Our system will be made open source to the community at https://github. com/SPQ-EditDistance/code.</p><p>A Note on Security. The proposed approach in this paper faces the security concern raised by Feigenbaum et al. <ref type="bibr" target="#b23">[23]</ref>, since we rely on the two parties to locally compute their sketches using public hash functions with public randomness. To get around this issue, we adopted a weaker notion of security defined with respect to a modified ideal world execution (see Section 3.1), where, aside from the approximation outcome, the randomness used in constructing the sketches is also revealed. It remains an open question whether our approach is secure (or insecure) with respect to the standard definition of ideal world execution (where the randomness is not revealed).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">BACKGROUND</head><p>Genetic variations and SPQ. The human genome includes two complementary strands, with 3 billion DNA bases each. Each unit on the strand is a nucleotide (A, T, C or G). Between two randomlyselected individuals, over 99% of their nucleotides are identical, with the rest different due to genetic variations. The most common variation involves only a single nucleotide, which can be either a major allele "0", or a minor one "1". Such a variation is called Single Nucleotide Polymorphism (SNP). About 50 million nucleotides in human genome are marked as SNPs according to dbSNP <ref type="bibr" target="#b47">[47]</ref>, while two average individuals' genomes typically differ in 4-5 million variation sites.</p><p>The DNA data produced by the sequencer are in the form of a large number of short sequences, which are later assembled into a whole sequence by aligning each short sequence with a public reference genome. The differences between the sequence and the reference, including the nucleotide(s) changed, inserted or deleted at different genetic positions, are documented in a VCF (Variation Call Format) file. A genome-wide SPQ actually happens on the VCF representations of two genome sequences. Note that restricting the comparison to only a set of genetic markers for certain diseases often leads to inferior medical decisions, because, on the one hand, the state-of-the-art understanding of the association between diseases and genetic variations are dynamically improving, and on the other hand, many other variations, which are not part of the disease's genetic markers, could also affect a treatment decision (e.g., patients' reaction to a therapy, known as the pharmacogenomic markers <ref type="bibr" target="#b22">[22]</ref>).</p><p>Secure Computation. The goal of secure computation is to allow several parties to jointly compute a function over secret input data supplied by each party, without using a trusted third party. The theory of secure computation is able to offer a security guarantee as strong as what can be achieved with a trusted third party, i.e., absolutely no information leak beyond what can be inferred from the desired outcome of the function. Since its inception in early 1980s <ref type="bibr" target="#b53">[53,</ref><ref type="bibr" target="#b28">28]</ref>, many constructions have been proposed, reducing the security guarantee either to the certain computational hardness assumptions <ref type="bibr" target="#b54">[54,</ref><ref type="bibr" target="#b39">39]</ref>, to the dominance of honest participants <ref type="bibr" target="#b12">[12,</ref><ref type="bibr">8]</ref>, or to the availability of a source of correlated randomness <ref type="bibr" target="#b9">[9,</ref><ref type="bibr" target="#b10">10]</ref>. In this paper, our construction is built and tested with the garbled circuit protocol. More recently, many cryptographic <ref type="bibr" target="#b41">[41,</ref><ref type="bibr" target="#b36">36,</ref><ref type="bibr" target="#b46">46,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b55">55]</ref> and implementational <ref type="bibr" target="#b41">[41,</ref><ref type="bibr" target="#b30">30,</ref><ref type="bibr" target="#b40">40]</ref> optimizations have been proposed that significantly improve the state-of-the-art of garbled circuit protocols. Threat model. We focus on the honest-but-curious (a.k.a. semihonest) model, where the parties are trusted to always follow the protocol specification but would do arbitrary (efficient) side computation in an attempt to violating the security of the system. This model makes sense in many real-world applications as launching an instance of a secure computation protocol alone already requires substantial level of trust among the participants, e.g., through a mutual (but weaker flavor of) agreement. Given a honest-but-   <ref type="bibr" target="#b31">[31]</ref> give a highly efficient dual execution protocol that leaks only one extra bit of information in presence of fully malicious attackers, while many cryptographic techniques <ref type="bibr" target="#b35">[35,</ref><ref type="bibr" target="#b38">38,</ref><ref type="bibr" target="#b33">33,</ref><ref type="bibr" target="#b45">45,</ref><ref type="bibr" target="#b19">19,</ref><ref type="bibr" target="#b26">26]</ref> could be automated to strengthen semi-honest protocols to work with active adversaries.</p><p>Feigenbaum et al. <ref type="bibr" target="#b23">[23]</ref> studied the general problem of secure approximation. They pointed out that the standard definition of security might not be always achievable if a sketching algorithm is not fully executed using generic secure computation. The security of our approach relies on an additional assumption (which is also used by Lindell and Pinkas <ref type="bibr" target="#b37">[37]</ref>) that learning the randomness used by the sketch algorithm in addition to the approximation results does not provide non-negligible advantage to the adversary in breaking the system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">DESIGN AND IMPLEMENTATION</head><p>GENSETS consists of a highly accurate approximation of edit distance between human genomes (Section 3.2), efficient private set difference size protocols and an efficient private set difference size thresholding protocol (Section 3.3). We will also discuss genome-wide clustering and two-step secure SPQ infrastructure in Section 3.5. We begin our description with an high level overview.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Overview</head><p>The SPQ Primitive. GENSETS is built around primitive SPQ protocols based on secure edit distance, which is arguably one of the most important biological similarity indicators <ref type="bibr" target="#b49">[49]</ref>. The edit distance between sequences A and B is defined as the minimum number of edits (insertion, deletion, or substitution of a single character is counted as one edit) to change A into B. Edit distance computation over generic input sequences requires O(n 2 ) time, which does not scale well on large inputs such as human's whole genome sequences. Computing edit distance is especially challenging in the privacy-preserving setting: the state-of-the-art protocol computing the distance between two sequences of lengths only 2K and 10K in a Giga-bits LAN setting requires more than 3.5 hours and 38 GB of network traffic <ref type="bibr" target="#b30">[30]</ref>. This is also the largest problem instance that has ever been attempted in privacy-preserving setting thus far.</p><p>We propose several new secure protocols for edit distance. Our protocols are order-of-magnitude more efficient -20 seconds to securely compute (with an error rate of less than 1%) the edit distance between two whole-genomes (each containing roughly 3 billion bases) and merely 0.1 second to securely threshold (with reasonable false positive/negative rates) the edit distance between two whole-genomes. Our protocol does introduce errors, but only at very limited scale: we have shown through experiments that errors resulted from the secure edit distance protocol applied to real human genomes are within 0.25∼0.5% of the true values; while the false positive and false negative rate of our private edit distance thresholding protocol running on our realistic human genome dataset are within 0.01%.</p><p>Our high level idea is illustrated in Figure <ref type="figure" target="#fig_2">1</ref>. First, each party will agree on a public reference genome Ref and independently compress local genomes with respect to Ref (by recording the minimum sequence of edits to derive itself from Ref). As a toy example, given the public reference genome Ref to be GCACTGGCCTT, the genome sequence A=GCAATAGCCTTC can be denoted as a set A of operations, {(4, sub, A), (6, sub, A), (12, ins, C)}, i.e., the minimum edits to convert the sequence Ref into A. Due to the information redundancy in human genomes, this step can typically compress a genome string representation of about 3 billion base pairs into roughly 5 million edits (stored in a VCF file). The key insight is that the edit distance between two human genomes A and B can be approximated both efficiently and accurately, through comparing only the VCF file representation of their edits from a single common Ref. Note that in our simplified toy example, the set of edits (desirably) contains only single-character operations, while the VCF file for a real genome will contain multi-character operations. Section 3.2 will elaborate the detailed algorithm to handle these complications and an extensive, empirical study of the accuracy of this approximation applied to human genomes.</p><p>Once the sequence of edits in a VCF file is converted into a set of single-character edits, the edit distance of two genomes can be approximated by the size of the symmetric difference between the two sets of single-character edits associated with the two genomes. Note that for the purpose of handling whole-genomes, each singlecharacter-edit set typically contains 8∼10 million edits. This is, unfortunately, still a scale too large to be efficiently handled by existing private set difference protocols. To this end, we propose a highly efficient private set difference size protocol exploiting the idea of probabilistic sketches (Section 3.3). Additionally, observing that the most frequent computation in our SPQ application is actually comparing an edit distance to a threshold value, we introduce a secure set difference size thresholding protocol which runs another order-of-magnitude faster than (our already fast) private set difference size protocol. All these protocols related to private set difference size are generic and readily composable with other secure computation protocols, hence maybe of independent interest. Infrastructure. Built on top of the primitive is a secure SPQ infrastructure, as illustrated in Figure <ref type="figure" target="#fig_4">2</ref>. Consider that a physician makes an SPQ for her breast cancer patients across hundreds of hospitals. Before the query happens, each hospital can pre-processed their data, grouping its patients' DNA sequences into a few clusters. For each cluster, a synthesized sequence that represents the center of the cluster is generated to support the query.</p><p>With the pre-computed clusters, the whole SPQ happens in two stages. In the first stage, the querier (the physician's secure SPQ client) runs the secure SPQ primitive with each hospital who supplies just the cluster centers, in order to identify all the hospitals that could have the similar patients (i.e., has at least one cluster center close to the query). Then, the second stage could be launched between the querier and all candidate hospitals identified as a result of the first stage, to securely scan through all patients in these hospitals. Ideal World Execution. The notion of security offered by GENSETS is defined with respect to a relaxed variant of ideal world execution: upon receiving a query genome and a threshold t from the client and a list of genome strings from the database server, the trusted party generates a random string r and uses the approximation algorithm (described in Section 3.2) followed by applying a  sketching algorithm (described in Section 3.4) with random tape r to compute all matching genomes in the server's list, and send to the client both the matches and the random tape r. This security notion is weaker, comparing to that developed around the standard ideal world execution where r is not revealed. However, we argue that, in practice, the additional leakage as result of revealing r is highly limited, though it remains open to formally prove this leakage is negligible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Private Edit Distance Approximation</head><p>Our first key observation is that the actual input strings to the edit distance computation in the SPQ application are distributed in a very special way. For example, for any two un-related individuals, (1) much (&gt; 99.5%) of their DNA sequences are identical;</p><p>(2) most (&gt; 95%) of their edits (from the reference genome) occur at non-adjacent locations; (3) most (about 80 ∼ 90%) of the edits between their genomes are substitutions. We exploited these statistical features in designing an efficient (and also very accurate) approximation of edit distance between human genomes.</p><p>Secondly, we also observe that, assuming a public reference genome Ref, a significant portion of the computational task of private edit distance between any two human genomes can be moved into a pre-computable (and also amortizable) local preparation stage. Basically, each party pre-computes locally the minimum edits from Ref to their respective private genomes, and then launch a secure computation protocol to approximate edit distance just from the private edits.</p><p>Next, we present detailed approximation algorithms, followed by examples demonstrating why it works and when it does not.</p><p>The Algorithm. The protocol involves two parties, each having a private human genome as input. The whole approximation algorithm has three steps: Substitutes: Since substitutes are already defined with respect to a single character, no special treatment is needed to break them down.</p><p>3. The parties run a secure computation protocol to calculate the size of symmetric set difference between the two sets and output it as an approximation of the edit distance between the genomes. The symmetric set difference between sets A and B, denoted as Diff (A, B), is defined as</p><formula xml:id="formula_0">(A -B) ∪ (B -A).</formula><p>Note that the first two steps only involve the public Ref and one party's genome, hence accomplishable with relatively inexpensive local computation. Moreover, they are also amortizable in the sense that they need to be done only once in a preparation stage, no matter how many queries are to be serviced. Only the third step requires more expensive secure computation, whose design is detailed in the next two subsections. Fortunately, these types of "problematic" scenarios happen very rarely in practice, because on human genomes, most (90% of) edits obtained in step 1 are short edits (involving 1 ∼ 2 nucleotides and the more problematic long-string, overlapping inserts and deletes almost never happen. In order to establish enough confidence over our approximation algorithm, we report below a comprehensive  empirical study of comparing the end-results of our approximation with the ground truth distance values obtained from an edit distance implementation using dynamic programming, over genome snippets of various lengths.</p><p>Overall Accuracy. To understand the accuracy of this approximation, we computed edit distance between the genomes segments (each segment contains 8, 000 nucleotides) of two randomly selected individuals in dataset of the Personal Genome Project (PGP) <ref type="bibr" target="#b17">[17]</ref> and compared the values with those produced by the estimation algorithm above. We note that because rigorous dynamic programming is not practical for the global alignment of genomic sequences with millions of bases, a common practice in genome comparison is to first find long identically matched segments in the input genomic sequences, and then to chain the aligned segment into global alignment <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b13">13]</ref>. This is essentially approximating the global edit distance between two genome sequences by the sum of the edit distances between corresponding genome subsequences delineated by long identically matched segments. For comparing two human genomes with more than 99.5% identity, this sum-of-segment method should give the same edit distance as that computed by the rigorous dynamic programming algorithm. Therefore, in our experiment, we used the results of the sum-ofsegment method as the ground truth distance for the comparison with our approximation. Still, it took 365 hours to compute the edit distance for 6, 000 tests cases.</p><p>In each test, we split long segments into shorter subsequences of varying lengths (i.e., eight sequences of 1, 000 nucleotides, four sequences of 2, 000 nucleotides, and two sequences of 4, 000 nucleotides) and then calculated the true edit distance using dynamic programming algorithm and approximation edit distance using our algorithm on segments and their subsequences. In our experiments, we observe that the edit distance between two 8, 000-nucleotide sequences is always exactly the same as the sum of the two edit distance values over its two 4, 000-nucleotide components; and same observation applies to segments of length 4, 000 and 2, 000 as well. These results suggest that, over real world human genome data, edit distance between long sequences can be accurately computed from sum of distances on its (not too short) subsequences.</p><p>Based on the observation above, we studied the accuracy of our approximation algorithm on longer sequences (each contains 80 million nucleotides), by summing up distance values over 10, 000 random basic segments (each contains 8, 000 nucleotides). Our experimental results show that 99.13% of 10, 000 tests exhibited an error rate less than 0.5%, while all tests resulted in less than 1% error (Figure <ref type="figure" target="#fig_7">3</ref>). These results demonstrate the accuracy of our approximation algorithm on real human genome data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Private Set Difference Size</head><p>Our approximation algorithm above reduces a private human genome edit distance problem to a private set difference size problem. Next, we will describe a basic protocol for private set difference size, and present in Section 3.4 three variations of the basic protocol each best suited for certain scenarios. Problem Definition. Given two secret sets A and B, output |Diff (A, B)| without revealing anything else about A and B. In particular, in the context of our private edit distance approximation scheme, we hope to efficiently handle sets of 5 ∼ 10 million elements, with accuracy comparable to that of the original approximation algorithm discussed above. One may attempt to first securely compute the set intersection of A and B using a Bloom Filter <ref type="bibr" target="#b20">[20,</ref><ref type="bibr" target="#b14">14]</ref> then securely count the number of elements in the intersection and infer the size of set difference. One could even leverage a Bloom Filter cardinality estimator <ref type="bibr" target="#b48">[48]</ref> to save the expensive secure counting phase. Alternatively, one may even construct a secure version of the Count-Min sketch <ref type="bibr" target="#b18">[18]</ref> or Hyper-Loglog <ref type="bibr" target="#b25">[25]</ref> to directly estimate the intersection size without using a Bloom Filter. However, these solutions do not work in practice for SPQ because the error introduced in estimating the intersection size needs be multiplied |A ∩ B|/Diff (A, B) times when it comes to describing the relative error in estimating set difference size. In SPQ, the most interesting data points (which indicates matching patients) actually fall into the category where |A ∩ B|/Diff (A, B) is very large. Tuning up the parameters (which grow at a rate of O(1/ε) to O(1/ε 2 ) where ε is the error rate) of these intersection size estimators to achieve reasonably small error relative to set difference size will degrade SPQ performance to an unusable level.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Some Strawman</head><p>A Basic Solution. We propose highly efficient and accurate protocols that directly compute set difference size. For the purpose of illustration, we first present a basic solution (Figure <ref type="figure" target="#fig_10">4</ref>), from which the more efficient variants are later derived.</p><p>Inspired by the seminal work by Alon et al. <ref type="bibr" target="#b2">[2]</ref> and Feigenbaum et al. <ref type="bibr" target="#b24">[24]</ref>, the basic idea is to first "compress" every input set, say S, into a single integer dS, using a binary hash function h : U → {-1, 1}, where U denotes the universe of all set elements. More concretely, dS is defined to be s∈S h(s). Assuming h can be randomly sampled from a family of pairwise independent binary hash functions, so for any element s, s1, s2 (s1 = s2) and a randomly sampled h, it is easy to see that E[h(s)] = 0, E[h 2 (s)] = 1, and E[h(s1)h(s2)] = E[h(s1)] • E[h(s2)] = 0, with all probabilities taken over the randomness in sampling h. Thus, for any set S,</p><formula xml:id="formula_1">E d 2 S = E s∈S h(s) 2 = E   s∈S h 2 (s) + 2 • s 1 =s 2 h(s1)h(s2)   = E s∈S h 2 (s) = |S|.</formula><p>Let dA, dB be the sketch integers computed from the two private input sets A and B, respectively. If we further assume the family of hash functions are four-wise independent (namely, for all distinct s1, s2, s3, s4,  Therefore,</p><formula xml:id="formula_2">E[h(s1)h(s2)h(s3)h(s4)] = E[h(s1)]E[h(s2)]E[h(s3)]E[h(s4)]), then we can show that E (dA -dB) 2 = |Diff (A, B)|. This is because dA -dB = s∈A h(s) - s∈B h(s) = s∈A-B h(s) - s∈B-A h(s).</formula><formula xml:id="formula_3">E (dA -dB) 2 = E s∈A-B h(s) 2 + s∈B-A h(s) 2 +2 • s 1 ∈A-B h(s1) • s 2 ∈B-A h(s2) = |A -B| + |B -A| + 2 • 0 = |Diff (A, B)|.</formula><p>To efficiently bound the error, our basic protocol estimates Diff (A, B) by computing the k-median of -mean of random sampling of (dA -dB) </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PROOF. See the proof in Appendix A.</head><p>Cost Analysis. In this basic protocol, Step 1(a)i and Step 1(a)ii can be done locally without expensive secure computation. Both steps are executed k times, while the cost of Step 1(a)ii also grows linearly with the size of the set. Note that for a whole-genome, the size of set A (or B) will be 5 ∼ 10 million. Also taking the factor k (whose exact value depends on the accuracy needed) into account, the cost of the local hashing step can be substantial. In Section 3.4, we give several techniques to reduce this cost.</p><p>Expensive secure computation is required only at three places (i.e., the Step 1(a)iii, 1b and 2), of which the Step 1(a)iii dominates the cost. If dA and dB are ω-bit integers, then overall, it incurs k ω-bit subtractions, k ω-bit integer squaring, 2ω-bit additions, and one secure median of k 2ω-bit integers. Thus, while the dominant cost comes from secure squaring, the overall cost of secure computation also highly depends on the integer bit length ω. Hashing. A 4-wise universal hash function can be generated by picking a random polynomial modulo a large prime. This, however, requires many multiplication operations per element. Therefore, we customized murmurHash64 (by leaving out several instructions that don't affect the accuracy of our approximation algorithm) (d) A and B run a secure computation protocol to securely compute</p><formula xml:id="formula_4">D j = i=1 (d A [i] -d B [i]) 2 2.</formula><p>A and B use a secure computation protocol to securely compute the median and used it in our prototype. In addition, our implementation fully utilizes all 64 bits of the hash result to compute 64 dA(dB)s at the same time.</p><formula xml:id="formula_5">Z of D 1 , • • • , D k . Output Z.</formula><p>Oblivious Transfer. When this protocol is actually deployed between hospital servers and health professional querier clients, the querier provides only one genome sketch per query while a hospital would need to provide thousands of private genome sketches per query. We take advantage of this asymmetry by setting up the hospital to be the garbled circuit generator so that only the querier's short inputs needs to be oblivious transferred in each query.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Optimized Protocols</head><p>Although our basic protocol above already outperforms the strawman solutions, there is ample design space to explore to further improve efficiency and accuracy. Next, we present a few interesting optimizations that aim to reduce the cost of local hashing and secure computation, while retaining accuracy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.1">Protocol 1</head><p>Inspired by the work of Thorup and Zhang on tabulating hashes in second moment estimation <ref type="bibr" target="#b50">[50]</ref>, we improve the basic private set difference size protocol through random bucketing. The full protocol is given in Figure <ref type="figure" target="#fig_13">5</ref>. The basic idea is to require each party to associate every set element s with one single (out of in total) bucket, according to a hash of s, namely g(s) in Figure <ref type="figure" target="#fig_13">5</ref>; and then estimate the number of elements in Diff (A, B) falling in each bucket simply with (dA[i] -dB[i]) 2 , and finally sum the numbers up. Like in the basic protocol, the median function is also used to bound the estimation error. Now it involves only a single loop of k iterations, and in each iteration an element will be hashed only once. The key observation is that although an -times coarser estimator is used to measure the size of each bucket (hence saving a factor of hashes), the variance of (dA[i] -dB[i]) 2 is actually -times smaller thanks to bucketing. Thus, it achieves the same level of accuracy with -times less hashing compared to the basic protocol.  PROOF. See the proof in Appendix C.</p><p>Remark. The benefits of randomized bucketing actually go beyond reducing the number of local hashes. Since the number of times the accumulators dA[i] and dB[i] are incremented is reduced by times, the number of bits (ω) in dA[i], dB[i] is then reduced by log , which saves substantial cost (30 ∼ 40%) in the secure computation stage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.2">Protocol 2</head><p>As is mentioned earlier, secure squaring accounts for the dominant cost of the secure computation part of the protocol. Fortunately, under an extra assumption that (dA -dB) is very close to normal distribution, it can be shown that E(|dA -dB|) = σ 2/π (where <ref type="bibr" target="#b3">[3]</ref>. Thus, measuring E(|dA -dB|) suffices to provide a good estimation of E (dA -dB) 2 . Because dA -dB is a binomial distribution, it is indeed very close to normal distribution as the set difference sizes observed in our genomic SPQ application all turn out much larger than 10,000.</p><formula xml:id="formula_6">σ 2 = E (dA -dB) 2 -(E[|dA -dB|]) 2 ) be- cause |dA -dB| is a half-normal distribution</formula><p>Figure <ref type="figure" target="#fig_15">6</ref> describes the improved protocol based on this observation (and the extra assumption that the size of set difference is not too small). The protocol resembles that of the basic protocol except for two changes highlighted with double-underlines in Step 1(a)iii and Step 2. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PROOF. See the proof in Appendix C.</head><p>We remark that it is unclear whether it is possible to harvest the savings by combining both ideas in one protocol, as the two optimizations are not compatible when trivially combined. To see the reason, imagine a third protocol randomly places set elements in buckets and attempts to use non-squaring approach to estimate the number of difference elements in each bucket. Because the number of elements in each bucket needs to be kept secret, the squaring operation of Step 2 in Protocol 2 needs to be done securely. Note that this per bucket squaring can't be simply moved to the end because for E k i=1 Zi 2 (where Zi is obtained for the i-th bucket) to be equal to Diff (A, B), Zi's need to be at least pairwise independent. However, this is not the case as each element was hashed into one and only one (out of ) bucket.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.3">Thresholding private set difference size</head><p>Although the protocols above are able to securely approximate the size of set difference with arbitrary precision, the key primitive that fits best with a secure SPQ system (such as PatientLikeMe) is actually comparing the set difference size with a given threshold, producing merely 1-bit output. In fact, thresholding the difference size is more desirable because it limits the potential information leak through output. A private set difference size protocol can be trivially extended to provide the secure thresholding primitive. However, it is worth noting that secure thresholding protocols generally result in much less error compared to the corresponding private set difference size protocols from which they are derived, due to a difference in the notion of error: 1% error in the size of set difference implies the estimated value is 1% away from the true value; while 1% error in thresholding the size actually means the chance to arrive at a wrong decision is 1%. As a result, smaller parameters (k, values) suffice to achieve the same level of accuracy. We have done extensive experiments to evaluate the performance and accuracy of secure thresholding protocols (see Section 4.1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">SPQ Infrastructure</head><p>Based on the secure SPQ primitive described above, we implemented a prototype infrastructure to support a secure SPQ over a large amount of data across multiple institutions. Such an infrastructure could be improved to work in a practical scenario where hundreds of thousands of genomes (associated with a particular disease, e.g., the breast cancer) collected by hundreds of hospitals are scanned to find those genetically similar to the patient in the query. To make this operation efficient at large scales, we design a data pre-processing mechanism for each hospital to organize its patient data into clusters.</p><p>Clustering. We leverage the complete-linkage hierarchical clustering algorithm <ref type="bibr" target="#b34">[34]</ref> (other more sophisticated algorithms can also be plugged into our infrastructure) to cluster patient genomes based on our edit distance approximation (Section 3.2). Note that the notion of clusters here does not necessarily match up with a known pathological categorization. In each cluster, a synthesized sequence, called representative, is generated. Let δ be the radius of each cluster, and be the threshold used to identify similar patients. Due to the triangular property of edit distance, if a patient P in a cluster C is considered similar to the querier's patient Q, then the distance between Q and the representative of C should be no more than δ + ε. Two-stage search. With these pre-computed clusters, a SPQ search will be performed in two stages (Figure <ref type="figure" target="#fig_4">2</ref>):</p><p>1. Compare the edit distance between the query genome and each cluster representative with threshold δ + ε using a se-cure thresholding scheme: if the distance is below the threshold, the hospital owning this cluster will be selected for the second stage search. 2. Compare the edit distance between the query genome and each patient in every selected hospital with threshold ε using a secure thresholding scheme: if the distance is below the threshold, the pseudo-identifier of the patient will be returned.</p><p>In the particular case of SPQ, ε is chosen to be much smaller than the edit distance between two random patients within the same cluster, i.e., ε δ. This allows us to use δ as the threshold for the first stage search to efficiently eliminate clusters that contain no patients similar to the query. Note that for a query involving a similar patient a in cluster A, the distance between the query genome and the representative of any other cluster is unlikely below δ + ε (as ε δ) unless the query genome (and its similar patient) is close to the border of the cluster.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">EVALUATION</head><p>In this section, we present experimental evaluation of both accuracy and efficiency of GENSETS.</p><p>System and network. Unless explicitly specified otherwise, all experiments were performed between two machines located more than 2000 miles apart (one in Bloomington, Indiana and the other in San Diego, California). The bandwidth is about 100Mbps with variations. We run the garbled circuit and oblivious transfer protocols using a single thread. We exploited multi-core parallelism to compute the amortizable precomputed hashing phase of sketch construction.</p><p>The implementation of the garbled circuit protocol leverages half-gate garbling <ref type="bibr" target="#b55">[55]</ref> and free-XOR technique <ref type="bibr" target="#b36">[36]</ref>. The oblivious transfer is implemented using NPOT <ref type="bibr" target="#b42">[42]</ref> with OT extension <ref type="bibr" target="#b32">[32]</ref> of Ishai et al.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Metrics.</head><p>In our evaluation, we use the following metrics to measure the accuracy and efficiency of our approach.</p><p>1. False positive/negative rate. A false positive refers to the event that a patient dissimilar to the query is returned; while a false negative happens when a similar patient is not returned. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Thresholding Private Set Difference Size</head><p>Private set difference size thresholding protocols are the core SPQ primitive that enables GENSETS. Figure <ref type="figure">7</ref> and Figure <ref type="figure">8</ref> show the performance of our thresholding protocols running over breast cancer patients' genomes (each of which is represented by a VCF file of roughly 150K variations). The private edit distance protocol is reduced to thresholding the set difference size of two sets, each containing 200K ∼ 300K single-character edits.</p><p>We observe that the accuracy achieved is generally proportional to the value of kl (at least when the difference in k is small). Also note the asymmetry of errors in the range around the threshold. For instance, comparing the columns d = 0.9t and d = 1.1t, the false negative rates (on columns with d &lt; t) is always smaller than the false positive rates (on columns with d &gt; t) on their mirroring columns. This would be desirable in SPQ search as the users are usually more sensitive on false negatives (i.e., similar patients are overlooked) while tending to tolerate false positives (irrelevant patients are returned). Last, note that protocol 1 and 2 performs comparably in thresholding the set difference size, except that protocol 2 is about 30% faster, while protocol 1 is slightly better in terms of accuracy.</p><p>In our particular application of secure SPQ, we assume there are 250 hospitals, each of which keeps 4000 patients records organized in 8 clusters. The first stage would check a total of 250 × 8 = 2000 clusters. Assuming at most 5 hospitals will be selected as candidates to proceed in the second stage search, which amounts to searching through all 4000 × 5 = 20000 patients in these 5 hospitals. Since cluster centers have the same representation as patient genomes, the performance of the entire search for similar breast cancer patients is equivalent to checking 22000 patients. Using protocol 2 with parameter k = 5, = 512, 22000 edit-distance comparison can be accomplished within 183 minutes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Private Set Difference Size</head><p>In an SPQ scenario, calculating the set difference size with high precision is mostly unnecessary. However, once a similar patient is found, it may be worthwhile to calculate the edit distance with high accuracy to confirm the match. Moreover, many other personal genomic applications (such as genetic diagnosis and medical treatment risk prediction) may find it useful to be able to precisely estimate edit distance in a privacy-preserving way.</p><p>Figure <ref type="figure">9</ref> shows the performance of Protocol 1 and Protocol 2 used in private set difference size estimation scenario. For each protocol, we report the cost to bound 90%-percentile error rate to 1% and 0.5%, respectively. This means that for 90% of the test cases, the relative error is less than or equal to 1% or 0.5% respectively. The results show that the protocols runs significantly slower than private set difference size thresholding protocols. However, since the number of similar patients returned in the final stage is usually quite low (typically less than 10), users can afford much more time per candidate patients for obtaining an accurate distance.</p><p>Note that, thanks to the optimized configuration of the OT protocol (Section 3.3), the cost of OT is independent of number of patients on the hospital server. Therefore, the total running time to query n patients can be calculated as TimeTotal = TimeOT + n × (TimeLocal + TimeGC) .</p><p>It is easy to verify that the total times reported in the figure conforms to the formula above with n = 10.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Experiments on Whole Genomes</head><p>We have also measured the performance of our protocols over whole-genomes obtained from the PGP project. Figure <ref type="figure" target="#fig_17">10</ref> shows the total running time of our approach on whole genomes. First we find that the timings for whole genome data are about 4 ∼ 5 times slower than those of breast cancer tests, because the genomes considered in breast cancer tests are only a fraction (1/40) of whole genomes. The primary cause of the slowdown is the increased cost of garbled circuit generation and evaluation, since the bit length ω of the sums of the hashes is increased by a factor of around log 40 ≈ 5.3). Secondarily, the local hashing and oblivious transfer, whose costs grow linear with the length of the input genomes, are 40 times more expensive. to jointly combine the sketches. Feigenbaum et al. pointed out that it is unclear how to prove it secure if secure computation protocol is not used to compute the sketches, (although no actual attacks are identified). We get around this issue by relaxing the security definition to allow revealing the randomness used in the sketch computation in the ideal world execution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">RELATED WORK</head><p>Privacy-preserving Genome Analysis. Researchers proposed solutions to privately compare two genomes, either using a private set intersection (PSI) protocol <ref type="bibr" target="#b6">[6]</ref>, or a private set intersection size protocol <ref type="bibr" target="#b15">[15]</ref>. These works, however, modeled the similarity by Hamming distance between genomes and could only handle relatively short genome snippets. In contrast, our work targets at the more challenging (and also generally more useful) edit distance protocol applied to people's whole-genomes. In addition, the private set difference size protocol runs many orders of magnitude faster than those derived from the state-of-the-art PSI or PSI size protocols.</p><p>Streaming Algorithms. Streaming algorithms, introduced by the groundbreaking work of Alon et al. <ref type="bibr" target="#b2">[2]</ref>, aim to significantly improve the (space, communication, and time) efficiency of problem solutions by tolerating a (controlled) small error. We borrowed many useful ideas from streaming algorithms research in designing the private set difference size protocols. However, different from the existing research on streaming algorithm, we studied the problem in secure computation setting, thus exploring the design space under a different set of goals, e.g., efficient joint computation versus small working space and low plaintext communication.</p><p>Approximating Edit Distance Quite a few researchers have considered approximating edit distance for general input strings, particularly in the streaming setting <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b7">7]</ref>. However, the best algorithms still incur significant error (such as a factor of √ n where n is the length of the input string), which renders them inapplicable in practice. In addition, none of the existing work considers the cost of executing the sketch combining phase with secure computation protocols.</p><p>Approximating Set Difference Size. Feigenbaum et al. <ref type="bibr" target="#b24">[24]</ref> proposed an efficient algorithm to compute L-1 norm. But their work considers the streaming setting and is general enough to compute weighted L-1 norm over multi-sets. Our basic protocol in Section 3.3 was inspired by their work, but is highly customized towards solving the privacy-preserving SPQ problem. For example, we avoided algebraic computations over finite fields required in their construction. Several other works <ref type="bibr" target="#b27">[27,</ref><ref type="bibr" target="#b43">43]</ref> have further improved the update time of this scheme, but still only considering the classic streaming model.</p><p>Using invertible bloom filter based approximation, Eppstein et al. <ref type="bibr" target="#b21">[21]</ref>   (in terms of sketch size), their algorithm is more expensive in the secure computation model (because their construction focused on minimizing the size of the sketch while ours aims at reducing the cost of joint computation).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSION</head><p>Securely computing edit distance between human wholegenomes promises many interesting applications of personal genomic data in medical and public health domains. We described novel techniques that is able to approximate edit distance on human genomes with unprecedented efficiency and accuracy. Based on the primitives we proposed, we implemented and evaluated GENSETS, a genome-wide secure SPQ system. The performance of SPQ demonstrated in our experiments with realistic genomic data and network setting shows that we have made a big step towards privacy-preserving SPQ at the national scale.</p><p>PROOF. In the i-th iteration, let Yij be the random variable indicator for event g(j) = i. We can rewrite dA[i] = s∈A Yish(s) and that dB[i] = s∈B Yish(s). Define h (s) to be h(s) for every s ∈ A-B, and -h(s) for every s ∈ B-A.  ). Therefore, for any ε &gt; 0, λ &gt; 1, by selecting an ε such that (1 + ) 2 &lt; 1 + ε we can find k, to ensure P r |R 2 -ε| ≤ εd ≥ 2 -λ .</p><formula xml:id="formula_7">s 1 =s 2 h (s1) 2 h (s2) 2 Y 2 is 1 Y 2 is 2   = E s∈∆ h (s) 4 Y 4 is + 3 s∈∆ h (s) 2 Y 2</formula></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>15 ,</head><label>15</label><figDesc>October 12-16, 2015, Denver, CO, USA c 2015 ACM. ISBN 978-1-4503-3832-5/15/10 ...$15.00. DOI: http://dx.doi.org/10.1145/2810103.2813725.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>sub, 'A'), (10, ins, 'A'), (12, ins, 'C')} |Diff (A, B)| = ? |Diff (A, B)| t ? &gt; Compress genome sequences into sets using a public Ref genome[Section 3.2] Private comparison of sets Private set difference size [Section 3.4] Threshold of private set difference size [Section 3.4]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Secure protocols of human-genome edit distances</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Two-stage secure SPQ with local clustering. Based on (weighted) edit distance metric, every hospital organizes their patients records in clusters. The first stage employs a secure SPQ primitive protocol to compare the querier's genome with every cluster center, in order to identify candidate hospitals that could have a similar patient. The second stage securely search through all patients in the candidate hospitals to identify all genetically similar individuals.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>1 .</head><label>1</label><figDesc>Each party calculates the minimum edit sequences from Ref to their own genomes. (In practice, edits of one genome (also known as variations) are stored in a VCF file.) 2. Each party computes a set of single-character edits from the minimum edit sequence associated with their private genome. Namely, every multi-character edit e = (pos, op, aux ) (where pos is the location of the edit, op is the type (either insert, delete, or substitute) of the edits, and aux represents operation-specific editing information) is decomposed into single-character edits as follows: Inserts: Inserting a string c1 . . . cn at location loc, denoted as (loc, ins, c1 . . . cn), is translated into (loc, ins, 1, c1), (loc, ins, 2, c2), • • • , (loc, ins, n, cn). Deletes: Deleting a string of length n at location loc, denoted as (loc, del , n), is translated into (loc, del , 1), (loc+1, del , 1), • • • , (loc+n-1, del , 1).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Examples. Suppose Ref = ATTGCCCGA, A = GTTGGA, B = GTTCGA. The minimum edits to convert Ref to A is {(1, sub, G), (5, del , 3)}, and to convert Ref to B is {(1, sub, G), (4, del , 3)}. Breaking down the edits into single-character edits, the two parties can respectively obtain set A = {(1, sub, G), (5, del , 1), (6, del , 1), (7, del , 1)} and set B = {(1, sub, G), (4, del , 1), (5, del , 1), (6, del , 1)}. Therefore,|Diff (A , B )| = 1, which coincides with the edit distance between A and B. Of course, there are cases our algorithm doesn't approximate very well. For instance, let Ref = ATTGCCCGA, A = GTTGGATAA, B = GTTCGATGA. In this case, the minimal sets of edits to obtain A and B from Ref are {(1, sub, G), (4, ins, C), (5, del , 1), (6, sub, A), (7, sub, T)} and {(1, sub, G), (5, sub, G), (6, sub, A), (7, sub, T), (8, sub, A)}, respectively. As A and B are already sets of single-character edits, it is obvious that |Diff (A, B)| = 4, whereas the actual edit distance between A and B is 2. The error is caused when comparing the 4th and 5th character of A and B-while CG can be converted to GG with just a single sub operation, the approximation algorithm essentially accounts it 3 times, namely, (4, sub, C) and (5, del , 1) for A and (5, sub, G) for B, because they were derived from Ref in different ways.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Accuracy of Approximation algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>Solutions. Since |Diff (A, B)| = |A| + |B| -2 • |A ∩ B| where |A| and |B| (the sizes of A and B) are not secret, |Diff (A, B)| could be derived from |A ∩ B|.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>1 .</head><label>1</label><figDesc>of A: a set A. Input of B: a set B. Public Input: a (sufficiently long) common random string Output: |Diff (A, B)| For j from 1 to k (a) For i from 1 to i. A and B use the (same) random string to randomly pick a function h from the family of hash functions. ii. A computes d A = s∈A h(s), whereas B computes d B = s∈B h(s), independently. iii. A and B run a secure computation protocol with respective private inputs d A and d B , to compute D i = (d A -d B ) 2 . (b) A and B securely compute Dj = i D i / . 2. A and B securely compute the median Z of D1 , • • • , Dk . Output Z.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: The basic protocol to approximate set difference size.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>2 .THEOREM 0 .</head><label>20</label><figDesc>For any two sets A, B, let d = |Diff (A, B)| and X be the output of the Basic Protocol running with A, B. Then for any positive ε and any positive integer λ, the inequality P r {|X -d| ≥ εd} ≤ 2 -λ can be achieved by setting = O(1/ε 2 ), k = O(λ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Protocol 1 Input</head><label>1</label><figDesc>of A: a set A. Input of B: a set B. Public Input: a (sufficiently long) common random string Output: |Diff (A, B)|. 1. For j from 1 to k (a) A and B use the public common random string to randomly sample a hash function h : U → {-1, 1} and a hash function g : U → {1, 2, • • • , }. (b) A and B initialize arrays d A and d B (each of length , respectively, to all zeros. (c) A computes d A [g(s)] := d A [g(s)] + h(s) for every s ∈ A; while B computes d B [g(s)] := d B [g(s)]+h(s) for every s ∈ B.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Faster private set difference size through bucketing.U denotes the universe of all set elements.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>THEOREM 1 .</head><label>1</label><figDesc>For any two sets A, B, let d = |Diff (A, B)| and X be the output of Protocol 1 running with A, B. Then for any Protocol 2 Input of A: a set A. Input of B: a set B. Public Input: a (sufficiently long) common random string Output: |Diff (A, B)|. 1. For j from 1 to k (a) For i from 1 to i. A and B use the (same) random string to randomly pick a function h from the family of hash functions. ii. A computes d A = s∈A h(s), whereas B computes d B = s∈B h(s), independently. iii. Party A and B run a secure computation protocol with inputs d A and d B , respectively, to compute D i = π/2 • |d A -d B |. (b) A and B securely compute Dj = i D i / . 2. A and B securely compute the median Z of D1 , • • • , Dk . Output Z 2 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Faster set difference size without secure squaring.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>THEOREM 2 .</head><label>2</label><figDesc>For any two sets A, B, let d = |Diff (A, B)| and X be the output of Protocol 2 running with A, B. Then for any positive ε and any positive integer λ, the inequality P r {|X -d| ≤ εd} ≥ 2 -λ can be achieved by setting = O(1/ε 2 ), k = O(λ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Running Protocol 1 and 2 on whole genomes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>= 4</head><label>4</label><figDesc>Let di = dA[i]-dB[i] and define ∆ = Diff (A, B). Therefore di = s∈Diff (A,B) Yish (s) = s∈∆ Yish (s)Next, we calculate the expectation and variance of d 2 i . is h (s) 4 + 3</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>d 2 - d = 3 d 2 - 2 d</head><label>222</label><figDesc>Thus we have E[Di] = E[di] = d, Var [Di] = Var [di] = ×(E[d 2 i ]-E[di] 2 ) ≤ 2d 2. Applying Chebyshev's and Chernoff's inequalities similar to Appendix A finishes the rest of the proof.C. PROOF OF THEOREM 2PROOF. If a random variable X ∼ N (0, σ 2 ) (where N (0, σ 2 ) denotes a normal distribution with expectation 0 and variance σ 2 ), then Y = |X| follows half normal distribution, and further we knowE[Y ] = σ 2/π, and Var [Y ] = σ 2 (1 -2/π).In protocol 2, assuming dA -dB can be approximated by N (0, d), the estimator for√ d is Di = π/2|dA -dB|, because E[Di] = √ d, Var [Di] = (π 2 -2π)d/4 &lt; d.With similar argument in the proof of Theorem 0 using Chebyshev's and Chernoff's inequalities, we can show that for any &gt; 0, λ &gt; 1,Pr (1 -) √ d ≤ R ≤ (1 + ) √ d ≥ 2 -λ .can be achieved with k = O(log(1/δ)), and = O(1/ 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>2. Error rate. Error rate measures the accuracy of private set difference size protocols. It is defined to be |u-v|/u where u denotes the true size and v is what the secure protocol outputs. 3. Number of AND gates. With garbled circuit protocol, the main cost grows linearly with the number of AND gates in the circuit. 4. Wall-clock time. This is the total elapsed time of a task.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Secure Approximation. Feigenbaum et al.<ref type="bibr" target="#b23">[23]</ref> first considered the problem of secure approximation. Generally a streaming algorithm consists of phases to locally compute the sketches and those Thresholding set difference size using extended protocol 1. (using breast cancer patients' genome) When k = 3, = 256, given a threshold t, this algorithm achieves a false negative rate of 0.03% if the set difference size is 0.9t; and achieves a false positive rate of 0.06% if the set difference size is 1.1t.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Set Difference Siz (d)</cell><cell></cell><cell></cell><cell></cell><cell>1000 Patients</cell></row><row><cell>k</cell><cell></cell><cell>0.7t</cell><cell>0.8t</cell><cell>0.9t</cell><cell>0.95t</cell><cell>1.05t</cell><cell>1.1t</cell><cell>1.2t</cell><cell>1.3t</cell><cell>Running time Bandwidth</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="3">False negative rate</cell><cell cols="3">False positive rate</cell><cell></cell></row><row><cell></cell><cell cols="9">32 0.01% 0.06% 0.22% 0.33% 0.43% 0.33% 0.17% 0.09%</cell><cell>47.13s</cell><cell>0.17GB</cell></row><row><cell></cell><cell>64</cell><cell cols="4">0.0% 0.02% 0.15% 0.3%</cell><cell cols="4">0.37% 0.24% 0.08% 0.02%</cell><cell>59.84s</cell><cell>0.34GB</cell></row><row><cell>3</cell><cell cols="2">128 0.0%</cell><cell cols="7">0.0% 0.09% 0.24% 0.31% 0.15% 0.02% 0.0%</cell><cell>92.96s</cell><cell>0.67GB</cell></row><row><cell></cell><cell cols="2">256 0.0%</cell><cell cols="6">0.0% 0.03% 0.18% 0.22% 0.06% 0.0%</cell><cell>0.0%</cell><cell>165.57s</cell><cell>1.35GB</cell></row><row><cell></cell><cell cols="2">512 0.0%</cell><cell cols="3">0.0% 0.01% 0.1%</cell><cell cols="3">0.12% 0.01% 0.0%</cell><cell>0.0%</cell><cell>304.16s</cell><cell>2.69GB</cell></row><row><cell></cell><cell>32</cell><cell cols="8">0.0% 0.03% 0.17% 0.29% 0.42% 0.29% 0.12% 0.04%</cell><cell>54.78s</cell><cell>0.29GB</cell></row><row><cell></cell><cell>64</cell><cell cols="8">0.0% 0.01% 0.1% 0.25% 0.35% 0.19% 0.04% 0.0%</cell><cell>80.25s</cell><cell>0.57GB</cell></row><row><cell>5</cell><cell cols="2">128 0.0%</cell><cell cols="3">0.0% 0.05% 0.2%</cell><cell cols="4">0.25% 0.09% 0.01% 0.0%</cell><cell>173.34s</cell><cell>1.13GB</cell></row><row><cell></cell><cell cols="2">256 0.0%</cell><cell cols="6">0.0% 0.01% 0.12% 0.16% 0.03% 0.0%</cell><cell>0.0%</cell><cell>244.81s</cell><cell>2.25GB</cell></row><row><cell></cell><cell cols="2">512 0.0%</cell><cell>0.0%</cell><cell cols="4">0.0% 0.05% 0.08% 0.0%</cell><cell>0.0%</cell><cell>0.0%</cell><cell>596.79s</cell><cell>4.49GB</cell></row><row><cell>Figure 7: k</cell><cell></cell><cell>0.7t</cell><cell>0.8t</cell><cell>0.9t</cell><cell cols="2">Set Difference Size (d) 0.95t 1.05t</cell><cell>1.1t</cell><cell>1.2t</cell><cell>1.3t</cell><cell>1000 Patients Running time Bandwidth</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="3">False negative rate</cell><cell cols="3">False positive rate</cell><cell></cell></row><row><cell></cell><cell cols="9">32 0.02% 0.09% 0.26% 0.38% 0.41% 0.32% 0.17% 0.08%</cell><cell>31.7s</cell><cell>0.11GB</cell></row><row><cell></cell><cell>64</cell><cell cols="8">0.0% 0.03% 0.19% 0.33% 0.36% 0.24% 0.09% 0.02%</cell><cell>44.05s</cell><cell>0.22GB</cell></row><row><cell>3</cell><cell cols="5">128 0.0% 0.01% 0.12% 0.27%</cell><cell cols="4">0.3% 0.16% 0.02% 0.0%</cell><cell>66.26s</cell><cell>0.44GB</cell></row><row><cell></cell><cell cols="2">256 0.0%</cell><cell cols="3">0.0% 0.04% 0.2%</cell><cell cols="3">0.23% 0.07% 0.0%</cell><cell>0.0%</cell><cell>131.98s</cell><cell>0.96GB</cell></row><row><cell></cell><cell cols="2">512 0.0%</cell><cell cols="6">0.0% 0.01% 0.12% 0.14% 0.02% 0.0%</cell><cell>0.0%</cell><cell>226.2s</cell><cell>1.75GB</cell></row><row><cell></cell><cell>32</cell><cell cols="8">0.0% 0.05% 0.21% 0.34% 0.38% 0.27% 0.11% 0.04%</cell><cell>43.06s</cell><cell>0.21GB</cell></row><row><cell></cell><cell>64</cell><cell cols="8">0.0% 0.01% 0.13% 0.28% 0.33% 0.19% 0.04% 0.01%</cell><cell>62.83s</cell><cell>0.37GB</cell></row><row><cell>5</cell><cell cols="2">128 0.0%</cell><cell cols="7">0.0% 0.06% 0.21% 0.27% 0.1% 0.01% 0.0%</cell><cell>99.89s</cell><cell>0.73GB</cell></row><row><cell></cell><cell cols="2">256 0.0%</cell><cell cols="6">0.0% 0.02% 0.15% 0.17% 0.03% 0.0%</cell><cell>0.0%</cell><cell>224.96s</cell><cell>1.6GB</cell></row><row><cell></cell><cell cols="2">512 0.0%</cell><cell>0.0%</cell><cell cols="4">0.0% 0.07% 0.09% 0.0%</cell><cell>0.0%</cell><cell>0.0%</cell><cell>497.51s</cell><cell>3.2GB</cell></row><row><cell></cell><cell cols="10">Figure 8: Thresholding set difference size using extended Protocol 2. (using breast cancer patients' genome)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>proposed protocols to reconstruct set difference and estimate set difference size. Although their set difference size approximation algorithm achieved a similar asymptotic error bound Figure9: Private set difference size using Protocol 1 and Protocol 2. (using breast cancer patients' genomes) The cost of oblivious transfer is per query, as it is setup so that their costs are independent of the number of patients in server's dataset (see Section 3.3).</figDesc><table><row><cell>k</cell><cell></cell><cell>90%</cell><cell cols="5">Oblivious Local Hash GC time #AND gates Bandwidth Transfer / patient / patient / patient / patient</cell><cell>Total time / 10 patients</cell></row><row><cell cols="3">Protocol 1 5 8192 1.4%</cell><cell>5.83s</cell><cell>0.01s</cell><cell>9.43s</cell><cell>3851.0K</cell><cell>73.44MB</cell><cell>95.1s</cell></row><row><cell cols="3">Protocol 1 5 16384 1.0%</cell><cell>9.18s</cell><cell>0.01s</cell><cell>18.98s</cell><cell>7701.0K</cell><cell>146.88MB</cell><cell>199.08s</cell></row><row><cell cols="3">Protocol 1 5 65535 0.5%</cell><cell>42.06s</cell><cell>0.01s</cell><cell>71.4s</cell><cell>27.8M</cell><cell>531MB</cell><cell>756s</cell></row><row><cell cols="3">Protocol 2 5 8192 1.4%</cell><cell>13.05s</cell><cell>0.37s</cell><cell>7.18s</cell><cell>2745.0K</cell><cell>52.35MB</cell><cell>76.84s</cell></row><row><cell cols="3">Protocol 2 5 16384 1.0%</cell><cell>29.8s</cell><cell>0.92s</cell><cell>15.71s</cell><cell>5489.0K</cell><cell>104.7MB</cell><cell>196.1s</cell></row><row><cell cols="4">Protocol 2 5 65535 0.5% 125.28s</cell><cell>2.83s</cell><cell>56.52s</cell><cell>22M</cell><cell>419MB</cell><cell>718.78s</cell></row><row><cell>k</cell><cell>90%</cell><cell cols="3">Total time /10 Patients /100 Patients Total time</cell><cell></cell><cell></cell></row><row><cell>Protocol 1 5 8192 Protocol 2</cell><cell>1.42% 1.42%</cell><cell>390s 401s</cell><cell>3970s 4014s</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">ACKNOWLEDGEMEMNT</head><p>We would like to thank Jonathan Katz for numerous helpful discussions. This work is supported by NSF award #1111599, #1464113, #1117106, #1223477, #1223495, #1408874 and NIH HG007078.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Define h (s) to be h(s) for every s ∈ A -B, and -h(s) for every</p><p>i=1 Di = d, and that Var Di = Var 1 l l i=1 Di ≤ 2d 2 /l. Using Chebyshev's inequality, we know that</p><p>By setting = 6/ε 2 , we obtain</p><p>Finally, note X = median j∈[k] Dj, where every Dj is bounded as above. Hence, |X -d| ≥ εd happens if and only if for at least half of j, | Dj -d| ≥ εd. Therefore, using a standard Chernoff bound, by setting k = O(λ), we can get the desired bound.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName><surname>Patientslikeme</surname></persName>
		</author>
		<ptr target="https://www.patientslikeme.com" />
		<imprint>
			<date type="published" when="2015-05-08">May 8, 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The space complexity of approximating the frequency moments</title>
		<author>
			<persName><forename type="first">N</forename><surname>Alon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Matias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Szegedy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Construction of age-related reference centiles using absolute residuals</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">G</forename><surname>Altman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Statistics in medicine</title>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Approximating edit distance in near-linear time</title>
		<author>
			<persName><forename type="first">A</forename><surname>Andoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Onak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">41st STOC</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">AND DU, W. Secure and private sequence comparisons</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Atallah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Kerschbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2003 ACM workshop on Privacy in the electronic society</title>
		<meeting>the 2003 ACM workshop on Privacy in the electronic society</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Countering gattaca: efficient and secure testing of fully-sequenced human genomes</title>
		<author>
			<persName><forename type="first">P</forename><surname>Baldi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Baronio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>De Cristofaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Gasti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Tsudik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Approximating edit distance efficiently</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Bar-Yossef</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">S</forename><surname>Jayram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Krauthgamer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">45th FOCS</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Secure multiparty protocols and zero-knowledge proof systems tolerating a faulty minority</title>
		<author>
			<persName><forename type="first">D</forename><surname>Beaver</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Correlated pseudorandomness and the complexity of private computations</title>
		<author>
			<persName><forename type="first">D</forename><surname>Beaver</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Commodity-based cryptography (extended abstract)</title>
		<author>
			<persName><forename type="first">D</forename><surname>Beaver</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Efficient garbling from a fixed-key blockcipher</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">T</forename><surname>Hoang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Keelveedhi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
		<editor>IEEE S &amp; P</editor>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Completeness theorems for non-cryptographic fault-tolerant distributed computation (extended abstract)</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ben-Or</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Aligning multiple genomic sequences with the threaded blockset aligner</title>
		<author>
			<persName><forename type="first">M</forename><surname>Blanchette</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Kent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Riemer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Elnitski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">F</forename><surname>Smit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">M</forename><surname>Roskin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Baertsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Rosenbloom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Clawson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">D</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><surname>Al</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome research</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Space/time trade-offs in hash coding with allowable errors</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">H</forename><surname>Bloom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<date type="published" when="1970">1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Espresso: efficient privacy-preserving evaluation of sample set similarity</title>
		<author>
			<persName><forename type="first">C</forename><surname>Blundo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>De Cristofaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Gasti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Security</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Lagan and multi-lagan: efficient tools for large-scale multiple alignment of genomic dna</title>
		<author>
			<persName><forename type="first">M</forename><surname>Brudno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">B</forename><surname>Do</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Cooper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Davydov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">D</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sidow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Batzoglou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">C S</forename><surname>Program</surname></persName>
		</author>
		<author>
			<persName><surname>Al</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome research</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The personal genome project</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Church</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Molecular Systems Biology</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">An improved data stream summary: the count-min sketch and its applications</title>
		<author>
			<persName><forename type="first">G</forename><surname>Cormode</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Muthukrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Algorithms</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Multiparty computation from somewhat homomorphic encryption</title>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Pastro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Smart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zakarias</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CRYPTO</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">When private set intersection meets big data: an efficient and scalable protocol</title>
		<author>
			<persName><forename type="first">C</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">What&apos;s the difference?: efficient set reconciliation without prior context</title>
		<author>
			<persName><forename type="first">D</forename><surname>Eppstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Goodrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Uyeda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Varghese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Moving towards individualized medicine with pharmacogenomics</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">E</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">V</forename><surname>Relling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Secure multiparty computation of approximations</title>
		<author>
			<persName><forename type="first">J</forename><surname>Feigenbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Malkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nissim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Strauss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">N</forename><surname>Wright</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automata, Languages and Programming</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">An approximate l1-difference algorithm for massive data streams</title>
		<author>
			<persName><forename type="first">J</forename><surname>Feigenbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kannan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Strauss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Viswanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal of Computing</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Hyperloglog: the analysis of a near-optimal cardinality estimation algorithm</title>
		<author>
			<persName><forename type="first">P</forename><surname>Flajolet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">É</forename><surname>Fusy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Gandouet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Meunier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">DMTCS Proceedings</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Efficient secure two-party computation from general assumptions</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">K</forename><surname>Frederiksen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">P</forename><surname>Jakobsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Nielsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Nordholt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Orlandi</surname></persName>
		</author>
		<author>
			<persName><surname>Minilego</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">On estimating frequency moments of data streams</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ganguly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Cormode</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Approximation, Randomization, and Combinatorial Optimization. Algorithms and Techniques</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">How to play any mental game or A completeness theorem for protocols with honest majority</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Assessing the privacy risks of data sharing in genomics</title>
		<author>
			<persName><forename type="first">C</forename><surname>Heeney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Hawkins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>De Vries</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Boddington</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kaye</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Public health genomics</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Faster secure two-party computation using garbled circuits</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Malka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Quid-Pro-Quo-tocols: Strengthening semi-honest protocols with dual execution</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Evans</surname></persName>
		</author>
		<editor>IEEE S &amp; P</editor>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Extending oblivious transfers efficiently</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nissim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Petrank</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Founding cryptography on oblivious transfer -efficiently</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Prabhakaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Algorithms for clustering data</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Dubes</surname></persName>
		</author>
		<author>
			<persName><surname>Al</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Efficient two-party secure computation on committed inputs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Jarecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Shmatikov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Improved garbled circuit: Free XOR gates and applications</title>
		<author>
			<persName><forename type="first">V</forename><surname>Kolesnikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Privacy preserving data mining</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">An efficient protocol for secure two-party computation in the presence of malicious adversaries</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">A proof of security of Yao&apos;s protocol for two-party computation</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">Automating efficient RAM-model secure computation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W</forename><surname>Hicks</surname></persName>
		</author>
		<editor>IEEE S &amp; P</editor>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Fairplay -a secure two-party computation system</title>
		<author>
			<persName><forename type="first">D</forename><surname>Malkhi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Nisan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Efficient oblivious transfer protocols</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SODA</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Fast manhattan sketches in data streams</title>
		<author>
			<persName><forename type="first">J</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Woodruff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Comprehensive molecular portraits of human breast tumours</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">G A</forename><surname>Network</surname></persName>
		</author>
		<author>
			<persName><surname>Al</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">A new approach to practical active-secure two-party computation</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Nielsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Nordholt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Orlandi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Burra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CRYPTO</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Secure two-party computation is practical</title>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Smart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">dbsnp: the ncbi database of genetic variation</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>Sherry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-H</forename><surname>Ward</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kholodov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Baker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Phan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Smigielski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sirotkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic acids research</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Mathematical correction for fingerprint similarity measures to improve chemical retrieval</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Swamidass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Baldi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of chemical information and modeling</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Using genetic variation to study human disease</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">G</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E.-H</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">B</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Chanock</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trends in molecular medicine</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Tabulation based 4-universal hashing with applications to second moment estimation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Thorup</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SODA</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Whole genomes redefine the mutational landscape of pancreatic cancer</title>
		<author>
			<persName><forename type="first">N</forename><surname>Waddell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pajic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A.-M</forename><surname>Patch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">K</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Kassahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bailey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Johns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Quek</surname></persName>
		</author>
		<author>
			<persName><surname>Et Al</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Illuminating the future of dna sequencing</title>
		<author>
			<persName><forename type="first">M</forename><surname>Watson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Protocols for secure computations (extended abstract)</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><surname>-C</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<imprint>
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">How to generate and exchange secrets (extended abstract)</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">-C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<imprint>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Two halves make a whole -reducing data transfer in garbled circuits using half gates</title>
		<author>
			<persName><forename type="first">S</forename><surname>Zahur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rosulek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Evans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
