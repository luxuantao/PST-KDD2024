<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">KLAVA: a Java package for distributed and mobile applications</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2002-09-27">27 September 2002</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Lorenzo</forename><surname>Bettini</surname></persName>
							<email>bettini@dsi.unifi.it</email>
						</author>
						<author>
							<persName><forename type="first">Rocco</forename><surname>De Nicola</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Rosario</forename><surname>Pugliese</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Dipartimento di Sistemi e Informatica</orgName>
								<orgName type="institution">Università di Firenze</orgName>
								<address>
									<addrLine>Via Lombroso 6/17</addrLine>
									<postCode>50134</postCode>
									<settlement>Firenze</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Dipartimento di Sistemi e Informatica</orgName>
								<orgName type="institution">Università di Firenze</orgName>
								<address>
									<addrLine>Via Lombroso 6/17</addrLine>
									<postCode>50134</postCode>
									<settlement>Firenze</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">KLAVA: a Java package for distributed and mobile applications</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2002-09-27">27 September 2002</date>
						</imprint>
					</monogr>
					<idno type="MD5">4CA2B209F7046B7C440066247269036E</idno>
					<idno type="DOI">10.1002/spe.486)</idno>
					<note type="submission">Received 26 November 2001 Revised 7 May 2002 Accepted 18 July 2002</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:20+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>code mobility</term>
					<term>distributed applications</term>
					<term>network awareness</term>
					<term>language and middleware implementation</term>
					<term>tuple spaces</term>
					<term>Java</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Highly distributed networks have now become a common infrastructure for wide-area distributed applications whose key design principle is network awareness, namely the ability to deal with dynamic changes of the network environment. Network-aware computing has called for new programming languages that exploit the mobility paradigm as a basic interaction mechanism. In this paper we present the architecture of KLAVA, an experimental Java package for distributed applications and code mobility. We describe how KLAVA permits code mobility by relying on Java and present a few distributed applications that exploit mobile code programmed in KLAVA.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>INTRODUCTION</head><p>Highly distributed networks have now become a common infrastructure for many applications which use network facilities to access remote resources and services. Thus, both programmers and users have to deal with a new kind of wide-area distributed application whose key design principle is network awareness, i.e. the ability to deal with dynamic changes of the network environment. This means that, for instance, applications have to be aware of the physical sites (administrative domains) where they are currently located and of the fact that remote operations can be time consuming, and they have to know how to cross administrative boundaries and move to other locations.</p><p>Network-aware computing has called for new programming languages and paradigms that support migratory applications as a new model of interaction among clients and servers. Mobile code, i.e. software that can be sent to remote sites and can be executed on arrival, has been advocated as the basic paradigm to support network-aware programming (see, e.g., <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref>). In the literature the term mobility is used to denote different mechanisms, ranging from simple ones, which only supply the ability of downloading code for execution (e.g. <ref type="bibr" target="#b2">[3]</ref>), to richer ones, which support migration of entire computations (e.g. <ref type="bibr" target="#b3">[4]</ref><ref type="bibr" target="#b4">[5]</ref><ref type="bibr" target="#b5">[6]</ref>). Mobile agents <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b6">7]</ref>, namely software objects with data and code that can autonomously migrate to a remote computer and execute automatically on arrival, are a special case of mobile code.</p><p>In this paper we present KLAVA, a Java package for programming distributed applications and code mobility where interactions take place through multiple distributed tuple spaces. Java <ref type="bibr" target="#b2">[3]</ref> has been chosen as the implementation language because it provides many tools for programming distributed applications with mobile code. Indeed, Java guarantees architectural independence, i.e. on-line portability <ref type="bibr" target="#b7">[8]</ref>, and supplies class libraries for network programming, tools for synchronization, dynamic class loading and customizable security mechanisms.</p><p>As shown in <ref type="bibr" target="#b8">[9]</ref>, where several messaging models for mobile agents are examined, the blackboard approach, of which tuple space based models are variants, is one of the most appreciated, also because of its flexibility. Since our approach is a variant of the Linda coordination model <ref type="bibr" target="#b9">[10]</ref>, also known as Generative Communication, in the rest of this section we briefly recall tuple space models and variants thereof. In Linda, processes can execute concurrently and share a single tuple space acting as a repository of elementary data structures, called tuples. All Linda primitives are devoted to coordinate and synchronize process behavior: two, possibly blocking, primitives allow processes to access tuples in the tuple space, and two other ones allow processes to add tuples to the tuple space. Tuples are anonymous and associatively selected from the tuple space by means of a pattern-matching mechanism, thus processes must only know the structure of tuples.</p><p>The Linda coordination model was originally proposed for parallel programming on isolated machines. However, it has a number of properties that also make it appealing for network computing environments (see, e.g., <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12]</ref>), where, in general, connections are not stable and host machines are heterogeneous. Indeed, the Linda asynchronous communication model permits:</p><p>• time uncoupling: the tuples' lifetime is independent of the producer process' lifetime;</p><p>• destination uncoupling: the creator of a tuple is not required to know the future use or the destination of that tuple; • space uncoupling: communicating objects need to know a single interface, i.e. the operations over the tuple space. This approach is also called flow-of-objects <ref type="bibr" target="#b12">[13]</ref> as opposed to method invocation, which requires many interfaces for the operations supplied by remote objects.</p><p>When moving to open distributed systems and large-scale, multi-user applications, the Linda coordination model suffers from a lack of modularity and scalability: identification tags of tuples, which are conceptually part of different contexts, may collide. In other words, processes of different computations could interfere and a mechanism to structure communication and hide information, e.g. to create areas restricted to a subset of the processes, is needed. This problem led to the introduction of Linda3 <ref type="bibr" target="#b13">[14]</ref>, a variant of Linda with multiple tuple spaces. In this extended model, tuple spaces are first-class objects (e.g. they can be obtained as result of an expression and used as fields of tuples), can be dynamically created (they are objects of type ts), and can be hierarchically structured. From their introduction, multiple tuple spaces have been exploited in many other variants of Linda that mainly differ in the way tuple spaces are structured: these can either be unrelated, giving rise to a simple flat structure (like in, e.g., Paradise <ref type="bibr" target="#b14">[15]</ref>, Piranha <ref type="bibr" target="#b15">[16]</ref>, and SecOS <ref type="bibr" target="#b16">[17]</ref>), or can be related creating some form of hierarchy (like in, e.g., Bauhaus <ref type="bibr" target="#b17">[18]</ref>, Melinda <ref type="bibr" target="#b18">[19]</ref>, and Polis <ref type="bibr" target="#b19">[20]</ref>). Performance can benefit from the adoption of multiple, possibly distributed, tuple spaces, like those used in KLAVA, because it would no longer be necessary to perform all operations through a single global tuple space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>THE PACKAGE KLAVA: BASIC CONCEPTS AND ARCHITECTURE</head><p>Before describing in detail the package Klava, we briefly illustrate the basic concepts on which it relies. The linguistic abstractions of our framework are inspired by KLAIM (Kernel Language for Agent Interaction and Mobility) <ref type="bibr" target="#b20">[21]</ref>, an experimental language specifically designed to program distributed systems made up of several components interacting through multiple distributed tuple spaces and mobile code (indeed, KLAVA stands for KLAIM in Java).</p><p>KLAVA relies on the concept of tuple space. A tuple space is a multiset of tuples that are sequences of information items. KLAVA handles multiple distributed tuple spaces that are placed on nodes of a net. Each node can be accessed through its locality and contains a single tuple space and processes in execution. Processes are the active computational units; they can be executed concurrently both at the same node or at different nodes, and can be exchanged in communications as first class data. Processes can perform a few basic operations over tuple spaces and nodes: retrieve/place tuples from/into a tuple space, send processes for execution on (possibly remote) nodes, and create new nodes. Since tuples are anonymous, to retrieve tuples from a tuple space, a pattern-matching mechanism is used.</p><p>In the rest of this section, we present the classes of the package Klava, together with more details about the notions above. Some of Klava classes can already be used as they are (e.g. the class Tuple), while others have to be specialized through inheritance and method overriding (e.g. the class KlavaProcess).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Tuples</head><p>Tuples are sequences of information items called fields and are the basic tools for data elaboration and information exchange. There are two kinds of tuple fields: actual fields (i.e. expressions, processes, localities, constants, identifiers) and formal fields (i.e. variables).</p><p>The class Tuple includes methods for handling tuples, such as creating tuples, adding elements to a tuple, getting an element of a tuple, etc. A tuple can be created by passing a Vector object, containing all tuple elements, to the Tuple constructor, such as Vector v = new Vector() ; v.addElement( o1 ) ; v.addElement( o2 ) ; v.addElement( o3 ) ; Tuple t = new Tuple( v ) ; or by first creating an empty tuple and then adding elements using the method add(Object o). To make tuple construction easier, a limited number of overloaded constructors is available such as public Tuple( Object o1 ) public Tuple( Object o1, Object o2 ) ... so that one can create a new tuple simply by writing Tuple t = new Tuple( o1, o2, o3 ) ; Tuples are anonymous and content-addressable and pattern-matching is used to select tuples in a tuple space:</p><p>• two tuples match if they have the same number of fields and corresponding fields have matching values or formals; • formal fields match any value of the same type and two actual fields match only if they are identical (two formals never match).</p><p>After matching, the variable of a formal field will get the value of the field it has matched. Pattern-matching is implemented through the method match of the class Tuple. match takes a tuple as parameter and checks the matching with the current tuple. The method match also performs the binding of the formals, in case the matching succeeds.</p><p>The interface TupleItem can be used for handling tuple fields. Its declaration is as follows:</p><p>public interface TupleItem extends java.io.Serializable { public boolean isFormal() ; // is it a formal? public void setValue(Object o) ; // for updating public boolean equals(Object o) ; // are they equal? } TupleItem's methods are used by the matching algorithm. More specifically, isFormal is used to test whether a tuple field is a formal, setValue is used to update a formal field with an actual value, and equals is used to test whether two actual fields match. As usual, the semantics of these methods must be specified by the classes that implement the interface. The package Klava makes available some wrapper classes for standard data types that implement this interface: KString, KInteger, KBoolean, and KVector.</p><p>It is assumed that a TupleItem created with the default constructor (i.e. with no parameters) is a formal. We think that this is better than having a method setFormal, which may cause inconsistencies among aliases. Below we provide an example: KString s = new KString() ; // formal declaration KInteger i = new KInteger() ; // formal declaration Tuple t1 = new Tuple( s, i ) ; Tuple t2 = new Tuple( new KString("Hello"), new KInteger(10) ) ; t2.match( t1 ) ; // true System.out.println( "s now is : " + s ) ; System.out.println( "i now is : " + i ) ;</p><p>Notice that the values of formal fields are automatically updated (by means of the method setValue).</p><p>Alternatively, a Class object can be used for expressing a formal field. After a successful matching, the method Object getItem(int index) (indexes start from 0) can be used to retrieve the value bound to a formal field. Thus, the above program fragment can be also rendered as follows:</p><p>Tuple t1 = new Tuple( String.class, Integer.class ) ; Tuple t2 = new Tuple( new String("Hello"), new Integer(10) ) ; t2.match( t1 ) ; // true System.out.println( "matched string : " + t1.getItem(0) ) ; System.out.println( "matched integer : " + t1.getItem(1) ) ;</p><p>The method match relies on types, thus, e.g., a KString cannot match a String. Indeed, the KLAVA matching mechanism is object based, but not object-oriented, in the sense that subtyping is not considered while checking whether two tuple fields match; namely, the static types must be the same. Thus, the internal structure of objects is no further inspected and, in particular, only the method equals is employed in order to test whether two actual fields match. There is only one exception that is needed to avoid that the matching mechanism limits the exchange of code and to make it possible to match a tuple containing processes without knowing their concrete classes in advance: actual processes, that are instances of subclasses of KlavaProcess (explained later), are retrieved by means of tuple fields of class KlavaProcessVar (see the section 'Nodes').</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Localities</head><p>Localities are the tools that processes can use for referring to nodes of the net. We distinguish between two kinds of localities:</p><p>• physical localities are identifiers through which nodes can be uniquely identified within a net;</p><p>• logical localities are symbolic names for nodes. A distinct logical locality, self, can be used by processes to refer to their execution node.</p><p>Intuitively, physical localities have an absolute meaning within the whole net, while logical localities have a relative meaning depending on the node where they are interpreted and can be thought of as aliases for network resources. The association between logical and physical localities is modeled via a function that we call allocation environment; each node has an allocation environment that solves the logical localities there used.</p><p>There are three classes that handle localities. The abstract class Locality is the base class and implements the interface TupleItem. The other two classes LogicalLocality and PhysicalLocality are derived from this base class. A variable that represents a locality should always be declared as a Locality so that polymorphism can be used extensively.</p><p>Physical localities are not IP addresses, but are simply the names with which Node objects (explained later) register themselves at the Net object that acts as a net server (see the section 'Nets'). In this way, we have an additional abstraction level and a Node is independent from its IP address. The only IP address that has to be known is that of the net server. Of course, localities implemented as real IP addresses or URL objects could also be introduced.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Tuple spaces</head><p>Tuple spaces are multisets of tuples. The class TupleSpace includes methods to place tuples in and retrieve tuples from a tuple space. In particular, the methods public boolean in( Tuple t ) public boolean read( Tuple t ) public void out( Tuple t ) implement three operations over tuple spaces, namely in(t), read(t), and out(t), that all require the evaluation of their argument tuple. Tuple evaluation consists in translating logical localities into physical ones and in closing processes (as explained later in the section 'Nodes').</p><p>• in(t): looks for a tuple t that matches the result of the evaluation of t. Whenever the matching tuple t is found, it is removed from the tuple space. The corresponding values of t are then assigned to the formal fields of t and the operation terminates. If no matching tuple is found, the operation is suspended until one is available. • read(t): differs from in(t) only because the matching tuple t is not removed from the tuple space.</p><p>• out(t): adds the tuple resulting from the evaluation of t to the tuple space.</p><p>Two other methods of this class that implement operations over tuple spaces are public boolean read nb( Tuple t ) public boolean in nb( Tuple t ) read_nb and in_nb act like read and in, but, if no matching tuple is found, they do not block the executing process and simply return false. Some versions of Linda also introduce such operations, called readp and inp <ref type="bibr" target="#b21">[22]</ref>. These variants are useful when one wants to search for a matching tuple in a tuple space with no risk of blocking. For instance, read_nb can be used to test whether a tuple is present in a tuple space. Below we report an example that uses a TupleSpace object: Due to network latency and bandwidth, network communications can be quite slow, hence, retrieving information may require more time than one is willing to wait. Moreover, the absence of matching tuples could block a process executing an in/read operation. To put upper bounds to the waiting time, a time-out can be used. Therefore, 'timed' versions of the blocking methods are supplied: public boolean read( Tuple t, long TimeOut ) throws KlavaTimeOutException public boolean in( Tuple t, long TimeOut ) throws KlavaTimeOutException If the specified timeout (expressed in milliseconds) expires before the corresponding operation returns, then a KlavaTimeOutException exception will be thrown. Time-outs can thus be handled in a try...catch block.</p><formula xml:id="formula_0">TupleSpace TS = new</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Nodes</head><p>Nodes are the loci where tuples and processes reside; they are also the execution engines for KLAVA processes. The class Node implements a KLAVA node: a Node object contains a single tuple space and exports methods for accessing this tuple space. These methods take, in addition to a tuple, the locality of the node as a parameter and redirect operations to the corresponding methods of the tuple space of the node: public void out( Tuple t, Locality l ) public boolean read( Tuple t, Locality l ) public boolean in( Tuple t, Locality l ) By using these methods, processes can explicitly address the tuple space where a given operation must be executed. For instance, out(t, l) means that the tuple resulting from evaluation of tuple t must be placed at the tuple space located at l.</p><p>For better programmability, a limited number of overloaded versions of these methods is supplied: • eval(P , l): spawns process P for execution at node l;</p><formula xml:id="formula_1">public</formula><p>• newloc(): creates a new node in the net and returns its physical locality. The node can be considered as a 'private' node that can be accessed by other nodes only if the creator communicates the node locality to them.</p><p>Every Node has two fields: self (of class LogicalLocality) and here (of class PhysicalLocality); the latter represents the physical locality of the node within the net. Moreover, each node has an allocation environment, namely a sort of partial function that maps logical localities into physical localities. The environment of a Node can be specified with the method void addToEnv(String logLoc, String phyLoc). In particular, the allocation environment of a node associates self to here.</p><p>When evaluating tuples, other than for translating logical localities into physical ones, allocation environments are also used to 'close' processes whenever they are exchanged in communications (as stated in the previous section). Indeed, evaluating a process that occurs in a field of a tuple means substituting it with its closure, namely the process along with the environment of the node where the evaluation is taking place. Hence, a remarkable difference between out(P , l) and eval(P , l) is that out adds the closure of P to the tuple space located at l, while eval sends P , not its closure, for execution at l. This will affect the evaluation of logical localities: when a process needs to translate a logical locality into a physical one, first its own allocation environment is used (if it has one) and then, if the translation fails, the environment of the node where the process runs is used. This means that a process delivered with an out will use a static scoping strategy for logical localities while a process remotely spawned with an eval will use a dynamic scoping strategy. Thus, for instance, in the former case, self will refer to the originating site, while, in the latter case, self will refer to the current execution site.</p><p>The other major difference between eval(P , l) and out(P , l) is that eval(P , l) automatically starts the execution of the process P at the remote site l, while out(P , l) does not. Indeed, out(P , l) simply posts a tuple containing the process P (along with an allocation environment) at the tuple space of l. The process has to be explicitly retrieved from the tuple space by means of a KlavaProcessVar (e.g. by a process executing at l) and explicitly started, as in the following example: KlavaProcessVar PV = new KlavaProcessVar(); // formal in( PV, self ); eval( PV, self ); Notice that eval also accepts a KlavaProcessVar as a parameter. Moreover, since out has a tuple as a parameter, many processes can be delivered to a remote site at once.</p><p>A Node object must log in a Net server, and hence has to know the exact IP address of the latter (host and port number). It must also specify its own physical locality; in case the proposed locality is already part of the net, the net server will refuse to register the node. It is worth noting that we can have more than one node on the same machine as long as each node refers to different physical localities; indeed, a physical locality is just a name, and not an Internet address.</p><p>Nodes communicate by means of messages delivered through streams (connected to sockets). The class NodeMessage implements messages exchanged in the KLAVA system and has the following structure (the content of a message can be any serializable Object): </p><formula xml:id="formula_2">public</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Processes</head><p>Processes are the basic computational units. The class KlavaProcess is an abstract class that must be specialized to create processes. The derived classes must implement the method execute declared as follows: abstract public void execute() throws KlavaException This method will be invoked when a process is executed (just like run for threads). A process must be executed within a node, which will be its execution environment <ref type="bibr" target="#b1">[2]</ref>. KlavaProcess also offers all the methods to access tuple spaces; these methods transparently call the homonymous methods of the class Node.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Nets</head><p>The class Net implements the server that manages a KLAVA net. A Net object keeps track of the physical localities of the Node objects that are part of the net. It is a multithreaded server that coordinates KLAVA nodes and enables them to communicate. It can also be seen as a name registry server. Of course Net and Node objects may execute on different machines.</p><p>There is exactly one net server for every KLAVA net. To become part of a KLAVA net, a node has to log into the net server by specifying its own physical locality that will uniquely identify the node and can be used to address it within the net. When a Net object receives a login request from a node, a new NodeHandler thread is spawned to handle the connection. After that, the NodeHandler will be a proxy for the node within the net and the net server keeps a table with NodeHandlers' references.</p><p>First, the NodeHandler will take care of registering the node within the net by executing the following steps:</p><p>1. asks the node for the physical locality with which the node wants to take part of the net; 2. checks whether the locality already exists within the net; if not, the NodeHandler communicates to the node that the node is now part of the net and enters an infinite loop waiting for messages from the node; otherwise the node is notified about the problem.</p><p>After registering, the NodeHandler will handle the delivery of the node's messages to other nodes; inter-node communication takes place as follows (see also Figure <ref type="figure" target="#fig_1">1</ref>):</p><p>1. each node sends the message to its own NodeHandler; 2. the NodeHandler, after inspecting the message destination field, asks the net server for a reference to the NodeHandler of the receiver node (the dashed line in Figure <ref type="figure" target="#fig_1">1</ref> represents a reference); 3. the message is inserted into the message queue of the NodeHandler of the destination node; 4. the NodeHandler of the destination node takes care of delivering the message to the node it manages.</p><p>In this scenario communications take place indirectly, through the net server. However, direct connections are also permitted (by means of a flag in the class Node): in this case, the first time a node A has to communicate with a node B (that accepts direct connections), the IP address of B is obtained through the net server and a direct connection between A and B is established (all these operations are performed automatically by KLAVA). Then, further messages between these two nodes will be exchanged directly through this connection. In case of firewalls or network restrictions the access to a remote node may be permitted only through a net server. For instance, an applet can only open a network connection towards the computer it has been downloaded from. If on this computer there is a net server running, the applet is still able to indirectly communicate with all the nodes and, possibly, with applets that are part of that KLAVA net; an example of a KLAVA applet is available at http://music.dsi.unifi.it/klava applet. In this sense, a Net object can also be seen as a gateway for nodes, allowing them to communicate even if they belong to different restricted domains.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CODE MOBILITY IN KLAVA</head><p>In KLAVA, processes can be sent as part of a message and executed at the destination site, where, however, their Java classes, i.e. their code, may be unknown. It might then be necessary to make such code available for execution at remote hosts; this can be done basically in two different ways:</p><p>• automatic approach: the classes needed by a process are collected and delivered together with the process; • on-demand approach: when a Java class is needed by the remote computer that received a process for execution, the class is requested to the server that sent the process.</p><p>We follow the automatic approach because it complies better with the mobile agent paradigm: during a migration, an agent takes with it all the information that it may need for later executions. The drawback of this approach is that code that may never be used by the mobile agent or code that is already provided by the remote site is also shipped. However, our choice has the advantage of simplifying the handling of disconnected operations <ref type="bibr" target="#b22">[23]</ref>: the agent owner does not have to stay connected after sending the agent and can connect later just to check whether his agent has terminated. This may not be possible with the on-demand approach: the server that sent the process must always be on-line in order to provide the classes needed by remote hosts.</p><p>Therefore, a process must be sent along with its class binary code, and with the class code of all the objects the process uses. Obviously, only the code of user-defined classes has to be sent, as the other code (e.g. Java and Klava classes) is common to every KLAVA application. This guarantees that classes belonging to java sub-packages are not loaded from other sources (especially, the network); this would be very dangerous, since, in general, such classes have many more access privileges.</p><p>All the nodes that are willing to accept remote processes (due to security issues, a node may refuse accepting remote processes for execution) must have a custom class loader: a NodeClassLoader supplied by the Klava package. When a process is received from the network, before using it, the node must add the class binary data (received along with the process) to its class loader's table. During process execution, whenever a class code is needed, if the class loader does not find the code in the local packages, then it can find it in its own local table of class binary data.</p><p>The names of user-defined classes can be retrieved by means of class introspection (Java Reflection API). Just before dispatching a process to a remote site, a recursive procedure is called for collecting all classes that are used by the process when declaring: data members, objects returned by or passed to a method/constructor, exceptions thrown by methods, inner classes, the interfaces implemented by its class and the base class of its class.</p><p>This procedure is implemented by some methods of the class KlavaProcess presented in Listing 1 in a simplified form. Notice that this procedure recursively calls itself. Mutual dependencies are handled by checking whether a class has already been collected; thus a class is never inspected more than once.</p><p>When extending KlavaProcess, there is an important detail to know in order to avoid run-time errors that would take place at remote sites and would be very hard to discover: Java Reflection API is unable to inspect local variables of methods. This implies that if a process uses a class only to declare a variable in a method, this class will not be collected and thus, when the process executes that method on a remote site, a ClassNotFoundException may be thrown. This limitation is due to the specific implementation of Java Reflection API, but it can be easily dealt with, once the programmer is aware of the problem. The programmer can explicitly add a class to the collection by calling the method addUsedClass in Listing 1; all the details of code marshaling are still handled by KLAVA and are transparent to the programmer.</p><p>Once these class names are collected, their byte code is gathered in the first server from which the process was sent, and packed along with the process in a KlavaProcessPacket object. Notice that the process (its variables) is written in an array of bytes and not in a field of type KlavaProcess. This is necessary because otherwise, when the packet is received at the remote site and read from the stream, the process would be deserialized and an error would be risen when any of its specific classes is needed (indeed, the class is in the packet but has not yet been read). Instead, by using our representation, we have that, first, the byte code of process classes is read from the packet and stored in the class loader table of the receiving node; then, the process is read from the byte array; when process classes are needed, the class loader finds them in its own table. Thus, when a node receives a process, after filling in the class loader's table, it can simply deserialize the process, without any need for explicit instantiation. The point here is that classes are always stored in the class loader's table, but they are linked (i.e. actually loaded) on-demand.</p><p>The byte code of the classes used by a migrating process is retrieved by the method getClassBytes of the class loader (as shown in Listing 1): at the server from where the process is first sent, the byte code is retrieved from the local file system, but when a process at a remote site has to be sent to another remote site, the byte code for its classes is obtained from the class loader's table of the node. This strategy, for sending and receiving code, is similar to a page on-demand mechanism in an operating system: first the class loader table is filled in with the code for all the classes that a remote process may need, then, when a class is needed, the class loader can load the class by taking the code from its table.  type system for expressing and forcing policies that control accesses to resources and data <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b31">32]</ref> are under progress.</p><p>In <ref type="bibr" target="#b32">[33]</ref> we enriched KLAVA with cryptographic primitives for encrypting and decrypting tuple fields and the original Linda operations have been extended for handling encrypted data. The extended framework allows mobile agents, which are not supposed to carry private keys with them when migrating, to collect encrypted data while executing on remote sites, and decrypt them safely when back at the home site.</p><p>Finally, for what concerns application safety, KLAVA does not provide direct support for saving processes and mobile agents into external memory in order to deal with nodes' shutdown and reboot. Safety can be recovered by explicitly programming serialization of components of a node (tuple space, processes, etc.).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>THREE EXAMPLE APPLICATIONS</head><p>In this section we present three programming examples that rely on mobility and distribution. The first example concerns a news gatherer that exploits mobile agents for retrieving information on remote sites; the second example implements a load balancing system that dynamically redistributes mobile code among several processors; the last example is a simplified chat system. The main purpose of these examples, whose core implementation parts are reported in some code snippets throughout the following sections, is showing that, by using KLAVA, dealing with mobility and communications among distributed processes boils down to a few method calls, since KLAVA takes care of all of the low level details of code mobility and distributed synchronization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A news gatherer</head><p>In this section we show how to program in KLAVA a news gatherer that relies on mobile agents for retrieving information on remote sites (this example is borrowed from <ref type="bibr" target="#b20">[21]</ref>). We assume that some data is distributed over the nodes of a KLAVA net and that each node either contains the information we are searching for, or the locality of the next node to visit in the net.</p><p>The implementation in KLAVA is reported in Listing 2. The agent NewsGatherer uses a timeout to test for the presence of the tuple containing the information: if this is not found within two seconds, the locality of the next node to visit is retrieved and a new instance of the agent is remotely spawned there by means of an eval. If the information is found, the agent communicates the result to its owner and terminates.</p><p>By using KLAVA, to spawn a new process to a remote site, it suffices to just invoke eval with the appropriate arguments: the underlying system will take care of serializing the process through the network together with the code of all its classes and the values of its fields. Figure <ref type="figure">2</ref> and Screenshot 1 show an agent that visits three nodes before finding the wanted information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Load balancing</head><p>In this second scenario, we suppose that remote clients send processes for execution to a server node that distributes the received processes among a group of processors by using, each time, the (estimated) idlest one (Figure <ref type="figure">3</ref>). This is determined by using the Leaky Bucket Of Credits pattern <ref type="bibr" target="#b33">[34]</ref>: when  for strong mobility (see the section about code mobility) and for objective mobility <ref type="bibr" target="#b34">[35]</ref> (the process does not migrate autonomously, but it is moved by the execution environment), which Java does not supply. However, even with this limitation, this architecture can still be employed in client-server-based distributed systems, where the server has to balance the number of connections and communications among several nodes it manages: the client issues a connection request to the server that then picks a node and charges it with the task of interacting with that client.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A chat system</head><p>The chat system we present in this section is simplified, but it implements the basic features that are present in several chat systems. Although this example does not deal with mobile code, it shows how to use KLAVA to implement distributed applications that can communicate through distributed and located tuple spaces.</p><p>The system consists of a ChatServer and many ChatClients. A client that wants to enter the chat must log in the net and register itself within the chat server. The server must keep track of all the registered clients and, when a client sends a message, the server has to deliver the message to every connected client. If the message is a private one, it will be delivered only to the clients in the list specified along with the message.</p><p>The class ChatServer derives from the class Node and redefines the method handleOUT that is called when a node performs an out to this node, as shown in Listing 5. The first field of the tuples that are handled by the server is the command that the client wishes to perform: entering the chat with a name, leaving the chat, sending a message either to everyone currently in the chat, or only to a list of people. The remaining fields depend on the content of the first field. Tuples having a different format are not handled and, hence, are implicitly discarded. The advantage of our approach, with respect to an alternative one based on dynamic creation of handler processes for tuples, is that we can implement reactions <ref type="bibr" target="#b35">[36]</ref> against the presence of some specific tuples. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PERFORMANCE ASSESSMENT</head><p>In this section we touch upon performance issues of the Klava package. In particular, we will concentrate on those issues related to accessing (local/remote) tuple spaces and those related to code mobility.</p><p>In the current implementation, a tuple space is implemented by storing its tuples in a Vector object. The search for matching tuples is performed sequentially, thus the average cost for retrieving a matching tuple is linear in the number of stored tuples. However, the class TupleSpace abstracts from the specific internal representation of the tuple space, thus alternative implementations can be plugged in by simply implementing specialized subclasses of TupleSpace. For instance, the following alternative implementations could be adopted that are based on the following.</p><p>• Hash tables: the hash code of a tuple can be computed by smartly composing the hash code of single tuple items. • Trees: tuples are stored in a search tree, and are indexed according to types and values of their items.</p><p>• DBMS: the tuple space acts as a wrapper for a database where tuples are stored in a specific format. The matching algorithm can retrieve tuples by means of SQL queries or of a richer query language. Indeed, in <ref type="bibr" target="#b36">[37]</ref>, an extension of KLAVA has been developed for storing tuples in a database that can be queried through the TQL query language <ref type="bibr" target="#b37">[38]</ref>.</p><p>More elaborate techniques, such as those based on fingerprints and summaries presented in <ref type="bibr" target="#b38">[39]</ref>, can also be employed.</p><p>When performing remote retrieval operations, such as, e.g. a read request to a remote site, the remote tuple space is inspected by a thread executing at the remote site. Thus, apart from the communication cost of the remote request and response, the cost of inspection of a remote tuple space is the same as that of a local retrieval.</p><p>Inserting a tuple in the local tuple space consists of storing a reference to the tuple in a Vector. Obviously, this operation takes place in a synchronized way; this is necessary because many processes may try to concurrently access the same tuple space. When inserting a tuple in a remote tuple space, the tuple is sent in a serialized form. Buffering is applied during this operation, so that the serialization does not interleave heavily with the network communications. Thus, the overhead of interacting with a tuple space is kept to the minimum, and basically does not influence the overall performance of the system.</p><p>The cost in time of process migration depends on:</p><p>• the time for collecting, through Java Reflection, the classes used by the process (recall that KLAVA relies on the 'automatic approach', thus the migrating process also carries the byte code of the classes it uses); • the time for delivering the serialized state of the process and the contents of the class files.</p><p>As explained in the section about code mobility, the (default) choice of sending a process along with its code renders mobile processes more autonomous and independent of the originating site. Moreover, it makes process migration an atomic operation, which is different from the on-demand approach that always requires a connection with the home site. However, one can disable the automatic collection and transmission of code for a mobile process by calling the method setDeliverCode(boolean) of class KlavaProcess. This disabling is reasonable when it is known that (the same version of) the needed code is already installed at every site visited by the mobile process. The automatic transmission of code can also be disabled when the connections are known to be solid and permanent: in this case, one can implement the on-demand approach either by using a low-level remote class loading (e.g. by using the Java URLClassLoader functionalities), or by implementing a protocol using the KLAVA communication model for exchanging code (see also the section about code mobility). Notice, however, that a process usually does not use many classes (apart from the ones of the standard packages, which are not moved anyway), hence, for most of the processes exchanged among distributed nodes, there is basically no difference whether the code is shipped or not (in these tests every node had all the classes needed by the processes). Thus, the way KLAVA deals with code mobility does not lead to a great decrease of performance.</p><p>An overhead imposed by the KLAVA framework includes the login phase (when a node has to register its physical locality in the net, as described in the section 'Nets'). However, this is a one time operation and it is common to distributed systems where resources are addressable by names (see, e.g., Java RMI Name Registry <ref type="bibr" target="#b39">[40]</ref>). After this first step, distributed nodes basically rely on sockets and the results of the tests we executed show that there is no noticeable difference with respect to a standard client-server socket based application. Obviously, KLAVA nodes that rely on direct communications perform better than those that communicate using the net server as a gateway, but, as explained in the section 'Nets', direct communications cannot be used in some circumstances.</p><p>Tables I-III show the results of our tests for evaluating the performance of the package Klava.</p><p>The tests were executed on various machines (Intel PCs and SUN Sparc Stations) of the departmental network with different operating systems (Windows, Unix, Linux). Each test has been repeatedly executed at different moments of the day to experiment with different bandwidths determined by the load of the network and the tables report mean values expressed in milliseconds.</p><p>Table <ref type="table" target="#tab_4">I</ref> highlights the impact of using a direct connection between nodes or the net server as a gateway. We distinguish between co-located nodes running on the same machine and distributed nodes. The tests were performed by measuring the time necessary for exchanging 10 tuples containing an integer value between two nodes whose tuple spaces contain other tuples filled in randomly. As expected, the first row of the table shows that local communications are more efficient than remote ones. The second column shows that inter-node direct communication is more efficient than indirect communication via the net server.</p><p>Table <ref type="table" target="#tab_4">II</ref> shows the overhead of the login phase executed by Klava nodes. Indeed, Klava nodes are needed to support execution of KlavaProcess objects, while, obviously, they are not needed for executing Java threads. The results show that the login phase is not too expensive. The tests have been performed by relying on standard sockets (not on tuple spaces) for exchanging 10 integers between processes running on different machines. Thus, the comparison between the second row of Table <ref type="table" target="#tab_4">I</ref> and that of Table II highlights the overhead of using a tuple-space-based communication mechanism over the one based on sockets.</p><p>Table <ref type="table" target="#tab_5">III</ref> shows the overhead due to migration of class code along with a process. The tests have been performed by measuring the time necessary to send a process, along with a number of class code ranging from 5 to 20 (usually, only a few classes have to be transmitted along with a migrating process), to a remote node. The results show that migration of class code does not degrade significantly the performance of a mobile process.</p><p>Finally, we would like to remark that issues concerning performance optimization are orthogonal to our prototype implementation. We refer the interested reader to, e.g., <ref type="bibr" target="#b40">[41]</ref><ref type="bibr" target="#b41">[42]</ref><ref type="bibr" target="#b42">[43]</ref><ref type="bibr" target="#b43">[44]</ref><ref type="bibr" target="#b44">[45]</ref><ref type="bibr" target="#b45">[46]</ref> that investigate the problem of optimizing various aspects of the Linda coordination model. We believe that most of these optimization techniques can be exploited also to improve KLAVA.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CONCLUSIONS AND RELATED WORKS</head><p>We have presented KLAVA, a Java package for implementing distributed applications that can exploit mobile code and run over a heterogeneous network environment. Its architecture is quite general and can be exploited for implementing other systems dealing with distributed applications and mobile code. The Klava package is available on line at <ref type="bibr" target="#b46">[47]</ref>.</p><p>KLAVA extends the Linda coordination paradigm with multiple distributed tuple spaces. Thus, the underlying model enables space uncoupling, time uncoupling, and destination uncoupling, and asynchronous, associative, and anonymous communication. We believe that this programming model is suitable for distributed applications, mobile agents, and, more in general, mobile code. Other models <ref type="bibr" target="#b8">[9]</ref>, such as the home-proxy <ref type="bibr" target="#b5">[6]</ref>, can be programmed on top of the KLAVA basic model by exploiting the locality abstractions.</p><p>KLAVA provides support for moving processes and all the code they will need for execution at remote sites. An interesting spin-off of our approach is that, since KLAVA is based upon the KLAIM specific tuples. In KLAVA, this is obtained either by using dynamically created private tuple spaces or by using the capability-based type system presented in <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b31">32]</ref>.</p><p>Jini <ref type="bibr" target="#b54">[55]</ref> is a connection technology that enables many devices to be plugged together to form a community on a network in a scalable way and without any planning, installation, or human intervention. Each device defines services that other devices in the community may use and drivers that can be downloaded when needed. Jini is developed on top of the JavaSpaces <ref type="bibr" target="#b12">[13]</ref> technologies, a framework for using Linda-like communication. JavaSpaces introduces some extensions of the Linda original paradigm, such as event notification, which allows a process to register its interest in future occurrences of some event and then to receive communication when the event occurs, and blocking operations with timeouts and leasing, which allows the presence of a tuple in a tuple space, or a notification request, to be granted only for a period of time. Leasing can also be obtained in our framework by means of timeouts: a process can sleep for some time (using timeout), and then can take a tuple away from the tuple space (if it is still available). JavaSpaces transactions can be programmed in KLAVA, by means of dedicated tuples, which represent transaction lifetime.</p><p>In JavaSpaces, tuples are instances of classes derived from the common base class Entry, each with a fixed configuration of fields. Instead, in KLAVA all tuples are instances of the class Tuple and they do not have a fixed configuration, namely they can be built from scratch by using the methods of the class Tuple for adding new fields. Therefore, in JavaSpaces two tuples match only if they both are instances of the same class, while in KLAVA two tuples match if all corresponding fields are instances of the same class.</p><p>Moreover, the KLAVA matching mechanism is object based, but not object oriented, namely subtyping is not applied while checking whether two fields match (apart from process fields for which a form of polymorphism is used). Instead, JavaSpaces permits matching of subtypes. While this feature can be easily added to the KLAVA matching function, by relying on Java RTTI (Run-Time Type Information), we decided not to add it because we believe that exact matching enforces a stronger form of data protection, in that the exact class of a field must be known (i.e. its code must be available) in order to match it. This check is weakened in JavaSpaces due to the possibility of matching any entry by using a null reference. This would not be acceptable in a system specifically oriented to mobile code; JavaSpaces instead basically aims at providing a distributed persistence and an object exchange mechanism for code written in Java.</p><p>IBM T Spaces <ref type="bibr" target="#b55">[56]</ref> is a network middleware package that supplies tuple space-based network communication with database capabilities; it is implemented in Java by relying on its portability. T Spaces is basically a message processor, in fact a client's view of T Spaces is that of a message center and a message database. Also T Spaces extends the Linda notion of exact type equivalence in the pattern matching algorithm to an object-oriented notion of subtype equivalence. A DBMS could be implemented in KLAVA by means of a process listening for requests (e.g. SQL strings) passed via tuples, to obtain a similar behavior.</p><p>IBM Aglets <ref type="bibr" target="#b5">[6]</ref> is a framework for programming mobile agents written in Java. Aglets execute on an aglet server, called Tahiti. Aglets overcomes the limitation that Java only supports weak mobility by exploiting a notification event-based model: when an agent arrives at a remote site, its call back method onArrival is invoked and the agent can then execute some actions according to the information stored in the agent's state (before migrating, the method onDispatching is invoked on the agent). We preferred not to employ this technique because it forces the programmer to adopt this style, which may be error prone. Moreover, the execution flow of an agent has to be split among many methods, and this might become hard to manage. In KLAVA the only thing that the programmer has to consider is that the entry point of a KlavaProcess is the method execute, even after a migration. Thus the programmer can implement his own technique accordingly. Aglets, by default, adopts the on-demand approach for code transmission. The automatic one (the one employed by KLAVA) is also available, but it may not be trivial to use, because it requires the programmer to be aware of some low-level details about Java's class loading and instantiation mechanisms.</p><p>µCODE <ref type="bibr" target="#b56">[57]</ref>, another Java-based mobile code toolkit, implements fine-grained mobile classes, so that single classes, instead of entire processes, can be exchanged among sites. In KLAVA the basic unit of migration and code mobility is KlavaProcess; this may cause efficiency problems when moving code due to class mobility overhead, thus requiring a different design when speed is a key concept. A finer grained mobility can be obtained in KLAVA by using the technique shown in the section about code mobility. However, as explained in the performance section, since typically a mobile process does not use many classes, the overhead is usually minimal.</p><p>Lime <ref type="bibr" target="#b57">[58]</ref> exploits the multiple tuple spaces paradigm <ref type="bibr" target="#b13">[14]</ref> to coordinate mobile agents and adds mobility to tuple spaces: it allows processes to have private tuple spaces and to transiently share them. Although in KLAVA tuple spaces are bound to nodes and nodes cannot move, processes can have objects of the class TupleSpace as data members and, hence, when processes move, TupleSpace objects move as well. However, TupleSpace objects are never shared and merged automatically.</p><p>Sumatra <ref type="bibr" target="#b4">[5]</ref> is an extension of Java that supports resource-aware mobile programs, and, in particular, includes tools for monitoring availability and quality of resources, either on demand or continuously. The monitoring can be easily performed through standard KLAVA operations, taking advantage of timeouts or non-blocking operations, to implement both synchronous and asynchronous monitoring. Like Sumatra, other systems, such as <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b58">59,</ref><ref type="bibr" target="#b59">60]</ref>, implement strong mobility in Java, by modifying the Java Virtual Machine, to access, save, and restore the execution state of threads. However, this solution can jeopardize one of the most desirable advantages of Java: portability across platforms. Indeed, one needs to run the modified version of the JVM in order to use such agents. This is the reason why we preferred not to include strong mobility in KLAVA; however, this feature is available in X-KLAIM and it is implemented on top of KLAVA by means of an appropriate precompilation phase <ref type="bibr" target="#b60">[61]</ref>.</p><p>A feature that is present in systems such as MARS, Lime, Sumatra, and T Spaces, but not in KLAVA, is the ability to react to events such as the insertion of a tuple. This could be programmed by means of a process waiting for a certain tuple, but this does not exactly implement reactions due to the nondeterminism in the selection of the process waiting for a tuple. However, one can specialize the method for a particular KLAVA operation in order to react to specific events. For instance, by specializing handleOUT (as shown in the chat system example), one can react to the presence of a tuple in the tuple space and spawn a procedure to handle such an event; furthermore, by specializing handleIN, one can avoid a certain tuple being removed from the tuple space, and possibly transform the in operation in a read <ref type="bibr" target="#b35">[36]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>void out( TupleItem i1, Locality l ) public void out( TupleItem i1, TupleItem i2, Locality l ) ... public boolean read( TupleItem i1, Locality l ) public boolean read( TupleItem i1, TupleItem i2, Locality l ) ... so that a tuple does not have to be explicitly built.The class Node also includes the methods public void eval( KlavaProcess P, Locality loc ) throws KlavaException public Locality newloc() throws KlavaException that correspond to the following basic operations:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Inter node communication through NodeHandlers.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>protected void getUsedClasses( Class c ) { if (c == null ! addUsedClass( c )) return ; Field[] fields = c.getDeclaredFields() ; Constructor[] constructors = c.getDeclaredConstructors() ; Method[] methods = c.getDeclaredMethods</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Screenshot 1 .Figure 3 .</head><label>13</label><figDesc>Figure 3. Load balancing system.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>public void sendString( String s ) { String[] clients = frame.GetSelectedNames() ; if ( clients.length &gt; 0 ) { KVector names = new KVector() ; for ( int i = 0 ; i &lt; clients.length ; i++ ) names.addElement( new KString( clients[i] ) ) ; out(new KString("PERSONAL"), names, new KString(s), chatServer) ; } else out(new KString("MESSAGE"), new KString(s), chatServer) ; } Listing 7. Sending a message to the server. Screenshot 3. ChatClient nodes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="18,107.91,436.83,381.01,183.61" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table I .</head><label>I</label><figDesc>Direct versus indirect communication of co-located/distributed nodes.</figDesc><table><row><cell></cell><cell>Indirect</cell><cell>Direct</cell></row><row><cell>Co-located</cell><cell>297 ms</cell><cell>114 ms</cell></row><row><cell>Distributed</cell><cell>3025 ms</cell><cell>2464 ms</cell></row><row><cell cols="3">Table II. Java threads versus KlavaProcess</cell></row><row><cell cols="3">objects communicating via sockets.</cell></row><row><cell>Java threads</cell><cell></cell><cell>1343 ms</cell></row><row><cell cols="2">KlavaProcess objects</cell><cell>1821 ms</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table III .</head><label>III</label><figDesc>Migrating processes with/without class code.</figDesc><table><row><cell>Processes with class code</cell><cell>427 ms</cell></row><row><cell>Processes without class code</cell><cell>293 ms</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Copyright  2002 John Wiley &amp; Sons, Ltd. Softw. Pract. Exper. 2002; 32:1365-1394</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>This work has been partially supported by the EU within the FET-Global Computing initiative project MIKADO IST-2001-32222, and by MIUR project NAPOLI. The funding bodies are not responsible for any use that might be made of the results presented here.</p><p>We thank the anonymous referees for their stimulating comments that have helped us to improve the paper.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Two main forms of agent mobility have been identified in the literature <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b24">25]</ref>:</p><p>• strong mobility: the movement of the code and of the execution state of a thread to a different site and the resumption of its execution on arrival (i.e. mobile agents automatically resume execution from the point following migration); • weak mobility: the dynamic linking of code arriving from a different site (i.e. mobile agents after migration start execution from the beginning).</p><p>Some existing mobile agent systems implementing strong mobility are Telescript <ref type="bibr" target="#b3">[4]</ref>, Agent Tcl <ref type="bibr" target="#b25">[26]</ref>, Sumatra <ref type="bibr" target="#b4">[5]</ref> and ARA <ref type="bibr" target="#b26">[27]</ref>. Systems such as TACOMA <ref type="bibr" target="#b27">[28]</ref>, Mole <ref type="bibr" target="#b28">[29]</ref> and Aglets <ref type="bibr" target="#b5">[6]</ref>, and, in general, all those systems based on Java, implement only weak mobility; this is due to the fact that Java does not permit dynamic inspection of the byte code stack and this makes it impossible to save the execution state for later use. For this reason, KLAVA can also only supply weak mobility of agents.</p><p>In addition to agent mobility, KLAVA also permits moving single parts of code: a single class can be sent to a remote site by building a generic wrapper for it, which implements the TupleItem interface, as in the following example:</p><p>The constructor takes the name of the class and stores its byte code in the field code (e.g. by using the method getClassBytes as in Listing 1). In this way a class can be sent to a remote site as follows: out( new KCode("mypackage.myclass"), l ); At the remote site this class can be retrieved with the following instructions (get_class will interact with the local class loader and create a Class object): KCode kcode = new KCode(); // formal in( kcode, self ); Class c = kcode.get class();</p><p>The on-demand approach to agent mobility can be implemented by exploiting single class mobility: agents are sent without their classes; then, at the remote site, when a class for an agent is needed it can be obtained by using a communication protocol exploiting the previous class KCode.</p><p>Downloading code from the net exposes the executing machine to security risks: the downloaded code could execute dangerous operations (maliciously or due to programming errors) that may tamper other processes or the overall system. To cope with this problem, we implemented a KlavaSecurityManager that, if activated by the node, does not allow processes downloaded from the net or sent by remote nodes to execute operations on critical system resources. Implementations of further security mechanisms that rely on the new Java security model <ref type="bibr" target="#b29">[30]</ref>  entering the system, each processor sends a number of 'credits' to the server (this number corresponds to the processor availability to perform computations on behalf of the server); the server stores the number of credits in a database and, when needed, it chooses the processor with the highest number of credits and decreases this number. The server may exhaust all credits; in that case it waits until it is notified that new credits have arrived.</p><p>When a processor receives a process, it immediately starts executing the process (in a parallel thread) and sends a credit back to the server (represented by the locality processorServer). Indeed, the Leaky Bucket Of Credits pattern is based on the heuristic that if a processor is busy, it cannot send a credit back, or at least it does not send a credit immediately. This behavior is implemented by the code fragment in Listing 3 that shows the process in the processor node taking care of receiving the processes to be executed. This process simply waits for a tuple of the form ("EXECUTE", P), where P is a formal obtained by creating a brand new KlavaProcessVar, and, by means of eval, spawns the received process for execution at the current site. A credit is sent to the server by means of out.</p><p>The server executes a ProcScheduler process that, as shown in Listing 4, whenever it receives a process sent by a client, delivers the received process to the idlest processor. The table processors is passed to the constructor of the scheduler process and it is updated by another concurrent process (not shown here) that receives tuples of the form ("CREDIT") from the processor nodes. The locality to which the process can be sent is computed by the method getHighestCredit (also not shown here) that, in case all credits for all processors are exhausted, will block the execution of the ProcScheduler until new credits arrive.</p><p>We would like to point out that the main structure of the application is represented by these few operations that, nonetheless, permit process sharing in a distributed environment. Screenshot 2 shows a ProcessorServer and three ProcessorNodes.</p><p>In KLAVA, the main computational unit is represented by a KlavaProcess, so a process is assigned to a processor as a whole and once for all: no further load balancing is performed after this assignment. Further decompositions and assignments would require that the framework supplies means frame.AddText("---" + message + " entered chat") ; frame.AddName( message.toString() ) ; } else if ( messageCode.equals("LEFT") ) { frame.AddText("---" + message + " left") ; frame.RemoveName( message.toString() ) ; } } } Listing 6. The method execute as implemented in class ChatClient.</p><p>The class ChatClient derives from the abstract class KlavaProcess and implements the method execute (Listing 6). A ChatClient object, after succeeding in entering the chat, continuously gets tuples containing messages from other clients or from the server itself and displays the messages on the user graphical interface.</p><p>When a user enters a message that has to be sent, the graphical interface will send the message to the chat server, as shown in Listing 7. Screenshot 3 shows three ChatClients. We remark that both the server and the clients are relieved from the details of sending and retrieving messages to and from the network: they use tuples and the operations supplied by KLAVA. formal model <ref type="bibr" target="#b20">[21]</ref>, some properties of systems can be formally proved <ref type="bibr" target="#b47">[48]</ref>. Indeed, a modal logic for KLAIM is being studied <ref type="bibr" target="#b48">[49]</ref> and a system to automatically prove KLAIM system properties is under development.</p><p>KLAVA is also used as the run-time system for X-KLAIM <ref type="bibr" target="#b49">[50]</ref>, a programming language obtained by extending the kernel language KLAIM with a few high-level programming constructs such as variable declarations, operations with time-out, assignments, conditionals, and sequential and iterative process composition. X-KLAIM is available on line at <ref type="bibr" target="#b46">[47]</ref>; the distribution also includes a compiler that translates X-KLAIM programs into Java classes that use KLAVA (the structure of the overall framework is illustrated in Figure <ref type="figure">4</ref>).</p><p>A number of extensions have been made to the original computation model of KLAVA. In <ref type="bibr" target="#b50">[51]</ref>, the model is enriched by transforming the underlying flat model into a hierarchical model that permits modeling structured nets, and in <ref type="bibr" target="#b51">[52,</ref><ref type="bibr" target="#b52">53]</ref> node connectivity is made explicit. We plan to implement all these new features in the near future.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related works</head><p>There are currently a number of Java packages, libraries, and frameworks that implement functionalities for programming distributed and mobile systems, and that are based on the Linda communication model. In the rest of this section, we review some of them and discuss their relationships with our system.</p><p>Jada <ref type="bibr" target="#b53">[54]</ref> is a coordination toolkit for Java where coordination and communication among distributed objects is achieved via shared ObjectSpaces that are implementations of tuple spaces. Remote access to ObjectSpaces is achieved by specifying the complete IP address and port number, i.e. no locality abstraction is used. Private ObjectSpaces can be dynamically created. Classes for representing tuples are very similar to KLAVA ones. However, no code mobility is supplied by Jada that aims at providing a coordination kernel for implementing more complex Internet languages and architectures.</p><p>MARS <ref type="bibr" target="#b35">[36]</ref> is a coordination tool for Java-based mobile agents that defines Linda-like tuple spaces programmable to react when accessed by agents. Such a mechanism can be used to control accesses to</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Programming languages for mobile code</title>
		<author>
			<persName><forename type="first">T</forename><surname>Thorn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="213" to="239" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Designing distributed applications with mobile code paradigms</title>
		<author>
			<persName><forename type="first">A</forename><surname>Carzaniga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">P</forename><surname>Picco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th International Conference on Software Engineering (ICSE&apos;97</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Taylor</surname></persName>
		</editor>
		<meeting>the 19th International Conference on Software Engineering (ICSE&apos;97</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="22" to="33" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">The Java Programming Language (3rd edn)</title>
		<author>
			<persName><forename type="first">K</forename><surname>Arnold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gosling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Holmes</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Mobile agents. Software Agents</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>White</surname></persName>
		</author>
		<editor>Bradshaw J</editor>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>AAAI Press and MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Mobile Object Systems-Towards the Programmable Internet</title>
		<author>
			<persName><forename type="first">A</forename><surname>Acharya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ranganathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Saltz</surname></persName>
		</author>
		<author>
			<persName><surname>Sumatra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Vitek</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Tschudin</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">1222</biblScope>
			<biblScope unit="page" from="111" to="130" />
			<date type="published" when="1997">1997</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
	<note>A language for resource-aware mobile programs</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Programming and Deploying Java Mobile Agents with Aglets</title>
		<author>
			<persName><forename type="first">D</forename><surname>Lange</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Oshima</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Mobile agents: Are they a good idea?</title>
		<author>
			<persName><forename type="first">C</forename><surname>Harrison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Chess</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kershenbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Research Report</title>
		<imprint>
			<date type="published" when="1994">19887. 1994</date>
			<publisher>IBM Research Division</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Mobile Object Systems-Towards the Programmable Internet</title>
		<author>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Vitek</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Tschudin</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">1222</biblScope>
			<biblScope unit="page" from="3" to="6" />
			<date type="published" when="1997">1997</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
	<note>Mobile computation</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Choosing a mobile agent messaging model. Proceedings of ISADS 2001</title>
		<author>
			<persName><forename type="first">D</forename><surname>Deugo</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>IEEE Press</publisher>
			<biblScope unit="page" from="278" to="286" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Generative communication in Linda</title>
		<author>
			<persName><forename type="first">D</forename><surname>Gelernter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="80" to="112" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">L 2 imbo: A tuple space based platform for adaptive mobile applications</title>
		<author>
			<persName><forename type="first">N</forename><surname>Davies</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wade</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Friday</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Blair</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Open Distributed Processing/Distributed Platforms (ICODP/ICDP&apos;97)</title>
		<meeting><address><addrLine>Toronto, Canada</addrLine></address></meeting>
		<imprint>
			<publisher>Chapman and Hall</publisher>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">The ShaPE of ShaDE: A coordination system</title>
		<author>
			<persName><forename type="first">S</forename><surname>Castellani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ciancarini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Rossi</surname></persName>
		</author>
		<idno>UBLCS 96-5</idno>
		<imprint>
			<date type="published" when="1996">1996</date>
			<pubPlace>Bologna, Italy</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Dipartimento di Scienze dell&apos;Informazione, Università di</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">JavaSpaces Principles, Patterns and Practice</title>
		<author>
			<persName><forename type="first">K</forename><surname>Arnold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Freeman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hupfer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Addison-Wesley: Reading, MA</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Multiple tuple spaces in Linda</title>
		<author>
			<persName><forename type="first">D</forename><surname>Gelernter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on Parallel Architectures and Languages Europe</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Odijk</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Rem</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Syre</surname></persName>
		</editor>
		<meeting>the Conference on Parallel Architectures and Languages Europe</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">89</biblScope>
			<biblScope unit="page" from="20" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Paradise: User&apos;s Guide and Reference Manual</title>
		<ptr target="http://www.lindaspaces.com/products/paradise.html" />
	</analytic>
	<monogr>
		<title level="m">Scientific Computing Associate</title>
		<meeting><address><addrLine>New Haven, CT</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Adaptive parallelism and Piranha</title>
		<author>
			<persName><forename type="first">N</forename><surname>Carriero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Freeman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gelernter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kaminsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="40" to="49" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A coordination model for agents based on secure spaces</title>
		<author>
			<persName><forename type="first">C</forename><surname>Bryce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Oriol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vitek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd International Conference on Coordination Models and Languages</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Ciancarini</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Wolf</surname></persName>
		</editor>
		<meeting>the 3rd International Conference on Coordination Models and Languages</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1594</biblScope>
			<biblScope unit="page" from="4" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Object-Based Models and Languages for Concurrent Systems</title>
		<author>
			<persName><forename type="first">N</forename><surname>Carriero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gelernter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zuck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Linda</forename><surname>Bauhaus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Ciancarini</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">O</forename><surname>Nierstrasz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Yonezawa</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">924</biblScope>
			<biblScope unit="page" from="66" to="76" />
			<date type="published" when="1995">1995</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Linda with multiple tuple spaces</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hupfer</surname></persName>
		</author>
		<author>
			<persName><surname>Melinda</surname></persName>
		</author>
		<idno>RR YALEU/DCS/R-766</idno>
		<imprint>
			<date type="published" when="1990">1990</date>
			<pubPlace>New Haven, CT</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, Yale University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Using a coordination language to specify and analyze systems containing mobile components</title>
		<author>
			<persName><forename type="first">P</forename><surname>Ciancarini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Franzè</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Mascolo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Software Engineering and Methodology</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="167" to="198" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">KLAIM: A kernel language for agents interaction and mobility</title>
		<author>
			<persName><forename type="first">R</forename><surname>De Nicola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ferrari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pugliese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="315" to="330" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">How to write parallel programs: A guide to the perplexed</title>
		<author>
			<persName><forename type="first">N</forename><surname>Carriero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gelernter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="323" to="357" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Personal disconnected operations with mobile agents</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Reichl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd Workshop on Personal Wireless Communications, PWC&apos;98</title>
		<meeting>the 3rd Workshop on Personal Wireless Communications, PWC&apos;98<address><addrLine>Tokyo</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Analyzing mobile code languages</title>
		<author>
			<persName><forename type="first">G</forename><surname>Cugola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ghezzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">P</forename><surname>Picco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Vitek</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Tschudin</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">1222</biblScope>
			<date type="published" when="1997">1997</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Mobile Object Systems-Towards the Programmable Internet</note>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">How to migrate agents</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hohlfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">S</forename><surname>Yee</surname></persName>
		</author>
		<ptr target="http://www.cs.ucsd.edu/˜bsy" />
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A safe Tcl toolkit for electronic meeting places</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Y</forename><surname>Levy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">K</forename><surname>Ousterhout</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st USENIX Workshop of Electronic Commerce</title>
		<meeting>the 1st USENIX Workshop of Electronic Commerce<address><addrLine>Berkeley, CA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="133" to="135" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">The architecture of the Ara platform for mobile agents</title>
		<author>
			<persName><forename type="first">H</forename><surname>Peine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Stolpmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st International Workshop on Mobile Agents (MA&apos;97</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Rothermel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Popescu-Zeletin</surname></persName>
		</editor>
		<meeting>the 1st International Workshop on Mobile Agents (MA&apos;97</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1219</biblScope>
			<biblScope unit="page" from="50" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">What TACOMA taught us. Mobility, Mobile Agents and Process Migration-An Edited Collection</title>
		<author>
			<persName><forename type="first">D</forename><surname>Johansen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">B</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Van Renesse</surname></persName>
		</author>
		<editor>Milojicic D, Douglis F, Wheeler R</editor>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>Addison-Wesley: Reading, MA</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Mole-a Java based mobile agent system</title>
		<author>
			<persName><forename type="first">M</forename><surname>Straßer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Baumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Hohl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd ECOOP Workshop on Mobile Object Systems</title>
		<meeting>the 2nd ECOOP Workshop on Mobile Object Systems<address><addrLine>Austria</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996">1996</date>
		</imprint>
		<respStmt>
			<orgName>University of Linz</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Inside Java 2 Platform Security: Architecture, API Design, and Implementation</title>
		<author>
			<persName><forename type="first">L</forename><surname>Gong</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Addison-Wesley: Reading, MA</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Types as specifications of access policies. Secure Internet Programming: Security Issues for Distributed and Mobile Objects</title>
		<author>
			<persName><forename type="first">R</forename><surname>De Nicola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ferrari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pugliese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Vitek</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Jensen</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">1603</biblScope>
			<biblScope unit="page" from="117" to="146" />
			<date type="published" when="1999">1999</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Types for access control</title>
		<author>
			<persName><forename type="first">R</forename><surname>De Nicola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ferrari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pugliese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Venneri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">240</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="215" to="254" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">A middleware for secure distributed tuple spaces</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bettini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">De</forename><surname>Nicola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename></persName>
		</author>
		<ptr target="http://music.dsi.unifi.it/papers.html" />
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Fault-tolerant telecommunication system patterns. Pattern Languages of Program Design 2, Vlissides</title>
		<author>
			<persName><forename type="first">M</forename><surname>Adams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Coplien</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gamoke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hanmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Keeve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nicodemus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">MA</title>
		<editor>
			<persName><forename type="first">Coplien</forename><surname>Jm</surname></persName>
		</editor>
		<editor>
			<persName><surname>Jo</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="page" from="549" to="562" />
			<date type="published" when="1996">1996</date>
			<publisher>Addison-Wesley: Reading</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Mobile ambients</title>
		<author>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gordon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundations of Software Science and Computation Structures (FoSSaCS&apos;98</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1378</biblScope>
			<biblScope unit="page" from="140" to="155" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<author>
			<persName><forename type="first">G</forename><surname>Cabri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Leonardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Zambonelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Reactive tuple spaces for mobile agent coordination Proceedings of the 2nd International Workshop on Mobile Agents</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Rothermel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Hohl</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1477</biblScope>
			<biblScope unit="page" from="237" to="248" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Interrogazione di database distribuiti XML con agenti mobili</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ianett</surname></persName>
		</author>
		<author>
			<persName><surname>Tql</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
		<respStmt>
			<orgName>Dipartimento di Informatica, Università di Pisa</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Master&apos;s Thesis</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">TQL algebra and its implementation</title>
		<author>
			<persName><forename type="first">G</forename><surname>Conforti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Ferrara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ghelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd IFIP International Conference on Theoretical Computer Science</title>
		<meeting>the 2nd IFIP International Conference on Theoretical Computer Science<address><addrLine>Montreal, Canada</addrLine></address></meeting>
		<imprint>
			<publisher>Kluwer</publisher>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Coordinating processes with secure spaces</title>
		<author>
			<persName><forename type="first">J</forename><surname>Vitek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bryce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Oriol</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<ptr target="http://java.sun.com/products/jdk/rmi" />
		<title level="m">RMI, Remote Method Invocation</title>
		<imprint/>
		<respStmt>
			<orgName>Sun Microsystems</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Optimizing analysis for first-class tuple-spaces</title>
		<author>
			<persName><forename type="first">S</forename><surname>Jagannathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Languages and Compilers for Parallel Processing</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Gelernter</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Gross</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Padua</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename></persName>
		</editor>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Extension of strand with Linda-like operations. Implementation and performance study</title>
		<author>
			<persName><forename type="first">G</forename><surname>Czajkowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Zieliński</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Practical Implementations and Systems Experience in Logic Programming</title>
		<meeting>the Workshop on Practical Implementations and Systems Experience in Logic Programming<address><addrLine>Budapest, Hungary</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer and Information Science, University of Oregon</orgName>
		</respStmt>
	</monogr>
	<note>Tick E (ed.</note>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">Dynamic optimizations in Linda systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kaxiras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Schoinas</surname></persName>
		</author>
		<ptr target="http://www.cs.wisc.edu/˜kaxiras" />
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">An efficient distributed tuple space implementation for networks of workstations</title>
		<author>
			<persName><forename type="first">A</forename><surname>Rowstron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EuroPar</title>
		<editor>
			<persName><forename type="first">L</forename><surname>Bouge</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Fraigniaud</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Mignotte</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Y</forename><surname>Robert</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">96</biblScope>
			<biblScope unit="page" from="511" to="513" />
			<date type="published" when="1996">1996</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title level="m" type="main">Compiler analysis and optimization of Linda programs for distributed-memory systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Fenwick</surname><genName>Jr</genName></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
		<respStmt>
			<orgName>University of Delaware</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD Thesis</note>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Proving the correctness of optimising destructive and non-destructive reads over tuple spaces</title>
		<author>
			<persName><forename type="first">R</forename><surname>De Nicola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pugliese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ait</forename><surname>Rowstron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Coordination 2000</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Porto</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G-C</forename><surname>Roman</surname></persName>
		</editor>
		<meeting>Coordination 2000<address><addrLine>Cyprus</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1906</biblScope>
			<biblScope unit="page" from="66" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Concurrency and Mobility Group at Dipartimento di Sistemi e Informatica, Università di Firenze</title>
		<ptr target="http://music.dsi.unifi.it" />
	</analytic>
	<monogr>
		<title level="m">KLAIM Web page</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Formalizing properties of mobile agent systems</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bettini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">De</forename><surname>Nicola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Loreti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Coordination Models and Languages</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Arbarb</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Talcott</surname></persName>
		</editor>
		<meeting>Coordination Models and Languages</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2315</biblScope>
			<biblScope unit="page" from="72" to="87" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">A modal logic for KLAIM</title>
		<author>
			<persName><forename type="first">R</forename><surname>De Nicola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Loreti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Conference on Algebraic Methodology and Software Technology, AMAST 2000</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Rus</surname></persName>
		</editor>
		<meeting>the 8th International Conference on Algebraic Methodology and Software Technology, AMAST 2000</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1816</biblScope>
			<biblScope unit="page" from="339" to="354" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Interactive mobile agents in X-KLAIM</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bettini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">De</forename><surname>Nicola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ferrari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Pugliese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 7th International IEEE Workshops on Enabling Technologies: Infrastructure for Collaborative Enterprises</title>
		<editor>
			<persName><forename type="first">)</forename><surname>Wetice</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Ciancarini</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Tolksdorf</surname></persName>
		</editor>
		<meeting>7th International IEEE Workshops on Enabling Technologies: Infrastructure for Collaborative Enterprises</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="110" to="115" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Structured nets in KLAIM</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bettini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Loreti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pugliese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SAC 2000, Special Track on Coordination Models, Languages and Applications</title>
		<editor>
			<persName><forename type="first">I</forename></persName>
		</editor>
		<editor>
			<persName><forename type="first">Carroll</forename><forename type="middle">J</forename><surname>Damiani</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Haddad</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Oppenheim</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename></persName>
		</editor>
		<meeting>ACM SAC 2000, Special Track on Coordination Models, Languages and Applications</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="174" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Modelling node connectivity in dynamically evolving networks</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bettini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Loreti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pugliese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CONCOORD, International Workshop on Concurrency and Coordination</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<meeting>CONCOORD, International Workshop on Concurrency and Coordination<address><addrLine>Lipari Island, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">54</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">An infrastructure language for open nets</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bettini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Loreti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pugliese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SAC 2002, Special Track on Coordination Models, Languages and Applications</title>
		<meeting>ACM SAC 2002, Special Track on Coordination Models, Languages and Applications</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="373" to="377" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Mobile Object Systems-Towards the Programmable Internet</title>
		<author>
			<persName><forename type="first">P</forename><surname>Ciancarini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Rossi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Vitek</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Tschudin</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">1222</biblScope>
			<biblScope unit="page" from="213" to="228" />
			<date type="published" when="1997">1997</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
	<note>Jada-coordination and communication for Java agents</note>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<title level="m" type="main">The Jini Specification</title>
		<author>
			<persName><forename type="first">K</forename><surname>Arnold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>'sullivan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Scheifler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Waldo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wollrath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">D</forename><surname>Ford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lehman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mclaughry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">T</forename><surname>Wyckoff</surname></persName>
		</author>
		<author>
			<persName><surname>Spaces</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM Systems Journal</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="454" to="474" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">P</forename><surname>Picco</surname></persName>
		</author>
		<author>
			<persName><surname>Μcode</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">A lightweight and flexible mobile code toolkit. Proceedings of the 2nd International Workshop on Mobile Agents</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Rothermel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Hohl</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1477</biblScope>
			<biblScope unit="page" from="160" to="171" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">LIME: Linda meets mobility</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">P</forename><surname>Picco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Murphy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G-C</forename><surname>Roman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st International Conference on Software Engineering (ICSE&apos;99</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Garlan</surname></persName>
		</editor>
		<meeting>the 21st International Conference on Software Engineering (ICSE&apos;99</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="368" to="377" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Pickling threads state in the Java system</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bouchenak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Hagimont</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Technology of Object-Oriented Languages and Systems (TOOLS)</title>
		<meeting>the Technology of Object-Oriented Languages and Systems (TOOLS)<address><addrLine>St. Malo, France</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Network-aware mobile programs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ranganathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Acharya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Saltz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Annual Technical Conference. USENIX Association</title>
		<meeting>the USENIX Annual Technical Conference. USENIX Association</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="91" to="103" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Translating strong mobility into weak mobility</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bettini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">De</forename><surname>Nicola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th IEEE International Conference on Mobile Agents</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Picco</surname></persName>
		</editor>
		<meeting>the 5th IEEE International Conference on Mobile Agents<address><addrLine>MA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001. 2001</date>
			<biblScope unit="volume">2240</biblScope>
			<biblScope unit="page" from="182" to="197" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Ltd. Softw. Pract. Exper</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="1365" to="1394" />
			<date type="published" when="2002">2002. 2002</date>
			<publisher>John Wiley &amp; Sons</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
