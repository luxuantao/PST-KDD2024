<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Spooky Encryption and Its Applications</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Yevgeniy</forename><surname>Dodis</surname></persName>
							<email>dodis@cs.nyu.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">NYU</orgName>
								<address>
									<settlement>New York</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Shai</forename><surname>Halevi</surname></persName>
							<email>shaih@alum.mit.edu</email>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">IBM Research</orgName>
								<orgName type="institution" key="instit2">Yorktown Heights</orgName>
								<address>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ron</forename><forename type="middle">D</forename><surname>Rothblum</surname></persName>
							<email>rothblum@gmail.com</email>
							<affiliation key="aff2">
								<orgName type="institution">MIT</orgName>
								<address>
									<settlement>Cambridge</settlement>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Daniel</forename><surname>Wichs</surname></persName>
							<email>danwichs@gmail.com</email>
							<affiliation key="aff3">
								<orgName type="institution">Northeastern University</orgName>
								<address>
									<settlement>Boston</settlement>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Spooky Encryption and Its Applications</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">306ACFD93ED2DCDBF035DBC3231C9B37</idno>
					<idno type="DOI">10.1007/978-3-662-53015-3</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:24+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Consider encrypting n inputs under n independent public keys. Given the ciphertexts {ci = Enc pk i (xi)}i, Alice outputs ciphertexts c 1 , . . . , c n that decrypt to y1, . . . , yn respectively. What relationships between the xi's and yi's can Alice induce?</p><p>Motivated by applications to delegating computations, Dwork et al. <ref type="bibr" target="#b11">[11]</ref> showed that a semantically secure scheme disallows signaling in this setting, meaning that yi cannot depend on xj for j = i. On the other hand if the scheme is homomorphic then any local (component-wise) relationship is achievable, meaning that each yi can be an arbitrary function of xi. However, there are also relationships which are neither signaling nor local. Dwork et al. asked if it is possible to have encryption schemes that support such "spooky" relationships. Answering this question is the focus of our work.</p><p>Our first result shows that, under the LWE assumption, there exist encryption schemes supporting a large class of "spooky" relationships, which we call additive function sharing (AFS) spooky. In particular, for any polynomial-time function f , Alice can ensure that y1, . . . , yn are random subject to n i=1 yi = f (x1, . . . , xn). For this result, the public keys all depend on common public randomness. Our second result shows that, assuming sub-exponentially hard indistinguishability obfuscation (iO) (and additional more standard assumptions), we can remove the common randomness and choose the public keys completely independently. Furthermore, in the case of n = 2 inputs, we get a scheme that supports an even larger class of spooky relationships.</p><p>We discuss several implications of AFS-spooky encryption. Firstly, it gives a strong counter-example to a method proposed by Aiello et al. [1]   for building arguments for NP from homomorphic encryption. Secondly, it gives a simple 2-round multi-party computation protocol where, at the end of the first round, the parties can locally compute an additive secret sharing of the output. Lastly, it immediately yields a function secret sharing (FSS) scheme for all functions.</p><p>We also define a notion of spooky-free encryption, which ensures that no spooky relationship is achievable. We show that any nonmalleable encryption scheme is spooky-free. Furthermore, we can construct spooky-free homomorphic encryption schemes from SNARKs, and</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Imagine Alice and Bob, standing on different planets light years apart. They are "simultaneously" given some input bits x 1 and x 2 respectively, and must answer by outputting bits y 1 and y 2 respectively. Classical physics allows them to implement local (component-wise) strategies where y 1 is an arbitrary function of x 1 and y 2 is a function of x 2 . On the other hand, the impossibility of faster-thanlight communication disallows signaling strategies, meaning that the distribution of y 1 cannot depend on the value of x 2 and vice versa.</p><p>However, there are strategies that are neither local nor signaling. For example, perhaps Alice and Bob want to ensure that y 1 , y 2 are random bits subject to y 1 ⊕ y 2 = x 1 ∧ x 2 . In this case, the distribution of y 1 does not depend on x 2 (and vice versa) so the strategy is not signaling, but it's also not local. Surprisingly some such strategies which are neither signaling nor local are achievable using quantum mechanics, if Alice and Bob share an entangled quantum state. Einstein referred to this phenomenon as "spooky action at a distance".</p><p>In this work, we consider an analogous scenario, first considered by Dwork et al. <ref type="bibr" target="#b11">[11]</ref>, where the separation between x 1 , x 2 is enforced not via physical distance but by encrypting these bits under two independent public keys. <ref type="foot" target="#foot_0">1</ref> Here Alice gets the two ciphertexts c 1 ← Enc pk 1 (x 1 ), c 2 ← Enc pk 2 (x 2 ), and outputs two other ciphertexts c 1 , c 2 which are decrypted as y i ← Dec ski (c i ), i = 1, 2. As in the physical analogy, here too we can rule out signaling strategies (if the encryption is semantically secure), and can implement local strategies (if the encryption is homomorphic). But can we replace the entangled state from above by a special "spooky encryption scheme" that would allow Alice to implement spooky strategies? Answering this question is the focus of this work, and we obtain the following results:</p><p>-Assuming the hardness of learning with errors (LWE), there exists a secure encryption scheme in which Alice can implement a wide class of spooky strategies that we call additive function sharing (AFS) spooky. Namely, for any two-argument function f : ({0, 1} * ) 2 → {0, 1}, Alice can convert encryption of inputs c i ← Enc pk i (x i ) to encryption of outputs y i ← Dec ski (c i ), ensuring that y 1 ⊕ y 2 = f (x 1 , x 2 ), except for a small error probability. This construction, described in Sect. 3, uses the LWE-based multi-key FHE schemes from <ref type="bibr" target="#b7">[7,</ref><ref type="bibr" target="#b22">22,</ref><ref type="bibr" target="#b26">26]</ref>, and it inherits from these multi-key scheme their dependence on a common random string. -In Sect. 4 we describe a spooky scheme that supports arbitrary two-input spooky relations on short inputs, as well as a very wide class of two-input spooky relations on long inputs. This construction uses probabilistic indistinguishability obfuscation (piO), which is an extension of iO to probabilistic circuits recently introduced by Canetti et al. <ref type="bibr" target="#b6">[6]</ref>, in conjunction with lossy encryption schemes which are homomorphic and ensure circuit privacy against malicious adversaries. This construction works in the plain model without common-random string and has no error, and it can be realized based on exponentially strong iO, exponentially strong PRFs, and DDH. -In Sect. 5 we describe a transformation from a scheme that supports only twoinput spooky relations on one-bit inputs to one that supports AFS spooky relations on arbitrary number of inputs (of arbitrarily length each). This transformation can be applied to both our LWE-based and piO-based constructions from above. -We show several implications of (AFS-)spooky encryption. On a negative, it gives a strong counter-example to a method proposed by Aiello et al. <ref type="bibr">[1]</ref> for building succinct arguments for NP from homomorphic encryption <ref type="foot" target="#foot_1">2</ref> , resolving a question posted by <ref type="bibr" target="#b11">[11]</ref>. On a positive, it immediately yields a function secret sharing (FSS) scheme for all functions <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b15">15]</ref>, and also gives a simple 2-round multi-party computation protocol where, at the end of the first round, the parties can locally compute an additive secret sharing of the output. These application are discussed in Sect. 6. -We also study in Sect. 7 the concept of spooky free encryption, i.e., an encryption scheme where we can prove that no spooky strategy is feasible. We show that any non-malleable encryption scheme is spooky-free, and also build spooky-free homomorphic encryption schemes from SNARKs. It remains an open problem to construct spooky-free homomorphic encryption under more standard assumptions. Spooky-free homomorphic encryption can be used to instantiate the approach of Aiello et al. to get succinct arguments for NP.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Technical Overview</head><p>LWE-Based Construction. Our LWE-based construction builds on the multikey FHE schemes from <ref type="bibr" target="#b7">[7,</ref><ref type="bibr" target="#b22">22,</ref><ref type="bibr" target="#b26">26]</ref>. In these schemes (after some syntactic massaging) secret keys and single-key ciphertexts are vectors in Z n q , and decryption consists of computing w = s, c mod q, then rounding to the nearest multiple of q/2, outputting zero if w is closer to 0 or one if w is closer to q/2.</p><p>These schemes, however, also support homomorphic computation across ciphertexts relative to different keys. Roughly, they feature a "lifting procedure" where a dimension-n ciphertext vector relative to one key s i is "lifted" to a dimension n vector c = (c 1 , . . . , c ) relative to the concatenated key s = (s 1 , . . . , s ) of dimension n. These lifted ciphertexts can still be computed on, and the decryption procedure proceeds just as before, except using the higher-dimension vectors. Namely, to decrypt c using s , one first computes the inner product w = s , c modulo q, then rounds to the nearest multiple of q/2. In other words, we compute the individual inner products w i = s i , c i , then add them all up and round to the nearest multiple of q/2.</p><p>We observe (cf. Lemma 1) that for the special case of two keys, = 2, instead of adding the w i 's and then rounding, we can first round each w i to the nearest multiple of q/2 and then add, and this yields the same result with high probability. Specifically, the error probability is proportional to the rounding error for the overall sum w . This observation immediately yields additive function sharing (AFS) spooky encryption for two-argument functions: We use one of the schemes from <ref type="bibr" target="#b7">[7,</ref><ref type="bibr" target="#b22">22,</ref><ref type="bibr" target="#b26">26]</ref> to encrypt the two arguments x 1 , x 2 under two keys, then use the multi-key evaluation procedure to compute a multi-key ciphertext c = (c 1 , c 2 ) encrypting the value f (x 1 , x 2 ). Viewing each c i as a single-key ciphertext, we apply the usual decryption procedure to each of them, and the resulting two bits are an additive secret sharing of f (x 1 , x 2 ), except with a small error probability. The error probability can be made negligible by relying on LWE with a super-polynomial approximation factor. piO-Based Construction. In Sect. 4 we show that using iO we can construct an AFS encryption scheme without CRS and without errors, and moreover we can support arbitrary spooky relations on two bits, not just additive sharing. For this overview, let us focus on the simpler task of constructing AFS spooky scheme for the multiplication function</p><formula xml:id="formula_0">MULT(b 1 , b 2 ) = b 1 • b 2 .</formula><p>The starting point of the construction takes a homomorphic encryption scheme (Gen, Enc, Dec, Eval) and adds to the public key an obfuscation of the randomized functionality that decrypts, computes the functions f , and re-encrypts secretsharing of the result. Specifically, let us denote for any</p><formula xml:id="formula_1">x 1 , y 1 ∈ {0, 1} the function f x1,y1 (x 2 ) = x 1 • x 2 ⊕ y 1 ,</formula><p>and consider the following randomized program:</p><formula xml:id="formula_2">Program P sk1,pk 1 (c 1 , pk 2 , c 2 ) 1. y 1 ← {0, 1}. 4 .c 2 = Eval(pk 2 , f x1,y1 , c 2 ). 2. c 1 ← Enc pk 1 (y 1 ). 5. Output (c 1 , c 2 ). 3. x 1 = Dec sk1 (c 1 ).</formula><p>Given the two pairs (pk 1 , Enc pk 1 (x 1 )), (pk 2 , Enc pk 2 (x 2 )), and access to the program P sk1,pk 1 , we can run P sk1,pk 1 (c 1 , pk 2 , c 2 ) to get two ciphertexts c 1 and c 2 , encrypting y 1 , y 2 , respectively, such that y 1 ⊕ y 2 = x 1 • x 2 . We would like, therefore, to add an obfuscation of P sk1,pk 1 to the public key, thereby obtaining AFS spooky multiplication.</p><p>As described, however, this construction is not even secure when P sk1,pk 1 (c 1 , pk 2 , c 2 ) is only accessed by a perfect black box. The reason is that if the underlying homomorphic encryption is not circuit private, then the evaluated ciphertext c 2 could leak information about x 1 . To fix this issue, we require the use of circuit-private homomorphic encryption in this construction. In fact, since the adversary could run the program P sk1,pk 1 (c 1 , pk 2 , c 2 ) on arbitrary inputs of its choice, we need a stronger notion of circuit privacy against malicious adversaries <ref type="bibr" target="#b24">[24]</ref>, that guarantees privacy even if the public-key and ciphertext given to the evaluation algorithm are generated adversarially.</p><p>Using a malicious circuit private homomorphic encryption scheme, the construction above would be secure if the program P sk1,pk 1 (c 1 , pk 2 , c 2 ) is accessed as a perfect black box (e.g., using VBB obfuscation). However, we would like to rely on the weaker notion of indistinguishability obfuscation (iO), or rather probabilistic iO <ref type="bibr" target="#b6">[6]</ref> (since we are dealing with a randomized program). We need to somehow argue that the secret key sk 1 that is encoded within the program P sk1,pk 1 is hidden by the weaker obfuscation, and we do it using a technique from the work of Canetti et al. <ref type="bibr" target="#b6">[6]</ref>, employing a lossy encryption scheme.</p><p>We note that the construction above only uses homomorphic computations for single-bit functions (in addition to probabilistic iO), and there are only four such function (identity, negation, constant 0 and constant 1). A secure and malicious-circuit-private encryption scheme that supports these operations was constructed by Naor and Pinkas <ref type="bibr" target="#b23">[23]</ref> based on the DDH assumption.</p><p>From 2-Spooky to n-Spooky. Both the LWE and piO based constructions above only support two-argument spooky relations. Specifically the LWE-based scheme only supports AFS-spooky relations for two-argument functions, and the piO-based scheme supports a large class of spooky relations but again, only on two inputs. We extend the supported spooky relations by showing how to transform a scheme that supports (multiple hops of) AFS-spooky two-input multiplication and single-key additive homomorphism, into a leveled AFS spooky scheme for any number of inputs of any length.</p><p>The transformation is inspired by the Goldreich-Micali-Wigderson MPC protocol <ref type="bibr" target="#b16">[16]</ref>: Suppose that we are given n public keys pk 1 , . . . , pk n , bit-bybit encryptions of the input values Enc pk i (x i ), and an arithmetic circuit C : ({0, 1} * ) n → {0, 1} that we want to evaluate (i.e., to produce encrypted shares of C(x 1 , . . . , x n )). We process the circuit gate by gate, while maintaining the invariant that for every wire w we produce ciphertexts Enc pk 1 (w 1 ), . . . , Enc pk n (w n ) such that ⊕ i∈ <ref type="bibr">[n]</ref> w i is equal to the wire w's value. The wires are processed inductively:</p><p>1. For an input wire holding a bit b, which is part of the j'th input x j , we take the ciphertext c that encrypts b relative to pk j , and append to it the ciphertexts c i ← Enc pk i (0) for all i = j. Clearly the ciphertexts (c 1 , . . . , c j-1 , c, c j+1 , . . . , c n ) are encryptions of an additive sharing of the wire's value b. </p><formula xml:id="formula_3">Enc pk i (x i,j ), Enc pk j (y i,j ) ← SpookyMult Enc pk i (u i ), Enc pk j (u j ) , such that x i,j ⊕ y i,j = u i • v j .</formula><p>Then we collapse this tensor product back into an n-vector using the additive homomorphism relative to each key separately.</p><p>That is, for every i ∈ [n] we can compute a ciphertext Enc pk i (w i ) such that w i = j∈ <ref type="bibr">[n]</ref> x i,j ⊕ j∈[n] y j,i . We observe that these ciphertexts form a secret sharing of u • v. Indeed, adding up the plaintexts we get:</p><formula xml:id="formula_4">i∈[n] ⎛ ⎝ j∈[n] x i,j ⊕ j∈[n] z j,i ⎞ ⎠ = i,j∈[n] (x i,j ⊕ y i,j ) = i,j∈[n] u i • v j = ( i u i ) • ( j v j )<label>(1)</label></formula><p>Thus, if the scheme can support 2d interleaved hops of (two-key) spooky multiplication and (single-key) additive homomorphism then it is an AFS-spooky scheme for the class of all depth d arithmetic circuits. We note that the resulting scheme does not depend on the number of inputs or their length, and it only depends on the complexity of C inasmuch as the underlying scheme depends on the depth of the evaluated circuit.</p><p>Applications of Spooky Encryption. In Sect. 6 we describe both positive and negative applications of spooky encryption. On the positive, it immediately yields a function secret sharing (FSS) scheme for all functions <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b15">15]</ref>. Previously such a general function secret sharing scheme was only known to follow from sub-exponentially hard indistinguishability obfuscation <ref type="bibr" target="#b4">[4]</ref> whereas we can base it on LWE (using our LWE based spooky encryption).</p><p>Spooky encryption also gives a simple 2-round multi-party computation protocol. Roughly, AFS-spooky encryption lets each party broadcast an encryption of its input under its own key, then everyone individually performs the AFSspooky evaluation locally, each party can locally decrypt and recover a share of the output, and the output is recover using another round of communication. There are some technicalities that should be addressed for this idea to work, and perhaps the easiest way of addressing them is to use AFS-spooky encryption to construct multi-key FHE with threshold decryption (TMFHE), which can then be used to get a two-round protocol as done in <ref type="bibr" target="#b22">[22]</ref>. Using our obfuscation based construction (which does not require a CRS), this gives the first 2-round semi-honest secure MPC protocol in the plain model. <ref type="foot" target="#foot_2">3</ref>On the negative side, AFS-spooky encryption yields a counter-example for the transformation of Aiello et al. <ref type="bibr">[1]</ref> from multi-prover (MIP) to single-prover protocols. Their idea was to send all of the MIP queries to a single prover, but encrypted under independents keys of a homomorphic encryption scheme. The single prover can homomorphically implement the actions of the MIP provers on the individual encrypted queries, and hopefully the fact that the queries are encrypted under independent keys means that no cross-influence is possible. It is easy to see that spooky encryption violates this hope (by its very nature). Moreover, we show that this transformation can lead to a total break of soundness -in Sect. 6.1 we show how using AFS-spooky encryption can lead to an unsound single-prover protocol, when the transformation is applied to a simple two-prover protocol for graph 3-colorability.</p><p>Spooky-Free Encryption. Finally, in Sect. 7 we discuss the notion of spookyfree (SF) encryption, which provably ensures that any correlation that an attacker can induce between the original messages (m 1 , . . . , m n ) and "tampered messages" (m 1 , . . . , m n ), can be simulated by a "local simulator" that produces m i only as a function of m i (and some shared randomness), see Definition 6. To validate this definition, we show that a spooky-free FHE suffices to prove the security of the natural approach of Aiello et al. <ref type="bibr">[1]</ref>, which was discussed above, of converting a succinct MIP into a succinct one-round argument discussed above. Indeed, spooky-freeness ensures that the attacker cannot cause more damage from seeing all n ciphertexts than what it could have done by seeing each plaintext independently.</p><p>We then turn to the systematic study of spooky-free encryption. First, we show that spooky-freeness implies semantic security. On the other hand, a very weak form of non-malleability (called 1-non-malleability here, or 1-bounded CCA security in <ref type="bibr" target="#b8">[8]</ref>) implies spooky-freeness. However, since the scheme is nonmalleable, it is inherently not homomorphic and so we cannot use it to obtain a delegation scheme via the foregoing approach.</p><p>Indeed, to instantiate the approach of Aiello et al. constructing succinct arguments for NP, we need a homomorphic encryption scheme which is spooky free. As a proof of concept, in the full paper <ref type="bibr" target="#b9">[9]</ref> we show how to built such a homomorphic spooky-free encryption using succinct non-interactive arguments of knowledge (SNARKs <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b14">14]</ref>), true-simulation-extractable NIZKs <ref type="bibr" target="#b10">[10]</ref> and regular FHE. While the use of SNARKs makes this construction uninteresting in the application to succinct arguments, the clean definition of SF-encryption, coupled with our "proof of concept" implementation, might open the door for more useful future constructions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Related Work</head><p>The starting point for this line of work is the natural approach, suggested by Aiello et al. <ref type="bibr">[1]</ref>, for constructing a secure delegation scheme by combining a multiprover interactive proof-system (MIP) with a homomorphic encryption scheme as described above. This intuition was questioned by Dwork et al. <ref type="bibr" target="#b11">[11]</ref> and our work confirms that the approach of <ref type="bibr">[1]</ref> is not always secure.</p><p>An approach to overcoming this barrier was taken by Kalai et al. <ref type="bibr" target="#b18">[18,</ref><ref type="bibr" target="#b19">19]</ref>. They designed a specific MIP (for P) that is sound even against arbitrary nosignaling adversaries. Since semantic-security rules out signaling strategies, they obtain a secure delegation protocol for any language in P.</p><p>Spooky Free vs. Homomorphism Extraction. Bitansky and Chiesa defined in <ref type="bibr" target="#b2">[2]</ref> a security notion called homomorphism extraction, that they show can be used to securely instantiate the construction of Aiello et al. and get succinct arguments for NP. Intuitively, this notion says that to produce a valid encryption of m from an encryption of m, you must know a function f such that m = f (m). Compared to our notion of spooky-free (which is also sufficient for the Aiello et al. transformation), the main difference is that of "extraction vs. soundness", so homomorphism extraction seems a stronger requirement. For example, homomorphism extraction implies some form of "plaintext awareness" and therefore is non-trivial even for schemes that aren't homomorphic, whereas we show that any non-malleable encryption scheme is spooky-free.</p><p>Multi-key FHE. A notion that is related to spooky-encryption, introduced by López-Alt et al. <ref type="bibr" target="#b21">[21]</ref> is that of multi-key FHE. In a multi-key FHE, similarly to a spooky encryption scheme, the homomorphic evaluation procedure gets as input n ciphertexts encrypted under different keys. The difference is that the output of the evaluation in a multikey FHE is a single ciphertext that can only be decrypted by combining all the n keys. In contrast, in a spooky encryption scheme the result of the spooky evaluation is n ciphertexts, c 1 , . . . , c n where each c i is encrypted under the i th original. Thus, spooky encryption can be thought of as a specific type of multi-key FHE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Definitions</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Local, No-Signaling, and Spooky Relations</head><p>We say that two distributions</p><formula xml:id="formula_5">D 1 , D 2 over a (finite) universe U are ε-close if their statistical distance 1 2 ||D 1 -D 2 || 1 is at most ε, and denote it by D 1 ε ≈ D 2 .</formula><p>We write D 1 ≡ D 2 to denote that the distributions are identical. We say that D 1 , D 2 are δ-far if their statistical distance is at least δ.</p><formula xml:id="formula_6">Definition 1. Let f : {0, 1} 1 × • • • {0, 1} n → {0, 1} 1 × • • • {0,</formula><p>1} n be a randomized mapping from n input to n outputs. For input x = (x 1 , . . . , x n ) to f , we denote the i'th component of the output by f (x) i , and more generally for a subset I ⊂ [n] we denote the projected input by x I = (x i : i ∈ I) and the projected output by f (x</p><formula xml:id="formula_7">) I = (f (x) i : i ∈ I). -f is local if there exist n randomized "component mappings" f i : {0, 1} i → {0, 1} i such that for all (x 1 , . . . , x n ) ∈ {0, 1} 1 × • • • {0, 1} n , the distribution f (x 1 , . . . , x n ) is a product distribution f (x 1 , . . . , x n ) ≡ f 1 (x 1 ) × • • • × f n (x n ). -f is no-signaling if for every subset I ∈ [n]</formula><p>and every two inputs x, x with the same I projection, x I = x I , the corresponding projected distributions are equal, f (x) I ≡ f (x ) I . -We say that f is ε-spooky for some ε &gt; 0 if it is no-signaling, but for every local f there exists some input x such that f (x) and f (x) are at least ε-far.</p><p>These definitions extends to an ensemble of mappings F = {f k : k ∈ N}, with the mapping parameters n, i , i and the distance bound ε possibly depending on the ensemble parameter k. In this case we say that F is spooky if the f k 's are ε-spooky for a non-negligible ε = ε(k).</p><p>As an example, consider the randomized function f (x 1 , x 2 ) = (y 1 , y 2 ) where y 1 , y 2 are uniformly random subject to y 1 ⊕ y 2 = x 1 ∧ x 2 . This function is no-signaling since the distributions f (x) 1 and f (x) 2 are individually uniform, no matter what x is. However, it's easy to show that for any local function</p><formula xml:id="formula_8">f = (f 1 , f 2 ) there is an input x = (x 1 , x 2 ) such that Pr[f 1 (x 1 ) ⊕ f 2 (x 2 ) = x 1 ∧ x 2 ] ≤ 1/2. Therefore the function f is ε-spooky for ε = 1/2.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Spooky Encryption</head><p>A public-key encryption scheme consists of a tuple (Gen, Enc, Dec) of polynomialtime algorithms. The key-generation algorithm Gen gets as input a security parameter κ ∈ N and outputs a pair of public/private keys (pk, sk). The encryption algorithm Enc gets as input the public-key pk and a bit m ∈ {0, 1} poly(κ) and outputs a ciphertext c, whereas the decryption algorithm Dec gets as input the private-key sk and the ciphertext c and outputs the plaintext bit m. The basic correctness guarantee is that Pr[Dec sk (Enc pk (m)) = m] &gt; 1negl(k), where the probability is over the randomness of all these algorithms. The security requirement is that for every pair of polynomial-sized adversaries (A 1 , A 2 ) it holds that Pr</p><formula xml:id="formula_9">(pk,sk)←Gen(1 κ ) b←{0,1} (m 0 , m 1 ) ← A 1 (pk) s.t. |m 0 | = |m 1 | A 2 (pk, Enc pk (m b )) = b ≤ 1 2 + negl(κ).</formula><p>If the message space consists of just a single bit then we say that the scheme is a bit encryption scheme.</p><p>Definition 2 (Spooky Encryption). Let (Gen, Enc, Dec) be a public-key bitencryption scheme and Spooky-Eval be a polynomial-time algorithm that takes as input a (possibly randomized) circuit with n = n(κ) inputs and n outputs, C : ({0, 1} * ) n → ({0, 1} * ) n , and also n pairs of (public-key, ciphertext), and outputs n ciphertexts. Let C be a class of such circuits, we say that (Gen, Enc, Dec, Spooky-Eval) is a C-spooky encryption scheme if for every security parameter κ, every randomized circuit C ∈ C, and every input x = (x 1 , . . . , x n ) for C, the distributions</p><formula xml:id="formula_10">SP OOK[C, x 1 , . . . , x n ] def = ⎧ ⎨ ⎩ (Dec(sk 1 , c 1 ), . . . , Dec(sk n , c n )) : ∀i ∈ [n] (pk i , sk i ) ← Gen(1 κ ), c i ← Enc(pk i , x i ), (c 1 , . . . , c n ) ← Spooky-Eval(C, (pk i , c i ) i ) ⎫ ⎬ ⎭ and C(x 1 , . . . , x n ) are close upto a negligible distance in κ.</formula><p>We note that the name spooky encryption stems from the application of Definition 2 to circuits C that compute spooky mappings. Indeed, as shown by Dwork et al. <ref type="bibr" target="#b11">[11]</ref>, the semantic security of (Gen, Enc, Dec) implies that only (almost) no-signaling C's can be realized, and every homomorphic scheme can realize C's that compute product mappings.</p><p>Spooky Encryption with CRS. We say that (Gen, Enc, Dec, Spooky-Eval) is a C-spooky encryption scheme with CRS if Definition 2 is satisfied except that we allow all algorithms (and the adversary) to get as input also a public uniformly distributed common random string.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Additive-Function-Sharing Spooky Encryption</head><p>An important special case of spooky encryption allow us to take encryptions c i ← Enc pk i (x i ) under n independent keys of inputs x 1 , . . . , x n to an n-argument function f , and produce new ciphertexts under the same n keys that decrypt to additive secret-shares of y = f (x 1 , . . . , x n ). An encryption scheme that supports such "non-interactive sharing" is called additive-function-sharing spooky encryption (or AFS-spooky). Several variants of this concept are defined below:</p><p>-We can either insist on getting a random secret sharing of y, or contend ourselves with any secret sharing. Below we call the latter variant weak AFSspooky, and the former is strong AFS-spooky (or just AFS-spooky). -Similarly to homomorphic encryption schemes, we can have either a leveled variant where key-generation receives an additional depth parameter d and the result supports only circuits of depth upto d, or a fully AFS-spooky scheme that supports any circuit with a fixed parameter setting. -We can either allow non-negligible error probability (i.e., the probability that the computation fails to produce a secret-sharing of the right output y), or insist on a negligible error probability. Below we denote by ε-AFS-spooky the variant where the error probability is bounded by some ε (that need not be negligible), and the variant with negligible error probability is just AFSspooky. -Sometimes we want to consider only two-argument functions f (x 1 , x 2 ), a scheme that only supports two-argument functions is called AFS-2-spooky.</p><p>The formal definition itself is provided in the full version <ref type="bibr" target="#b9">[9]</ref>, where we also show that the weak and strong variants are essentially equivalent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">LWE-Based Spooky Encryption</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Learning with Errors (LWE) and Multi-key FHE</head><p>The LWE assumption roughly says that adding just a little noise to a set of linear equations makes them hard to solve. In our context, we consider equations modulo some integer q and the noise consists of numbers whose magnitude is much smaller than q, as expressed via a noise distribution χ that yields such "small numbers" with high probability. Below we identify Z q with the symmetric interval [-q/2, q/2) and let [x] q denote the reduction of x modulo q into this interval. <ref type="bibr" target="#b28">[28]</ref>). Let n = n(κ), q = q(κ) ∈ Z be functions of the security parameter κ and χ = {χ(κ)} κ be a distribution ensemble over Z. The decision-LWE assumption with parameters (n, q, χ) says that for any polynomial m = m(κ) ∈ Z, the following two distribution ensembles are computationally indistinguishable</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3 (Learning with Errors</head><formula xml:id="formula_11">LWE[n, m, q, χ] def = (A, b) : A ← Z n×m q , s ← Z n q , e ← χ m , b := [sA + e]q ,</formula><p>and</p><formula xml:id="formula_12">U[n, m, q] def = (A, b) : A ← Z n×m q , b ← Z m q (i.e., unif orm over Z (n+1)×m q ).</formula><p>For α = α(κ) ∈ (0, 1), the α-DLWE assumption asserts the existence of parameters n, q, χ as above with n polynomial in κ, such that e ← χ yields |e| &lt; αq with overwhelming probability.</p><p>Note that the α-DLWE assumption becomes stronger as α gets smaller, and it is known to be false in the extreme case where α = 2 -Ω(n) using lattice-reduction techniques. On the other hand, we have ample evidence to belive the α-DLWE assumption with α = 1/poly(n) <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b25">25,</ref><ref type="bibr" target="#b28">28]</ref>, and it is commonly belived to hold also for super-polynomially (and perhaps even sub-exponentially) small α's.</p><p>We show that assuming hardness of the learning-with-errors problem, there exists a function-secret sharing (in the common-random-string model) for any n-argument function f . Our construction can be built on the multi-key fully homomorphic encryption construction of Mukherjee and Wichs <ref type="bibr" target="#b22">[22]</ref> or the one of Peikert and Shiehian <ref type="bibr" target="#b26">[26]</ref>, which are variations of the Clear-McGoldrick scheme from <ref type="bibr" target="#b7">[7]</ref>. We summarize the relevant properties of these constructions:</p><p>Theorem 1 <ref type="bibr" target="#b7">[7,</ref><ref type="bibr" target="#b22">22,</ref><ref type="bibr" target="#b26">26]</ref>. Assuming the hardness of α-DLWE (for some α(κ)), there exists a multi-key homomorphic encryption with the following properties:</p><p>-The construction works in the common-random-string model. For parameters n, m, q = poly(κ), all instances have access to a uniformly random matrix A ∈ Z</p><p>(n-1)×m q . -For any depth parameter d, the scheme supports multi-key evaluation of depthd circuits using public keys of size d • poly(κ), while secret keys are vectors s ∈ Z n q , regardless of the depth parameter. Specifically, there is an efficient procedure Eval that is given as input:</p><p>• Parameters d, ∈ N;</p><formula xml:id="formula_13">• A depth-d circuit computing an -argument function f : ({0, 1} * ) → {0, 1}; • Public keys (pk 1 , . . . , pk n ) and fresh encryptions (bit-by-bit) of each argu- ment x i ∈ {0, 1} * under key pk i , denoted c i ← Enc pk i (x i ).</formula><p>On such input, the Eval procedure outputs a dimension n -vector, c = (c 1 . . . c ) (with each c i ∈ Z n q ),<ref type="foot" target="#foot_3">4</ref> such that for the secret keys s i corresponding to pk i it holds that</p><formula xml:id="formula_14">i=1 s i , c i = q/2 • f (x 1 , . . . , x n ) + e (mod q)</formula><p>for some error e ∈ Z q with |e| &lt; αq • poly(κ).</p><p>By further making a circular-security assumption, there exists a scheme that supports evaluation of circuits of any depth without growing the public keys.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">LWE-Based AFS Spooky Encryption</head><p>Below we show that under the decision-LWE assumption we can construct AFSspooky encryption schemes (in the common-random-string model). Namely, for every n-argument function f (x 1 , . . . , x n ), given encryption of the arguments under n independent public keys, we can compute an encryption of shares under the same keys of an additive secret-sharing of the output y = f (x 1 , . . . , x n ).</p><p>Theorem 2. Assuming the hardness of α-DLWE, there exists a leveled ε-AFS-2-Spooky encryption scheme for ε = α • poly(κ). Further making a circular-security assumption, we get a (non-leveled) ε-AFS-2-spooky encryption scheme.</p><p>Proof. We show that the encryption scheme from Theorem 1 is already essentially a leveled weak AFS-2-spooky encryption scheme. Specifically, Theorem 1 tells us that given the description of a depth-d circuit C, computing a 2-argument function f : ({0, 1} * ) 2 → {0, 1}, together with two public-key and corresponding bit-by-bit encryptions,</p><formula xml:id="formula_15">c i ← Enc pk i (x i ), the Eval procedure yields (c 1 , c 2 ) ← Eval(C, (pk 1 , c 1 ), (pk 2 , x 2 )) such that sk 1 , c 1 + sk 2 , c 2 = y • q/2 + e (mod q),</formula><p>where the sk i 's are the secret keys corresponding to the pk i 's, y = f (x 1 , x 2 ), and</p><formula xml:id="formula_16">|e| &lt; αq • poly(κ) = εq. Denote v i = [ sk i , c i ] q for i = 1, 2 and v = [v 1 + v 2 ] q .</formula><p>Lemma 1 below says that instead of first adding the v i 's and then rounding to the nearest multiple of q/2, we can first round and then add, and this will yield the same result except with error probability of at most 2ε. The only catch is that Lemma 1 assumes that v 1 , v 2 are chosen at random subject to their sum modulo q being v, whereas in our case we do not have this guarantee. To account for this, we modify our Spooky-Eval procedure, letting it choose a random shift amount δ ∈ Z q and adding/subtracting it from v 1 , v 2 , respectively. More detail is provided in the full version <ref type="bibr" target="#b9">[9]</ref>. Lemma 1. Fix some modulus q ∈ Z, bit b ∈ {0, 1}, and a value v ∈ Z q such that v = b • q/2 + e (mod q) for some bounded error |e| &lt; q/4. Consider choosing v 1 , v 2 uniformly at random in Z q subject to v 1 + v 2 = v (mod q), and denote</p><formula xml:id="formula_17">v i = b i • q/2 + e i (mod q) with b i = [ v i • 2/q ] 2 ∈ {0, 1} and |e i | ≤ q/4. Then Pr v1,v2 [b 1 ⊕ b 2 = b] &gt; 1 -2(|e| + 1)/q.</formula><p>Proof. We break the proof into four cases, namely b = 0 vs. b = 1 and e ≥ 0 vs. e &lt; 0. Below we prove only the first the case b = 0 and v = e ≥ 0, the other three cases are similar. For the first case consider choosing at random v 1 ∈ Z q and setting v</p><formula xml:id="formula_18">2 = [v -v 1 ] q = [e -v 1 ] q . It is straightforward (but tedious) to check that the condition b 1 ⊕ b 2 = b = 0 is satisfied whenever we have either v 1 , v 2 ∈ -q 4 + e, q 4 , or v 1 , v 2 ∈ -q 2 , -q 4 ∪ q 4 + e, q 2 .</formula><p>For example when v 1 ∈ q 4 + e, q 2 then we have b 1 = 1 and</p><formula xml:id="formula_19">v 2 = e -v 1 ∈ e - q 2 , e -( q 4 + e) ⊆ - q 2 , - q 4 ,</formula><p>so we get also b 2 = 1 and therefore b 1 ⊕ b 2 = 0 = b. The only error regions are v 1 , v 2 ∈ ( -q 4 , -q 4 + e), v 1 , v 2 ∈ ( q 4 , q 4 + v), and (depending on rounding) also upto two of the four points v 1 ∈ { ±q 4 , ±q 4 + e} ∩ Z.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Beyond AFS-2-Spooky Encryption</head><p>The construction from Theorem 2 does not directly extend to functions with more than two arguments, since Lemma 1 no longer holds for more than two v i 's (even for the no-error case of e = 0). Instead, we can use the GMW-like transformation that was sketched in the introduction and is described in detail in Sect. 5 to get a general AFS-spooky scheme.</p><p>To support this transformation, we need an AFS-2-spooky scheme which is multi-hop (in the sense of <ref type="bibr" target="#b13">[13]</ref>), i.e. we need to apply the spooky evaluation procedure not just to fresh ciphertexts, but also to evaluated ciphertexts that resulted from previous applications of spooky evaluation. The AFS-2-spooky scheme in Theorem 2 may or may not have this property, depending on the underlying multi-key FHE scheme. In particular the Peikert-Shiehian scheme in <ref type="bibr" target="#b26">[26]</ref> is "natively multi-hop," so we can base our construction on that scheme and get directly a multi-hop AFS-2-spooky scheme which is suitable for our transformation.</p><p>On the other hand, the schemes from <ref type="bibr" target="#b7">[7,</ref><ref type="bibr" target="#b22">22]</ref> support only one hop, since only fresh cipehrtexts can be processed in a multi-key fashion. We can stil use them for our purposes by applying the same bootstrapping-based transformation as in <ref type="bibr" target="#b13">[13,</ref><ref type="bibr">Theorem 4]</ref>, which transforms any compact fully-homomorphic scheme to a multi-hop one: <ref type="foot" target="#foot_5">5</ref> More details are provided in the full version <ref type="bibr" target="#b9">[9]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 3. Assuming the hardness of α-DLWE, there exists a leveled FHE scheme that supports d interleaved levels of AFS-2-spooky multiplications and single-key addition, with total error probability</head><formula xml:id="formula_20">ε = α • d • poly(κ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary 1. Assuming the hardness of α-DLWE, there exists a leveled ε-AFSspooky encryption scheme for ε = α•d•poly(κ). Further making a circular-security assumption, we get a (non-leveled) ε-AFS-spooky encryption scheme.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">piO Based Spooky Encryption</head><p>In this section we show a construction based on probabilistic iO, in conjunction with lossy homomorphic encryption, that can support many 2-key spooky relations, even beyond AFS-spooky. Compared to our LWE-based construction from Sect. 3, the construction here does not need a CRS and has zero error probability, and it supports more spooky distributions. On the other hand, we are making a much stronger assumption here, and also we need a different scheme for different spooky relations. <ref type="foot" target="#foot_6">6</ref>The construction in this section supports in particular the functionality that we need for our generic transformation from Sect. 5, that turns an AFS-2-spooky scheme to an AFS-n-spooky one. The resulting AFS-n-spooky also does not use a CRS and has no error probability. Moreover, applying this transformation yields a single scheme supporting all AFS-spooky relations.</p><p>Organization of this Section. In Sect. 4.1 we introduce our tools, defining probabilistic indistinguishability obfuscation (using a slightly weaker variant of the definition of Canetti et al. <ref type="bibr" target="#b6">[6]</ref>) and lossy homomorphic encryption with malicious circuit privacy. In Sect. 4.2 we describe and prove our construction for 2-input spooky encryption scheme, and finally in Sect. 4.3 we show how to obtain a multi-input AFS-spooky encryption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Tools</head><p>Probabilistic Indistinguishability Obfuscation. Our construction uses probabilistic iO, a notion that was recently introduced by Canetti et al. <ref type="bibr" target="#b6">[6]</ref>. Loosely speaking, this is an obfuscator for probabilistic circuits with the guarantee that the obfuscations of any two "equivalent" circuits are computationally indistinguishable.</p><p>Canetti et al. define several variants of piO, where the main distinction is the precise formulation of what it means for circuits to be equivalent. Our definition corresponds to a (weakened variant) of their X-Ind piO (which can be realized assuming sub-exponentially secure iO and sub-exponentially secure OWF, see Theorem 4 below). Roughly, our variant only considers pairs of circuits with the property that for every input, their output distributions are identical, while the definition in <ref type="bibr" target="#b6">[6]</ref> allows a small statistical gap.</p><p>To formally define piO, we consider a (possibly randomized) PPT sampling algorithm S that given as input a security parameter 1 κ , outputs a triple (C 0 , C 1 , z), where C 0 and C 1 are randomized circuits (to be obfuscated) and z is some auxiliary input. We say that a sampler S is an equivalent-circuit-sampler if with probability 1 it outputs circuits C 0 and C 1 such that for every x the circuits C 0 (x) and C 1 (x) generate identical distributions. Definition 4 (Probabilistic Indistinguishable Obfuscation (piO), <ref type="bibr" target="#b6">[6]</ref>). A probabilistic indistinguishability obfuscator is a probabilistic polynomial-time algorithm piO that, given as input a security parameter 1 κ and a probabilistic circuit C, outputs a circuit C = piO(1 κ , C) (which may be deterministic) of size at most |C | = poly(κ, |C|) such that the following two properties hold:</p><p>1. For every individual input x, the distribution C(x) and piO(1 κ , C) (x) are identical.<ref type="foot" target="#foot_7">7</ref> 2. For every equivalent-circuit-sampler S, drawing (C 0 , C 1 , z) ← S(1 κ ) we get computationally indistinguishable distributions:</p><formula xml:id="formula_21">{(C 0 , C 1 , z, piO(1 κ , C 0 ))} c = {(C 0 , C 1 , z, piO(1 κ , C 1 ))}</formula><p>We note that our correctness guarantee is incomparable to that given by <ref type="bibr" target="#b6">[6]</ref>. Indeed, motivated by their PRF based construction, the definition in <ref type="bibr" target="#b6">[6]</ref> basically requires that no PPT adversary can distinguish between oracle access to C and to piO(1 κ , C) (so long as the adversary is not allowed to repeat its queries). On the one hand our definition is weaker in that it only considers each input individually, but on the other hand it is stronger in that it requires that for each such individual input the distributions are identical. Our correctness guarantee can be easily obtained from the construction in <ref type="bibr" target="#b6">[6]</ref>, by using an underlying PRF {f s } s with the property that f s (x) is individually uniformly random for every x. The latter can be easily obtained by taking any PRF and xor-ing its output with a fixed random string.</p><p>Theorem 4 <ref type="bibr" target="#b6">[6]</ref>. Assuming the existence of a sub-exponentially indistinguishable indistinguishability obfuscator for circuits and a sub-exponentially secure puncturable PRF, there exists a probabilistic indistinguishability obfuscator.</p><p>Lossy Encryption. Loosely speaking, a lossy encryption scheme has a procedure Gen for generating "lossy public keys." These keys are indistinguishable from normal public keys, but have the property that ciphertexts generated using such lossy keys contain no information about their plaintext. We defer the formal definition to the full version <ref type="bibr" target="#b9">[9]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Malicious Circuit-Private Encryption.</head><p>A public-key encryption scheme (Gen, Enc, Dec), with message space {0, 1} , is a homomorphic encryption scheme for a class of Boolean circuits C on -bit inputs if there exists a PPT algorithm Eval, such that for every key-pair (pk, sk), circuit C ∈ C and ciphertext c = Enc pk (x), where x ∈ {0, 1} , on input (C, c) the algorithm Eval pk outputs c * such that Dec sk (c * ) = C(x). If the length of c * does not depend on C then we say that the scheme is compact.</p><p>As noted in the introduction, our construction requires a homomorphic encryption scheme that has malicious circuit privacy, which means that the ciphertext c * does not reveal any non-trivial information about the circuit C which was used to generate it, even for an adversarially chosen public-key pk and ciphertext c. We defer the formal definition to the full version <ref type="bibr" target="#b9">[9]</ref>.</p><p>Malicious circuit privacy for evaluating NC 1 circuits can be achieved by a "folklore" combination of an information theoretic variant of Yao's garbled circuit <ref type="bibr" target="#b17">[17]</ref> with an oblivious transfer protocol that has perfect security against a malicious receiver. The latter can be constructed based on DDH <ref type="bibr" target="#b23">[23]</ref>. Moreover, these schemes can be made lossy using standard techniques.</p><p>Moreover, we can apply the techniques of Ostrovsky et al. <ref type="bibr" target="#b24">[24]</ref> to bootstrap this result to any poly-circuit, assuming the existence of (leveled) fully homomorphic encryption with NC 1 decryption. The latter scheme can be instantiated based on LWE, see more details in the full version <ref type="bibr" target="#b9">[9]</ref>. Hence we obtain: Theorem 5. Assuming the hardness of LWE and DDH, there exists a lossy leveled fully-homomorphic encryption scheme with malicious circuit privacy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Two-Key Spooky Encryption from piO</head><p>Our construction relies on a property of two-input relations that we call resampleability. Roughly, it should be possible to sample efficiently from the distribution of the second coordinate conditioned on a particular fixed value for the first coordinate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 5 (Efficiently Re-sampleable). A randomized polynomial-size circuit</head><formula xml:id="formula_22">C : {0, 1} 1 × {0, 1} 2 → {0, 1} 1 × {0, 1} 2 is efficiently re-sampleable if there exists a polynomial-size randomized "resampling circuit" RS C , such that for any input (x 1 , x 2 ) to C, the distribution C(x 1 , x 2 ) is identical to the "resam- pled distribution" {(y 1 , y 2 ) : (y 1 , y 2 ) ← C(x 1 , x 2 ), y 2 ← RS C (x 1 , x 2 , y 1 )} .</formula><p>We construct a 2-key spooky scheme that supports any 2 input/output circuit that is both efficiently re-sampleable and no-signaling. Theorem 6 (2-Key Spooky Encryption from piO). Let C : {0, 1} 1 × {0, 1} 2 → {0, 1} 1 × {0, 1} 2 be an efficiently re-sampleable no-signaling circuit, with re-sampling circuit RS C . If there exist (1) piO, and (2) a perfectly-lossy homomorphic encryption scheme that can evaluate C and RS C , and is perfectly malicious circuit private, then there exists a C-spooky encryption scheme, which is also perfectly lossy (and hence semantically secure).</p><p>We stress that the encryption scheme that we need for Theorem 6 must be able to evaluate C and RS C and be perfectly malicious circuit private, but it need not be compact. In the full paper we describe such a scheme for NC 1 circuits based on DDH. Hence, under DDH and piO, we get a C-spooky scheme for every re-sampleable and no-signaling C in NC 1 . Moreover, we can use the techniques of Ostrovsky et al. <ref type="bibr" target="#b24">[24]</ref> to supports any poly-size circuit, assuming both DDH and FHE. Since <ref type="bibr" target="#b6">[6]</ref> show that full-fledged FHE can be built based on piO, we get a construction under DDH and piO for C-spooky scheme for every re-sampleable and no-signaling polynomial-size circuit C.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Remark 1 (Almost No-Signaling).</head><p>A natural relaxation of no-signaling circuits, considered in previous works (e.g., <ref type="bibr" target="#b11">[11,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b19">19]</ref>), allows the distributions C(x, y) 1 and C(x, y ) 1 to be indistinguishable (rather than identical). Such circuit is called almost no-signaling.</p><p>It is clear that for a secure C-spooky encryption scheme to exist, C must be (at least) almost no-signaling (cf. <ref type="bibr" target="#b11">[11]</ref>). However our construction does not extend to the "almost" case, Theorem 6 requires that C to be perfectly no-signaling, i.e. C(x, y) 1 and C(x, y ) 1 must be identically distributed for all x, y, y . Supporting almost no-signaling circuits is left to future work.</p><p>Proof of Theorem 6. Let piO be a probabilistic indistinguishability obfuscator and let (Gen, Enc, Dec) be the encryption scheme from the theorem statement, with Gen the corresponding lossy key generation algorithm and Eval the homomorphic evaluation algorithm with malicious circuit privacy.</p><p>Each instance of our construction uses two public/secret keys pairs, where only the first pair is used for "normal encryption and decryption," and the other pair is only used for spooky evaluation. In addition to the two pairs, the public key also contains an obfuscated program that implements spooky evaluation using the secret key. That obfuscated program has a secret key hard-wired, and given two ciphertexts c 1 , c 2 it decrypt the first one, then evaluates the resampling circuit RS C homomorphically on the other. A complete description of the resulting scheme is found in Fig. <ref type="figure">1</ref>.</p><p>We first show that the scheme supports spooky evaluation of C and then show that it is a lossy encryption scheme (and in particular is semantically secure). Lemma 2. The scheme (Gen-Spooky, Enc-Spooky, Dec-Spooky, Spooky-Eval) is C-spooky.</p><p>Proof. The spooky evaluation procedure gets as input two public-keys pk-spooky 1 = pk1 1 , pk2 1 , P1 , pk-spooky 2 = pk1 2 , pk2 2 , P2 , and matching ciphertexts c 1 = Enc-Spooky(pk-spooky 1 , x 1 ) and c 2 = Enc-Spooky (pk-spooky 2 , x 2 ) (for some inputs x 1 , x 2 to C). It simply runs the obfuscated program P1 = piO(1 κ , P [sk1 1 , pk2 1 ]) on input (c 1 , pk1 2 , c 2 ) and returns its output.</p><p>By construction and using the correctness of piO, this procedure outputs c 1 and c 2 such that c 1 ← Enc(pk2 1 , y 1 ), where</p><formula xml:id="formula_23">y 1 ← C(x 1 , 0 2 ) 1 , and c 2 ← Eval pk12 (RS[x 1 , y 1 , r], c 2 ), where RS[x 1 , y 1 , r](x 2 ) ≡ RS C (x 1 , x 2 , y 1 ; r). By the no-signaling property y 1 is distributed identically to y 1 ← C(x 1 , x 2 ) 1 and so c 2 is distributed as Eval pk12 (RS[x 1 , y 1 , r], c 2 ). Hence Dec-Spooky(sk-spooky 1 , c 1 ) = Dec sk11 (Enc(pk2 1 , y 1 )) = y 1 and Dec-Spooky(sk-spooky 2 , c 2 ) = RS[x 1 , y 1 , r](x 2 ) = RS C x 1 , x 2 , y 1 ; r 2 .</formula><p>By the definition of re-sampling, the joint distribution Dec-Spooky(sk-spooky 1 , c 1 ), Dec-Spooky(sk-spooky 2 , c 2 ) is identical to C(x 1 , x 2 ), as required. Lemma 3. The scheme (Gen-Spooky, Enc-Spooky, Dec-Spooky) is a perfectly lossy encryption scheme. Proof. We need to show that there is an alternative key-generation procedure Gen-Spooky, producing public keys that are indistinguishable from the real ones, but such that ciphertexts encrypted relative to these keys contain no information about the encrypted plaintext.</p><p>The main challenge in establishing the lossiness of the scheme is in showing that the public-keys are indistinguishable from lossy keys despite the obfuscated programs in the public-key (which depend on the corresponding secret keys). Toward that end, we will (gradually) show that these obfuscated programs are computationally indistinguishable from programs that do not depend on the secret keys.</p><p>Below we state and prove a few claims, where we consider the distributions (pk1, sk1), (pk2, sk2) ← Gen(1 κ ) and pk1, pk2 ← Gen(1 κ ), where Gen is the lossy key-generation of the underlying encryption scheme.</p><formula xml:id="formula_24">Claim 4.1. pk1, pk2, piO(1 κ , P [sk1, pk2]) c = pk1, pk2, piO(1 κ , P [sk1, pk2]) .</formula><p>Proof. Follows from the indistinguishability between standard and lossy publickeys of the underlying scheme.</p><formula xml:id="formula_25">Claim 4.2. pk1, pk2, piO(1 κ , P [sk1, pk2]) c = pk1, pk2, piO(1 κ , P [sk1, pk2]) ,</formula><p>where P [sk1, pk2] is similar to P [sk1, pk2] except that it encrypts 0 1 rather than y 1 in Step 3, see Fig. <ref type="figure">2</ref>.</p><p>Proof. Since pk2 is a lossy public-key, Enc pk2 (0 1 ) and Enc pk2 (y 1 ) are identically distributed. Hence P and P have identical output distribution for every input, and so their piO-obfuscations are indistinguishable.</p><p>We proceed to the main claim:</p><formula xml:id="formula_26">Claim 4.3. pk1, pk2, piO(1 κ , P [sk1, pk2]) c = pk1, pk2, piO(1 κ , P [ pk2]) ,</formula><p>where the program P [ pk2], defined in Fig. <ref type="figure">2</ref>, does not have the secret key sk1 (hence it cannot recover x 1 or compute y 1 ), so on c = Enc pk (x 2 ) it evaluates homomorphically f</p><formula xml:id="formula_27">(x 2 ) = C(0 1 , x 2 ) 2 rather than f (x 2 ) = RS C (x 1 , x 2 , y 1 ).</formula><p>Proof. We will show that for every valid secret key sk1 and arbitrary public key pk2, the randomized programs P [sk1, pk2] and P [ pk2] are functionally identical, in the sense that their outputs are identically distributed for every input. The claim will then follow from the fact that piO is a probabilistic indistinguishability obfuscator (see <ref type="bibr">Definition 4)</ref>. Note that the first output c 1 = Enc pk2 (0 1 ) is generated identically by the two programs, and is independent of everything else that happens in these programs, so we only need to show that the second output c 2 is identically distributed. To show this, we first establish that c 2 is an encryption under pk of a value y 2 that is distributed identically in the two programs, and then we appeal to the malicious circuit-privacy of the underlying scheme to conclude that also c 2 itself is identically distributed.</p><p>For starters, fix some arbitrary x 1 ∈ {0, 1} 1 and x ∈ {0, 1} 2 , and consider the following distributions</p><formula xml:id="formula_28">D 1 [x 1 , x] = y 1 ← C(x 1 , 0 2 ) 1 , output y 2 ← RS C (x 1 , x, y 1 ) , // Output distribution of P D 2 [x 1 , x] = y 1 ← C(x 1 , x) 1 , output y 2 ← RS C (x 1 , x, y 1 ) , D 3 [x 1 , x] = output y 2 ← C(x 1 , x) 2 , D 4 [x] = output y 2 ← C(0 1 , x) 2 . // Output distribution of P Since C is a no-signaling circuit then D 1 [x 1 , x] = D 2 [x 1 , x] and D 3 [x 1 , x] = D 4 [x],</formula><p>and since R C is the re-sampling circuit for C then we also have</p><formula xml:id="formula_29">D 2 [x 1 , x] = D 3 [x 1 , x].</formula><p>We therefore conclude that the two distributions D 1 [x 1 , x] and D 4 [x] are identical for every x 1 , x. Now consider x 1 = Dec sk1 (c 1 ), and x which is the "effective plaintext" for pk, c (such x must exist since the underlying scheme is malicious circuit-private). Recall that the second output of P [sk1, pk2] consists of a homomorphic evaluation of D 1 [x 1 , x], while the second output of P [ pk2] consists of homomorphic evaluation of D 4 [x]. Using perfect malicious circuit privacy, we conclude that these outputs are identically distributed.</p><p>Having established that the output distributions of P [sk1, pk2] and P [ pk2] are identical (for every input), the claim follows because piO is a probabilistic indistinguishability obfuscator. Proof. This claim follows from the indistinguishability between standard and lossy public-keys of the underlying scheme.</p><p>Combining Claims 4.1-4.3, the two distributions pk1, pk2, piO(P sk1,pk2 ) and pk1, pk2, piO(P pk2 ) are computationally indistinguishable. We complete the proof of Lemma 3 by observing that keys drawn from the latter distribution are lossy, since the key pk1 is lossy, the Enc-Spooky procedure just uses the underlying encryption procedure with pk1, and the program P [pk2] that we obfuscate is independent of pk1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">piO Based Multi-key Spooky Encryption</head><p>To obtain spooky encryption for more than two inputs, we would like to invoke our general transformation from 2-key spooky encryption to n-key spooky encryption (see <ref type="bibr">Theorem 8)</ref>. The scheme in Theorem 6 supports spooky multiplication, but we need it to support multiple alternating hops of (single-key) additive homomorphism and spooky multiplication. This is obtained by the following lemma: Lemma 4. Assume the existence of (1) piO and (2) a lossy encryption scheme that is homomorphic for all one-bit to one-bit functions with perfect malicious circuit privacy. Then, for every d = d(κ), there exists an encryption scheme that supports d interleaved levels of AFS-2-spooky multiplications and single-key additions.</p><p>Proof (Proof Sketch). To obtain an additive homomorphism, we use a construction of Canetti et al. <ref type="bibr" target="#b6">[6]</ref> which, assuming piO, transforms any lossy encryption into a d-leveled FHE. This is done by taking d copies of keys of the original lossy scheme and publishing d -1 obfuscated programs where the i th obfuscated program takes as input two ciphertexts encrypted under the i th key, decrypts them (using the i th private-key which is hard-wired) applies one operation (AND, XOR, NAND, etc.) and encrypts the result under the (i + 1) th key. Using the fact that the scheme is lossy, <ref type="bibr">Canetti et al.</ref> show that the piO obfuscation hides the hard-wired private keys and semantic security is maintained.</p><p>For our application, we need to compute multiple spooky multiplications, and then sum them up with single-key addition. To get n-input AFS-spooky we need to sum up n ciphertexts, which can be done using an addition tree of depth d = log n.</p><p>Looking more closely at the construction from <ref type="bibr" target="#b6">[6]</ref>, we observe that by setting d = i log n we can already support i interleaving hops of (single-key) additive homomorphism and 2-input spooky multiplications. This follows since the transformation in <ref type="bibr" target="#b6">[6]</ref> has the property that after every additive homomorphic operation, we obtain a fresh ciphertext (under a new-key).</p><p>Using the scheme from Lemma 4 and applying Theorem 8, we get:</p><p>Theorem 7 (n-Key Spooky from piO). Assume existence of (1) piO and (2) a lossy encryption scheme that is homomorphic for all single-bit to singlebit functions with perfect malicious circuit privacy. Then there exists a leveled AFS-spooky encryption scheme.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">From 2-Input to n-Input AFS-Spooky</head><p>Theorem 8 (2-Spooky to n-Spooky). Let d = d(κ) and assume that there exists a public-key bit-encryption scheme that supports 2d (interleaving) hops of (1) single-key compact additive homomorphism and ( <ref type="formula">2</ref>) two-key spooky multiplication. Then, that same scheme is a d-level AFS-spooky encryption.</p><p>Proof. Let (Gen, Enc, Dec) be the encryption scheme in the theorem statement, let Spooky-Mult be the spooky multiplication PPT algorithm and let Eval be the single-key homomorphic evaluation algorithm (that supports compact additive homomorphism). We show a procedure that given as input:</p><p>outputs a sequence of ciphertexts c 1 , . . . , c n such that j∈[n] Dec skj (c j ) = C(x 1 , . . . , x n ) (where addition is over GF(2)).</p><p>The procedure processes the circuit wire by wire. We maintain the invariant that whenever a wire w is processed, the procedure generates ciphertexts c</p><formula xml:id="formula_30">(w) 1 , . . . , c (w) n such that j∈[n] Dec skj (c (w) j )</formula><p>is the correct value of the wire w when the circuit C is evaluated on input (x 1 , . . . , x n ). Furthermore, if the wire w is at distance i from the input then c ) is equal to the output value of the circuit, as required. We proceed to describe how the wires are (inductively) processed.</p><p>Consider an input wire w, corresponding to an input bit b which is part of the i th input x i , and for which we are given the input ciphertext c = Enc pk i (b). For that wire we set c </p><formula xml:id="formula_31">(v) 1 , . . . , c (v) n such that j∈[n] Dec skj (c (u) j ) = b u and j∈[n] Dec skj (c (v) j ) = b v .</formula><p>For the case that g is an addition gate, we set c</p><formula xml:id="formula_32">(w) j = Eval pk j , ⊕, c (u) j , c (v) j</formula><p>and we get:</p><formula xml:id="formula_33">j∈[n] Dec sk j (c (w) j ) = j∈[n] Dec sk j (Eval pk j (⊕, c (u) j , c (v) j )) = j∈[n] Dec sk j (c (u) j ) ⊕ Dec sk j (c (v) j ) = bu ⊕ bv,</formula><p>which is the correct value for the wire w. Furthermore, each new ciphertext was obtained by just a single homomorphic operation. Now consider the case that g is a multiplication gate. We first compute auxiliary ciphertexts (f j,j , g j,j ) = Spooky-Mult(pk j , pk j , c</p><formula xml:id="formula_34">(u) j , c (v) j ), for every j, j ∈ [n]. We then set c (w) j = Eval pk j (⊕, f j,1 , . . . , f j,n , g 1,j , . . . , g n,j ).</formula><p>We obtain that:</p><formula xml:id="formula_35">j∈[n] Dec skj c (w) j = j∈[n] Dec skj Eval pk j (⊕, x j,1 , . . . , x j,n , y 1,j , . . . , y n,j ) = j∈[n] j ∈[n] Dec skj (f j,j ) ⊕ Dec skj (g j ,j ) = j∈[n] j ∈[n] Dec skj (c (u) j ) • Dec skj (c (v) j ) = j∈[n] Dec skj (c (u) j ) • j ∈[n] Dec skj (c (v) j ) = b u • b v , FinDec(y 1 , . . . , y n ) outputs y = n i=1 y i .</formula><p>For security, we observe that each partial decryption y i can be simulated given c * = (c 1 , . . . , c n ), y and sk j for j = i by computing y j = Dec skj (c j ) and setting y i = y ⊕ ( j =i y j ). <ref type="foot" target="#foot_9">9</ref> This proves the following theorem. Theorem 10. An AFS-spooky encryption scheme with perfect correctness implies a multi-key FHE with threshold decryption (TMFHE).</p><p>Using the above theorem and the results of <ref type="bibr" target="#b22">[22]</ref> which constructs a 2-round MPC from TMFHE, we get the following corollaries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary 2. Assuming the existence of a weak AFS-spooky encryption scheme:</head><p>-There exists a 2-round MPC protocol with semi-honest security. If the encryption scheme is in the plain model then so is the MPC protocol and if the encryption scheme requires a CRS then so does the MPC protocol. -Furthermore, assuming the existence of NIZKs in the CRS model, there exists a 2-round MPC protocol with malicious security in the CRS model.</p><p>Combining this with our construction of AFS-spooky encryption without a CRS from iO, we get the first construction of a 2-round semi-honest MPC protocol in the plain model.</p><p>Corollary 3. Assume existence of (1) piO and (2) a lossy encryption scheme that is homomorphic for all single-bit to single-bit functions with perfect malicious circuit privacy. Then, there exists a 2-round MPC protocol with semi-honest security in the plain model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Function Secret Sharing</head><p>Function secret sharing (FSS), recently introduced by Boyle, Gilboa and Ishai <ref type="bibr" target="#b4">[4]</ref>, allows a dealer to split a function f into k succinctly described functions f1 , . . . , fk such that (1) any strict subset of the fi 's reveals nothing about f and (2) for any x it holds that the values f1 (x), . . . , fk (x) are an additive secret sharing of f (x). Boyle et al. gave constructions under standard assumptions for certain restricted families of functions and a general construction for any polysize circuit, based on piO. We show how to construct such a general FSS scheme given any AFS-spooky encryption scheme. In particular, we obtain a leveled FSS scheme assuming only LWE.</p><p>To construct such an FSS scheme, the dealer first generates a k-out-of-k secret sharing f 1 , . . . , f k of the description of the function f . The dealer also generates k key pairs (pk i , sk i ) i∈ <ref type="bibr">[k]</ref> for the AFS spooky scheme and publishes fi def = sk i , pk 1 , . . . , pk k , Enc pk 1 (f 1 ), . . . , Enc pk k (f k ) as the i th share. Assuming the scheme is semantically secure, any strict subset of the fi 's hides the original function f (upto its description length).</p><p>For the FSS functionality, given an input x we can consider the circuit C x that takes as input k shares of a function f , adds them up and applies the resulting function to the input x (which, say, is hardwired). To evaluate fi on x, we run the spooky evaluation algorithm, which we assume wlog is deterministic, on Enc pk 1 (f 1 ), . . . , Enc pk k (f k ) with respect to the circuit C x . Thus, given each fi separately, we can generate the same ciphertexts c 1 , . . . , c k which are encryptions of an additive secret sharing of f (x). Each function fi can then be used to decrypt c i and publish its share of f (x).</p><p>A De-centralized View. We remark that the above construction can be viewed as a de-centralized FSS. More specifically, we may have some k (not necessarily secret or functional) shares f 1 , . . . , f k of a function f , where each share is owned by a different player. Player i can generate a key pair (pk i , sk i ) and broadcast (pk i , Enc pk i (f i )) to all other players. Using our scheme, after learning the input x, the players can (non-interactively) generate an additive secret sharing of f (x).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Spooky-Free Encryption</head><p>We turn now to study spooky-free encryption, i.e. an encryption scheme that ensures that no spooky relations can be realized by an adversary. The formal definition roughly states that any correlation that an attacker can induce between the original messages (m 1 , . . . , m n ) and "tampered messages" (m 1 , . . . , m n ), can be simulated by a "local simulator" that produces m i only as a function of m i (and some shared randomness).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 6 (Spooky-Free Encryption</head><p>). An encryption scheme (Gen, Enc, Dec) is spooky-free if for every PPT adversary A there exists a PPT simulator S such that for all PPT message distributions D, the two distributions REAL D,A (κ) and SIM D,S (κ) specified below are computationally indistinguishable: It is not hard to see that spooky-freeness for n ≥ 2 implies semantic security. As a small subtlety, here the attacker must choose the messages it claims to distinguish before seeing the public-key, since the message sampler D does not know anything public keys used in the real experiment. (We defined it this way since stronger security was not needed for our delegation application.) Of course, this minor difference from standard semantic security is without loss of generality when the message space is polynomial small (e.g., for bit encryption). Lemma 5. A spooky-free scheme for n ≥ 2 is semantically secure (in the "selective" sense discussed above).</p><formula xml:id="formula_36">REAL D,</formula><p>Proof. Suppose that a scheme (Enc, Dec, Gen) is not semantically secure, and let B be an attacker that can distinguish Enc pk (x 0 ) from Enc pk (x 1 ). We use B to construct a sampler D and attacker A that can fool any simulator S with nonnegligible probability. We assume that D and A (and S) know the messages x 0 and x 1 whose encryption B can distinguish.</p><p>D draws at random m 1 ← {x 0 , x 1 } and sets m i := 0 for i &gt; 1. Upon seeing n ciphertexts c 1 , . . . , c n , A gives c 1 to B, asking him to guess whether it encrypts x 0 or x 1 . Let σ be the guess that B makes, then we know that m 1 = x σ with probability ≥ 1/2 + ε. A then sets c i = c i for all i = 2, and sets c 2 to be a fresh encryption of x σ under pk 2 .</p><p>As we can see, the output of the real experiment has the tuple (m 1 , m 2 ) distributed as (x b , x σ ), where b is a random bit and σ = b with probability ≥ 1/2 + ε. On the other hand, the simulator for the second message m 2 is only given m 2 = 0 as the input, and has to guess σ s.t., Pr[b = σ ] ≥ 1/2 + ε, which is impossible information-theoretically.</p><p>In the full version of this work <ref type="bibr" target="#b9">[9]</ref> we show that spooky-free homomorphic encryption is exactly the ingredient needed to instantiate the idea of Aiello et al. <ref type="bibr">[1]</ref> for converting general multi-prover (MIP) systems into single-prover arguments. <ref type="foot" target="#foot_10">10</ref> We also show there that non-malleable encryption is always spooky-free (albeit without any homomorphic capabilities), and we construct a spooky-free FHE scheme using a strong security component called succinct non-interactive argument of knowledge (SNARK). <ref type="foot" target="#foot_11">11</ref>Spooky-Free Encryption with CRS. Definition 6 can be naturally extended to the common-reference-string model. We use this relaxation in the full version to gain somewhat better efficiency (at the price of a slightly harder proof of security). We note that, unlike the setting of spooky encryption from Sect. 3, we do not need the CRS to get the desired functionality, but rather use it only to improve efficiency. Our construction remains spooky-free (but slower) if all the public keys are chosen completely independently.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .Fig. 2 .</head><label>12</label><figDesc>Fig. 1. based spooky encryption</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Claim 4 . 4 .</head><label>44</label><figDesc>pk1, pk2, piO(P pk2 ) c = pk1, pk2, piO(P pk2 ) .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>most 2i hops of homomorphic operations. In particular, at the end of the process the procedure will have generated the sequence of ciphertexts c out 1 , . . . , c out n such that j∈[n] Dec skj (c out j</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>=</head><label></label><figDesc>Enc pk j (0) for all j = i. Hence,j∈[n] Dec skj (c (w) j ) = Dec ski (c) = b,which is the correct value for the wire w. Consider a gate g with input wires u, v and output wire w. Let b u (resp., b v ) be the value on the wire u (resp., v) when C is evaluated on input (x 1 , . . . , x n ). By induction, we have already generated ciphertexts c</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc><ref type="bibr" target="#b2">2</ref>. For an addition gate with input wires u, v and output wire w, by induction we already have Enc pk 1 (u 1 ), . . . , Enc pk n (u n ) and Enc pk 1 (v 1 ), . . . , Enc pk n (v n ). Using just an additive homomorphism on each key individually, we can produce Enc pk 1 (u 1 ⊕ v 1 ), . . . , Enc pk n (u n ⊕ v n ) which is the desired secret sharing. 3. For a multiplication gate with input wires u, v and output wire w, again by induction we already have Enc pk 1 (u 1 ), . . . , Enc pk n (u n ) and Enc pk 1 (v 1 ), . . . ,</figDesc><table><row><cell>Enc pk n (v n ). Using the AFS spooky multiplication we compute an encrypted tensor product of the u and v vectors. Namely, for every i, j we use spooky</cell></row><row><cell>multiplication to compute</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>A (κ): 1. Sample (m 1 , . . . , mn, α) ← D(1 κ ); // α is auxiliary information 2. Choose (pk i , sk i ) ← Gen(1 κ ), set c i ← Enc pk i (m i ) for i = 1, . . . , n; 3. Let (c 1 , . . . , c n ) ← A(pk 1 , . . . , pk n , c 1 , . . . , cn); 4. Set m i = Dec sk i (c i ) for i = 1, . . . , n; 5. Output (m 1 , . . . , mn, m 1 , . . . , m n , α).SIM D,S (κ):1. Sample (m 1 , . . . , mn, α) ← D(1 κ ); // α is auxiliary information 2. Sample a random r, let m i = S(1 κ , 1 n , i, m i ; r) for i = 1, . . . , n; 3. Output (m 1 , . . . , mn, m 1 , . . . , m n , α).</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Dwork et al.  considered PIR rather than encryption, but the translation is immediate.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Although included in the ICALP conference proceedings, the article[1]  was withdrawn before the conference and was not presented there.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>In contrast,<ref type="bibr" target="#b12">[12]</ref> and<ref type="bibr" target="#b22">[22]</ref> construct 2-round protocols in the CRS model. As for security against a malicious adversary,<ref type="bibr" target="#b20">[20]</ref> show that 5 rounds are necessary in the plain model (with respect to black-box proofs of security).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>Referring to<ref type="bibr" target="#b22">[22,</ref> Sect.  </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_4"><p><ref type="bibr" target="#b5">5</ref>.4], the vector c i is the result of the product Ĉ(i) × Ĝ-1 ( ŵT ), without the added noise term e sm i .</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_5"><p>The transformation in<ref type="bibr" target="#b13">[13]</ref> is described for single-key FHE schemes, but it applies also to multi-key schemes.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_6"><p>We can extend the construction so that a single scheme can handle an entire class of spooky relations, as long as we can describe relations in that class and verify that a given relation is no-signaling.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_7"><p>The latter distribution is defined also over the randomnees of piO. Note that this does not imply that the joint distribution for multiple inputs will be the same in the two cases.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_8"><p>Actually, the original suggestion in[1]  was to use a PCP (rather than an MIP). Dwork et al.<ref type="bibr" target="#b11">[11]</ref> show that using PCPs is not sound and raise the question of whether soundness can be obtained by replacing the PCP with an MIP.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_9"><p>We note that imperfect correctness of the AFS-spooky scheme will translate into a security problem for the TMFHE scheme, as the simulated yi will have a different distribution than the real ones.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_10"><p>An alternate route for instantiating the[1]  idea due to<ref type="bibr" target="#b18">[18,</ref><ref type="bibr" target="#b19">19]</ref> is to use special types of MIP, which satisfy a stronger soundness condition, together with any (possibly spooky) homomorphic encryption scheme.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11" xml:id="foot_11"><p>Of course, this construction does not give any new one-round delegation schemes, since SNARKs trivially imply the existence of such a scheme directly (i.e., without building spooky-free encryption). Still, if better constructions of spooky-free FHE are found, they would immediately imply new delegation schemes for NP.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments. This work was done in part while the authors were visiting the Simons Institute for the Theory of Computing, supported by the Simons Foundation and by the DIMACS/Simons Collaboration in Cryptography through NSF grant #CNS-1523467.</p><p>The first author was partially supported by gifts from VMware Labs and Google, and NSF grants 1319051, 1314568, 1065288, 1017471.</p><p>The second author was supported in part by the Defense Advanced Research Projects Agency (DARPA) and Army Research Office(ARO) under Contract No. W911NF-15-C-0236.</p><p>The third author was supported by NSF MACS -CNS-1413920, DARPA IBM -W911NF-15-C-0236, SIMONS Investigator award Agreement Dated 6-5-12 and DARPA NJIT -W911NF-15-C-0226.</p><p>The last author was supported in part by NSF grants CNS-1347350, CNS-1314722, CNS-1413964.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>which is the correct value for the wire w (where the fourth equality is due to the Spooky-Mult guarantee). Furthermore, each new ciphertext was obtained by applying two hops of homomorphic operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Applications of Spooky Encryption</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Counter Example for the [1] Heuristic</head><p>Building on <ref type="bibr" target="#b11">[11]</ref>, we show that AFS-2-spooky encryption gives a counter-example to a natural method proposed by Aiello et al. <ref type="bibr">[1]</ref> for building succinct arguments for NP, resolving a question posed by <ref type="bibr" target="#b11">[11]</ref>. The suggestion of Aiello et al. <ref type="bibr">[1]</ref> was to take any multi-prover interactive proof-system (MIP) and to use that proofsystem using only a single prover by sending all of the MIP queries encrypted under independents keys of a homomorphic encryption scheme. 8 The fact that the scheme is homomorphic allows the honest prover to answer the different queries (homomorphically) and the intuition was that the use of different keys means that only local homomorphisms are possible. Dwork et al. <ref type="bibr" target="#b11">[11]</ref> questioned this intuition and raised the question of whether there exist spooky encryption schemes that allow for other kinds of attacks which can break the soundness of the <ref type="bibr">[1]</ref> protocol. We show that this is indeed the case: there exists an MIP (suggested by <ref type="bibr" target="#b11">[11]</ref>) which, when combined with any AFS-2-spooky encryption scheme via the <ref type="bibr">[1]</ref> transformation, yields an insecure protocol. The MIP that we use is based on a PCP for 3-coloring due to Petrank <ref type="bibr" target="#b27">[27]</ref>:</p><p>Theorem 9 <ref type="bibr" target="#b27">[27]</ref>. There exists a universal constant ε &gt; 0 such that distinguishing between the following two types of graphs is NP complete:</p><p>-Every 3-coloring of G has at least ε fraction of monochromatic edges.</p><p>This PCP leads to the following natural MIP protocol between a verifier V and two non-communicating provers P 1 and P 2 (who, in case G is 3-colorable, also have access to the same 3-coloring of G).</p><p>1. V chooses a random edge (u, v) ∈ E, then with probability 1/3 it sets q 1 = u and q 2 = v, with probability 1/3 it sets q 1 = u and q 2 = u, and with probability 1/3 it sets q 1 = v and q 2 = v. V sends q 1 to P 1 and q 2 to P 2 . 2. Each P i sends the color a i ∈ {0, 1, 2} of the vertex q i (encoded as two bits). 3. V accepts if q 1 = q 2 and a 1 = a 2 , or if q 1 = q 2 and a 1 = a 2 .</p><p>Completeness and soundness are easy to see, some details are given in the full version <ref type="bibr" target="#b9">[9]</ref>.</p><p>Insecurity of the 3-Coloring MIP. Composed the foregoing MIP with any AFS-2-spooky encryption scheme yields an insecure protocol. More specifically, the cheating prover is given ciphertexts c 1 = Enc pk 1 (q 1 ) and c 2 = Enc pk 2 (q 2 ). Loosely speaking, using the spooky evaluation algorithm it can produce ciphertexts Enc pk 1 (a 1 ) and Enc pk 2 (a 2 ) for bits a 1 , a 2 ∈ {0, 1} such that a 1 = a 2 if and only if u = v. It sends as its answers to V the ciphertext Enc pk 1 (0), Enc pk 1 (a 1 ) as its answer to the first query and Enc pk 1 (0), Enc pk 1 (a 2 ) as its answer to the second query (the extra encryption of 0 is used simply because the verifier expects an answer with 2 bits). Now, if the verifier choose q 1 = u and q 2 = v (corresponding to the first of the three possibilities) then q 1 = q 2 and so a 1 = a 2 and the verifier accepts. Otherwise, (i.e. if q 1 = q 2 ) then we have that a 1 = a 2 and again the verifier accepts. Hence, we have shown a strategy that breaks the soundness of the scheme with probability 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">2-Round MPC from AFS-Spooky Encryption</head><p>AFS-spooky encryption seems to be a useful tool for minimally-interactive multiparty protocols: it lets each party broadcast an encryption of its input under its own key, then everyone individually performs the AFS-spooky evaluation locally, and each party can locally decrypt and recover a share of the output (relative to an additive n-out-of-n secret-sharing scheme). Finally another round of communication can be used to recover the secret from all the shares. Implementing this the approach requires attention to some details, such as ensuring that the spooky evaluation is deterministic (so that all the parties arrive at the same sharing) and making the shares simulatable. The latter can be done by having each party distribute a random additive sharing of 0 in the first round, and then adding all their received shares to their spooky generated share before broadcasting it in the second round.</p><p>A different (but similar) avenue for implementing 2-round MPC, is by reducing AFS-spooky encryption to multi-key FHE with threshold decryption (TMFHE). This primitive was recently formalized by Mukherjee and Wichs <ref type="bibr" target="#b22">[22]</ref>, who showed how to use it to generically construct 2-round MPC. Just like spooky encryption, a TMFHE scheme can homomorphically process n ciphertexts c 1 , . . . , c n , encrypting values x 1 , . . . , x n under independent public keys pk 1 , . . . , pk n , producing for any function f a ciphertext c * = Eval(f, (pk 1 , c 1 ), . . . , (pk n , c n )). The ciphertexts c * cannot be decrypted by any single secret keys sk i individually, but each party can compute a partial decryption y i = PartDec ski (c * ) and these y's can be combined to get y = FinDec(y 1 , . . . , y n ) = f (x 1 , . . . , x n ). For security, Mukherjee and Wichs required that for each individual i, the partial decryption y i can be simulated given the evaluated ciphertext c * , the final output y and the secret key sk j for j = i (see <ref type="bibr" target="#b22">[22]</ref> for formal definitions).</p><p>We observe that an AFS-spooky encryption with perfect correctness immediately yields a TMFHE scheme. The homomorphic evaluation procedure Eval of the TMFHE runs the Spooky-Eval procedure of the AFS-spooky encryption and sets c * = (c 1 , . . . , c n ) to be the resulting ciphertexts. The partial decryption procedure PartDec ski (c * ) outputs y i = Dec ski (c i ) and the combination procedure</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">C : ({0, 1} * ) n → {0</title>
	</analytic>
	<monogr>
		<title level="m">A depth-d, fan-in-2, n-input arithmetic circuit over GF</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Fast verification of any remote procedure call: short witness-indistinguishable one-round proofs for NP</title>
		<author>
			<persName><forename type="first">W</forename><surname>Aiello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bhatt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">R</forename><surname>Rajagopalan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP 2000</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Welzl</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">U</forename><surname>Montanari</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">D P</forename><surname>Rolim</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1853</biblScope>
			<biblScope unit="page" from="463" to="474" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Succinct arguments from multi-prover interactive proofs and their efficiency benefits</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bitansky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Chiesa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2012</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Safavi-Naini</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7417</biblScope>
			<biblScope unit="page" from="255" to="272" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Targeted malleability: homomorphic encryption for restricted computations</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Segev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Innovations in Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</editor>
		<meeting><address><addrLine>Cambridge, MA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012-01-10">8-10 January 2012. 2012</date>
			<biblScope unit="page" from="350" to="366" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Function secret sharing</title>
		<author>
			<persName><forename type="first">E</forename><surname>Boyle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Gilboa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2015</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Oswald</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Fischlin</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">9057</biblScope>
			<biblScope unit="page" from="337" to="367" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Classical hardness of learning with errors</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Brakerski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Langlois</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Peikert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Regev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Stehlé</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Theory of Computing Conference, STOC 2013</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Roughgarden</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Feigenbaum</surname></persName>
		</editor>
		<meeting><address><addrLine>Palo Alto, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013-06-04">1-4 June 2013. 2013</date>
			<biblScope unit="page" from="575" to="584" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Obfuscation of probabilistic circuits and applications</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tessaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2015, Part II</title>
		<editor>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Nielsen</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">9015</biblScope>
			<biblScope unit="page" from="468" to="497" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Multi-identity and multi-key leveled FHE from learning with errors</title>
		<author>
			<persName><forename type="first">M</forename><surname>Clear</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Mcgoldrick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2015</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Robshaw</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">9216</biblScope>
			<biblScope unit="page" from="630" to="656" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Bounded CCA2-secure encryption</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cramer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Hanaoka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Hofheinz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Imai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kiltz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shelat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2007</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Kurosawa</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4833</biblScope>
			<biblScope unit="page" from="502" to="518" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Spooky encryption and its applications</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">D</forename><surname>Rothblum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wichs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="page">272</biblScope>
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Efficient public-key cryptography in the presence of key leakage</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Haralambiev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>López-Alt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wichs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2010</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Abe</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6477</biblScope>
			<biblScope unit="page" from="613" to="631" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Succinct proofs for NP and spooky interactions</title>
		<author>
			<persName><forename type="first">C</forename><surname>Dwork</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Langberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nissim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Reingold</surname></persName>
		</author>
		<ptr target="http://www.cs.bgu.ac.il/∼kobbi/papers/spookysubcrypto.pdf" />
	</analytic>
	<monogr>
		<title level="m">Unpublished manuscript)</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Two-round secure MPC from indistinguishability obfuscation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Raykova</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2014</title>
		<editor>
			<persName><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8349</biblScope>
			<biblScope unit="page" from="74" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">i-hop homomorphic encryption and rerandomizable Yao circuits</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2010/145" />
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2010</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Rabin</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6223</biblScope>
			<biblScope unit="page" from="155" to="172" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Separating succinct non-interactive arguments from all falsifiable assumptions</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wichs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="99" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Distributed point functions and their applications</title>
		<author>
			<persName><forename type="first">N</forename><surname>Gilboa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2014</title>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">Q</forename><surname>Nguyen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Oswald</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8441</biblScope>
			<biblScope unit="page" from="640" to="658" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">How to play any mental game or a completeness theorem for protocols with honest majority</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th Annual ACM Symposium on Theory of Computing</title>
		<meeting>the 19th Annual ACM Symposium on Theory of Computing<address><addrLine>New York, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="218" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Randomizing polynomials: a new representation with applications to round-efficient secure computation</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">st Annual Symposium on Foundations of Computer Science, FOCS 2000</title>
		<meeting><address><addrLine>Redondo Beach, California, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-11-14">12-14 November 2000. 2000</date>
			<biblScope unit="page" from="294" to="304" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Delegation for bounded space</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">T</forename><surname>Kalai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Raz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">D</forename><surname>Rothblum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="565" to="574" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">How to delegate computations: the power of no-signaling proofs</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">T</forename><surname>Kalai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Raz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">D</forename><surname>Rothblum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Theory of Computing, STOC</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-05-31">2014. May 31-June 03 2014. 2014</date>
			<biblScope unit="page" from="485" to="494" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Round-optimal secure two-party computation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2004</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Franklin</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer, Heidelberg</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3152</biblScope>
			<biblScope unit="page" from="335" to="354" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">On-the-fly multiparty computation on the cloud via multikey fully homomorphic encryption</title>
		<author>
			<persName><forename type="first">A</forename><surname>López-Alt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Tromer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 44th Symposium on Theory of Computing Conference, STOC 2012</title>
		<meeting>the 44th Symposium on Theory of Computing Conference, STOC 2012<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012-05-22">19-22 May 2012. 2012</date>
			<biblScope unit="page" from="1219" to="1234" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Two round multiparty computation via multi-key FHE</title>
		<author>
			<persName><forename type="first">P</forename><surname>Mukherjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wichs</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-662-49896-5_26</idno>
		<ptr target="http://eprint.iacr.org/2015/345" />
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2016</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Fischlin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J.-S</forename><surname>Coron</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">9666</biblScope>
			<biblScope unit="page" from="735" to="763" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Efficient oblivious transfer protocols</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twelfth Annual Symposium on Discrete Algorithms</title>
		<meeting>the Twelfth Annual Symposium on Discrete Algorithms<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-01-09">7-9 January 2001. 2001</date>
			<biblScope unit="page" from="448" to="457" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Maliciously circuit-private FHE</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Paskin-Cherniavsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Paskin-Cherniavsky</surname></persName>
		</author>
		<ptr target="https://eprint.iacr.org/2013/307" />
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2014, Part I</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8616</biblScope>
			<biblScope unit="page" from="536" to="553" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Public-key cryptosystems from the worst-case shortest vector problem: extended abstract</title>
		<author>
			<persName><forename type="first">C</forename><surname>Peikert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 41st Annual ACM Symposium on Theory of Computing</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Mitzenmacher</surname></persName>
		</editor>
		<meeting>the 41st Annual ACM Symposium on Theory of Computing<address><addrLine>Bethesda, MD, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009-05-31">2009. May 31-June 2 2009. 2009</date>
			<biblScope unit="page" from="333" to="342" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<author>
			<persName><forename type="first">C</forename><surname>Peikert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shiehian</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="m">Multi-key FHE from LWE, revisited. Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2016">2016/196. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The hardness of approximation: gap location</title>
		<author>
			<persName><forename type="first">E</forename><surname>Petrank</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Complex</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="133" to="157" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">On lattices, learning with errors, random linear codes, and cryptography</title>
		<author>
			<persName><forename type="first">O</forename><surname>Regev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page">40</biblScope>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
