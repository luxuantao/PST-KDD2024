<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Delay-Optimal Technology Mapping by DAG Covering</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Yuji</forename><surname>Kukimoto</surname></persName>
							<email>fkukimoto@eecs.berkeley.edu</email>
						</author>
						<author>
							<persName><forename type="first">Robert</forename><forename type="middle">K</forename><surname>Brayton</surname></persName>
							<email>braytong@eecs.berkeley.edu</email>
						</author>
						<author>
							<persName><forename type="first">Prashant</forename><surname>Sawkar</surname></persName>
							<email>psawkar@ichips.intel.com</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering and Computer Sciences Strategic CAD Laboratories</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>94720</postCode>
									<settlement>Berkeley</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Intel Corporation</orgName>
								<address>
									<postCode>97124</postCode>
									<settlement>Hillsboro</settlement>
									<region>OR</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Delay-Optimal Technology Mapping by DAG Covering</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">076BC801B03ECF76A58711D2E7428423</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T09:49+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We propose an algorithm for minimal-delay technology mapping for library-based designs. We show that subject graphs need not be decomposed into trees for delay minimization; they can be mapped directly as DAGs. Experimental results demonstrate that significant delay improvement is possible by this new approach.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In 1987 Keutzer <ref type="bibr" target="#b6">[7]</ref> proposed an algorithmic approach to the technology mapping problem, in which he observed similarity between this problem and the code optimization problem for programming languages and adapted an existing tree-covering technique for the latter problem to technology mapping. This approach soon dominated rule-based approaches and became the de facto standard.</p><p>In Keutzer's formulation a technology-independent circuit and each gate in a given library are decomposed into NAND2-INV circuits. The decomposed circuit is called a subject graph while each decomposed gate is called a pattern graph. The technology mapping problem can then be formulated as covering the subject graph by using pattern graphs. A subject graph is a directed acyclic graph (DAG) in general since it is derived from a given network. Keutzer showed that if a subject graph is a DAG, graph covering for minimum area mapping is NP-hard <ref type="bibr" target="#b7">[8]</ref>. He further proposed a linear-time dynamic programming algorithm which guarantees optimal results for the case where a subject graph and pattern graphs are trees. These observations led naturally to the following threestep approach: (1) Decompose a subject DAG into a disjoint set of trees (2) Solve the technology mapping problem optimally for each tree (3) Glue the results together. This separation of the problem again has become a standard approach due to the theoretical justification about the complexity of DAG covering.</p><p>Inspired by Keutzer's result technology mapping has been studied extensively to optimize different criteria. Rudell <ref type="bibr" target="#b11">[12]</ref> worked on minimum-delay technology mapping and showed that if loading effects are completely ignored, the minimum-delay mapping problem for subject trees can be solved optimally by dynamic programming in linear time. He also considered the minimum-delay mapping problem for trees under loading effects and showed that by maintaining the best mapping for each possible load at each node the same dynamic programming approach can guarantee optimal results. Touati <ref type="bibr" target="#b12">[13]</ref> further refined this idea later by combining the optimal tree mapping with sophisticated buffer tree construction. An interesting fact is that they directly started looking at tree covering without studying the complexity of DAG covering for minimum delay.</p><p>In parallel to these works on library-based technology mapping the emergence of FPGAs posed a new technology mapping problem in early 90's. LUT-based FPGAs can implement any function of k inputs by a single LUT, where k is a fixed constant depending on a given technology. It is not practical to follow the same approach as This work is partially supported by SRC-98-DC-324. library-based technology mapping since one needs to generate pattern graphs for all 2 2 k k-input functions. Based on this observation many ideas have been proposed for the FPGA mapping problem again under different cost criteria <ref type="bibr" target="#b3">[4]</ref>. As for minimum area mapping Levin et al. <ref type="bibr" target="#b9">[10]</ref> and Farrahi et al. <ref type="bibr" target="#b5">[6]</ref> proved that the problem is NP-hard for k = 4 and k 5 respectively. Minimum-delay mapping, on the other hand, was shown for LUT-based FPGAs to be solvable in polynomial time by <ref type="bibr">Cong et al.</ref> in <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref>. Here the given circuit is directly mapped without decomposing its DAG structure to trees unlike conventional library-based mapping.</p><p>In this paper we consider the minimum-delay technology mapping problem for library-based designs where a subject graph is a DAG. Careful analysis of <ref type="bibr" target="#b1">[2]</ref> shows that the basic dynamic programming approach in <ref type="bibr" target="#b1">[2]</ref> is not specific to FPGA mapping and can be easily adapted to library-based mapping. This leads to a linear time algorithm for minimum-delay DAG covering under load-independent delay models. As far as we know, this is the first result that shows that the minimum-delay technology mapping problem for DAGs can be solved optimally in polynomial time. This implies that tree decomposition in performance-oriented mapping is not necessary; a given subject DAG can be directly mapped optimally. We experimentally confirmed that the additional solution space explored by this direct approach finds significantly faster mappings especially under a rich library.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Delay-Optimal T echnology Mapping fo r FPGAs</head><p>We will have a close look at the FlowMap algorithm presented in <ref type="bibr" target="#b1">[2]</ref> since this gives the basis of our proposed algorithm.</p><p>Assume that a network is decomposed into a k-bounded network <ref type="bibr" target="#b1">[2]</ref>, which is a Boolean network where the number of fanins of each node is less than or equal to k. If a given network is not kbounded, simple decomposition can yield an equivalent k-bounded network. In the following we assume that an LUT has a unit delay and that wiring delay is negligible.</p><p>The key idea of the FlowMap algorithm is in the labeling procedure that labels each node of the DAG its optimal depth achievable. The algorithm visits each node in the network in a topological order. All primary inputs are labeled 0 assuming that they are available at t = 0. At each intermediate node the goal is to investigate all cuts of size less than or equal to k in the fanin cone of the node and to find the best delay realizable at the node. Each such cut represents a mapping of the node. More specifically the node can be implemented by a single LUT whose inputs are the nodes forming the cut. The constraint on the size of cuts comes from the fact that an LUT can implement any function of up to k-inputs. Since nodes are visited in a topological order, by the time the current node is examined the optimal depths of all the nodes in its transitive fanin are available. Therefore the optimal depth of the current node x can be computed as follows by dynamic programming.</p><p>optimal depthx = min cut X:jXjk max x i 2X optimal depthxi + 1 Notice that this cost criterion meets the principle of optimality of dynamic programming. The cut X that realizes the optimal depth is stored at the node along with the depth. Although explicit enumeration of all valid cuts is possible by a brute-force approach, the complexity is pseudo polynomial On k , where n is the number of nodes in a given network. <ref type="bibr" target="#b1">[2]</ref> showed that this optimal depth com-</p><formula xml:id="formula_0">35 th Design Automation Conference ® Copyright ©1998 ACM 1-58113-049-x-98/0006/$3.50 DAC98 -06/98 San Francisco, CA USA</formula><p>Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full cit ation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee.</p><p>DAC 98, June 15-19, 1998, San Francisco, CA USA ISBN 1-58113-049-x/98/06…$5.00</p><p>putation at each node can be formulated as a network flow problem whose runtime is strongly polynomial with respect to k.</p><p>Once all the nodes have been labeled by their optimal depths, the network is traversed backward from primary outputs to primary inputs. At each primary output an LUT is created whose fanins are the same as the best cut stored at the node. The LUT creation is repeated for each of those fanins. This process is continued until either a primary input or a node whose output is already available in the mapping is reached. An important fact is that intermediate nodes are automatically duplicated in an optimal way to guarantee optimal depths while in tree mapping no duplication is allowed.</p><p>The complexity of the entire algorithm is Okmn, where m is the number of edges in the network.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Delay-Optimal T echnology Mapping for Library-Based Designs</head><p>Although the FlowMap algorithm was originally developed for FP-GAs, the basic principle of the labeling procedure is not necessarily specific to those architectures 1 . In this section we will show how the FlowMap algorithm can be easily adapted to the standard librarybased technology mapping under a load-independent delay model, where each gate has an intrinsic delay and loading has no effect in delays. This extension leads to a linear time algorithm for delayoptimal technology mapping of DAG networks. We assume that a given network is decomposed into a subject DAG as usual. Therefore, the optimality of delay is claimed with respect to this subject DAG.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Computation of Optimal Delay at Internal Nodes</head><p>The only difference between FPGAs and library-based designs is how an internal node is mapped. In FPGAs all the local mappings that cover an internal node and part of its fanin cone are examined by enumerating all k-cuts of the fanin cone, which gives the best possible delay realized at the node. This step needs to be modified for library-based designs so that all successful matches for a given set of pattern graphs are systematically examined. However this can be easily done by mimicking the standard pattern matching step used in conventional technology mapping. More precisely once the fanin cone of the node is extracted, the standard matching procedure against pattern graphs can be applied to exhaustively check all the successful matches. This way the best delay achievable at each intermediate node can be computed in a similar way to <ref type="bibr" target="#b1">[2]</ref>. The only difference is that actual pin-to-pin delays of gates specified in a given library need to be used in our case instead of unit delay in <ref type="bibr" target="#b1">[2]</ref>. As with FPGA mapping, the principle of optimality is still valid here. Notice that as long as delay is optimized, any DAG pattern graph can be used directly without losing the optimality, i.e. it is not necessary to restrict the library to pattern graphs of trees and leaf DAGs. General DAG patterns are problematic only in the context of area optimization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Pattern Matching</head><p>We now examine how pattern matching is done between a subject graph and a pattern graph.</p><p>Pattern matching between a subject graph and a pattern graph in the context of technology mapping was studied extensively by Keutzer <ref type="bibr" target="#b6">[7]</ref> and Rudell <ref type="bibr" target="#b11">[12]</ref>. A match between a subject graph Gs = V s ; E s and a pattern graph Gp = V p ; E p is defined as follows <ref type="bibr" target="#b11">[12]</ref>. Definition 1 A (standard)match of a pattern graph Gp = V p ; E p on a subject graph Gs = V s ; E s is a one-to-one mapping of the pattern graph nodes into the subject graph nodes I : Vp 7 ! Vs such that:</p><p>1 It is interesting to note that <ref type="bibr" target="#b1">[2]</ref> has a comment as follows. "Our result makes a sharp contrast with the fact that the conventional technology mapping problem in library-based designs is NP-hard for general Boolean networks."(page 2 <ref type="bibr" target="#b1">[2]</ref>) 2. 8v 2 Vp; jivj 6 = 0 j i v j = j i I v j; where iv = f w j w;v 2 Egfor G = V;E.</p><p>The first condition requires that the edge relationship in the pattern graph is completely preserved in the subject graph. The second condition constrains the in-degree of a non-primary-input node in the pattern graph to be the same as that of the matching node in the subject graph. Notice that it is allowed for a subject-graph node covered by an intermediate pattern-graph node to have fanout to a node which is not covered by the pattern graph. However, in the conventional tree-covering based approach such a match is invalid, i.e. all fanouts of a subject-graph node matched with an intermediate pattern-graph node need to be covered by the same pattern. A match satisfying this additional constraint is called an exact match <ref type="bibr" target="#b11">[12]</ref> and defined as follows.</p><p>Definition 2 An exact match of a pattern graph Gp = V p ; E p on a subject graph Gs = V s ; E s is a one-to-one mapping of the pattern graph nodes into the subject graph nodes I : Vp 7 ! Vs such that:</p><p>1. 8e = e 1 ; e 2 2E p ; I e 1 ; I e 2 2 Es. 2. 8v 2 Vp; jivj 6 = 0 j i v j = j i I v j 3. 8v 2 Vp; jivj 6 = 0 and jovj 6 = 0 j o v j = j o I v j, where ov = f w j v;w 2Egfor G = V;E.</p><p>Rudell proposed an algorithm called graph match <ref type="bibr" target="#b11">[12]</ref> for the general case where both a subject graph and a pattern graph are DAGs. We can simply use this matching algorithm to enumerate all successful standard matches instead of exact matches.</p><p>Although a constraint that a mapping is one-to-one is posed in the above two definitions by Rudell, this can be safely dropped as follows, which leads to the definition of a larger class of matches.</p><p>Definition 3 An extended match of a pattern graph Gp = V p ; E p on a subject graph Gs = V s ; E s is a mapping of the pattern graph nodes into the subject graph nodes I : Vp 7 ! Vs such that:</p><p>1. 8e = e 1 ; e 2 2E p ; I e 1 ; I e 2 2 Es.</p><p>2. 8v 2 Vp; jivj 6 = 0 j i v j = j i I v j</p><p>The only difference between extended matches and standard matches is that in extended matches the requirement of a mapping from the pattern graph nodes into the subject graph nodes being one-to-one is dropped. Therefore extended matches subsume standard matches. This relaxation of the requirement allows duplication of subject graph nodes while searching for a match by unfolding a DAG structure. Figure <ref type="figure" target="#fig_0">1</ref> shows an example where a pattern graph is matched successfully as an extended match but not as a standard match. Assume that a two-input node is a NAND2 gate and a single-input node is an inverter. Consider pattern matching at the top node of the subject graph shown on the left against the pattern graph on the right. An extended match exists by mapping both m and m 0 to n while a standard match does not since such a mapping violates the one-to-one mapping property. A simple modification to the graph match algorithm makes the algorithm search all extended matches instead of all standard matches without changing its asymptotic complexity. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Constructing an Optimum Mapping</head><p>Once a (best delay, best gate)-pair is computed at each node, a delay-optimal network can be constructed in exactly the same way as in <ref type="bibr" target="#b1">[2]</ref>. We maintain a queue which contains nodes to be created in the final mapping. This queue is initialized to the set of all primary outputs. A node is picked up from the queue and the best gate at the node is created in the mapping. Each fanin node of the gate is then inserted to the queue if the fanin is not a primary input and does not yet have a corresponding gate in the mapping. Once the queue becomes empty, the mapping is complete.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Complexity o f D A G Mapping for Delay Minimization</head><p>An application of graph match to enumerate all successful matches at a node is Op <ref type="bibr" target="#b11">[12]</ref>, where p is the number of nodes in the entire unique pattern graphs<ref type="foot" target="#foot_0">2</ref> . Since this procedure is called once at each node in a subject graph, the complexity of the labeling step is Osp, where s is the number of nodes in the subject graph. The final step of constructing a delay-optimal mapping only costs Os. Therefore the complexity of DAG mapping is Osp. Since p is a constant defined by a given technology, the procedure is linear in the size of a subject graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Comparison between DAG Mapping and Tree Mapping</head><p>In the past, performance-oriented technology mapping has been done by a combination of tree covering and buffer tree construction <ref type="bibr" target="#b12">[13]</ref>. A fundamental limitation of this conventional treecovering approach is that the search space is highly limited by the structure of a given subject graph since multiple-fanout points in the subject graph are completely preserved in the final results. On the other hand, since DAG mapping does not respect initial multiplefanout points at all, it can explore a strictly larger search space.</p><p>In other words multiple-fanout points are created as the result of delay optimization as we see later in Figure <ref type="figure" target="#fig_1">2</ref>. Buffering techniques proposed in the literature can be directly used in conjunction with DAG covering to speed up such multiple-fanout points. Another major difference is how subject-graph nodes are duplicated during technology mapping. DAG mapping can duplicate subject-graph nodes while creating final mappings whereas in tree mapping no duplication is allowed since each subject-graph node is covered only once by a single pattern. In some sense, subject-graph node duplication is limited to the buffer tree construction phase in the tree-mapping-based approach.</p><p>Figure <ref type="figure" target="#fig_1">2</ref> illustrates how duplication of subject-graph nodes helps reduce the delay of a mapping. Consider a subject graph shown on the left. Suppose that a pattern graph on the right is available in a given library. If tree mapping is invoked on this subject graph, the pattern graph is of no use since there is no exact match between the subject graph and the pattern graph. If, on the other hand, DAG mapping is employed, the two output nodes in the subject graph are implemented as in Figure <ref type="figure" target="#fig_1">2</ref>. The cone rooted at the middle node in the subject graph is duplicated in this mapping, which makes effective use of the pattern graph possible.</p><p>This example also illustrates how multiple-fanout points are created in DAG mapping. Since the middle node of the subject graph with multiple fanouts is an internal node of each of the matchings in Figure <ref type="figure" target="#fig_1">2</ref>, the mapped circuit does not inherit the multiple fanout point. On the other hand, the two primary inputs of the subject graph in the middle have multiple fanouts in the mapped circuit while each of the inputs has a single fanout in the subject graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Extensions</head><p>We will examine how the approach of Section 3 can be generalized to sequential circuits so that optimal cycle time is guaranteed in conjunction with retiming. We only consider sequential circuits with edge-triggered latches all of which are controlled by a single clock.</p><p>This problem was studied for LUT-based FPGAs by Pan and</p><p>Liu <ref type="bibr" target="#b10">[11]</ref>. Given a k-bounded network consider the following threestep transformation: (1) Retime an initial circuit, (2) Perform technology mapping of the combinational portion of the circuit, (3) Retime the resulting mapped circuit. <ref type="bibr" target="#b10">[11]</ref> proposed a polynomial-time algorithm for computing the minimum cycle-time mapping among all the mapped circuits obtained by the above transformation, which was later improved in <ref type="bibr" target="#b4">[5]</ref>. The key ingredient is a polynomial-time decision procedure which determines whether there exists a mapping whose cycle time is less than or equal to a given value. This procedure is used repeatedly to guide a binary search to determine the minimum cycle time achievable by retiming and optimal technology mapping. The core of this decision procedure is again a labeling scheme quite similar to the one used in FlowMap <ref type="bibr" target="#b1">[2]</ref>. All k-cuts at each intermediate node are explored by considering retiming possibility. This is again done implicitly by converting the original problem to a flow network problem. This step of examining all k cuts can be replaced by pattern matching as was done for combinational mapping. All the other theories hold without any modification. Details are omitted here due to page limitation. So far optimality is guaranteed in terms of a subject graph constructed arbitrarily from a given circuit by decomposition. Since a single subject graph is chosen among a huge number of different decompositions without knowing an actual library to be used, it is likely that many potentially good mappings are simply not explored due to this initial choice. Lehman et al. <ref type="bibr" target="#b8">[9]</ref> have recently resolved this issue by encoding various decompositions into a single extended subject graph called mapping graph and performing technology mapping on it. Since this technique is orthogonal to our technique, the two can be combined to produce even better results. In fact, we have recently become aware that the actual implementation of <ref type="bibr" target="#b8">[9]</ref> performed DAG covering similar to ours although <ref type="bibr" target="#b8">[9]</ref> discusses their algorithm for subject trees <ref type="bibr" target="#b13">[14]</ref>. It is interesting to know how much of delay improvement in <ref type="bibr" target="#b8">[9]</ref> is due to DAG covering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experimental Results</head><p>To show the effectiveness of this approach the technology mapper of SIS was extended so that delay-optimal mapping is obtained for combinational circuits by DAG covering <ref type="foot" target="#foot_1">3</ref> . As discussed in the previous sections the delay model used in this experiment is the intrinsic delay model where a fixed, load-independent delay is given between each input and the output of a gate. This is in fact the delay model used in <ref type="bibr" target="#b8">[9]</ref>. Although loading effects are certainly an important factor in delays, there are several justifications one way to capture this flexibility in technology mapping is to approximate this flexibility by having many discrete size gates. This approach, however, is known to be very expensive. The approach taken in <ref type="bibr" target="#b8">[9]</ref> is to pick a single delay for each gate and perform technology mapping by ignoring loads. Each gate in the final mapping is then continuously sized by considering actual loads so that the delay matches the one associated with the gate. Even without the capability of continuous sizing, the buffer tree construction methods of <ref type="bibr" target="#b12">[13]</ref> can be used later at multiple fanout points to reduce load dependency of delays. Therefore the use of this delay model is at least justified as an approximation to the minimum-delay mapping problem under realistic delay models. Table <ref type="table" target="#tab_0">1</ref> shows the comparison of the quality of final circuits between the DAG mapping approach proposed in this paper and the standard tree mapping approach. In this experiment each benchmark circuit was first decomposed into a subject graph. We then applied the DAG mapping algorithm and the tree mapping algorithm on this same subject graph using MCNC gate library lib2.genlib<ref type="foot" target="#foot_2">4</ref> . The effectiveness of the DAG mapping algorithm is clear. We could obtain significantly faster circuits. CPU time was obtained on DEC AlphaServer 8400 5/300 and is reported in seconds. The increase of CPU time from tree mapping to DAG mapping is reasonable.</p><p>The same experiment was repeated using different libraries to see how the DAG mapping algorithm performs on rich libraries. MCNC libraries 44-1.genlib and 44-3.genlib were used in this comparison. The former library only contains 7 gates while the latter library has 625 gates, many of which are complex gates with many inputs <ref type="foot" target="#foot_3">5</ref> . 44-3.genlib is a strict superset of 44-1.genlib. Table <ref type="table" target="#tab_1">2</ref> and Table <ref type="table" target="#tab_2">3</ref> summarize the results of 44-1 and 44-3 respectively. We can see that the difference in mapping quality between the DAG and tree mapping approaches is further pronounced with the use of richer libraries. Complex gates are used more effectively in DAG covering than in tree covering since no tree decomposition is performed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusions</head><p>We have shown that the delay-optimal technology mapping problem for combinational circuits under load-independent delay models can be solved optimally in polynomial time without decomposing a subject DAG into trees. We experimentally showed that the proposed approach gives significant improvement in mapping quality compared against conventional tree mapping. Extensions of this technique to sequential circuits have also been discussed.</p><p>In this paper we focus on delay minimization without any area consideration. Therefore at each intermediate node the fastest mapping is simply created no matter how critical the node is. By constructing slower but smaller mapping for non-critical subnetworks we can have a better control over area increase. Cong et al. <ref type="bibr" target="#b2">[3]</ref> already have results on area-delay tradeoff for FPGA mapping based on the FlowMap algorithm. An extension of this idea to library-based mapping is currently being investigated. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Standard Match vs. Extended Match 1. 8e = e 1 ; e 2 2E p ; I e 1 ; I e 2 2 Es.2. 8v 2 Vp; jivj 6 = 0 j i v j = j i I v j; where iv = f w j w;v 2 Egfor G = V;E.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Duplication of Subject-Graph Nodes in DAG Mapping</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Tree mapping vs. DAG mapping for lib2.genlib</figDesc><table><row><cell>. In de-</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Tree mapping vs. DAG mapping for 44-1.genlib</figDesc><table><row><cell>circuit</cell><cell cols="2">Delay</cell><cell cols="2">Area</cell><cell cols="2">CPU time</cell></row><row><cell></cell><cell cols="2">tree DAG</cell><cell>tree</cell><cell cols="3">DAG tree DAG</cell></row><row><cell>C2670</cell><cell>27</cell><cell cols="2">18 2998</cell><cell>4568</cell><cell>2.0</cell><cell>2.0</cell></row><row><cell>C3540</cell><cell>42</cell><cell cols="2">30 4007</cell><cell>6640</cell><cell>2.7</cell><cell>2.8</cell></row><row><cell>C5315</cell><cell>46</cell><cell cols="2">33 6817</cell><cell>8352</cell><cell>4.6</cell><cell>4.8</cell></row><row><cell cols="2">C6288 125</cell><cell cols="2">120 7782</cell><cell>7121</cell><cell>4.3</cell><cell>4.4</cell></row><row><cell>C7552</cell><cell>39</cell><cell cols="3">28 9552 11149</cell><cell>6.0</cell><cell>6.3</cell></row><row><cell>circuit</cell><cell>Delay</cell><cell></cell><cell cols="2">Area</cell><cell cols="2">CPU time</cell></row><row><cell></cell><cell cols="2">tree DAG</cell><cell>tree</cell><cell>DAG</cell><cell cols="2">tree DAG</cell></row><row><cell>C2670</cell><cell>22</cell><cell cols="2">10 2314</cell><cell>3943</cell><cell cols="2">92.2 159.7</cell></row><row><cell>C3540</cell><cell>28</cell><cell cols="2">13 2983</cell><cell cols="3">6148 128.2 255.6</cell></row><row><cell>C5315</cell><cell>31</cell><cell cols="2">15 5115</cell><cell cols="3">6685 220.4 341.5</cell></row><row><cell cols="2">C6288 125</cell><cell cols="5">42 7694 14775 155.1 229.5</cell></row><row><cell>C7552</cell><cell>27</cell><cell cols="5">13 7062 13267 248.7 491.0</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 :</head><label>3</label><figDesc>Tree mapping vs. DAG mapping for 44-3.genlib</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>Note that p is not equal to the number of nodes in the entire pattern graphs since during matching a single pattern graph is tried for all possible permutations of its inputs. p is thus the number of nodes in the expanded pattern graphs. See<ref type="bibr" target="#b11">[12]</ref> for details.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>In this experiment we used graph match for only finding standard matches instead of extended matches. Therefore the optimality of the results is claimed with respect to standard matches. So far we have not been able to see any major difference in mapping quality between the use of standard matches and extended matches.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>Each gate has a non-zero load-dependent delay specified in lib2.genlib. In the experiment this was simply assumed to be zero.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_3"><p>The largest gate has 16 inputs.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">An optimal technology mapping algorithm for delay optimization in lookup-table based FPGA designs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ding</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Conference on Computer-Aided Design</title>
		<meeting>IEEE International Conference on Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1992-11">November 1992</date>
			<biblScope unit="page" from="48" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">FlowMap: An optimal technology mapping algorithm for delay optimization in lookup-table based FPGA designs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ding</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computer-Aided Design</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="12" />
			<date type="published" when="1994-01">January 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">On area/depth trade-off in LUT-based FPGA technology mapping</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ding</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on VLSI Systems</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="137" to="148" />
			<date type="published" when="1994-06">June 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Combinational logic synthesis for LUT based field programmable gate arrays</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ding</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Design Automation of Electronic Systems</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="145" to="204" />
			<date type="published" when="1996-04">April 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">An improved algorithm for performance optimal technology mapping with retiming in LUT-based FPGA design</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Conference on Computer Design</title>
		<meeting>IEEE International Conference on Computer Design</meeting>
		<imprint>
			<date type="published" when="1996-10">October 1996</date>
			<biblScope unit="page" from="572" to="578" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Complexity of the lookup-table minimization problem for FPGA technology mapping</title>
		<author>
			<persName><forename type="first">A</forename><surname>Farrahi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sarrafzadeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computer-Aided Design</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1319" to="1332" />
			<date type="published" when="1994-11">November 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">DAGON: Technology binding and local optimization by DAG matching</title>
		<author>
			<persName><forename type="first">K</forename><surname>Keutzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 24th ACM/IEEE Design Automation Conference</title>
		<meeting>24th ACM/IEEE Design Automation Conference</meeting>
		<imprint>
			<date type="published" when="1987-06">June 1987</date>
			<biblScope unit="page" from="617" to="623" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Computational complexity of logic synthesis and optimization</title>
		<author>
			<persName><forename type="first">K</forename><surname>Keutzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Richards</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Workshop on Logic Synthesis</title>
		<meeting>International Workshop on Logic Synthesis</meeting>
		<imprint>
			<date type="published" when="1989-05">May 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Logic decomposition during technology mapping</title>
		<author>
			<persName><forename type="first">E</forename><surname>Lehman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Watanabe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Grodstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Harkness</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE/ACM International Conference on Computer-Aided Design</title>
		<meeting>IEEE/ACM International Conference on Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="1995-11">November 1995</date>
			<biblScope unit="page" from="264" to="271" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Realizing expression graphs using tablelookup FPGAs</title>
		<author>
			<persName><forename type="first">I</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">Y</forename><surname>Pinter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the European Design Automation Conference</title>
		<meeting>the European Design Automation Conference</meeting>
		<imprint>
			<date type="published" when="1993-09">September 1993</date>
			<biblScope unit="page" from="306" to="311" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Optimal clock period FPGA technology mapping for sequential circuits</title>
		<author>
			<persName><forename type="first">P</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 33rd ACM/IEEE Design Automation Conference</title>
		<meeting>33rd ACM/IEEE Design Automation Conference</meeting>
		<imprint>
			<date type="published" when="1996-06">June 1996</date>
			<biblScope unit="page" from="720" to="725" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Logic synthesis for VLSI design</title>
		<author>
			<persName><forename type="first">R</forename><surname>Rudell</surname></persName>
		</author>
		<idno>UCB/ERL M89/49</idno>
		<imprint>
			<date type="published" when="1989-04">April 1989</date>
		</imprint>
		<respStmt>
			<orgName>University of California, Berkeley</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Performance-oriented technology mapping</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Touati</surname></persName>
		</author>
		<idno>UCB/ERL M90/109</idno>
		<imprint>
			<date type="published" when="1990-11">November 1990</date>
		</imprint>
		<respStmt>
			<orgName>University of California, Berkeley</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Y</forename><surname>Watanabe</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997-10">October 1997</date>
		</imprint>
	</monogr>
	<note>Private communication</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
