<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A taxonomy of variability realization techniques ‡</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2005-04-01">1 April 2005</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Mikael</forename><surname>Svahnberg</surname></persName>
							<email>mikael.svahnberg@bth.se</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Systems and Software Engineering</orgName>
								<orgName type="institution">Blekinge Institute of Technology</orgName>
								<address>
									<postBox>Box 520</postBox>
									<postCode>SE-372 25</postCode>
									<settlement>Ronneby</settlement>
									<country key="SE">Sweden</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jilles</forename><surname>Van Gurp</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">GX creative online development B.V</orgName>
								<address>
									<addrLine>Wijchenseweg 111</addrLine>
									<postCode>NL-6538 SW</postCode>
									<settlement>Nijmegen</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jan</forename><surname>Bosch</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Department of Mathematics and Computing Science</orgName>
								<orgName type="institution">University of Groningen</orgName>
								<address>
									<postBox>P.O. Box 800</postBox>
									<postCode>NL-9700 AV</postCode>
									<settlement>Groningen</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="department">Department of Systems and Software Engineering</orgName>
								<orgName type="institution">Blekinge Institute of Technology</orgName>
								<address>
									<postBox>Box 520</postBox>
									<postCode>SE-372 25</postCode>
									<settlement>Ronneby</settlement>
									<country key="SE">Sweden</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A taxonomy of variability realization techniques ‡</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2005-04-01">1 April 2005</date>
						</imprint>
					</monogr>
					<idno type="MD5">8C05F970710E625356076AD11A953349</idno>
					<idno type="DOI">10.1002/spe.652</idno>
					<note type="submission">Received 13 November 2003 Revised 13 April 2004, 21 September 2004 Accepted 21 September 2004</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:56+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>variability</term>
					<term>software product families</term>
					<term>development process</term>
					<term>software architecture</term>
					<term>variability realization techniques</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Development of software product families relies heavily on the use of variability to manage the differences between products by delaying design decisions to later stages of the development and usage of the constructed software systems. Implementation of variability is not a trivial task, and is governed by a number of factors. In this paper, we describe the factors that are relevant in determining how to implement variability, and present a taxonomy of variability realization techniques.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Over the last few decades, the software systems that we have used and built have required and exhibited increasing variability, i.e. the ability of a software artifact to vary its behavior at some point in its lifecycle. We can identify two underlying forces that drive this development. First, we see that variability in systems has moved from mechanics and hardware to the software. Second, because of the cost of reversing design decisions once these are taken, software engineers typically try to delay such decisions to the latest phase in a system's lifecycle that is economically viable. An example of the first trend is car engine controllers. Most car manufacturers now offer engines with different characteristics for a particular car model. A new development is that frequently these engines are the same from a mechanical perspective and differ only in the software of the car engine controller. Thus, whereas previously the variation between different engine models was incorporated through the mechanics and hardware, due to economies of scale that exist for these artifacts, car developers have moved the variation to the software.</p><p>The second trend, i.e. delayed design decisions, can be illustrated through software product families <ref type="bibr" target="#b1">[2]</ref><ref type="bibr" target="#b2">[3]</ref><ref type="bibr" target="#b3">[4]</ref> and the increasing configurability of software products. Over the last decade many organizations have identified a conflict in their software development. On the one hand, the amount of software necessary for individual products is constantly increasing. On the other hand, there is a constant pressure to increase the number of software products put out on the market in order to better service the various market segments. For many organizations, the only feasible way forward has been to exploit the commonality between different products and to implement the differences between the products as variability in the software artifacts. The product family architecture and shared product family components must be designed in such a way that the different products can be supported, whether the products require replaced components, extensions to the architecture or particular configurations of the software components. Additionally, the software product family must also incorporate variability to support likely future changes in requirements and future generations of products. This means that when designing the commonalities of a software product line, not all decisions can be taken. Instead, design decisions are left open and determined at a later stage, e.g. when constructing a particular product or during runtime of a particular product. This is achieved through variability.</p><p>Since this article discusses variability, it is important to provide a definition of the term: software variability is the ability of a software system or artefact to be efficiently extended, changed, customized or configured for use in a particular context. This article is about techniques that enable software developers to improve variability of software artefacts.</p><p>Based on our case studies <ref type="bibr" target="#b4">[5]</ref><ref type="bibr" target="#b5">[6]</ref><ref type="bibr" target="#b6">[7]</ref>, we have found that it is not a trivial task to introduce variability into a software product family. We also see that engineers are seeking variation mechanisms beyond those shipped with their development tools or that are not supported by used software systems. The adoption of mechanisms such as aspect oriented programming <ref type="bibr" target="#b7">[8]</ref> and the popularity of generative and reflective techniques (see, e.g. <ref type="bibr" target="#b8">[9]</ref>) in programming communities such as Java and .Net are evidence of this.</p><p>Essentially, by supporting variability, design decisions are pushed to a later stage in the development. Rather than making specific design choices, the design choice is made to allow for variability at a later stage. For example, by allowing users to choose between different plug-ins for a media player, the media player designers can avoid hard wiring the playback feature to a particular playback functionality (by enabling the system to use plug-ins). Thus they can support new file formats after the media player has been shipped to the end user.</p><p>Many factors influence the choices of how design decisions can be delayed. Influencing factors include, for example, the type of software entity for which variability is required, how long the design decision can be delayed, the cost of delaying a design decision and the intended runtime environment. Another factor to consider is that variability does not need to be represented only in the architecture (i.e. the fundamental organization of a system embodied in its components, their relationships to each other and to the environment and the principles guiding its design and evolution <ref type="bibr" target="#b9">[10]</ref>) or the source code of a system. It can also be represented as procedures during the development process, making use of various tools outside of the actual system being built.</p><p>Although the use of variability techniques is increasing, research, both by others, e.g. <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b11">12]</ref>, and by ourselves, e.g. <ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref>, shows that several problems exist. A major cause of these problems is that software architects typically lack a good overview of the available variability techniques as well as the pros and cons of these techniques. In addition, they tend to apply them in an ad-hoc fashion without properly considering the various variability-related constraints imposed by requirements and the road map of the system. This paper discusses the factors that need to be considered for selecting an appropriate method or technique for implementing variability. We also provide a taxonomy of techniques that can be used to implement variability. The contribution of this is, we believe, that the notion of variability and its qualities is better understood and that more informed decisions concerning variability and variation points can be made during software development. The provided toolbox of available realization techniques facilitates the development process since the consequences of a particular choice can be seen at an early stage. This is similar to the way Design Patterns <ref type="bibr" target="#b15">[16]</ref> also present developers with consequences of a particular design decision.</p><p>It should be noted that this paper focuses on implementing variability in architecture and implementation artifacts, such as the software architecture design, the components and classes of a software system. We do not address issues related to how to handle, for example, variability of requirements, managing variations of design documents or test specifications, structure of the development organization, etc. While these are important subjects that need to be addressed to properly manage variability in a software product family, the goal of this paper is to cover the area of how to technically achieve variability in the software system. This paper should thus be seen as one piece in the large puzzle that is software product family variability. For a description of many of the other key areas to consider, please see <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">INTRODUCING VARIABILITY IN SOFTWARE PRODUCT FAMILIES</head><p>While introducing variability into a software product family there are a number of steps to take along the way in order to get the required variability in place, and to take care of it once it is in place. In this section we present the minimal number of steps (see Figure <ref type="figure" target="#fig_0">1</ref>) that in our experience are necessary to take. These steps are an extension of the process presented in our earlier article on software variability <ref type="bibr" target="#b12">[13]</ref>.</p><p>We use the term variability to refer to the whole area of how to manage the parts of a software development process and its resulting artifacts that are made to differ between products or, in certain situations, within a single product. Variability is concerned with many topics, ranging from the development process itself to the various artifacts created during the development process, such as requirements specifications, design documents, source code, and executable binaries (to mention a few). In this paper, however, we focus on the software artifacts, involving software architecture design, detailed design, components, classes, source code, and executable binaries. Variability in this context, refers to the ability to select between these artifacts at different times during a product's lifecycle.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Identification of variability</head><p>The first step is to identify where variability is needed in the software product family. The identification of variability is a rather large field of research (see, e.g., <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5]</ref>), and it is outside the scope of this paper to investigate it in detail. However, there appears to be some consensus that there is a relation between features and variability, in that variability can be more easily identified if the system is modeled using the concept of features (see, e.g., <ref type="bibr" target="#b17">[17]</ref><ref type="bibr" target="#b18">[18]</ref><ref type="bibr" target="#b19">[19]</ref><ref type="bibr" target="#b20">[20]</ref>, as well as FODA <ref type="bibr" target="#b21">[21]</ref> and FORM <ref type="bibr" target="#b22">[22]</ref>). A major advantage of discussing a system in terms of features is that they bridge the gap between requirements and technical design decisions since software components rarely address a single requirement but rather an entire set of requirements. As discussed below, this is similar to our perception of a feature.</p><p>In <ref type="bibr">[5, p. 194</ref>], we defined features as follows: 'a logical unit of behavior that is specified by a set of functional and quality requirements'. The point of view taken there, and in this article, is that a feature is a construct used to group related requirements ('there should at least be an order of magnitude difference between the number of features and the number of requirements for a product family member' <ref type="bibr">[5, p. 196]</ref>). In other words, features are an abstraction from requirements. In our view, constructing a feature set is the first step towards interpreting and ordering the requirements. In the process of constructing a feature set, the first design decisions about the future system are already taken. It is important to realize that there is an n-to-m relation between features and requirements. This means that a particular requirement (e.g. a performance requirement) may apply to several features and that a particular feature typically meets more than one requirement.</p><p>A software product family provides a central architecture that can be evolved and specialized into concrete products. In the context of software product families, features are used to differentiate various products (with respect to marketing, management of artifacts, etc.), i.e. variation between products of a software product family is usually expressed in terms of features. Consequently, a software product family must support variability for those features that tend to differ from product to product.</p><p>The process of identifying variability consists of listing the features that may vary between products. These so-called variant features will need to be implemented in such a way that the resulting software artifact can easily be adapted to accommodate the different variants that are associated with the variant feature.</p><p>In order to identify variant features, we suggest that features are organized into so-called feature diagrams. Over time, various feature diagram notations have been proposed, for example: FODA <ref type="bibr" target="#b21">[21,</ref><ref type="bibr" target="#b22">22]</ref>, RSEB <ref type="bibr" target="#b10">[11]</ref> and FeatureRSEB <ref type="bibr" target="#b23">[23]</ref>. In addition, our notation, which is derived from FeatureRSEB, is introduced in reference <ref type="bibr" target="#b12">[13]</ref>. An example of our notation is provided in Figure <ref type="figure" target="#fig_1">2</ref>. The example models some of the features of an email client application. Each of the notations makes a distinction between the following features.</p><p>• Mandatory features. These are the features that identify a product. For example, the ability to type in a message and send it to the smtp server is essential for an email client application. • Variant features. A variant feature is an abstraction for a set of related features (optional or mandatory). An example of a variant feature for the email client might be the editor used for typing in messages. Some email clients, for example, offer the feature of having a user configurable editor. We make a distinction between XOR (only one of the variants can be selected) and OR (more than one of the variants may be selected) variation. • Optional features. These are features that, when enabled, add some value to the core features of a product. A good example of an optional feature for an email client is the ability to add a signature to each message. It is in no way an essential feature and not all users will use it, but it is nice to have it in the product. Optional features can be seen as a special case of variant features.</p><p>Our own notation adds a fourth category:</p><p>• External features. These are features offered by the target platform of the system. While not directly part of the system, they are important because the system uses them and depends on them. For example, in an email client, the ability to make TCP connections to another computer is essential but not part of the client. Instead, the functionality for TCP connections is typically part of the operating system (OS) on which the client runs. Differences in external features may motivate inclusion of parts in the software to manage such variability. Requirements with respect to the deployment platform have consequences for the amount and type of the available external features. Similarly, depending on certain external features limits the amount of deployment platforms. Organizing external features under variant/optional features therefore may help improve platform independence. In any case, the decision on how to handle external features requires an informed approach, such as our variation management process. Our choice of introducing external features is further motivated by Zave and Jackson <ref type="bibr" target="#b24">[24]</ref>. In this article it is argued that requirements should not reflect on implementation details (such as platform-specific features). Since features are abstractions from requirements, we need external features to map requirements that can be met by using functionality external to the system to features.</p><p>The main difference between our notation and other notations is this notion of an external feature.</p><p>In addition, our notation communicates the notion that the relation between a variant feature and its variants is a specialization relation. Consequently, we have adopted a UML-like notation. Finally, our notation includes the notion of binding time, which is one of the constraints discussed in Section 2.2. However, for the purpose of identifying variant features, either of the notations is adequate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Constraining variability</head><p>Once a variant feature has been identified, it needs to be constrained. After all, the purpose is not to provide limitless flexibility but to provide just enough flexibility to suit the current and future needs of the system in a cost-effective way. By constraining the variability we enable an informed decision on how to implement the variant feature in the software product family, as is described in Section 2.3. The aspects to consider when selecting an appropriate technique for implementing a variant feature can be identified by considering the lifecycle of the variant feature. During the lifecycle the variant feature is transformed in several ways during different phases until there is a decision on which variant to use in a given moment. In this section we briefly introduce these transformations and then discuss them further in the subsequent sections.</p><p>• Identified. As described in Section 2.1, the first step is to identify a variant feature and the available variants. • Implicit. When a variant feature is first identified it is said to be implicit, as it is not yet realized in the software product family. An implicit variant feature exists only as a concept and is not yet implemented. Software designers and developers are aware that they eventually will need to consider the variant feature, but defer its implementation until a later stage. • Introduced. A variant feature ceases to be implicit when it is introduced into the software product family. When a variant feature is introduced, it has already been decided how to implement it in the software product family. After a variant feature is introduced it has a representation in the design or implementation of the software product family. This representation takes the form of a set of variation points, i.e. places in the design or implementation that together provide the mechanisms necessary to make a feature variable. Note that the variants of the variant feature need not be present at this time. • Populated. After the introduction of a variant feature the next step is to populate the variant feature with its variants. What this means is that software entities are created for each of the variants in such a way that they fit together with the variation points that were previously introduced, and then the variation points are instrumented so that they can use the new variant. • Bound. At some stage a decision must be taken which variant of a variant feature to use, and at this stage the software product family or software system is bound to one of the variants for a particular variant feature. This means that the variation points related to the variant feature are committed to the software entities representing the variant decided upon.</p><p>For constraining a variant feature the last three of these transformations are of importance, and are described further in Sections 2.2.1-2.2.3, respectively.</p><p>During each of the transformations, decisions are made about the variant feature. Various stakeholders may be involved in these decisions and specifying who takes what decisions can be considered to be a part of the constraints. We have identified three groups of stakeholders that need to be considered in the context of a software product-line (we only consider stakeholders that directly interact with the variant feature).</p><p>• Domain engineers. Domain engineers are all people (e.g. designers, programmers, etc.) that are participating in the development of a software product family (i.e. a set of reusable software artifacts). • Application engineers. Application engineers (e.g. product managers, programmers), reuse the software artifacts from the software product family to create specific products. • End users. The products created by the application engineers are eventually used by an end user.</p><p>At present we make no distinction between the real end users of the product and the 'end users' of the variation points, i.e. the system or service engineers. The system engineers are the active users of variation points in software (e.g. setting environment variables, configuring infrastructure, upgrading components, etc.). The border between an end user and a system engineer is not always clear and distinct. At present we see few reasons to differ between end users and service engineers from a development perspective as both categories are users of a delivered system, albeit using the system differently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1.">Introducing a variant feature</head><p>When a variant feature is introduced into the software product family (by a domain engineer) it takes the form of a set of variation points. The variation points are used to connect the software entities constituting the variants with the rest of the software product family. The decision on when to introduce a variant feature is governed by a number of things, such as:</p><p>• the size of the involved software entities;</p><p>• the number of resulting variation points;</p><p>• the cost of maintaining the variant feature. Size of software entities. A variant can be implemented in many ways, for example as a component, a set of classes, a single class, a few lines of code, or a combination of all of these. We refer to these different implementation artifacts as software entities. As is presented in Table <ref type="table" target="#tab_0">I</ref> different software entities are most likely to be in focus during the different stages of architecture design, detailed design, implementation, compilation and linking. While the size of the involved software entities does not have any direct connection to how the variation points are implemented, it determines the overall strategy of how to implement the variant feature. This is further discussed in Section 2.3.</p><p>We would also like to stress the point that a variant of a variant feature can be implemented by one or more cooperating software entities. Each of these software entities is connected to the rest of the software system with one or more variation points. Figure <ref type="figure">3</ref> presents the relations between a variant feature, variants, variation points and software entities. The introduction of a variant feature is the process of adding the entire set of variation points necessary to implement all of the variants for the variant feature.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Number of variation points.</head><p>In our experience, a variant feature usually maps to a set of software entities. These software entities need not be of the same type. Hence a variant feature is typically implemented by a set of collaborating components, classes and even lines of code. These collaborating software entities can be scattered throughout the software system, even if it is usually possible to keep them gathered in a few places. Consequently, a single variant feature typically manifests itself as a set of variation points in the software system, working with different types of software entities. These variation points may be introduced into the software system during different development phases.</p><p>To increase the understandability of the source code, facilitate maintenance and reduce the risk of introducing bugs, it is desirable to keep the set of variation points as small as possible. This means that rather than using a mechanism that works with lines of code, these lines of code should be gathered into a class, or a set of classes. This would enable us to use a single variation point for the entire variant feature, rather than many variation points for each individual part of the variant feature.</p><p>Cost of maintaining variant feature. Whenever something is added to the software system, e.g. a component, a design element, a class or a line of code, it needs to be maintained during subsequent development phases. For example, if a software entity is added during architecture design, it needs to be taken into consideration during architecture design, detailed design, implementation, compilation and linking. If, however, a software entity is added during implementation, it only needs to be considered during implementation, compilation and linking. Hence, there is a cost associated with introducing a variant feature at an early stage during development. On the other hand, it is typically more expensive (computationally and in terms of complexity) to have variant features that work during runtime. Hence, care should be taken not to add a variant feature (i.e. the software entities of the variants as well as the variation points) too early, but no later than is needed either.</p><p>Example of introducing a variant feature. Consider the example given in Figure <ref type="figure" target="#fig_1">2</ref> of an email application. This feature graph is created by the domain engineers to identify the features, and in particular identify the features that may vary. One example of a variant feature is which protocol to use when receiving messages (Figure <ref type="figure" target="#fig_1">2</ref> lists the two variants POP3 and IMAP). It is decided to implement the two variants as two implementations of a component in the architecture. Thus, this sets the size of the involved software entities to components, or component implementations. By ensuring that both variants have the same interface, i.e. the same set of possible operations, the number of variation points can be reduced to only the point where it is decided which variant to use. This also reduces the cost of maintaining the variation points, as there is only one place to consider. Should, however, the interface to the variants change, this will impose an increased cost since not all places where the variant feature is used are gathered in one place.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2.">Populating a variant feature with variants</head><p>During this step the software entities of the variants are created such that they fit together with the variation points introduced in the previous step. After this, the variation points are instrumented to be made aware of each new variant. There are three things to consider when instrumenting the variation points, namely when, how and who.</p><p>When it is possible to populate. A variation point is typically available for population only during a limited period of its lifecycle. This depends on, for example, what type of software entities are involved in the variant feature, and what types of software entities are in focus during different phases of a system's lifecycle. This means that during some phases of a system's lifecycle (comprising all of the activities from product architecture design to runtime) a variation point is open for adding new variants or for removing old ones. During all other phases it is not possible to change the set of available variants, and then the variation point is closed.</p><p>The time when a variation point is open or closed for adding new variants is mainly decided by the development and runtime environments and the type of software entity that is connected to the variation point. For example, if the variation point is implemented using lines of code or classes, it is typically open during detailed design and implementation but closed during all other phases. However, if the variation point is implemented in components, it can be open during architecture design and during runtime but closed during detailed design, implementation and compilation.</p><p>An important factor to consider is when linking is performed. If linking can only be done in conjunction with compilation, then this closes all variation points for population at this phase. If the system supports dynamically linked libraries, the variation points can remain open even during runtime.</p><p>When a variation point is open or closed may also be determined by which type of application the system is. For example, embedded software may have fewer means for populating a variation point once the system is delivered, and it may be undesirable to be able to populate variation points in some other types of systems once it has been delivered (e.g. for security reasons). Hence, when the population phase is open or closed is determined from both a technical perspective (i.e. the technical limitations of the chosen implementation technique for a variant feature) and as a design decision (i.e. when one desires the variation points to be open or closed).</p><p>How to populate. Depending on how a variation point is implemented, the population is either done implicitly or explicitly. If the population is implicit the variation point itself has no knowledge of the available variants and the list of available variants is not represented as such in the system. While the variation point may in some cases include functionality to decide which variant to use, there is no explicit list of all variants available. For example, an if-statement in the source code that decides which variant to use is an implicit variation point, since there are only two variants (the if-block and the elseblock). With an implicit population, if there is a list and a description of the available variants, it is maintained outside of the system, e.g. in a document describing how to instrument the variation point.</p><p>With an explicit population the list of available variants is manifested in the software system. This means that the software system is aware of all of the possible variants, can add to the list of available variants and possesses the ability to discern between them and by itself select a suitable variant during runtime. In the case of the if-statement mentioned above, this is not an explicit population since new variants (e.g. new else-blocks) cannot be added by the if-statement itself and in most cases not during runtime.</p><p>Another example of an implicit population is when selecting which operating system to build for, since this is a decision made by the application engineers outside of the software system. On the other hand, selecting between different email editors (as in the example in Figure <ref type="figure" target="#fig_1">2</ref>) is a decision controlled by the software system itself and may hence be an explicit population. In the first case the system need not itself be aware of what operating systems can be built, whereas in the latter case the system can be aware of which email editors are available, how to add a new email editor, how to distinguish between the editors and which editor to use at any given moment.</p><p>The differences between an implicit and explicit population is that with an explicit population the set of variants is managed inside the system. Connected with an internal binding (as discussed in Section 2.2.3), this enables the system to decide without extra help from the user which variant is most suitable at any given moment. It also enables the addition of new variants to the system and a decision to be made between these without restarting. With an implicit population, the set of variants is managed outside of the system, e.g. by application engineers. There may be a manifestation of the population in the source code, e.g. in the form of an if-statement, but the set of variants cannot be extended without help from either an application engineer or an end user. In the latter case, the end user typically also needs to actively decide between the variants when it is time to bind the variation point.</p><p>The decision on when and how to add variants is governed by the business strategy and delivery model for the products in the software product family. For example, if the business strategy involves supporting the late addition of variants by, e.g., third-party vendors, this constrains the selection of implementation techniques for the variation points as they may need to be open for adding new variants after compilation or possibly even during runtime. This decision also affects whether or not the collection of variants should be managed explicitly or implicitly, which is determined based on how the third-party vendors are supposed to add their variants to the system. Likewise, if the delivery model involves updates of functionality into a running system this will also impact the choices of implementation techniques for the variation points.</p><p>In addition, the development process and the tools used by the development company influence how and when to add variants. For example, if the company has a domain engineering unit developing reusable assets, more decisions may be taken during the product architecture derivation, whereas another organization may defer many such decisions until compile or link-time.</p><p>Who populates the variant feature with variants. The decision as to who is allowed/enabled to populate a variant feature with variants is key to selecting the appropriate mechanism. Domain engineers may choose to provide application engineers with a fixed set of variants to choose from. However, they may also allow application engineers to create and add their own product-specific variants. Additionally, there is an increasing trend to provide variability to end users (e.g. plugin mechanisms). However, one cannot expect end users to edit and compile source code § , so any variability technique that requires this would be unsuitable for this kind of variant feature. Similarly, domain engineers typically may want to shield application engineers from the complexity of the software product family and provide them with easy to use mechanisms instead. Depending on who needs to populate a variant feature with variants, some techniques are more suitable than others.</p><p>Example of populating a variant feature. In the email example, the set of protocols for receiving messages is fixed by the domain engineers. There is no requirement to be able to add new email protocols in a running system. Hence, it is decided to deliberately lock the set of available variations during architecture design. This means that the variation points related to this variant feature can be closed at any point after this-the sooner the better. As the set of available variations is locked, the population can be implicit in the system. A simple if-statement can be used to decide which variant to use. For a variation point that is as static as this, i.e. where the set of variants is not expected to change much over time, and especially not during runtime, an implicit population preferred over an explicit population.</p><p>Another example is that many command-line email clients on UNIX offer end users the ability to select their own text editor for editing their messages. Typically such email clients include a variation point that allows end-users to select a suitable text editor program. In most cases, this will be implemented with an implicit population where the system only has an option with the path to the desired executable. If the system were to implement this variant feature as an explicit population, it would include functionality to add editors, the paths of which are then maintained internally.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.3.">Binding to a variant</head><p>The main purpose of introducing a variant feature is to delay a decision, but at some time there must be a choice between the variants and a single variant will be selected and used. We refer to this as binding the system to a particular variant. As before, this decision is concerned with when to bind and how to bind.</p><p>When to bind. Binding can be done at several stages during the development and also as a system is being run. Decisions on binding to a particular variant can be expected during the following phases of a system's lifecycle.</p><p>• Product architecture derivation. The product family architecture typically contains many unbound variation points. The binding of some of these variation points is what generates a particular product architecture. Typically, configuration management tools are involved in this process, and most of the mechanisms are working with software entities introduced during architecture design. A good example of this is KOALA <ref type="bibr" target="#b25">[25]</ref>, an architecture description language that is used within Philips to describe the components in their product family and derive products. • Compilation. The finalization of the source code is done during the compilation. This includes pruning the code according to compiler directives in the source code, but also extending the code to superimpose additional behavior (e.g. macros and aspects <ref type="bibr" target="#b7">[8]</ref>). • Linking. When the link phase begins and when it ends is very much dependent on the programming and runtime environment being used. In some cases, linking is performed irrevocably just after compilation, and in some cases it is done when the system is started.</p><p>In other systems again, the running system can link and re-link at will. In general there appears to be a trend to delay linking until runtime (even in embedded systems, where we have observed companies such as Axis (see Section 4.1), Symbian (see Section 4.4), and Danaher Motion Särö AB (see Section 4.5) that increasingly require binding of functionality during runtime in their embedded software). Consequently, any variability mechanism traditionally associated with linking is becoming available at runtime. • Runtime. This type of binding is usually implemented by means of any standard object-oriented language. The collection of variants can be closed at runtime, i.e. it is not possible to add new variants, but it can also be open, in which case it is possible to extend the system with new variants at runtime. Such variants are normally referred to as plug-ins and these may often be developed by third-party vendors. This type of runtime variability usually relies heavily on the linking mechanism on the platform. Another type of runtime binding is the interpretation of configuration files or startup parameters that determines what variant to bind to. This type of runtime binding is what is normally referred to as parameterization.</p><p>Note that binding times do not include the design and implementation phases. Variation points may well be introduced during these phases, but to the best of our knowledge a system cannot be bound to a particular variant on other occasions than the ones presented above. This is because during these phases classes and variables are introduced, but there are no means available to select between them. It is possible to manually remove all but one variant in the design but this is part of the product architecture derivation. Hence, the selection is either done as the architecture for the particular system is derived from the product family architecture or when the compiler, linker or runtime system selects a particular variant, e.g. based on some constant or variable.</p><p>As with the adding of variants, the time when one wants to be able to bind the system (again, as for the adding of variants, this decision may in some instances be influenced by the type of system being built) constrains the selection of possible ways to implement a variation point. For a variant feature resulting in many variation points this results in quite a few problems. The variation points need to be bound either at the same time (as is the case if binding is required at runtime), or the binding of several variation points is synchronized so that, for example, a variation point that is bound during compilation binds to the same variant that related variation points have already bound to during product architecture derivation.</p><p>Consider, for example, a variant feature consisting of a component and some lines of code in other components where the variant feature is called from. Each variant has its own component implementation, and the lines of code in the other components are also different to make best use of the variant. Which component to use is decided during product architecture derivation, but which lines of code to use in the other component cannot be determined at this stage as lines of code are not in focus during this stage. Instead, this has to be deferred until compilation when the source code can be pruned from all but the chosen variant. This example is illustrated in Figure <ref type="figure" target="#fig_3">4</ref>. We see the three phases of this particular variant feature implementation. In the first phase, both variants (Components A and B) are available, and the variability points include code to use either A or B. In the second phase, the architecture is pruned of Component B, i.e. it decides to use Component A. In the third and last phase in this example, the variability points are during compilation bound to use Component A.</p><p>When determining when to bind a variant feature to a particular variant, what needs to be considered is when binding is absolutely required. As a rule of thumb, one can in most cases say that the later the binding is done, the more costly (e.g. in terms of performance or resource consumption) it is. Deferring binding from product architecture derivation to compilation means that developers need to manage all variants during implementation, and deferring binding from compilation to runtime means that the system will have to include binding functionality. This introduces a cost in terms of, for example, performance to conduct the binding. Moreover, there are security aspects to consider when allowing runtime binding, and the memory footprint of the application also increases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>How to bind.</head><p>The other aspect of binding is to decide whether or not the binding should be done internally or externally. Internal binding implies that the system contains the functionality to bind to a particular variant. This is typically true for the binding that is done during a system's runtime. External binding implies that there is a person or a tool external to the system that performs the actual binding. This is typically true for the binding that is done during product architecture derivation, compilation  and linking, where tools such as configuration management tools, compilers and linkers perform the actual binding. These two concepts are related but not equivalent to the implicit and explicit concepts introduced earlier. The different alternatives can be combined in four different ways.</p><p>• Implicit population and internal binding. Variation points of this type are typically bound during runtime. The system contains functionality to bind to a variant, but does not contain functionality to manage or extend the list of possible variants. The email application and the email retrieval protocols discussed earlier are examples of this. The system does not need to explicitly manage the set of variants, but it does need to, by itself, be able to select one of the variants each time email is retrieved. • Implicit population and external binding. This combination is predominant for variation points that are bound in the development phases, i.e. all phases except for runtime and the linking performed at runtime. The resulting system does not need to know what different variants exist, as it is not concerned with the actual binding process. This is done by the application or domain engineers, e.g. by using configuration management tools, compilers and linkers. For example, consider an application that allows compilation for both a Windows and a Unix platform.</p><p>Once the compiler knows what variant is required, the system itself need never be made aware that it could have been compiled for another platform as well. • Explicit population and internal binding. This is typically used for variation points that can be both populated and bound at runtime. With this combination the system is aware of what variants exist, and has sufficient knowledge to select between them. For example, consider an email application that allows a user-defined text editor that is then launched automatically when needed. The set of available text editors is not fixed, and can be extended during runtime. • Explicit population and external binding. This combination involves including in the running system the ability to discern between variants and to determine which variant is most suitable and then let the users perform the binding manually. We do not think that this combination is very common or even likely. Normally, the end user asks the computer to perform tasks, not the other way around.</p><p>Whether to bind internally or externally is decided by many things, such as whether the binding is done by the software developers or the end users, and whether the binding should be made transparent to the end users or not. Moreover, external binding is sometimes preferred as it does not necessarily leave any traces in the source code which may simplify the work of, e.g., product engineers. When the binding is internal the system must contain functionality to bind and this may increase the complexity of the source code.</p><p>Example of binding to a variant. In the email example, it is decided during runtime what email retrieval protocol to use. This means that the binding time is set to runtime. Moreover, as the system decides by itself between the different variants, the binding is done internally.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.4.">Summary of example</head><p>The running example used in this section can thus be summarized as follows.</p><p>• It is identified from the feature graph in Figure <ref type="figure" target="#fig_1">2</ref> that there is a choice between email retrieval protocols. At this point, the variant feature 'retrieval protocols' is implicit. • As the system is designed, it is decided by the domain engineers that the email retrieval protocols can be implemented as component implementations. The number of variation points can thus be reduced to one, i.e. the point where it is decided which variant to use. This need not be done for every point where the email retrieval protocols are used in the system At this point, the variant feature 'retrieval protocols' is said to be introduced. • Also during architecture design, the component 'email retrieval protocol' is designed, as are the two component implementations, POP3 and IMAP. We have thus populated the variant feature. The population is thus done during architecture design. Moreover, it is decided that it is sufficient if the population is implicit, i.e. we need not include functionality to manage the list of available variants. The actual implementation of the two component implementations is of lesser importance from a variability perspective. They can be created during the general implementation of the system, be reused from a previous project, developed in parallel or bought as COTS components. Accordingly, this task is handed over to the application engineers. • The last part of constraining the variant feature is to decide when it should be possible to bind the system to a variant. For the email retrieval protocols, this cannot be decided until during runtime, for each time that emails are retrieved. The end users should not have to be involved in the binding, so it is decided to keep the variation point internal, i.e. it is the system that binds without any help from the outside.</p><p>The last two parts of this summary, i.e. the population and the binding, may require further discussion.</p><p>Starting with the 'when' part of the decision. When to populate determines when it should be possible to add new variants, i.e. software entities implementing each variant. This is not connected to when the variants are implemented or when the variation points are introduced and implemented. When one wishes to bind determines when the variation points should be active. Again, this is not directly connected to when the variation points are introduced and implemented. Part of our argumentation is that it is the different aspects covered in this chapter that determines when and how to introduce and implement variation points, and not the other way round.</p><p>The second part of the decision, the 'how' part, is in both of the last two steps involved with the variation point but with two different perspectives. The decision on how to populate (i.e. implicitly or explicitly) determines how much the variation points need to be aware of the variants. This ranges from cases where there is no manifestation at all in the source code of the variation point, to where there is source code to decide between the variants but with no 'awareness' of the different variants, and all the way up to variation points where there is source code in place to explicitly manage the set of variants and decide which to use. The decision on how to bind (i.e. internally or externally) is related to this, as described in Section 2.2.3. In the example above, the population is implicit and the binding is internal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Implementing variability</head><p>Based on the previous constraint of variability, a suitable variability realization technique may be selected from our taxonomy (Section 3) for the variation points pertaining to a certain variant feature. The selected realization technique should strike the best possible balance between the constraints that have been identified in the previous step. Using our process this choice may be a reasonably informed choice. We believe that making the right choices with respect to variability is vital for the survival of a product family. Being too conservative with respect to variability may lead to a situation where new features can either not be implemented at all, or only at a very high cost. On the other hand, adding too much variability makes the product family more complex which may result in maintainability problems and may also result in higher product derivation cost. Additionally, having too many variation points may lead to architecture drift <ref type="bibr" target="#b26">[26]</ref> and design erosion <ref type="bibr" target="#b27">[27]</ref>.</p><p>Example of implementing variability. In the email example used in the previous section, this step consists of deciding which variability realization technique to use for the variation point that decides which email protocol to use when retrieving emails. Browsing through the taxonomy in Section 3, and especially Table <ref type="table" target="#tab_1">II</ref>, we see that we are in fact working with framework implementations (the framework is 'email retrieval protocols', and the two implementations are POP3 and IMAP), and the binding time is runtime. This means that we have two variability realization techniques available, 'Runtime variant component specializations' and 'Variant component implementations'. For this variation point the 'Variant component implementations' is the variability realization technique that is the most suitable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.">Managing the variability</head><p>The last step is to manage the variability. This involves maintenance and to continue to populate variant features with new variants and pruning old, no longer used, variants. Moreover, variant features may be removed altogether, as the requirements change, new products are added and old products are removed from the product family. Management also involves the distribution of new variants to the already installed customer base, and billing models regarding how to make money off new variants. As with the identification of variability, this is outside the scope of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.">Summary</head><p>Figure <ref type="figure" target="#fig_4">5</ref> illustrates the different tasks discussed in this section that together decide where and how to implement an identified variant feature. Especially important for this decision are the two tasks identify variability and constrain variant feature. In this paper we focus on the aspects needed to constrain a variant feature. This depends on a number of aspects, e.g. the size of the variant feature, the desired number of variation points, the cost for managing the variant feature, when how and by whom to populate the variant feature with variants, and when, how and by whom the system is bound to a particular variant.  During these tasks, the variant features undergo a number of transformations, also depicted in Figure <ref type="figure" target="#fig_4">5</ref>. These transformations range from when a variant feature is first identified, thus being implicit until it is introduced (this follows after the task constrain variant feature and during the task implement variant feature). During the task implement variant feature the variation points are introduced into the software system, and variants for the variant feature are implemented. The variant feature is then populated with these variants, and eventually the variant feature is bound to a particular variant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">VARIABILITY REALIZATION TECHNIQUES</head><p>In this section, we present a taxonomy of different ways to implement the variation points for a variant feature, which we refer to as variability realization techniques. If the variation points are constrained, e.g. as described in the previous section, it enables a more informed choice of how to implement them. The taxonomy in this section is structured according to the criteria set up in the previous section. The taxonomy is based on the different realization techniques we have observed in several industry cases. Section 4 presents the industry cases in which the variability realization techniques have been observed along with some additional examples. We encourage readers to extend this taxonomy with variability realization techniques that may be used in companies other than those we have studied.</p><p>The variability realization techniques in our taxonomy are summarized in Table <ref type="table" target="#tab_1">II</ref>. In this table the variability realization techniques are organized according to the software entity the variability realization techniques work with and when it is at the latest possible to bind them. For each variability realization technique there is also a reference to a more detailed description of the technique. These descriptions are presented below. There are some areas in this table (in bold) where we perceive that it is not interesting to have any variability realization techniques. These areas are:</p><p>• components and frameworks during compilation, as compilation works with smaller software entities; this type of software entity comes into play again only during linking; • lines of code during product architecture derivation, as we know of no tools working with product architecture derivation that also work with lines of code; • lines of code during linking, as linkers work with larger software entities.</p><p>We present the variability realization techniques using a Design Pattern like form, in the style used by, e.g., Buschmann et al. <ref type="bibr" target="#b28">[28]</ref> and Gamma et al. <ref type="bibr" target="#b15">[16]</ref>. For each of the variability realization techniques we discuss the following topics.</p><p>• Intent. This is a short description of the intent of the realization technique.</p><p>• Motivation. A description of the problems that the realization technique address and other forces that may be at play. It should be noted that the techniques described in our taxonomy have deliberately been described in an abstract fashion. Our reason for this is that we wish to abstract from specific programming languages and yet capture the commonalities between similar mechanisms in languages. The number of specific language features (and their numerous implementations) that would have to be taken into account is so large that it distracts from the essence of our taxonomy. Moreover, our taxonomy also takes into account software entities (e.g. architecture components) that are currently poorly supported in programming languages.</p><p>We would like to emphasize that we do not present a pattern collection such as in <ref type="bibr" target="#b15">[16]</ref> or <ref type="bibr" target="#b28">[28]</ref>-we only borrow the presentation form from these pattern collections. The goal of the presented taxonomy differs since we present specific technical solutions (albeit in an abstract form) rather than the type of abstract solutions proposed in <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b28">28]</ref>. Another goal of the taxonomy is to be able to reason about the specific properties of the listed solutions (e.g. binding time) and to outline benefits and liabilities of different variability realization techniques. We would also like to stress that although we only present the techniques from the perspective of variability, many of the techniques may also serve other quality attributes. Moreover, implementing support for some quality attributes (e.g. portability) requires supporting flexibility or variability in the software, which can be provided using the variability realization techniques presented in this taxonomy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Architecture reorganization</head><p>Intent. Support several product-specific architectures by reorganizing (i.e. changing the architectural structure of components and their relations) the overall product family architecture.</p><p>Motivation. Although products in a product family share many components, the control flow and data flow between these components need not be the same. Therefore, the product family architecture is reorganized to form the concrete product architectures. This involves mainly changes in the control flow, i.e. the order in which components are connected to each other, but may also consist of changes in how particular components are connected to each other, i.e. the provided and required interface of the components may differ from product to product.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Solution.</head><p>In this realization technique, the components are represented as subsystems controlled by configuration management tools or, at best, Architecture Description Languages (ADLs) (e.g. Koala <ref type="bibr" target="#b25">[25]</ref>, XVCL <ref type="bibr" target="#b29">[29]</ref>, or any of the ADLs mentioned in <ref type="bibr" target="#b30">[30]</ref>). Which variants are included in a system is determined by the configuration management tools. Some variation points may be resolved at this level, as the selected components may impose a certain architecture structure. Typically this technique also requires variation points that are in focus during later stages of the development cycle in order to work. These later variation points can be used to connect the components properly. This technique is implicit and external, as there is no first-class representation of the architecture in the system. For an explicit realization technique, see Section 3.6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lifecycle.</head><p>This technique is open for the adding of new variants during architecture design, where the product family architecture is used as a template to create a product-specific architecture, i.e. during product derivation. As detailed design commences, the architecture is no longer a first class entity, and can hence not be further reorganized. Binding time, i.e. when a particular architecture is selected, is when a particular product architecture is derived from the product family architecture. This also implies that this is not a technique for achieving dynamic architectures. If this is what is required, see Section 3.6. Moreover, as this realization technique typically relies on other variation points in focus during later stages of the development, the architecture is not entirely committed until these variation points are also bound.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Consequences.</head><p>The product family architecture is kept as an abstract template from which concrete product architectures are derived. This facilitates development of the individual products. However, this also introduces a risk that part of the development made for a particular product is not compatible with the rest of the products in the product family. Secondly, this variability realization technique may require variation points in subsequent development phases as well, in order to function properly. What we have seen at several companies (e.g. Philips <ref type="bibr" target="#b25">[25]</ref>) that apply this technique is that the organization is changed in such a way that product engineers are not allowed to change components. If a certain change is required, product engineers have to file a change request with the domain engineers.</p><p>Examples. A design of the email application used as an example earlier is presented in Figure <ref type="figure" target="#fig_6">6</ref>(a). To create a USENET news application, the architecture is reorganized to that of Figure <ref type="figure" target="#fig_6">6(b)</ref>. As can be seen, some components and some connectors are removed or joined and other components and connectors are removed altogether. Most of this is due to the fact that the communication standard for news (NNTP) provides a uniform interface for both sending and receiving messages, whereas email  has several different protocols both for sending and for receiving messages. Another example of this technique is Axis Communications <ref type="bibr" target="#b5">[6]</ref> where a hierarchical view of the product family architecture is employed, where different products are grouped in sub-trees of the main product family. To control the derivation of one product out of this tree, a rudimentary, in-house developed-ADL is used. Another example is Philips, which uses a proprietary ADL called Koala to derive products <ref type="bibr" target="#b25">[25]</ref>.</p><p>This variability realization technique is summarized in Table <ref type="table" target="#tab_3">III</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Variant architecture component</head><p>Intent. Support several, differing, architecture components representing the same conceptual entity.</p><p>Motivation. In some cases, an architecture component in one particular place in the architecture can be replaced with another that may have a differing interface, and sometimes also representing a different domain. This need not affect the rest of the architecture. Using the email application example from the previous section, this product can quite easily be changed into a USENET news reader application. This, however, requires that some components work quite differently. By replacing the components for the email application with those for the USENET news application we use this realization technique to cope with this variability. Solution. The solution to this as the title implies, is to, support a set of components, each implementing one variant of the variant feature. The selection of which component to use at any given moment is then delegated to the configuration management tools that select what component to include in the system. A part of the solution is also delegated to subsequent development phases, where the variant component specialization will be used to call and operate the different components in the correct way. To summarize, this technique has an implicit collection, and the binding functionality is external.</p><p>Lifecycle. It is possible to add new variants, implemented as components, during architecture design when new components can be added, and also during detailed design when these components are concretely designed as separate components in the architecture. The architecture is bound to a particular component during the transition from a product family architecture to a product architecture, when the configuration management tool selects which architecture component to use.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Consequences.</head><p>A consequence of using this pattern is that the decision of which component interface to use, and how to use it, is placed in the calling components rather than when the actual variant feature is implemented. Moreover, the handling of the differing interfaces cannot be dealt with during the same development phase as the varying component, but has to be deferred until later development stages.</p><p>Examples. In the email application example, there may be a need to replace the browser component with one that is specific for the news application, supporting, e.g., a nested view of the messages. This can be done using this variability realization technique by providing two components-one email browser and one news browser-and then letting the configuration management tool decide which to include in the system being built. Another example is Axis Communications <ref type="bibr" target="#b5">[6]</ref>, where there existed over a long period of time two versions of a file system component; one supporting both read and write functionality, and one supporting only read functionality. Different products used either the read-write or the read-only component. This was due, in Axis' case, to a limited amount of memory in their embedded products. Since the two components differed in the interface as well as the implementation, they were, in effect, two different architecture components. This variability realization technique is summarized in Table <ref type="table" target="#tab_4">IV</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Optional architecture component</head><p>Intent. Provide support for a component that may, or may not, be present in the system. Motivation. Some architecture components may be present in some products but absent in other.</p><p>For example, the email application described earlier may optionally provide functionality to manage a contact list. This means that some configurations, e.g. the 'compose email' functionality, need to interact with the contact list, and in other configurations this interaction is not available or even possible.</p><p>Solution. There are two ways of solving this problem depending on whether it should be fixed on the calling side or the called side. If we want to implement the solution on the calling side, the solution is simply delegated to variability realization techniques introduced during later development phases. To implement the solution on the called side, which may be nicer but is less efficient, create a 'null' component. This is a component that has the correct interface, but replies with dummy values. This latter approach assumes, of course, that there are predefined dummy values that the other components know to ignore. This null component is then included in the product configuration during product architecture derivation. The binding for this technique is done externally to the system, using, e.g., configuration management tools.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lifecycle.</head><p>This technique is open when a particular product architecture is designed based on the product family architecture, but due to the lack of architecture representation during later development phases is closed at all other times. The architecture is bound to the existence or non-existence of a component when a product architecture is selected from the product family architecture.</p><p>Consequences. Consequences of using this technique are that the components depending on the optional component must either have realization techniques to support its not being there, or have techniques to cope with dummy values. The latter technique also implies that the 'plug', or the null component, will occupy space in the system, and the dummy values will consume processing power. An advantage is that should this variation point later be extended to be of the type variant architecture component, the functionality is already in place, and all that needs to be done is to add more variants for the variant feature.</p><p>Examples. In the email application example and the architecture reorganization in Figure <ref type="figure" target="#fig_6">6</ref>, the 'Archive' component is removed in the news application. This is an example of when the variability is solved on the calling side, as the browser component needs to be aware of whether there is an archive component or not. If we had included a null component, this would have been entirely transparent for the browser component. More examples include a Storage Server at Axis Communications which can optionally be equipped with a so-called hard disk cache. This means that in one product configuration, other components need to interact with the hard disk cache, whereas in other configurations, the same components do not interact with this architecture component. Also, in Symbian's EPOC operating system (which has since our case study been renamed SymbianOS) <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b31">31]</ref>, the presence or absence of a network connection decides whether network drivers should be loaded or not. The Web browser Mozilla comes with a null component in the plug-in directory (npnul32.dll) that is called in the absence of a plug-in to call when an embedded object is encountered. Curiously, there are even replacements for it (e.g. DefaultPluginPro, an alternative that offers users the option to the object for which no plug-in could be found).</p><p>This variability realization technique is summarized in Table <ref type="table" target="#tab_6">V</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">Binary replacement-linker directives</head><p>Intent. Provide the system with alternative implementations of underlying libraries. Motivation. In some cases, all that is required to support a new platform is that an underlying system library is replaced. For example, when compiling a system for different UNIX dialects, this is often the case. It does not need to even be a system library, it can also be a library distributed together with the system to achieve some variability. For example, some games have been observed to be released with different libraries to work with different graphics environments such as the Windows system (e.g. X-Windows), an OpenGL graphics device or a standard SVGA graphics device.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Solution.</head><p>Represent the variants as stand-alone library files, and instruct the linker which file to link with the system. If this linking is done at runtime, the binding functionality must be internal to the system, whereas it can, if the linking is done during the compile and linking phase prior to delivery, be external and managed by a traditional linker. An external binding also implies, in this case, an implicit collection. Naturally, this assumes that all the available libraries conform to a common interface. If this is not the case the switch to another library will not work as seamlessly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lifecycle.</head><p>This technique is open for adding new variants as the system is linked. It is also bound during this phase. As the linking phase ends, this technique becomes unavailable. However, it should be noted that the linking phase does not necessarily end. In modern systems (e.g. Java-based systems), linking is also available during execution.</p><p>Consequences. This is a fairly well developed variability realization technique, and the consequences of using it are relatively harmless. Security is a concern since this technique means that there is a trust issue if you make a call to a library. The advantages are that it is relatively easy to use and it allows the memory footprint of the executing application to be reduced by simply not loading any unwanted libraries.</p><p>A major disadvantage is a situation that is generally described as DLL hell. Multiple applications may require different versions of the same DLL. In the worst case, system stability may degrade because applications link to different versions of DLLs than they were tested with. Older versions of MS Windows are particularly vulnerable to such problems.</p><p>Examples. In the email application example the situation is as illustrated in Figure <ref type="figure" target="#fig_7">7</ref> where there are two sets of libraries to use, one for Windows and one for UNIX. Which set of libraries to use is decided as the system is linked by the application engineers before the system is delivered to customers. Another example is the Mozilla Web browser (http://www.mozilla.org) that is available on many platforms, including Linux. Some versions of Linux can display so-called anti-aliased fonts that look smoother on LCD screens. However, this requires that programs that wish to use this link  to specific system libraries. To support this in the Mozilla browser, an (at the moment of writing) experimental build option exists that creates a version of Mozilla that uses these libraries.</p><p>This variability realization technique is summarized in Table <ref type="table" target="#tab_7">VI</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.">Binary replacement-physical</head><p>Intent. Facilitate the modification of software after delivery.</p><p>Motivation. Unfortunately, very few software systems are released in a perfect and optimal state. This creates a need to upgrade the system after delivery. In some cases these upgrades can be done using the variation points already existing in the system, but in others the system does not currently support variability at the places needed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Solution.</head><p>In order to introduce a new variation point after delivery, the software binary must be altered.</p><p>The easiest way of doing this is to replace an entire file with a new copy. To facilitate this replacement the system should thus be organized as a number of relatively small binary files, to localize the impact of replacing a file. Furthermore, the system can be altered in two ways: either the new binary completely covers the functionality of the old one or the new binary provides additional functionality in the form of, for example, a new variant feature using other variability realization techniques. In this technique the collection is implicit, and the binding is external to the system.</p><p>Lifecycle. This technique is bound before start-up (i.e. before runtime) of the system. In this technique the method for binding to a variant is also the one used to add new variants. After delivery (i.e. after compilation), the technique is always open for adding new variants.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Consequences.</head><p>If the new binary does not introduce 'traditional' variation points, the same technique will have to be used again the next time a new variant for the variant feature in question is detected. However, if traditional variation points are introduced, this facilitates future changes at this particular point in the system. Replacing binary files is normally a volatile way of upgrading a system, since the rest of the system may in some cases even be depending on, e.g., software bugs in the replaced binary in order to function correctly (please note that bug fixing is not the only usage of this technique. One may just as well use it to extend the functionality of a product). Moreover, it is worthwhile maintaining the release history needed to keep consistency in the system. Furthermore, there are also some trust issues to consider here, e.g. who provides the replacement component and what are the guarantees that the replacement component actually does what it is supposed to do.</p><p>Examples. The email application example can be upgraded after delivery to support editing emails in HTML, as opposed to the default text-only editor. When the end user installs the upgrade, the binary file containing the previous editor component is overwritten with a new file, containing the HTML editor component. This technique is particularly popular with hardware manufacturers such as Axis Communications, providing the possibility of upgrading the software in their devices by re-flashing the ROM <ref type="bibr" target="#b5">[6]</ref>. This basically replaces the entire software binary with a new one. Another example is the Bios software that is located on the motherboard of a PC. Typically, manufacturers offer binary replacements for this software on their homepage to fix bugs and add compatibility with hardware that became available after the product was sold.</p><p>This variability realization technique is summarized in Table <ref type="table" target="#tab_8">VII</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6.">Infrastructure-centered architecture</head><p>Intent. Make the connections between components a first-class entity.</p><p>Motivation. Part of the problem when connecting components (in particular components that may vary) is that the knowledge of the connections is often hard coded in the required interfaces of the components and is thus implicitly embedded into the system. A reorganization of the architecture, or indeed a replacement of a component in the architecture, would be vastly facilitated if the architecture is an explicit entity in the system, where such modifications could be performed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Solution.</head><p>Convert the connectors into first-class entities, so the components are no longer connected to each other but are rather connected to the infrastructure, i.e. the connectors. This infrastructure is then responsible for matching the required interface of one component with the provided interface of one or more other components. The infrastructure can either be an existing standard, such as COM or CORBA <ref type="bibr" target="#b32">[32]</ref>, or it can be an in-house developed standard such as Koala <ref type="bibr" target="#b25">[25]</ref>. The infrastructure may also be a scripting language in which the connectors are represented as snippets of code that are responsible for binding the components together in an architecture. These code snippets can either be done in the same programming language as the rest of the system, or they can be done using a specialized scripting language. Such scripting languages are, according to e.g. <ref type="bibr" target="#b33">[33]</ref>, highly suitable for 'gluing' components together. The collection of variants is in this realization technique either implicit or explicit and the binding functionality is internal, provided by the infrastructure.</p><p>Lifecycle. This technique can be implemented in many ways and this governs, e.g., when it is open for populating with variants. In some cases the infrastructure is open for the addition of new components as late as during runtime and in other cases the infrastructure is concretized during compile and linking, and is thus open for new additions only until then. Binding can also be performed during compile and linking, even if it is more likely that this is deferred until runtime.</p><p>Consequences. When used correctly, this realization technique yields perhaps the most dynamic of all architectures. Performance is impeded slightly because the components need to abstract their connections to fit the format of the infrastructure, which then performs more processing on a connection before it is concretized as a traditional interface call again. In many ways, this technique is similar to the Adapter Design Pattern <ref type="bibr" target="#b15">[16]</ref>. As complexity is moved from the components to the glue code, this may in some cases have a negative impact on maintainability. On the other hand, the components become more focused on their actual task and hence easier to maintain. The infrastructure does not remove the need for well-defined interfaces, or the troubles with adjusting components to work in different operating environments (i.e. different architectures), but it removes part of the complexity in managing these connections.</p><p>Examples. An alternative to the design of the email application in Figure <ref type="figure" target="#fig_6">6</ref> is to design it around a CORBA bus (http://www.omg.org), as illustrated in Figure <ref type="figure" target="#fig_8">8</ref>. The advantage of this is that the infrastructure can take care of the connections between components, so that the components themselves need not be as dependent or aware of what other components are available in the system. Other examples are programming languages and tools such as Visual Basic, Delphi and JavaBeans that also support a component-based development process where the components are supported by some underlying infrastructure. Another example is the Mozilla Web browser, which makes extensive use of a scripting language, in that everything that can be varied is implemented in a scripting language  and only the atomic functionality is represented as compiled components. It is our experience that most larger systems we encounter in industry either use an off-the-shelf component architecture or an in-house developed component architecture (e.g. Philips <ref type="bibr" target="#b25">[25]</ref> and Axis <ref type="bibr" target="#b5">[6]</ref>).</p><p>This variability realization technique is summarized in Table <ref type="table" target="#tab_9">VIII</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7.">Variant component specializations</head><p>Intent. Adjust a component implementation to the product architecture.</p><p>Motivation. Some variability realization techniques on the architecture design level require support in later stages. In particular, those techniques in which the provided interfaces vary need support from the required interface side as well. In these cases, what is required is that parts of a component implementation, namely those parts that are concerned with interfacing a component representing a variant of a variant feature, need to be replaceable as well. This technique can also be used to tweak a component to fit a particular product's needs. It is desirable that there are no traces left of the Lifecycle. The available variants are introduced during detailed design, when the interface classes are designed. The technique is closed during architecture design, which is unfortunate since it is here that it is decided whether the variability realization technique is needed. This technique is bound when the product architecture is instantiated from the source code repository.</p><p>Consequences. A consequence of using classes is that it introduces another layer of indirection, which may consume processing power (although today the overhead incurred by an extra layer of indirection is minimal). It may not always be a simple task to separate the interface. Suppose that the different variants require different feedback from the common parts, then the common part will be full with method calls to the varying parts, of which only a subset is used in a particular configuration. Naturally this hinders readability of the source code. However, the use of classes like this has the advantage that the variation points are localized to one place (i.e. a single class) in the source code, which facilitates adding more variants and maintaining the existing variants.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Examples.</head><p>In the example email application, one version of the product is delivered with the functionality to filter (i.e. process in various ways) emails as they arrive. This is done in a separate component connected to the archive component (see Figure <ref type="figure" target="#fig_6">6</ref>). This means that the archive component needs to be made aware whether the filter component is available. At the same time, once this decision has been made it is not necessary to clutter the source code with an already bound variability realization technique. This is solved using two separate class implementations bearing the same name, and then letting the configuration management tool decide which class to include in the product to build. Figure <ref type="figure" target="#fig_9">9</ref> illustrates this situation. We have also observed this variability realization technique in the Storage Servers at Axis Communications <ref type="bibr" target="#b5">[6]</ref>, which can be delivered with a traditional cache or a hard disk cache. The file system component must be aware of which is present, since the calls needed for the two are slightly different. Thus, the file system component is adjusted using this variability realization technique to work with the cache type present in the system. This variability realization technique is summarized in Table <ref type="table" target="#tab_10">IX</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.8.">Optional component specializations</head><p>Intent. Include or exclude parts of the behavior of a component implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Motivation.</head><p>A particular component implementation may be customized in various ways by adding or removing parts of its behavior. For example, depending on the screen size, an application for a handheld device can opt not to include some features, and in the case when these features interact with others this interaction also needs to be excluded from the executing code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Solution.</head><p>Separate the optional behavior into a separate class and create a 'null' class that can act as a placeholder when the behavior is to be excluded. Let the configuration management tools decide which of these two classes to include in the system. Alternatively, surround the optional behavior with compile-time flags to exclude it from the compiled binary. Binding is done externally in this technique, by the configuration management tools or the compiler. Technically, this variability realization technique is similar to the optional architecture component technique. The difference is just a matter of scale; the software entities involved in this technique are smaller.</p><p>Lifecycle. This technique is introduced during detailed design and is immediately closed to adding new variants, unless the variation point is transformed into a variant component specialization. The system is bound to the inclusion or exclusion of the component specialization during the product architecture derivation or, if the second solution is chosen, during compilation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Consequences.</head><p>It may not be easy to separate the optional behavior into a separate class. The behavior may be such that it cannot be captured by a 'null' class.</p><p>Examples. In the email application example, this technique is used when the archive component is not present, as in Figure <ref type="figure" target="#fig_6">6</ref>. In this case, the Browser component needs to be aware that there is no archive component present. All connections from the browser component to the archive component are localized into a single class, much the same as in the variant component specialization example. In addition, a null class with the same name is created that simply acts as if there are no mail folders or stored messages available. Configuration management tools are used to decide which of these classes to include in the system. This variability realization technique was used when Axis Communications <ref type="bibr" target="#b5">[6]</ref> added support for Novel Netware, some functionality required by the filesystem component was specific for Netware. This functionality was fixed externally to the file system component, in the Netware component. As the functionality was later implemented in the file system component, it was removed from the Netware component. The way to implement this was in the form of an optional component specialization. <ref type="table" target="#tab_11">X</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>This variability realization technique is summarized in Table</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.9.">Runtime variant component specializations</head><p>Intent. Support the existence and selection between several specializations inside a component implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Motivation.</head><p>It is required of a component implementation that it adapts to the environment in which it is executing, i.e. that for any given moment during the execution of the system, the component implementation is able to satisfy the requirements from the user and the rest of the system. This implies that the component implementation is equipped with a number of alternative executions, and is able, at runtime, select between these.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Solution.</head><p>There are several Design Patterns <ref type="bibr" target="#b15">[16]</ref> that are applicable here, for example Strategy, Template Method and Abstract Factory. Alternating behavior is collected into separate classes, and mechanisms are introduced to select, at runtime, between these classes. Using Design Patterns makes the collection explicit, and the binding is done internally, by the system. Design Patterns use language constructs such as inheritance and polymorphism to implement the variability. Alternatively, generative programming solutions such as C++ templates may also be used <ref type="bibr" target="#b8">[9]</ref>. Essentially, the mentioned Design Patterns work around the lack of such language features in some popular object-oriented languages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lifecycle.</head><p>This technique is open for new variations during detailed design since classes and objectoriented concepts are in focus during this phase. Because these are not in focus in any other phase this technique is not available anywhere else. The system is bound to a particular specialization at runtime, when an event occurs.</p><p>Consequences. Depending upon the ease with which the problem divides into a generic and variant part, more or less of the behavior can be kept in common. However, it is often the case that even common code is duplicated in the different strategies. A hypothesis is that this could stem from quirks in the programming language such as the self problem <ref type="bibr" target="#b34">[34]</ref>.</p><p>Examples. As the email example application supports two protocols, i.e. POP and IMAP, for receiving emails, the differences between these must be managed by different parts of the system. For example, IMAP provides support for keeping and managing mail folders on the server, which POP does not. This means that the archive component in Figure <ref type="figure" target="#fig_6">6</ref> needs functionality that is specific for IMAP and other similar protocols. This is solved by localizing these specific parts into separate classes, as illustrated in Figure <ref type="figure" target="#fig_10">10</ref>. An abstract factory <ref type="bibr" target="#b15">[16]</ref> class is used to instantiate the correct class when needed (note that this may be an oversimplification of how to design an email application and how IMAP functions; the main purpose is to exemplify the variability realization technique, not to provide a complete and correct design of an IMAP email client). Another example is hand-held devices that can be attached to communication connections with differing bandwidths, such as a mobile phone or a LAN, and this implies different strategies for how the EPOC operating system <ref type="bibr" target="#b31">[31]</ref> retrieves data. Not only do the algorithms for, e.g., compression differ, but on a lower bandwidth the system can also decide to retrieve less data, thus reducing the network traffic. This variant feature need not be in the magnitude of an entire component, but can often be represented as strategies within the concerned components.</p><p>This variability realization technique is summarized in Table <ref type="table" target="#tab_12">XI</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.10.">Variant component implementations</head><p>Intent. Support several coexisting implementations of one architecture component so that each of the implementations can be chosen at any given moment. Motivation. An architecture component typically represents some domain or sub-domain. These domains can be implemented using any of a number of standards and typically a system must support more than one simultaneously. For example, an email application may support several protocols for receiving emails, e.g. POP and IMAP, and is able to choose between these at runtime. Problems include that the architecture must support these different component implementations and other components in the system must be able to dynamically determine to what component implementation data and messages should be sent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Solution.</head><p>Implement several component implementations adhering to the same interface and make these component implementations tangible entities in the system architecture. There are a number of Design Patterns <ref type="bibr" target="#b15">[16]</ref> that facilitate this process. For example, the Strategy pattern is on a lower level a solution to the issue of having several implementations present simultaneously. Using the Broker pattern is one way of assuring that the correct implementation gets the data, as are patterns like Abstract Factory and Builder. Part of the flexibility of this variability realization technique stems from the fact that the collection is explicitly represented in the system, and the binding is done internally. The decision on exactly what component implementations to include in a particular product can be delegated to configuration management tools.</p><p>Lifecycle. This technique is introduced during architecture design, but is not open for addition of new variants until detailed design. For the domain and application engineers, the technique is not open during other phases. They can, however, develop component implementations for the end users to add to the system during later stages. This may involve installation, before or during startup or during runtime (if the system supports dynamic linking). Binding time of this technique is at runtime. The binding is done either at start-up, where a start-up parameter decides which component implementation to use, or at runtime, when an event decides which implementation to use. If the system supports dynamic linking, the linking can be delayed until binding time, but the technique works equally well when all variants are already compiled into the system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Consequences.</head><p>A consequence of using this technique is that the system will support several implementations of a domain simultaneously, and it must be possible to choose between them either at start-up or during execution of the system. Similarities in the different domains may lead to inclusion of several similar code sections in the system, code that could have been reused if the system had been designed differently. Examples. In the email application example, this technique is used to support several protocols for fetching emails, e.g. POP and IMAP. Both of these component implementations share the same interface for connecting to the mail server and checking for new emails. In addition, the IMAP component also has other interfaces since this protocol supports more functionality. For example, Axis Communications uses this technique to select between different network communication standards.</p><p>Ericsson Software Technology uses this technique to select between different filtering techniques to perform on call data in their Billing Gateway product <ref type="bibr" target="#b5">[6]</ref>. Some open-source Web browsers, e.g. Konqueror (http://www.kde.org), can optionally use the Web browsing component of Mozilla, called Gecko, instead of its internal browsing component (i.e. KHTML).</p><p>This variability realization technique is summarized in Table <ref type="table" target="#tab_13">XII</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.11.">Condition on constant</head><p>Intent. Support several ways to perform an operation, of which only one will be used in any given system.</p><p>Motivation. Essentially this is a more fine-grained version of a variant component specializations where the variant is not large enough to be a class in its own right. The reason for using the condition on constant technique can be for performance reasons and to help the compiler remove unused code.</p><p>In the case where the variant concerns connections to other, possibly variant, components, it is also a means to actually get the code through the compiler, since a method call to a non-existent class would cause the compilation process to abort.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Solution.</head><p>We can in this technique use two different types of conditional statements. One form includes pre-processor directives such as C++ #IFDEFs, and the other is the traditional if-statements in a programming language. If the former is used it can be used to alter the architecture of the system, for example by opting to include one file over another or using another class or component, whereas the latter can only work within the frame of a given system structure. In both cases, the collection of variants is implicit, but depending on whether traditional constants or pre-processor directives are used the binding is either internal or external, respectively. Another way to implement this variability Lifecycle. This technique is introduced while implementing the components and is activated during compilation of the system when it is decided using compile-time parameters which variant to include in the compiled binary. If a constant is used instead of a compile-time parameter, this is also bound at this point. After compilation, the technique is closed for adding new variants.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Consequences.</head><p>Using #IFDEFs or other pre-processor directives is always a risky business, since the number of potential execution paths tends to explode when using #IFDEFs, making maintenance and bug-fixing difficult. Variation points often tend to be scattered throughout the system, making it difficult to keep track of what parts of a system are actually affected by one variant.</p><p>Examples. When the email application example is reconfigured to become a USENET news reader, some menu options are also added, for example, the option to connect to a news server is added. The addition of this option is implemented within an #IFDEF statement, as is the functionality connected to the menu choice. Another example is the different cache types in Axis Communications <ref type="bibr" target="#b5">[6]</ref> storage servers, which can either be hard disk caches or traditional caches, where the file system component must call the cache type present in the system in the correct way. Calls to the cache component are spread throughout the file system component, meaning that many variability realization techniques on different levels are used, including in some cases condition on constant. This variability realization technique is summarized in Table <ref type="table" target="#tab_14">XIII</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.12.">Condition on variable</head><p>Intent. Support several ways to perform an operation of which only one will be used at any given moment but allow the choice to be rebound during execution.</p><p>Motivation. Sometimes, the variability provided by the condition on constant technique needs to be extended into runtime as well. Since constants are evaluated at compilation this cannot be done, hence a variable must be used instead. Solution. Replace the constant used in condition on constant with a variable and provide functionality for changing this variable. This technique cannot use any compiler directives but is rather a pure programming language construct. The collection of variants pertaining to the variation point does not have to be explicit, even though it can be. The process of binding to a particular variant is internal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lifecycle.</head><p>This technique is open during implementation, where new variants can be added, and is closed during compilation. It is bound at runtime when the variable is given a value that is evaluated by the conditional statements.</p><p>Consequences. This is a very flexible realization technique. It is a relatively harmless technique but, as with condition on constant, if the variation points for a particular variant feature are spread throughout the code it becomes difficult to get an overview.</p><p>Examples. This technique is used in all software programs to control the execution flow. For example, the ability in the email application example to browse messages sorted by name, date and subject is controlled using a variable that determines which sort order is currently active. This variability realization technique is summarized in Table XIV.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.13.">Code fragment superimposition</head><p>Intent. Introduce new considerations into a system without directly affecting the source code.</p><p>Motivation. Because a component can be used in several products, introducing product-specific considerations into the component is not desirable. However, it may be required to do so in order to be able to use the component at all. Product-specific behavior can be introduced in a multitude of ways, but these all tend to obscure the view of the component's core functionality, i.e. what the component is really supposed to do. It is also possible to use this technique to introduce variants of other forms that need not have to do with customizing source code to fit a particular product.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Solution.</head><p>The solution to this is to develop the software to function generically and then superimpose the product-specific concerns at a stage when the work with the source code is completed anyway. There are a number of tools for this, for example Aspect Oriented Programming <ref type="bibr" target="#b7">[8]</ref>, where different concerns are weaved into the source code just before the software is passed to the compiler and, superimposition as proposed by <ref type="bibr" target="#b35">[35]</ref>, where additional behavior is wrapped around existing behavior. The collection, in this case is implicit, and the binding is performed externally.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lifecycle.</head><p>Depending on what kind of implementation technique is used, variation points of this type are typically bound at either compilation or linking. Some experimental Java extensions exist that allow for runtime imposition of new functionality. However, such solutions typically require the use of reflection, which in most languages is not available. New variants may either be added by application or product engineers during either detailed design or compilation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Consequences.</head><p>A consequence of superimposing an algorithm is that different concerns are separated from the main functionality. This is positive as it increases the readability of what the source code is intended to do. However, this also means that it becomes harder to understand how the final code will work since the execution path is no longer obvious. When developing, one must be aware that there will or may be a superimposition of additional code at a later stage. In the case where binding is deferred to runtime, one must even program the system to add a concern to an object.</p><p>Examples. In the email application example, this technique is used to ship the product with a contextsensitive user assistant in the shape of a paper clip. Aspects are added throughout the source code containing functionality to inform the user assistant component of what is happening in the system. Advice for the end user is then dispersed based upon the gathered information. During compilation, the aspects are intertwined and compiled with the rest of the source code. To the best of our knowledge none of the case companies use this technique. This is not very surprising since at the time of writing, the only production ready technique that could be used is AspectJ. Several case studies are available from the Aspect Oriented Programming home page (http://www.aosd.net) that suggest that this technique may be used more often in the near future.</p><p>This variability realization technique is summarized in Table <ref type="table" target="#tab_16">XV</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.14.">Summary</head><p>In this section we presented a taxonomy of variability realization techniques. The way to use this taxonomy is, as described in Section 2, to decide upon the size of the software entities and the binding time. Then, with the help of Table <ref type="table" target="#tab_1">II</ref>, to determine which variability realization techniques are available. After this, additional characteristics are used to decide which technique to employ. These characteristics concern the population, i.e. when to add the variants and how the collection of variants should be managed, as well as where the functionality for the binding should reside. These characteristics are summarized at the end of each variability realization technique and in Table <ref type="table" target="#tab_17">XVI</ref>.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Axis Communications AB</head><p>Axis Communications is a medium-sized hardware and software company in the south of Sweden. They develop mass-market networked equipment, such as print servers, various storage servers (CD-ROM servers, JAZ servers and hard disk servers), camera servers and scan servers. Since the beginning of the 1990s, Axis Communications has employed a product family approach. At the time of our studies this software product family consisted of 13 reusable assets. These assets are in themselves object-oriented frameworks of differing size. Many of these assets are reused over the complete set of products, which in some cases have quite differing requirements on the assets. Moreover, because the systems are embedded systems, there are very stringent memory requirements; the application, and hence the assets, must not be larger than what is already fitted onto the motherboard. What this implies is that only the functionality used in a particular product may be compiled into the product software, and this calls for a somewhat different strategy when it comes to handling variability.</p><p>In this paper we have given several examples of how Axis implements variability in its software product family, but the variability realization technique they prefer is that of variant component implementations (Section 3.10), which is augmented with runtime variant component specializations (Section 3.9). Axis uses several other variability realization techniques as well, but this is more because of architecture decay which has occurred during the evolution of the software product family.</p><p>Further information can be found in two papers by Svahnberg and Bosch <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b6">7]</ref> and in our co-author's book on software product families <ref type="bibr" target="#b4">[5]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Ericsson Software Technology</head><p>Ericsson Software Technology is a leading software company within the telecommunications industry. At their site in Ronneby, Sweden they develop (among other products) their Billing Gateway product. The Billing Gateway is a mediating device between telephone switching stations and post-processing systems such as billing systems, fraud control systems, etc. The Billing Gateway has also been developed since the early 1990s, and was at the time of our study installed at more than 30 locations worldwide. The system is configured for every customer's needs with regards to, for instance, what switching station languages to support, and each customer builds a set of processing points that the telephony data should go through. Examples of processing points are formatters, filters, splitters, encoders, decoders and routers. These are connected into a dynamically configurable network through which the data are passed. Also for Ericsson, we have given several examples of how variability is implemented. As with Axis Communications, the favored variability realization technique is that of variant component implementations (Section 3.10), but Ericsson has managed to keep the interfaces and connectors between the software entities intact as the system has evolved, so there is lesser need to augment this realization technique with other techniques. In many ways their architecture is similar to the Infrastructure-centered architecture (Section 3.6).</p><p>For further reading, see <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b36">36,</ref><ref type="bibr" target="#b37">37,</ref><ref type="bibr" target="#b38">38]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Mozilla</head><p>The Mozilla Web browser was Netscape's Open Source project to create their next generation of Web browsers. In 2003, the Mozilla project was transferred to an independent foundation and the remains of the Netscape company were liquidated. One of the design goals of Mozilla is to be a platform for Web applications (see, e.g., the Web site http://www.mozdev.org-a repository for more than a hundred Mozilla-based projects). Mozilla is constructed using a highly flexible architecture which makes massive use of components. The entire system is organized around an infrastructure of XUL (a language for defining user interfaces), JavaScript (to bind functionality to the interfaces) and XPCOM (a COM-like model with components written in languages such as C++). The use of C++ for lower level components ensures high performance, whereas XUL and JavaScript ensure high flexibility concerning appearance (i.e. how and what to display), structure (i.e. the elements and relations) and interactions (i.e. how elements work across the relations). This model enables Mozilla to use the same infrastructure for all functionality sets, which ranges from email and news handling to Web browsing and text editing. Moreover, any functionality defined in this way is platform independent, and only requires the underlying C++ components to be reconstructed and/or recompiled for new platforms. Variability issues here concern the addition of new functionality sets, i.e. applications in their own right, and incorporation of new standards, for example regarding data formats such as HTML, CSS and various XML-based languages, such as RSS, XHTML and XBL.</p><p>As described above, Mozilla connects its components using XUL and XPCOM. In our taxonomy, this would translate to the use of an infrastructure-centered architecture (Section 3.6). Additionally, it uses an elaborate XML-based linking system to relate various resources to each other (XBL). This XBL (XML Binding Language) is used extensively, for example, to associate user interface skins with user interface elements. Both techniques can be seen as variations of the binary replacement-linker directives mechanism described in Section 3.4.</p><p>For further information regarding Mozilla, see <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b39">39,</ref><ref type="bibr" target="#b40">40]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.">Symbian-Epoc</head><p>EPOC is an operating system, an application framework, and an application suite specially designed for wireless devices such as hand-held, battery-powered computers and cellular phones. It was developed by Symbian, a company that is owned by major companies within the domain such as Ericsson, Nokia, Psion, Motorola and Matsushita, in order to be used in these companies' wireless devices. Variability issues here concern how to allow third-party applications to seamlessly and transparently integrate with a multitude of different operating environments, which may even affect the amount of functionality that the applications provide. For example, with screen sizes varying from a full VGA screen to a two-line cellular phone, the functionality and how this functionality is presented to the user will differ vastly between the different platforms. Symbian, by means of EPOC, does not interfere with how applications for the EPOC operating system implement variability. They do, however, provide support for creating applications supporting different operating environments. This was at the time of our studies done by dividing applications into a set of components handling user interface, application control and data storage (i.e. a Model-View-Controller pattern <ref type="bibr" target="#b28">[28]</ref>). The EPOC operating system itself is specialized for different hardware environments by using the architecture reorganization (Section 3.1) and variant architecture component (Section 3.2) variability realization techniques.</p><p>More information can be obtained from Symbian's Website <ref type="bibr" target="#b31">[31]</ref> and in <ref type="bibr" target="#b4">[5]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5.">Danaher Motion Särö AB</head><p>Danaher Motion Särö AB develops general control systems, software and electronic equipment in the field of materials handling control. Specifically, the company develops the control software for automated guided vehicles, i.e. automatic vehicles that handle transport of goods on factory floors. Danaher Motion Särö AB's product family consists of a range of software components that together control the assignment of cargo to vehicles, monitor and control the traffic (i.e. intelligent routing of vehicles to avoid traffic jams, for example) as well as steering and navigating the actual vehicles.</p><p>The most significant variant features in this product family concern a variety of navigation techniques, ranging from inductive wires in the factory floor to laser scanners mounted on the vehicles and specializations to each customer installation, such as different vehicles with varying loading facilities, and of course different factory layouts.</p><p>The variability realization techniques used in this software product family is mainly by using parameterization, e.g. in the form of a database with the layout of the factory floor, which translates to the realization technique 'condition on variable' described in Section 3.12. For the different navigation techniques, the realization technique used is mainly the 'variant architecture component' (Section 3.2), which is also aided by the use of an infrastructure-centered architecture (Section 3.6).</p><p>For further information about Danaher Motion Särö AB, see <ref type="bibr" target="#b41">[41]</ref> and <ref type="bibr" target="#b42">[42]</ref>. For a further introduction to the domain of automated guided vehicles, see <ref type="bibr" target="#b43">[43]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6.">Rohill Technologies BV</head><p>Rohill Technologies BV is a Dutch company that specializes in product and system development for professional mobile communication infrastructure, e.g. radio networks for police and fire departments. One of their major product families is TetraNode, a product family of trunked mobile radios. In this product family, the products are tailored to each customer's requirements by modifying the soft-and/or hardware architecture. The market for this type of radio systems is divided into a professional market, a medium market and a low-end market. The products for these three markets all use the same product family architecture, designed to support all three market segments. The architecture is then pruned to suit the different product architectures for each of these markets.</p><p>Rohill identifies two types of variability: anticipated (domain engineering) and unanticipated (application engineering). It is mainly through the anticipated variability that the product family is adjusted to the three market segments. This is done using license keys that load a certain set of dynamic linked libraries, as described in the variability realization technique 'binary replacement-linker directives' (Section 3.4). The unanticipated variability is mainly adjustments to specific customers' needs, something which is needed in approximately 20% of all products developed and delivered. The unanticipated variability is solved by introducing new source code files, and instructing the linker through makefiles to bind to these product-specific variants. This variability is, in fact, using the same realization technique as the anticipated variability, i.e. binary replacement through linker directives (Section 3.4), with the difference that the binding is external as opposed to internal binding for anticipated variability.</p><p>For further information regarding Rohill Technologies BV and their TetraNode product family, see <ref type="bibr" target="#b14">[15]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.7.">Cummins Inc.</head><p>Cummins Inc. is a U.S.-based company that develops diesel engines and the control software for these engines. Examples of usages of diesel engines involve automotives, power generation, marine, mining, railroad and agriculture. For these different markets the types of diesel engines vary in a number of ways. For example, the amount of horsepower, the number of cylinders, the type of fuel system, air handling systems and sensors vary between the different engines. Since 1994, Cummins Inc. has developed the control software for the different engine types in a software product family.</p><p>Cummins Inc. uses several variability realization techniques, ranging from the variant architecture components (Section 3.2) to select what components to include for a particular hardware configuration, to #IFDEFs, which translates to the realization technique condition on constant (Section 3.11), which is used to specify the exact hardware configuration with regards to how many cylinders, displacement, fuel type, etc. that the particular engine type has. The system also provides a large number of userconfigurable parameters, which are implemented using the variability realization technique condition on variable (Section 3.12).</p><p>The company Cummins Inc. and its product family are further described in <ref type="bibr" target="#b3">[4]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.8.">Control Channel Toolkit</head><p>Control Channel Toolkit, or CCT for short, is a software asset base commissioned by the National Reconnaissance Office (in the U.S.A.), and built by the Rayethon Company under contract. The asset base that is CCT consists of generalized requirements, domain specifications, a software architecture, a set of reusable software components, test procedures, a development environment definition and a guide for reusing the architecture and components. With the CCT, products are built that command and control satellites. Typically, only one software system is used per satellite. Development on CCT started in 1997.</p><p>The CCT uses an infrastructure-centered architecture (Section 3.6), i.e. CORBA, to connect the components in the architecture. Within the components, CCT provides a set of standard mechanisms: dynamic attributes, parameterization, template, function extension (callbacks), inheritance and scripting. Dynamic attributes and parameterization amounts to the technique condition on variable (Section 3.12). Inheritance is what we refer to as runtime variant component specializations (Section 3.9). Scripting is another example of an infrastructure-centered architecture (Section 3.6). We have not found sufficient information regarding function extension to identify which variability realization technique this is.</p><p>Further information on CCT can be found in <ref type="bibr" target="#b3">[4]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.9.">Market Maker</head><p>Market Maker is a German company that develops products that present stock market data, and also provide stock market data to users of its applications. Their product family includes a number of functionality packages to manage different aspects of the customers' needs, such as depot management, trend analysis, option strategies. It also consists of a number of products for different customer segments, such as individuals and different TV networks or TV news magazines. In 1999 a project was started to integrate this product family with another product family with similar functionality but with the ability to update and present stock data continuously, rather than at specified time intervals (six times/day). This new product family, the MERGER product family, is implemented in Java, and also includes salvaged Delphi code from the previous product family. Market Maker manages variability by having a property file for each customer that decides which features to enable for the particular customer. This property file translates to the variability realization technique condition on variable (Section 3.12). Properties in the property file are even used to decide what parts of the system to start up, by also making use of Java's reflection mechanism in which classes can be instantiated by providing the name of the class as a text string.</p><p>For further information about Market Maker and its MERGER product family, see <ref type="bibr" target="#b3">[4]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">RELATED WORK</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Software product families</head><p>In the past few years, there have been a number of publications on how to design and implement software product families, for instance, <ref type="bibr" target="#b1">[2]</ref><ref type="bibr" target="#b2">[3]</ref><ref type="bibr" target="#b3">[4]</ref>. These and other publications, such as <ref type="bibr" target="#b44">[44]</ref>, our coauthor's book <ref type="bibr" target="#b4">[5]</ref> and conferences such as SPLC 1 <ref type="bibr" target="#b45">[45]</ref> and the upcoming SPLC 2 conference have increased interest in and use of software product families. Empirical research such as <ref type="bibr" target="#b46">[46]</ref>, suggests that a software product family approach stimulates reuse in organizations. In addition, a follow-up paper <ref type="bibr" target="#b47">[47]</ref> provides empirical evidence for the hypothesis that organizations get the greatest reuse benefits during the early phases of development. Because of this we believe it is worthwhile for software product family developing companies to invest time and money in performing methods for determining and implementing variability.</p><p>Bass et al. <ref type="bibr" target="#b44">[44]</ref> define a software product family as a collection of systems sharing a managed set of features from a common set of core software assets. This is entirely in line with our view that using feature models is an important way of identifying and managing variability <ref type="bibr" target="#b12">[13]</ref>.</p><p>A case study presented in <ref type="bibr" target="#b49">[48]</ref> recommends that a focus on simplification, clarification and minimization is essential for the success of software product family architectures. However, the authors also warn against oversimplification since the architecture needs to be adaptable to future needs. In a case in which the architecture was over-simplified, the time needed to introduce a new feature tripled. Clearly the use of variation techniques needs to be adaptable and our taxonomy can help in selecting the right techniques so that the architecture can be both adaptable and not too complex. In addition, identifying the need for variation using for example feature diagrams (such as in our earlier work <ref type="bibr" target="#b12">[13]</ref>) is necessary. Other methods that may be of use are the FAST and PASTA <ref type="bibr" target="#b1">[2]</ref>, and FODA <ref type="bibr" target="#b21">[21]</ref>.</p><p>In <ref type="bibr" target="#b2">[3]</ref>, a number of variability mechanisms are discussed. However, the authors fail to put these mechanisms in a taxonomy like we do. In addition, variability is not linked to features. This is a vital characteristic of our approach as it is an important means for early identification (i.e. before architecture design) of variability needed in future system.</p><p>A comprehensive work on software product families is given in <ref type="bibr" target="#b3">[4]</ref>. This book presents what a software product family is and is not, the benefits gained by using a product family approach, and a wide range of practice areas, covering aspects of software engineering, technical management and organizational management. This book also presents, in great detail, three cases studies of companies using software product family solutions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Variability</head><p>There appears to be a lot of consensus that domain analysis and feature diagrams in particular are suitable for identifying and documenting variability. FODA <ref type="bibr" target="#b21">[21]</ref>, for instance, introduces a feature diagram notation that includes things like optional, mandatory and alternative features. In <ref type="bibr" target="#b22">[22]</ref>, which discusses the FODA-derived FORM method, feature diagrams are highlighted as a means of identifying commonality between products. Related to FODA is FeatureRSEB <ref type="bibr" target="#b23">[23]</ref>, which extends the use-case modeling of RSEB <ref type="bibr" target="#b10">[11]</ref> with the feature model of FODA. Also related is the FAST method described in <ref type="bibr" target="#b1">[2]</ref>, which also includes analyzing variability. The use of such techniques to organize requirements is also recommended in <ref type="bibr" target="#b3">[4]</ref>. This book presents a number of practices and patterns for the development of software product families.</p><p>In <ref type="bibr">[12, pp. 149-150]</ref>, it is observed that changes in a system can typically be related to individual features or small groups of features. Griss also states that 'Starting from the set of common and variable features needed to support a product-line, we can systematically develop and assemble the reusable elements needed to produce the customized components and frameworks to implement the product'.</p><p>A good overview of domain analysis and engineering methods is provided in <ref type="bibr" target="#b8">[9]</ref>. In this book, the authors also include a chapter on feature modeling and the relation of feature models to various generative programming techniques such as inheritance and parameterization. These techniques can be regarded as variability realization techniques as well.</p><p>In <ref type="bibr" target="#b50">[49]</ref> methodology for using COTS (commercial off the shelf) components is discussed. The discussion also includes what the authors refer to as alternative refinements. These alternative refinements can be seen an instance of our variant architecture component technique.</p><p>Some recent work has focused on exploiting variation points and providing languages for using these variation points. An example of such a language is Jarzabek's XVCL (XML-based Variant Configuration Language) <ref type="bibr" target="#b29">[29]</ref>, which is a language that describes systems in terms of variation. A generator then takes care of binding the variation points to the appropriate variants. It is tempting to regard this generation process as a separate variability realization technique. However, we have decided against this because the actual variation is not provided but only described by such languages. These languages merely use the techniques we describe in this paper and do not (at least in their present form) add to them. We are aware of several large companies that are using configuration languages to describe systems. For example, Philips uses the ADL KOALA <ref type="bibr" target="#b25">[25]</ref> to describe configurations of embedded software. An overview of ADL's using similar approaches is presented in <ref type="bibr" target="#b30">[30]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Variability realization techniques</head><p>In <ref type="bibr" target="#b10">[11]</ref>, five ways to implement variability are presented, namely, inheritance, extensions, parameterization, configuration and generation. Most of the variability realization techniques we present are based on these implementation techniques. Our contribution is that we explore when it is more suitable to select one technique over another, and what the consequences are of a particular technique. Moreover, we present more than one way in which one can use these implementation techniques.</p><p>The two major techniques for variability, as identified in our taxonomy, are configuration management and Design Patterns. Configuration management is dealt with extensively in <ref type="bibr" target="#b51">[50]</ref>, which presents the common configuration management tools of today, with their benefits and drawbacks. Design Patterns are discussed in detail in <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b28">28]</ref>, where many of the most commonly used Design Patterns are presented.</p><p>Configuration management is also identified as a variability realization mechanism in <ref type="bibr" target="#b52">[51]</ref>. This paper primarily focuses on how to model variability in terms of software modules, and is as such a complement to the feature graphs as discussed above. It does, however, also include a section on how to realize variability in the software product family, which includes techniques such as generators, compilation, adaptation during start-up and during runtime, and also configuration management. Our work complements this work by providing further detail on when to introduce variability, when it is possible to add new variants, and when it is possible to bind to a particular variant. We provide a comprehensive taxonomy that brings these things together into the decision of which realization technique to use, rather than just focusing on one of these aspects.</p><p>Another technique for variability, seen more and more often these days, is to use some form of infrastructure-centered architecture. Typically, these infrastructures involve some form of component platform, e.g. CORBA, COM/DCOM or JavaBeans <ref type="bibr" target="#b32">[32]</ref>.</p><p>During recent years, code fragment superimposition techniques have received increasing attention. Examples of such techniques are aspect-, feature-and subject-oriented programming. In aspectoriented programming, features are weaved into the product code <ref type="bibr" target="#b7">[8]</ref>. These features are in the magnitude of a few lines of source code. Feature-oriented programming extends this concept by weaving together entire classes of additional functionality <ref type="bibr" target="#b53">[52]</ref>. Subject-oriented programming <ref type="bibr" target="#b54">[53]</ref> is concerned with merging classes developed in parallel to achieve a combination of the merged classes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.">Historical notes</head><p>We received comments on a draft of this article that many of the concepts presented that relate to variability and product families as well as those published by others in recent years, are not new and that ideas like these were published as early as the 1960s (for example, <ref type="bibr" target="#b55">[54]</ref> discusses an early notion of software components that can be used and re-used in different environments). One of these pioneers, David Parnas, wrote a number of articles in the 1970s discussing program families and extension points. For example, in <ref type="bibr" target="#b56">[55]</ref>, a methodology for reusing a 'common ancestor' in different versions of a program is outlined. Ironically, this article makes a number of historical notes too, referring, for example, to the work of Dijkstra <ref type="bibr" target="#b57">[56]</ref>, who introduced the notion of step-wise refinement in software engineering. While Parnas deserves credit for his visionary papers in the 1970s, we note that he seems to have been primarily occupied with variation in time rather than in space (reusing an early version of product A to later develop product B). Additionally, while the examples used were certainly relevant then, using today's standards such systems would be considered very small. For example, <ref type="bibr" target="#b58">[57]</ref> discusses an 'address processing subsystem' that consists of 25 function calls (i.e. a moderately sized class in a modern object-oriented system), and <ref type="bibr" target="#b56">[55]</ref> discusses a space allocation algorithm consisting of (roughly) 25-30 lines of code. The technical detail of these articles is pretty much limited to the types of variation techniques that were common in those days (subroutines, gotos, etc.). Other trends that were emerging during that time are the early development of object orientation (e.g. Simula-67 and Smalltalk), which is a technique that underlies many of the variability realization techniques we describe in this article, and the already-mentioned discussions on software components <ref type="bibr" target="#b55">[54]</ref>. More recent contributions to the software engineering field, while still relying on the ground breaking work performed in the 1960s and 1970s, have since then, we argue, evolved and are much more detailed with respect to techniques, methodologies and case studies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSIONS</head><p>We have observed that software systems increasingly rely on variability mechanisms to exploit commonalities between software products. This has resulted in the adoption of so-called product families <ref type="bibr" target="#b1">[2]</ref><ref type="bibr" target="#b2">[3]</ref><ref type="bibr" target="#b3">[4]</ref> by numerous companies. However, it is often far from obvious what kind of techniques are the most suitable for implementing variability in a product family. In this article we make this decision process more obvious by providing a number of selection criteria and a taxonomy of variability realization techniques based on these criteria.</p><p>There are several factors that influence the choice of implementation technique, such as identifying the variant features, when variant features are to be bound, which software entities should be used to implement the variant features and last but not least how and when to bind the variation points related to a particular variant feature. Moreover, the job is not done just because the variant feature is implemented. The variation points and software entities implementing the variant feature need to be managed during the product's lifecycle, extended during evolution, and used during different stages of the development cycle. This also constrains the choices of how to implement the variability into the software system.</p><p>In this paper we present a minimal set of steps by which to introduce variability into a software product family, and what characteristics distinguish the ways in which one can implement variability. We present how these characteristics are used to constrain the number of possible ways to implement the variability, and what needs to be considered for each of these characteristics.</p><p>Once the variability has been constrained, the next step is to select a way in which to implement it into the software system. To this end, we provide a taxonomy of available variability realization techniques. This taxonomy presents the intent, motivation, solution, lifecycle, consequences and a brief example for each of the realization techniques. The variability realization techniques in the taxonomy are based around technical solutions we have observed in industry. These are generalized in that the domain-specific and company-specific technical details have been removed so that the underlying principles appear and can be used in different settings by different companies.</p><p>We believe that this taxonomy provides a toolbox for software developers when designing and implementing a software system, to assist them in selecting the most appropriate means by which to implement a particular variant feature and its corresponding variation points. By taking into account the steps outlined in this paper, and considering the characteristics we have identified, a more informed, and hopefully more accurate, decision can be made with respect to the variability realization techniques chosen to implement the variant features during the construction of a product or a software product family.</p><p>To the best of our knowledge, the taxonomy covers most conventional variation techniques. However in future work, we intend to further refine our taxonomy and annotate it with more examples from practice and from other domains. Currently we are working on several case studies (for example, in the context of the European IST funded CONIPF project of which the University of Groningen is an active partner). Preliminary experience with these case studies is confirming the results presented in this survey. However, it is too early to report on these cases.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Steps for introducing variability.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Example feature graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Example of phases in committing to a variant.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Summary of discussed concepts.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>• Solution. Known solutions to the problems presented in the motivation section. • Lifecycle. A description of when the realization technique is open, when it closes, and when it allows binding to one of the variants. • Consequences. The consequences and potential hazards of using the realization technique. • Examples. Some examples of the realization technique in use at the companies in which we have conducted case studies.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Design of example email application: (a) an e-mail client; (b) a USENET news application.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. Email application with two different sets of libraries.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. An email application using a CORBA bus.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. Example of variant component specialization.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 10 .</head><label>10</label><figDesc>Figure 10. Example of runtime variant component specialization.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>John Wiley &amp; Sons, Ltd. Softw. Pract. Exper. 2005; 35:705-754</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table I .</head><label>I</label><figDesc>Entities most likely to be in focus during the different development activities.</figDesc><table><row><cell cols="4">Development activities Software entities in focus</cell></row><row><cell cols="2">Architecture design</cell><cell>Components</cell><cell></cell></row><row><cell></cell><cell></cell><cell>Frameworks</cell><cell></cell></row><row><cell>Detailed design</cell><cell></cell><cell cols="2">Framework implementations</cell></row><row><cell></cell><cell></cell><cell>Sets of classes</cell><cell></cell></row><row><cell>Implementation</cell><cell></cell><cell>Individual classes</cell><cell></cell></row><row><cell></cell><cell></cell><cell>Lines of code</cell><cell></cell></row><row><cell>Compilation</cell><cell></cell><cell>Lines of code</cell><cell></cell></row><row><cell>Linking</cell><cell></cell><cell>Binary components</cell><cell></cell></row><row><cell>Variant Feature</cell><cell></cell><cell>Variant</cell><cell>Software Entity</cell></row><row><cell>1</cell><cell>*</cell><cell>1</cell><cell>*</cell></row><row><cell>1</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="2">-Connects to</cell></row><row><cell></cell><cell></cell><cell>Variation Point</cell><cell></cell></row><row><cell></cell><cell>*</cell><cell>0..*</cell><cell></cell></row></table><note><p>* Figure 3. Relations between terms.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table II .</head><label>II</label><figDesc>Variability realization techniques.</figDesc><table><row><cell></cell><cell></cell><cell cols="2">Binding time</cell><cell></cell></row><row><cell>Involved</cell><cell>Product architecture</cell><cell></cell><cell></cell><cell></cell></row><row><cell>software entities</cell><cell>derivation</cell><cell>Compilation</cell><cell>Linking</cell><cell>Runtime</cell></row><row><cell>Components</cell><cell>Architecture</cell><cell>N/A</cell><cell>Binary</cell><cell>Infrastructure-</cell></row><row><cell>frameworks</cell><cell>reorganization</cell><cell></cell><cell>replacement-</cell><cell>centered</cell></row><row><cell></cell><cell>(Section 3.1)</cell><cell></cell><cell>linker directives</cell><cell>architecture</cell></row><row><cell></cell><cell>Variant architecture</cell><cell></cell><cell>(Section 3.4)</cell><cell>(Section 3.6)</cell></row><row><cell></cell><cell>component</cell><cell></cell><cell>Binary</cell><cell></cell></row><row><cell></cell><cell>(Section 3.2)</cell><cell></cell><cell>replacement-</cell><cell></cell></row><row><cell></cell><cell>Optional</cell><cell></cell><cell>physical</cell><cell></cell></row><row><cell></cell><cell>architecture</cell><cell></cell><cell>(Section 3.5)</cell><cell></cell></row><row><cell></cell><cell>component</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>(Section 3.3)</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Component</cell><cell>Variant component</cell><cell>Code fragment</cell><cell>Binary</cell><cell>Runtime variant</cell></row><row><cell>implementations</cell><cell>specializations</cell><cell>superimposition</cell><cell>replacement-</cell><cell>component</cell></row><row><cell>Framework</cell><cell>(Section 3.7)</cell><cell>(Section 3.13)</cell><cell>linker directives</cell><cell>specializations</cell></row><row><cell>implementations</cell><cell>Optional</cell><cell></cell><cell>(Section 3.4)</cell><cell>(Section 3.9)</cell></row><row><cell>Classes</cell><cell>component</cell><cell></cell><cell>Binary</cell><cell>Variant component</cell></row><row><cell></cell><cell>specializations</cell><cell></cell><cell>replacement-</cell><cell>implementations</cell></row><row><cell></cell><cell>(Section 3.8)</cell><cell></cell><cell>physical</cell><cell>(Section 3.10)</cell></row><row><cell></cell><cell></cell><cell></cell><cell>(Section 3.5)</cell><cell></cell></row><row><cell>Lines of code</cell><cell>N/A</cell><cell>Condition on</cell><cell>N/A</cell><cell>Condition on</cell></row><row><cell></cell><cell></cell><cell>constant</cell><cell></cell><cell>variable</cell></row><row><cell></cell><cell></cell><cell>(Section 3.11)</cell><cell></cell><cell>(Section 3.12)</cell></row><row><cell></cell><cell></cell><cell>Code fragment</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>superimposition</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>(Section 3.13)</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table III .</head><label>III</label><figDesc>Summary of architecture reorganization.</figDesc><table><row><cell>Introduction times</cell><cell>Architecture design</cell></row><row><cell cols="2">Open for adding variants Architecture design</cell></row><row><cell>Collection of variants</cell><cell>Implicit</cell></row><row><cell>Binding times</cell><cell>Product architecture derivation</cell></row><row><cell cols="2">Functionality for binding External</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table IV .</head><label>IV</label><figDesc>Summary of variant architecture component.</figDesc><table><row><cell>Introduction times</cell><cell>Architecture design</cell></row><row><cell cols="2">Open for adding variants Architecture design</cell></row><row><cell></cell><cell>Detailed design</cell></row><row><cell>Collection of variants</cell><cell>Implicit</cell></row><row><cell>Binding times</cell><cell>Product architecture derivation</cell></row><row><cell cols="2">Functionality for binding External</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table V .</head><label>V</label><figDesc>Summary of optional architecture component.</figDesc><table><row><cell>Introduction times</cell><cell>Architecture design</cell></row><row><cell cols="2">Open for adding variants Architecture design</cell></row><row><cell></cell><cell>Detailed design</cell></row><row><cell>Collection of variants</cell><cell>Implicit</cell></row><row><cell>Binding times</cell><cell>Product architecture derivation</cell></row><row><cell cols="2">Functionality for binding External</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table VI .</head><label>VI</label><figDesc>Summary of binary replacement-linker directives.</figDesc><table><row><cell>Introduction times</cell><cell>Architecture design</cell></row><row><cell>Open for adding variants</cell><cell>Linking</cell></row><row><cell>Collection of variants</cell><cell>Implicit or explicit</cell></row><row><cell>Binding times</cell><cell>Linking</cell></row><row><cell>Functionality for binding</cell><cell>External or internal</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table VII .</head><label>VII</label><figDesc>Summary of binary replacement-physical.</figDesc><table><row><cell>Introduction times</cell><cell>Architecture design</cell></row><row><cell>Open for adding variants</cell><cell>After compilation</cell></row><row><cell>Collection of variants</cell><cell>Implicit</cell></row><row><cell>Binding times</cell><cell>Before runtime</cell></row><row><cell>Functionality for binding</cell><cell>External</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Table VIII .</head><label>VIII</label><figDesc>Summary of infrastructure-centered architecture.</figDesc><table><row><cell>Introduction times</cell><cell>Architecture design</cell></row><row><cell>Open for adding variants</cell><cell>Architecture design</cell></row><row><cell></cell><cell>Linking</cell></row><row><cell></cell><cell>Runtime</cell></row><row><cell>Collection of variants</cell><cell>Implicit or explicit</cell></row><row><cell>Binding times</cell><cell>Compilation</cell></row><row><cell></cell><cell>Runtime</cell></row><row><cell>Functionality for binding</cell><cell>Internal</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head>Table IX .</head><label>IX</label><figDesc>Summary of variant component specialization. realization technique once it is bound, thus presenting an unobstructed view for subsequent development phases. Hence, the technique needs to work during product architecture derivation, i.e. at the same time as the variability realization techniques it works together with. Solution. Separate the interfacing parts into separate classes that can decide the best way to interact with the other component. Let the configuration management tool decide what classes to include at the same time as it is decided what variant of the interfaced component to include in the product architecture. This technique has an implicit collection, and external binding functionality.</figDesc><table><row><cell>Introduction times</cell><cell>Detailed design</cell></row><row><cell cols="2">Open for adding variants Detailed design</cell></row><row><cell>Collection of variants</cell><cell>Implicit</cell></row><row><cell>Binding times</cell><cell>Product architecture derivation</cell></row><row><cell cols="2">Functionality for binding External</cell></row></table><note><p>variability</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>Table X .</head><label>X</label><figDesc>Summary of optional component specialization.</figDesc><table><row><cell>Introduction times</cell><cell>Detailed design</cell></row><row><cell cols="2">Open for adding variants Detailed design</cell></row><row><cell>Collection of variants</cell><cell>Implicit</cell></row><row><cell>Binding times</cell><cell>Product architecture derivation</cell></row><row><cell cols="2">Functionality for binding External</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head>Table XI .</head><label>XI</label><figDesc>Summary of runtime variant component specializations.</figDesc><table><row><cell>Introduction times</cell><cell>Detailed design</cell></row><row><cell>Open for adding variants</cell><cell>Detailed design</cell></row><row><cell>Collection of variants</cell><cell>Explicit</cell></row><row><cell>Binding times</cell><cell>Runtime</cell></row><row><cell>Functionality for binding</cell><cell>Internal</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13"><head>Table XII .</head><label>XII</label><figDesc>Summary of variant component implementations.</figDesc><table><row><cell>Introduction times</cell><cell>Architecture design</cell></row><row><cell>Open for adding variants</cell><cell>Detailed design</cell></row><row><cell>Collection of variants</cell><cell>Explicit</cell></row><row><cell>Binding times</cell><cell>Runtime</cell></row><row><cell>Functionality for binding</cell><cell>Internal</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_14"><head>Table XIII .</head><label>XIII</label><figDesc>Summary of condition on constant. technique is by means of C++ templates which are handled similarly to pre-processor directives by most compilers we have encountered ¶ .</figDesc><table><row><cell>Introduction times</cell><cell>Implementation</cell></row><row><cell cols="2">Open for adding variants Implementation</cell></row><row><cell>Collection of variants</cell><cell>Implicit</cell></row><row><cell>Binding times</cell><cell>Compilation</cell></row><row><cell cols="2">Functionality for binding Internal or external</cell></row></table><note><p>realization</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_15"><head>Table XIV .</head><label>XIV</label><figDesc>Summary of condition on variable.</figDesc><table><row><cell>Introduction times</cell><cell>Implementation</cell></row><row><cell cols="2">Open for adding variants Implementation</cell></row><row><cell>Collection of variants</cell><cell>Implicit or explicit</cell></row><row><cell>Binding times</cell><cell>Runtime</cell></row><row><cell cols="2">Functionality for binding Internal</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_16"><head>Table XV .</head><label>XV</label><figDesc>Summary of code fragment superimposition.</figDesc><table><row><cell>Introduction times</cell><cell>Compilation</cell></row><row><cell>Open for adding variants</cell><cell>Compilation</cell></row><row><cell>Collection of variants</cell><cell>Implicit</cell></row><row><cell>Binding times</cell><cell>Compilation</cell></row><row><cell></cell><cell>Runtime</cell></row><row><cell>Functionality for binding</cell><cell>External</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_17"><head>Table XVI .</head><label>XVI</label><figDesc>Summary of variability realization techniques.</figDesc><table><row><cell>Collection</cell></row><row><cell>Open for</cell></row><row><cell>Introduction</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Copyright c 2005 John Wiley &amp; Sons, Ltd. Softw. Pract. Exper. 2005; 35:705-754</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>§  Within the open source community, e.g. the Linux kernel, the border between an end user and a developer has historically not been distinct, so in many cases one has indeed expected the end users to be able to edit and compile source code. The trend in more recent releases, e.g. the Linux kernel, is to move away from this method of supporting variability. Copyright c 2005 John Wiley &amp; Sons, Ltd. Softw. Pract. Exper. 2005; 35:705-754</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>¶ A simple experiment is to construct a template class containing a text string and then instantiate it a number of times with different types for the template. Compile using, e.g., the default CC compiler in Solaris and then see how many times the text string occurs in the compiled binary. By changing the number of instantiations of the class a couple of times a correlation is quickly found between the number of different instantiation types and the number of occurrences of the text string. Copyright c 2005 John Wiley &amp; Sons, Ltd. Softw. Pract. Exper. 2005; 35:705-754</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_3"><p>The name EPOC has subsequently been changed to SymbianOS. However, at the time we were in contact with Symbian (1999-2000); the software was still referred to as EPOC. Probably, the software has evolved significantly since then. Copyright c 2005 John Wiley &amp; Sons, Ltd. Softw. Pract. Exper. 2005; 35:705-754</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>We would like to thank the reviewers for their feedback on earlier drafts of this article. Their constructive criticism has enabled us to make many improvements. Additionally, we would like to thank the companies who have worked with us in the various case studies: Symbian (named UIQ nowadays), Axis Communications AB, Philips, Ericsson Software Technology, Danaher Motion Särö AB, and the Mozilla project.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">CASE STUDIES</head><p>In this section we briefly detail a set of companies that use product families, and how these have typically implemented variability, i.e. what variability realization techniques they have mostly used in their software product families.</p><p>The cases are divided into three categories.</p><p>• Cases on which we based the taxonomy of variability realization techniques.</p><p>• Unrelated case studies conducted after the initial taxonomy was created, which were used to confirm and refine the taxonomy. • Cases found in the literature that contain information regarding how variability was typically implemented.</p><p>We provide a brief presentation of the companies within each category and how they have typically implemented variability. The cases from the first category are presented to give a further overview of the companies behind the examples in the taxonomy. The second category is presented to provide examples of which we have in-depth knowledge, having been given full insight into the development process and having helped in refining the taxonomy. The third category is included to extend the generalizability of the taxonomy further, by providing cases over which we ourselves have not had any influence.</p><p>Observed cases. The taxonomy of variability realization techniques and indeed the identification of the relevant characteristics to distinguish between different variability realization techniques was created using information gathered from four companies. These companies are:</p><p>• Axis Communications AB and their storage server product family <ref type="bibr" target="#b4">[5]</ref><ref type="bibr" target="#b5">[6]</ref><ref type="bibr" target="#b6">[7]</ref> (presented in Section 4.1); • Ericsson Software Technology and their Billing Gateway product <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b37">37,</ref><ref type="bibr" target="#b38">38]</ref> (presented in Section 4.2); • The Mozilla Web browser <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b39">39,</ref><ref type="bibr" target="#b40">40]</ref> (presented in Section 4.3); • Symbian and the EPOC Operating System <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b31">31]</ref> (presented in Section 4.4).</p><p>Confirming cases. The second category includes case studies conducted by the research groups of the authors of this paper. These case studies were not conducted with the purpose of creating or refining the taxonomy of variability realization techniques. However, during these studies we had the opportunity to see and get an in-depth understanding of the software product families. Hence, we can make confident statements regarding how these companies choose implementation strategies for their variant features and what these implementation strategies are. The companies in this category are:</p><p>• Danaher Motion Särö AB <ref type="bibr" target="#b41">[41]</ref> (presented in Section 4.5); • Rohill Technologies BV <ref type="bibr" target="#b14">[15]</ref> (presented in Section 4.6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Additional cases.</head><p>In the third and final category we include examples of case studies described in the literature where these descriptions are of sufficient detail to discern what types of variability realization techniques these companies typically use. The cases in this category are:</p><p>• Cummins Inc. <ref type="bibr" target="#b3">[4]</ref> (presented in Section 4.7); • Control Channel Toolkit <ref type="bibr" target="#b3">[4]</ref> (presented in Section 4.8); • Market Maker <ref type="bibr" target="#b3">[4]</ref> (presented in Section 4.9).</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">On the notion of variability in software product lines</title>
		<author>
			<persName><forename type="first">M</forename><surname>Svahnberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Van Gurp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bosch</surname></persName>
		</author>
		<idno>BTH-RES- 02/01-SE</idno>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
		<respStmt>
			<orgName>Blekinge Institute of Technology, Sweden</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Software Product-Line Engineering: A Family Based Software Development Process</title>
		<author>
			<persName><forename type="first">Ctr</forename><surname>Lai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Weiss</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Addison-Wesley: Reading, MA</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Software Architecture for Product Families: Principles and Practice</title>
		<author>
			<persName><forename type="first">M</forename><surname>Jazayeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Van Der Linden</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Software Product Lines-Practices and Patterns</title>
		<author>
			<persName><forename type="first">P</forename><surname>Clements</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Northrop</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Design &amp; Use of Software Architectures-Adopting and Evolving a Product Line Approach</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bosch</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Evolution in software product lines: Two cases</title>
		<author>
			<persName><forename type="first">M</forename><surname>Svahnberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bosch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Software Maintenance-Research and Practice</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="391" to="422" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Characterizing evolution in product line architectures</title>
		<author>
			<persName><forename type="first">M</forename><surname>Svahnberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bosch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd Annual IASTED International Conference on Software Engineering and Applications</title>
		<meeting>the 3rd Annual IASTED International Conference on Software Engineering and Applications<address><addrLine>Anaheim, CA</addrLine></address></meeting>
		<imprint>
			<publisher>IASTED/Acta Press</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="92" to="97" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Aspect oriented programming</title>
		<author>
			<persName><forename type="first">G</forename><surname>Kiczalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lamping</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mendhekar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Maeda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lopes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J-M</forename><surname>Loingtier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Irwin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th European Conference on Object-Oriented Programming</title>
		<meeting>the 11th European Conference on Object-Oriented Programming<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="220" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Generative Programming-Methods, Tools and Applications</title>
		<author>
			<persName><forename type="first">K</forename><surname>Czarnecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><forename type="middle">W</forename><surname>Eisenecker</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Recommended practice for architectural description of software-intensive systems</title>
		<author>
			<persName><surname>Ieee</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="1471" to="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Software Reuse: Architecture, Process and Organization for Business Success</title>
		<author>
			<persName><forename type="first">I</forename><surname>Jacobson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Griss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Johnson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Implementing product line features with component reuse</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Griss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th International Conference on Software Reuse</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 6th International Conference on Software Reuse<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1844</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">On the notion of variability in software product lines</title>
		<author>
			<persName><forename type="first">J</forename><surname>Van Gurp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bosch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Svahnberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Working IEEE/IFIP Conference on Software Architecture</title>
		<meeting>the Working IEEE/IFIP Conference on Software Architecture</meeting>
		<imprint>
			<date type="published" when="2001-08">2001. August 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Variability issues in software product lines</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bosch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Florijn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Greefhorst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kuusela</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Obbink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pohl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th International Workshop on Product Family Engineering</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 4th International Workshop on Product Family Engineering<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2290</biblScope>
			<biblScope unit="page" from="13" to="21" />
		</imprint>
	</monogr>
	<note>Linden Fvd</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Representing variability in software product lines: A case study</title>
		<author>
			<persName><forename type="first">M</forename><surname>Jaring</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bosch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Second Product Line Conference (SPLC-2)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>San Diego, CA; Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002-08-22">19-22 August 2002. 2002</date>
			<biblScope unit="volume">2379</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Design Patterns: Elements of Reusable Object-Oriented Software</title>
		<author>
			<persName><forename type="first">E</forename><surname>Gamma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Helm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vlissides</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Ltd. Softw. Pract. Exper</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="705" to="754" />
			<date type="published" when="2005">2005. 2005</date>
			<publisher>John Wiley &amp; Sons</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Comprehensive variability modeling to facilitate efficient variability treatment</title>
		<author>
			<persName><forename type="first">M</forename><surname>Becker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Geyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gilbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Becker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th International Workshop on Product Family Engineering</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 4th International Workshop on Product Family Engineering<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2290</biblScope>
			<biblScope unit="page" from="294" to="303" />
		</imprint>
	</monogr>
	<note>Linden Fvd</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Modeling variability with features in distributed architectures</title>
		<author>
			<persName><forename type="first">R</forename><surname>Capilla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Dueñas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th International Workshop on Product Family Engineering</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Linden</forename><surname>Fvd</surname></persName>
		</editor>
		<meeting>the 4th International Workshop on Product Family Engineering<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2290</biblScope>
			<biblScope unit="page" from="319" to="329" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Easing the transition to software mass customization</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Krueger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th International Workshop on Product Family Engineering</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Linden</forename><surname>Fvd</surname></persName>
		</editor>
		<meeting>the 4th International Workshop on Product Family Engineering<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2290</biblScope>
			<biblScope unit="page" from="282" to="293" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Expression and usage of the variability in the software product lines</title>
		<author>
			<persName><forename type="first">S</forename><surname>Salicki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Farcet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th International Workshop on Product Family Engineering</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 4th International Workshop on Product Family Engineering<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2290</biblScope>
			<biblScope unit="page" from="304" to="318" />
		</imprint>
	</monogr>
	<note>Linden Fvd</note>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Feature oriented domain analysis (FODA) feasibility study</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">C</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">G</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Hess</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">E</forename><surname>Novak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Peterson</surname></persName>
		</author>
		<idno>CMU/SEI-90-TR-21</idno>
		<imprint>
			<date type="published" when="1990">1990</date>
			<pubPlace>Pittsburgh, PA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Software Engineering Institute, Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">FORM: A feature-oriented reuse method with domain specific architectures</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">C</forename><surname>Kang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Software Engineering</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="345" to="355" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Integrating feature modeling with the RSEB</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Griss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Favaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Alessandro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifth International Conference on Software Reuse</title>
		<meeting>the Fifth International Conference on Software Reuse<address><addrLine>Los Alamitos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="76" to="85" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Four dark corners of requirements engineering</title>
		<author>
			<persName><forename type="first">P</forename><surname>Zave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jackson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Software Engineering and Methodology</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="30" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Building Reliable Component-Based Software Systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Van Ommering</surname></persName>
		</author>
		<editor>Crnkovic I, Larsson M</editor>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Artech House Publishers: Norwood, MA</publisher>
		</imprint>
	</monogr>
	<note>The Koala component model</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Foundations for the study of software architecture</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Perry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Wolf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGSOFT Software Engineering Notes</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="40" to="52" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Design erosion: Problems &amp; causes</title>
		<author>
			<persName><forename type="first">J</forename><surname>Van Gurp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bosch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Systems &amp; Software</title>
		<imprint>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="105" to="119" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Pattern-Oriented Software Architecture-A System of Patterns</title>
		<author>
			<persName><forename type="first">F</forename><surname>Buschmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Jäkel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Meunier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Rohnert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stahl</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Wiley</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">XVCL: XML-based variant configuration language</title>
		<author>
			<persName><forename type="first">S</forename><surname>Jarzabek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Basset</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Software Engineering, ICSE&apos;03</title>
		<meeting>the International Conference on Software Engineering, ICSE&apos;03<address><addrLine>Los Alamitos CA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="810" to="811" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">A classification and comparison framework for software architecture description languages</title>
		<author>
			<persName><forename type="first">N</forename><surname>Medvidovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">N</forename><surname>Taylor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="70" to="93" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<ptr target="http://www.uiq.com/" />
		<title level="m">Symbian Website (now UIQ website)</title>
		<imprint>
			<date type="published" when="2005-01-14">14 January 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Component Software-Beyond Object-Oriented Programming</title>
		<author>
			<persName><forename type="first">C</forename><surname>Szyperski</surname></persName>
		</author>
		<editor>Harlow, U.K.</editor>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Scripting: Higher level programming for the 21st century</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">K</forename><surname>Ousterhout</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="page" from="23" to="31" />
			<date type="published" when="1998-05">May 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Proceedings on Object-Oriented Programming systems, Languages and Applications</title>
		<author>
			<persName><forename type="first">H</forename><surname>Lieberman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
			<publisher>ACM Press</publisher>
			<biblScope unit="page" from="214" to="223" />
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
	<note>Using prototypical objects to implement shared behavior</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Superimposition: A component adaption technique</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bosch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Software Technology</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="257" to="273" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Evolution and composition of object-oriented frameworks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Mattsson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
		<respStmt>
			<orgName>Blekinge Institute of Technology, Sweden</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD Thesis</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Evolution observations of an industry object-oriented framework</title>
		<author>
			<persName><forename type="first">M</forename><surname>Mattsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bosch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Software Maintenance</title>
		<meeting>the International Conference on Software Maintenance<address><addrLine>Los Alamitos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="139" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Characterizing stability in evolving frameworks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Mattsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bosch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of TOOLS Europe</title>
		<meeting>TOOLS Europe<address><addrLine>Los Alamitos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1999">1999. 1999</date>
			<biblScope unit="page" from="118" to="130" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Mozilla</forename><surname>Website</surname></persName>
		</author>
		<ptr target="http://www.mozilla.org/" />
		<imprint>
			<date type="published" when="2005-01-14">14 January 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">XULNotes: A XUL bestiality</title>
		<author>
			<persName><forename type="first">I</forename><surname>Oeschger</surname></persName>
		</author>
		<ptr target="http://www.mozilla.org/docs/xul/xulnotes/xulnotebeasts.html" />
		<imprint>
			<date type="published" when="2000-05">May 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Conditions and restrictions for product line generation migration</title>
		<author>
			<persName><forename type="first">M</forename><surname>Svahnberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mattsson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th International Workshop on Product Family Engineering</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 4th International Workshop on Product Family Engineering<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2290</biblScope>
		</imprint>
	</monogr>
	<note>Linden Fvd</note>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<ptr target="http://www.danahermotion.se/" />
		<title level="m">Danaher Motion Särö AB Website</title>
		<imprint>
			<date type="published" when="2005-01-14">14 January 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">A roller-coaster ride for AGVs</title>
		<author>
			<persName><forename type="first">T</forename><surname>Feare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Modern Materials Handling</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="55" to="63" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title level="m" type="main">Software Architecture in Practice</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Clements</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kazman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Donohoe</surname></persName>
		</author>
		<title level="m">Proceedings of the First Software Product Line Conference (SPLC1)</title>
		<meeting>the First Software Product Line Conference (SPLC1)</meeting>
		<imprint>
			<publisher>Dordrecht</publisher>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Investments in reusable software. A study of software reuse investment success factors</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Rine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Sonnemann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Systems and Software</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="17" to="32" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">An empirical study of a software reuse reference model</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Rine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nada</forename><forename type="middle">N</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Software Technology</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="47" to="65" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Ltd. Softw. Pract. Exper</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="705" to="754" />
			<date type="published" when="2005">2005. 2005</date>
			<publisher>John Wiley &amp; Sons</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Applying software product-line architecture</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dikel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kane</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ornburn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Loftus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wilson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="page" from="49" to="55" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<title level="m" type="main">Building Systems from Commercial Components</title>
		<author>
			<persName><forename type="first">K</forename><surname>Wallnau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Hissam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Seacord</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Version models for software configuration management</title>
		<author>
			<persName><forename type="first">R</forename><surname>Conradi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Westfechtel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Survey</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="232" to="282" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Managing variability in software architectures</title>
		<author>
			<persName><forename type="first">F</forename><surname>Bachmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bass</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Software Reusability: Putting Software Reuse in Context</title>
		<meeting>the ACM Symposium on Software Reusability: Putting Software Reuse in Context</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="126" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Feature-oriented programming: A fresh look at objects</title>
		<author>
			<persName><forename type="first">C</forename><surname>Prehofer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the European Conference on Object-Oriented Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the European Conference on Object-Oriented Programming<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1241</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Subject-oriented design and the Watson subject compiler</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kaplan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ossher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Harrisson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kruskal</surname></persName>
		</author>
		<ptr target="http://www.research.ibm.com/sop/papers/position96.htm" />
	</analytic>
	<monogr>
		<title level="m">Position paper for the International Conference on Object-Oriented Programming, Systems, Languages, and Applications Subjectivity Workshop</title>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Mcilroy</surname></persName>
		</author>
		<title level="m">Mass produced software components. Software Engineering: Concepts and Techniques</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Buxton</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Naur</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Randell</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Petrocelli/Charter Publishers Inc</publisher>
			<date type="published" when="1969">1969. 1976</date>
			<biblScope unit="page" from="88" to="98" />
		</imprint>
	</monogr>
	<note>republished</note>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">On the design and development of program families</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Parnas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="9" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Dijkstra</surname></persName>
		</author>
		<title level="m">Structured programming. Software Engineering Techniques</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">N</forename><surname>Buxton</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Randell</surname></persName>
		</editor>
		<meeting><address><addrLine>Belgium</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1970">1970</date>
			<biblScope unit="page" from="84" to="87" />
		</imprint>
	</monogr>
	<note>NATO Scientific Affairs Division: Brussels</note>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Designing software for ease of extension and contraction</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Parnas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Software Engineering</title>
		<meeting>the International Conference on Software Engineering<address><addrLine>Piscataway, NJ</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="1978">1978</date>
			<biblScope unit="page" from="264" to="277" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Ltd. Softw. Pract. Exper</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="705" to="754" />
			<date type="published" when="2005">2005. 2005</date>
			<publisher>John Wiley &amp; Sons</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
