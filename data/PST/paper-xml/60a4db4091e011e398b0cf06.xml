<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">MetaSys: A Practical Open-Source Metadata Management System to Implement and Evaluate Cross-Layer Optimizations</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2021-05-17">17 May 2021</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Nandita</forename><forename type="middle">Vijaykumar</forename><surname>Ataberk</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Olgun</forename><surname>§ℵ</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Konstantinos</forename><surname>Kanellopoulos</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Nisa</forename><surname>Bostanci</surname></persName>
						</author>
						<author>
							<persName><forename type="first">§ℵ</forename><surname>Hasan</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Mehrshad</forename><surname>Lotfi</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Phillip</forename><forename type="middle">B</forename><surname>Gibbons</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Carnegie Mellon University § ETH Zürich ℵ TOBB ETÜ ‡ Max Plank Institute</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Onur</forename><surname>Mutlu</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Carnegie Mellon University § ETH Zürich ℵ TOBB ETÜ ‡ Max Plank Institute</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">University of Toronto</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">MetaSys: A Practical Open-Source Metadata Management System to Implement and Evaluate Cross-Layer Optimizations</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2021-05-17">17 May 2021</date>
						</imprint>
					</monogr>
					<idno type="arXiv">arXiv:2105.08123v1[cs.AR]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T14:01+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper introduces the first open-source FPGAbased infrastructure, MetaSys, with a prototype in a RISC-V core, to enable the rapid implementation and evaluation of a wide range of cross-layer techniques in real hardware. Hardware-software cooperative techniques are powerful approaches to improve the performance, quality of service, and security of general-purpose processors. They are however typically challenging to rapidly implement and evaluate in real hardware as they require full-stack changes to the hardware, OS, system software, and instruction-set architecture (ISA).</p><p>MetaSys implements a rich hardware-software interface and lightweight metadata support that can be used as a common basis to rapidly implement and evaluate new cross-layer techniques. We demonstrate MetaSys's versatility and ease-of-use by implementing and evaluating three cross-layer techniques for: (i) prefetching for graph analytics; (ii) bounds checking in memory unsafe languages, and (iii) return address protection in stack frames; each technique only requiring ~100 lines of Chisel code over MetaSys.</p><p>Using MetaSys, we perform the first detailed experimental study to quantify the performance overheads of using a single metadata management system to enable multiple cross-layer optimizations in CPUs. We identify the key sources of bottlenecks and system inefficiency of a general metadata management system. We design MetaSys to minimize these inefficiencies and provide increased versatility compared to previously-proposed metadata systems. Using three use cases and a detailed characterization, we demonstrate that a common metadata management system can be used to efficiently support diverse crosslayer techniques in CPUs.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Hardware-software cooperative techniques offer a powerful approach to improve the performance and efficiency of generalpurpose processors. These techniques involve communicating key application information from the software to the architecture to enable more powerful optimizations and resource management in hardware. Recent research proposes many such cross-layer approaches for various purposes, e.g., performance, quality of service (QoS), memory protection, programmability, security. For example, Whirlpool <ref type="bibr" target="#b0">[1]</ref> identifies and communicates regions of memory that have similar properties (i.e., data structures) in the program to the hardware, where it is used to more intelligently place data in a non-uniform cache architecture (NUCA) system. RADAR <ref type="bibr" target="#b1">[2]</ref> and EvictMe <ref type="bibr" target="#b2">[3]</ref> communicate which data blocks will no longer be used in the program, such that cache policies can evict them. These are just a few examples in an increasingly large space of crosslayer techniques proposed in the form of hints implemented as new ISA instructions to aid cache replacement, prefetching, etc. <ref type="bibr" target="#b1">[2]</ref><ref type="bibr" target="#b2">[3]</ref><ref type="bibr" target="#b3">[4]</ref><ref type="bibr" target="#b4">[5]</ref><ref type="bibr" target="#b5">[6]</ref><ref type="bibr" target="#b6">[7]</ref><ref type="bibr" target="#b7">[8]</ref><ref type="bibr" target="#b8">[9]</ref><ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref>, program annotations/directives to convey program semantics <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref><ref type="bibr" target="#b16">[17]</ref>, or interfaces to communicate an application's QoS requirements for efficient partitioning and prioritization of shared hardware resources <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref>.</p><p>While cross-layer approaches have been demonstrated to be highly effective, such proposals are challenging to evaluate on real hardware as they require cross-layer changes to the hardware, operating system (OS), the instruction-set architecture (ISA), and application software. Existing open-source infrastructure for implementing cross-layer techniques in real hardware include PARD <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref> for QoS and Cheri <ref type="bibr" target="#b19">[20]</ref> for fine-grained memory protection and security. Unfortunately, these open-source infrastructures are not designed to provide key features required for performance optimizations: (i) rich dynamic hardware-software interfaces, (ii) low-overhead metadata management, and (iii) interfaces to numerous hardware components such as prefetchers, caches, etc.</p><p>In this work, we introduce MetaSys (Metadata Management System for Cross-Layer Performance Optimization), a full-system FPGA-based infrastructure, with a prototype in the Rocket RISC-V core <ref type="bibr" target="#b20">[21]</ref>, to enable rapid implementation and evaluation of diverse cross-layer techniques in real hardware. MetaSys comprises three key components: (1) A rich hardware-software interface to communicate a general and extensible set of application information (metadata) to the hardware architecture at runtime. The metadata that can be communicated with this interface include memory access pattern information for prefetching, data reuse information for cache management, address bounds for hardware bounds checking, etc. The interface is implemented as new instructions in the RISC-V ISA and is wrapped with easy-to-use software library abstractions. (2) Metadata management support in the OS and hardware to save the communicated metadata. Hardware components performing optimizations can then efficiently query for the metadata. We use a tagged memory-based design for metadata management where each memory address is tagged with an ID. This ID points to metadata that describes the data contained in the memory address location. (3) Modularized components to quickly implement various cross-layer optimizations with interfaces to the metadata management support, OS, core, and memory system.</p><p>Compared to the closest prior-work, XMem <ref type="bibr" target="#b21">[22]</ref>, MetaSys uses a similar tagged memory-based metadata management system. MetaSys however offers two key benefits over XMem: First, MetaSys offers a richer interface that communicates a flexible amount of metadata at runtime, rather than being limited to statically available program information. This enables a wider set of use cases and more powerful cross-layer techniques (as explained in §3.8). Second, MetaSys has a more optimized system design that is designed to be lightweight in terms of the hardware complexity and changes to the ISA, without sacrificing versatility ( §3.8). MetaSys incurs only a small area overhead of 0.02% (including 17KB of additional SRAM), 0.2% memory overhead in DRAM, and adds only 8 new instructions to the RISC-V ISA. Furthermore, XMem is not an open-source infrastructure and was not implemented nor evaluated in real hardware with full-system support.</p><p>Use cases. Cross-layer techniques that can be implemented with MetaSys include performance optimizations such as cache management, prefetching, memory scheduling, data compression, and data placement; cross-layer techniques for QoS; and lightweight techniques for memory protection (see §7). To demonstrate the versatility and ease-of-use of MetaSys in implementing new cross-layer techniques, we implement and evaluate three hardware-software cooperative techniques: (i) prefetching for graph analytics applications; (ii) bounds checking in memory unsafe languages, and (iii) return address protection in stack frames. These techniques were quick to implement with MetaSys, each only requiring an additional ~100 lines of Chisel <ref type="bibr" target="#b22">[23]</ref> code. In comparison, the hardware components of MetaSys required ~1800 lines of code.</p><p>Characterizing a general metadata management system. Using MetaSys, we perform the first detailed experimental characterization and limit study of the performance overheads of using a single common metadata management system to enable multiple diverse cross-layer techniques in a general-purpose processor. We make the following new observations from our characterization across 24 applications and 4 microbenchmarks that were designed to stress MetaSys.</p><p>First, the performance overheads from the cross-layer interface and metadata system itself are on average very low (2.7% on average, up to 27% for the most intensive microbenchmark). Second, there is no performance loss from supporting multiple techniques that simultaneously query the shared metadata system. This indicates that the system can be designed to be a scalable substrate. Third, the most critical factor in determining the performance overhead is the fundamental spatial and temporal locality in the accesses to the metadata itself. This determines the effectiveness of the metadata caches and the additional memory accesses to retrieve metadata. Finally, an important previously unidentified factor in performance overhead is the additional TLB misses from the required address translation when metadata is retrieved from memory.</p><p>Conclusions from characterization. From our detailed characterization and implemented use cases on real hardware, we make the following conclusions: Using a single general metadata management system is a promising low-overhead approach to implement multiple cross-layer techniques in future general-purpose processors. The significance of using a single framework is in enabling a wide range of cross-layer techniques with a single change to the hardware-software interface <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b21">22]</ref> and consolidating common metadata management support; thus, making the adoption of new cross-layer techniques in future processors significantly easier. We demonstrate that a common framework can simultaneously and scalably support multiple optimizations. For our implemented use cases, we observe low performance overheads from using the general MetaSys system: 0.2% for prefetching, 14% for bounds checking, and 1.2% for return address protection.</p><p>This work makes the following major contributions. • We introduce MetaSys, the first full-system open-source FPGA-based infrastructure, with a prototype in a RISC-V core, of a lightweight metadata management system with a rich hardware-software interface that can be used to implement a diverse set of cross-layer techniques. MetaSys provides the required support in the hardware, OS, and the ISA to enable quick implementation and evaluation of new hardwaresoftware cooperative techniques in real hardware.</p><p>• MetaSys comprises a new expressive hardware-software interface with a streamlined system design that enables a richer set of cross-layer optimizations than prior work.</p><p>• We present the first detailed experimental characterization of the performance and area overheads of a general hardwaresoftware interface and lightweight metadata management system designed to enable multiple and diverse cross-layer performance optimizations. We identify key sources of inefficiencies and bottlenecks of a general metadata system on real hardware, and we demonstrate its effectiveness as a common substrate for enabling cross-layer techniques in CPUs.</p><p>• We demonstrate the versatility and ease-of-use of the Meta-Sys infrastructure by implementing and evaluating three hardware-software cooperative techniques: (i) prefetching for graph analytics applications; (ii) efficient bounds checking for memory-unsafe languages; and (iii) return address protection for stack frames. We highlight other use cases that can be implemented with MetaSys.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Background and Related Work</head><p>Hardware-software cooperative techniques in CPUs. Cross-layer performance optimizations communicate additional information across the application-system boundary and we refer to this information as metadata. Metadata that is typically useful for performance optimization include program properties such as access patterns, read-write characteristics, data locality/reuse, data types/layouts, data "hotness", and working set size. This metadata enables more intelligent hardware/system optimizations such as cache management, data placement, thread scheduling, memory scheduling, data compression, and approximation <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b23">24]</ref>. For QoS optimizations, metadata includes application priorities and prioritization rules for allocation of resources such as memory bandwidth and cache space <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref>. Memory safety optimizations may communicate base/bounds addresses of data structures <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b25">26]</ref>.</p><p>A general framework is a promising approach as it enables many cross-layer techniques with a single change to the hardware-software interface and enables reusing the metadata management support across multiple optimizations. Such systems were recently proposed for performance <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b23">24]</ref>, memory protection and security <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b24">25]</ref>, and QoS <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref>.</p><p>A general framework to support a wide range of cross-layer optimizations-specifically for performance-requires: (i) a rich and dynamic hardware-software interface to communicate a diverse set of metadata at runtime and (ii) lightweight and low-overhead metadata management <ref type="bibr" target="#b21">[22]</ref>. Even small overheads imposed as a result of the system's generality may overshadow the performance benefits of a cross-layer technique. General metadata systems may also impose significant complexity, performance, and power overheads to the processor. While prior work has demonstrated the significant benefits of cross-layer approaches, no previous work has characterized the efficiency and capacity limits of a general metadata system for cross-layer optimizations in CPUs.</p><p>Tagged architectures. MetaSys is inspired by the metadata management and interfaces proposed in XMem <ref type="bibr" target="#b21">[22]</ref> and the large body of work on tagged memory <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b26">[27]</ref><ref type="bibr" target="#b27">[28]</ref><ref type="bibr" target="#b28">[29]</ref><ref type="bibr" target="#b29">[30]</ref> and capability-based systems <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b30">[31]</ref><ref type="bibr" target="#b31">[32]</ref><ref type="bibr" target="#b32">[33]</ref>. We qualitatively compare against the closest work, XMem, in §3.8 and quantitatively in §5. Unlike all above works, our goal is to provide an open-source framework to implement and evaluate cross-layer approaches in real hardware and to perform a characterization of such metadata systems for performance optimizations.</p><p>Infrastructure for evaluating cross-layer techniques. Evaluating the overheads and feasibility of a newly-proposed cross-layer technique is non-trivial. Fully characterizing the performance and area overheads either with a full-system cycle-accurate simulator or an FPGA implementation requires implementing: (i) Hardware support to implement the mechanism; (ii) OS support for OS-based cross-layer optimizations and to characterize the context-switch and system overheads of saving and handling a process' metadata; and (iii) Compiler support and ISA modifications to add and recognize new instructions to communicate metadata.</p><p>Recent works propose general systems that are designed to enable cross-layer techniques for QoS (PARD <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref>) or finegrained memory protection and security (Cheri <ref type="bibr" target="#b19">[20]</ref>). PARD enables tagging of components and applications with IDs that are propagated with memory requests and enforce QoS requirements in hardware. Cheri <ref type="bibr" target="#b19">[20]</ref> is a capability-based system that provides hardware support and ISA extensions to enable fine-grained memory protection. Neither system supports the (i) communication of diverse metadata at runtime, (ii) flexible granularity tagging of memory to enable efficient metadata lookups from multiple components, or (iii) interfaces to numerous hardware components such as the prefetcher, caches, etc., needed for performance optimization.</p><p>Our Goal. Our goal in this work is twofold. First, we aim to develop an efficient and flexible open-source framework that enables rapid implementation of new cross-layer techniques to evaluate the associated overheads performance, area, and power overheads, and thus their feasibility, in real hardware.</p><p>Second, we aim to perform the first detailed limit study to characterize and experimentally quantify the overheads associated with general metadata systems to determine their practicality for performance optimization in future CPUs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">MetaSys: Enabling and evaluating crosslayer optimizations</head><p>To this end, we develop MetaSys (Metadata Management System for Cross-Layer Performance Optimization), an opensource full-system FPGA-based infrastructure to implement and evaluate new cross-layer techniques in real hardware. MetaSys includes: (i) a rich hardware-software interface to dynamically communicate a flexible amount of metadata at runtime from the application to the hardware, using new RISC-V instructions; (ii) a tagged memory-based <ref type="bibr" target="#b26">[27]</ref><ref type="bibr" target="#b27">[28]</ref><ref type="bibr" target="#b28">[29]</ref><ref type="bibr" target="#b29">[30]</ref> implementation of metadata management in the system and OS; and (iii) flexible modules to add new hardware optimizations with interfaces to the metadata, core, memory, and OS. We build a prototype of MetaSys in the RISC-V Rocket <ref type="bibr" target="#b20">[21]</ref> core.</p><p>We choose an FGPA implementation as opposed to a fullsystem simulator as: (i) This enables focus on feasibility as all components need to be fully implemented (e.g., ports, wires, buffers) and its impact on area, cycle time, power, and scalability is quickly visible. (ii) FPGAs are much faster, running full application simulations in a few minutes/hours as opposed to many days on a full-system simulator, making it a better fit for quick experimentation. (iii) The RTL generated can be used for more accurate area and power calculation.</p><p>Fig. <ref type="figure" target="#fig_0">1</ref> depicts an overview of the major hardware components in MetaSys and their operation: The metadata lookup unit , the mapping management unit , and the optimization component .  3.1. Tagged memory-based metadata management Similar to prior systems for taint-tracking, security, and performance optimization, MetaSys implements tagged memory-based <ref type="bibr" target="#b26">[27]</ref><ref type="bibr" target="#b27">[28]</ref><ref type="bibr" target="#b28">[29]</ref><ref type="bibr" target="#b29">[30]</ref> metadata management. MetaSys associates metadata with memory address ranges of any size by tagging each memory address with an 8-bit (configurable) ID or tag. Each tag is a unique pointer to metadata that describes the data at the memory address. Hardware optimizations (e.g., in the cache, memory controller, or core) can query for the tag associated with any memory address and the metadata associated with the tag.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TLB</head><p>The mapping between each memory address and the corresponding ID is saved in a table in memory referred to as Metadata Mapping Table (MMT): in Fig. <ref type="figure" target="#fig_0">1</ref>. This table is allocated by the OS for each process and is saved in memory. In MetaSys (similar to XMem <ref type="bibr" target="#b21">[22]</ref> and Cheri <ref type="bibr" target="#b19">[20]</ref>), we tag physical addresses. As a result, any virtual address has to be translated before indexing the MMT to retrieve the tag ID. To enable fast retrieval of IDs, we implement a cache for the MMT in hardware that stores frequently accessed mappings, referred to as the Metadata Mapping Cache (MMC) . MMC misses lead to memory accesses to retrieve mappings from the MMT in memory. MetaSys can be configured to tag memory at flexible granularities. In §9.1, we evaluate the performance impact of the tagging granularity. The size of the MMT depends on the tagging granularity. For a 512B mapping granularity, the MMT requires 0.2% of physical memory (16MB in a 8GB system). The MMC holds 128 entries, where each entry stores a physical-address-to-tag mapping, and is 608B in size (8 bit entry and 30 bit tag).</p><p>The actual metadata associated with any ID is saved in special SRAM caches that are private to each hardware component or optimization. For example, the prefetcher would separately save access pattern information, while a hardware bounds checker would privately save bounds information. We refer to these stores as Private Metadata Tables (PMTs) . The PMTs are saved near each component (private to each component) and are loaded/updated by MetaSys. The meta-data (e.g., locality/"hotness") is encoded such that it can be directly interpreted by the component, e.g., prefetcher.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">The Hardware-Software Interface</head><p>Communicating application information with MetaSys requires (i) associating memory address ranges with a tag or ID of configurable bit width (8 bits by default) and (ii) associating each ID with the relevant metadata. The metadata could include program properties that describe the memory range, such as data locality/reuse, access patterns, read-write characteristics, data "hotness", and data types/layouts. We use two operators (described below) that can be called in programs to dynamically communicate metadata.</p><p>To associate memory address ranges with an ID, we provide the MAP/UNMAP interface (similar to XMem <ref type="bibr" target="#b21">[22]</ref>). MAP and UNMAP are implemented as new RISC-V instructions that are interpreted by the MetaSys hardware support to map a range of memory addresses (from a given virtual address up to a certain length) to the provided ID. These mappings are saved by the hardware in the MMT. We also implement 2D and 3D versions of MAP to efficiently map 2/3-dimensional address ranges in a multi-dimensional data structure with a single instruction.</p><p>To associate each ID with metadata, we provide the CREATE interface. CREATE takes 3 inputs from the application: the tag ID, the 8-bit ID for the hardware component (i.e., prefetcher, bounds checker, etc., called Module ID), and 512B of metadata. CREATE directly populates the PMT of the appropriate hardware component with the 512 bytes (or less) of metadata. All CREATE and MAP instructions are associated with the next load/store instruction in program order to avoid inaccuracies due to out-of-order execution. In other words, an implicit dependence is created in hardware between these instructions and the next load/store, and they are committed together.</p><p>Table <ref type="table" target="#tab_1">1</ref> lists the new instructions along with their arguments. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Metadata Lookup</head><p>Each optimization component is triggered by a hardware event (e.g., a cache miss). It then retrieves the physical address from the TLB and queries the MMC with the physical address to retrieve the associated tag ID. On a miss in the MMC, the mapping is retrieved from the MMT in memory. The optimization component uses the retrieved tag ID to obtain the appropriate metadata from the PMT. The optimization module is designed to flexibly implement a wide range of use cases and can be designed based on the optimization in question. This module has the required interfaces to the prefetcher, caches, memory controller, and TLBs to make this easier.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">Operating System Support</head><p>We add OS support for metadata management in the RISC-V proxy kernel <ref type="bibr" target="#b33">[34]</ref>, which can be booted on our Rocket RISC-V prototype. This includes support to manage the MMT in memory and flush the PMTs during a context switch. If the OS changes the virtual to physical address mapping of a page, then to ensure consistency of the metadata, the MMT is updated by the OS to reflect the correct physical-addressto-tag-ID mapping and the corresponding MMC entries are invalidated. If the application changes metadata before a virtual address has a page mapping, the OS is forced to allocate a physical page to it. In addition, we also provide support to implement optimizations performed by the OS or with OS cooperation. MetaSys enables trapping into the OS to perform customized checks or optimizations (e.g., protection checks or altering virtual-to-physical mappings) based on specific hardware trigger events. We describe one such use case in §6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.">Coherence/Consistency of Metadata in Multicore</head><p>MetaSys can be flexibly extended to multicore processors. Metadata is maintained at a process-level, therefore, threads within the same process cannot have different metadata for the same data structure. The MMC is a per-core structure, while the Private Metadata Tables (PMTs) are per-component structures (e.g, at the memory controller, LLC, prefetcher). The two dynamic operators (CREATE and MAP) may cause challenges in coherence and consistency of metadata in multicore systems. CREATE directly updates metadata associated with the per-process tag ID, which is saved at the per-component PMTs. The PMTs are shared by all cores when the optimization component is also shared (and thus any updates by CREATE are automatically coherent). The PMTs for private components (e.g., L1 cache) are not coherent and can only be updated by the corresponding thread. MAP updates the address to tag ID mapping in the MMC, which is private to each core. To ensure coherence of the MMC mappings, a MAP update invalidates the corresponding MMC entry (if present) in other MMCs. If the use case requires consistency of the metadata, i.e., ordering between a CREATE/MAP instruction and when it is visible to other cores, barriers and fence instructions are used to enforce any required ordering between threads for updates to metadata.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6.">Timing Sensitivity of Metadata</head><p>MetaSys supports three modes: (i) Force stall, where the instruction triggering a metadata lookup cannot commit until the optimization completes (e.g., for security use cases); (ii) No stall, where metadata lookups do not stall the core but are always resolved (e.g., for page placement, cache replacement), and (iii) Best effort, where lookups may be dropped to minimize performance overheads (e.g., for prefetcher training).  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7.">Software Library</head><p>We develop a software library which can be included in user programs to facilitate the use of MetaSys primitives CREATE and MAP (summarized in Table <ref type="table" target="#tab_2">2</ref>). The library exposes three functions: (i) CREATE populates an entry indexed by the tag ID (TagID) in the PMT of a hardware optimization module (Mod-uleID) with the corresponding metadata; (ii) MAP updates the MMT by assigning tag IDs to memory addresses of the range (start, end); (iii) UNMAP resets the tag IDs of the corresponding address range in the MMT.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.8.">Comparison to the XMem [22] framework</head><p>MetaSys implements a tagged-memory-based system with a metadata cache similar to XMem <ref type="bibr" target="#b21">[22]</ref>. MetaSys however has three major benefits. First, MetaSys enables communicating metadata at runtime using a more powerful CREATE operator that is implemented as a new instruction. In XMem, metadata is communicated only statically at compile time (CREATE is hence a compiler pragma). MetaSys thus enables a wider set of optimizations including in memory safety, protection, prefetching, etc., and enables communicating metadata that is input-data dependent and metadata that can only be known at runtime (e.g., access patterns, data "hotness", etc.). MetaSys was designed to efficiently handle these dynamic metadata updates. Second, the dynamic and more expressive CREATE operator obviates the need for additional interfaces (ACTIVATE/DEACTIVATE) to track the validity of statically communicated metadata. This enables a more streamlined metadata system in MetaSys with fewer tables and lookups. Third, MetaSys allows the application programmer to directly select which cross-layer optimization to enable/disable and communicate metadata to, via the CREATE operator. XMem, on the other hand, does not allow control of hardware optimizations from the application. Table <ref type="table" target="#tab_3">3</ref> summarizes the operators and compares to the corresponding operators in XMem. Of the three evaluated use cases, only return address protection ( §6.2) can be implemented with XMem. Selects a hardware optimization, dynamically associates metadata with an ID, and communicates both to hardware at runtime (implemented as new instructions).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(UN)MAP</head><p>Associate memory ranges with tag IDs (implemented as new instructions).</p><p>Same semantics and implementation as XMem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(DE)ACTIVATE</head><p>Enable/disable optimizations associated with a tag ID (implemented as new instructions).</p><p>Removed as the same functionality can now be done with CREATE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.9.">FPGA-based infrastructure</head><p>We build a full system prototype of MetaSys on an FPGA with the Rocket <ref type="bibr" target="#b20">[21]</ref> RISC-V core and add the necessary support in the compiler, libraries, OS, ISA, and hardware. The modularized MetaSys components can also be ported to other RISC-V cores. We used the RoCC accelerator <ref type="bibr" target="#b20">[21]</ref> in the Rocket chip to implement the metadata management system. The RoCC is a customizable module that enables interfacing with the core and memory. The hardware support implemented in the ROCC comprises (i) the control logic to handle MAPs and CREATEs, (ii) control logic to perform metadata lookups by components that implement optimizations, and (iii) the SRAM metadata caches (MMC and PMTs). We extended the RISC-V ISA with 8 instructions (6 for MAP/CREATE and 2 for OS operations). To implement all the hardware modules of MetaSys, we modified/added 1781 lines of Chisel code in the Rocket Chip. As we demonstrate later, since the Meta-Sys hardware modules can be flexibly reused across multiple hardware-software optimizations, the techniques in our use cases only required 87-103 additional lines of Chisel code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.10.">Implementing a hardware-software cooperative technique with MetaSys</head><p>To implement a new hardware technique with the baseline MetaSys code, we provide a flexible module ( in Fig. <ref type="figure" target="#fig_2">2</ref>) with a PMT and interfaces to the metadata lookup unit, to the core (to receive triggers), and templated interfaces to the cache controller, memory controller, etc. The interface to the lookup unit provides dynamic access to the metadata communicated by the CREATE and MAP operators. The interfaces to the core and the memory system can be used as trigger events for optimization and lookups (e.g., a cache miss). The different components within the MetaSys logic itself (i.e., the metadata caches, logic to access the Metadata Mapping Table in memory, and the lookup logic) can be flexibly reconfigured.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.11.">Dynamically-typed or managed languages</head><p>MetaSys relies heavily on function calls/libraries that abstract away low level details that call the MetaSys instructions even in C/C++. With managed and dynamically-typed languages, the additional metadata associated with data structures/objects would be provided by the user with additional class/object member functions. The metadata could also be directly embedded within object/class definitions (e.g., a list or map in Python would by definition have certain access properties). Other properties (e.g., data types) would be provided by the interpreter (in the case of dynamically-typed languages) and the mapping/remapping calls to memory addresses would be handled by the runtime during memory (de)allocation. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Methodology</head><p>Baseline system. We use the in-order Rocket core <ref type="bibr" target="#b20">[21]</ref> as the baseline CPU and conduct our experiments on the Zed-Board Zynq-7000 <ref type="bibr" target="#b34">[35]</ref> FPGA board. 1 Since DRAM is disproportionately faster than the CPU clock rate possible on FPGAs, we added logic in the memory controller to proportionately scale the rate at which memory requests are issued. The resulting average memory latency and bandwidth in core cycles were validated with microbenchmarks against a real CPU.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Use Case 1: HW-SW Cooperative Prefetching</head><p>Hardware-software cooperative prefetching techniques have been widely proposed to handle challenging access patterns such as in graph processing <ref type="bibr" target="#b37">[38]</ref><ref type="bibr" target="#b38">[39]</ref><ref type="bibr" target="#b39">[40]</ref><ref type="bibr" target="#b40">[41]</ref><ref type="bibr" target="#b41">[42]</ref><ref type="bibr" target="#b42">[43]</ref><ref type="bibr" target="#b43">[44]</ref><ref type="bibr" target="#b44">[45]</ref>, pointer-chasing <ref type="bibr" target="#b45">[46]</ref><ref type="bibr" target="#b46">[47]</ref><ref type="bibr" target="#b47">[48]</ref><ref type="bibr" target="#b48">[49]</ref>, linear algebra computation <ref type="bibr" target="#b49">[50]</ref> and other applications <ref type="bibr" target="#b50">[51]</ref><ref type="bibr" target="#b51">[52]</ref><ref type="bibr" target="#b52">[53]</ref><ref type="bibr" target="#b53">[54]</ref>. In this section, we demonstrate how MetaSys can be flexibly used to implement and evaluate such prefetching techniques. We design a new prefetcher for graph applications that leverages knowledge of the semantics of graph data structures using MetaSys. Graph applications typically involve irregular pointer-chasing-based memory access patterns. The data-dependent non-sequential accesses in these works are challenging for traditional heuristic-based hardware prefetchers, e.g., stride <ref type="bibr" target="#b54">[55]</ref> and stream <ref type="bibr" target="#b55">[56]</ref>, or even sophisticated prefetchers that rely on repeated patterns <ref type="bibr" target="#b56">[57]</ref><ref type="bibr" target="#b57">[58]</ref><ref type="bibr" target="#b58">[59]</ref>.</p><p>To implement the hardware support for our prefetcher, we only needed to add 87 lines of Chisel code to the baseline MetaSys codebase, all within the provided module for new optimization components. 5.1 Hardware-Software Cooperative Prefetching for Graph Analytics with MetaSys. Vertex-centric graph analytics typically involves first traversing a work list containing vertices to be visited ( in Fig. <ref type="figure" target="#fig_3">3</ref>). For each vertex, the vertex list is indexed to retrieve the neighboring vertex IDs from the edge list . To perform computation on the graph, the application then operates on the data properties of these neighboring vertices (retrieved from the property list ). Graph processing thus involves a series of memory accesses that depend on the contents of the work, vertex and edge lists. In this use case, we design a prefetcher that can interpret the contents of each of the above data structures and appropriately compute the next data-dependent memory address to prefetch.</p><p>To capture the required application information for each data structure, we use MetaSys's CREATE interface to communicate the following metadata (i) base address of the data structure that is indexed using the current data structure's contents (64 bits); (ii) base address of the current data structure (64 bits); (iii) data type (32 bits) and size (32 bits) to determine the index of the next access; and (iv) the prefetching stride (6 bits). MAP then associates the memory address range of each data structure with the appropriate tag.</p><p>We then design a hardware prefetcher that: (i) snoops every memory request from the core and retrieves the associated tag ID using MetaSys; (ii) queries the Private Metadata Table to retrieve the communicated metadata (listed above); and (iii) directly interprets the metadata to compute the data-dependent memory address of the data that is indexed by the current memory address content. In Fig. <ref type="figure" target="#fig_3">3</ref>, when the prefetcher sees a memory request to the work list at index 0, it looks ahead (depending on the prefetching stride) to retrieve the contents of the work list at index 1. At this point, it also prefetches the contents of the vertex, edge, and property lists based on the computed index at each level. In graph applications where the work list is ordered, the prefetcher is configured to simply stream through the contents of the vertex and edge lists to prefetch the data dependent memory locations in the property list. The prefetcher can hence be flexibly programmed based on the specific properties associated with any data structure, algorithm, as well as the desired aggressiveness of prefetcher. 5.2 Evaluation and Methodology. We evaluate the MetaSysbased prefetcher using 8 graph workloads from the Ligra framework <ref type="bibr" target="#b35">[36]</ref> using the Rocket-based prototype of MetaSys with the system parameters listed in Table <ref type="table" target="#tab_4">4</ref>. We evaluate three configurations: (i) the baseline system with a hardware stride prefetcher <ref type="bibr" target="#b59">[60]</ref>; (ii) GraphPref, a customized hardware prefetcher that implements the same idea described above without the generalized MetaSys support; and (iii) the MetaSysbased graph prefetcher. Fig. <ref type="figure" target="#fig_4">4</ref> depicts the corresponding speedups, normalized to the baseline. We observe that the MetaSys graph prefetcher improves performance by 11.2% on average (up to 14.3%) over the baseline by accurately prefetching data-dependent memory accesses. It also significantly outperforms the stride prefetcher which is unable to capture the irregular access patterns in graph workloads. Compared to a similar prefetcher implemented as customized hardware, GraphPref, the MetaSys-based prefetcher performs almost as well: within 0.2% on average (only up to 0.8% for BFS). We conclude that MetaSys can be used to flexibly implement and evaluate hardware-software cooperative techniques for prefetching by leveraging MetaSys's metadata support and interfaces, incurring only small overheads from MetaSys's general metadata management.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Use Case 2: Memory Safety and Protection</head><p>We describe two hardware-software cooperative mechanisms for memory safety/protection that can be directly implemented with MetaSys. To implement both use cases, we only add 103 lines of Chisel code to the baseline MetaSys code, all within the provided module for new optimization components.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Hardware Bounds Checking</head><p>Unmanaged languages such as C/C++ provide great flexibility in memory management but an important challenge with these languages is memory safety. The pointer casting and pointer arithmetic supported by these languages allow buffer overflows and potentially hazardous writes to arbitrary memory locations. Prior work has demonstrated a range of software approaches <ref type="bibr" target="#b60">[61]</ref><ref type="bibr" target="#b61">[62]</ref><ref type="bibr" target="#b62">[63]</ref><ref type="bibr" target="#b63">[64]</ref><ref type="bibr" target="#b64">[65]</ref><ref type="bibr" target="#b65">[66]</ref><ref type="bibr" target="#b66">[67]</ref><ref type="bibr" target="#b67">[68]</ref><ref type="bibr" target="#b68">[69]</ref><ref type="bibr" target="#b69">[70]</ref><ref type="bibr" target="#b70">[71]</ref><ref type="bibr" target="#b71">[72]</ref><ref type="bibr" target="#b72">[73]</ref><ref type="bibr" target="#b73">[74]</ref><ref type="bibr" target="#b74">[75]</ref> to increase memory safety in the form of static or dynamic checks, such as CCured <ref type="bibr" target="#b62">[63]</ref>, Cyclone <ref type="bibr" target="#b66">[67]</ref>, and Softbound <ref type="bibr" target="#b68">[69]</ref>. These approaches are however known to incur significant runtime overheads in perform-ing numerous checks in software <ref type="bibr" target="#b75">[76]</ref>. Hardware-based approaches offer a promising opportunity to alleviate these overheads. Prior work <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b76">[77]</ref><ref type="bibr" target="#b77">[78]</ref><ref type="bibr" target="#b78">[79]</ref><ref type="bibr" target="#b79">[80]</ref><ref type="bibr" target="#b80">[81]</ref><ref type="bibr" target="#b81">[82]</ref> including HardBound <ref type="bibr" target="#b25">[26]</ref>, ShaktiT <ref type="bibr" target="#b81">[82]</ref> and Cheri <ref type="bibr" target="#b19">[20]</ref> investigate enabling hardwaresoftware cooperative bounds checking. These approaches however require architectures that are entirely specialized for bounds checking <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b76">77,</ref><ref type="bibr" target="#b81">82]</ref> or more heavyweight metadata management systems tailored for memory security and protection <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b77">[78]</ref><ref type="bibr" target="#b78">[79]</ref><ref type="bibr" target="#b79">[80]</ref><ref type="bibr" target="#b80">[81]</ref>. In this section, we demonstrate how MetaSys can be used to implement hardware-based bounds checking in a lightweight and general metadata system. 6.1.1. Implementing bounds checking with MetaSys. To implement bounds checking with MetaSys, we use the MAP operator to tag each data structure to be protected with a unique ID. For dynamically allocated nodes (which may not be contiguously located), each node is tagged with the same ID as other nodes in the same data structure. Every memory access in the program then needs to then be verified in hardware to be going to the correct data structure. To do this, we add the CREATE operator before every load or store to a protected data structure. The CREATE operator in this case only communicates the tag ID of the desired data structure. These instructions are added using software libraries for pointers. In hardware, we simply check whether there is a match between CREATE's tag ID and the ID of the load/store address that follows the CREATE instruction. To perform this check, we perform a lookup to the Metadata Management Cache to retrieve the associated tag ID. On a mismatch, using its interface to the OS, MetaSys terminates the program. 6.1.2. Methodology and Evaluation. We evaluate MetaSysbased bounds checking on our prototype with the parameters listed in Table <ref type="table" target="#tab_4">4</ref> (tagging granularity is set to 64B). We use the Olden <ref type="bibr" target="#b82">[83]</ref> benchmarks (commonly used for bounds checking and stack protection research <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b68">69,</ref><ref type="bibr" target="#b74">75,</ref><ref type="bibr" target="#b83">84]</ref> due to its focus on pointer-based data structures) for both use cases.</p><p>We evaluate 3 designs: (i) the Baseline system without Meta-Sys; (ii) software bounds checking, based on prior work <ref type="bibr" target="#b60">[61]</ref>; and (iii) MetaSys-based bounds checking. Fig. <ref type="figure" target="#fig_5">5</ref> depicts the execution time normalized to the Baseline. We observe that on average the software bounds checking design incurs a significantly high overhead of 36% (up to 82%). This overhead comes from executing more instructions to check bounds (64% on average). In contrast, MetaSys-based bounds checking only incurs a 14% overhead on average (up to 40%). MetaSys only requires a 32% increase in the number of executed instructions. Workloads such as em3d, power, and mst, are highly compute intensive and hence do not incur significant overheads with either bounds checking technique.</p><p>We conclude that MetaSys provides a lightweight substrate to implement and evaluate hardware-software cooperative bounds checking. MetaSys can be flexibly extended to implement more sophisticated memory protection techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Return Address Protection</head><p>The program's call stack is a known source of many security vulnerabilities in low-level, memory-unsafe languages such as C/C++. For example, the control flow in the program can be hijacked by overwriting the return addresses saved in the stack. Existing defenses such as ExecShield <ref type="bibr" target="#b84">[85]</ref>   stack canaries <ref type="bibr" target="#b85">[86]</ref> do not protect against sophisticated attack techniques <ref type="bibr" target="#b86">[87]</ref><ref type="bibr" target="#b87">[88]</ref><ref type="bibr" target="#b88">[89]</ref>. Stack canary protection is a software check that involves writing an additional randomly generated value in the stack and a duplicate is saved separately in memory. This value in the stack is checked against the duplicate to detect stack overwriting by the canary code before returning to the saved return address. Protecting return addresses with more powerful software checks <ref type="bibr" target="#b89">[90]</ref><ref type="bibr" target="#b90">[91]</ref><ref type="bibr" target="#b91">[92]</ref><ref type="bibr" target="#b92">[93]</ref><ref type="bibr" target="#b93">[94]</ref> incurs significant runtime overheads and are hence difficult to use in practice <ref type="bibr" target="#b75">[76,</ref><ref type="bibr" target="#b94">95]</ref>. Prior work has proposed a range of hardware techniques <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b95">[96]</ref><ref type="bibr" target="#b96">[97]</ref><ref type="bibr" target="#b97">[98]</ref><ref type="bibr" target="#b98">[99]</ref> to enable return address protection more efficiently. These approaches however require dedicated hardware support for stack protection (e.g., RAGuard <ref type="bibr" target="#b95">[96]</ref>, PAC-it-up <ref type="bibr" target="#b96">[97]</ref>, CET <ref type="bibr" target="#b98">[99]</ref>) or more heavy-weight metadata systems for memory protection (e.g., SDMP <ref type="bibr" target="#b97">[98]</ref>, Cheri <ref type="bibr" target="#b19">[20]</ref>, PUMP <ref type="bibr" target="#b24">[25]</ref>). In this section, we implement and evaluate return address protection with MetaSys's lightweight metadata support and cross-layer interfaces. 6.2.1. Return address protection with MetaSys. To enable return address protection with MetaSys, we first tag each return address using MAP as id="1". In hardware, we add support to simply disallow writes to any address tagged with id="1". The application can then unmap the return address when it is retrieved again from the stack. This ensures that once a memory location within the stack has a return address saved, it cannot be overwritten via attacks that hijack control flow such as buffer overflow attacks. To check in hardware whether any memory address is tagged as "1" (i.e., contains a return address), we simply issue a lookup to the Metadata Mapping Cache. Any store to a tagged memory address causes the hardware to invoke the OS to terminate the program. 6.2.2. Evaluation and Methodology. We evaluate MetaSysbased return address protection using our FPGA prototype with system parameters listed in Table <ref type="table" target="#tab_4">4</ref> (the tagging granularity set to 64B). We evaluate 3 designs using the Olden <ref type="bibr" target="#b82">[83]</ref> benchmarks: (i) the Baseline system with no overheads; (ii) canary <ref type="bibr" target="#b85">[86]</ref> stack protection in the GCC RISC-V compiler; and (iii) MetaSys-based return address protection. Fig. <ref type="figure" target="#fig_6">6</ref> depicts the execution time normalized to the Baseline. We observe that the canary approach incurs a performance overhead of 5.5% (up to 20%), while MetaSys incurs a diminished overhead of 1.2% (up to 6.2%). The major overheads for the stack canaries come from executing extra instructions (5.5% on average) to perform software checks. The overheads for MetaSys are low due to the high MMC hit rate which leads to few additional memory accesses. In addition to providing less overhead, MetaSys-based return address protection can also protect against more sophisticated attacks that exploit write-what-where <ref type="bibr" target="#b99">[100]</ref> gadgets and, unlike canaries, is immune to information leaks <ref type="bibr" target="#b100">[101]</ref>. Protecting additional memory locations beyond return addresses (e.g., function pointers) with software approaches would incur even higher instruc-  tion overhead. However, the above MetaSys overheads would largely remain the same as it already involves checking each store.</p><p>We conclude that MetaSys enables easy implementation and evaluation of lightweight memory protection mechanisms using the provided interfaces and metadata management with low performance overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Other Use Cases of MetaSys</head><p>We briefly discuss other cross-layer techniques that can be implemented with MetaSys (but would be challenging to implement with XMem).</p><p>Performance optimization techniques. MetaSys provides a low-overhead framework and a rich cross-layer interface to implement a diverse set of performance optimizations including cache management, prefetching, page placement in memory, approximation, data compression, DRAM cache management, and memory management in NUMA and NUCA systems. MetaSys can flexibly implement the range of crosslayer optimizations supported by XMem <ref type="bibr" target="#b21">[22]</ref>. MetaSys's dynamic interface for metadata communication enables even more powerful optimizations than XMem including memory optimizations for dynamic data structures such as graphs.</p><p>Techniques to enforce cross-layer quality of service (QoS). MetaSys can be used to implement cross-layer techniques to enforce QoS requirements of applications in shared environments <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b101">102,</ref><ref type="bibr" target="#b102">103]</ref>. MetaSys allows communicating an applications' QoS requirements to hardware components (e.g., the last-level cache, memory controllers) to enable optimizations for partitioning and allocating shared resources such as the cache and memory bandwidth.</p><p>Hardware support for debugging and monitoring. MetaSys can be used to implement cross-layer techniques for performance debugging and bug detection by providing efficient mechanisms to track memory access patterns using the memory tagging and metadata lookup support. This includes efficient detection of memory safety violations <ref type="bibr" target="#b80">[81,</ref><ref type="bibr" target="#b103">104]</ref> or concurrency bugs <ref type="bibr" target="#b104">[105]</ref><ref type="bibr" target="#b105">[106]</ref><ref type="bibr" target="#b106">[107]</ref><ref type="bibr" target="#b107">[108]</ref><ref type="bibr" target="#b108">[109]</ref><ref type="bibr" target="#b109">[110]</ref> such as data races, deadlocks, or atomicity violations.</p><p>Security and protection. MetaSys provides a substrate to implement low-overhead hardware techniques for security/protection: the tagged memory support can be used to implement protection for spatial memory safety <ref type="bibr" target="#b79">[80]</ref>, cache timing side-channels <ref type="bibr" target="#b110">[111]</ref> and stack protection <ref type="bibr" target="#b97">[98]</ref>. For example, using MetaSys, software can tag memory accesses as security-critical or safe. Based on the metadata received for every access, MetaSys can activate/deactivate (for the specific access) the corresponding side-channel defense technique at runtime (e.g., protect from/undo speculation <ref type="bibr" target="#b111">[112]</ref><ref type="bibr" target="#b112">[113]</ref><ref type="bibr" target="#b113">[114]</ref>). We demonstrate two security techniques in §6.</p><p>Garbage collection. MetaSys offers an efficient mechanism to track dead memory regions, unreachable objects, or young objects in managed languages. MetaSys is hence a natural substrate to implement hardware-software cooperative approaches (such as prior work <ref type="bibr" target="#b114">[115]</ref><ref type="bibr" target="#b115">[116]</ref><ref type="bibr" target="#b116">[117]</ref>) for garbage collection. For example, HAMM <ref type="bibr" target="#b114">[115]</ref>, a hardware-software technique for reference counting, tracks the number of references to any object in hardware. It has many of the same metadata management components as MetaSys. HAMM uses a multi-level metadata cache to manage the large amounts of metadata associated with reference counting for each object. MetaSys was designed with modular interfaces that enable adding more levels to the metadata cache for such use cases.</p><p>OS optimizations. MetaSys can be used to implement OS optimizations that require hardware performance monitoring of memory access patterns, contention, reuse, etc. The metadata support in MetaSys can used to implement this monitoring and then inform OS optimizations like thread scheduling, I/O scheduling, and page allocation/mapping.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Limitations of MetaSys</head><p>Our goal of providing a low-overhead and general system largely tailored for cross-layer performance optimization leads to two major limitations in MetaSys:</p><p>Instruction and register tagging. MetaSys does not currently support tagging of instructions or registers and thus cannot easily support techniques such as taint-tracking and security mechanisms that require rule-checking at the instruction/register level.</p><p>Fine-granularity memory tagging. While MetaSys supports memory tagging at flexible granularity, the system is optimized for the larger granularities typically required for performance optimization (&gt;=64B) or fine granularities for only some data (e.g., return addresses). Byte/word granularity tagging for the entire program data may lead to high MMC miss rates and may thus incur higher overheads with MetaSys.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Characterizing general metadata management systems for cross-layer optimizations</head><p>Our goal in this section is to perform a detailed characterization of the overheads of using a single common metadata system and interface for multiple cross-layer techniques. Three major challenges and sources of system overhead include:</p><p>(1) Handling dynamic metadata: Communicating metadata at runtime requires execution of additional instructions in the program. This incurs performance overheads in the form of CPU processing cycles and data movement to communicate the metadata to hardware components or to save them in memory.</p><p>(2) Efficient metadata management and lookups: The communicated metadata must be saved in memory or specialized caches (the MMC in MetaSys) that overflow to memory. Different components in the system must then be able to efficiently look up the metadata for performance optimization. Storing and retrieving metadata may incur expensive memory accesses and consume memory bandwidth.</p><p>(3) Scaling to multiple components: A general cross-layer interface and metadata system must be able to serve multiple client components implementing different optimizations in the caches, the prefetchers, the memory controller, etc. Multiple components accessing shared metadata support during program execution poses significant scalability challenges.</p><p>All the above challenges may impose significant area and performance overheads in the CPU making the feasibility of a common metadata system and interface (as opposed to per-use-case specialized interfaces and systems) for crosslayer techniques questionable. In this section, we set out to experimentally quantify these overheads and identify the key bottlenecks and insights on how these challenges affect different workloads and how they can be alleviated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.1.">Analysis</head><p>We perform our characterization using the Polybench <ref type="bibr" target="#b36">[37]</ref> and Ligra <ref type="bibr" target="#b35">[36]</ref> benchmark suites along with a set of microbenchmarks. Polybench contains building block kernels frequently used in linear algebra, scientific computation, and machine learning. Ligra contains widely used graph analytics workloads. The microbenchmarks are designed to intensely stress the MetaSys system and identify worst-case overheads.</p><p>• Stream. This memory-bandwidth-intensive microbenchmark streams through a large amount of data, accessing it only once. It hence has high spatial locality and no data reuse.</p><p>• Linked List Traversal. The microbenchmark mimics typical linked list creation, insertion, and traversal and emulates the widely-seen memory-intensive pointer-chasing operation.</p><p>• Random Access. This microbenchmark accesses memory locations within a large array at random indices and is designed to test the worst-case (and a largely unrealistic) scenario-no pattern in accesses, no reuse, and no spatial locality. • 3-dimensional array traversal (3D Array). This microbenchmark mimics the access pattern and locality seen in applications with multi-dimensional arrays. It traverses a 3D array first along the third dimension, and then along the second and first (data is contiguously placed in the first dimension). The access pattern is highly regular but with no spatial locality.</p><p>§4 describes the parameters of our baseline system. We summarize our key findings in §9. <ref type="bibr" target="#b2">3</ref>. In all evaluations in this section, since we aim to characterize the overheads of the system itself, we do not implement any cross-layer optimization that improves performance. We simply implement lookups to the metadata system that an optimization would make. Since our goal is to stress the system, we perform lookups for every memory access. In typical use cases, the lookup trigger would be less frequent, e.g., lookups on every cache miss for prefetching or on every store for return address protection. 9.1.1. Performance Overhead Analysis. The performance overheads in MetaSys come from two major sources: (i) the dynamic instructions (MAP and CREATE) and (ii) metadata lookups when a component retrieves the tag ID associated with any memory address (from the MMT, cached in the MMC) and then the corresponding metadata (in the PMT).  performing metadata lookups for every access to the L1 cache (All-Accesses) and (ii) when performing metadata lookups only on every L1 cache miss (Miss-Only). These studies were conducted with our baseline 128-entry MMC with a tagging granularity of 512B (as in XMem <ref type="bibr" target="#b21">[22]</ref>). Fig. <ref type="figure">9</ref> plots the corresponding MMC hit rates and Fig. <ref type="figure">8</ref> plots the number of memory accesses, normalized to baseline (the additional memory accesses come from misses in the MMC). We make two major observations from the figure. First, the overall overheads from the metadata management system for both designs are low in most workloads with an average overhead of 2.7% (ranging from ∼0% up to 14%), excluding the microbenchmarks. The highest overheads observed in the microbenchmarks is 27% for Random and represents the absolute worst-case overhead. Workloads with the highest overheads (Random, GS, PR, TF) are highly memory-intensive and have low spatial and temporal locality, which leads to low hit rates in the MMC (e.g., ∼0% in Random and 24% in GS). This causes a significant increase in accesses to memory and thus higher performance overheads.</p><p>Second, the number of metadata lookups has a minimal impact on the overall performance overhead. All-Access performs on average 75.2% more lookups than Miss-Only, but incurs an additional overhead of only 0.05%. Miss-Only has lower MMC hit rates due to lower locality in lookups than All-Access. Thus, the number of additional memory accesses is largely the same for both designs.</p><p>Since the major overheads are from additional memory accesses, we evaluate the impact of available memory bandwidth. Fig. <ref type="figure" target="#fig_0">10</ref> depicts the performance overhead of All-Access with 0.5× and 2× the memory bandwidth as the baseline system. We observe that, except for GS, more memory bandwidth significantly reduces any lookup overheads: the average overhead is only 0.5% with 2× the bandwidth. Conversely, in workloads with higher MMC miss rates (e.g, DSYR2K), the overheads increase with a reduction in available memory bandwidth. We conclude that (i) the performance overheads are directly correlated to the MMC hit rates; (ii) the metadata lookup hardware can be frequently queried with no direct observable impact on performance; and (iii) the overall performance overheads are minimal when the MMC provides high hit rates. 9.1.2. Effect of the Metadata Mapping Cache (MMC). In Fig. <ref type="figure" target="#fig_0">11</ref>, we evaluate the impact of the size of the MMC on performance overhead. We evaluate 6 sizes for All-Access and Fig. <ref type="figure" target="#fig_0">11</ref> presents the resulting execution time (normalized to the baseline system). We make two observations. First, in most workloads 128 entries is sufficient to obtain minimal overheads. This is because with a 512B tagging granularity, we can hold tag IDs for 64KB of memory in the MMC (compared to 16KB of L1 cache space). Second, workloads with poor spatial and temporal locality (e.g., Random, GS), are largely insensitive to the MMC sizes we evaluated. These overheads cannot hence be easily addressed by increasing its size. 9.1.3. Effect of Metadata Granularity. The granularity at which memory is tagged plays a critical role in determining the reach of the MMC. More MMC entries are needed when memory is tagged at small granularities to hold tag IDs for the same amount of memory, but enables more optimizations (e.g., bounds checking). Fig. <ref type="figure" target="#fig_2">12</ref> presents execution time for different granularities of tagging, normalized to the baseline system without MetaSys. For most workloads, even the smallest granularity we evaluated (64B) has a minimal impact on performance. High granularities minimize overheads for all but Random and GS by significantly increasing the MMC hit rate. A secondary effect in irregular workloads, such as PR and SSSP, is that low granularities increase the number of TLB misses (by 11% and 13% respectively), depicted in Fig. <ref type="figure" target="#fig_3">13</ref>. The additional MMC misses cause accesses to the Metadata Mapping Table in memory which requires address translation.</p><p>To evaluate the effect of the TLB, we implement a design which does not require address translation to access the MMT (i.e., it is addressed directly in physical memory). Fig. <ref type="figure" target="#fig_4">14</ref> presents the resulting normalized execution time without address translation. We observe a decrease in overhead with this design in the irregular workloads: BFS, CC, Random, and LL (by 1.9%, 1.8%, 14%, and 1% respectively). 9.1.4. Effect of Contention. To evaluate the scalability of the system with multiple components accessing the same metadata support, we evaluate the overheads of two components performing frequent metadata lookups: one component at every memory access (with the corresponding memory address) and another at every TLB miss (with the page table entry address). Since each design performs lookups with different memory addresses, they do not share entries in the MMC and this creates a worst-case scenario for the shared MMC.</p><p>Fig. <ref type="figure" target="#fig_9">15</ref> depicts the resulting execution time for both designs normalized to the baseline system. We observe that for all workloads except the microbenchmarks, increasing the number of client components only trivially impacts the performance overhead (on average the increase is 0.3%). This is because the MMC can sufficiently capture the tag ID working set for both components. The microbenchmarks designed to stress the system have a significant performance degradation (up to 60%) as a result of more misses in the MMC.</p><p>To investigate mechanisms to alleviate the contention overheads seen in the microbenchmarks we evaluate three designs in Fig. <ref type="figure" target="#fig_10">16:</ref> (i) Partitioning the MMC equally between the two clients; (ii) Prioritized Insertion, where we insert mappings for the client with better locality at a higher priority in the MMC (they are evicted last); and (iii) No stall, where we do not stall the core on an MMC miss (the optimization performed by the client will be delayed). We observe that Partitioning reduces the overhead for 3D Array and LL by 9% and 4% by avoiding cache thrashing. Prioritized Insertion helps reduce the overheads in LL (by 8.5%) and Random (by 6%), where one client has more locality than the other in lookups.  cantly reduces the overhead in Random (by 40%) by mitigating the latency overhead of additional memory accesses. We conclude that the metadata support is scalable to multiple components with no observable impact on performance overheads (except in microbenchmarks). The overheads seen in microbenchmarks are a result of poor MMC hit rates that can be mitigated via techniques such as partitioning, prioritized insertion, and by not stalling the core on an MMC miss. Since optimizations are triggered by loads/stores in MetaSys, it can be expected to scale to more than two clients as most clients will query the MMC with the same addresses, which are aggregated, and will not lead to more lookups.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.2.">Hardware Area Overhead</head><p>We synthesized the baseline MetaSys system using the Synopsys DC <ref type="bibr" target="#b117">[118]</ref> at 22nm process technology to estimate the area overhead. MetaSys incurs small area overhead: 0.03mm 2 (0.02% of a 22nm Intel CPU Core <ref type="bibr" target="#b118">[119]</ref>). 9.3. Summary of Findings (1) Despite stressing the metadata support, the overall overheads of the system are very low (2.7% on average, excluding the microbenchmarks). This indicates that using metadata systems that are general enough to support a range of use cases is a promising approach for cross-layer performance optimizations in real-world applications. The higher overheads seen in microbenchmarks indicate that the worst-case overheads are however substantially higher (up to 27%).</p><p>(2) Our studies indicate that the metadata management is scalable in supporting multiple client components that have high frequencies of querying. There was no observable impact of the number of queries, indicating that the same system can 0.9  support multiple cross-layer optimizations at the same time.</p><p>We proposed simple techniques to alleviate contention in the MMC from multiple clients.</p><p>(3) The most critical factor that impacted performance overhead was the effectiveness of the MMC. Workloads with low locality in metadata lookups incur performance overheads from additional memory accesses. The reach of the MMC is also affected by the granularity at which memory is tagged and hence the MMC hit rate can be improved with larger granularities. Thus efficient caching of metadata tags is critical. (4) In irregular workloads, accesses to tag ID mappings in memory require address translation and cause additional TLB misses, leading to higher performance overhead. We demonstrate that this can be mitigated by addressing mappings directly in physical memory or by using a separate TLB for mappings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">Conclusion</head><p>This work introduces MetaSys, an open-source full-system FPGA-based infrastructure to rapidly implement and evaluate diverse cross-layer optimizations in real hardware. We demonstrate MetaSys's versatility and ease-of-use by implementing and evaluating three new cross-layer techniques. We believe and hope MetaSys can enable new ideas and their rigorous evaluation on real hardware.</p><p>Using MetaSys, we present the first detailed experimental characterization to evaluate the efficiency and practicality of a single metadata system for cross-layer performance optimization. We demonstrate that the associated performance and area overheads are small, identify key performance bottlenecks, and propose simple techniques to alleviate them. Our characterization thus indicates that a general hardware-software interface with lightweight metadata management support offers a promising approach towards enabling cross-layer performance optimization in CPUs.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: MetaSys hardware components and operation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>LibraryCall Description CREATE(ModuleID, TagID, *meta) ModuleID -&gt; PMT[TagID] = *metadata MAP(start*, end*, TagID) MMT[start...end] = TagID UNMAP(start*, end*) MMT[start...end] = 0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: MetaSys Optimization Module.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Data-dependent accesses in graph processing.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Performance speedup with the MetaSys prefetcher.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Performance overheads with bounds checking.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Performance overheads for return address protection.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Normalized performance overheads.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 7 Figure 8 :Figure 9 :Figure 10 :</head><label>78910</label><figDesc>Fig.7depicts the execution time normalized to the baseline system (without MetaSys) for two scenarios: (i) when</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 15 :</head><label>15</label><figDesc>Figure 15: Performance overhead with multiple clients.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 16 :</head><label>16</label><figDesc>Figure 16: Alleviating MMC contention in microbenchmarks.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Physical Address ID Metadata Mapping Cache Mapping Management Unit 1 Metadata Mapping Table 3 4 Private Metadata Table Trigger Optimization Client 2 5 8 Metadata Lookup Unit Create(ID, Component, Properties) Map(Virtual address, Mapping range) 6 7 9 10 Memory MMC miss</head><label></label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>MetaSys instructions.</figDesc><table><row><cell>MetaSys Operator</cell><cell>MetaSys ISA Instructions</cell></row><row><cell>CREATE</cell><cell>CREATE ModuleID, TagID, Metadata</cell></row><row><cell>(UN)MAP</cell><cell></cell></row></table><note>(UN)MAP TagID, start_addr, size (UN)MAP2D TagID, start_addr, lenX, sizeX, sizeY (UN)MAP3D TagID, start_addr, lenX, lenY, sizeX, sizeY, sizeZ ;</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>The MetaSys software library.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3 :</head><label>3</label><figDesc>Comparison between MetaSys and XMem's interfaces.</figDesc><table><row><cell>Operator</cell><cell>XMem [22]</cell><cell>MetaSys</cell></row><row><cell></cell><cell>Compiler pragma to commu-</cell><cell></cell></row><row><cell>CREATE</cell><cell>nicate static metadata at load</cell><cell></cell></row><row><cell></cell><cell>time.</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 4 :</head><label>4</label><figDesc>Table 4 lists the parameters of the core and memory system. 1 CPU: 25 MHz; in-order Rocket core [21]; TLB 16 entries DTLB; LRU policy; L1 Data + Inst. Cache: 16 KB, 4-way; 4-cycle; 64 B line; LRU policy; MSHR size: 2 MMC: NMRU Policy; 128 entries; 38bits/entry; Tagging Granularity: 512B; Private Metadata Table: 256 entries; 64B/entry; DRAM: 533MHz; V dd : 1.5V; Parameters of evaluated system.</figDesc><table><row><cell>Workloads: Ligra [36]: PageRank(PR), Shortest Path (SSSP), Collaborative</cell></row><row><cell>Filtering (CF) Teenage Follower (TF), Triangle Counting (TC), Breadth-First</cell></row><row><cell>Search (BFS) Radius Estimation (Radii), Connected Components (CC);</cell></row><row><cell>Polybench [37]; µBenchmarks</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>and</figDesc><table><row><cell>Normalized Execution Time</cell><cell>1.0 1.5 2.0</cell><cell></cell><cell cols="3">SW Bounds Check</cell><cell cols="2">HW Bounds Check</cell></row><row><cell></cell><cell>b is o r t</cell><cell>e m 3 d</cell><cell>h e a lt h m s t</cell><cell>p e r im e t e r</cell><cell>p o w e r</cell><cell>t r e e a d d t s p</cell><cell>A V G</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>No Stall signifi-Figure 13: Impact of tagging granularity on TLB misses.</figDesc><table><row><cell cols="2">Normalized</cell><cell cols="2">TLB Misses</cell><cell cols="2">0.5 1 1.5 2 2.5</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">64</cell><cell></cell><cell></cell><cell cols="2">128</cell><cell></cell><cell cols="2">256</cell><cell></cell><cell>512</cell><cell></cell><cell cols="2">1024</cell><cell>2048</cell><cell>4096</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">BFS</cell><cell>CC</cell><cell cols="2">CF</cell><cell cols="2">PR</cell><cell>Radii</cell><cell>SSSP</cell><cell>TC</cell><cell cols="2">TF</cell><cell cols="2">Corr</cell><cell>DCT</cell><cell cols="2">DSYR2K</cell><cell cols="2">DSYRK</cell><cell>Dynprog</cell><cell>FDTD1D</cell><cell>Floyd</cell><cell>Gesum</cell><cell>Jacobi1D</cell><cell>Jacobi2D</cell><cell>LU</cell><cell>MM</cell><cell>MVT</cell><cell>TRMM</cell><cell>TS</cell><cell>GS</cell><cell>3D Array</cell><cell>LL</cell><cell>Random</cell><cell>Stream</cell><cell>AVG</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Ligra</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Polybench</cell><cell>μbenchmarks</cell></row><row><cell>Normalized</cell><cell cols="2">Execution Time</cell><cell>0.9 1 1.1 1.2 1.3</cell><cell cols="2">BFS CC</cell><cell cols="2">CF PR</cell><cell cols="2">Radii SSSP TC</cell><cell>TF</cell><cell>Corr</cell><cell>DCT</cell><cell cols="5">DSYR2K DSYRK Default No Translation Dynprog FDTD1D Floyd Gesum Jacobi1D Jacobi2D</cell><cell cols="2">LU MM</cell><cell>MVT</cell><cell cols="6">TRMM TS GS 3D Array LL Random Stream AVG</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Ligra</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Polybench</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="4">μbenchmarks</cell><cell></cell><cell></cell></row><row><cell cols="27">Figure 14: Performance overhead with no address translation</cell><cell></cell><cell></cell></row><row><cell cols="8">for metadata.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Normalized</cell><cell>Execution Time</cell><cell cols="2">0.9 1 1.1 1.2 1.3</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">One Client</cell><cell cols="2">Two Clients</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">1.61</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>BFS CC</cell><cell cols="2">CF</cell><cell>PR</cell><cell cols="2">Radii SSSP TC</cell><cell>TF</cell><cell>Corr</cell><cell>DCT</cell><cell>DSYR2K DSYRK</cell><cell>Dynprog FDTD1D</cell><cell>Floyd Gesum</cell><cell cols="3">Jacobi1D Jacobi2D LU</cell><cell cols="2">MM MVT</cell><cell>TRMM TS</cell><cell>GS</cell><cell cols="2">3D Array LL</cell><cell cols="2">Random Stream AVG</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Ligra</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Polybench</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">μbenchmarks</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Whirlpool: Improving dynamic cache management with static data classification</title>
		<author>
			<persName><forename type="first">A</forename><surname>Mukkara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Beckmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sanchez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
				<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">RADAR: Runtime-assisted dead region management for last-level caches</title>
		<author>
			<persName><forename type="first">M</forename><surname>Manivannan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Papaefstathiou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pericas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Stenstrom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HPCA</title>
				<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Using the compiler to improve cache replacement decisions</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Mckinley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Rosenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">C</forename><surname>Weems</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PACT</title>
				<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Software-assisted cache replacement mechanisms for embedded systems</title>
		<author>
			<persName><forename type="first">P</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Engels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Rudolph</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICCAD</title>
				<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Compiler-managed partitioned data caches for low power</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ravindran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mahlke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LCTES</title>
				<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">P-opt: Program-directed optimal cache management</title>
		<author>
			<persName><forename type="first">X</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Bai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Archambault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ding</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<publisher>LCPC</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Pacman: Program-assisted cache management</title>
		<author>
			<persName><forename type="first">J</forename><surname>Brock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Bao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ding</surname></persName>
		</author>
		<editor>ISMM</editor>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Generating cache hints for improved program efficiency</title>
		<author>
			<persName><forename type="first">K</forename><surname>Beyls</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">H</forename><surname>Hollander</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JSA</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Cooperative caching with keep-me and evict-me</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Sartor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Venkiteswaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Mckinley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note>in INTERACT-9</note>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Compiler-assisted cache replacement: Problem formulation and performance evaluation</title>
		<author>
			<persName><forename type="first">H</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Govindarajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">R</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Hu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>LCPC</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Cooperative cache scrubbing</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Sartor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Heirman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Blackburn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Eeckhout</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Mckinley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PACT</title>
				<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Runtime-driven shared last-level cache management for task-parallel programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">S</forename><surname>Pai</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
			<pubPlace>SC</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Prefetching and cache management using task lifetimes</title>
		<author>
			<persName><forename type="first">V</forename><surname>Papaefstathiou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">G</forename><surname>Katevenis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Nikolopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pnevmatikatos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICS</title>
				<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">A modified approach to data cache management</title>
		<author>
			<persName><forename type="first">G</forename><surname>Tyson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Farrens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Matthews</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Pleszkun</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>MICRO</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Page placement strategies for GPUs within heterogeneous memory systems</title>
		<author>
			<persName><forename type="first">N</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">W</forename><surname>Nellans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stephenson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>O'connor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Keckler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
				<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Data tiering in heterogeneous memory systems</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">R</forename><surname>Dulloor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sundaram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Satish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sankaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jackson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Schwan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EuroSys</title>
				<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Flikker: Saving DRAM refresh-power through critical data partitioning</title>
		<author>
			<persName><forename type="first">S</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pattabiraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Moscibroda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">G</forename><surname>Zorn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
				<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Supporting differentiated services in computers via programmable architecture for resourcing-on-demand (PARD)</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Sui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
				<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Labeled RISC-V: A new perspective on software-defined architecture</title>
		<author>
			<persName><forename type="first">B</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bao</surname></persName>
		</author>
		<editor>CARVV</editor>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The CHERI capability model: Revisiting RISC in an age of risk</title>
		<author>
			<persName><forename type="first">J</forename><surname>Woodruff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">N</forename><surname>Watson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Chisnall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Laurie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Neumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Norton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Roe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA</title>
				<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">The rocket chip generator</title>
		<author>
			<persName><forename type="first">K</forename><surname>Asanović</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Avizienis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bachrach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Beamer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Biancolin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Celio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Dabbelt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Hauser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Izraelevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Karandikar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Keller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Koenig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Love</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Maas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Magyar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Moretó</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Patterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">H</forename><surname>Richards</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Twigg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Vo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Waterman</surname></persName>
		</author>
		<idno>No. UCB/EECS-2016-17</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A Case for Richer Cross-layer Abstractions: Bridging the Semantic Gap with Expressive Memory</title>
		<author>
			<persName><forename type="first">N</forename><surname>Vijaykumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Majumdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hsieh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Pekhimenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Ebrahimi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Hajinazar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">B</forename><surname>Gibbons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Mutlu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA</title>
				<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Chisel: constructing hardware in a scala embedded language</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bachrach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Vo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Richards</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Waterman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Avižienis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wawrzynek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Asanović</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DAC</title>
				<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">The Locality Descriptor: A Holistic Cross-Layer Abstraction to Express Data Locality in GPUs</title>
		<author>
			<persName><forename type="first">N</forename><surname>Vijaykumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Ebrahimi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hsieh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">B</forename><surname>Gibbons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Mutlu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA</title>
				<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">PUMP: A programmable unit for metadata processing</title>
		<author>
			<persName><forename type="first">U</forename><surname>Dhawan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Vasilakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rubin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chiricescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Knight</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Dehon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third Workshop on Hardware and Architectural Support for Security and Privacy</title>
				<meeting>the Third Workshop on Hardware and Architectural Support for Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Hardbound: architectural support for spatial safety of the c programming language</title>
		<author>
			<persName><forename type="first">J</forename><surname>Devietti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Blundell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M K</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zdancewic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS, ser. ASPLOS XIII</title>
				<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Mondrian memory protection</title>
		<author>
			<persName><forename type="first">E</forename><surname>Witchel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cates</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Asanović</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
				<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Efficient tagged memory</title>
		<author>
			<persName><forename type="first">A</forename><surname>Joannou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Woodruff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kovacsics</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bradbury</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">N M</forename><surname>Watson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Chisnall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Roe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Napierala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Baldwin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Gudka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Neumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mazzinghi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Richardson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Son</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">T</forename><surname>Markettos</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">On the advantages of tagged architecture</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Feustel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TC</title>
		<imprint>
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Hardware enforcement of application security policies using tagged memory</title>
		<author>
			<persName><forename type="first">N</forename><surname>Zeldovich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
				<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Hardware support for fast capability-based addressing</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Carter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Keckler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Dally</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Notices</title>
				<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="319" to="327" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Capability-based computer systems</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">M</forename><surname>Levy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014">2014</date>
			<publisher>Digital Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Capsicum: Practical capabilities for UNIX</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">N M</forename><surname>Watson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Laurie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kennaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th USENIX Conference on Security</title>
				<meeting>the 19th USENIX Conference on Security</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">RISC-V proxy kernel</title>
		<author>
			<persName><surname>Risc-V</surname></persName>
		</author>
		<ptr target="https://github.com/riscv/riscv-pk" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Zynq®-7000 zedboard</title>
		<ptr target="http://zedboard.org/product/zedboard" />
		<imprint/>
		<respStmt>
			<orgName>AVNET</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Ligra: A lightweight graph processing framework for shared memory</title>
		<author>
			<persName><forename type="first">J</forename><surname>Shun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Blelloch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th ACM SIG-PLAN Symposium on Principles and Practice of Parallel Programming, ser. PPoPP &apos;13</title>
				<meeting>the 18th ACM SIG-PLAN Symposium on Principles and Practice of Parallel Programming, ser. PPoPP &apos;13</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Polybench: The polyhedral benchmark suite</title>
		<author>
			<persName><forename type="first">L</forename><surname>Pouchet</surname></persName>
		</author>
		<ptr target="http://web.cse.ohio-state.edu/~pouchet.2/software/polybench/" />
		<imprint/>
	</monogr>
	<note>Online</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Analysis and optimization of the memory hierarchy for graph processing workloads</title>
		<author>
			<persName><forename type="first">A</forename><surname>Basak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Oh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Xie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2019 IEEE International Symposium on High Performance Computer Architecture (HPCA)</title>
				<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Minnow: Lightweight offload engines for worklist management and worklist-directed prefetching</title>
		<author>
			<persName><forename type="first">D</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Thomson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Chiou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Third International Conference on Architectural Support for Programming Languages and Operating Systems, ser. ASPLOS &apos;18</title>
				<meeting>the Twenty-Third International Conference on Architectural Support for Programming Languages and Operating Systems, ser. ASPLOS &apos;18</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Imp: Indirect memory prefetcher</title>
		<author>
			<persName><forename type="first">X</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Hughes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Satish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 48th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)</title>
				<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Exploiting locality in graph analytics through hardware-accelerated traversal scheduling</title>
		<author>
			<persName><forename type="first">A</forename><surname>Mukkara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Beckmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Abeydeera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sanchez</surname></persName>
		</author>
		<idno>ser. MICRO-51</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 51st Annual IEEE/ACM International Symposium on Microarchitecture</title>
				<meeting>the 51st Annual IEEE/ACM International Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Prefedge: Ssd prefetcher for large-scale graph traversal</title>
		<author>
			<persName><forename type="first">K</forename><surname>Nilakant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Dalibard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Yoneki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Conference on Systems and Storage</title>
				<meeting>International Conference on Systems and Storage</meeting>
		<imprint/>
	</monogr>
	<note>ser. SYSTOR &apos;14</note>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Graph prefetching using data structure knowledge</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ainsworth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M</forename><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 International Conference on Supercomputing, ser. ICS</title>
				<meeting>the 2016 International Conference on Supercomputing, ser. ICS</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">An event-triggered programmable prefetcher for irregular workloads</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ainsworth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M</forename><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Third International Conference on Architectural Support for Programming Languages and Operating Systems, ser. ASPLOS</title>
				<meeting>the Twenty-Third International Conference on Architectural Support for Programming Languages and Operating Systems, ser. ASPLOS</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Prodigy: Improving the Memory Latency of Data-Indirect Irregular Workloads Using Hardware-Software Co-Design</title>
		<author>
			<persName><forename type="first">N</forename><surname>Talati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HPCA 2021</title>
				<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Dependence based prefetching for linked data structures</title>
		<author>
			<persName><forename type="first">A</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moshovos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Sohi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eighth International Conference on Architectural Support for Programming Languages and Operating Systems, ser. ASPLOS &apos;98</title>
				<meeting>the Eighth International Conference on Architectural Support for Programming Languages and Operating Systems, ser. ASPLOS &apos;98</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Compiler-directed contentaware prefetching for dynamic data structures</title>
		<author>
			<persName><forename type="first">H</forename><surname>Al-Sukhni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Bratt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Connors</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th International Conference on Parallel Architectures and Compilation Techniques, ser. PACT &apos;03</title>
				<meeting>the 12th International Conference on Parallel Architectures and Compilation Techniques, ser. PACT &apos;03</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Cooperative prefetching: compiler and hardware support for effective instruction prefetching in modern processors</title>
		<author>
			<persName><forename type="first">Chi-Keung</forename><surname>Luk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">C</forename><surname>Mowry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings. 31st Annual ACM/IEEE International Symposium on Microarchitecture</title>
				<meeting>31st Annual ACM/IEEE International Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Guided region prefetching: a cooperative hardware/software approach</title>
		<author>
			<persName><forename type="first">Zhenlin</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Burger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Mckinley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Reinhardt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">C</forename><surname>Weems</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">30th Annual International Symposium on Computer Architecture</title>
				<imprint>
			<date type="published" when="2003">2003. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Sunder: a programmable hardware prefetch architecture for numerical loops</title>
		<author>
			<persName><forename type="first">Tzi-Cker</forename><surname>Chiueh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Supercomputing &apos;94:Proceedings of the 1994 ACM/IEEE Conference on Supercomputing</title>
				<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Semantic locality and context-based prefetching using reinforcement learning</title>
		<author>
			<persName><forename type="first">L</forename><surname>Peled</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mannor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Weiser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Etsion</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 42Nd Annual International Symposium on Computer Architecture, ser. ISCA &apos;15</title>
				<meeting>the 42Nd Annual International Symposium on Computer Architecture, ser. ISCA &apos;15</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Data prefetching by dependence graph precomputation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Annavaram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Patel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">S</forename><surname>Davidson</surname></persName>
		</author>
		<idno>ser. ISCA &apos;01</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th Annual International Symposium on Computer Architecture</title>
				<meeting>the 28th Annual International Symposium on Computer Architecture</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Combining cooperative software/hardware prefetching and cache replacement</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Mckinley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Burger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IBM Austin CAS Center for Advanced Studies Conference</title>
				<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Stream-based memory access specialization for general purpose processors</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Nowatzki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 46th International Symposium on Computer Architecture, ser. ISCA &apos;19</title>
				<meeting>the 46th International Symposium on Computer Architecture, ser. ISCA &apos;19</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Data cache prefetching using a global history buffer</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">J</forename><surname>Nesbit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">10th International Symposium on High Performance Computer Architecture (HPCA&apos;04)</title>
				<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Spatial Memory Streaming</title>
		<author>
			<persName><forename type="first">S</forename><surname>Somogyi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Wenisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ailamaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Falsafi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moshovos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA</title>
				<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Efficiently prefetching complex address patterns</title>
		<author>
			<persName><forename type="first">M</forename><surname>Shevgoor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Koladiya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Balasubramonian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wilkerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">H</forename><surname>Pugsley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Chishti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 48th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)</title>
				<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Dspatch: Dual spatial pattern prefetcher</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Nori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Mutlu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Subramoney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 52Ndsd Annual IEEE/ACM International Symposium on Microarchitecture, ser. MI-CRO &apos;19</title>
				<meeting>the 52Ndsd Annual IEEE/ACM International Symposium on Microarchitecture, ser. MI-CRO &apos;19</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Bingo spatial data prefetcher</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bakhshalipour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Shakerinava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lotfi-Kamran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Sarbazi-Azad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2019 IEEE International Symposium on High Performance Computer Architecture (HPCA)</title>
				<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<monogr>
		<title level="m" type="main">Stride directed prefetching in scalar processors</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W C</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Patel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">L</forename><surname>Janssens</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>MICRO</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">An efficient and backwardscompatible transformation to ensure memory safety of c programs</title>
		<author>
			<persName><forename type="first">W</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Duvarney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sekar</surname></persName>
		</author>
		<idno>ser. SIGSOFT &apos;04/FSE- 12</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th ACM SIGSOFT Twelfth International Symposium on Foundations of Software Engineering</title>
				<meeting>the 12th ACM SIGSOFT Twelfth International Symposium on Foundations of Software Engineering</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Protecting c programs from attacks via invalid pointer dereferences</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">H</forename><surname>Yong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Horwitz</surname></persName>
		</author>
		<idno>ser. ESEC/FSE-11</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th European Software Engineering Conference Held Jointly with 11th ACM SIGSOFT International Symposium on Foundations of Software Engineering</title>
				<meeting>the 9th European Software Engineering Conference Held Jointly with 11th ACM SIGSOFT International Symposium on Foundations of Software Engineering</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Ccured: Type-safe retrofitting of legacy software</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">C</forename><surname>Necula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Condit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Harren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mcpeak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Efficient detection of all pointer and array access errors</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M</forename><surname>Austin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">E</forename><surname>Breach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Sohi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN 1994 Conference on Programming Language Design and Implementation, ser. PLDI &apos;94</title>
				<meeting>the ACM SIGPLAN 1994 Conference on Programming Language Design and Implementation, ser. PLDI &apos;94</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Dependent types for low-level programming</title>
		<author>
			<persName><forename type="first">J</forename><surname>Condit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Harren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">C</forename><surname>Necula</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th European Symposium on Programming</title>
				<meeting>the 16th European Symposium on Programming</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Backwards-compatible array bounds checking for c with very low overhead</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dhurjati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Adve</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th International Conference on Software Engineering, ser. ICSE &apos;06</title>
				<meeting>the 28th International Conference on Software Engineering, ser. ICSE &apos;06</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Cyclone: A safe dialect of c</title>
		<author>
			<persName><forename type="first">T</forename><surname>Jim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">G</forename><surname>Morrisett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Grossman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W</forename><surname>Hicks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cheney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<idno>ser. ATEC &apos;02</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the General Track of the Annual Conference on USENIX Annual Technical Conference</title>
				<meeting>the General Track of the Annual Conference on USENIX Annual Technical Conference</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Efficient run-time monitoring using shadow processing</title>
		<author>
			<persName><forename type="first">H</forename><surname>Patil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">N</forename><surname>Fischer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AADEBUG</title>
				<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">Softbound: Highly compatible and complete spatial memory safety for c</title>
		<author>
			<persName><forename type="first">S</forename><surname>Nagarakatte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zdancewic</surname></persName>
		</author>
		<idno>ser. PLDI &apos;09</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
				<meeting>the 30th ACM SIGPLAN Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Purify: Fast detection of memory leaks and access errors</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hastings</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Joyce</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Winter 1992 USENIX Conference</title>
				<meeting>of the Winter 1992 USENIX Conference</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">Backwards-compatible array bounds checking for c with very low overhead</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dhurjati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Adve</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th International Conference on Software Engineering, ser. ICSE &apos;06</title>
				<meeting>the 28th International Conference on Software Engineering, ser. ICSE &apos;06</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">A practical dynamic buffer overflow detector</title>
		<author>
			<persName><forename type="first">O</forename><surname>Ruwase</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Lam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
				<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Memory safety for embedded devices with nescheck</title>
		<author>
			<persName><forename type="first">D</forename><surname>Midi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Payer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Bertino</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM on Asia Conference on Computer and Communications Security, ser. ASIA CCS &apos;17</title>
				<meeting>the 2017 ACM on Asia Conference on Computer and Communications Security, ser. ASIA CCS &apos;17</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">Intel MPX explained: A cross-layer analysis of the Intel MPX system stack</title>
		<author>
			<persName><forename type="first">O</forename><surname>Oleksenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kuvaiskii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bhatotia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Felber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Fetzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Abstracts of the 2018 ACM International Conference on Measurement and Modeling of Computer Systems, ser. SIGMETRICS &apos;18</title>
				<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">Checked c: Making c safe by extension</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Elliott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ruef</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hicks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tarditi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Cybersecurity Development (SecDev)</title>
		<imprint>
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">Sok: Eternal war in memory</title>
		<author>
			<persName><forename type="first">L</forename><surname>Szekeres</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Payer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2013 IEEE Symposium on Security and Privacy, ser. SP &apos;13</title>
				<meeting>the 2013 IEEE Symposium on Security and Privacy, ser. SP &apos;13</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">Low-fat pointers: Compact encoding and efficient gate-level implementation of fat pointers for spatial safety and capability-based security</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kwon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Dhawan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Knight</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jr</forename></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>De-Hon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2013 ACM SIGSAC Conference on Computer &amp;#38; Communications Security, ser. CCS &apos;13</title>
				<meeting>the 2013 ACM SIGSAC Conference on Computer &amp;#38; Communications Security, ser. CCS &apos;13</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<analytic>
		<title level="a" type="main">Watchdoglite: Hardware-accelerated compiler-based pointer checking</title>
		<author>
			<persName><forename type="first">S</forename><surname>Nagarakatte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M K</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zdancewic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Annual IEEE/ACM International Symposium on Code Generation and Optimization, ser. CGO &apos;14</title>
				<meeting>Annual IEEE/ACM International Symposium on Code Generation and Optimization, ser. CGO &apos;14</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">Watchdog: Hardware for safe and secure manual memory management and full memory safety</title>
		<author>
			<persName><forename type="first">S</forename><surname>Nagarakatte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M K</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zdancewic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 39th Annual International Symposium on Computer Architecture, ser. ISCA &apos;12</title>
				<meeting>the 39th Annual International Symposium on Computer Architecture, ser. ISCA &apos;12</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">High-performance parallel accelerator for flexible and efficient run-time monitoring</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">Y</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Suh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE/IFIP International Conference on Dependable Systems and Networks (DSN 2012)</title>
				<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">Memtracker: Efficient and programmable support for memory access monitoring and debugging</title>
		<author>
			<persName><forename type="first">G</forename><surname>Venkataramani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Roemer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Solihin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Prvulovic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2007 IEEE 13th International Symposium on High Performance Computer Architecture</title>
				<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<analytic>
		<title level="a" type="main">Shakti-T: A RISC-V processor with light weight security extensions</title>
		<author>
			<persName><forename type="first">A</forename><surname>Menon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Murugan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rebeiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Gala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Veezhinathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Hardware and Architectural Support for Security and Privacy</title>
				<meeting>the Hardware and Architectural Support for Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note>ser. HASP &apos;17</note>
</biblStruct>

<biblStruct xml:id="b82">
	<analytic>
		<title level="a" type="main">Supporting dynamic data structures on distributed-memory machines</title>
		<author>
			<persName><forename type="first">A</forename><surname>Rogers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Carlisle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Laboratories</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Hendren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<analytic>
		<title level="a" type="main">Memsafe: Ensuring the spatial and temporal memory safety of c at runtime</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Simpson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Barua</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2010 10th IEEE Working Conference on Source Code Analysis and Manipulation</title>
				<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<monogr>
		<title level="m" type="main">New security enhancementsin red hat enterprise linuxv.3, update 3</title>
		<author>
			<persName><forename type="first">A</forename><surname>Van De Ven</surname></persName>
		</author>
		<ptr target="https://static.redhat.com/legacy/f/pdf/rhel/WHP0006US_Execshield.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<analytic>
		<title level="a" type="main">Stackguard: Automatic adaptive detection and prevention of buffer-overflow attacks</title>
		<author>
			<persName><forename type="first">C</forename><surname>Cowan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Hintony</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Walpole</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bakke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Beattie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Grier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wagle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th Conference on USENIX Security Symposium</title>
				<meeting>the 7th Conference on USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">7</biblScope>
		</imprint>
	</monogr>
	<note>ser. SSYM&apos;98</note>
</biblStruct>

<biblStruct xml:id="b86">
	<analytic>
		<title level="a" type="main">Return-oriented programming without returns</title>
		<author>
			<persName><forename type="first">S</forename><surname>Checkoway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Davi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Dmitrienko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A.-R</forename><surname>Sadeghi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Shacham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Winandy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th ACM Conference on Computer and Communications Security, ser. CCS &apos;10</title>
				<meeting>the 17th ACM Conference on Computer and Communications Security, ser. CCS &apos;10</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b87">
	<monogr>
		<title level="m" type="main">Jump-oriented programming: a new class of code-reuse attack</title>
		<author>
			<persName><forename type="first">T</forename><surname>Bletsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Freeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Liang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="30" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b88">
	<analytic>
		<title level="a" type="main">On the expressiveness of return-into-libc attacks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Tran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Etheridge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Bletsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Freeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th International Conference on Recent Advances in Intrusi-flon Detection, ser. RAID&apos;11</title>
				<meeting>the 14th International Conference on Recent Advances in Intrusi-flon Detection, ser. RAID&apos;11</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b89">
	<analytic>
		<title level="a" type="main">Transparent run-time defense against stack smashing attacks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Baratloo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Tsai</surname></persName>
		</author>
		<idno>ser. ATEC &apos;00</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Annual Conference on USENIX Annual Technical Conference</title>
				<meeting>the Annual Conference on USENIX Annual Technical Conference</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b90">
	<analytic>
		<title level="a" type="main">Control-flow integrity</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Budiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Erlingsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ligatti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th ACM Conference on Computer and Communications Security, ser. CCS &apos;05</title>
				<meeting>the 12th ACM Conference on Computer and Communications Security, ser. CCS &apos;05</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b91">
	<analytic>
		<title level="a" type="main">Ccfi: Cryptographically enforced control flow integrity</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Mashtizadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bittau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mazières</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22Nd ACM SIGSAC Conference on Computer and Communications Security, ser. CCS &apos;15</title>
				<meeting>the 22Nd ACM SIGSAC Conference on Computer and Communications Security, ser. CCS &apos;15</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b92">
	<analytic>
		<title level="a" type="main">Opaque control-flow integrity</title>
		<author>
			<persName><forename type="first">V</forename><surname>Mohan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Brunthaler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">W</forename><surname>Hamlen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Franz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
				<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b93">
	<analytic>
		<title level="a" type="main">Code-pointer integrity</title>
		<author>
			<persName><forename type="first">V</forename><surname>Kuznetsov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Szekeres</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Payer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Candea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sekar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">11th USENIX Symposium on Operating Systems Design and Implementation</title>
				<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note>OSDI 14</note>
</biblStruct>

<biblStruct xml:id="b94">
	<analytic>
		<title level="a" type="main">The performance cost of shadow stacks and stack canaries</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">H</forename><surname>Dang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Maniatis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th ACM Symposium on Information, Computer and Communications Security, ser. ASIA CCS &apos;15</title>
				<meeting>the 10th ACM Symposium on Information, Computer and Communications Security, ser. ASIA CCS &apos;15</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b95">
	<analytic>
		<title level="a" type="main">Raguard: A hardware based mechanism for backward-edge control-flow integrity</title>
		<author>
			<persName><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Mckee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Computing Frontiers Conference, ser. CF&apos;17</title>
				<meeting>the Computing Frontiers Conference, ser. CF&apos;17</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b96">
	<analytic>
		<title level="a" type="main">Pac it up: Towards pointer integrity using arm pointer authentication</title>
		<author>
			<persName><forename type="first">H</forename><surname>Liljestrand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Nyman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">C</forename><surname>Perez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-E</forename><surname>Ekberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Asokan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
				<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b97">
	<analytic>
		<title level="a" type="main">Protecting the stack with metadata policies and tagged hardware</title>
		<author>
			<persName><forename type="first">N</forename><surname>Roessler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Dehon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 IEEE Symposium on Security and Privacy (SP)</title>
				<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b98">
	<monogr>
		<title level="m" type="main">Control-flow Enforcement Technology Specification</title>
		<author>
			<persName><surname>Intel</surname></persName>
		</author>
		<ptr target="www.intel.com/content/dam/www/public/us/en/documents/white-papers/virtualization-enabling-intel-virtualization-technology-features-and-benefits-paper.pdf" />
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b99">
	<monogr>
		<title level="m" type="main">Cwe-123: Write-what-where condition</title>
		<author>
			<persName><forename type="first">C</forename><surname>Mitre</surname></persName>
		</author>
		<ptr target="https://cwe.mitre.org/data/definitions/123.html" />
		<imprint>
			<date type="published" when="2019-09">September 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b100">
	<analytic>
		<title level="a" type="main">Breaking the memory secrecy assumption</title>
		<author>
			<persName><forename type="first">R</forename><surname>Strackx</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Younan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Philippaerts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Piessens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lachmund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Walter</surname></persName>
		</author>
		<idno>ser. EUROSEC &apos;09</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second European Workshop on System Security</title>
				<meeting>the Second European Workshop on System Security</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b101">
	<monogr>
		<title level="m" type="main">Cooperative caching for chip multiprocessors</title>
		<author>
			<persName><forename type="first">J</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Sohi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<publisher>ACM</publisher>
			<biblScope unit="volume">34</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b102">
	<analytic>
		<title level="a" type="main">Dynamic qos management for chip multiprocessors</title>
		<author>
			<persName><forename type="first">B</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L.-S</forename><surname>Peh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Iyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Architecture and Code Optimization (TACO)</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">17</biblScope>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b103">
	<analytic>
		<title level="a" type="main">iwatcher: efficient architectural support for software debugging</title>
		<author>
			<persName><forename type="first">Pin</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Feng</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wei</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuanyuan</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Torrellas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings. 31st Annual International Symposium on Computer Architecture</title>
				<meeting>31st Annual International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2004">2004. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b104">
	<analytic>
		<title level="a" type="main">Colorsafe: Architectural support for debugging and dynamically avoiding multi-variable atomicity violations</title>
		<author>
			<persName><forename type="first">B</forename><surname>Lucia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ceze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Strauss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">SIGARCH Comput. Archit. News</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b105">
	<analytic>
		<title level="a" type="main">Avio: Detecting atomicity violations via access interleaving invariants</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tucek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th International Conference on Architectural Support for Programming Languages and Operating Systems, ser. ASPLOS XII</title>
				<meeting>the 12th International Conference on Architectural Support for Programming Languages and Operating Systems, ser. ASPLOS XII</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b106">
	<analytic>
		<title level="a" type="main">Atomtracker: A comprehensive approach to atomic region inference and violation detection</title>
		<author>
			<persName><forename type="first">A</forename><surname>Muzahid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Otsuki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Torrellas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2010 43rd Annual IEEE/ACM International Symposium on Microarchitecture</title>
				<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b107">
	<analytic>
		<title level="a" type="main">Atom-aid: Detecting and surviving atomicity violations</title>
		<author>
			<persName><forename type="first">B</forename><surname>Lucia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Devietti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Strauss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ceze</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="277" to="288" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b108">
	<analytic>
		<title level="a" type="main">Conflict exceptions: Simplifying concurrent language semantics with precise hardware exceptions for data-races</title>
		<author>
			<persName><forename type="first">B</forename><surname>Lucia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ceze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Strauss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Qadeer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-J</forename><surname>Boehm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 37th Annual International Symposium on Computer Architecture, ser. ISCA &apos;10</title>
				<meeting>the 37th Annual International Symposium on Computer Architecture, ser. ISCA &apos;10</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b109">
	<analytic>
		<title level="a" type="main">Hard: Hardware-assisted lockset-based race detection</title>
		<author>
			<persName><forename type="first">P</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Teodorescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2007 IEEE 13th International Symposium on High Performance Computer Architecture</title>
				<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b110">
	<analytic>
		<title level="a" type="main">Timing attacks on implementations of diffie-hellman, rsa, dss, and other systems</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>Kocher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th Annual International Cryptology Conference on Advances in Cryptology, ser. CRYPTO &apos;96</title>
				<meeting>the 16th Annual International Cryptology Conference on Advances in Cryptology, ser. CRYPTO &apos;96</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b111">
	<monogr>
		<title level="m" type="main">Cleanupspec: An &quot;undo&quot; approach to safe speculation</title>
		<author>
			<persName><forename type="first">G</forename><surname>Saileshwar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Qureshi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2019">2019</date>
			<pubPlace>MICRO</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b112">
	<monogr>
		<title level="m" type="main">Invisispec: Making speculative execution invisible in the cache hierarchy</title>
		<author>
			<persName><forename type="first">M</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Skarlatos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Morrison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Torrellas</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018">2018</date>
			<pubPlace>MICRO</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b113">
	<monogr>
		<title level="m" type="main">MI6: Secure Enclaves in a Speculative Out-of-Order Processor</title>
		<author>
			<persName><forename type="first">T</forename><surname>Bourgeat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Lebedev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wright</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arvind</forename></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2019">2019</date>
			<pubPlace>MICRO</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b114">
	<analytic>
		<title level="a" type="main">Flexible reference-counting-based hardware acceleration for garbage collection</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Joao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Mutlu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">N</forename><surname>Patt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="418" to="428" />
			<date type="published" when="2009">2009</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b115">
	<analytic>
		<title level="a" type="main">A hardware accelerator for tracing garbage collection</title>
		<author>
			<persName><forename type="first">M</forename><surname>Maas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Asanović</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kubiatowicz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 45th Annual International Symposium on Computer Architecture</title>
				<meeting>the 45th Annual International Symposium on Computer Architecture</meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="138" to="151" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b116">
	<analytic>
		<title level="a" type="main">Grail quest: A new proposal for hardware-assisted garbage collection</title>
		<author>
			<persName><forename type="first">M</forename><surname>Maas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Asanovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kubiatowicz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Architectures and Systems for Big Data</title>
				<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b117">
	<monogr>
		<title level="m" type="main">Synopsys design compiler</title>
		<author>
			<persName><surname>Synopsys</surname></persName>
		</author>
		<ptr target="https://www.synopsys.com/support/training/rtl-synthesis/design-compiler-rtl-synthesis.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b118">
	<monogr>
		<title level="m" type="main">Dual core/gt2 ivy bridge die measured: 121mm2</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Shimpi</surname></persName>
		</author>
		<ptr target="https://www.anandtech.com/show/5875/dual-coregt2-ivy-bridge-die-measured-121mm2" />
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
