<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Concurrent Zero Knowledge with Logarithmic Round-Complexity</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Manoj</forename><surname>Prabhakaran</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Alon</forename><surname>Rosen</surname></persName>
						</author>
						<author role="corresp">
							<persName><forename type="first">Amit</forename><surname>Sahai</surname></persName>
							<email>sahai@cs.princeton.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Princeton University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Weizmann Institute of Science</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Princeton University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Concurrent Zero Knowledge with Logarithmic Round-Complexity</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">0BC60256D2EBF3DCEEA027D19E55AF15</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T06:02+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We show that every language in N P has a (black-box) concurrent zero-knowledge proof system using Õ(log n) rounds of interaction. The number of rounds in our protocol is optimal, in the sense that any language outside BPP requires at least Ω(log n) rounds of interaction in order to be proved in black-box concurrent zero-knowledge. The zeroknowledge property of our main protocol is proved under the assumption that there exists a collection of claw-free functions. Assuming only the existence of one-way functions, we show the existence of Õ(log n)-round concurrent zero-knowledge arguments for all languages in N P.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Zero-knowledge proof systems, introduced by Goldwasser, Micali and Rackoff <ref type="bibr" target="#b13">[14]</ref> are efficient interactive proofs that have the remarkable property of yielding nothing beyond the validity of the assertion being proved. The generality of zero-knowledge proofs has been demonstrated by Goldreich, Micali and Wigderson <ref type="bibr" target="#b12">[13]</ref>, who showed that every NP-statement can be proved in zero-knowledge provided that one-way functions exist <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b19">20]</ref>. Since then, zero-knowledge proofs have turned out to be an extremely useful tool in the design of various cryptographic protocols.</p><p>The original setting in which zero-knowledge proofs were investigated consisted of a single prover and verifier which execute only one instance of the protocol at a time. A more realistic setting, especially in the time of the Internet, is one which allows the concurrent execution of zeroknowledge protocols <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b5">6]</ref>. In the concurrent setting, many protocols (sessions) are executed at the same time, involving many verifiers which may be talking with the same (or many) provers simultaneously (the so-called parallel composition considered in <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b9">10]</ref> is a special case). This setting presents the new risk of a coordinated attack in which an adversary controls many verifiers, interleaving the executions of the protocols and choosing verifiers' messages based on other partial executions of the protocol. Since it seems unrealistic (and certainly undesirable) for honest provers to coordinate their actions so that zero-knowledge is preserved, we must assume that in each prover-verifier pair the prover acts independently.</p><p>Loosely speaking, a zero-knowledge proof is said to be concurrent zero-knowledge (cZK) if it remains zeroknowledge even when executed in the concurrent setting. Recall that in order to demonstrate that a certain protocol is zero-knowledge it is required to demonstrate that the view of every probabilistic polynomial-time adversary interacting with the prover can be simulated by a probabilistic polynomial-time machine (a.k.a. the simulator). In the concurrent setting, the verifiers' view may include multiple sessions running at the same time. Furthermore, the verifiers may have control over the scheduling of the messages in these sessions (i.e., the order in which the interleaved execution of these sessions should be conducted). As a consequence, the simulator's task in the concurrent setting becomes considerably more complicated. In particular, standard techniques, based on "rewinding the adversary", run into trouble.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Previous Work</head><p>An informal argument concerning the difficulty of constructing round-efficient cZK was given by Dwork, Naor, and Sahai in their paper introducing cZK <ref type="bibr" target="#b5">[6]</ref>. The first rigorous lower bound was given by Kilian, Petrank and Rackoff <ref type="bibr" target="#b18">[19]</ref> who showed, building on the techniques of <ref type="bibr" target="#b11">[12]</ref>, that for every language outside BPP there is no 4round protocol whose concurrent execution is simulatable in polynomial-time by a black-box simulator. (A black-box simulator is a simulator that has only black-box access to the adversarial verifier.) This lower bound was later improved by Rosen to seven rounds <ref type="bibr" target="#b21">[22]</ref>, and was further improved to Ω(log n/ log log n) rounds by Canetti, Kilian, Petrank and Rosen <ref type="bibr" target="#b4">[5]</ref>.</p><p>Even ignoring issues of round efficiency, it was not apriori clear whether there exists cZK protocols for languages outside of BPP. Richardson and Kilian were the first to exhibit a family of cZK protocols (parameterized by the number of rounds) for all languages in N P <ref type="bibr" target="#b20">[21]</ref>.</p><p>The original analysis of the RK protocol showed how to simulate in polynomial-time n O (1) concurrent sessions only when the number of rounds in the protocol is at least n ǫ (for some arbitrary ǫ &gt; 0). This analysis has been later improved by Kilian and Petrank <ref type="bibr" target="#b17">[18]</ref>, who show that the RK protocol remains concurrent zero-knowledge even if it has O(α(n) • log 2 n) rounds, where α(•) is any non-constant function (e.g., α(n) = log log n).</p><p>In a recent breakthrough result, Barak <ref type="bibr" target="#b0">[1]</ref> constructs a constant-round protocol for all languages in N P whose zero-knowledge property is proved using a non black-box simulator. Such a method of simulation enables him to prove that for every (predetermined) polynomial p(•), there exists a constant-round protocol that preserves its zeroknowledge property even when it is executed p(n) times concurrently (where n denotes the size of the common input). This has been previously shown to be unachievable via black-box simulation <ref type="bibr" target="#b4">[5]</ref> (unless N P ⊆ BPP).</p><p>A major drawback of Barak's protocol is that the (polynomial) number of concurrent sessions relative to which the protocol should be secure must be fixed before the protocol is specified. Moreover, the length of the messages in the protocol grows linearly with the number of concurrent sessions. Thus, from both a theoretical and a practical point of view, Barak's protocol is still not satisfactory. What we would like to have is a single protocol that preserves its zero-knowledge property even when it is executed concurrently for any (not predetermined) polynomial number of times. Such a property is indeed satisfied by the protocols of <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b17">18]</ref> (alas these protocols are not constant-round).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Our Results</head><p>In this work we close the gap between the known upper and lower bounds on the round-complexity of blackbox cZK <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b4">5]</ref>. Specifically, assuming the existence of perfectly-hiding commitment schemes (which exist assuming the existence of a collection of claw-free functions <ref type="bibr" target="#b14">[15]</ref>), we show that every language in N P can be proved in cZK using only Õ(log n) rounds of interaction. Our main result is stated in the following theorem: Theorem 1 (Main Theorem) Assuming the existence of perfectly-hiding commitment schemes, there exists an Õ(log n)-round black-box concurrent zero-knowledge proof system for every language L ∈ N P (that is, for every input x, the number of messages exchanged is at most Õ(log(|x|))).</p><p>We stress that our protocol retains its zero-knowledge property even under "full fledged" concurrent composition. That is, once the protocol is fixed it will remain zero-knowledge no matter how many times it is executed concurrently (as long as the number of concurrent sessions is polynomial in the size of the input). Notice that the above theorem completes the classification of the round-complexity of black-box cZK. Namely, by combining Theorem 1 with the lower bound of Canetti et al. <ref type="bibr" target="#b4">[5]</ref>, we have:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary 1</head><p>The round-complexity of black-box concurrent zero-knowledge is Θ(log n) rounds. <ref type="foot" target="#foot_0">1</ref>By relaxing the soundness requirement of the protocol to hold only against computationally bounded provers (that is, by considering so-called zero-knowledge arguments <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b2">3]</ref>), we are able to achieve a similar result assuming only the existence of one-way functions, namely: Theorem 2 Assuming the existence of one-way functions, there exists an Õ(log n)-round black-box concurrent zeroknowledge argument system for every language L ∈ N P.</p><p>We note that the lower-bound by Canetti et al. <ref type="bibr" target="#b4">[5]</ref> applies also in the case of arguments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Techniques</head><p>The proof of Theorem 1 builds on the protocol by Richardson and Kilian <ref type="bibr" target="#b20">[21]</ref> and on the simulator by Kilian and Petrank <ref type="bibr" target="#b17">[18]</ref>. However, our analysis of the simulator's execution is more sophisticated and thus yields a stronger result. We introduce a novel counting argument that involves a direct analysis of the underlying probability space. This is in contrast to previous results that required subtle manipulations of conditional probabilities. We also present a new variant of the RK protocol <ref type="bibr" target="#b20">[21]</ref> which is both simpler and more amenable to analysis than the original version. In the rest of this section, we briefly sketch the ideas we use to obtain our main result.</p><p>Constructing zero-knowledge proofs for N P involves resolving a tension between the soundness and zero knowledge conditions: In (black-box) zero-knowledge proofs, the simulator can be thought of as a party that interacts with the verifier, but unlike the prover, the simulator must be able to convince the verifier of both true and false statements. To enable this, the simulator is given a "super power," namely the ability to "rewind" the verifier to an earlier state, and thus base its messages on future verifier messages. Very roughly speaking, zero knowledge proofs for N P have been constructed by inserting "rewinding opportunities" into protocols, which allow the simulator to "win" if it can base one of its earlier messages to the verifier on a future message received from the verifier. We stress that in order to successfully "exploit" a "rewinding opportunity," the simulator must take care not to "rewind" too far back, otherwise the information it learned from the verifier will no longer be useful. It is precisely this problem which makes simulation so difficult in concurrent zero knowledge, because rewinding one verifier may cause another verifier to be rewound "too much," requiring re-simulation, as first pointed out by <ref type="bibr" target="#b5">[6]</ref>.</p><p>The Richardson-Kilian (RK) protocol and Kilian-Petrank simulation. The basic idea of the Richardson-Kilian cZK protocol <ref type="bibr" target="#b20">[21]</ref> is to have a protocol with many rewinding opportunities, so that even if the simulator has to miss one opportunity, it will still get many more. Kilian and Petrank then showed that in fact, there exists a simulator for the RK protocol which has a very natural "oblivious" rewinding strategy <ref type="bibr" target="#b17">[18]</ref> -in other words, the simulator's decisions of when and how much to rewind do not depend on the behavior of the verifiers, but are predetermined.</p><p>At this point, we note that a simple technical calculation shows that a single chance to exploit a rewinding opportunity results in only a constant probability that the simulator will "win." Thus, the simulator needs a superlogarithmic number of (roughly independent) chances to exploit rewinding opportunities in order to reduce its failure probability to a negligible fraction. Kilian and Petrank showed that in their oblivious rewinding strategy, throughout the simulation, every time a session of the protocol completes, the simulator will have chances to exploit at least Ω(k/ log n) rewinding opportunities, where k is the total number of rewinding opportunities in the protocol (the number of rounds in the protocol would then be O(k)). This implies that Õ(log 2 n) rounds suffice for concurrent simulation of the RK protocol.</p><p>The new ideas underlying this work. Unfortunately, the Kilian-Petrank argument does not extend to the case when k = Õ(log n). In fact, in such a case there may exists only few (i.e., o(log n)) rewinding opportunities that can be exploited by the simulator.</p><p>We overcome this limitation by shifting our focus from the number of "exposed" rewinding opportunities in the protocol, to the total number of chances to exploit rewinding opportunities counted with multiplicity, in case the rewinding schedule permits multiple chances to exploit a single rewinding opportunity in the protocol. In fact, we show that the Kilian-Petrank oblivious rewinding strategy itself always yields roughly k-O(log n) such chances in total. This allows us to conclude that Õ(log n) rounds suffice. Furthermore, rather than relying on a subtle manipulation of conditional probabilities as done in previous work <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b17">18]</ref>, building on a suggestion of <ref type="bibr" target="#b16">[17]</ref> we employ a direct counting argument to prove our claim. We essentially show directly that there can only be very few random coins on which our simulation fails, by arguing that for every choice of random coins on which our simulation fails, there must be superpolynomially more other choices for the random coins on which it does not.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">Conclusions and an open problem</head><p>Our result (together with <ref type="bibr" target="#b4">[5]</ref>) essentially completes the classification of the round-complexity of black-box cZK (Corollary 1). Still, in light of Barak's recent result <ref type="bibr" target="#b0">[1]</ref>, constant-round cZK protocols (with non black-box simulators) do not seem out of reach. A natural open question is whether there exists a constant-round (non black-box) cZK protocol for all languages in N P.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Definition of cZK</head><p>We use the standard definitions of interactive proofs (and interactive Turing machines) <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b10">11]</ref> and arguments (a.k.a computationally-sound proofs) <ref type="bibr" target="#b2">[3]</ref>. In defining concurrent zero knowledge, we follow the original definition of <ref type="bibr" target="#b5">[6]</ref>, using a refinement due to <ref type="bibr" target="#b4">[5]</ref>.</p><p>Let P, V be an interactive proof (resp. argument) for a language L, and consider a concurrent adversary (verifier) V * that, given input x ∈ L, interacts with an unbounded number of independent copies of P (all on common input x). The concurrent adversary V * is allowed to interact with the various copies of P concurrently, without any restrictions over the scheduling of the messages in the different interactions with P (in particular, V * has control over the scheduling of the messages in these interactions).</p><p>The transcript of a concurrent interaction consists of the common input x, followed by the sequence of prover and verifier messages exchanged during the interaction. We denote by view P V * (x) a random variable describing the content of the random tape of V * and the transcript of the concurrent interaction between P and V * .</p><p>Following <ref type="bibr" target="#b4">[5]</ref>, we overcome subtle issues that arise in the context of black-box cZK by allowing the existence of a different simulator S q for every V * that runs at most q(|x|) concurrent sessions. (This is in contrast to the customary definition of "stand-alone" black-box ZK in which it is required that there exists a "universal" simulator that works for all potential verifiers V * .) Definition 1 (Black-Box cZK) Let P, V be an interactive proof system for a language L. We say that P, V is black-box concurrent zero-knowledge if for every polynomial q(•), there exists a probabilistic polynomial-time algorithm S q , so that for every concurrent adversary V * that runs at most q(|x|) concurrent sessions, S q (x) runs in time polynomial in q(|x|) and |x|, and satisfies that the ensembles {view P V * (x)} x∈L and {S q (x)} x∈L are computationally indistinguishable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">A new cZK Proof System for N P</head><p>In this section we present a high-level description of our protocol, as well as a description of the black-box simulator that establishes its zero-knowledge property.</p><p>Our protocol is inspired by the RK protocol <ref type="bibr" target="#b20">[21]</ref> and uses the well known 3-round protocol for Hamiltonicity by Blum <ref type="bibr" target="#b1">[2]</ref> as a building block. The crucial property of Blum's protocol that we need in order to construct a concurrent zero-knowledge simulator is that the simulation task becomes trivial as soon as the verifier's message is known in advance. That is, if the prover knows the verifier's "secret" prior to the beginning of the protocol then it can always make the verifier accept (regardless of whether the graph is Hamiltonian). This is done by adjusting the prover's messages according to the contents of the verifier's "secret" (which, as we said, is known in advance).</p><p>We stress that the choice of Blum's protocol as a building block is arbitrary (and is made just for simplicity of presentation). In fact, the above property is satisfied by many other known protocols. Any one of these protocols could have been used as a building block for our construction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The Protocol</head><p>We let k be any super-logarithmic function in n. Our protocol consists of two stages. In the first stage (or preamble), which is independent of the actual common input, the verifier commits to a random n-bit string σ, and to two sequences, {σ 0 i,j } k i,j=1 , and</p><formula xml:id="formula_0">{σ 1 i,j } k i,j=1</formula><p>, each consisting of k 2 random n-bit strings (this first message employs a perfectlyhiding commitment scheme and is called the initial commitment of the protocol). The sequences are chosen under the constraint that for every i, j the value of σ 0 i,j ⊕ σ 1 i,j equals σ. This is followed by k iterations so that in the j th iteration the prover sends a random k-bit string, b j = b 1,j , . . . , b k,j , and the verifier decommits to σ b1,j 1,j , . . . , σ b k,j k,j . In the second stage, the prover and verifier engage in the 3-round protocol for Hamiltonicity, where the "secret" sent by the verifier in the second round of the Hamiltonicity protocol equals σ (at this point the verifier also decommits to all the values σ, {σ 1-bi,j i,j } k i,j=1 that were not revealed in the first stage). The protocol is depicted in Figure <ref type="figure" target="#fig_0">1</ref>.</p><p>Intuitively, since in an actual execution of the protocol, the prover does not know the value of σ, the protocol constitutes a proof system for Hamiltonicity (with negligible soundness error). However, knowing the value of σ in advance allows the simulation of the protocol: Whenever the simulator may cause the verifier to reveal both σ 0 i,j and σ 1 i,j</p><p>for some i, j (this is done by the means of rewinding the verifier after the values σ b1,j 1,j , . . . , σ b k,j k,j have been revealed), it can simulate the rest of the protocol (and specifically Stage 2) by adjusting the first message of the Hamiltonicity protocol according to the value of σ = σ 0 i,j ⊕ σ 1 i,j (which, as we said, is obtained before entering the second stage).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>First stage:</head><p>V → P : Commit to σ, {σ 0 i,j } k i,j=1 , {σ 1 i,j } k i,j=1 . σ 0 i,j ⊕ σ 1 i,j = σ for every i, j. For j = 1, . . . , k:</p><formula xml:id="formula_1">P → V : Send b1,j, . . . , b k,j r ← {0, 1} k . V → P : Decommit to σ b 1,j 1,j , . . . , σ b k,j k,j .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Second stage:</head><p>P → V : Send first message of Hamiltonicity protocol.</p><p>V → P : Decommit to σ and to {σ</p><formula xml:id="formula_2">1-b i,j i,j</formula><p>} k i,j=1 . P → V : Answer according to the value of σ. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The Simulator</head><p>Let (V0), (P1), (V1), . . . , (Pk ), (Vk ) denote the 2k + 1 first stage messages in our protocol and let (p1), (v1), (p2) denote the three (second stage) messages in the Hamiltonicity proof system. Loosely speaking, the simulator is said to rewind the the j th round if after receiving a (Vj ) message, it "goes back" to some point preceding the corresponding (Pj ) message and "re-executes" the relevant part of the interaction until (Vj ) is reached again.</p><p>Note that, if the simulator manages to receive (Vj ) as answer to two different (Pj ) messages (due to rewinding) the simulator has obtained both σ 0 i,j and σ 1 i,j for some i ∈ {1, . . . , k}. If this happens in even one of the rounds j in the first stage, then it reveals the verifier's "secret" (which is equal to σ 0 i,j ⊕ σ 1 i,j ). Once the secret is revealed, the simulator can cheat arbitrarily in the second stage of the protocol.</p><p>To simplify the analysis, we let the simulator always pick the (Pj )'s uniformly at random. Since the length of the (Pj ) messages is super-logarithmic, the probability that any two (Pj ) messages sent during the simulation are equal is negligible.</p><p>Motivating discussion. The binding property of the initial commitment guarantees us that, once σ 0 i,j and σ 1 i,j have been revealed, the verifier cannot "change his mind" and decommit to σ = σ 0 i,j ⊕ σ 1 i,j on a later stage. However, this remains true only if we have not rewound past the initial commitment. As observed by Dwork et al. <ref type="bibr" target="#b5">[6]</ref>, rewinding a specific session in the concurrent setting may result in rewinding past the initial commitment of other sessions. This means that the "work" done for these sessions may be lost (since once we rewind past the initial commitment of a Input: (ℓ, hist, T )</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Bottom level (ℓ = 1):</head><p>• Uniformly choose a first stage prover message p, and feed V * with (hist, p).</p><p>• Store V * 's answer v, in T .</p><p>• Output (p, v), T .</p><p>Recursive step (ℓ &gt; 1):</p><p>• Set (p1, ṽ1, . . . , pℓ/2 , ṽℓ/2 ), T1 ←SIMULATE(ℓ/2, hist, T ).</p><p>• Set (p1, v1, . . . , p ℓ/2 , v ℓ/2 ), T2 ← SIMULATE(ℓ/2, hist, T1).</p><p>• Set (p ℓ/2+1 , ṽℓ/2+1 , . . . , pℓ , ṽℓ ), T3 ←SIMULATE(ℓ/2, (hist, p1, v1, . . . , p ℓ/2 , v ℓ/2 ), T2).</p><p>• Set (p ℓ/2+1 , v ℓ/2+1 , . . . , p ℓ , v ℓ ), T4 ← SIMULATE(ℓ/2, (hist, p1, v1, . . . , p ℓ/2 , v ℓ/2 ), T3).</p><p>• Output (p1, v1, . . . , p ℓ , v ℓ ), T4. session all σ bi,j i,j values that we have gathered in this session become irrelevant). Consequently, the simulator may find himself doing the same amount of "work" again.</p><p>The rewinding strategy. The big question is how to design a simulation strategy that will manage to overcome the above difficulty. In this work we follow the approach taken by Kilian and Petrank <ref type="bibr" target="#b17">[18]</ref> and let the simulator determine the order and timing of its rewindings obliviously of the concurrent scheduling.</p><p>The rewinding strategy of our simulator is specified by the SIMULATE procedure. The goal of the SIMULATE procedure is to supply the simulator with V * 's "secret" for each session before reaching the second stage in the protocol. As discussed above, this is done by rewinding the interaction with V * while trying to make the verifier answer two different challenges (Pj ).</p><p>The timing of the rewindings performed by the SIM-ULATE procedure depends only on the number of verifier messages received so far (and on the size of the schedule). For the sake of simplicity, we currently ignore second stage messages and refrain from specifying the way they are handled. On a very high level, the SIMULATE procedure splits the first stage messages it is about to explore into two halves and invokes itself recursively twice for each half (completing the two runs of the first half before proceeding to the two runs of the second half).</p><p>At the top level of the recursion, the messages that are about to be explored consist of the entire schedule, whereas at the bottom level the procedure explores only a single message (at this level, the verifier message explored is stored in a special data-structure, denoted T ). The solve procedure always outputs the sequence of "most recently explored" messages.</p><p>The input to the SIMULATE procedure consists of a triplet (ℓ, hist, T ). The parameter ℓ corresponds to the number of verifier messages to be explored, the string hist is a transcript of the current thread of interaction, and T is a table containing the contents of all the messages explored so far (to be used whenever the second stage is reached in some session). <ref type="foot" target="#foot_1">2</ref>The simulation is performed by invoking the SIMULATE procedure with the appropriate parameters. Specifically, whenever the schedule contains m = poly(n) sessions, the SIMULATE procedure is invoked with input (m(k+2), φ, φ) (where m(k +2) is the total number of verifier messages in a schedule of m sessions). The SIMULATE procedure is depicted in Figure <ref type="figure" target="#fig_1">2</ref>.</p><p>If the simulation reaches the second stage (the main ZK proof part) in the protocol at any time, without the secret having been extracted, the simulator commits to a random string. <ref type="foot" target="#foot_2">3</ref> But if subsequently the verifier sends the message (v1) to reveal a secret consistent with its earlier messages, the simulator "gets stuck," i.e., it cannot continue the proof as in the original protocol and keep it indistinguishable from an actual proof. Then it gives up the entire simulation and outputs ⊥.</p><p>A slot in the simulation consists of two messages: a prover message and the next verifier message. The two messages of a slot may be from different sessions; but for each verifier message, the next message in the simulation is the simulated prover's reply to it (in the same session). The simulator will rewind to points between slots. A session during the run of the simulator is identified by the slot in the simulation where the first message of the session, namely the initial commit message (V0) from the verifier, arrives (thereby ending that slot).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Blocks</head><p>We define a block as the part of execution of the simulator within an invocation of the SIMULATE procedure. The smallest block is a single slot, corresponding to the base of recursion. The other blocks are composed of four blocks of the next lower level.</p><p>Figure <ref type="figure" target="#fig_2">3</ref> illustrates one block. The way in which the history is passed to the lower level invocations tie them together as shown. The invocation of the (lower level) block called 1 ′ in the top thread corresponds to the first (lookahead) call. It is truncated immediately (i.e., its history is not continued further) as the simulator rewinds when the call returns; the second call (block marked 1) starts off with the same history as the first one, as indicated by the first fork in the thread; the resulting thread continues, as the SIMU-LATE procedure goes to the next half in the recursion. Again the first call is truncated by rewinding, and the history from the second call is passed to the outside of the block.</p><p>Of these four blocks, the first one (in Figure <ref type="figure" target="#fig_2">3</ref>, 1 ′ ) is called the look-ahead block of the second one (1). Similarly the third block (2 ′ ) is the look-ahead block of the fourth one <ref type="bibr" target="#b1">(2)</ref>. Every block except the one at the top-most level either is a look-ahead block or has a look-ahead block. A block may contain another block of a lower level, but no two blocks can ever overlap otherwise.  A thread from the initial point of simulation, up to a slot x corresponds to the transcript of the simulated protocol when the simulation reaches x.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">High Level Analysis of the Simulator</head><p>In order to prove the correctness of the simulation, it will be sufficient to show that for every adversary verifier V * , the three conditions corresponding to the following subsections are satisfied. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">The simulator runs in polynomial-time</head><p>Each invocation of the SIMULATE procedure with parameter ℓ &gt; 1 involves four recursive invocations of the SIMU-LATE procedure with parameter ℓ/2. In addition, the work invested at the bottom of the recursion (i.e., when ℓ = 1) is upper bounded by poly(n). Thus, the recursive work</p><formula xml:id="formula_3">W (m•(k +1)), that is invested by the SIMULATE procedure in order to handle m • (k + 1) (first stage) verifier messages satisfies W (m • (k + 1)) ≤ (m • (k + 1)) 2 • poly(n) = poly(n).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">The simulator's output is "correctly" distributed</head><p>Indistinguishability of the simulator's output from V * 's view (of m = poly(n) concurrent interactions with P ) is shown assuming that the simulator does not "get stuck" and output ⊥ during its execution (see the next section). Since the simulator S will get stuck only with negligible probability, indistinguishability will immediately follow. The key for proving the above lies in the following two properties:</p><p>• First stage messages output by S are identically distributed to first stage messages sent by P . This is proved based on the definition of the simulator's actions. (Note that this property is easier to prove for our protocol than it is for the RK protocol.)</p><p>• Second stage messages output by S are computationally indistinguishable from second stage messages sent by P . This is proved based on the fact that the verifier cannot feasibly distinguish between the prover using a real witness and the prover cheating by knowing the secret string used by the verifier. This follows from the security of the commitment scheme used by the prover inside the ZK proof system employed in the second stage of the protocol.</p><p>A formal proof can be given using a hybrid simulator which differs from the original simulator only in that for each session s, it knows the witness for x s ∈ L, and uses that for the second stage. Though the hybrid simulator does not use the entries in the Solution Table, it also fails if it reaches the last message in an unsolved session. In the sequel, we shall analyse this hybrid simulator.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">The simulator (almost) never "gets stuck"</head><p>This is the most involved part of the proof. What is required is to show that whenever a session in the simulation reaches the second stage of the protocol, the simulator has already solved it -i.e., managed to obtain the value of the verifier's "secret" corresponding to that session (if there is a valid secret for the session) with overwhelming probability.</p><p>The adversarial verifier is said to succeed on a random tape of the simulator, if the simulator gets stuck in some session s. Recall that a session is specifed by the "startslot." In contrast, the simulator is said to secure a session if it does not get stuck in that session (but the simulator may still get stuck in some other session). We would like to bound the probability that the adversary succeeds in any session.</p><p>We shall bound this probability for each setting of the coin flips of the verifier. So now onwards we fix the coin flips of the verifier and consider the probability with respect to the coin-flips of the simulated prover only. So given the random tape of the simulator (i.e., the randmoness used to generate the prover messages), the entire execution of the simulator is determined.</p><p>To bound the probability that the adversary succeeds we have to bound the number of random tapes on which the adversary succeeds. We shall show that for every random tape on which the adversary succeeds with respect to a particular session s, there are many other tapes with which that is not the case (taking care not to double-count the tapes). In the sequel we restrict ourselves to random tapes which cause the simulator to never pick two identical challenges; this does not affect the probabilities by more than a negligible fraction.</p><p>Lemma 1 Let R be the set of all random tapes used by the simulator. There exists a mapping f : R → 2 R such that for every R ∈ R, if the adversary succeeds on R for a session s, then</p><formula xml:id="formula_4">1. ∀R ′ ∈ R\{R}, f (R) ∩ f (R ′ ) = φ 2. |f (R)| ≥ 2 k-O(h)</formula><p>, where h is the maximum depth of recursion of the simulator.</p><p>3. ∀R ′ ∈ f (R)\{R}, the simulator secures s on random tape R ′ .</p><p>We shall sketch the proof of this lemma in the next section, but before that note that it achieves our goal. Since all the random tapes are equally probable, the next lemma follows immediately from Lemma 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 2</head><p>The probability that the adversary succeeds for a given session s is at most 2 -(k-O(h)) . Now we prove the assertion of this section: The number of possible sessions is at most the number of slots, and therefore poly(n). (When the simulator is simulating a concurrent session involving at most ℓ messages, the number of slots in the simulation is at most ℓ 2 .) Thus by union bound, Lemma 2 implies that the probability of the simulator getting stuck (i.e., that of the adversary succeeding with respect to some session) is at most</p><formula xml:id="formula_5">poly(n)2 -(k-O(h))</formula><p>. This is negligible in n as we take k = ω(log n), and h = O(log n). The latter follows, because h, the depth of the recursion, is logarithmic in the number of slots.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Proof Sketch of Lemma 1</head><p>Here we sketch the proof of Lemma 1. (A more complete proof is included in the full version of this paper).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Overview</head><p>Let the adversary succeed on the random tape (deck) R, in session s which starts at a slot start (when the message (V0) arrives) and ends at the slot stop (at whose beginning the simulator gets stuck unable to send (p2)). The map f is established by demonstrating a procedure which takes R and outputs at least 2 k-O(h) distinct tapes in which the simulator secures s. To show that f (R) ∩ (R ′ ) = φ we will demonstrate an inverse procedure which takes any tape in f (R) and gives back R.</p><p>The random-tape of the simulator can be considered a concatenation of the random strings used at each slot (normalized to the same length). Imagine that each such random string is a card drawn from a large universe, and the random tape is a deck of such cards. Then, each tape output by the procedure is obtained by shuffling the input deck. That is, the order in which the different random strings are used is changed, but the random strings themselves are not altered.</p><p>Spans. Suppose the verifier sends a correct message (Vj ) in session s in response to prover's challenge in a message (Pj ). The prover's challenge (Pj ) starts a slot x and the subsequent verifier's answer ends a slot y (the two slots may be the same). The set of slots along the x-y thread, between (and inclusive of) x and y is called a span.</p><p>Let us call the segment of the thread between, but not including, the slots start and stop the start-stop segment. Since the simulator reaches (p2) at the slot stop, within the start-stop segment the prover (simulator) must send the k challenges (P1), . . . , (Pk ), and the verifier must properly answer in messages (V1), . . . , (Vk ). Thus the start-stop segment is partitioned into k spans.</p><p>A span is called good if the challenge at the beginning of the span is correctly answered in the verifier message at the end of the span. With the random tape R all the k spans in the start-stop segment are good, and there are no other good spans.</p><p>Shuffling Threads. The random strings (cards) in all the slots along a thread fixes the execution of that thread <ref type="foot" target="#foot_3">4</ref> So if we move the randomness in a thread (or in a segment thereof) to some other thread (or its segment), the execution in the latter will be identical to that of the former before the change, as long as the two threads or segments in question fork off from the same point.</p><p>Suppose that there is a look-ahead thread that starts after the slot start, but is not as long as the start-stop segment, and that the execution in the start-stop segment were to be advanced to that thread. Then if the latter thread is long enough, at least one of the k good spans originally in the start-stop segment, with messages (Pj ) and (Vj ) say, will appear in that thread. If that happens the simulator would have secured the session (i.e., it will not get stuck in that session) by the time it rewinds out of that thread, because if the verifier answers a later challenge (Pj ) correctly (since we are assuming that no two challenges are the same), it can successfully extract the secret σ for session s.</p><p>The above observation suggests that from a random tape in which the adversary succeeds for a session s, just by swapping the randomness of the "crashing thread" with that of many other appropriate threads, we get random tapes in which the session s is secured. But the resulting mapping is not invertible. For our counting argument to go through smoothly, we do a slightly more sophisticated mapping, as explained in Section 5.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Shuffling by Swapping Blocks</head><p>The aim of the shuffling procedure is to establish that there are some non-overlapping "swappable" segments (each containing one good span) in the start-stop thread, and for each segment there are many segments with which it can be swapped. Further each of these swappings can be carried out independently one after the other, and still the entire swapping remains invertible. We shall show that there are at least 2 k-O(h) distinct tapes that can be produced by these swappings, all of which will allow the simulator to secure session s.</p><p>The shuffling procedure can be described in terms of the block structure of the execution of the simulator as described in Section 3.3. A block is said to be swappable if it is the smallest block containing a good span, it does not properly contain any other good span, and it does not contain the slots start or stop. Note that the minimal block containing a good span, as long as it does not contain start or stop, either is a swappable block, or contains a swappable block. The part of the start-stop segment inside a swappable block is called a swappable segment. A swappable segment will be swapped with some other segments as described shortly.</p><p>The swappable blocks are ordered according to the order of their associated spans. A block is called an allied block of a swappable block B if (a) it contains (or is) B, but does not contain the previous swappable block, and (b) does not contain the start or stop slots.</p><p>A swappable block B is an allied block of itself. At each higher level, there is one allied block of B, namely the one containing the allied block of the lower level, up to the level at which the block containing B also contains its previous swappable block or start or stop. The number of allied blocks of B will be denoted by t B .</p><p>Note that since an allied block cannot contain the start or stop slots, the start-stop segment enters the block and leaves it. Such a block cannot be a look-ahead block (as defined in Section 3.3), because a look-ahead block cannot have any thread continuing out of it. Thus every allied block has a look-ahead block. We are now ready to outline the shuffling strategy.</p><p>Basic-Shuffle. The entire shuffling of a thread is composed of many basic-shuffles, each of which works on a swappable block. The basic-shuffle is a hierarchical procedure involving the allied blocks of a swappable block. We illustrate this through an example. A formal description is available in the full version of this paper.</p><p>Figure <ref type="figure" target="#fig_5">5</ref> shows how the swappable block marked 1 in the lower thread AP Q is shuffled up to the upper thread ABC. The block marked 1 * (in thread ABC) is called the target. The allied blocks of 1 are blocks marked 1, 2 and 3, and the blocks containing 1 * at the corresponding levels are marked 1 * , 2 * and 3 * . First, block 1 is swapped with its look-ahead block 1 ′ , as 1 * is a look-ahead block. But blocks 2 and 2 ′ are not swapped, because 2 * is not a look-ahead block. Finally blocks 3 and 3 ′ are swapped with each other as 3 * is a look-ahead block, completing the basic-shuffle.</p><p>For a swappable block B, by choosing at each of the t B levels whether to swap the allied block with its look-ahead block or not, the above strategy specifies 2 tB targets with which B can be shuffled (one of them being itself). (In our example this number is 2 3 .) Inverting a Basic-Shuffle. Suppose the r-th swappable block (ordered according to the order of the spans associated with the swappable blocks) with the original random tape R is B, and it was shuffled to a target block B * to get the tape R ′ . Inverting this basic-shuffle involves recovering R from R ′ , as well as identifying the target block B * . The latter ensures that the tapes obtained by shuffling B with the different targets of B are indeed distinct.</p><p>We note that shuffling B does not change anything outside the outer-most allied block and its look-ahead block. In particular, all the previous r -1 swappable blocks in the simulation remain unchanged. Also, the shuffling makes the execution of B * identical to that of B before the shuffle. Further, the execution of every block till B * with R ′ , is identical to that of some block before B, with the tape R. Thus B * becomes the r-th swappable block after the shuffle. This makes it possible to identify the target block of the shuffle by inspecting R ′ . This is crucially used for inverting the mapping. 5   5 Note that if a simpler shuffling strategy of exchanging the randomness in the two threads to be shuffled is used, this may no longer be true. In our illustration, if we just swap the randomness in the two threads ABC and AP Q, the execution in the segment BX for instance, will be unpredictable (and in particular may introduce a good span in BX and introduce an associated swappable block). This is because, in the original random Having identified B * , we are ready to start our unshuffling. We set B * as the current block. Next we check if it is a look-ahead block or not. If it is, then it means it reached there due to a swap. So it is swapped to become a non-lookahead block, and the current-block is also changed to the resulting block. Then we check if the block containing the current-block is an allied block (i.e., we check if it contains the r -1-th swappable block or the start or stop slots). If it is, we make it the current-block and repeat by checking if it is a look-ahead block, and if necessary swapping. We continue this way until the current block becomes the maximal allied block. It is not hard to see that this operation undoes the basic-shuffle which takes B to B * .</p><p>Shuffling the entire thread. To shuffle the entire thread, the above basic-shuffle procedure is carried out on each of the swappable blocks. This is done from right to left, i.e., the last (in simulation order) swappable block is shuffled first, then the previous one, and so on. The first basic-shuffle does not change the execution of any of the previous swappable blocks (as all the segments involved in a swapping occur after the previous swappable segments). Then the next swappable block is swapped and so on. This ensures that the unswapping can be done, in the reverse order, first swapping back the earliest swappable segment, then the next and so on.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Counting Swaps</head><p>By the above, the random tape R can be invertibly mapped to Π B 2 tB = 2 È B tB tapes, where the summation is over all swappable segments B. So to prove condition (2) of Lemma 1 we need to count the total number of allied blocks of all swappable blocks for the random tape R.</p><p>If B is a block which does not contain start or stop, then we have the following: (1) For every good span q, if B is the smallest block containing q, then B is either a swappable block or contains a swappable block. (2) B is an allied block of the first swappable block that it contains, if it contains at least one swappable block. (3) Therefore, B is an allied block (of the first swappable block that it contains) if it contains at least one good span.</p><p>Suppose we map each of the k good spans in the startstop segment to the smallest block containing it. Then, a block B can have at most one span mapped to it; this is because a span mapped to B must include slots in both halves of the B, and the k spans are all disjoint. Thus there are at least k blocks which contain at least one good span. Of these, at most h blocks contain the slot start, and similarly for stop. Thus by Observation 3 above, at least k-2h tape there was no thread with the randomness same as in the thread ABX after the swap. But when the swap is carried out systematically as illustrated above, every thread before ABC was already present in the original setting, and none of them had a good span in them. blocks are allied blocks, there by proving condition (2) of Lemma 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Securing the session</head><p>Out of all the new random tapes obtained by the strategy above, there is one which is identical to the original tape R. In any other tape R ′ ∈ f (R), there is one good span outside the start-stop segment, in a look-ahead block, namely the target of the left-most swappable block swapped. As described earlier, if the call to SIMULATE returns from that look-ahead segment to a point after the start slot, the simulator will be able to find the secret of the verifier (conditional on all the challenges of the simulator being distinct) the next time it goes through the same round in that session. But we know that the call to SIMULATE will return because the block swapped did not contain the slot stop, and that it will return to a point after the start slot because it did not contain the slot start. Thus on all random strings obtained above except for the original adversarially given one, the simulator indeed secures the session which began at start. (The simulation may still get stuck, but only for a different session. The union bound argument given in Section 4.3 shows that this can't happen too often, and the proof goes through.) This completes the proof of Lemma 1</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Our cZK protocol. The first stage is independent of the common input and consists of k iterations. The second stage consists of a 3-round proof of Hamiltonicity.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. The rewinding strategy of the simulator. Even though messages (p 1 , ṽ1 , . . . , pℓ , ṽℓ ) do not explicitly appear in the output, some of them do appear in the table T 4 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. The Threads of execution of the simulator. The shaded blocks hide the threads in the recursive calls. The block returns the messages from blocks 1 and 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4</head><label>4</label><figDesc>Figure4illustrates the "threads" in the simulation. A thread refers to a path from left to right in such a figure. A thread from the initial point of simulation, up to a slot x corresponds to the transcript of the simulated protocol when the simulation reaches x.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. A block in the execution of the simulator. The shaded boxes correspond to blocks two levels below the block shown. The lines indicate the different "threads" of execution taken by the simulator.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. A basic-shuffle can move the swappable block 1 to the block 1 * , one of its 8 target blocks.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>f (n) = Θ(h(n)) if both f (n) = Õ(h(n)) and f (n) = Ω(h(n)).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>The messages stored in T are used in order to determine the verifier's "secret" according to "different" answers to (Vj ).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>If the secret has been extracted, it is used to manufacture a message which helps the simulator complete the proof later.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>Recall that the hybrid simulator that we are analysing does not make use of the table T . Also, the verifier is assumed to be deterministic.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Acknowledgements</head><p>We gratefully thank Joe Kilian for sharing his thoughts with us and generously giving us his permission to use and build up on his suggestion <ref type="bibr" target="#b16">[17]</ref> for an analysis which avoids the dangers involved in earlier similar analyses involving subtle arguments based on conditional probability.</p><p>We are grateful to Oded Goldreich for his support, for enlightening conversations and for giving many useful remarks on previous manuscripts. We are also grateful to Moni Naor for discussions leading to the new cZK protocol. Thanks also to Uri Feige, Ronen Shaltiel and Erez Petrank for helpful discussions.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">How to go Beyond the Black-Box Simulation Barrier</title>
		<author>
			<persName><forename type="first">B</forename><surname>Barak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">42nd FOCS</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="106" to="115" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">How to prove a Theorem So No One Else Can Claim It</title>
		<author>
			<persName><forename type="first">M</forename><surname>Blum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the International Congress of Mathematicians</title>
		<meeting>of the International Congress of Mathematicians<address><addrLine>Berekeley, California, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="1444" to="1451" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Minimum Disclosure Proofs of Knowledge</title>
		<author>
			<persName><forename type="first">G</forename><surname>Brassard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Chaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Crépeau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JCSS</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="156" to="189" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Resettable Zero-Knowledge</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">32nd STOC</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="235" to="244" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Black-Box Concurrent Zero-Knowledge Requires Ω(log n) Rounds</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Petrank</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rosen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">33rd STOC</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="570" to="579" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Concurrent Zero-Knowledge</title>
		<author>
			<persName><forename type="first">C</forename><surname>Dwork</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">30th STOC</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="409" to="418" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Concurrent Zero-Knowledge: Reducing the Need for Timing Constraints</title>
		<author>
			<persName><forename type="first">C</forename><surname>Dwork</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Crypto98, Springer LNCS 1462</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="442" to="457" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Alternative Models for Zero Knowledge Interactive Proofs</title>
		<author>
			<persName><forename type="first">U</forename><surname>Feige</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
		<respStmt>
			<orgName>Weizmann Institute of Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Witness Indistinguishability and Witness Hiding Protocols</title>
		<author>
			<persName><forename type="first">U</forename><surname>Feige</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">22nd STOC</title>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="416" to="426" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Concurrent Zero-Knowledge with Timing -Revisited</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
	<note>To appear, in 34th STOC</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<title level="m">Foundation of Cryptography -Basic Tools</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">On the Composition of Zero-Knowledge Proof Systems</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Computing</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="169" to="192" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Proofs that Yield Nothing But Their Validity or All Languages in NP Have Zero-Knowledge Proof Systems</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JACM</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="691" to="729" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The Knowledge Complexity of Interactive Proof Systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rackoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="186" to="208" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A Digital Signature Scheme Secure Against Adaptive Chosen Message Attacks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="281" to="308" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Construction of Pseudorandom Generator from any One-Way Function</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hastad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Impagliazzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Luby</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Jour. on Computing</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1364" to="1396" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Personal Communication</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Concurrent and Resettable Zero-Knowledge in Poly-logarithmic Rounds</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Petrank</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">33rd STOC</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="560" to="569" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Lower Bounds for Zero-Knowledge on the Internet</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Petrank</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rackoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">39th FOCS</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="484" to="492" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Bit Commitment using Pseudorandomness</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Jour. of Cryptology</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="151" to="158" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">On the Concurrent Composition of Zero-Knowledge Proofs</title>
		<author>
			<persName><forename type="first">R</forename><surname>Richardson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EuroCrypt99, Springer LNCS 1592</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="415" to="431" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A note on the round-complexity of Concurrent Zero-Knowledge</title>
		<author>
			<persName><forename type="first">A</forename><surname>Rosen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Crypto2000, Springer LNCS 1880</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="451" to="468" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
