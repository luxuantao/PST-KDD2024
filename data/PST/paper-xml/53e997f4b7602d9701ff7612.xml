<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Information-Theoretic Cryptography</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Ueli</forename><surname>Maurer</surname></persName>
							<email>maurer@inf.ethz.ch</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Swiss Federal Institute of Technology (ETH)</orgName>
								<address>
									<postCode>CH-8092</postCode>
									<settlement>Zurich, Zurich</settlement>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Information-Theoretic Cryptography</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">D20D2D80A96C0FCB4B1775045133B217</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T04:17+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Information theory</term>
					<term>unconditional security</term>
					<term>conditional independence</term>
					<term>information-theoretic primitive</term>
					<term>generalized random oracle</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We discuss several applications of information theory in cryptography, both for unconditional and for computational security. Unconditionally-secure secrecy, authentication, and key agreement are reviewed. It is argued that unconditional security can practically be achieved by exploiting the fact that cryptography takes place in a physical world in which, for instance due to noise, nobody can have complete information about the state of a system. The general concept of an information-theoretic cryptographic primitive is proposed which covers many previously considered primitives like oblivious transfer, noisy channels, and multi-party computation. Many results in information-theoretic cryptography can be phrased as reductions among such primitives We also propose the concept of a generalized random oracle which answers more general queries than the evaluation of a random function. They have applications in proofs of the computational security of certain cryptographic schemes. This extended abstract summarizes in an informal and non-technical way some of the material presented in the author's lecture to be given at Crypto '99.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Historically, information theory and cryptography are closely intertwined, although the latter is a much older discipline. Shannon's foundation of information theory <ref type="bibr" target="#b39">[40]</ref> was motivated in part by his work on secrecy coding during the second world war, and it may be for this reason that his work was not de-classified until 1948 when his seminal paper was published. His 1949 companion paper on the communication theory of secrecy systems <ref type="bibr" target="#b38">[39]</ref> was, like Diffie and Hellman's later discovery of public-key cryptography <ref type="bibr" target="#b18">[19]</ref>, a key paper in the transition of cryptography from an art to a science.</p><p>There are two types of cryptographic security. The security of a cryptographic system can rely either on the computational infeasibility of breaking it (computational security), or on the theoretical impossibility of breaking it, even Supported in part by the Swiss National Science Foundation, grant no. 20-42105.94.</p><p>using infinite computing power (information-theoretic or unconditional security). Because no computational problem has been proved to be computationally difficult for a reasonable model of computation, the computational security of every practical cryptographic system relies on an unproven intractability assumption. In contrast, information-theoretically secure systems rely on no such assumptions, but they rely on an assumption about the probabilistic behavior of the universe, for instance of a noisy channel or a quantum measurement. However, even computationally-secure systems rely on such assumptions, at least the tacitly made assumption that random keys can be generated and that they are independent of an adversary's entire a priori knowledge.</p><p>While information-theoretic security is stronger than computational security, it is usually less practical. In fact, Shannon's proof that perfect secrecy requires a secret key of the same length as the plaintext is often taken as evidence that unconditional security can never be practical. However, this precipitate jump to conclusions should be reconsidered: in contrast to Shannon's model, in which his result holds, cryptography takes place in a physical world (every communication channel is based on a physical process) in which nobody can have complete information about the state of a system, for instance due to noise or theoretical limitations of quantum physics.</p><p>Information theory has several applications in cryptography. First, it allows to prove the unconditional security of cryptographic systems. Second, it allows to prove impossibility and lower bound results on the achievability of unconditional security. Third, it is a key tool in reduction proofs showing that breaking a cryptographic system is as hard as breaking an underlying cryptographic primitive (e.g. a one-way function or a pseudo-random function).</p><p>In this extended abstract we give an overview of known applications and results of information theory in cryptography. Due to space limitations we cannot give a complete overview of the extensive literature on the subject. The treatment is informal and non-technical, emphasizing concepts and general viewpoints. In Section 2, we review some basic concepts of information theory and state two basic facts on conditional independence. In Section 3, we summarize known results on unconditional secrecy, authentication, and key agreement. In Section 4 we take a general approach to cryptographic primitives and reductions among them. The concept of generalized random oracles is sketched briefly in Section 5, followed by some conclusions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Random Variables, Entropy, and Conditional Independence</head><p>Information theory, like statistics, is a mathematical theory based on probability theory. <ref type="foot" target="#foot_1">1</ref> In almost all applications of probability theory in cryptography one considers a discrete random experiment which is conceptually very simple: it is defined by a finite or countably infinite set called the sample space, consisting of all elementary events, and a probability measure assigning a non-negative real number to every elementary event, such that the sum of all these probabilities is equal to 1. An event of a discrete random experiment is a subset of the sample space, and the probability assigned to it is the sum of the probabilities of its elementary events. A discrete random variable X is a mapping from the sample space to a certain range X and is characterized by its probability distribution P X that assigns to every x ∈ X the probability P X (x) of the event that X takes on the value x.</p><p>The entropy of a random variable X is a real number that measures the uncertainty about the value of X when the underlying random experiment is carried out. It is defined as</p><formula xml:id="formula_0">H(X) = - x P X (x) log 2 P X (x),</formula><p>assuming here and in the sequel that terms of the form 0 log 0 are excluded from the summation. The particular formula will be irrelevant below, but we need certain important properties of entropy. It is easy to verify that 0 ≤ H(X) ≤ log 2 |X | with equality on the left if and only if P X (x) = 1 for some x ∈ X and with equality on the right (for finite X ) if and only if</p><formula xml:id="formula_1">P X (x) = 1/|X | for all x ∈ X .</formula><p>The deviation of the entropy H(X) from its maximal value can be used as a measure of non-uniformity of the distribution P X . While there are other such non-uniformity measures (e.g., based on Rényi entropy and min-entropy, which have some interesting applications not discussed in this paper), the significance of Shannon entropy is that it satisfies some intuitive rules (e.g., the chain rule) and that it gives the right answer to fundamental questions in communication engineering: how much can (reversible) data compression reduce the size of a message, and how many information bits per channel use can be transmitted reliably over a given noisy communication channel?</p><p>When several random variables (e.g. X, Y, Z with joint distribution P XY Z ) are considered, they are always defined on the same random experiment. The definition of H(X) can be generalized to the definition of the joint entropy of two or more random variables. For instance, we have</p><formula xml:id="formula_2">H(XY Z) = -(x,y,z) P XY Z (x, y, z) log P XY Z (x, y, z).</formula><p>The conditional probability distribution P X|Y (•, y) of the random variable X, given the event Y = y, is defined by P X|Y (x, y) = P XY (x, y)/P Y (y) when P Y (y) = 0. For every such y ∈ Y, P X|Y (•, y) is a probability distribution satisfying x∈X P X|Y (x, y) = 1. The entropy of this distribution is the conditional entropy of X, given the event Y = y:</p><formula xml:id="formula_3">H(X|Y = y) = - x P X|Y (x, y) log 2 P X|Y (x|y).</formula><p>The conditional uncertainty of X, given the random variable Y , is defined as the average over all y of H(X|Y = y), and is not the entropy of a distribution:</p><formula xml:id="formula_4">H(X|Y ) = y∈Y:PY (y) =0 H(X|Y = y)P Y (y).</formula><p>One can show that additional knowledge can never increase entropy:</p><formula xml:id="formula_5">0 ≤ H(X|Y ) ≤ H(X),</formula><p>with equality on the left if and only if Y determines X (except when P Y (y) = 0) and with equality on the right if and only if X and Y are statistically independent (see below).</p><p>An important rule for transforming entropies is</p><formula xml:id="formula_6">H(XY ) = H(X) + H(Y |X),</formula><p>i.e., the joint entropy about X and Y is the entropy about X plus the additional entropy about Y , given that X is known. This so-called chain rule can be used repeatedly to expand</p><formula xml:id="formula_7">H(X 1 X 2 • • • X N ) as H(X 1 X 2 • • • X N ) = N n=1 H(X n |X 1 • • • X n-1 ).</formula><p>Note that the order in which variables are extracted is arbitrary. For example,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>H(XY Z) = H(X) + H(Y |X) + H(Z|XY ) = H(Y ) + H(Z|Y ) + H(X|Y Z).</head><p>The mutual information I(X; Y ) between two random variables X and Y is defined as the amount by which the uncertainty (entropy) about X is reduced by learning Y :</p><formula xml:id="formula_8">I(X; Y ) = H(X) -H(X|Y ).</formula><p>The term mutual stems from the fact that, as can easily be verified, I(X; Y ) = I(Y ; X) = H(Y ) -H(X|Y ). The conditional mutual information between X and Y , given the random variable Z, is defined as</p><formula xml:id="formula_9">I(X; Y |Z) = H(X|Z) -H(X|Y Z).</formula><p>We have I(X; Y |Z) = 0 if and only if X and Y are statistically independent when given Z.</p><p>Conditional independence is a fundamental concept in information-theoretic cryptography. Two events A and B are statistically independent, here denoted [A; B], if P (A ∩ B) = P (A) • P (B). In the following we will drop the symbol ∩ and use the shorter notation P (A, B) or simply P (AB) for P (A∩B). Two events A and B are conditionally independent, given the event C, denoted [A; B|C], if The concept of statistical independence and this notation can be extended to a situation where any of A, B and C can be either an event or a random variable. Independence when random variables are involved means that the independence relation holds when any random variable is replaced by the event that it takes on a particular value. For instance, if A is an event and X and Y are random variables, then [X; A|Y ] is equivalent to [X = x; A|Y = y] for all x and y.</p><formula xml:id="formula_10">P (A ∩ B ∩ C) • P (C) = P (A ∩ C) • P (B ∩ C)</formula><p>The following theorem stated without proof implies the rules for a calculus of conditional independence and is useful for simplifying certain security proofs. It states under which condition an event or random variable can be added to an independence set. Moreover, any random variables in an independence set can be dropped, and, if accompanied in the set only by other random variables, then it can also be moved to the conditioning set.</p><p>Theorem 1. Let S, T, U and V each be an event or a random variable (defined for the same random experiment). Then </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Unconditional Secrecy, Authenticity, and Key Agreement</head><p>One of the fundamental problems in cryptography is the transmission of a message M from a sender Alice to a receiver Bob such that an adversary Eve with access to the communication channel is unable to obtain information about M (secrecy). Moreover, if Eve has write-access to the channel, then Bob must not accept a fraudulent message modified or inserted by Eve (authenticity). This is achieved by Alice and Bob sharing a secret key K used together with the message to compute a ciphertext C to be transmitted over the channel. <ref type="foot" target="#foot_2">2</ref> The security can be either computational or information-theoretic, and we are here only interested in the latter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Unconditional Authentication</head><p>Unconditionally secure message authentication based on a shared secret key was first considered in <ref type="bibr" target="#b23">[24]</ref> and later in a large number of papers (e.g., see <ref type="bibr" target="#b43">[44]</ref>, <ref type="bibr" target="#b40">[41]</ref>, <ref type="bibr" target="#b41">[42]</ref>). Another line of research is devoted to proving lower bounds on the cheating probability as a function of the entropy of the key, H(K); see <ref type="bibr" target="#b32">[33]</ref> for a discussion and generalization of these bounds. Assume that the secret key K is used to authenticate a message M , resulting in ciphertext C, and let p I and p S denote Eve's probability of successfully creating a fraudulent message (impersonation attack) and of successfully replacing a valid message by a fraudulent message (substitution attack), respectively, then the following lower bounds hold for any authentication system, for an optimal cheating strategy: ) , and max(p</p><formula xml:id="formula_11">p I ≥ 2 -I(C;K) , p S ≥ 2 -H(K|C</formula><formula xml:id="formula_12">I , p S ) ≥ 2 -H(K)/2 .</formula><p>In other words, half of the key must be used for protecting against an impersonation attack, and the other half to prevent a substitution attack. These bounds can be generalized in various directions, for instance to a setting where n consecutive messages are authenticated using the same key. Then the cheating probability is lower bounded by 2 -H(K)/(n+1) . This bound can easily be achieved, when the message space is a subset of the k-bit strings, by a scheme based on polynomial evaluation (where the secret key consists of the n + 1 coefficients of a polynomial over GF (2 k ) of degree n), achieving cheating probability 2 -k . One can show that equality in the bounds cannot be achieved for larger message spaces. However, Gemmell and Naor <ref type="bibr" target="#b22">[23]</ref> proved that interactive protocols for authenticating a k-bit message can make more efficient use of the secret key than non-interactive protocols.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Unconditional Secrecy</head><p>It is well-known that the one-time pad <ref type="bibr" target="#b42">[43]</ref> provides perfect secrecy (though no authenticity unless the message is redundant), where perfect secrecy is the strongest possible type of security of an encryption system and is defined as the message M and the ciphertext C being statistically independent: <ref type="bibr" target="#b38">[39]</ref> proved that for every perfect system, H(K) ≥ H(M ), i.e. perfect secrecy requires an impractically large amount of secret key. A system that is perfect for every distribution P M of the message M is called robustly perfect. The (binary) key of such a system must be at least as long as the message; hence the one-time pad is optimal. Rather than proving Shannon's bound, we look at a more general setting below from which Shannon's result follows as a special case.</p><formula xml:id="formula_13">I(M ; C) = 0, or [M ; C]. Shannon</formula><p>In the following we assume that an insecure communication channel between Alice and Bob is available. Since we are interested in results on security and not primarily on communication efficiency, this assumption is made without loss of generality. It implies that a secure key agreement protocol implies a secure encryption scheme (e.g. using the one-time pad), and the reverse implication is trivial. Thus we can restrict our attention to key agreement. Similarly, if Bob accepts, he generates a key S depending on his view of the protocol. Even if a party does not accept, he or she may generate a key.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Unconditional</head><p>In the sequel we assume without loss of generality that S and S are binary strings of length |S| = |S | = k, where the goal is of course to make k as large as possible. Let t be the total number of messages and let</p><formula xml:id="formula_14">C t = [C 1 , . . . , C t ] denote the set of exchanged messages.</formula><p>Informally, a key agreement protocol is secure if the following conditions are satisfied <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b44">45]</ref>:</p><p>whenever Eve is only passive, then Alice and Bob both accept, and whenever one of the parties accepts, then -the other party has also generated a key (with or without accepting), and the two keys agree with very high probability (i.e. P [S = S ] ≈ 0), -the key S is very close to uniformly distributed, i.e. H(S) (and hence also H(S )) is very close to k, and -Eve's information about S, I(S; C t Z), given her entire knowledge, is very small (see the definition of Z below).</p><p>It appears obvious that if Alice and Bob do not share at least some partially secret information initially, they cannot generate an information-theoretically secure secret key S (i.e. H(S) = 0) if they can only communicate over a public channel accessible to Eve, even if this channel is authenticated. <ref type="foot" target="#foot_3">3</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>This follows from inequality (1) below and implies Shannon's bound H(K) ≥ H(M ).</head><p>In order for the key agreement problem to be interesting and relevant, we therefore need to consider a setting that takes into account the possibility that Alice and Bob each have some correlated side information about which Eve does not have complete information. Several such scenarios, practical and theoretical, have been considered. For instance, Fischer and Wright analyzed a setting in which Alice and Bob are assumed to have been dealt disjoint random deals of cards. More natural and realistic scenarios may arise from exploiting an adversary's partial uncertainty due to unavoidable noise in the communication channel or intrinsic limitations of quantum physics. We refer to <ref type="bibr" target="#b3">[4]</ref> for a discussion of quantum key agreement. The problem of designing information-theoretically secure key agreement protocols is hence to identify practical scenarios in which the adversary's total information can be bounded, and then to design a protocol that exploits this scenario.</p><p>Such a scenario can generally be modeled by assuming that Alice, Bob, and Eve initially know random variables X, Y , and Z, respectively, which are jointly distributed according to some probability distribution P XY Z . <ref type="foot" target="#foot_4">4</ref> These random variables could be the individual received noise signals of a deep-space radio source, or the individual received noisy versions of a random bit string broadcast by a satellite at a very low signal power.</p><p>For this setting it was shown in <ref type="bibr" target="#b34">[35]</ref> that<ref type="foot" target="#foot_5">5</ref> </p><formula xml:id="formula_15">H(S) ≤ I(X; Y ↓ Z),</formula><p>where I(X; Y ↓ Z) denotes the intrinsic conditional mutual information between X and Y , given Z, which is defined as follows <ref type="bibr" target="#b34">[35]</ref>:</p><formula xml:id="formula_16">I(X; Y ↓ Z) := inf P Z|Z I(X; Y |Z) : P XY Z = z∈Z P XY Z • P Z|Z .</formula><p>The above inequality is a generalization of the following bound <ref type="bibr" target="#b31">[32]</ref>:</p><formula xml:id="formula_17">H(S) ≤ min[I(X; Y ), I(X; Y |Z)].<label>(1)</label></formula><p>Note that I(X; Y ) and I(X; Y |Z) are obtained when Z is a constant or Z = Z, respectively, and that I(X; Y |Z) ≥ I(X; Y ) is possible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Unconditional Key Agreement by Public Discussion</head><p>The previous bound is an impossibility result. In order to prove constructive results about key agreement by public discussion, we need to make an explicit assumption about the distribution P XY Z . A very natural assumption, which is often made in an information-theoretic context, is that the same random experiment generating X, Y , and Z is repeated independently many times. One can then define the secret key rate S(X; Y ||Z) <ref type="bibr" target="#b31">[32]</ref> as the maximum rate (per executed random experiment) at which Alice and Bob can generate secret key, assuming (for now) an authenticated but otherwise insecure communication channel. This rate turns out to be positive even in cases where intuition might suggest that key agreement is impossible. For instance, when a satellite broadcasts random bits and X, Y , and Z are the bits (or more generally signals) received by Alice, Bob, and Eve, respectively, then key agreement is possible under the sole condition that Eve's channel is not completely perfect, even if Alice's and Bob's channels are by orders of magnitude more noisy than Eve's channel, for instance when Alice's and Bob's bit error rates are very close to 50% (e.g. 0.499) and Eve's bit error rate is very small (e.g. 0.001).</p><p>We conjecture that the secret key rate S(X; Y ||Z) is positive if and only if I(X; Y ↓ Z) is positive, and the two quantities may even be equal. Even if the public discussion channel is not authenticated, key agreement is still possible. The secret key rate is even equal to S(X; Y ||Z) (where an authenticated channel is assumed) <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b44">45]</ref>, except if Eve can either generate from Z a random variable Ỹ such that P X Ỹ = P XY or, symmetrically, a random variable X such that P XY = P XY . In both these cases, key agreement is impossible.</p><p>Many results on unconditionally secure key agreement were recently refined in various ways. We refer to <ref type="bibr" target="#b45">[46]</ref> for a very good overview and to <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b46">47]</ref> for detailed accounts of recent results in unconditionally-secure key agreement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Public Randomness and Memory-Bounded Adversaries</head><p>In this section we briefly discuss two other scenarios in which Eve cannot obtain complete information, and where this can be exploited by Alice and Bob to agree on a very long unconditionally-secure secret key S (e.g. 1 Gigabyte), assuming that they share only a short secret key K (e.g. 5000 bits) initially.</p><p>Suppose that all parties, including Eve, have access to a public source of randomness (similar to a random oracle) which is too large to be read entirely by Eve in feasible time. Then Alice and Bob can access only a moderate number of random bits, selected and combined using the secret key, such that unless Eve examines a substantial fraction (e.g. one half) of the random bits (which is infeasible), she ends up having no information about the generated key <ref type="bibr" target="#b29">[30]</ref>. More precisely, there exists an event E such that [S; KW |E], where W summarizes Eve's entire observation resulting from an adaptive access strategy. This is true even if Eve is given access to the secret key K after finishing her access phase. Moreover, for any adaptive strategy (without knowledge of K), the event E has probability exponentially close to 1. In other words, conditioned on this highprobability event, the scheme achieves perfect secrecy.</p><p>While the original proof assumed that Eve accesses individual bits of the source, Aumann and Rabin <ref type="bibr" target="#b36">[37]</ref> showed that the scheme is secure even if she accesses arbitrary bits of information about the random bits, e.g. Boolean functions evaluated on all the randomizer bits.</p><p>This also motivates the following model <ref type="bibr" target="#b10">[11]</ref>: Alice and Bob publicly exchange a random string too long to fit into Eve's memory, and use a scheme similar to that described above, based on a short initially shared secret key. It's security holds based on the sole assumption that Eve's memory capacity is bounded, without assumption about her computing power.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Information-Theoretic Primitives: A General Perspective</head><p>In both complexity-theoretic and information-theoretic cryptography, an important body of research is devoted to the reduction of one primitive to another primitive, e.g. of a pseudo-random number generator to a one-way function <ref type="bibr" target="#b26">[27]</ref> or of oblivious transfer to the existence of a noisy channel <ref type="bibr" target="#b15">[16]</ref>. In this section we informally define a general notion of an information-theoretic cryptographic primitive, discuss the general reduction problem among such primitives and possible goals of such a reduction, and show that many results in the literature fit into this general framework.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Definition of IT-Primitives</head><p>Definition 2. A (stateless) information-theoretic cryptographic primitive (ITprimitive or simply primitive, for short) is an abstractly defined mechanism (which can be viewed as a service offered by a trusted party) to which n ≥ 2 players P 1 , . . . , P n have access. For every invocation of the primitive, each player P i can provide a (secret) input X i from a certain domain and receives a (secret) output Y i from a certain range according to a certain (usually publicly known) conditional probability distribution P Y1,...,Yn|X1,...,Xn of the outputs, given the inputs.</p><p>As described, different invocations of the primitive are independent, but more generally an IT-primitive can have an internal state: the players can provide inputs and receive outputs in consecutive rounds, where in each round the dependence of the outputs on the inputs and the current state is specified by a conditional probability distribution.</p><p>This concept encompasses as special cases a very large class of previously considered cryptographic primitives, including secure message transmission, noisy channels, all types of oblivious transfer, broadcast channels, and secure multiparty computation, as will be explained below. The concept of a secure reduction of one primitive to another primitive will be discussed later.</p><p>There are at least two different ways of defining what it means for the players to have incomplete knowledge of the distribution P Y1,...,Yn|X1,...,Xn .</p><p>-The distribution can be any one in a class of distributions, possibly chosen by an adversary. If such a primitive is used in a protocol, security must be guaranteed for all distributions in the class. -The distribution is fixed, but some or all players' knowledge about the distribution may be incomplete. This can be modeled by letting each player receive an additional output summarizing his information about the distribution. This extra output can be viewed as part of the regular output and hence this case is covered by the above definition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Examples</head><p>Let us first consider some IT-primitives for n = 2 players, called Alice and Bob.</p><p>-A noisy channel from Alice to Bob: Alice can provide an input X from a certain domain (e.g. a bit) and Bob receives the output Y generated according to the conditional distribution P Y |X . For instance, in a binary symmetric channel with error rate , P Y |X (y, x) = if x = y and P Y |X (y, x) = 1if x = y. The (γ, δ)-unfair noisy channel of <ref type="bibr" target="#b17">[18]</ref> is a binary symmetric channel with error probability chosen by the adversary in the interval [γ, δ]. -Oblivious transfer (OT) of any type is a classical example of an IT-primitive.</p><p>In standard 1-out-of-2 OT, Alice chooses as input two bits (or bit strings), Bob chooses as input a selection bit, and Bob learns as output the corresponding bit (or string), while Alice learns nothing. In the generalized OT of Brassard and Crépeau <ref type="bibr" target="#b7">[8]</ref>, Bob can choose to receive any binary function of the two input bits, and this can be generalized further <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b9">10]</ref> to allow Bob to specify any channel over which he receives the two input bits, with the only constraint that his uncertainty (entropy) about the two input bits be at least γ, for some 0 &lt; γ &lt; 2. -Damgård, Kilian, and Salvail <ref type="bibr" target="#b17">[18]</ref> introduced a more general two-party primitive which they called weak oblivious transfer (WOT). In this model, also Alice receives an output that gives her partial information about Bob's choice. -A commitment scheme is a primitive with state: Alice inputs a value (which is kept as the state). Later, upon initiation of an opening phase, Alice chooses (with a binary input) whether or not she agrees to open the commitment, and Bob's output is the committed value or a dummy value, respectively. This primitive can also be defined with respect to several players (see below).</p><p>Damgård et al. <ref type="bibr" target="#b17">[18]</ref> also introduced a two-player primitive called weak generic transfer (WGT) that is similar to the two-player case of our general IT-primitive. However, the models differ in the following way: In WGT, cheating by one of the players is modeled by an additional output which the player receives only when cheating, but not otherwise. Passive cheating means that the player collects this information, without deviating from the protocol, and active cheating means that the player can take this extra information into account during the execution of the protocol. In contrast, cheating is in our definition not considered as part of the primitive, but as misbehavior to be protected against in a protocol in which the primitive is used. The possible assumption that a player receives additional information when cheating can be phrased as a security condition of a protocol in which the primitive is used.</p><p>Next we consider primitives for n = 3 players which we call Alice, Bob, and Eve, and where it is known in advance that Alice and Bob are honest while Eve is a cheating adversary.</p><p>-Key agreement between Alice and Bob: The players have no input <ref type="foot" target="#foot_6">6</ref> and receive outputs Y A , Y B , and Y E , respectively. The specification of the primitive is that Y A is chosen uniformly at random from the key space, that Y B = Y A , and that Y E is some dummy output that is independent of Y A . -A noisy random source: there are again no inputs, but the outputs Y A , Y B , and Y E are selected according to a general distribution. This corresponds to the key agreement scenario discussed in the previous section, where the random variables Y A , Y B , and Y E were called X, Y , and Z and generated according to some distribution P XY Z . The distribution of a random deal of cards <ref type="bibr" target="#b21">[22]</ref> is also a special case. -Wyner's wire-tap channel <ref type="bibr" target="#b47">[48]</ref> and the generalization due to Csiszár and Körner <ref type="bibr" target="#b16">[17]</ref>: A symbol sent by Alice is received by Bob and Eve over two dependent noisy channels. -Secure message transmission also fits into this framework: Alice's input is received by Bob, Eve receives no output. If the channel is authenticated but not confidential, then Eve also receives the output. -A quantum channel from Alice to Bob can also be modeled as an IT-primitive if the eavesdropper is forced to measure each quantum state independently.</p><p>For modeling the possibility that Eve could perform general quantum computations on the quantum states, our IT-primitive can be generalized to the quantum world.</p><p>We now describe some IT-primitives for general n:</p><p>-A broadcast channel: A designated sender provides an input which is received (consistently) by all other n -1 players. -Secure function evaluation for an agreed function: each player provides a secret input and receives the output of a function evaluated on all inputs. The players' output functions can be different. -Secure multi-party computation <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b11">12]</ref> among a set of n ≥ 2 players: here the primitive keeps state. This corresponds to the general paradigm of simulating a trusted party. -A random oracle can also be interpreted in this framework.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Reductions among IT-Primitives</head><p>The general reduction problem can be phrased as follows: assuming the availability of one primitive G (more generally, several primitives G 1 , . . . , G s ), can one construct primitive H, even if some of the players cheat, where the type of tolerable cheating must be specified. One can distinguish many types of cheating. Three well-defined cases are active cheater(s) who deviate from the protocol in an arbitrary manner, passive cheaters who follow the protocol but record all information in order to violate other players' privacy, and fail-corrupted cheaters who may stop executing the protocol at any time. Cheating players are usually modeled by assuming a central adversary who may corrupt some of the players.</p><p>One generally assumes without essential loss of generality or applicability that insecure communication channels between any pair of entities are available.</p><p>Such information-theoretic reductions among primitives are interesting for at least two reasons. First, if a certain primitive exists or can be assumed to exist in nature (e.g. a noisy channel), then it can be used to build practical unconditionally-secure protocols. Second, if a primitive can be realized or approximated cryptographically (e.g. oblivious transfer), then one can construct computationally-secure cryptographic protocols with a well-defined isolated complexity assumption. The relevance of a reduction result depends on at least the following criteria:</p><p>whether the resulting primitive is useful in applications, -whether the assumed primitive has a natural realization in the physical world, or can efficiently be realized by cryptographic means, -the efficiency of the reduction, for instance the number of invocations of primitive G needed to realize one occurrence of H? -the assumption about cheating (e.g. less than n/3 cheaters), and which additional assumptions are made (e.g., availability of an authenticated channel between certain or all pairs of players).</p><p>Informally, a reduction of one primitive to another is secure against an adversary with some specified corruption power if the adversary can do nothing more in the protocol than what he could do in an idealized implementation of the primitive, except possibly with exponentially small probability.</p><p>Many results in cryptography can be phrased as a reduction among primitives. Some of them were mentioned above, and a few are listed below:</p><p>-Many reduction results for oblivious transfer (e.g. <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b19">20]</ref>).</p><p>-Secret-key agreement by public discussion from noisy channels as discussed in the previous section can be interpreted as the reduction of key agreement to a certain type of noisy source. -Privacy amplification <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b4">5]</ref>, an important sub-protocol in unconditional key agreement, can be interpreted as the reduction of key agreement to a setting in which Alice and Bob share the same string, but where Eve has some arbitrary unknown type information about the string with the only constraint being an upper bound on the total amount of information. -Byzantine agreement protocols (e.g., see <ref type="bibr" target="#b27">[28]</ref>) can be interpreted as the reduction of the broadcast primitive to the primitive of bilateral authenticated channels, assuming active cheating by less than n/3 of the players. -The commitment primitive can be defined for an arbitrary number n of players, one of which commits to an input. Secret sharing can be interpreted as a reduction of such a commitment primitive to the primitive of bilateral secure communication channels, assuming only passive cheating by a nonqualified set of players. Verifiable secret sharing is like secret sharing, but security is guaranteed with respect to active cheaters (e.g. less than n/3). -The results of Ben-Or, Goldwasser and Wigderson <ref type="bibr" target="#b2">[3]</ref> and Chaum, Crépeau, and Damgård <ref type="bibr" target="#b11">[12]</ref> can be interpreted as the reduction of the primitive secure multi-party computation to the primitive bilateral secure communication channels, assuming active cheating by less than n/3 of the players. If also the broadcast primitive is assumed, then less than n/2 cheaters can be tolerated <ref type="bibr" target="#b37">[38]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">General Transfer Primitives</head><p>A two-player primitive covering various types of oblivious transfer as special cases can be defined as follows: Alice inputs a random variable We refer to an (α, β)-transfer as any transfer of the described type for which for at least one distribution P X (e.g., the uniform distribution) we have H(X) = α and H(Y i ) ≤ β for 1 ≤ i ≤ n, and assuming the natural condition that X is determined from Y 1 , . . . , Y n , i.e. that X contains no information that is irrelevant in the transfer. A transfer is said to hide at most γ bits if for all distributions P X and for 1 ≤ i ≤ n we have H(X|Y i ) ≤ γ.</p><p>For example, in 1-out-of-n OT of l-bit strings, X is the concatenation of the n input strings, which are Y 1 , . . . , Y n . Such an OT is an (ln, l)-transfer and can easily be shown to hide at most (n -1)l bits. Motivated by Dodis' and Micali's <ref type="bibr" target="#b19">[20]</ref> lower bound on reducing weak 1-out-of-N OT of L-bit strings to 1-out-of-n OT of l-bit strings we prove the following more general theorem.</p><p>Theorem 2. The reduction of any (α, β)-transfer to any transfer that hides at most γ bits requires at least (αβ)/γ invocations of the latter.</p><p>Proof. Let X be the input and Y be the output of the (α, β)-transfer to be realized, and let T be the entire communication taking place during the reduction protocol over the standard communication channel. Let k be the number of invocations of the second transfer, let U 1 , . . . , U k and V 1 , . . . , V k be the corresponding k inputs and outputs, and let</p><formula xml:id="formula_18">U k = [U 1 , . . . , U k ] and V k = [V 1 , . . . , V k ].</formula><p>Then we have H(X|V k T ) ≥ αβ (for at least one distribution P X ) because Bob must not learn more than β bits about X, and H(X|U k T ) = 0 because unless Alice enters all information about X into the protocol, she will learn something about C. We expand H(XU k |V k T ) in two different ways:</p><formula xml:id="formula_19">H(XU k |V k T ) = H(U k |V k T ) + H(X|U k V k T ) = H(X|V k T ) + H(U k |XV k T ), and observe that H(X|U k V k T ) ≤ H(X|U k T ) = 0 and H(U k |XV k T ) ≥ 0.</formula><p>Applying repeatedly the chain rule and the fact the further conditioning cannot increase entropy, we obtain α</p><formula xml:id="formula_20">-β ≤ H(X|V k T ) ≤ H(U k |V k T ) ≤ H(U k |V k ) = k j=1 H(U j |V k , U 1 • • • U j-1 ) ≤ k j=1 H(U j |V j ) ≤ kγ,</formula><p>and the theorem follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Generalized Random Oracles</head><p>In this section we briefly sketch the definition of a new general concept, which we call generalized random oracles for lack of a perhaps better name, and describe some applications and constructions.</p><p>One motivation for introducing this concept is the fact that many proofs of the computational security of a cryptographic system (e.g. a MAC scheme or a pseudo-random permutation) based on a pseudo-random function (PRF) <ref type="bibr" target="#b24">[25]</ref> rely on information-theoretic arguments, although this is not always made explicit in the proofs. An adversary's attack is modeled as a usually adaptive algorithm for performing certain query operations to the system. <ref type="foot" target="#foot_7">7</ref> The proof of the computational security of such a system consists of two steps: 1) a purely information-theoretic proof that the attack cannot succeed in an idealized setting where the PRF is replaced by a random function, and 2) the simple observation that if the random function is replaced by a PRF, then any efficient successful attack algorithm could be converted into an efficient distinguisher for the PRF, thus contradicting the underlying intractability assumption.</p><p>For instance, the Luby-Rackoff construction of a 2n-bit to 2n-bit pseudorandom permutation generator <ref type="bibr" target="#b28">[29]</ref> (involving three pseudo-random functions from n bits to n bits, combined in a three-round Feistel construction) can be proved secure by showing that no adaptive algorithm querying the permutation for less than a certain (super-polynomial) number of arguments (actually 2 n/2 ) can distinguish it from a truly random permutation with non-negligible advantage. If the three random functions are replaced by PRFs, the construction is computationally indistinguishable from a random permutation.</p><p>We sketch a general approach that allows to simplify and generalize many of the security proofs given in the literature by interpreting them as the proof of indistinguishability of two particular types of generalized random oracles. Some of the proofs can be obtained from a set of simpler information-theoretic arguments which can be formulated as results of independent interest and can serve as a toolkit for new constructions. Some of the proofs that can be revisited are those for the Luby-Rackoff construction <ref type="bibr" target="#b28">[29]</ref> and generalizations thereof <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b35">36]</ref>, and the analysis of the CBC MAC <ref type="bibr" target="#b0">[1]</ref> and the XOR MAC <ref type="bibr" target="#b1">[2]</ref>. Definition 3. A generalized random oracle (GRO) is characterized by 1) a set of query operations, each of which takes as input an argument from a certain domain and outputs a corresponding value in a certain range, and 2) a random experiment for which each elementary event in the sample space is a complete set of answers to all possible queries, with some probability distribution over the sample space.</p><p>A more operational interpretation of a GRO may help: In many cases a GRO is constructed using an array of k (usually k is exponential in a security parameter) independent random bits. The sample space hence consists of 2 k equally probable elementary events, and each access operation consists of (efficiently) evaluating a certain function involving the k bits.</p><p>The simplest form of a GRO is a random function from n bits to 1 bit (hence k = 2 n ). The (single) query operation evaluates the random function for a given argument. A generalization is obtained by allowing other types of queries, e.g. arbitrary linear combinations of the bits. Allowing outputs of general size (e.g. also n bits as in <ref type="bibr" target="#b28">[29]</ref>) entails no essential generalization, except that a new type of binary query exists: for a given input/output pair, do they match?</p><p>The concept of locally random functions proposed in <ref type="bibr" target="#b30">[31]</ref> also fits into this framework: these are efficient constructions of GROs with k 2 n and a single query operation {0, 1} n → {0, 1}, and which are indistinguishable from a random function for any algorithm accessing them less than, but close to k times. Definition 4. Two GRO's A and B have compatible access operations if each operation for A is compatible with an operation for B in the sense of having the same input domain and output range. Informally, two GRO's A and B with compatible access operations are perfectly (statistically) indistinguishable for a given number of access operations of each type if no adaptive algorithm that can access the GROs in the specified manner has different (non-negligibly different) probability of outputting 1 when the queries are answered using A or B.</p><p>Note that there is no restriction on the computing power of the distinguishing algorithm; hence a GRO is an information-theoretic rather than a complexitytheoretic concept.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusions</head><p>The three main points addressed in this paper are:</p><p>-In cryptography and more generally in computer science one generally considers only digital operations. However, all processes in the real world, including computation and communication, are physical processes involving noise and other uncertainty factors. We propose to further investigate and exploit this fact to achieve unconditional security in cryptography. -A general definition of an information-theoretic cryptographic primitive was proposed which encompasses many primitives previously proposed in the literature and leads to new research problems on the reduction between such primitives. -A generalized definition of a random oracle has been proposed which has applications for security proofs in complexity-theoretic cryptography.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>[</head><label></label><figDesc>S; T |V ] and [S; U |T V ] =⇒ [S; T U|V ]. If U is a random variable, then [S; T U|V ] =⇒ [S; T |V ], and if also T is a random variable, then [S; T U|V ] =⇒ [S; U |T V ] Note that if S, T , and U are events, then [S; T U] =⇒ [S; T |U ] and [S; T U] =⇒ [S; T ] are false in general. For instance, let P (S) = P (T ) = P (U ) = 0.5, P (ST ) = P (SU ) = P (T U) = 0.2, and P (ST U ) = 0.1. Then P (ST U ) = P (S)P (T U) = 0.1 but P (ST U )P (U ) = 0.05 = P (SU )P (T U) = 0.04.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>or, in our short notation, &gt; 0, this is equivalent to P (AB|C) = P (A|C) • P (B|C). Note that independence is symmetric, i.e.[A; B] ⇐⇒ [B; A] and [A; B|C] ⇐⇒ [B; A|C]. Let A denote the complement of the event A. One can also show that [A; B] ⇐⇒ [A; B] and [A; B] ⇐⇒ [A; B] while [A; BC] =⇒ [A;BC] is false in general.</figDesc><table><row><cell>If P (C)</cell></row><row><cell>P (ABC) • P (C) = P (AC) • P (BC).</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Key Agreement: Impossibility Results and Bounds Definition 1</head><label></label><figDesc>. A key-agreement protocol consists of a communication phase in which Alice and Bob alternate sending each other messages C 1 , C 2 , C 3 , . . ., where we assume that Alice sends messages C 1 , C 3 , C 5 , . . . and Bob sends messages C 2 , C 4 , C 6 , . . .. Each message can depend on the sender's entire view of the protocol and possibly on privately generated random bits.After the communication phase, Alice and Bob each either accepts or rejects the protocol execution, depending on whether he or she believes to be able to generate a shared secret key. If Alice accepts, she generates a key S depending on her view of the protocol.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>X, and Bob can select (by the random variable C ∈ {1, . . ., n}) to receive any one of n random variables Y 1 , . . . , Y n defined by a conditional distribution P Y1,...,Yn|X , such that for all (or for certain) distributions P X Alice learns nothing about C and Bob learns nothing about X beyond what he learns from Y C .</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Michael Wiener (Ed.): CRYPTO'99, LNCS 1666, pp. 47-65, 1999. c Springer-Verlag Berlin Heidelberg 1999</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1"><p>We refer to<ref type="bibr" target="#b6">[7]</ref> and<ref type="bibr" target="#b12">[13]</ref> for a more detailed introduction to information theory, and to<ref type="bibr" target="#b20">[21]</ref> for an introduction to probability theory.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_2"><p>For instance, C is an encryption of M , or M together with an appended message authentication code.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_3"><p>This fact can be rephrased as follows: There exists no unconditionally-secure publickey cryptosystem or public-key distribution protocol.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_4"><p>More generally, the distribution PXY Z could be under Eve's partial control and may only partly be known to Alice and Bob, for instance in the case of a quantum transmission disturbed by Eve.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_5"><p>neglecting here the fact that the bound can be slightly greater if imperfect secrecy or a non-zero failure probability is tolerated.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_6"><p>Invocation of the primitive could actually be considered as a special type of input.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_7"><p>For example, for the case of a MAC, two query operations are allowed: evaluation of the MAC for a chosen message, and verification of a message-MAC pair (yielding a binary output)<ref type="bibr" target="#b1">[2]</ref>.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>It is impossible to list all the people with whom I have had stimulating discussions on topics related to information-theoretic cryptography. Among them, I would like to thank the following people with whom I have had the pleasure to collaborate on related topics: Charles Bennett, Gilles Brassard, Christian Cachin, Ronald Cramer, Claude Crépeau, Ivan Damgård, Matthias Fitzi, Martin Gander, Martin Hirt, Olaf Keller, and Stefan Wolf. Above all, I am grateful to Jim Massey who introduced me to information theory and cryptography. I also thank Michael Wiener and the Crypto 99 program committee for inviting me to give this lecture.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The security of the cipher block chaining message authentication code</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO &apos;94</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">839</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The security of the cipher block chaining message authentication code</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Guérin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO &apos;95</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">963</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Completeness theorems for noncryptographic fault-tolerant distributed computation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ben-Or</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 20th ACM Symposium on the Theory of Computing (STOC)</title>
		<meeting>20th ACM Symposium on the Theory of Computing (STOC)</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Experimental quantum cryptography</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Bennett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Bessette</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Brassard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Salvail</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Smolin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="28" />
			<date type="published" when="1992">1992</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Generalized privacy amplification</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Bennett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Brassard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Crépeau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><forename type="middle">M</forename><surname>Maurer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1915" to="1923" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Privacy amplification by public discussion</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Bennett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Brassard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-M</forename><surname>Robert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="210" to="229" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Principles and practice of information theory</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Blahut</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<publisher>Addison-Wesley Publishing Company</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<author>
			<persName><forename type="first">G</forename><surname>Brassard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Crépeau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Oblivious transfer and privacy amplification, Advances in Cryptology -EUROCRYPT &apos;97</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1233</biblScope>
			<biblScope unit="page" from="334" to="345" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Cachin</surname></persName>
		</author>
		<title level="m">Entropy measures and unconditional security in cryptography</title>
		<meeting><address><addrLine>Konstanz</addrLine></address></meeting>
		<imprint>
			<publisher>ETH Zürich, Hartung-Gorre Verlag</publisher>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
	<note type="report_type">Ph. D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">On the foundation of oblivious transfer</title>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EURO-CRYPT &apos;98</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1403</biblScope>
			<biblScope unit="page" from="361" to="374" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Unconditional security against memory-bounded adversaries</title>
		<author>
			<persName><forename type="first">C</forename><surname>Cachin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><forename type="middle">M</forename><surname>Maurer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO &apos;97</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1294</biblScope>
			<biblScope unit="page" from="292" to="306" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Multiparty unconditionally secure protocols</title>
		<author>
			<persName><forename type="first">D</forename><surname>Chaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Crépeau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 20th ACM Symposium on the Theory of Computing (STOC)</title>
		<meeting>20th ACM Symposium on the Theory of Computing (STOC)</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="11" to="19" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Elements of information theory</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M</forename><surname>Cover</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Thomas</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Wiley Series in Telecommunications</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Equivalence between two flavours of oblivious transfer</title>
		<author>
			<persName><forename type="first">C</forename><surname>Crépeau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO &apos;87</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="350" to="354" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Efficient cryptographic protocols based on noisy channels</title>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT &apos;97</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1233</biblScope>
			<biblScope unit="page" from="306" to="317" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Achieving oblivious transfer using weakened security assumptions, 29th Symposium on Foundations of Computer Science</title>
		<author>
			<persName><forename type="first">C</forename><surname>Crépeau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<publisher>IEEE</publisher>
			<biblScope unit="page" from="42" to="52" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Broadcast channels with confidential messages</title>
		<author>
			<persName><forename type="first">I</forename><surname>Csiszár</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Körner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="339" to="348" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">On the (im)possibility of basing oblivious transfer and bit commitment on weakened security assumptions</title>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Salvail</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT &apos;99</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1592</biblScope>
			<biblScope unit="page" from="56" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">New directions in cryptography</title>
		<author>
			<persName><forename type="first">W</forename><surname>Diffie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Hellman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="644" to="654" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Lower bounds for oblivious transfer reductions</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT &apos;99</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1592</biblScope>
			<biblScope unit="page" from="42" to="55" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">An introduction to probability theory and its applications</title>
		<author>
			<persName><forename type="first">W</forename><surname>Feller</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1968">1968</date>
			<publisher>Wiley International</publisher>
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
	<note>3rd edition</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Bounds on secret key exchange using a random deal of cards</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">N</forename><surname>Wright</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="71" to="99" />
			<date type="published" when="1996">1996</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Codes for interactive authentication</title>
		<author>
			<persName><forename type="first">P</forename><surname>Gemmell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO &apos;93</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">773</biblScope>
			<biblScope unit="page" from="355" to="367" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Codes which detect deception</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">N</forename><surname>Gilbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Macwilliams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">J A</forename><surname>Sloane</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bell Syst. Tech. J</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="405" to="424" />
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">How to construct random functions</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="210" to="217" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">How to play any mental gamea completeness theorem for protocols with honest majority</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 19th ACM Symposium on the Theory of Computing (STOC)</title>
		<meeting>19th ACM Symposium on the Theory of Computing (STOC)</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="218" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Construction of a pseudorandom generator from any one-way function</title>
		<author>
			<persName><forename type="first">J</forename><surname>Håstad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Impagliazzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Luby</surname></persName>
		</author>
		<idno>no. 91-068</idno>
	</analytic>
	<monogr>
		<title level="j">ICSI</title>
		<imprint>
			<date type="published" when="1991">1991</date>
			<pubPlace>Berkeley, CA</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The Byzantine generals problem</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Shostak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pease</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="382" to="401" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">How to construct pseudorandom permutations from pseudorandom functions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Luby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rackoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="373" to="386" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Conditionally-perfect secrecy and a provably-secure randomized cipher</title>
		<author>
			<persName><forename type="first">U</forename><forename type="middle">M</forename><surname>Maurer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="53" to="66" />
			<date type="published" when="1992">1992</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">A simplified and generalized treatment of Luby-Rackoff pseudo-random permutation generators</title>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT &apos;92</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">658</biblScope>
			<biblScope unit="page" from="239" to="255" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Secret key agreement by public discussion from common information</title>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="733" to="742" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">A unified and generalized treatment of authentication theory</title>
	</analytic>
	<monogr>
		<title level="m">Proceedings 13th Symp. on Theoretical Aspects of Computer Science -STACS &apos;96</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>13th Symp. on Theoretical Aspects of Computer Science -STACS &apos;96</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1046</biblScope>
			<biblScope unit="page" from="387" to="398" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Information-theoretically secure secret-key agreement by NOT authenticated public discussion</title>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT &apos;97</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1233</biblScope>
			<biblScope unit="page" from="209" to="225" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Unconditionally secure key agreement and the intrinsic conditional information</title>
		<author>
			<persName><forename type="first">U</forename><forename type="middle">M</forename><surname>Maurer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wolf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="499" to="514" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">On the construction of pseudorandom permutations: Luby-Rackoff revisited</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Reingold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="29" to="66" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">O</forename><surname>Rabin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
	<note>personal communication</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Verifiable secret sharing and multiparty protocols with honest majority</title>
		<author>
			<persName><forename type="first">T</forename><surname>Rabin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ben-Or</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 21st ACM Symposium on the Theory of Computing (STOC)</title>
		<meeting>21st ACM Symposium on the Theory of Computing (STOC)</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="73" to="85" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Communication theory of secrecy systems</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Shannon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bell System Technical Journal</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="656" to="715" />
			<date type="published" when="1949">1949</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">A mathematical theory of communication</title>
	</analytic>
	<monogr>
		<title level="j">Bell System Technical Journal</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="379" to="423" />
			<date type="published" when="1948">1948</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">A survey of information authentication</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Simmons</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE</title>
		<meeting>the IEEE</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="volume">76</biblScope>
			<biblScope unit="page" from="603" to="620" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Universal hashing and authentication codes</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Stinson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">576</biblScope>
			<biblScope unit="page" from="74" to="85" />
			<date type="published" when="1992">1992</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
	<note>Advances in Cryptology -CRYPTO &apos;91</note>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Cipher printing telegraph systems for secret wire and radio telegraphic communications</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Vernam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the American Institute for Electrical Engineers</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="page" from="109" to="115" />
			<date type="published" when="1926">1926</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">New hash functions and their use in authentication and set equality</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">N</forename><surname>Wegman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Carter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="265" to="279" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Strong security against active attacks in information-theoretic secret-key agreement</title>
		<author>
			<persName><forename type="first">S</forename><surname>Wolf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -ASIACRYPT &apos;98</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1514</biblScope>
			<biblScope unit="page" from="405" to="419" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Unconditional security in cryptography</title>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Summer School in Cryptology and Data Security</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>Summer School in Cryptology and Data Security<address><addrLine>Aarhus, Denmark</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1998-07">July 1998. 1999</date>
			<biblScope unit="volume">1561</biblScope>
			<biblScope unit="page" from="217" to="250" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title level="m" type="main">Information-theoretically and unconditionally secure key agreement in cryptography</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>ETH Zurich</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Ph.D. Thesis no. 13138</note>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">The wire-tap channel</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Wyner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bell System Technical Journal</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1355" to="1387" />
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
