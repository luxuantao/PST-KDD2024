<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Automatic Recovery from Runtime Failures</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Antonio</forename><surname>Carzaniga</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Faculty of Informatics Lugano</orgName>
								<orgName type="institution">University of Lugano</orgName>
								<address>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alessandra</forename><surname>Gorla</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Computer Science</orgName>
								<orgName type="institution">Saarland University</orgName>
								<address>
									<settlement>Saarbrücken</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Andrea</forename><surname>Mattavelli</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Faculty of Informatics Lugano</orgName>
								<orgName type="institution">University of Lugano</orgName>
								<address>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Nicolò</forename><surname>Perino</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Faculty of Informatics Lugano</orgName>
								<orgName type="institution">University of Lugano</orgName>
								<address>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mauro</forename><surname>Pezzè</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Faculty of Informatics Lugano</orgName>
								<orgName type="institution">University of Lugano</orgName>
								<address>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Automatic Recovery from Runtime Failures</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">E6183D0DC94F84FAF00E13A5FE6C40EF</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T10:32+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present a technique to make applications resilient to failures. This technique is intended to maintain a faulty application functional in the field while the developers work on permanent and radical fixes. We target field failures in applications built on reusable components. In particular, the technique exploits the intrinsic redundancy of those components by identifying workarounds consisting of alternative uses of the faulty components that avoid the failure. The technique is currently implemented for Java applications but makes little or no assumptions about the nature of the application, and works without interrupting the execution flow of the application and without restarting its components. We demonstrate and evaluate this technique on four mid-size applications and two popular libraries of reusable components affected by real and seeded faults. In these cases the technique is effective, maintaining the application fully functional with between 19% and 48% of the failure-causing faults, depending on the application. The experiments also show that the technique incurs an acceptable runtime overhead in all cases.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Software systems are sometimes released and then deployed with faults, and those faults may cause field failures, and this happens despite the best effort and the rigorous methods of developers and testers. Furthermore, even when detected and reported to developers, field failures may take a long time to diagnose and eliminate. As a perhaps extreme but certainly not unique example, consider fault n. 3655 in the Firefox browser, which was reported first in March 1999 and other times over the following ten years, and is yet to be corrected at the time of writing of this paper (summer 2012). 1 The prevalence and longevity of faults in deployed applications may be due to the difficulty of reproducing failures in the development environment or more generally to the difficulty of diagnosing and eliminating faults at a cost and with a schedule compatible with the objectives of developers and users.</p><p>At any rate, dealing with faults that escape the testing environment seems to be a necessity for modern software, and in fact, several lines of research have been devoted to avoiding or at least mitigating the effects of faults in deployed software. A primary example is software fault tolerance. Inspired by hardware fault-tolerance techniques such as RAID <ref type="bibr" target="#b0">[1]</ref>, software fault tolerance is based on the idea of producing and executing different versions of an application (or parts of it) so as to obtain a correct behavior from the majority (or possibly even just one) of the versions <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b2">[3]</ref>. 1 https://bugzilla.mozilla.org/show bug.cgi?id=3655</p><p>The problem with these fault-tolerance techniques is that they are expensive and are also considered ineffective due to correlation between faults. Therefore, more recent techniques attempt to avoid or mask failures without incurring the significant costs of producing fully redundant code. Among them, some address specific problems such as inconsistencies in data structures <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b4">[5]</ref>, configuration incompatibilities <ref type="bibr" target="#b5">[6]</ref>, infinite loops <ref type="bibr" target="#b6">[7]</ref>, security violations <ref type="bibr" target="#b7">[8]</ref>, and non-deterministic failures <ref type="bibr" target="#b9">[9]</ref>, <ref type="bibr" target="#b10">[10]</ref>, while others are more general but require developers to manually write appropriate patches to address application-specific problems <ref type="bibr" target="#b11">[11]</ref>, <ref type="bibr" target="#b12">[12]</ref>.</p><p>In this paper we describe a technique intended to incur minimal costs and also to be very general. The technique works opportunistically and therefore can not offer strict reliability guarantees. Still, short of safety-critical systems, our goal is to support a wide range of applications to overcome a large class of failures. Similarly to other techniques, the main ingredient we plan to use is redundancy. In particular, we propose to exploit a form of redundancy that is intrinsic in modern component-based software systems. We observe that modern software and especially reusable components are designed to accommodate the needs of several applications and therefore to offer many variants of the same functionality. Such variants may be similar enough semantically, but different enough in their implementation, that a fault in one operation might be avoided by executing an alternative variant of the same operation. The automatic selection and execution of a correct variant (to avoid a failure of a faulty one) is what we refer to as an automatic workaround.</p><p>In prior work we have developed this notion of automatic workarounds by showing experimentally that such workarounds exist and can be effective in Web applications <ref type="bibr" target="#b13">[13]</ref>. We initially focused on Web applications because they allowed us to make some simplifying assumptions regarding the state and execution flow of the application. In particular, Web applications consist of a user interface built and modified by event-driven procedures that always run to completion, and are also essentially stateless (the state of the application is typically held on the server side). With this execution model, it is relatively easy to apply an automatic workaround by changing the code of one or more procedures and simply re-executing them (by reloading the page). Web applications also simplify the failure-detection problem, since the user can be assumed to detect failures and explicitly request workarounds.</p><p>In this paper we present a technique to apply automatic workarounds to general-purpose, possibly long-running applications. The technique is implemented for Java applications but makes little or no assumptions about the nature of the application. We make the very reasonable assumption that the application uses components taken from libraries, and for simplicity in the following discussion we consider one such library per application. The only two significant assumptions we make are that the library comes with a specification of the equivalence between the operations it supports, and that failures are somehow detected and reported.</p><p>The equivalence specifications may be written by the programmer of the library or by a knowledgeable user of the library. In any case, they need to be written only once for each library. (In Section III we briefly discuss the possibility of deriving these specifications automatically.) As in our prior work, we express those specifications with code-rewriting rules that are supposed to produce semantically equivalent code.</p><p>As for failure detection, our technique is almost completely independent of the particular detection and reporting mechanism. In practice we use exceptions as a reporting mechanism, and we experimented with implicit failure detectors such as run-time exceptions, as well as with more sophisticated detectors based on derived application-specific invariants.</p><p>At a high-level, the technique works as follows: when a failure is detected, the state of the application is restored to a previous checkpoint, then the code of the application is dynamically changed to replace a chosen code fragment that contains a call to the library with a potential workaround, and then the execution is restarted from the checkpoint with that new code.</p><p>A bit more in detail, the technique consists of an off-line preprocessing that also instruments the application with the necessary machinery to apply workarounds at runtime. The preprocessor identifies (through static analysis) those sections of the application code in which the application calls the library in ways that could potentially be rewritten and in which failures may be detected. We refer to those sections of application code as roll-back areas (RBAs). The preprocessor then produces alternative versions of each RBA using all the applicable rewriting rules. These versions are then compiled and stored for possible use at runtime. The preprocessor also instruments the application code by wrapping each RBA in a loop. The loop starts with a checkpoint of the state of the application, then proceeds with the execution of the RBA code, and then iterates in case of failures. The iteration restores the state to the initial checkpoint, replaces the code of the RBA with one of the alternative versions, and resumes the execution with the new version.</p><p>We demonstrate and evaluate our technique by applying it to two popular libraries and four applications that use those libraries. The first library is Guava, Google's "core" library for collections, caching, string processing, and more; the second library is JodaTime, a utility to process and convert dates and time across multiple and diverse calendar systems. The applications are an e-book converter called Fb2pdf, a framework for Java microbenchmarks called Caliper, a search results clustering engine called Carrot2, and a JavaScript source-tosource compiler called Closure. We evaluate the effectiveness of our technique by measuring its ability to handle real as well as injected faults and also by measuring its runtime overhead. In summary, our experiments demonstrate that the technique is effective while incurring an acceptable overhead. In particular, the technique maintains the applications fully functional with between 19% (Fb2pdf) and 48% (Carrot2) of the failure-inducing faults with a run-time overhead of between 2% (Caliper) and 194% (Closure).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. A MOTIVATING EXAMPLE</head><p>JodaTime is an open-source Java library of utilities to deal with dates and time. It provides full support for several calendars, it allows to easily represent dates and intervals, and to easily parse and format dates.</p><p>In May 2011 a developer reported issue n. 3304757 with the JodaTime library. <ref type="foot" target="#foot_1">2</ref> As it turns out, that issue was fixed within a short period of time, but the issue is still interesting because of the nature of the fault and the resulting failure.</p><p>Issue n. 3304757 reported a failure resulting in an exception when trying to get the instant corresponding to the beginning of the day on certain dates in countries that observe daylight saving time (DST). This failure could not be easily obtained in testing since it is triggered only under particular conditions, namely in regions where the DST leap occurs over midnight (e.g., America/Sao Paulo every year, some years in US regions and some Latin America regions). Due to this issue, the code in Listing 1 would fail with an exception on the day when daylight saving starts (for instance, 2011-10-16). The reason of the failure is that the invocation of dt.millisOfDay().withMinimumValue(), which is a way to get the representation of the beginning of the day, would return 2011-10-16 00:00:00.000 on 2011-10-16, but that instant does not exist on 2011-10-16 because that day begins at 01:00:00.000 due to the DST leap.</p><p>Thus issue n. 3304757 would cause any Java application using JodaTime in similar ways to fail, unless the developer had also put in place a proper and specific exception-handling procedure. However, that is unlikely because the failure scenario is somewhat obscure and hard to anticipate and test for. One might argue that cases like this one are rare, but while this specific case is in and of itself rare, it is also indicative of many similar "special" cases or features whose implications are not fully understood and therefore not properly handled. Fortunately however, JodaTime offers several different ways to get the instant representing the beginning of the day. As shown in Listing 2, there are at least two alternative ways to obtain the same expected result that do not suffer from that failure. Such alternative operations could be easily documented and therefore be used as automatic workarounds at runtime.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. INTRINSIC REDUNDANCY IN REUSABLE COMPONENTS</head><p>The foundational idea of our technique is that failures might be avoided with workarounds consisting of operations or sequences of operations that are equivalent to the failing ones but that do not suffer from the same failures. More specifically, a workaround consists of operations whose effect is equivalent to the intended effect of the original failing sequence, but whose implementation does not fail and therefore must be to some extent different. In other words, workarounds require redundancy: different code to do the same thing. Moreover, contrary to classic N-version programming, we expect this redundancy to be available at no cost, since we argue that this redundancy is an intrinsic property of modular software.</p><p>It is therefore natural or even necessary to ask whether modern software is indeed intrinsically redundant, and if so to what extent. And if the extent is significant, it would also be interesting to find out why. In this section we provide some qualitative arguments, with references to other studies (including our own), that, together with the direct evidence assembled during the experimentation we carried out for this work, lead us to believe that intrinsic redundancy exists and is significant enough to be exploited. A more thorough study of the prevalence and nature of intrinsic redundancy is the subject of another research we are currently pursuing.</p><p>Redundancy in software has been already studied, especially to identify and remove code clones. These are code fragments that are syntactically similar or even identical to other fragments in the same application. Code clones are considered harmful for maintenance <ref type="bibr" target="#b14">[14]</ref>, <ref type="bibr" target="#b15">[15]</ref> and are not exactly the kind of redundancy we expect to find. However, more recent studies in this and related areas also reveal more or less directly that semantic equivalence is also present and natural in software. Hindle et al. show that even with today's rich programming languages, developers tend to write simple and repetitive code <ref type="bibr" target="#b16">[16]</ref>. More importantly, Jiang and Su found that several code fragments are semantically equivalent even though they are syntactically different <ref type="bibr" target="#b17">[17]</ref>.</p><p>There are also plausible qualitative explanations for the intrinsic redundancy of software, especially in the case of libraries of reusable components. One is that a library might maintain various versions of the same components for backward compatibility. For example, the Java-6 standard library contains 45 classes and 365 methods that are deprecated and that duplicate exactly or almost exactly the same functionality of newer classes and methods. Another one is that modern libraries are designed to offer many flavors of the same or very similar functionalities. For example, the popular library JQuery for Web applications offers many methods to display elements in a Web page: fadeIn(), show(), fadeTo(), animate(), etc. These differ in some details, but are essentially equivalent in terms of the end result. Another example is when the same functionality is duplicated in different libraries. For example, the logging functionality of the Apache library log4J implements the same logging functions of the standard Java library (java.util.Logging), and several other similar examples of replicated functionality are found in the Apache Ant project. Yet another reason to have different variants of the same functionality is to address different non-functional requirements or different use cases. For example, the GNU Standard C++ Library implements its basic (stable) sorting function using the insertion-sort algorithm for small sequences, and mergesort for the general case. Similarly, other functions may be implemented in two or more variants, each one optimized for a specific case (for instance, memory vs. time).</p><p>In our own prior work we also found that redundancy exists and is usable in some very popular libraries for Web applications <ref type="bibr" target="#b13">[13]</ref>. With this paper we add more evidence of that kind for other types of libraries and applications. As shown in the example of Section II, the JodaTime library offers a number of redundant methods to obtain the time of the beginning of a day. However, that is by no means the only case of a redundant functionality in JodaTime. For instance, the DateTimeFormatter class provides several methods to parse dates and time (parseDateTime, parseLocalDateTime, parseLocalTime, and parseLocalDate). Most of these operations are equivalent only under special conditions (for instance, parseLocalDateTime and parseLocalDate can be used interchangeably only if the time is not specified) but it is still usually possible to find at least an alternative method to execute in many conditions.</p><p>Beyond these exemplary cases, we methodically studied and documented the redundancy of the JodaTime and Guava libraries, which we use as the basis for the experimental evaluation presented in Section V, as well as the widely used SWT graphical user interface library. We identified equivalences between sequences of library calls by first reading the documentation and later by testing each equivalence experimentally. We did not examine the code of the libraries, but instead we manually validated each rule by considering its observable effects.</p><p>Notice that this manual derivation and validation can be aided by some form of automation, for example by selecting equivalent operations based on their behavior under the available tests. However, a full automation would be counter to the notion of workarounds that we seek to support. Recall in fact that we are interested in finding operations that are equivalent in their intended behavior, but not exactly equivalent in their actual observable behavior.</p><p>Table <ref type="table" target="#tab_2">I</ref> shows the results of our analysis. We report the number of classes analyzed for each library (all SWT classes, a selected set for Guava and JodaTime) and the number of equivalent sequences that we found at the method level, in total and on average per class.</p><p>Notice that having many equivalences does not necessarily imply that a system is highly redundant. In fact, several equivalences may correspond to a shallow redundancy that exists only at the interface level, with different calls executing the same code after an initial veneer of interface code. Still, our experience with Web applications <ref type="bibr" target="#b13">[13]</ref> and even more so the experiments presented in this paper in Section V show that a significant number of equivalent sequences do indeed correspond to redundant behaviors that can be harnessed and used productively to avoid failures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. IMPLEMENTATION</head><p>We now present the architecture of ARMOR, a system that implements our automatic-workaround technique. 3 ARMOR works in the following general scenario: a Java application fails because of faults in one of the libraries it uses. Such faults may trigger a failure in the library code or in the application code. ARMOR, which is embedded within the application and is notified of the failure, reacts to the failure by first restoring the state of the application to a previously set checkpoint, and then by selecting and executing an equivalent sequence of operations that might avoid the failure. If multiple equivalent sequences are available, ARMOR selects the one that was most successful for past failures. ARMOR iterates this process until it obtains a valid workaround (i.e., a failure-free execution) or until there are no more equivalent sequences left to try. In the first case the execution of the application proceeds as if no failure occurred. In the second case ARMOR forwards the failure (an exception) to the application code as if ARMOR did not exist.</p><p>ARMOR works in two phases and with two main components. In a first off-line phase, a preprocessor component analyzes the application to identify where workarounds might be applied, pre-compiles all alternative sequences, and instruments the application with the necessary code to select those alternative sequences at runtime in response to a failure. At runtime, ARMOR records the state of the application at chosen checkpoints set before potential workarounds, and then reacts 3 http://star.inf.usi.ch/armor/ to failures by selecting and activating workarounds. We now detail all these preprocessing and runtime activities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Preprocessing</head><p>The preprocessor starts with the source code of the application, the binary distribution of the libraries, and the specification of the rewriting rules for each library. The preprocessor (1) identifies the units of code to which workarounds might be applied, which we call roll-back areas (RBAs), (2) instruments them with the necessary code to set checkpoints and to react to failures, and (3) compiles and stores the RBA variants to be used as potential workarounds at runtime.</p><p>1) Identifying Roll-Back Areas: A roll-back area (RBA) is the primary structural element of the application upon which ARMOR operates. We define a roll-back area as a segment of the application code within which (1) the application calls one or more operations of any one of the libraries, and (2) a failure can be detected and reported. Ideally, a roll-back area should also be minimal in the sense that it should be confined to operations that might fail and that could be replaced with a workaround. This is because the execution of any other code, before or after the library calls, might invalidate the checkpoint (for instance, with I/O operations, see Section IV-B1) and in any case would increase its runtime overhead.</p><p>In principle, a roll-back area may extend over sections of the application code at any level of granularity, from a single statement to a basic block to an entire method, and conceivably also across methods. However, our current implementation of ARMOR supports two types of extents for roll-back areas: a whole method body and a single initialization expression for a field (static or not). The extent of a roll-back area is constrained by the mechanism that ARMOR implements to dynamically replace the code of the RBA with one of its variants. This mechanism that we describe in detail in Section IV-B2 is capable of replacing only entire methods and thus requires every RBA to be encapsulated as a method. Thus the ARMOR preprocessor identifies RBAs consisting of a method body, which do not need additional encapsulation, and field initialization expressions, which need to be encapsulated through an ad-hoc additional method.</p><p>It is also conceivable to encapsulate RBAs consisting of blocks of instructions. However, the encapsulation of such RBAs poses a number of technical problems that we ultimately decided to avoid. Among these problems, the most significant one is the handling of local variables along with the application state that those variables might refer to.</p><p>Listing 3 shows a simple application intended to illustrate the preprocessing performed by ARMOR. This application uses the JodaTime library to get the instant corresponding to midnight of the current date, and would fail on specific dates and time zones because of the issue described in Section II. In this example, in the first step of preprocessing, ARMOR would identify three roll-back areas. These are the initialization of field tz on line 2, the initDayAndZone method on line 5, and the setMidnight method on line 12, since they all contain at least one invocation to the JodaTime library. Notice that ARMOR supports nested RBAs, that is, RBAs that invoke other RBAs. Method initDayAndZone is an example of a nested RBA, since it uses JodaTime directly, and invokes setMidnight, which is itself an RBA.</p><p>2) RBA Encapsulation and Proxy Methods: Once the RBAs have been identified, the preprocessor encapsulates and instruments them to allow them to be dynamically replaced with alternative variants at runtime. The encapsulation applies only to RBAs consisting of initialization expressions, which must be rewritten as methods. Once each RBA is encapsulated as a method, the preprocessor creates a proxy method for each RBA method. The role of the proxy is to set the checkpoint and then call the original RBA method and to respond to potential failures.</p><p>Listing 4 shows the encapsulation of initialization expressions (method tz init original on line 3) and the proxy methods created for two of the three RBAs identified in the example of Listing 3. For the sale of readability, we omit some details and show a simpler code than what is produced by ARMOR.</p><p>Let us consider the RBA that consists of the original method setMidnight. ARMOR renames this method to set-Midnight original and then creates a proxy method called setMidnight with the same signature as the original method. In particular, the proxy method must also declare and handle the same exceptions declared and handled by the original method. In this respect, ARMOR distinguishes between checked and unchecked exceptions. (In Java, exceptions can be either checked or unchecked.) Checked exceptions are invalid or simply special conditions that are explicitly declared as potential outcomes of the calls to library functions. These are exceptions that the application code must deal with explicitly, either by handling them or by passing them up the stack. By contrast, unchecked (or runtime) exceptions are unexpected conditions that may or may not be handled explicitly by the application.</p><p>ARMOR ignores checked exceptions, since it is the responsibility of the programmer to handle those, and in many cases those may well represent a normal path of execution for the application. Therefore, masking those exceptions may interfere with the correct behavior of the application. On the other hand, unchecked exceptions typically represent failures, and therefore ARMOR catches them and responds to them. In practice, the proxy method catches all exceptions with a generic catch statement, but must also explicitly catch all the specific exceptions thrown by the original method only to immediately re-throw them to the application.</p><p>In addition to handling the exceptions thrown by the original RBA method, the proxy handles the state of the application (and the library) in the execution of the original RBA and of potential workarounds. In particular, the proxy sets a checkpoint for the state of the application immediately before the execution of the RBA (line 35). Then, in case of failure, the proxy restores the state to that checkpoint (line 41) before trying an alternative variant. Before terminating, the proxy discards the checkpoint.</p><p>3) RBA Variants:</p><p>For each identified roll-back area, the ARMOR preprocessor produces a series of alternative variants of the application code by applying the rewriting rules of each library used within that roll-back area. These are variants of the original application methods as well as of the ad-hoc methods produced by ARMOR to encapsulate initialization expressions. In practice, referring to the example of Listing 4, these are all the methods with the original name suffix. The preprocessor produces one variant for each application of a single rewriting rule. The preprocessor then pre-compiles all the RBA variants and stores the bytecode in a database for potential retrieval and use at runtime.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Runtime Operations</head><p>After the preprocessing phase, the application can be compiled and deployed. ARMOR does not run any special component alongside the application, so the execution of the instrumented application differs from the original one only in the execution of the proxy methods. ARMOR assumes the existence of a failure detector, which may be implemented as a separate autonomous component. However, for the purpose of this paper we assume a typical lightweight failure detection based on assertions or at a minimum on runtime exceptions.</p><p>In practice, the most significant difference in the execution of the instrumented application is the checkpointing of the application state performed within the proxy methods. In the case of successful execution, this is also the only difference.</p><p>1) Checkpointing and Restoring Application State: AR-MOR implements an ad-hoc mechanism to checkpoint and restore the state of the application during execution. The high-level semantics of this mechanism is that of a classic checkpointing mechanism: a checkpoint can be set during the execution of the application, then later the checkpoint may be restored, in which case the state of the application is brought back to what it was at the time the checkpoint was set. The same checkpoint may be restored multiple times.</p><p>Since RBAs may be nested and several workarounds might be tried at different levels of the execution of the application, ARMOR maintains a thread-local stack of active checkpoints. Every time a proxy method sets a checkpoint, for instance line 35 in Listing 4, ARMOR pushes a new checkpoint handle on the stack.</p><p>ARMOR implements two interchangeable types of checkpoints, one based on a snapshot taken before the execution of the RBA code, and one based on a lazy change-log recorded during the execution of the RBA code.</p><p>The first mechanism takes a snapshot of the portion of the application state that might be modified by the execution of a roll-back area at the time the checkpoint is set. In its basic form, the snapshot consists of the transitive closure of all the objects reachable from the object on which the RBA method is called (i.e., this object) plus the parameters to the RBA method and all the static fields that are accessible by the RBA method. The second mechanism uses a change-log whereby the first time a field is written (static or not, primitive values as well as references) the previous value of that field is recorded in the change-log, so that it can be restored later.</p><p>The two mechanisms have complementary advantages and disadvantages. The snapshot saves every value that is part of the application state and that is accessible by the RBA at the checkpoint, regardless of whether it is actually modified by the execution of the RBA. The change-log saves every value that is actually modified, regardless of whether that value is part of the application state at the checkpoint. So, the snapshot incurs a potentially high cost at the time the checkpoint is set, but then incurs no cost during the execution of the RBA. Conversely, the change-log incurs no initial cost when the checkpoint is set but may incur a high cost during the execution of the RBA. Both mechanism may be improved through static analysis, although in our current implementation of ARMOR we only applied such analysis to the snapshot method, in order to exclude from the transitive closure those objects that are for sure never modified in the execution of the RBA. In Section V we analyze the performance of both mechanism in all our experiments.</p><p>2) Replacing Code: When a failure occurs within an RBA, the proxy method replaces the code of the RBA with a variant of that RBA. ARMOR implements this dynamic code replacement by substituting the code of the whole class that contains the RBA, since this is the only way that code can be dynamically redefined in Java. This is done using the redefineClasses method of the java.lang.instrument package.</p><p>ARMOR selects one of the pre-compiled classes produced by the preprocessor for that RBA. Each pre-compiled class is derived from the original instrumented class (with proxy and original methods) with only the original method changed. The effect of reloading such a class is to change the original method of the present RBA, and in particular all future calls to that method. This redefinition does not affect the execution of methods of the class that are active (on the current stack). In particular, it does not affect the execution of the proxy method, which is in fact the one that initiates the class redefinition. In practice, referring to the example of Listing 4, after the replacement of the RBA code (line 42), the call to the RBA method (line 43) will execute the new RBA variant, different from that executed previously (line 36 or line 43).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. EXPERIMENTAL EVALUATION</head><p>We now present the results of the experimental evaluation of the ARMOR system and the technique it embodies. The objective of this evaluation is to determine whether the technique is effective in making applications more resilient to faults, and efficient enough to be practically usable. In answering the first question, we also indirectly provide evidence that modular software is to some significant extent intrinsically redundant.</p><p>We conducted this evaluation with four non-trivial applications and two non-trivial libraries affected by real and seeded faults. The two libraries are</p><p>• JodaTime:<ref type="foot" target="#foot_2">4</ref> a library of utility functions to represent and manipulate dates and time. • Guava:<ref type="foot" target="#foot_3">5</ref> the Google "core" library for collections, I/O, caching, concurrency, string processing, etc. The four applications are</p><p>• Fb2pdf:<ref type="foot" target="#foot_4">6</ref> a command-line utility to convert files from the FB2 e-book format into PDF. Fb2pdf uses the Java date/time library but we changed it to use the fully compatible JodaTime library. • Carrot2:<ref type="foot" target="#foot_5">7</ref> a search results clustering engine. Carrot2 uses the Guava library. • Caliper:<ref type="foot" target="#foot_6">8</ref> a framework for writing, running and viewing the results of Java microbenchmarks. Caliper uses the Guava library. • Closure:<ref type="foot" target="#foot_7">9</ref> a source-to-source optimizing JavaScript compiler. Closure uses the Guava library. As a first preliminary step in our experiments, we wrote the equivalence specifications for Guava and JodaTime based on their respective API documentation. Of the 1000+ classes of the Guava v.12 library, we analyzed the 116 classes in the collections package that also come with an API documentation, including all the classes used in Carrot2, Caliper, and Closure. Of the 149 classes of the JodaTime v.2.1 library, we analyzed 12 classes, including all the ones used in Fb2pdf. For both libraries we identified several equivalences between sequences of calls (see Table <ref type="table" target="#tab_2">I</ref>). Then, focusing on the relevant equivalences for our experiments, we abstracted and formalized those equivalences through code-rewriting rules. In total, we compiled 63 rewriting rules for Guava, and 100 for JodaTime. With these rewriting rules, we ran the ARMOR preprocessor to identify the roll-back areas and to produce their variants. The results of the preprocessing are reported in Table <ref type="table" target="#tab_2">II</ref>. Notice that not every identified RBA (for example, a method that uses the library) would have multiple valid variants. This is because there might be no applicable equivalences, or because the application of the rewriting rules, which are simple textual pattern-substitution rules, sometimes produces invalid code.</p><p>We first conducted an evaluation of ARMOR on a limited number of real faults affecting the JodaTime library and the Fb2pdf application, and then we conducted a more extensive evaluation using seeded faults with both libraries and all four applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Real Faults in JodaTime</head><p>We analyzed three real faults reported for JodaTime.</p><p>• Issue n. 1375249 reports that if a YearMonthDate (Joda-Time class) is created with a Calendar (java.util.Calendar class) as a parameter, the method plusDays() (part of the class YearMonthDate) throws an IllegalArgumentException when the resulting date is in the next year. A workaround exists for this fault: YearMonthDay must be constructed from a Calendar by explicitly specifying an ISOChronology.</p><p>• Issue n. 3072758 reports that the method parseDateTime of the class DateTimeFormatter (JodaTime class) fails to parse a DST leaping date even if the LenientChronology is specified (which means it should be tolerant to DST leaps). A workaround exists: by using parseLocalDate-Time instead of parseDateTime. • Issue n. 3304757: see Section II. For all three of these faults, ARMOR was able to find and execute a valid workaround.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Mutation Analysis</head><p>In order to obtain a more extensive coverage of the features of the libraries and of ARMOR itself, and also to obtain more statistically significant results, we turned to a systematic mutation analysis. We proceeded as follows:</p><p>1) We used the Major mutation analysis framework <ref type="bibr" target="#b18">[18]</ref> to inject faults in the two libraries. We did that by activating all types of mutations supported by Major. 2) We then ran all the applications with the mutated versions of their respective libraries, and we traced those executions. For each application we obtained an input that we deemed representative for the application. For Fb2pdf we used a third-party e-book file, for Carrot2 and Caliper we used inputs provided by the developers for demonstration purposes, for Closure we used a large and popular JavaScript library (jQuery). Based on the execution traces, we then discarded the mutants that were never executed. 3) We activated each remaining mutant individually and executed all applications in the presence of each mutant.</p><p>For each application and mutant, we observed and categorized the outcome of the execution as error, loop, and success, when the execution led to an error or exception, an infinite loop, or a normal termination, respectively. Of the mutants in the success categories we further analyzed and distinguished mutants whose execution produced the expected output, which we classified as equivalent and that we discarded, and mutants whose execution failed to produce the expected result, which we classified as non-equivalent. 4) We then executed all applications instrumented with ARMOR on all error, loop, and non-equivalent success mutants. For the error mutants we simply relied on the implicit failure detection (i.e., exceptions). For the mutants in the loop and non-equivalent success categories, we augmented the application with specific failure detectors that we obtained as follows:</p><p>• We used Daikon <ref type="bibr" target="#b19">[19]</ref> to derive invariants from repeated executions of the original program (without mutations). • We used Daikon on each mutant (same application, same input) and selected those invariants found within roll-back areas that were valid for the original program but not for the mutant program. • We inserted those invariants as assertions in the application code, within the RBA where they were found.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Effectiveness</head><p>We first evaluate the effectiveness of ARMOR. We measure that by counting the cases in which ARMOR could recover from one or more failures caused by a mutant and allow the application to run to completion with a correct output.</p><p>These results are displayed in Table <ref type="table" target="#tab_2">III</ref>. The top part of the table summarizes the selection and classification of mutants for each application. The last row shows the effectiveness of ARMOR. These results are very encouraging, since they demonstrate that ARMOR is successful with between 19% and 48% of the mutants. These are cases in which ARMOR is completely successful, meaning that the application terminates successfully and with the correct output despite the presence of a failure-inducing fault.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Runtime Overhead</head><p>We then measure the runtime overhead of ARMOR to verify that the execution of an instrumented application would not suffer an unreasonable penalty due to the instrumentation. We measure the overhead of ARMOR in terms of total execution time and in terms of allocated memory in a normal (nonfailing) run, and we compare those measurements with the execution of the original application code.</p><p>Table <ref type="table" target="#tab_7">IV</ref> summarizes the results of this analysis. At a highlevel, the results demonstrate that ARMOR (with the changelog-based checkpoint) incurs a noticeable but also seemingly reasonable overhead in all cases. In particular, the running time overhead ranges from 2% to 194%. Interestingly, we initially assumed that the runtime overhead would be attributable to the checkpoint mechanism, since that is essentially the only active code executed by ARMOR in normal (non-failing) runs.</p><p>However, a further analysis shows that a significant portion of the total overhead is instead due to the instrumentation alone, which in practice consists of the time needed to execute a try-block in the proxy method.</p><p>The somewhat extreme case of the Closure compiler in which RBAs are executed in very hot loops, as evidenced by the high number of recorded checkpoints, also shows that the checkpoint mechanism is quite efficient, since the execution of over 1.2 million checkpoints incurs only a relatively low 99% overhead, corresponding to a bit more than 5 seconds of execution time (on a 2.53GHz Intel Xeon E5630 CPU).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Analysis and Discussion</head><p>For each mutant and each application, we manually analyzed the results of the execution with ARMOR to identify the causes of the successes and failures of our technique. Here we report some highlights of this analysis.</p><p>An interesting case is Fb2pdf. Fb2pdf is the application with the fewest number of RBAs but also with the largest set of mutants affecting the execution, and it is also the application with the lowest success rate. What we found is in fact that Fb2pdf uses the library quite extensively, but it does that through a few access points and, therefore, at a greater depth than other applications. We draw two conclusions from this analysis: first, there is little hope to avoid the effects of a fault whenever a few calls use a large portion of the library code, since that would require a large amount of redundancy. Second, workarounds are likely to be more effective when the fault (in the library) is somewhat closer to the application code, and therefore when the alternative use of the library would have a more direct control in steering the execution away from the fault.</p><p>Another interesting and related case is that of a failure in Carrot2 which ARMOR could not avoid. This failure turned out to be caused by a use of the (mutated) Guava library from within another library used by Carrot2, which means that ARMOR was not even involved in that particular use. We do not know whether ARMOR could have prevented the failure, but once again we observe that faults at a greater depth in the call stack have less chances of being avoided through workarounds at the interface between application and library.</p><p>The case of Carrot2 is also interesting because it is characterized by several active and also nested RBAs. One of the RBAs of Carrot2 is in fact in its main method, and several others are nested up to a depth of 7. Nested RBAs are expensive because they involve more checkpoints and also because they might induce several nested iterations to look for a valid workaround, especially when no workarounds are found for lower-level RBAs. This complexity might explain the overhead incurred by ARMOR with Carrot2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. RELATED WORK</head><p>The idea of relying on some form of redundancy to make applications more robust to faults is not new. Some of the most well known (but also disputed) software fault tolerance techniques require the availability of several variants of  the same components developed independently by different teams <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b20">[20]</ref>. Diversity in the design and development limits the number of correlated faults and therefore increases fault tolerance, but it also increases the development costs. Our technique is similar in that it exploits redundancy, but it is also different in that it exploits redundancy that is already present in libraries and therefore does not incur additional design costs. Similarly, data diversity exploits redundancy to tolerate faults, but without incurring higher development costs <ref type="bibr" target="#b21">[21]</ref>. Instead of executing several variants of the same component, the execution involves the original component with several reexpressions of the input. Other classic software fault tolerance techniques, such as wrappers and exception handling, require the development of additional code to deal with specific failures <ref type="bibr" target="#b22">[22]</ref>, <ref type="bibr" target="#b23">[23]</ref>. Our technique automatically creates proxy methods, which are equivalent to wrappers, to execute alternative code, and it relies on exception handling to automatically deal with failures.</p><p>Software fault tolerance also comprises several techniques that specifically deal with non-deterministic failures. Such techniques, including software rejuvenation, microreboots, and checkpoint-and-retry, are complementary to our technique, since they would all fail in avoiding deterministic failures that our technique can instead avoid <ref type="bibr" target="#b24">[24]</ref>, <ref type="bibr" target="#b9">[9]</ref>, <ref type="bibr" target="#b25">[25]</ref>. Rx extends these techniques by dealing with some deterministic failures. However, it is effective only on failures that are caused by problematic interactions with the environment <ref type="bibr" target="#b10">[10]</ref>.</p><p>Most of the recent techniques to avoid or mitigate the effects of field failures address specific problems, such as repairing inconsistencies in data structures <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b26">[26]</ref>, avoiding infinite loops <ref type="bibr" target="#b6">[7]</ref>, fixing configuration issues <ref type="bibr" target="#b5">[6]</ref>, fixing invalid HTML code generated by PHP applications <ref type="bibr" target="#b27">[27]</ref>, and making applications more robust to malicious inputs <ref type="bibr" target="#b28">[28]</ref> and malicious attacks in general <ref type="bibr" target="#b7">[8]</ref>. Our technique does not target specific faults and instead is intended as a general-purpose solution to avoid failures at runtime. Other general techniques like ours require a more intense manual intervention. For instance, Chang et al. can automatically deploy patches for integration problems, but they require library developers to manually write the patches first <ref type="bibr" target="#b11">[11]</ref>. Moreover, they assume the applications to be stateless, since they do not offer any mechanism to handle the state after a failure. Cabral et al. instead can automatically deploy applications with exception handlers that can deal with general problems (e.g., I/O exceptions) but they still require developers to write the exception handlers for application-specific exceptions <ref type="bibr" target="#b12">[12]</ref>. Finally, <ref type="bibr">Harmanci et al.</ref> propose new Java constructs to execute alternative blocks of code in case of exceptions <ref type="bibr" target="#b29">[29]</ref>. However, it is up to the developers to code the alternative blocks. Our technique requires some manual effort too, since we assume to have a list of rewriting rules for each library. However, this information can be reused with different applications.</p><p>Our work is also very related to some recent state-of-theart automated debugging techniques. These techniques can automatically find patches to fix faults identified either by failures in test suites or by contract violations <ref type="bibr" target="#b30">[30]</ref>, <ref type="bibr" target="#b31">[31]</ref>, <ref type="bibr" target="#b32">[32]</ref>, <ref type="bibr" target="#b33">[33]</ref>. Differently from these techniques, we do not aim to fix the faulty statements in the application, but instead we only aim to avoid their effects at runtime. In fact, our technique is designed to work on deployed applications, whereas automated debugging techniques are still costly and at the moment are best applied only to an off-line debugging process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. CONCLUSIONS</head><p>We presented a technique to improve the reliability of applications. This technique is based on and extends the notion of automatic workarounds that we developed in prior work. In particular, we now support general-purpose (Java) applications with workarounds that can be deployed at runtime without interrupting the execution flow of the application and without restarting its components. We demonstrate the effectiveness and usability of this technique through a concrete implementation called ARMOR, with which we obtain very positive results. As part of our evaluation we also evidence and document the intrinsic redundancy of some software systems, which is an interesting result of independent value.</p><p>Our future research plans include the further development and refinement of ARMOR on the basis of the experience gained with this study. We plan to work on new methods to deal with faults and failures that are deep in the library code and therefore that are unlikely to be solved by a workaround at the application level. We also plan to conduct more and more thorough experiments with ARMOR by applying it to yet more libraries and applications.</p><p>Departing from ARMOR and automatic workarounds, and moving forward towards a more broad and somewhat ambitious research objective, we also intend to formalize the notion of intrinsic redundancy and to study its prevalence and its origin in modern software.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE I EQUIVALENT</head><label>I</label><figDesc>SEQUENCES FOUND IN REPRESENTATIVE JAVA LIBRARIES</figDesc><table><row><cell>Library</cell><cell>Guava</cell><cell cols="2">SWT JodaTime</cell></row><row><cell>Classes considered</cell><cell>116</cell><cell>252</cell><cell>12</cell></row><row><cell>Total equivalences found</cell><cell>1715</cell><cell>1494</cell><cell>135</cell></row><row><cell>Average per class</cell><cell>14.78</cell><cell>5.93</cell><cell>11.25</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>TABLE IV OVERHEAD</head><label>IV</label><figDesc>INCURRED BY ARMOR IN NORMAL NON-FAILING EXECUTIONS (MEDIAN OVER 10 RUNS)</figDesc><table><row><cell></cell><cell></cell><cell>Caliper</cell><cell>Carrot2</cell><cell>Closure</cell><cell>Fb2pdf</cell></row><row><cell></cell><cell>Original total running time</cell><cell>30.13</cell><cell>2.43</cell><cell>5.40</cell><cell>2.26</cell></row><row><cell>Time</cell><cell>Exception-handling only (no checkpoints)</cell><cell>(1%) 30.41</cell><cell>(69%) 4.15</cell><cell>(95%) 10.53</cell><cell>(68%) 3.79</cell></row><row><cell>(seconds)</cell><cell>Snapshot-based checkpoints</cell><cell>(5%) 31.78</cell><cell>(117%) 5.32</cell><cell cols="2">&gt;1h (121%) 4.99</cell></row><row><cell></cell><cell>Change-log-based checkpoints</cell><cell>(2%) 30.87</cell><cell>(94%) 4.75</cell><cell cols="2">(194%) 15.90 (114%) 4.70</cell></row><row><cell>Memory (MB)</cell><cell>Original total memory allocated Snapshot-based checkpoints Change-log-based checkpoints</cell><cell>1.40 12.30 10.18</cell><cell>8.87 23.78 11.37</cell><cell>30.56 -120.58</cell><cell>17.90 90.94 25.93</cell></row><row><cell cols="2">Number of recorded checkpoints (approx.)</cell><cell>30</cell><cell>2,350</cell><cell>1,255,000</cell><cell>4</cell></row><row><cell cols="2">Values saved in change-log-based checkpoints (approx.)</cell><cell>26,000</cell><cell>270,000</cell><cell>1,880,000</cell><cell>9,000</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>978-1-4673-3076-3/13/$31.00 c 2013 IEEE ICSE 2013, San Francisco, CA, USA</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>http://sourceforge.net/tracker/?func=detail&amp;aid=3304757&amp;group id= 97367&amp;atid=617889</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>http://joda-time.sourceforge.net/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_3"><p>http://code.google.com/p/guava-libraries/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_4"><p>http://code.google.com/p/fb2pdf/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_5"><p>http://project.carrot2.org/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_6"><p>http://code.google.com/p/caliper/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_7"><p>http://code.google.com/p/closure-compiler/</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments This work was supported in part by the Swiss National Science Foundation with project SHADE (n. 200021-138006) and by the European Research Coucil with ERC Advanced Grant SPECMATE (n. 290914).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A case for redundant arrays of inexpensive disks (RAID)</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Patterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gibson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Record</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The N-version approach to fault-tolerant software</title>
		<author>
			<persName><forename type="first">A</forename><surname>Avizienis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">12</biblScope>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">System structure for software fault tolerance</title>
		<author>
			<persName><forename type="first">B</forename><surname>Randell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Reliable software</title>
		<meeting>the International Conference on Reliable software</meeting>
		<imprint>
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Automatic detection and repair of errors in data structures</title>
		<author>
			<persName><forename type="first">B</forename><surname>Demsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th Conference on Objectoriented Programming, Systems, Languages, and Applications</title>
		<meeting>the 18th Conference on Objectoriented Programming, Systems, Languages, and Applications</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">DSDSR: a tool that uses dynamic symbolic execution for data structure repair</title>
		<author>
			<persName><forename type="first">I</forename><surname>Hussain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Csallner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Workshop on Dynamic Analysis</title>
		<meeting>the 8th International Workshop on Dynamic Analysis</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Using feature locality: can we leverage history to avoid failures during reconfiguration</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">J</forename><surname>Garvin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">B</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">B</forename><surname>Dwyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th Workshop on Assurances for Self-Adaptive Systems</title>
		<meeting>the 8th Workshop on Assurances for Self-Adaptive Systems</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Detecting and escaping infinite loops with Jolt</title>
		<author>
			<persName><forename type="first">M</forename><surname>Carbin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Misailovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th European Conference on Object-Oriented Programming</title>
		<meeting>the 25th European Conference on Object-Oriented Programming</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Perkins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Sullivan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-F</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Automatically patching errors in deployed software</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Zibin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ernst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rinard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Amarasinghe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bachrach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Carbin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pacheco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sherwood</surname></persName>
		</author>
		<author>
			<persName><surname>Sidiroglou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd International Symposium on Operating Systems Principles</title>
		<meeting>the 22nd International Symposium on Operating Systems Principles</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Microreboot-a technique for cheap recovery</title>
		<author>
			<persName><forename type="first">G</forename><surname>Candea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kawamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Fujiki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Friedman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fox</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th Symposium on Operating Systems Design &amp; Implementation</title>
		<meeting>the 6th Symposium on Operating Systems Design &amp; Implementation</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Rx: Treating bugs as allergies-a safe method to survive software failures</title>
		<author>
			<persName><forename type="first">F</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tucek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sundaresan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">In-field healing of integration problems with COTS components</title>
		<author>
			<persName><forename type="first">H</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Mariani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pezzè</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31st International Conference on Software Engineering</title>
		<meeting>the 31st International Conference on Software Engineering</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A transactional model for automatic exception handling</title>
		<author>
			<persName><forename type="first">B</forename><surname>Cabral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Marques</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Languages, Systems and Structures</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Automatic workarounds for Web applications</title>
		<author>
			<persName><forename type="first">A</forename><surname>Carzaniga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gorla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Perino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pezzè</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th International Symposium on the Foundations of Software Engineering</title>
		<meeting>the 18th International Symposium on the Foundations of Software Engineering</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">An empirical study of code clone genealogies</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Sazawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Notkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Murphy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th Conference on the Foundations of Software Engineering</title>
		<meeting>the 10th Conference on the Foundations of Software Engineering</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">CCFinder: a multilinguistic token-based code clone detection system for large scale source code</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kamiya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kusumoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Inoue</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">7</biblScope>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">On the &quot;naturalness&quot; of software</title>
		<author>
			<persName><forename type="first">A</forename><surname>Hindle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Barr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Devanbu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gabel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th International Conference on Software Engineering</title>
		<meeting>the 34th International Conference on Software Engineering</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Automatic mining of functionally equivalent code fragments via random testing</title>
		<author>
			<persName><forename type="first">L</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Su</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th International Symposium on Software testing and analysis</title>
		<meeting>the 18th International Symposium on Software testing and analysis</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">MAJOR: An efficient and extensible tool for mutation analysis in a java compiler</title>
		<author>
			<persName><forename type="first">R</forename><surname>Just</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Schweiggert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Kapfhammer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2011 26th International Conference on Automated Software Engineering</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Dynamically discovering likely program invariants to support program evolution</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Ernst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cockrell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">G</forename><surname>Griswold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Notkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Definition and analysis of hardware-and software-fault-tolerant architectures</title>
		<author>
			<persName><forename type="first">J.-C</forename><surname>Laprie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Béounes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kanoun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">7</biblScope>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Data diversity: An approach to software fault tolerance</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">E</forename><surname>Ammann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Knight</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">On systematic design of protectors for employing OTS items</title>
		<author>
			<persName><forename type="first">P</forename><surname>Popov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Riddle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Romanovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Strigini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th Euromicro Conference</title>
		<meeting>the 27th Euromicro Conference</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Exception handling and software fault tolerance</title>
		<author>
			<persName><forename type="first">F</forename><surname>Cristian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">6</biblScope>
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Software rejuvenation: analysis, module and applications</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kintala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Kolettis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Fulton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th International Symposium on Fault-Tolerant Computing</title>
		<meeting>the 25th International Symposium on Fault-Tolerant Computing</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A survey of rollback-recovery protocols in message-passing systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Elnozahy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Alvisi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Assertion-based repair of complex data structures</title>
		<author>
			<persName><forename type="first">B</forename><surname>Elkarablieh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Garcia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">L</forename><surname>Suen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Khurshid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22th IEEE Conference on Automated Software Engineering</title>
		<meeting>the 22th IEEE Conference on Automated Software Engineering</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Automated repair of HTML generation errors in PHP applications using string constraint solving</title>
		<author>
			<persName><forename type="first">H</forename><surname>Samimi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schäfer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Artzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Millstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Tip</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Hendren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th International Conference on Software Engineering</title>
		<meeting>the 34th International Conference on Software Engineering</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Automatic input rectification</title>
		<author>
			<persName><forename type="first">F</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Ganesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Carbin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sidiroglou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th International Conference on Software Engineering</title>
		<meeting>the 34th International Conference on Software Engineering</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Atomic boxes: coordinated exception handling with transactional memory</title>
		<author>
			<persName><forename type="first">D</forename><surname>Harmanci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Gramoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Felber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th European Conference on Object-Oriented Programming</title>
		<meeting>the 25th European Conference on Object-Oriented Programming</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Generating fixes from object behavior anomalies</title>
		<author>
			<persName><forename type="first">V</forename><surname>Dallmeier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zeller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Meyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th International Conference on Automated Software Engineering</title>
		<meeting>the 24th International Conference on Automated Software Engineering</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Automatically finding patches using genetic programming</title>
		<author>
			<persName><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Goues</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Forrest</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31st International Conference on Software Engineering</title>
		<meeting>the 31st International Conference on Software Engineering</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">A novel co-evolutionary approach to automatic software bug fixing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Arcuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 11th IEEE Congress on Evolutionary Computation</title>
		<meeting>11th IEEE Congress on Evolutionary Computation</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Automated fixing of programs with contracts</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Furia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">S</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Buchholz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Meyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zeller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th International Symposium on Software Testing and Analysis</title>
		<meeting>the 19th International Symposium on Software Testing and Analysis</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
