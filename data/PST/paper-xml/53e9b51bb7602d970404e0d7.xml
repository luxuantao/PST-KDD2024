<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The Geometry of Innocent Flesh on the Bone: Return-into-libc without Function Calls (on the x86)</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Hovav</forename><surname>Shacham</surname></persName>
							<email>hovav@hovav.net</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science &amp; Engineering</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<addrLine>San Diego La Jolla</addrLine>
									<region>California</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<address>
									<settlement>Alexandria</settlement>
									<region>Virginia</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">The Geometry of Innocent Flesh on the Bone: Return-into-libc without Function Calls (on the x86)</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">F89533404F70758568461D3750170926</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:45+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.4.6 [Operating Systems]: Security and Protection Security</term>
					<term>Algorithms Return-into-libc</term>
					<term>Turing completeness</term>
					<term>instruction set</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present new techniques that allow a return-into-libc attack to be mounted on x86 executables that calls no functions at all. Our attack combines a large number of short instruction sequences to build gadgets that allow arbitrary computation. We show how to discover such instruction sequences by means of static analysis. We make use, in an essential way, of the properties of the x86 instruction set.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>We present new techniques that allow a return-into-libc attack to be mounted on x86 executables that is every bit as powerful as code injection. We thus demonstrate that the widely deployed "W⊕X" defense, which rules out code injection but allows return-into-libc attacks, is much less useful than previously thought.</p><p>Attacks using our technique call no functions whatsoever. In fact, the use instruction sequences from libc that weren't placed there by the assembler. This makes our attack resilient to defenses that remove certain functions from libc or change the assembler's code generation choices.</p><p>Unlike previous attacks, ours combines a large number of short instruction sequences to build gadgets that allow arbitrary computation. We show how to build such gadgets * Work done while at the Weizmann Institute of Science, Rehovot, Israel, supported by a Koshland Scholars Program postdoctoral fellowship.</p><p>using the short sequences we find in a specific distribution of gnu libc, and we conjecture that, because of the properties of the x86 instruction set, in any sufficiently large body of x86 executable code there will feature sequences that allow the construction of similar gadgets. (This claim is our thesis.) Our paper makes three major contributions:</p><p>1. We describe an efficient algorithm for analyzing libc to recover the instruction sequences that can be used in our attack.</p><p>2. Using sequences recovered from a particular version of gnu libc, we describe gadgets that allow arbitrary computation, introducing many techniques that lay the foundation for what we call, facetiously, returnoriented programming.</p><p>3. In doing the above, we provide strong evidence for our thesis and a template for how one might explore other systems to determine whether they provide further support.</p><p>In addition, our paper makes several smaller contributions. We implement a return-oriented shellcode and show how it can be used. We undertake a study of the provenance of ret instructions in the version of libc we study, and consider whether unintended rets could be eliminated by compiler modifications. We show how our attack techniques fit within the larger milieu of return-into-libc techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Background: Attacks and Defenses</head><p>Consider an attacker who has discovered a vulnerability in some program and wishes to exploit it. Exploitation, in this context, means that he subverts the program's control flow so that it performs actions of his choice with its credentials. The traditional vulnerability in this context is the buffer overflow on the stack <ref type="bibr" target="#b1">[1]</ref>, though many other classes of vulnerability have been considered, such as buffer overflows on the heap <ref type="bibr" target="#b29">[29,</ref><ref type="bibr" target="#b2">2,</ref><ref type="bibr" target="#b13">13]</ref>, integer overflows <ref type="bibr" target="#b34">[34,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b4">4]</ref>, and format string vulnerabilities <ref type="bibr" target="#b25">[25,</ref><ref type="bibr" target="#b10">10]</ref>. In each case, the attacker must accomplish two tasks: he must find some way to subvert the program's control flow from its normal course, and he must cause the program to act in the manner of his choosing. In traditional stack-smashing attacks, an attacker completes the first task by overwriting a return address on the stack, so that it points to code of his choosing rather than to the function that made the call. (Though even in this case other techniques can be used, such as frame-pointer overwriting <ref type="bibr" target="#b14">[14]</ref>.) He completes the second task by injecting code into the process image; the modified return address on the stack points to this code. Because of the behavior of the C-language string routines that are the cause of the vulnerability, the injected code must not contain nul bytes. Aleph One, in his classic paper, discusses how to write Linux x86 code under this constraint that execs a shell (for this reason called "shellcode") <ref type="bibr" target="#b1">[1]</ref>; but shellcodes are available for many platforms and for obtaining many goals (see, e.g., <ref type="bibr" target="#b31">[31]</ref>).</p><p>This paper concerns itself with evaluating the effectiveness of security measures designed to mitigate the attacker's second task above. There are many security measures designed to mitigate against the first task -each aimed at a specific class of attacks such as stack smashing, heap overflows, or format string vulnerabilities -but these are out of scope.</p><p>The defenders' gambit in preventing the attacker's inducing arbitrary behavior in a vulnerable program was to prevent him from executing injected code. The earliest iterations of this defensemodified the memory layout of executables to make the stack nonexecutable. Since in stacksmashing attacks the shellcode was typically injected onto the stack, this was already useful. A more complete defense, dubbed "W⊕X," ensures that no memory location in a process image is marked both writable ("W") and executable ("X"). With W⊕X, there is no location in memory into which the attacker can inject code to execute. The PaX project has developed a patch for Linux implementing W⊕X <ref type="bibr" target="#b22">[22]</ref>. Similar protections are included in recent versions of OpenBSD. AMD and Intel recently added to their processors a per-page execute disable ("NX" in AMD parlance, "XD" in Intel parlance) bit to ease W⊕X implementation, and Microsoft Windows (as of XP SP2) implements W⊕X on processors with NX/XD support. Now that the attackers cannot inject code, their response was to use, for their own purposes, code that already exists in the process image they are attacking. (It was Solar Designer who first suggested this approach <ref type="bibr" target="#b28">[28]</ref>.) Since the standard C library, libc, is loaded in nearly every Unix program, and since it contains routines of the sort that are useful for an attacker (e.g., wrappers for system calls), it is libc that is the usual target, and such attacks are therefore known as return-into-libc attacks. But in principle any available code, either from the program's text segment or from a library it links to, could be used.</p><p>By carefully arranging values on the stack, an attacker can cause an arbitrary function to be invoked, with arbitrary arguments. In fact, he can cause a series of functions to be invoked, one after the other <ref type="bibr" target="#b21">[21]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Our Results</head><p>One might reasonably ask why, in the face of return-intolibc attacks, it was considered worthwhile to invest in deploying W⊕X. The answer is that return-into-libc was considered a more limited attack than code injection, for two reasons:</p><p>1. in a return-into-libc attack, the attacker can call one libc function after another, but this still allows him to execute only straight-line code, as opposed to the branching and other arbitrary behavior available to him with code injection;</p><p>2. the attacker can invoke only those functions available to him in the program's text segment and loaded libraries, so by removing certain functions from libc it might be possible to restrict his capabilities. 1   Were the perception of return-into-libc attacks described above correct, deploying W⊕X would in fact weaken attackers. Unfortunately, we show in this paper that this perception is entirely untrue: we describe new return-intolibc techniques that allow arbitrary computation (and that are not, therefore, straight-line limited) and that do not require calling any functions whatsoever, so removing functions from libc is no help.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2.1">The Building Blocks for Our Attack</head><p>The building blocks for the traditional return-into-libc attack are functions, and these can be removed by the maintainers of libc. By contrast, the building blocks for our attack are short code sequences, each just two or three instructions long. Some are present in libc as a result of the code-generation choices of the compiler. Others are found in libc despite not having been placed there at all by the compiler. In either case, these code sequences would be very difficult to eliminate without extensive modifications to the compiler and assembler.</p><p>To understand how there exist code sequences in libc that were not placed there by the compiler, consider an analogy to English. English words vary in length, and there is no particular position on the page where a word must end and another start. Intel x86 code is like English written without punctuation or spaces, so that the words all run together. 2  The processor knows where to start reading and, continuing forward, is able to recover the individual words and make out the sentence, as it were. At the same time, one can make out more words on the page than were intentionally placed there. Some words will be suffixes of other words, as "dress" is a suffix of "address"; others will consist of the end of one word and the beginning of the next, as "head" can be found in "the address"; and so on. Here is a concrete example for the x86, taken from our testbed libc (see Section And the x86 ISA is extremely dense, meaning that a random byte stream can be interpreted as a series of valid instructions with high probability <ref type="bibr" target="#b3">[3]</ref>. Thus for x86 code it is quite easy to find not just unintended words but entire unintended sequences of words. For a sequence to be potentially useful in our attacks, it need only end in a return instruction, represented by the byte c3. 3 In analyzing a large body of code 1 One candidate for removal from libc is system, a function often used in return-into-libc attacks but not much used in Unix daemons, since it is difficult to apply securely to user input <ref type="bibr" target="#b33">[33,</ref><ref type="bibr">Section 8.3</ref>]. 2 . . . if English were a prefix-free code, to be pedantic. 3 Sequences ending with some other instructions can also be useful; see Section 5.1.</p><p>such as libc we therefore expect to find many such sequences, a claim that we codify as this paper's thesis:</p><p>Our thesis: In any sufficiently large body of x86 executable code there will exist sufficiently many useful code sequences that an attacker who controls the stack will be able, by means of the return-into-libc techniques we introduce, to cause the exploited program to undertake arbitrary computation.</p><p>By contrast, on an architecture such as MIPS where all instructions are 32 bits long and 32-bit aligned there is no ambiguity about where instructions start or stop, and no unintended instructions of the sort we describe. One way to weaken our attack is to bring the same features to the x86 architecture. McCamant and Morrisett, as part of their x86 Software Fault Isolation (SFI) design <ref type="bibr" target="#b19">[19]</ref>, propose an instruction alignment scheme that does this. However, their scheme has some downsides: first, code compiled for their scheme cannot call libraries not so compiled, so the switch must be all-or-nothing; second, the nop padding allows less code to fit in the instruction cache and the "andl $0xfffffff0, (%esp); ret" idiom imposes a data dependency that may introduce slowdowns that might be unacceptable in generalpurpose software as opposed to the traditional, more limited SFI usage scenarios. <ref type="foot" target="#foot_0">4</ref> We stress, however, that while countermeasures of this sort would impede our attack, they would not necessarily prevent it. We have taken some steps, described in Section 2, to avoid including sequences in our trie that were intentionally placed there by the compiler, but an attacker is under no such obligation, and there may well be enough sequences that are suffixes of functions in libc to mount our attack.</p><p>In relying intimately on the details of the x86 instruction set, our paper is inspired by two others: rix's Phrack article showing how to construct alphanumeric x86 shellcode <ref type="bibr" target="#b24">[24]</ref> and Sovarel, Evans, and Paul's "Where's the FEEB?," which showed how to defeat certain kinds of instruction set randomization on the x86 <ref type="bibr" target="#b30">[30]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2.2">How We Find Sequences</head><p>In Section 2, we describe an efficient algorithm for static analysis of x86 executables and libraries. In the version of libc we examined, our tool found thousands of sequences, from which we chose a small subset by means of which to mount our attack. Static analysis has recently found much use as an attack tool. For example, Kruegel et al. <ref type="bibr" target="#b16">[16]</ref> use sophisticated symbolic execution to find ways by which an attacker can regain control after supposedly restoring a program to its pristine state, with the goal of defeating hostbased intrusion detection system. In their setting, unlike ours, the attacker can execute arbitrary injected code. Their static analysis techniques, however, might be applicable to our case as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2.3">How We Use Sequences in Crafting an Attack</head><p>The way we interact with libc in return-oriented programming differs from the way we interact with libc in traditional return-into-libc attacks in three ways that make crafting gadgets a delicate, difficult task.</p><p>1. The code sequences we call are very short -often two or three instructions -and, when executed by the processor, perform only a small amount of work. In traditional return-into-libc attacks, the building blocks are entire functions, which each perform substantial tasks. Accordingly, our attacks are crafted at a lower level of abstraction, like assembler instead of a high-level language.</p><p>2. The code sequences we call generally have neither function prologue nor function epilogue, and aren't chained together during the attack in the standard ways described in the literature, e.g., by Nergal <ref type="bibr" target="#b21">[21]</ref>.</p><p>3. Moreover, the code sequences we call, considered as building blocks, have haphazard interfaces; by contrast, the function-call interface is standardized as part of the ABI.</p><p>(Recall that there is, of course, a fourth difference between our code sequences and libc functions that is what makes our attack attractive: the code sequences we call weren't intentionally placed in libc by the authors, and are not easily removed.) In Section 3, we show, despite the difficulties, how to construct gadgets -short blocks placed on the stack that chain several of instruction sequences together -that perform all the tasks one needs to perform. We describe gadgets that perform load/store, arithmetic and logic, control flow, and system call operations.</p><p>We stress that while we choose to use certain code sequences in the gadgets in Section 3, we could have used other sequences, perhaps less conveniently; and while our specific code sequences might not be found in a libc on another platform, other code sequences will be, and gadgets similar to ours could be constructed with those -at least if our thesis holds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2.4">Previous Uses of Short Sequences in Attacks</head><p>Some previous return-into-libc attacks have used short code snippets from libc. Notably, code segments of the form pop %reg; ret to set registers have been used to set function arguments on architectures where these are passed in registers, such as SPARC <ref type="bibr" target="#b20">[20]</ref> and x86-64 <ref type="bibr" target="#b15">[15]</ref>. Other examples are Nergal's "pop-ret" sequences <ref type="bibr" target="#b21">[21]</ref> and the "register spring" technique introduced by dark spyrit <ref type="bibr" target="#b6">[6]</ref> and discussed by Crandall, Wu, and Chong <ref type="bibr" target="#b5">[5]</ref>. Our attack differs in doing away altogether with calling functions in libc. The previous attacks used short sequences as glue in combining the invocations of functions in libc or in jump-starting the execution of attacker-injected code. Our technique shows that short code sequences, combined in appropriate ways, can express any computation an attacker might want to carry out, without the use of any functions.</p><p>Of the previous uses discussed here, Krahmer's borrowed code chunks exploitation technique <ref type="bibr" target="#b15">[15]</ref> is the closest to ours. Krahmer uses static analysis to look for register-pop sequences. He describes a shellcode-building tool that combines these sequences to allow arbitrary arguments to be passed to libc functions. However, exploits constructed using Krahmer's techniques are still straight-line limited and still rely on specific functions in libc -like other traditional return-into-libc attacks, and unlike the new attack we propose.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2.5">Wait, What about Zero Bytes?</head><p>The careful reader will observe that some of the gadgets we describe in Section 3 require that a nul byte be placed on the stack. This means that they cannot be used in the payload of a simple stack-smash buffer overflow. This is not a problem, however, for the following reasons:</p><p>1. We have not optimized our gadgets to avoid nul bytes.</p><p>If they are a concern, it should be possible to eliminate the use of many of them, using the same techniques used in standard shellcode construction. For example, loading an immediate 0 into %eax could be replaced by a code sequence of the form xor %eax, %eax; ret, or by a load of 0xffffffff followed by an increment. If the address of a code sequence includes a nul byte, we could have Galileo choose another instance of that sequence whose address does not include a nul byte, or we can substitute a different sequence.</p><p>2. There are other ways by which an attacker can overwrite the stack than standard buffer overflows, and not all suffer from the same constraints. For example, there is no problem writing nul bytes onto the stack in a format-string exploit.</p><p>3. We view our techniques not in isolation but as adding to the toolbox available for return-into-libc attacks. This toolbox already contains techniques for patching up nul bytes -as described, for example, by Nergal [21, Section 3.4] -that are just as applicable to exploits structured in the ways we describe.</p><p>A similar argument applies to the interaction between our techniques and address space layout randomization (ASLR). Those gadgets that do not require knowledge of addresses on the stack can be used directly in the Shacham et al. <ref type="bibr" target="#b27">[27]</ref> derandomization framework. Some of those gadgets that do require knowledge of addresses on the stack could likely be rewritten not to require it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2.6">Our Libc Testbed</head><p>We carry out our experiments on the gnu C Library distributed with Fedora Core Release 4: libc-2.3.5.so. Our testing environment was a 2.4 GHz Pentium 4 running Fedora Core Release 4, with Linux kernel version 2.6.14 and gnu libc 2.3.5, as noted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">DISCOVERING USEFUL INSTRUCTION SEQUENCES IN LIBC</head><p>In this section, we describe our algorithm for discovering useful code sequences in libc. We sifted through the sequences output by this algorithm when run on our testbed libc to select those sequences employed in the gadgets described in Section 3.</p><p>Before we describe the algorithm, we must first make more precise our definition of "useful code sequence." We say that a sequence of instructions is useful if it could be used in one of our gadgets, that is, if it is a sequence of valid instructions ending in a ret instruction and such that that none of the instructions causes the processor to transfer execution away, not reaching the ret. (It is the ret that causes the processor to continue to the next step in our attack.) We say that a useful sequence is intended if the instructions were actually inserted by the compiler in giving the machine-code compiled equivalent for some function in libc. In accordance with our thesis, the algorithm we describe attempts to avoid intended code sequences, though it does not shy away from using intended rets at the end of sequences.</p><p>Two observations guide us in the choice of a data structure in which to record our findings. First, any suffix of an instruction sequence is also a useful instruction sequence. If, for example, we discover the sequence "a; b; c; ret" in libc, then the sequence "b; c; ret" must of course also exist. Second, it does not matter to us how often some sequence occurs, only that it does. <ref type="foot" target="#foot_1">5</ref> Based on these observations, we choose to record sequences in a trie. At the root of the trie is a node representing the ret instruction; the "child-of" relation in the trie means that the child instruction immediately precedes the parent instruction at least once in libc. For example, if, in the trie, a node representing pop %eax is a child of the root node (representing ret) we can deduce that we have discovered, somewhere in libc, the sequence pop %eax; ret.</p><p>Our algorithm for populating the trie makes use of following fact: It is far simpler to scan backwards from an already found sequence than to disassemble forwards from every possible location in the hope of finding a sequence of instructions ending in a ret. When scanning backwards, the sequence-so-far forms the suffix for all the sequences we discover. The sequences will then all start at instances of the ret instruction, which we can scan libc sequentially to find.</p><p>In looking backwards from some location, we must ask: Does the single byte immediately preceding our sequence represent a valid one-byte instruction? Do the two bytes immediately preceding our sequence represent a valid twobyte instruction? And so on, up to the maximum length of a valid x86 instruction. <ref type="foot" target="#foot_2">6</ref> Any such question answered "yes" gives a new useful sequence of which our sequence-so-far is a suffix, and which we should explore recursively by means of the same approach. Because of the density of the x86 ISA, more than one of these questions can simultaneously have a "yes" answer. <ref type="foot" target="#foot_3">7</ref>Figure <ref type="figure">1</ref> presents, in pseudocode, our algorithm for finding useful sequences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">"Boring" Instructions</head><p>The definition of "boring" we use is the following:</p><p>1. the instruction is a leave instruction and is followed by a ret instruction; or 2. the instruction is a pop %ebp instruction and is immediately followed by a ret instruction; or 3. the instruction is a return or an unconditional jump.</p><p>The last of these criteria eliminates instruction streams in which control transfers elsewhere before the ret is reached, as these are useless for our purposes. The other two are intended to capture, and allow us to ignore, instruction</p><p>Algorithm Galileo: create a node, root, representing the ret instruction; place root in the trie; for pos from 1 to textseg len do: if the byte at pos is c3, i.e., a ret instruction, then: call BuildFrom(pos, root).</p><p>Procedure BuildFrom(index pos, instruction parent insn): for step from 1 to max insn len do: if bytes ˆ(pos -step) . . . (pos -1) ˜decode as a valid instruction insn then: ensure insn is in the trie as a child of parent insn; if insn isn't boring then: call BuildFrom(pos -step, insn).</p><p>Figure <ref type="figure">1</ref>: The Galileo Algorithm.</p><p>streams that are actually generated by the compiler. Because the libc we examined was compiled with frame pointer enabled, functions in libc will, by and large, end either with a "leave; ret" sequence or an equivalent where the leave instruction is replaced by mov and pop instructions.</p><p>It is important to observe that the conditions given here eliminate instruction sequences that would be useful in crafting exploits. There are three ways in which they do so. First, even if we wish to avoid calling actual functions in libc, suffixes of those functions might prove useful and, if short, difficult for the compiler-writer to eliminate. Second, the same characteristics that allow us to discover unintended instruction sequences elsewhere will also allow us to discover, within the body of libc functions, unintended sequences that end in intended "leave; ret" sequences. Third, both leave and pop %ebp are one-byte instructions, and it is possible that a "leave; ret" sequence we come upon wasn't intended at all, but is found in the libc byte stream in the same way that unintended rets are, explained in Section 5. Note that while the techniques we develop for generating programs from chains of instruction sequences do not usually interact with leaves, it is possible to modify our techniques to work in this setting using the frame-chaining methods described by Nergal <ref type="bibr" target="#b21">[21]</ref>. That we are able to mount our attacks even without using the code snippets eliminated by the conditions above gives further evidence, of course, for our thesis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Implementation and Performance</head><p>Our implementation of Galileo follows the pseudocode given above quite closely. To discover what portion of libc is mapped as an executable segment, our code parses libc's elf headers. We make use of two helper libraries. To parse the elf headers, we use gnu libelf, version 0.8.9 <ref type="bibr" target="#b23">[23]</ref>; to decode x86 instructions, we use the Bastard project's libdisasm <ref type="bibr" target="#b18">[18]</ref>, version 0.21-pre from CVS, with some local modifications. Analyzing the 1,189,501 bytes of libc's executable segment yields a trie with 15,121 nodes, and takes 1.6 sec on a 1.33 GHz PowerPC G4 with 1 GB RAM. While it should be possible to improve the running time of the algorithmfor example, by using memoization to avoid decoding a particular byte sequence in libc several times -we judged our implementation's performance to be already quite adequate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">RETURN-ORIENTED PROGRAMMING</head><p>This section is intended to serve as a catalogue for the actions that we can perform using the sequences we find in libc, and as a tutorial to return-oriented programming generally. Accordingly, we provide more explanatory detail for the earlier gadgets than the later.</p><p>Gadgets are our intermediate organizational unit. Each gadget specifies certain values to be placed on the stack that make use of one or more sequences of instructions from libc. Gadgets perform well-defined operations, such as a load, an xor, or a jump. Return-oriented programming consists in putting gadgets together that will perform the desired operations. The set of gadgets we describe is Turing complete by inspection, so return-oriented programs can do anything possible with x86 code. We stress that the code sequences pointed to by our gadgets are actually contained in libc; they are not injected with the gadgets themselves -this is ruled out by W⊕X. This is the reason that some of the sequences used are weird looking: those were the best sequences available in our testbed libc.</p><p>Each of our gadgets expects to be entered in the same way: the processor executes a ret with the stack pointer, %esp, pointing to the bottom word of the gadget. This means that, in an exploit, the first gadget should be placed so that its bottom word overwrites some function's saved return address on the stack. Further gadgets can be placed immediately after the first or, by means of the control flow gadgets given in Section 3.3, in arbitrary locations. (It is helpful for visualizing gadget placement to think of the gadgets as being instructions in a rather strange computer.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Load/Store</head><p>We consider three cases: loading a constant into a register; loading the contents of a memory location into a register; and writing the contents of a register into a memory location.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Loading a Constant</head><p>The first of these can trivially be accomplished using a sequence of the form pop %reg; ret. One such example is illustrated in Figure <ref type="figure" target="#fig_0">2</ref>. In this figure as in all the following, the entries in the ladder represent words on the stack; those with larger addresses are placed higher on the page. Some words on the stack will contain the address of a sequence in libc. Our notation for this shows a pointer from the word to the sequence. Other words will contain pointers to other words, or immediate values. In the example here, once the processor is executing the sequence pop %edx; ret, the ret that caused it to enter the gadget will also have caused %esp to be incremented by a word; the pop %edx instruction, therefore, %esp pop %edx ret 0xdeadbeef will pop the next word on the stack -0xdeadbeef, in this case -into %edx, advancing %esp once more, past the end of the gadget, so that the ret instruction causes execution to continue with the next gadget, placed above it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Loading from Memory</head><p>We choose to load from memory into the register %eax, using the sequence movl 64(%eax), %eax; ret. We first load the address into %eax, using, for example, the constant-load procedure detailed above. Because of the immediate offset in the movl instruction we use, the address in %eax must actually be 64 bytes less than the address we wish to load. We then apply the movl sequence, after which %eax contains the contents of the memory location. This procedure, and later ones, are detailed in the full version of this paper, available online <ref type="bibr" target="#b26">[26]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.3">Storing to Memory</head><p>We use the sequence movl %eax, 24(%edx); ret to store the contents of %eax into memory. We load the address to be written into %edx using the constant-load procedure above.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Arithmetic and Logic</head><p>There are many approaches by which we could implement arithmetic and logic operations. The one we choose, which we call our ALU paradigm, is as follows. For all operations, one operand is %eax; the other is a memory location. Depending on what is more convenient, either %eax or the memory location receives the computed value. This approach allows us to compute memory-to-memory operations in a simple way: we load one of the operands into %eax, using the load-from-memory methods of Section 3.1; we apply the operation; and, if the result is now held in %eax, we write it to memory, using the store-to-memory methods of the same section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Add</head><p>The most convenient sequence for performing an add that fits into our ALU paradigm is the following: addl (%edx), %eax; push %edi; ret.</p><p>(</p><formula xml:id="formula_0">)<label>1</label></formula><p>The first instruction adds the word at %edx to %eax, which is exactly what we want. The next instruction, however, creates some problems. Whereas a "popret" sequence is convenient for implementing a constant-load operation, a "pushret" sequence is inconvenient for two reasons. First, the value pushed onto the stack is then immediately used by the ret instruction as the address for the next code sequence to execute, which means the values we can push are restricted. Second, the push overwrites a word on the stack, so that if we execute the gadget again (say, in a loop) it will not behave the same. We first present a simple approach that does not take the second problem into account. Before undertaking the addl instruction sequence, we load into %edi the address of a ret instruction. In return-oriented programming, a ret acts like nop, increasing %esp but otherwise having no effect. We illustrate this version in Figure <ref type="figure" target="#fig_1">3</ref>. Observe that the push %edi instruction causes the top word on the stack to be overwritten by the contents of %edi, i.e., to point to a ret instruction.</p><p>As can be seen, the gadget is changed by the pushret sequence, and a subsequent run through it would not give an add operation. This is fine if the gadget is only executed once, but is a problem if it forms a subroutine or a loop body. The solution in this case is to fix up the last word in the gadget with the address of (1), as part of the gadget's code; it is detailed in the full version of this paper <ref type="bibr" target="#b26">[26]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Other Arithmetic Operations</head><p>The sequence neg %eax; ret allows us to compute -x given x and, together with the method for addition given above, also allows us to subtract values. There is not, in the sequences we found in libc, a convenient way to compute multiplication, but the operation could be simulated using addition and the logic operations described below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.3">Exclusive Or</head><p>We could implement exclusive or just as we implemented addition if we had available a sequence like xorl (%edx), %eax or xorl %eax, (%edx), but we do not. We do, however, have access to a bytewise operation of the form xorb %al, (%ebx). If we can move each byte of %eax into %al in turn, we can compute a wordwise xor of %eax into a memory location x by repeating the operation four times, with %ebx taking on the values x, x + 1, x + 2, and x + 3. Conveniently, we can rotate %eax using the sequence ror $0x08, %eax; ret. All that remains, then is to deal with the side effects of the xorb sequence we have: xorb %al, 0x48908c0(%ebx); and $0xff, %al; push %ebp; or $0xc9, %al; ret.</p><p>(</p><formula xml:id="formula_1">)<label>2</label></formula><p>The immediate offset in the xorb instruction means that the values we load into %ebx must be adjusted appropriately. The and and or operations have the effect of destroying the %esp pop %esp ret value in %al, but by then we have already used %al, so this is no problem. (If we want to undertake another operation with the value in %eax, we must reload it from memory.)</p><p>The push operation means that we must load into %ebp the address of a ret instruction and that, if we want the xor to be repeatable, we must rewrite the xorb instructions into the gadget each time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.4">And, Or, Not</head><p>Bitwise-and and -or are also best implemented using bytewise operations, in a manner quite similar to the xor method above. The code sequences are, respectively, andb %al, 0x5d5e0cc4(%ebx); ret and orb %al, 0x40e4602(%ebx); ret.</p><p>These code sequences have fewer side effects than (2) for xor, above, so they are simpler to employ. Bitwise-not can be implemented by xoring with the all-1 pattern.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.5">Shifts and Rotates</head><p>Rotates by any immediate (constant) value can be implemented using the sequence roll %cl, 0x17383f8(%ebx); ret. Shifts by any immediate value can be implemented by a rotate and a mask. Rotates and shifts by a variable value could be implemented using a lookup table or a loop.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Control Flow</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Unconditional Jump</head><p>Since in return-oriented programming the stack pointer %esp takes the place of the instruction pointer in controlling the flow of execution, an unconditional jump requires simply changing the value of %esp to point to a new gadget. This is quite easy to do using the instruction sequence pop %esp; ret. Figure <ref type="figure" target="#fig_2">4</ref> shows a gadget that causes an infinite loop by jumping back on itself.</p><p>Loops in return-into-libc exploits have been considered before: see Gera's "esoteric #2" challenge <ref type="bibr" target="#b9">[9]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">Conditional Jumps</head><p>These are rather more tricky. Below we develop a method for obtaining conditional jumps.</p><p>To begin, some review. The cmp instruction compares its operands and, based on their relationship, sets a number of flags in a register called %eflags. In x86 programming, it is often unnecessary to use cmp directly, because many operations set flags as a side effect. The conditional jump instructions, jcc, cause a jump when the flags satisfy certain conditions. Because this jump is expressed as a change in the instruction pointer, the conditional jump instructions are not useful for return-oriented programming: What we need is a conditional change in the stack pointer.</p><p>The strategy we develop is in three parts, which we tackle in turn:</p><p>1. Undertake some operation that sets (or clears) flags of interest.</p><p>2. Transfer the flags from %eflags to a general-purpose register, and isolate the flag of interest.</p><p>3. Use the flag of interest to perturb %esp conditionally by the desired jump amount.</p><p>For the first task, we choose to use the carry flag, CF, for reasons that will become clear below. Employing just this flag, we obtain the full complement of standard comparisons. Most easily, we can test whether a value is zero by applying neg to it. The neg instruction (and its variants) calculates two's-complement and, as a side effect, clears CF if its operand is zero and sets CF otherwise.</p><p>If we wish to test whether two values are equal, we can subtract one from the other and test (using neg, as above) whether the result is zero. If we wish to test whether one value is larger than another, we can, again, subtract the first from the second; the sub instruction (and its variants) set CF when the subtrahend is larger than the minuend.</p><p>For the second task, the natural way to proceed is the lahf instruction, which stores the five arithmetic flags (SF, ZF, AF, PF, and CF) in %ah. Unfortunately, this instruction is not available to us in the libc sequences we found. Another way is the pushf instruction, which pushes a word containing all of %eflags onto the stack. This instruction is available to us, but like all pushrets is tricky to use in a return-oriented setting.</p><p>Instead, we choose a third way. Several instructions use the carry flag, CF, as an input: in particular, left and right rotates with carry, rcl and rcr, and add with carry, adc. Add with carry computes the sum of its two operands and the carry flag, which is useful in multiword addition algorithms. If we take the two operands to be zero, the result is 1 or 0 depending on whether the carry flag is set -exactly what we need. This we can do quite easily by clearing %ecx and using the instruction sequence adc %cl, %cl; ret. We note, finally, that we can evaluate complicated Boolean expressions by collecting CF values for multiple tests and combining them with the logical operations described in Section 3.2.</p><p>For the third task, we proceed as follows. We have a word in memory that contains 1 or 0. We transform it to contain either esp delta or 0, where esp delta is the amount we'd like to perturb %esp by if the condition evaluates as true. One way to do this is as follows. The two's complement of 1 is the all-1 pattern and the two's complement of 0 is the all-0 pattern, so applying negl to the word containing CF we have all-1s or all-0s. Then taking bitwise and of the result and esp delta gives a word containing esp delta or 0. Now, we have the desired perturbation, and it is simple to apply it to the stack pointer by means of the sequence addl (%eax), %esp; addb %al, (%eax); addb %cl, 0(%eax); addb %al, (%eax); ret with %eax pointing to the displacement. The extra operations have the effect of destroying the displacement, but as it has already been used this is no problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">System Calls</head><p>Our key observation is that many system calls have simple wrappers in libc that behave, broadly, as follows:</p><p>1. move the arguments from the stack to registers, and set the syscall number in %eax;</p><p>2. trap into the kernel (indirectly through the kernelsupplied linux-gate.so.1); and 3. check for error and translate the return value appropriately, leaving it in %eax.</p><p>A typical example is the code for umask: 89 da mov %ebx, %edx 8b 5c 24 04 movl 4(%esp), %ebx b8 3c 00 00 00 mov $0x0000003C, %eax 65 ff 15 10 00 00 00 lcall %gs:0x10(,0) 89 d3 mov %edx, %ebx c3 ret</p><p>The GS-segment lcall invokes __kernel_vsyscall, which issues the sysenter or int 0x80 instruction (cf. <ref type="bibr" target="#b8">[8]</ref>). If we set up the system call parameters ourselves and jump into a wrapper at step 2 -that is, immediately before the lcall in the fourth line, for umask -we can invoke any system call we choose, with any arguments.</p><p>For system calls, then, it is safe to use intended sequences in libc, rather than the (largely) unintended sequences elsewhere. Since nearly all useful programs make system calls, the requirement that a system call wrapper function be available is milder than the requirement that specific libc routines, such as system, be available. On Linux, we can also do away with this assumption by calling __kernel_vsyscall directly, after finding it by parsing the elf auxiliary vectors (cf. <ref type="bibr">[7]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Function Calls</head><p>Finally, we note that nothing prevents us from making calls to arbitrary functions in libc. This is, in fact, the basis for previous return-into-libc exploits, and the required techniques are described in by Nergal <ref type="bibr" target="#b21">[21]</ref>; the discussion of "frame faking" is of particular interest. It suffices to add that it is best to invoke functions with the stack pointer set to a part of the stack not used by other return-oriented code, because otherwise those functions might, in using the stack, trash a gadget that we intend to reinvoke.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">RETURN-ORIENTED SHELLCODE</head><p>We now present a return-oriented shellcode as an application of the techniques laid out in Section 3. Our shellcode invokes the execve system call to run a shell. This requires:</p><p>(1) setting the system call index, in %eax, to 0xb; (2) setting the path of the program to run, in %ebx, to the string "/bin/sh"; (3) setting the argument vector argv, in %ecx, to an array of two pointers, the first of which points to the string "/bin/sh" and the second of which is null; and (4) setting the environment vector envp, in %edx, to an array of one pointer, which is null. The shellcode is in Figure <ref type="figure" target="#fig_3">5</ref>.</p><p>We store "/bin/sh" in the top two words of the shellcode; we use the next two words for the argv array, and reuse the higher of these also for the envp array. We can set up the appropriate pointers as part of the shellcode itself, but to avoid nul bytes we must zero out the null-pointer word after the shellcode has been injected. The rest of the shellcode behaves as follows:</p><p>• Word 1 (from the bottom) sets %eax to zero.</p><p>• Words 2-4 load into %edx the address of the second word in argv (minus 24; see Section 3.1.2) and, in preparation for setting the system call index, load into %ecx the all-0b word.</p><p>• Word 5 sets the second word in argv to zero.</p><p>• Word 6 sets %eax to 0x0b by modifying its least significant byte, %al.</p><p>• Words 7-8 point %ebx at the string "/bin/sh".</p><p>• Words 9-11 set %ecx to the address of the argv array and %edx to the address of the envp array.</p><p>• Word 12 traps into the kernel -see Section 3.4.</p><p>Provided that the addresses of the libc instruction sequences pointed to and of the stack addresses pointed to do no contain nul bytes, this shellcode contains no nul bytes except for the terminator for the string "/bin/sh". Nul bytes in the stack addresses can be worked around by having the shellcode build these addresses at runtime by examining %esp and operating on it; this would also allow the shellcode to be placed at various stack positions without needing retargeting. Nul bytes in libc addresses can be handled using the techniques recalled in Section 1.2.5.</p><p>Suppose that libc is loaded at base address 0x03000000 into some program. Suppose, moreover, that this program has a function exploitable by buffer overflow, with return address stored at 0x04ffffefc. In this case, the shellcode given above yields: 3e 78 03 03 07 7f 02 03 0b 0b 0b 0b 18 ff ff 4f 30 7f 02 03 4f 37 05 03 bd ad 06 03 34 ff ff 4f 07 7f 02 03 2c ff ff 4f 30 ff ff 4f 55 d7 08 03 34 ff ff 4f ad fb ca de 2f 62 69 6e 2f 73 68 00 Note that there is no nul byte except the very last. Like all the other examples of return-oriented code presented in this paper, this shellcode uses only code that is already present in libc, and will function even in the presence of W⊕X.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">A CATALOG OF RETS</head><p>In this section, we give some statistics about the origin of c3 bytes in the libc executable segment. Our methodology is a as follows. For each c3 byte that we find, we check whether it is within a span of bytes belonging to a function that is exported in libc's SYMTAB section. 8 If so, we include it in our statistics. We then disassemble the function until we discover which instruction includes the c3 byte. Not all of libc's executable segment is covered by exported functions. Some of the segment is taken up by elf headers, and some by static functions that are not named in the SYMTAB section. Nevertheless, this methodology is sufficient to allow us to draw meaningful conclusions.</p><p>Out of 975,626 covered bytes, 5,483 are c3 bytes, or one in every 178. (This is more than the expected one-in-256 because ret instructions occur often.)</p><p>• 3,429 are actually ret instructions. Since there are only 3,157 unique entrypoints listed in the SYMTAB section, this means that some functions have more than one return instruction.</p><p>• 1,692 occur in the ModR/M byte for an add imm32, %ebx instruction, opcode 81 c3 imm32. Immediateadd is part of "Immediate Grp 1" (opcodes 80-83), which use bits 3-5 of the ModR/M byte to encode an opcode extension. In this case bits 6 and 7 <ref type="bibr" target="#b11">(11)</ref> specify that the target is a register; bits 0-2 (011) name %ebx; and bits 3-5 (000) specify an add operation. For comparison, 81 c2 would encode add imm32, %edx, and 81 cb would encode or imm32, %ebx. See Tables 2-1 and A-4 of <ref type="bibr" target="#b12">[12]</ref>.</p><p>• 290 occur in immediate displacements. Of these, 273 specify offsets to the instruction point -109 relative calls, 100 relative conditional jumps, and 64 relative unconditional jumps -and the other 17 specify data offsets, as in movb %al, -61(%ebp), opcode 88 45 c3.</p><p>• 35 occur in a proper ModR/M byte, which indicates %eax and %ebx as source and target, respectively. Of these, 33 are in the instruction add %eax, %ebx, opcode 89 c3, and the other two are shrd %cl, %eax, %ebx and shld %cl, %eax, %ebx, opcodes 0f ad c3 and 0f a5 c3.</p><p>• 28 occur in immediate constants, in add, mov, and movw instructions.</p><p>• 8 occur in the SIB byte, indicating addressing of the form (%ebx,%eax,8). These all happen to be in instances of the instruction movl r/m32, r32 in which the 8 There are substantially more functions listed in the SYMTAB section than in the DYNSYM section, which lists only the functions that are actually made available for dynamic linking.</p><p>ModR/M byte specifies SIB+disp32 addressing. (Opcodes: 8b modr/m c3 imm32, with modr/m being of the form 10bbb100.)</p><p>• 1 occurs in the floating point operation fld %st(3), opcode d9 c3. (More generally, d9 c0+i encodes fld %st(i).)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Can we avoid spurious rets?</head><p>Some modest changes to GCC might yield a libc without unintended c3 bytes. For example, each procedure could have only a single exit point (with the standard leave; ret sequence), to which early exits could jump. The %ebx register could be avoided as an accumulator for adds. Moves from %eax to %ebx could be avoided or written using instructions other than mov. Instruction placement could be jiggered -in most cases, at least -to avoid offsets with c3 bytes in them.</p><p>Such a strategy might indeed succeed in ridding generated executables of unintended c3 bytes. The cost would be a compiler that is less transparent and more complicated, and a certain loss of efficiency in the use of registers on an already register-starved architecture: %ebx is handy as an accumulator because, unlike %eax, %ecx, and %edx, it is callee-saved in the Intel calling convention <ref type="bibr" target="#b32">[32]</ref>.</p><p>We must be clear, however, that while this would eliminate unintended rets, it would not eliminate unintended sequences of instructions that end in a ret. This is because whereas the attacker is now constrained to choosing attack strings that are suffixes of valid libc functions, he still need not begin his strings on an intended instruction boundary.</p><p>There is a more fundamental problem, however. The gadgets we described in Section 3 made use only of instruction sequences ending in c3 bytes because these were sufficient. However, the x86 ISA actually includes four opcodes that perform a return instruction: c3 (near return), c2 imm16 (near return with stack unwind), cb (far return), and ca imm16 (far return with stack unwind). The variants with stack unwind, having popped the return address off the stack, increment the stack pointer by imm16 bytes; this is useful in calling conventions where arguments are callee-cleaned. The far variants pop %cs off the stack as well as %eip. These three variants are more difficult to use in exploits of the sort we describe. For the far variants, the correct code segment must be placed on the stack; for the stack-unwind variants, a stack underflow must be avoided. Nevertheless, it should be possible to use them. And eliminating instances of all four would be difficult, as it would require avoiding four byte values out of 256.</p><p>Moreover, if we have the ability to load immediate values into registers, for example using the techniques of Section 3.1, then we can use some sequences that do not end in a ret. For example, if %ebx points to a ret instruction in libc, then any sequence ending in jmp %ebx can be used. This is simply register springs (cf. <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b5">5]</ref>) in a return-into-libc context. With a bit more setup, we can also use sequences ending in jmp imm(%esp), if the word at imm(%esp) contains the address of a ret, and again with other registers replacing %esp. This translates to the return-into-libc context a technique due to Litchfield <ref type="bibr" target="#b17">[17]</ref>.</p><p>Finally, we note that the libc executable image includes areas that are not intended as executable code: notably, the elf headers. These might contain return instructions as well, which modifying the compiler will not address.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSION AND FUTURE WORK</head><p>We presented a new way of organizing return-into-libc exploits on the x86 that is fundamentally different from previous techniques. By means of static analysis we discovered short instruction sequences; we then showed how to combine such sequences into gadgets that allow an attacker to perform arbitrary computation. There are several directions for future work.</p><p>A first direction is towards greater automation and integration with existing technologies. Given a collection of gadgets, one could create add a return-oriented backend to gcc or llvm. To build our gadgets we combed over the output of Galileo manually. It should be possible, however, to analyze the available code sequences automatically to discover how to combine them into gadgets.</p><p>A second research direction would attempt to validate (or invalidate) our thesis by examining C libraries in other platforms. While the gadgets we describe all derive from a particular distribution of gnu libc, the techniques we present for discovering sequences and combining them into gadgets should be universally applicable. A preliminary analysis we conducted of msvcrt.dll, the Microsoft C runtime, seemed promising.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Load the constant 0xdeadbeef into %edx.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Simple add into %eax.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: An infinite loop by means of an unconditional jump.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Shellcode.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_0"><p>Things would be better if Intel added 16-byte-aligned versions of ret, call, jmp, and jcc to the x86 instruction set.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_1"><p>From all the occurrences of a sequence, we might prefer to use one whose address does not include a nul byte over one that does.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_2"><p>Including all instruction-modifying prefixes, 20 bytes.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_3"><p>In fact, amongst the useful sequences we discover in libc there is a point where four valid instructions all end at the same point; and, examining libc as a whole, there is a point where seven valid instructions do.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank Dan Boneh, Eu-Jin Goh, Frans Kaashoek, Nagendra Modadugu, Eric Rescorla, Mike Sawka, Stefan Savage, Nick Vossbrink, and Robert Zimmerman for helpful discussions regarding this work; Avram Shacham for his detailed comments on the manuscript; and members of the MIT Cryptography and Information Security Seminar, Berkeley Systems Lunch, and Stanford Security Lunch for their comments on early presentations.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Smashing the stack for fun and profit</title>
		<author>
			<persName><forename type="first">Aleph</forename><surname>One</surname></persName>
		</author>
		<ptr target="http://www.phrack.org/archives/49/P49-14" />
	</analytic>
	<monogr>
		<title level="j">Phrack Magazine</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="issue">14</biblScope>
			<date type="published" when="1996-11">Nov. 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Once upon a free(</title>
		<author>
			<persName><surname>Anonymous</surname></persName>
		</author>
		<ptr target="http://www.phrack.org/archives/57/p57-0x09" />
	</analytic>
	<monogr>
		<title level="j">Phrack Magazine</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="issue">9</biblScope>
			<date type="published" when="2001-08">Aug. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Randomized instruction set emulation</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">G</forename><surname>Barrantes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">H</forename><surname>Ackley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Forrest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Stefanović</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Info. &amp; System Security</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="40" />
			<date type="published" when="2005-02">Feb. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Basic integer overflows</title>
		<ptr target="http://www.phrack.org/archives/60/p60-0x0a.txt" />
	</analytic>
	<monogr>
		<title level="j">Phrack Magazine</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="issue">10</biblScope>
			<date type="published" when="2002-12">Dec. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Experiences using Minos as a tool for capturing and analyzing novel worms for unknown vulnerabilities</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Crandall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">F</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">T</forename><surname>Chong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Detection of Intrusions and Malware, and Vulnerability Assessment, Second International Conference</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Julisch</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Krügel</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2005-07">2005. July 2005</date>
			<biblScope unit="volume">3548</biblScope>
			<biblScope unit="page" from="32" to="50" />
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Win32 buffer overflows (location, exploitation and prevention)</title>
		<ptr target="http://www.phrack.org/archives/55/P55-15" />
	</analytic>
	<monogr>
		<title level="j">Phrack Magazine</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="issue">15</biblScope>
			<date type="published" when="1999-09">Sept. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">About ELF auxiliary vectors</title>
		<author>
			<persName><forename type="first">M</forename><surname>Garg</surname></persName>
		</author>
		<ptr target="Online:manugarg.googlepages.com/aboutelfauxiliaryvectors" />
		<imprint>
			<date type="published" when="2006-08">Aug. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Garg</surname></persName>
		</author>
		<title level="m">Sysenter based system call mechanism in Linux</title>
		<imprint>
			<date type="published" when="2006-07">July 2006</date>
		</imprint>
	</monogr>
	<note>Online: manugarg.googlepages.com/systemcallinlinux2 6.html</note>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Insecure programming by example</title>
		<author>
			<persName><surname>Gera</surname></persName>
		</author>
		<ptr target="Online:community.corest.com/∼gera/InsecureProgramming/" />
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Advances in format string exploiting</title>
		<author>
			<persName><forename type="first">Riq</forename><surname>Gera</surname></persName>
		</author>
		<ptr target="http://www.phrack.org/archives/59/p59-0x07.txt" />
	</analytic>
	<monogr>
		<title level="j">Phrack Magazine</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="issue">7</biblScope>
			<date type="published" when="2001-07">July 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Big loop integer protection</title>
		<author>
			<persName><forename type="first">O</forename><surname>Horovitz</surname></persName>
		</author>
		<ptr target="http://www.phrack.org/archives/60/p60-0x09.txt" />
	</analytic>
	<monogr>
		<title level="j">Phrack Magazine</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="issue">9</biblScope>
			<date type="published" when="2002-12">Dec. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">IA-32 Intel Architecture Software Developer&apos;s Manual</title>
	</analytic>
	<monogr>
		<title level="m">Instruction Set Reference</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2</biblScope>
		</imprint>
		<respStmt>
			<orgName>Intel Corporation</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">M</forename><surname>Kaempf</surname></persName>
		</author>
		<ptr target="http://www.phrack.org/archives/57/p57-0x08" />
	</analytic>
	<monogr>
		<title level="j">Vudo malloc tricks. Phrack Magazine</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="issue">8</biblScope>
			<date type="published" when="2001-08">Aug. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The frame pointer overwrite</title>
		<ptr target="http://www.phrack.org/archives/55/P55-08" />
	</analytic>
	<monogr>
		<title level="j">Phrack Magazine</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="issue">8</biblScope>
			<date type="published" when="1999-09">Sept. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">x86-64 buffer overflow exploits and the borrowed code chunks exploitation technique</title>
		<author>
			<persName><forename type="first">S</forename><surname>Krahmer</surname></persName>
		</author>
		<ptr target="http://www.suse.de/∼krahmer/no-nx.pdf" />
		<imprint>
			<date type="published" when="2005-09">Sept. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Automating mimicry attacks using static binary analysis</title>
		<author>
			<persName><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kirda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th USENIX Sec. Symp</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Mcdaniel</surname></persName>
		</editor>
		<meeting>14th USENIX Sec. Symp</meeting>
		<imprint>
			<publisher>USENIX</publisher>
			<date type="published" when="2005-08">Aug. 2005</date>
			<biblScope unit="page" from="161" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Defeating the stack based buffer overflow prevention mechanism of Microsoft Windows</title>
		<author>
			<persName><forename type="first">D</forename><surname>Litchfield</surname></persName>
		</author>
		<ptr target="http://www.ngssoftware.com/papers/defeating-w2k3-stack-protection.pdf" />
		<imprint>
			<date type="published" when="2003">2003 Server, Sept. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<ptr target="http://bastard.sourceforge.net/libdisasm.html" />
		<title level="m">mammon . The Bastard project: libdisasm</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Evaluating SFI for a CISC architecture</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mccamant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Morrisett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 15th USENIX Sec. Symp</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Keromytis</surname></persName>
		</editor>
		<meeting>15th USENIX Sec. Symp</meeting>
		<imprint>
			<publisher>USENIX</publisher>
			<date type="published" when="2006-07">July 2006</date>
			<biblScope unit="page" from="209" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Defeating Solaris/SPARC non-executable stack protection</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mcdonald</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bugtraq</title>
		<imprint>
			<date type="published" when="1999-03">Mar. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The advanced return-into-lib(c) exploits (PaX case study)</title>
		<author>
			<persName><surname>Nergal</surname></persName>
		</author>
		<ptr target="http://www.phrack.org/archives/58/p58-0x04" />
	</analytic>
	<monogr>
		<title level="j">Phrack Magazine</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2001-12">Dec. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">PaX non-executable pages design &amp; implementation</title>
		<author>
			<orgName type="collaboration">PaX Team</orgName>
		</author>
		<ptr target="pax.grsecurity.net/docs/noexec.txt" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Riepe</forename><surname>Libelf</surname></persName>
		</author>
		<ptr target="http://www.mr511.de/software/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Writing ia32 alphanumeric shellcodes)</title>
		<ptr target="http://www.phrack.org/archives/57/p57-0x18" />
	</analytic>
	<monogr>
		<title level="j">Phrack Magazine</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="issue">15</biblScope>
			<date type="published" when="2001-12">Dec. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<ptr target="http://www.team-teso.net" />
		<title level="m">Scut/team teso. Exploiting format string vulnerabilities</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">The geometry of innocent flesh on the bone, Oct</title>
		<author>
			<persName><forename type="first">H</forename><surname>Shacham</surname></persName>
		</author>
		<ptr target="http://hovav.net/dist/geometry.pdf" />
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">On the effectiveness of address-space randomization</title>
		<author>
			<persName><forename type="first">H</forename><surname>Shacham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Page</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pfaff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E.-J</forename><surname>Goh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Modadugu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 11th ACM Conf. Comp. and Comm. Sec. -CCS 2004</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Pfitzmann</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Liu</surname></persName>
		</editor>
		<meeting>11th ACM Conf. Comp. and Comm. Sec. -CCS 2004</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2004-10">Oct. 2004</date>
			<biblScope unit="page" from="298" to="307" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">return-to-libc&quot; attack</title>
		<author>
			<persName><forename type="first">Solar</forename><surname>Designer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bugtraq</title>
		<imprint>
			<date type="published" when="1997-08">Aug. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">JPEG COM marker processing vulnerability in Netscape browsers</title>
		<author>
			<persName><forename type="first">Solar</forename><surname>Designer</surname></persName>
		</author>
		<ptr target="Online:www.openwall.com/advisories/OW-002-netscape-jpeg/" />
		<imprint>
			<date type="published" when="2000-07">July 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Where&apos;s the FEEB? the effectiveness of instruction set randomization</title>
		<author>
			<persName><forename type="first">N</forename><surname>Sovarel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Paul</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th USENIX Sec. Symp</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Mcdaniel</surname></persName>
		</editor>
		<meeting>14th USENIX Sec. Symp</meeting>
		<imprint>
			<publisher>USENIX</publisher>
			<date type="published" when="2005-08">Aug. 2005</date>
			<biblScope unit="page" from="145" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title/>
		<ptr target="http://www.metasploit.com/shellcode.html" />
	</analytic>
	<monogr>
		<title level="j">The Metasploit Project. Shellcode archive</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m">The Santa Cruz Operation. System V Application Binary Interface: Intel386 Architecture Processor Supplement</title>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
	<note>fourth edition</note>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Secure Programming for Linux and Unix HOWTO</title>
		<author>
			<persName><forename type="first">D</forename><surname>Wheeler</surname></persName>
		</author>
		<ptr target="http://www.dwheeler.com/secure-programs/" />
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
	<note>Linux Documentation Project</note>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Remote vulnerability in SSH daemon CRC32 compression attack detector</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zalewski</surname></persName>
		</author>
		<ptr target="http://www.bindview.com/Support/RAZOR/Advisories/2001/advssh1crc.cfm" />
		<imprint>
			<date type="published" when="2001-02">Feb. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
