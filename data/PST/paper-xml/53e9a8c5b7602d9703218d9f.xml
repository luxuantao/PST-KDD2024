<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A General Composition Theorem for Secure Reactive Systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Michael</forename><surname>Backes</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">IBM Zurich Research Lab</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Birgit</forename><surname>Pfitzmann</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">IBM Zurich Research Lab</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Michael</forename><surname>Waidner</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">IBM Zurich Research Lab</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">A General Composition Theorem for Secure Reactive Systems</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">0A938A79D486A6F2E259EE04488FBA3E</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:58+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We consider compositional properties of reactive systems that are secure in a cryptographic sense. We follow the well-known simulatability approach of modern cryptography, i.e., the specification is an ideal system and a real system should in some sense simulate this ideal one. We show that if a system consists of a polynomial number of arbitrary ideal subsystems such that each of them has a secure implementation in the sense of blackbox simulatability, then one can securely replace all ideal subsystems with their respective secure counterparts without destroying the blackbox simulatability relation. We further prove our theorem for universal simulatability by showing that blackbox simulatability implies universal simulatability under reasonable assumptions. We show all our results with concrete security.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In recent times, the analysis of cryptographic protocols has been getting more and more attention, and thus the demand for general frameworks for representing cryptographic protocols and their security requirements has been rising. To enable a cryptographically correct analysis of cryptographic protocols, such frameworks have to capture probabilistic behaviors, complexity-theoretically bounded adversaries as well as a reactive environment of the protocol, i.e., continuous interaction with users and an adversary, e.g., in many protocol runs. Clearly, such frameworks further have to be rigorously defined to avoid ambiguities and to enable convincing proofs. Moreover, it is highly desirable that such frameworks provide a link to formal methods, i.e., to tool-supported verification of cryptographic protocols. Tool support can minimize flaws, which occur quite often if the distributed-systems aspects of cryptographic protocols are analyzed by hand. One ingredient for this is that the model should contain an abstract machine model besides Turing machines. The model of Pfitzmann and Waidner <ref type="bibr" target="#b30">[31]</ref> is suitable for all these requirements and we use it as a rigorous foundation of this work.</p><p>The model of <ref type="bibr" target="#b30">[31]</ref> introduced a notion of security-preserving refinement, called reactive simulatability. This notion captures the idea of refinement that preserves not only integrity properties but also confidentiality properties. Intuitively it can be stated as follows, when applied to the relation between a real and an ideal system: <ref type="foot" target="#foot_0">1</ref> Everything that can happen to users of the real system in the presence of an arbitrary adversary A can also happen to the same users with the ideal system, where attack capabilities are usually much more restricted, in the presence of another adversary A ′ . In particular, it comprises confidentiality because the notion of what happens to users, called their view, not only includes their in-and outputs to the system, but also their communication with the adversary. This includes whether the adversary can guess secrets of the users or partial information about them. As it is often desirable to impose further restrictions on how the adversary A ′ against the ideal service is constructed, simulatability comes in different flavors. The two most prominent ones (besides general simulatability as described above, which does not impose any restriction on A ′ ) are universal simulatability, which states that A ′ has to be independent of the actual users of the protocol, and the (seemingly) more restrictive notion of black-box simulatability, which states that A ′ consists of the original adversary A and a simulator that may only depend on the protocol itself.</p><p>One of the key results in the considered model is a composition theorem <ref type="bibr" target="#b30">[31]</ref>. It states that if a larger system is designed based on a specification of a subsystem, and the implementation of the subsystem is later plugged in, the entire implementation of the larger system is as secure as its design in the same sense of reactive simulatability. This theorem (as well as its predecessor <ref type="bibr" target="#b29">[30]</ref> for a synchronous reactive model) holds for all variants of simulatability (general, universal, and blackbox), but it is restricted to replacing one system. Obviously, a constant number of systems can then be replaced by applying the theorem multiple times.</p><p>In this work, we present a more comprehensive composition theorem for blackbox simulatability by showing that a polynomial number (in a security parameter) of arbitrary systems can be composed without destroying the simulatability relation. The proof relies on what is often called a "standard hybrid argument" as first used in <ref type="bibr" target="#b14">[15]</ref>. We further show that universal simulatability implies black-box simulatability under reasonable assumptions. This is of independent interest, but it in particular allows us to prove our theorem also for universal simulatability. We show all our results with concrete security. Related Literature. Simulatability was first sketched for secure multi-party function evaluation, i.e., for the computation of one output tuple from one tuple of secret inputs from each participant in <ref type="bibr" target="#b32">[33]</ref> and defined (with different degrees of generality and rigorosity) in <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b8">9]</ref>. While composition theorems for special cases were proven in <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b26">27]</ref>, the first general composition theorem for non-reactive simulatability was proven in <ref type="bibr" target="#b8">[9]</ref>.</p><p>An important step towards compositionality results of reactive systems was taken in <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b19">20]</ref>, where the cryptographic security of specific systems was directly defined and verified using a formal language, the π-calculus, and security was expressed using observational equivalence. This notion is even stronger than reactive simulatability because the entire environment (corresponding to users and adversary together for reactive simulatability) must not be able to distinguish the implementation and the specification. Correspondingly, the concrete specifications used were not abstract; they essentially comprise the actual protocols including all cryptographic details. Composition was defined in the calculus by defining processes with "holes" for other processes, which then allows for composing a constant number of systems.</p><p>A reactive simulatability definition was first proposed (after some earlier sketches, in particular in <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b8">9]</ref>) in <ref type="bibr" target="#b15">[16]</ref>. It is synchronous, covers a restricted class of protocols (straightline programs with restricted operators, in view of the constructive result of this paper), and simulatability is defined for the information-theoretic case only, where it can be done with a quantification over input sequences instead of active honest users.</p><p>The first composition theorem for reactive simulatability was given in <ref type="bibr" target="#b29">[30]</ref> for a general synchronous reactive model, followed by essentially the same composition theorem <ref type="bibr" target="#b30">[31]</ref> in the corresponding asynchronous model. Later than <ref type="bibr" target="#b30">[31]</ref> but independently, another model of asynchronous reactive systems together with a composition theorem for reactive simulatability was developed in <ref type="bibr" target="#b9">[10]</ref>. The theorem is specific for universal simulatability, but for this case it is more general than the ones in <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b30">31]</ref> since it additionally allows for securely composing a polynomial number of copies of an ideal service, which naturally correspond to different protocol instances in the real implementation. We stress that our composition theorem in this paper not only captures secure composition of a polynomial number of copies of one single ideal system but also of a polynomial number of truly arbitrary systems. However, our work was inspired by <ref type="bibr" target="#b9">[10]</ref>.</p><p>Besides considering composition as secure refinement, property-based composition has received interest in the literature: It considers the question whether systems that individually provide certain security properties still have these properties when they are run in parallel with other systems. For safety and liveness, general theories of this kind of compositionality exist <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b0">1]</ref>, which are sufficient to reason about most functional system properties. However, many security properties are not safety and liveness properties, in particular confidentiality. Compositional information flow properties were first investigated in <ref type="bibr" target="#b22">[23]</ref>. After that, much work has been devoted to identifying properties which are preserved under composition like, e.g., restrictiveness <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b23">24]</ref>, forward correctability <ref type="bibr" target="#b17">[18]</ref>, or separability <ref type="bibr" target="#b24">[25]</ref>. For certain security properties that are in general not preserved under composition, it is known how to restrict composition in order to preserve these properties <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b25">26]</ref>. More recent work concentrated on a uniform basis to reason about property-based composition <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b10">11]</ref>.</p><p>Somewhere between both notions of composition, so-called preservation theorems exist, which state that specific properties are preserved under (reactive) simulatability. Such theorems exist for integrity <ref type="bibr" target="#b1">[2]</ref>, transitive and non-transitive non-interference <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4]</ref>, i.e., absence of information flow, and a class of liveness properties <ref type="bibr" target="#b4">[5]</ref>.</p><p>Outline. In Section 2 we review the model of reactive systems in asynchronous networks. Section 3 contains our composition theorem and its proof for black-box simulatability. In Section 4, we show that universal simulatability implies black-box simulatability and reasonable assumptions. In particular, this can be used to carry over our composition theorem for universal simulatability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Asynchronous Reactive Systems</head><p>In this section, we review our model for secure reactive systems in an asynchronous network from <ref type="bibr" target="#b30">[31]</ref>. Several definitions are only sketched whereas those that are important for understanding our results are given in full detail. All other details can be looked up in the original paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">General System Model</head><p>Systems mainly consist of several interactive machines. Machines communicate via ports (local endpoints for different potential channels) and messages are strings over an alphabet Σ. Inspired by the CSP-Notation <ref type="bibr" target="#b16">[17]</ref>, we write output and input ports as q! and q? respectively. As in similar models, channels are defined implicitly by naming convention (and not by a separate graph), that is port q! sends messages to q?. For asynchronous timing, a message is not immediately delivered to its recipient, but first stored in a special machine q called a buffer. If a machine wants to schedule the i-th message of buffer q, it must have the unique clock-out port q ⊳ !, and it sends i at q ⊳ !, see Figure <ref type="figure">1</ref>. The buffer then outputs and deletes its i-th message. For a port p, we write p c to denote the port which it connects to according to Figure <ref type="figure">1</ref>, i.e., q! c = q ↔ ?, q ↔ ! c = q?, q ⊳ ! c = q ⊳ ? and vice versa. The in-and output ports in a port set or port sequence P are denoted in(P ) and out(P ). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1.</head><p>Ports and buffers. Specifications only need to spell out the black part.</p><p>Our primary machine model is probabilistic state-transition machines, similar to probabilistic I/O automata as in Lynch <ref type="bibr" target="#b20">[21]</ref> (and also essentially in <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b26">27]</ref>). If a machine is switched, it receives an input tuple at its input ports and performs its transition function. This yields a new state and an output tuple in the deterministic case, or a finite distribution over such pairs in the probabilistic case. Moreover, each machine has a function bounding the length of the considered inputs; this allows flexible time bounds independent of the environment. Two restrictions apply to δ M : Every output distribution has to be finite and if I = (ǫ, . . . , ǫ), then δ M (s, I) = (s, (ǫ, . . . , ǫ)). Inputs are ignored beyond the length bounds, i.e., δ M (s, I) = δ M (s, I⌈ l M (s) ) for all I ∈ I M , where r ⌈ l for l ∈ N,r ∈ Σ * denotes the lsymbol prefix, and the notation is lifted to tuples. We further demand l M (s) = (0, . . . , 0) for every s ∈ Fin M . 3</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1. (Machines) A machine is a tuple</head><formula xml:id="formula_0">M = (name M , Ports M , States M , δ M , l M , Ini M , Fin M ) of a name name M ∈ Σ + ,</formula><p>In the text, we often write "M" for name M . The set (in contrast to the sequence) of ports of a machine M is denoted by ports(M), and similar for sets of machines.</p><p>A collection Ĉ of machines is a set of machines with pairwise different machine names and disjoint sets of ports. The completion [ Ĉ ] of a collection Ĉ is the union of all machines of Ĉ and the buffers needed for every channel. A port of a collection is called free if its connecting port is not in the collection. These ports will be connected to the users and the adversary. The free ports of a completion [ Ĉ ] are denoted as free([ Ĉ ]). A collection Ĉ is called closed if its completion [ Ĉ ] has no free ports except a special master clock-in port clk ⊳ ?.</p><p>A closed collection represents a "runnable" system and a probability space of runs (sometimes called traces or executions) is defined for it. Machines switch sequentially, i.e., we have exactly one active machine M at any time. If this machine has clock outports, it can select the next message to be delivered by scheduling a buffer via one of these clock out-ports. If the buffer contains a message at the selected position, it delivers this message, and the receiving machine is the next active machine. If M tries to schedule multiple messages, only one is taken, and if it schedules none or the message does not exist, the master scheduler X becomes active. Formally, runs are defined as follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2. (Runs and Views) Let Ĉ be a closed collection with master scheduler X.</head><p>Runs and their probability spaces are defined inductively by the following algorithm for each tuple ini ∈ × M∈ Ĉ Ini M of initial states. The algorithm maintains variables for the state of each machine and treats each port as a variable over Σ * , initialized with ǫ except for clk ⊳ ? := 1. It further maintains a variable M CS ("current scheduler") over machine names, initially M CS := X, for the currently active non-buffer machine, and a variable r for the resulting run, an initially empty list. The algorithm has five phases. Probabilistic choices only occur in Phase 1. Whenever a machine (this may be a buffer) M switches from (s, I) to (s ′ , O), we add a step (name M , s, I, s ′ , O) to the run r with the following two restrictions. First, we cut each input according to the respective length function, i.e., we replace I by I ′ := I⌈ l M (s) . Secondly, we do not add the step to the run if I ′ = (ǫ, . . . , ǫ), i.e., if nothing happens in reality. This gives a random variable run Ĉ ,ini for each tuple ini ∈ × M∈ Ĉ of initial states, and similarly for l-step prefixes run Ĉ ,ini,l .</p><p>The view of a subset M ⊆ Ĉ of machines in a run r is the subsequence of r consisting of those steps where a machine of M switches. This gives a random variable view Ĉ ,ini ( M ) for each tuple ini of initial states, and similarly for l-step prefixes view Ĉ ,ini,l ( M ) of the view. For a singleton M = {H} we write view Ĉ ,ini (H) for view Ĉ ,ini ({H}). 3</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Security-specific System Model</head><p>We now define specific collections for security purposes. We start with the definition of structures. Intuitively, these are the machines that execute a security protocol. They have a distinguished set of service ports. This is a subset of the free ports where, intuitively, a certain service is guaranteed, while remaining free ports are meant only for the adversary. Typical examples of inputs at service ports are "send message m to participant id " for a message transmission system or "pay amount x to participant id " for a payment system, while typical non-service ports are those of insecure network connections in a real system. For cryptographic purposes, the initial state of all machines in a structure is a security parameter k in unary representation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3. (Structures and Service Ports</head><formula xml:id="formula_1">) A structure is a pair struc = ( M , S )</formula><p>where M is a collection of simple machines (i.e., with only normal in-and out-ports and clock out-ports) with {1} * ⊆ Ini M for all M ∈ M , and S ⊆ free([ M ]). The set S is called service ports. 3</p><p>Forbidden ports for users of a structure are those that clash with port names of given machines and those that would link the user to a non-service port. A system is a set of structures. The idea behind systems is that there may be different actual structures depending on the set of actually malicious participants.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 5. (Systems) A system Sys is a set of structures. 3</head><p>A structure can be complemented to a configuration by adding a user machine and an adversary machine. The user is restricted to connecting to the service ports. The adversary closes the collection, i.e., it connects to the remaining service ports, the other free ports S M of the collection, and the free ports of the user. Thus, user and adversary can interact, e.g., for modeling active attacks. 3</p><formula xml:id="formula_2">Definition 6. (Configurations) A configuration of a structure ( M , S ) is a tuple conf = ( M , S ,</formula><p>Circuit complexity, i.e., non-uniform complexity, is natural for this definition because one can consider every machine M, used only for security parameter k, as a separate circuit. Meaningful uniform complexity for such a definition requires a universal machine that simulates all these structures, and a generation algorithm for structures. However, our results are reductions with concrete security (as first introduced as a general concept with special notation in <ref type="bibr" target="#b7">[8]</ref>), and usable for a wide range of complexity measures. In those reductions we actually work with Turing complexity because it is defined in full detail for our interacting machines.</p><p>A parametrized system considers the potentially used subsystems as potentially available from the start. This is also implicitly the case in <ref type="bibr" target="#b9">[10]</ref> because although a subsystem is said to be generated there, it springs up magically in distributed locations by this operation. This means that all the connections must be assumed to be predefined. A truly dynamic system would need to distribute port or machine names of new machines, like the π-calculus does. We do not see any specific reason while our theorem should not hold for this case but it would require a rigorous definition first.</p><p>We now define user and adversary of a parametrized system. To reason about the complexity of users and adversaries, or more generally families of machines, we define the parametrized complexity.</p><p>Definition 9. (Parametrized Complexity) Let X = k∈N X k be a partitioned index set (with the same conventions as for systems) and let A = (A x ) x∈X be a family of machines with {1} * ⊆ Ini Ax for every x ∈ X. We say that A is of complexity t : N → N if for all x ∈ X k , the runtime of A x on initial input 1 k is bounded by t(k) in the sense of circuit complexity. We sometimes write t A for "the" complexity of A. 3</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Defining Security with Simulatability</head><p>Reactive simulatability essentially means that whatever might happen to an honest user in a real system Sys 1 can also happen in an ideal system Sys 2 . More precisely, for every configuration conf 1 of Sys 1 , there exists a configuration conf 2 of Sys 2 with the same user yielding indistinguishable views for this user. A typical situation is illustrated in Figure <ref type="figure" target="#fig_7">2</ref>.</p><formula xml:id="formula_3">H H A 2 A 1 S S M 1 M 2 TH M 3 ∀ ∀ ∃ Real configuration Ideal configuration</formula><p>Fig. <ref type="figure" target="#fig_7">2</ref>. Example of simulatability. The view of H is compared.</p><p>However, we do not want to compare a structure of Sys 1 with arbitrary structures of Sys 2 , but only with certain suitable ones. What suitable means in a concrete situation can be defined by a mapping f from Sys 1 to Sys 2 . The mapping f is called valid if it maps structures with the same service ports, so that the same user can connect.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 10. (Valid Mappings)</head><p>A valid mapping between two systems Sys 1 and Sys 2 is a function f : Sys 1 → Sys 2 with ( M2 , S 2 ) = f (( M1 , S 1 )) ⇒ S 1 = S 2 . We call f (( M1 , S 1 )) the corresponding structure of ( M1 , S 1 ). If the systems are parametrized, we also require f (Sys 1,k ) ⊆ Sys 2,k for all k ∈ N.</p><p>3</p><p>A technical problem for reactive simulatability is that a correct user of a structure from Sys 1 might have forbidden ports in the corresponding structure. Configurations where this does not happen are called suitable; we restrict the simulatability definition to those. We omit a rigorous definition for brevity. For a valid mapping f : Sys 1 → Sys 2 , let Conf f (Sys 1 ) be the set of suitable configurations. We present the definition of indistinguishability for two families of random variables with a common partitioned index set and with versions for concrete security, following <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b11">12]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 11. (Indistinguishability) Let two families (var x ) x∈X and (var ′</head><p>x ) x∈X of discrete probability distributions (random variables) on common domains (D x ) x∈X be given with a partitioned index set X = k∈N X k (with the same conventions as for systems).</p><p>-They are called perfectly indistinguishable iff var x = var ′</p><p>x for all x ∈ X. -They are called statistically δ-indistinguishable for a function δ :</p><formula xml:id="formula_4">N → R ≥0 iff the statistical distance ∆ stat (var x , var ′ x ) := 1 2 d∈Dx |Pr(var x = d) -Pr(var ′ x = d)| is at most δ(k) for all k and all x ∈ X k .</formula><p>-An algorithm Dis is called a (t, δ)-distinguisher for var x and var ′</p><p>x for t ∈ N, δ ∈ R ≥0 , and x ∈ X k iff its complexity is at most t and</p><formula xml:id="formula_5">δ Dis x := |Pr(Dis(1 k , var x ) = 1) -Pr(Dis(1 k , var ′ x ) = 1)| ≥ δ.</formula><p>-The distributions are called polynomially indistinguishable iff for all polynomials t and all distinguishers (Dis x ) x∈X with complexity t in their first parameter, there exists a negligible function δ such that δ Dis x ≤ δ(k) for all k and all x ∈ X k .</p><p>3</p><p>We write "≈ y " for indistinguishability with y = perf, δ, or poly, respectively. We write "≈" if we want to treat all cases together, and we often write "=" for "≈ perf ". We later need that indistinguishability of families of random variables implies indistinguishability of functions of them, e.g., of "parts" of the random variables. Lemma 1. (Indistinguishability of Derived Distributions) Let var, var ′ be families of probability distributions with partitioned index set X and a common family of domains D, and let φ = (φ x ) x∈X be a family of functions φ x on D x (to strings, but encoding domains as strings is not made explicit). Then the following holds:</p><formula xml:id="formula_6">-var ≈ y var ′ ⇒ φ(var) ≈ y φ(var ′ ) if y is perf, or a function δ.</formula><p>-Every (t, δ)-distinguisher Dis φ for φ(var x ) and φ(var ′</p><p>x ) gives rise to a (t ′ , δ)distinguisher Dis for var x and var ′</p><p>x with t ′ = t + t φ (b(k)), where t φ : N → N denotes the complexity of φ, and b : N → N bounds the length of the random variables, i.e., |v| ≤ b(k) for all v ∈ D x and x ∈ X k .</p><p>var ≈ poly var ′ ⇒ φ(var) ≈ poly φ(var ′ ) if the random variables are of polynomial length, and φ is of polynomial complexity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>This is clear for the perfect case, and can be easily shown by computations on statistical distances for the statistical case. For concrete complexity and the computational case, the distinguisher family Dis for the original distributions is defined by Dis x (1 k , v) := Dis φ,x (1 k , φ(v)) for all k and x ∈ X k , and for v of length at most b(k).</p><p>We are now ready to define reactive simulatability for parametrized systems. We require that there exists an extension f C of the valid structure mapping f to a configuration mapping that leaves the user unchanged, i.e., we skolemize the existence of corresponding adversaries in Figure <ref type="figure" target="#fig_7">2</ref>. We then consider the families of user views view conf 1 (H) and view f C (conf 1 ) (H) where all machines have initial input 1 k for the security parameter k to which this configuration belongs. Each of these two families contains one well-defined probability distribution for each configuration conf 1 . Overall these are two families of distributions with the partitioned index set Conf f (Sys 1 ) = k∈N Conf f (Sys 1,k ). Similarly, we obtain two families view conf 1 ,l (H) and view f C (conf 1 ),l (H) for l-step prefixes of user views. Definition 12. (Reactive Simulatability) Let parametrized systems Sys 1 and Sys 2 with a valid mapping f be given. For reactive simulatability, we require that there exists a function f C : Conf f (Sys 1 ) → Conf(Sys 2 ) with f C (conf 1 ).struc = f (conf 1 .struc) and f C (conf 1 ).H = conf 1 .H for all conf 1 ∈ Conf f (Sys 1 ), and with the following properties. We say that f C is a τ -mapping for a structure struc 1 and a function τ : N → N if the complexity t f C (conf 1 ).A is bounded by τ (t conf 1 .A ) for all conf 1 ∈ Conf(struc 1 ). The entire f C is a τ -mapping for a function τ :</p><formula xml:id="formula_7">N 2 → N if for all conf 1 ∈ Conf f (Sys 1 ) we have t f C (conf 1 ).A ≤ τ (k, t conf 1 ).</formula><p>We say that Sys 1 ≥ f,y sec Sys 2 , spoken "y ′ -at least as secure as", under the following conditions for different cases of y and y ′ , where we abbreviate H := conf 1 .H: a) y = perf and y ′ = "perfectly" iff view conf 1 (H) and view f C (conf 1 ) (H) are perfectly indistinguishable for every conf 1 ∈ Conf f (Sys 1 ). b) y = δ and y ′ = "δ-statistically" for a function δ :</p><formula xml:id="formula_8">N 2 → R ≥0 iff for ev- ery conf 1 ∈ Conf f (Sys 1,k ) and every l ∈ N we have view conf 1 ,l (H) ≈ δ(k,l) view f C (conf 1 ),l (H). c) Concrete security: An algorithm Dis is called a (t, δ)-distinguisher for conf 1 ∈ Conf f (Sys 1,k ) and f C (conf 1 )</formula><p>where t ∈ N and δ ∈ R ≥0 iff its complexity is at most t and δ Dis conf 1 ≥ δ where</p><formula xml:id="formula_9">δ Dis conf 1 := |Pr(Dis(1 k , view conf 1 (H)) = 1) -Pr(Dis(1 k , view f C (conf 1 ) (H)) = 1)|.</formula><p>e) y = poly and y ′ = "polynomially" iff for all users H and adversary A of polynomial complexity, the views (view</p><formula xml:id="formula_10">( M ,S ,H ( M ,S ) ,A ( M ,S ) ) (H ( M ,S ) )) ( M ,S )∈Sys 1 and (view f C (( M ,S ,H ( M ,S ) ,A ( M ,S ) )) (H ( M ,S ) )) ( M ,S )∈Sys 1</formula><p>are polynomially indistinguishable and f C is a P -mapping for a polynomial P .</p><p>Universal simulatability means that f C (conf 1 ).A (i.e., A 2 in Figure <ref type="figure" target="#fig_7">2</ref>) for conf 1 = ( M1 , S , H, A 1 ) only depends on M1 , S , and A 1 . We write ≥ uni,f,y sec instead of ≥ f,y sec if we want to emphasize this case.</p><p>3</p><p>Where the difference between the types of security is irrelevant, we only write ≥ f sec , and we omit the indices f and sec if they are clear from the context.</p><p>An essential ingredient in the composition theorem and other uses of the model is a notion of combining several machines into one, and a lemma that this makes no essential difference in views. The combination is defined in a canonical way by considering a combined state space and letting each transition function operate on its respective part. We omit details for brevity. The combination of a set M of machines is written comb( M ) and we sometimes write comb(M 1 , . . . , M j ) for comb({M 1 , . . . , M j }).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 2. (Machine Combination) Let Ĉ be a collection without buffers, and D ⊆ Ĉ . The view of every set of original machines in ( Ĉ \ D ) ∪ {comb( D )} is the same as in Ĉ . This includes the view of the submachines in comb( D ), which is well-defined given Ĉ and D. The Turing complexity of comb( D) is the sum of the complexities of the machines in comb( D ).</head><p>We can now add the notion of blackbox simulatability to Definition 12. Here A 2 is given as the combination of a fixed "simulator" Sim and a machine A ′ 1 that is identical to A 1 up to port renaming.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 13. (Blackbox Simulatability) With the notation of Definition 12, blackbox simulatability means that we have functions f</head><p>Sim from Sys 1 to machines (the simulators for the structures) and f σ from Sys 1 to port renaming functions such that for all conf 1 = ( M1 , S , H, A 1 ) ∈ Conf f (Sys 1 ) we have f C (conf 1 ) = ( M2 , S , H, A 2 ) with ( M2 , S ) = f (( M1 , S )) and A 2 = comb(Sim, A ′ 1 ) with Sim := f Sim (( M1 , S 1 )) and A ′ 1 := f σ (( M1 , S 1 ))(A 1 ). For computational security, we require that Sim is polynomial-time, i.e., that the parametrized complexity of (f Sim (( M1 , S ))) ( M1,S )∈Sys 1 is polynomially bounded. We write ≥ bb sec instead of ≥ sec if we want to emphasize this case (with the respective superscripts). 3</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Composition</head><p>When composing several systems, one typically does not want to compose every structure of one system with every structure of the others, but only with certain matching ones. For instance, if the individual machines of Sys 2 are implemented on the same physical devices as those of Sys 1 , as usual in a layered distributed system, we only compose structures corresponding to the same set of corrupted physical devices. However, this is not the only conceivable situation. Hence we do not define a composition operator that produces one specific composition, but a set of possible compositions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 14. (Composability and Composition of Structures) We call structures</head><formula xml:id="formula_11">( M1 , S 1 ), . . . , ( Mn , S n ) composable if ports( Mi ) ∩ forb( Mj , S j ) = ∅ and S i ∩ free([ Mj ]) = S j ∩ free([ Mi ]</formula><p>) for all i = j. <ref type="foot" target="#foot_1">2</ref> We then define their composition as</p><formula xml:id="formula_12">( M1 , S 1 )|| . . . ||( Mn , S n ) := ( M , S ) with M := M1 ∪ . . . ∪ Mn and S := (S 1 ∪ . . . ∪ S n ) ∩ free([ M ]).<label>3</label></formula><p>We now define the composition of variably many systems, i.e., there is a potentially infinite supply of systems from which a finite number P (k) is chosen for composition for each security parameter k.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 15. (Parametrized Composition of Systems)</head><p>Let a sequence Sysseq = (Sys (i) ) i∈N be given where each Sys (i) is a parametrized system, and let P : N → N be a function. Then a P -sized composition of Sysseq is a parametrized system Sys * where for all k ∈ N, every structure ( M * , S * ) ∈ Sys * k has a unique representation</p><formula xml:id="formula_13">( M * , S * ) = ( M1 , S 1 )|| . . . ||( MP (k) , S P (k) ) with composable structures ( Mi , S i ) ∈ Sys (i)</formula><p>k for i = 1, . . . , P (k).We call ( Mi , S i ) the restriction of ( M * , S * ) to Sys (i) and write ( Mi , S i ) = ( M * , S * )⌈ Sys (i) .</p><p>3</p><p>If the systems Sys (i) have a joint bounding function Q, then P •Q is a bounding function for Sys * . In particular, if P and Q are polynomials, then Sys * is polynomial-time.</p><p>In this section, we show that reactive blackbox simulatability is consistent with the composition of a parametrized number of systems, in particular polynomially many in the computational case. The basic idea is the following: Assume that we have proven that a potentially infinite supply of systems Sys (i) are as secure as systems Sys ′(i) in the sense of black-box simulatability. Now we want to use Sys (i) as a secure replacement for Sys ′(i) , i.e., as an implementation of the ideal system Sys ′(i) . The following theorem shows that such modular proofs are possible. The situation is shown in the upper part of Figure <ref type="figure">3</ref>. Additional conditions in the theorem are that all corresponding structures are composable and that, for the polynomial case, the security of the system is in certain sense uniform.</p><p>Theorem 1. (Secure Parametrized Composition, Blackbox Case) Let Sysseq = (Sys (i) ) i∈N and Sysseq ′ = (Sys ′(i) ) i∈N be sequences of parametrized systems. Let f = (f (i) ) i∈N be a sequence of valid mappings f (i) : Sys (i) → Sys ′(i) , and let Sys (i) ≥ bb,f (i) ,yi sec Sys ′(i) for all i ∈ N. Let P : N → N, and let Sys # and Sys * denote the P -sized compositions of Sysseq and Sysseq ′ , respectively. Assume that the following structural conditions hold for all k ∈ N and every structure ( M # , S ) ∈ Sys # k : Let its restrictions be ( Mi , S i ) := ( M # , S )⌈ Sys (i) and the corresponding structures</p><formula xml:id="formula_14">( M ′ i , S i ) := f (i) (( Mi , S i )) for all i ≤ P (k). Then the composition f # (( M # , S )) := ( M ′ 1 , S 1 ) || • • • || ( M ′ P (k) , S P (k) )</formula><p>exists and lies in Sys * k . Furthermore, ( Mi , S i ) and ( M ′ j , S j ) must be composable for j = i, and ports( M ′ i ) ∩ S c j = ports( Mi ) ∩ S c j for all j = i. Then we have </p><formula xml:id="formula_15">Sys # ≥ bb,f # ,</formula><formula xml:id="formula_16"># ∈ Conf f # (Sys # k ), a (t, δ)- distinguisher for conf # and f C (conf # ) gives rise to a (t ′ , δ ′ )-distinguisher for conf (i) and f C (conf (i) ) for a conf (i) ∈ Conf(Sys (i) k ) with δ ′ = δ P (k) and t ′ = t + b ′ (k)</formula><p>, where b ′ (k) is a polynomial independent of t conf # .A . (Details are given in the proof.) d) with y = poly if y i = poly for all i ∈ N and under the following conditions: The function P is polynomially bounded, and the systems Sys (i) have a joint bounding polynomial Q. The complexities of the simulator families induced by the mappings f</p><formula xml:id="formula_17">(i)</formula><p>Sim are bounded by a joint polynomial Q Sim . The distinguishing probabilities of the system pairs (Sys (i) , Sys ′(i) ) are uniformly bounded, i.e., for all polynomials t there exists a negligible function δ such that for all distinguishers Dis, all i, k ∈ N,</p><formula xml:id="formula_18">and all conf = ( Mi , S i , H, A) ∈ Conf f (i) (Sys (i) k ) we have (t Dis ≤ t(k) ∧ t H ≤ t(k) ∧ t A ≤ t(k)) ⇒ δ Dis conf ≤ δ(k) (recall Definition 12d).</formula><p>2</p><p>The first statement to be proved is extracted into the following lemma.</p><p>Lemma 3. Under the conditions of Theorem 1, the mapping f # is a valid mapping between Sys # and Sys * . 2</p><p>The proof is straightforward as in <ref type="bibr" target="#b29">[30]</ref>, but heavy on notation. Hence we omit it in this short version. Recall that blackbox simulatability was defined by a function that selects one fixed simulator for each structure (Definition 13).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 16. (Simulator and Corresponding Configurations) Under the conditions of Theorem 1 and for all</head><formula xml:id="formula_19">i ∈ N, let f (i)</formula><p>Sim and f</p><formula xml:id="formula_20">(i)</formula><p>A be the simulator and renaming functions from which f</p><formula xml:id="formula_21">(i)</formula><p>C is composed by blackbox simulatability. We compose them into functions f # Sim and f # A on Sys # as follows: Given k ∈ N and</p><formula xml:id="formula_22">( M # , S ) ∈ Sys # k , let Sim i := f (i)</formula><p>Sim (( Mi , S i )) for all i ≤ P (k), and let</p><formula xml:id="formula_23">f # Sim (( M # , S )) := comb(Sim 1 , . . . , Sim P (k) ); further let f # A := f (P (k)) A • • • • • f<label>(1)</label></formula><p>A . Let f # C be constructed from f # , f # Sim , and f # A by the equations in Definition 13 (blackbox simulatability).</p><p>3</p><p>The complexity t Sim of the simulator is t Sim (k) =</p><formula xml:id="formula_24">P (k)</formula><p>i=1 t Simi (k) by Lemma 2. In the polynomial case, there exists a polynomial Q Sim such that t Sim i ≤ Q Sim for all i, hence t Sim (k) is polynomially bounded by</p><formula xml:id="formula_25">P (k) • Q Sim (k).</formula><p>We also omit the technical proof that indeed f # C : Conf f # (Sys # ) → Conf(Sys * ) in Definition 16. It is nevertheless interesting that these proof parts that verify the compatibility of channels and the difference of service ports and adversary ports in compositions make up the major part of a rigorous proof, while the cryptographic aspects are shorter and more standard. Now we can concentrate on proving that the simulator simulates correctly. The proof consists of a hybrid argument as first used in <ref type="bibr" target="#b14">[15]</ref>, i.e., we construct intermediate configurations that differ only in the machines of one system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof (Theorem 1). Let a configuration conf</head><formula xml:id="formula_26"># = ( M # , S , H, A) ∈ Conf f # (Sys #</formula><p>k ) be given and conf * := f # C (conf # ) the corresponding configuration according to Definition 16. Let the sub-structures ( Mi , S i ) and ( M ′ i , S ′ i ), the simulators Sim i , and functions f x z with various indices be defined as in the formulation of the theorem and Definition 16. Furthermore, let ( M * , S ) := f * (( M # , S )) and Sim := f # Sim (( M # , S )). Then we have conf * = ( M * , S , H, comb(Sim, f # A (A))); recall that f # A is just a port renaming; hence Figure <ref type="figure">3</ref> simplifies it to A.</p><p>The outline of the hybrid argument is as follows.</p><formula xml:id="formula_27">M 3 M 2 A conf # H M' 1 M 3 M 2 A conf hyb i Sim 1 H hyb i H M' 1 M 3 M' 2 A conf ' hyb i Sim 1 H hyb i Sim 2 H M' 1 M' 3 A Sim 1 Sim 3 M' 2 Sim 2</formula><p>conf * Sim Fig. <ref type="figure">3</ref>. Configurations in the composition theorem for blackbox simulatability.</p><p>1. We define hybrid configurations conf hyb i of Sys (i) and conf ′hyb i of Sys ′(i) for i = 1, . . . , P (k). In conf hyb i the first i-1 real structures have already been replaced with their ideal counterparts, while in conf ′hyb i also the i-th structure has been replaced. To make these configurations correct configurations of the respective systems, all other machines are grouped into an overall hybrid user H hyb i as shown at the bottom of Figure <ref type="figure">3</ref> for i = 2 and P (k) = 3. 2. We show that these are correct and corresponding configurations with respect to the given blackbox simulatability between Sys (i) and Sys ′(i) . 3. We show that the views of H in conf ′hyb i and conf hyb i+1 are equal for i = 1, . . . , P (k) -1. Moreover, we show that the views of H are equal in conf # and conf hyb 1 , and in conf ′hyb P (k) and conf * . This gives a kind of indistinguishability chain (for one configuration)</p><formula xml:id="formula_28">view conf # (H) ≈ view conf hyb 1 (H) ≈ • • • ≈ view conf ′hyb P (k) (H) ≈ view conf * (H).</formula><p>4. We show that this implies indistinguishability between first and last elements.</p><p>We now explain these steps in more detail.</p><p>Step 1: For i = 1, . . . , P (k), let the machine collection for the i-th hybrid user be Ĥi :</p><formula xml:id="formula_29">= {H} ∪ 1≤j&lt;i M ′ j ∪ {Sim j | 1 ≤ j &lt; i} ∪ i&lt;j≤P (k) Mj , and let H hyb i := comb( Ĥi ).</formula><p>Furthermore let</p><formula xml:id="formula_30">A i := f (i-1) A • • • • • f<label>(1)</label></formula><p>A (A) and</p><formula xml:id="formula_31">A ′ i := f (i) A (A i ).</formula><p>Then we define the hybrid configurations as</p><formula xml:id="formula_32">conf hyb i := ( Mi , S i , H hyb i , A i ); conf ′hyb i := ( M ′ i , S i , H hyb i , comb(Sim i , A ′ i )).</formula><p>For the computational case, we have to show that the family of H hyb i is polynomial-time. This holds since t H hyb i ≤ t H + t Sim + t M # + t M * by Lemma 2, where each addend is polynomially bounded by assumption.</p><p>Step 2: We have to show that conf hyb i ∈ Conf fi (Sys i ) and conf ′hyb i ∈ Conf(Sys ′ i ), i.e., essentially that the hybrid users do not use non-service ports. In this short version, we omit this proof. Then the definition of conf hyb i and conf ′hyb i immediately implies</p><formula xml:id="formula_33">conf ′hyb i = f (i) C (conf hyb i ),<label>(1)</label></formula><p>i.e., these are indistinguishable configurations under the given blackbox simulatability between Sys (i) and Sys ′(i) .</p><p>Step 3: The configurations conf ′hyb i and conf hyb i+1 consist of the same collection of machines Ĉi :</p><formula xml:id="formula_34">= Ĥi ∪ { M ′ i , Sim i , A ′ i }.</formula><p>Combining them in different ways does not alter the view of H by Lemma 2. Thus we have</p><formula xml:id="formula_35">view conf ′hyb i (H) = view conf hyb i+1 (H)<label>(2)</label></formula><p>for all i ∈ {1, . . . , P (k)}, and similarly</p><formula xml:id="formula_36">view conf # (H) = view conf hyb 1 (H) ∧ view conf hyb P (k) (H) = view conf * (H).<label>(3)</label></formula><p>Step 4: We now distinguish the type of the given simulatability relations Sys (i) ≥ bb,f (i) ,yi sec Sys ′(i) . For perfect simulatability, Equation (1) gives us view conf hyb i (H) = view conf ′hyb i (H) for all i. With Equations ( <ref type="formula" target="#formula_35">2</ref>) and (3) this yields view conf # (H) = view conf * (H). This result for an arbitrary fixed configuration conf # implies equality of all families of such views.</p><p>For statistical simulatability, let Sys (i) be δ i -statistically at least as secure as Sys ′(i) . Let l ∈ N. For prefixes of length l and v ranging over the potential views of this length, we abbreviate q # v := Pr(view conf # ,l (H) = v ), and q * v := Pr(view conf * ,l (H) = v ), and q i,v := Pr(view conf hyb i ,l (H) = v ) and q ′ i,v := Pr(view conf ′hyb i ,l (H) = v ) for all i. For all potential views v , we have q ′ i,v = q i+1,v and q # v = q 1,v and q ′ P (k),v = q * v by Equations ( <ref type="formula" target="#formula_35">2</ref>) and (3). The desired statistical distance is</p><formula xml:id="formula_37">δ stat (conf # ) := 1 2 v |q # v -q * v | = 1 2 v |q 1,v -q 2,v + q 2,v -q 3,v + • • • + q P (k),v -q ′ P (k),v | ≤ 1 2 v (|q 1,v -q 2,v | + |q 2,v -q 3,v | + • • • + |q P (k),v -q ′ P (k),v |) = P (k) i=1 1 2 v |q i,v -q ′ i,v | = P (k) i=1 ∆ stat (view conf hyb i ,l (H), view conf ′hyb i ,l (H)).</formula><p>With Lemma 1 this gives</p><formula xml:id="formula_38">δ stat (conf # ) ≤ P (k) i=1 ∆ stat (view conf hyb i ,li (H hyb i ), view conf ′hyb i ,li (H hyb i )) ≤ P (k) i=1 δ(k, l i ),</formula><p>where the l i are sufficiently large numbers to ensure that the l-step prefix of the view of H in conf hyb i is a subsequence of the l i -step prefix of the view of</p><formula xml:id="formula_39">H hyb i . A general bound is the complexity of H hyb i , which is bounded by b := t H + t M # + t M * + t Sim . This implies δ stat (conf # ) ≤ P (k) • δ(k, b(k)) as desired.</formula><p>For concrete complexity and for a (t, ∆ Dis )-distinguisher Dis, we have by definition</p><formula xml:id="formula_40">∆ Dis ≤ |Pr(Dis(1 k , view conf # (H)) = 1) -Pr(Dis(1 k , view conf * (H)) = 1)|.</formula><p>We abbreviate q # := Pr(Dis(1 k , view conf # (H)) = 1) and q * := Pr(Dis(1 k , view conf * (H)) = 1), and q i := Pr(Dis(1 k , view conf hyb i (H)) = 1) and q ′ i := Pr(Dis(1 k , view conf ′hyb i (H)) = 1) for all i, and ∆ i := |q iq ′ i |. Now Equations ( <ref type="formula" target="#formula_35">2</ref>) and (3) yield</p><formula xml:id="formula_41">∆ Dis = |q # -q * | = |q 1 -q 2 + q 2 -q 3 + q 3 + • • • + q P (k) -q ′ P (k) | ≤ |q 1 -q 2 | + |q 2 -q 3 | + • • • + |q P (k) -q ′ P (k) | = ∆ 1 + ∆ 2 + • • • + ∆ P (k) .</formula><p>This implies that there exists some i with ∆ i ≥ ∆ Dis P (k) . We can now consider Dis as a (t, ∆ i )-distinguisher Dis (i) φ of a function φ of views of the actual user H hyb i of the i-th hybrid systems. Here φ is defined by φ(v) := v⌈ H , i.e., the restriction to the view of H. The complexity t φ of φ is linear. Hence Lemma 1 implies that there exists a (t i , ∆ i )-distinguisher Dis (i)  </p><formula xml:id="formula_42">≤ P • Q Sim .</formula><p>The length of runs and thus views in our current representation is bounded by the square of this complexity (but this might be improvable by tighter encoding). This yields the desired polynomial bound b ′ (k) independent of the adversary complexity.</p><p>For polynomial simulatability, let H, A be a user and an adversary for Sys # of complexity t H and t A , and let t be a polynomial and Dis a distinguisher family of complexity t. Then the functions t H hyb i , t i , and t Ai = t A are polynomials. By assumption, there exists a negligible function δ that uniformly bounds the advantage of distinguishers for the given system pairs for the complexity function max(t i , t H hyb i , t Ai ). Now let a configuration conf # = ( M # , S , H ( M # ,S ) , A ( M # ,S ) ) be given. The concrete security considerations and Equation (1) imply ∆ i = δ Dis </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">From Black-Box to Universal Simulatability</head><p>We now show a relation between universal simulatability and black-box simulatability. It allows us to apply our general composition theorem to universal simulatability under reasonable assumptions, but it also is of independent interest. More precisely, we show that universal simulatability for two parametrized systems Sys 1 and Sys 2 is equivalent to black-box simulatability if Sys 1 fulfills the following structural requirements: Whenever a clock-out port of a structure ( M1 , S 1 ) ∈ Sys 1 is contained in S c 1 , then so is either the corresponding input or output port. This means that the adversary is not allowed to schedule messages of a connection where it is neither the sender nor the recipient. This condition is naturally fulfilled for insecure channels, since the adversary is inserted between the connections of two machines of the system. For concrete security, if ≥ uni,f sec is given with a τ -mapping f C , then we obtain ≥ bb,f sec with simulator complexity τ (t Sys 1 ), and a (t, δ)-distinguisher for the views in the blackbox case gives rise to a (t ′ , δ)-distinguisher for the views in the universal case where t ′ is the sum of t and the view length of H and A. 2</p><p>Proof. The left-to-right direction is clear by definition. The difficult direction is to show that universal simulatability implies black-box simulatability. Due to lack of space, we can only present a short sketch. This direction essentially consists of four steps:</p><p>1. Let a configuration conf 1 = ( M1 , S , H, A 1 ) of the sub-system Sys 1,k be given. We first derive another configuration conf uni 1 = ( M1 , S , H uni , A ′ 1 ) of Sys 1 as follows: We insert a machine TS P ,b,k , called transparent scheduler, into the connections between A 1 and the simple ports in S1 . It forwards messages between machines of the structure and the adversary. Its parameters P and b correspond to the ports that the transparent scheduler connects to and a bound on its runtime, which is the joint runtime of the machines in M1 . This machine only depends on M1 , S , and k. The new user is the combination H uni := comb(H, A 1 ), and the new adversary is A ′ 1 := TS P ,b,k . We show that the views of both H and A 1 are identical in the two configurations. 2. We now show that conf uni 1 ∈ Conf f (Sys 1 ) and apply the precondition Sys 1 ≥ uni,f sec Sys 2 . This yields an indistinguishable configuration conf uni 2 of Sys 2 with a new adversary A 2 . By the definition of universal simulatability, A 2 only depends on M1 , S and on A ′ 1 = TS P ,b,k . Since TS P ,b,k only depends on M1 and S , the adversary A 2 also only depends on M1 and S .</p><p>3. We obtain a configuration conf 2 with the original user and a simulator from conf uni 2 by reversing the combination of H and A 1 into H uni , and by defining the simulator as Sim := A 2 . We show that this does not affect the view of H. 4. Combining several equalities between views of H in different configurations and one indistinguishability gives the same class of indistinguishability.</p><p>Summarized statements follow from this treatment per configuration, i.e., with concrete security (although details are omitted here), as usual.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>a finite sequence Ports M of ports, a set States M ⊆ Σ * of states, a probabilistic state-transition function δ M , a length function l M : States M → (N ∪ {∞}) |in(Ports M )| , and sets Ini M , Fin M ⊆ States M of initial and final states. Its input set is I M := (Σ * ) |in(Ports M )| ; the i-th element of an input tuple denotes the input at the i-th in-port. Its output set is O M := (Σ * ) |out(Ports M )| . The empty word, ǫ, denotes no in-or output at a port. δ M probabilistically maps each pair (s, I) ∈ States M × I M to a pair (s ′ , O) ∈ States M × O M .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>1 . 5 .</head><label>15</label><figDesc>Switch current scheduler: Switch the current machine M CS , i.e., set (s ′ , O) ← δ M CS (s, I) for its current state s and in-port values I. Then assign ǫ to all in-ports of M CS . 2. Termination: If X is in a final state, the run stops. (As X made no outputs in this case, this only prevents repeated master clock inputs.) 3. Store outputs: For each simple out-port o! of M CS with o! = ǫ, in their given order, switch buffer o with input o ↔ ? := o!. Then assign ǫ to these ports o! and o ↔ ?. 4. Clean up scheduling: If at least one clock out-port of M CS has a value = ǫ, let n ⊳ ! denote the first such port and assign ǫ to the others. Otherwise let clk ⊳ ? := 1 and M CS := X and go to Phase 1. Deliver scheduled message: Switch buffer n with input n ⊳ ? := n ⊳ !, set n? := n ↔ ! and then assign ǫ to all ports of n and to n ⊳ !. If n? = ǫ let clk ⊳ ? := 1 and M CS := X. Else let M CS := M ′ for the unique machine M ′ with n? ∈ ports(M ′ ). Go to Phase 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Definition 4 .</head><label>4</label><figDesc>(Forbidden Ports) For a structure ( M , S ) let S M := free([ M ]) \ S . We call forb( M , S ) := ports( M ) ∪ S c M the forbidden ports. 3</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Definition 8 .</head><label>8</label><figDesc>(User and Adversary of a Parametrized System) A user and an adversary of a parametrized system Sys are families (H struc ) struc∈Sys , (A struc ) struc∈Sys such that ( M , S , H ( M ,S ) , A ( M ,S ) ) ∈ Conf(Sys) for all ( M , S ) ∈ Sys.3</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>y = perf if y i = perf for all i ∈ N. b) with y = P (k) • δ(k, b(k)) if all y i are bounded by a function δ : N 2 → R ≥0 , and where b(k) is the sum of the complexity of the systems, the user, and the simulators. c) With concrete complexity: For every conf</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>k), and therefore δ Disconf # ≤ P (k) • δ(k)is negligible. This proves the desired polynomial indistinguishability of the families of user views over Sys # and Sys * .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Theorem 2 .</head><label>2</label><figDesc>(Relating Black-box and Universal Simulatability) Let Sys 1 , Sys 2 be two parametrized systems with a valid mapping f , where for every structure ( M1 , S 1 ) ∈ Sys 1 , we have p ⊳ ! ∈ S c 1 ⇒ (p? ∈ S c 1 ∨ p! ∈ S c 1 ). Then Sys 1 ≥ bb,f,y sec Sys 2 iff Sys 1 ≥ uni,f,y sec Sys 2 for y = perf or a function δ and also for y = poly if Sys 1 is polynomial-time.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>In many typical systems, the structures only depend on the trust model, but not on the security parameter k. In a parametrized system this is different. Hence such a system is partitioned into different subsystems for different values of k. "Normal" systems can naturally be identified with parametrized systems where all subsystems are equal. Definition 7. (Parametrized Systems) A parametrized system is a system Sys together with a partitioning (Sys k ) k∈N , i.e., the elements Sys k are pairwise disjoint systems with Sys = k∈N Sys k . In slight abuse of notation we also call the sequence of partitions Sys, and if the system is called Sys, the notation Sys k always refers to the k-th element in the partition sequence.A bounding function for a parametrized system is a function P such that for all k ∈ N and ( M , S ) ∈ Sys k we have | M | ≤ P (k) and the runtime of every M ∈ M on initial input 1 k is bounded by P (k) in the sense of circuit complexity (more precisely, circuit size). A parametrized system is polynomial-time if it has a polynomial bounding function.</figDesc><table /><note><p><p><p><p><p><p><p>H, A) where -H is a machine called user with ports(H) ∩ forb( M , S ) = ∅ and {1} * ⊆ Ini H , -A is a machine called adversary with {1} * ⊆ Ini A , -and the completion Ĉ := [ M ∪ {H, A}] is a closed collection.</p>The set of configurations of ( M , S ) is written Conf( M , S ). The notation Conf() is lifted to sets of structures, i.e., systems. We write conf . M for conf</p><ref type="bibr" target="#b0">[1]</ref> </p>(component selection function) and similarly conf .S , conf .H, and conf .A, and conf .struc for conf</p><ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref></p>. 3</p>2.3 Parametrized Systems</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>for view conf hyb</figDesc><table><row><cell>and view conf ′hyb i</cell><cell>(H hyb</cell><cell>i</cell><cell>(H hyb i )</cell></row></table><note><p><p>i ) with t i = t + b ′ (k),</p>where b ′ (k) bounds the length of the views of H hyb i . The complexity t H hyb i of H hyb i is bounded by b = t H + t M # + t M * + t Sim , and above we showed t Sim</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Other terms are implementation and specification, or in special cases cryptographic and abstract system.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>The first condition makes one structure a valid user of another. The second one excludes cases where p ∈ free([ Mi])∩free([ Mj]) (e.g., a clock port for a connection between these structures) and p ∈ Si but p ∈ Sj .</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank Anupam Datta, Dennis Hofheinz, Ralf Küsters, John Mitchell, Jörn Müller-Quade, Dusko Pavlovic and Rainer Steinwandt for interesting discussions.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Conjoining specifications</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="507" to="534" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Cryptographically sound and machine-assisted verification of security protocols</title>
		<author>
			<persName><forename type="first">M</forename><surname>Backes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Jacobi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 20th Annual Symposium on Theoretical Aspects of Computer Science (STACS), volume 2607 of LNCS</title>
		<meeting>20th Annual Symposium on Theoretical Aspects of Computer Science (STACS), volume 2607 of LNCS</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="675" to="686" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Computational probabilistic non-interference</title>
		<author>
			<persName><forename type="first">M</forename><surname>Backes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pfitzmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th European Symposium on Research in Computer Security (ESORICS), volume 2502 of LNCS</title>
		<meeting>7th European Symposium on Research in Computer Security (ESORICS), volume 2502 of LNCS</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="1" to="23" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Intransitive non-interference for cryptographic purposes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Backes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pfitzmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 24th IEEE Symposium on Security &amp; Privacy</title>
		<meeting>24th IEEE Symposium on Security &amp; Privacy</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="140" to="152" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Polynomial fairness and liveness</title>
		<author>
			<persName><forename type="first">M</forename><surname>Backes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pfitzmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Steiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Waidner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 15th IEEE Computer Security Foundations Workshop (CSFW)</title>
		<meeting>15th IEEE Computer Security Foundations Workshop (CSFW)</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="160" to="174" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Secure multiparty protocols and zero knowledge proof systems tolerating a faulty minority</title>
		<author>
			<persName><forename type="first">D</forename><surname>Beaver</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="75" to="122" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The security of cipherblock chaining</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Killian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology: CRYPTO &apos;94</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">839</biblScope>
			<biblScope unit="page" from="341" to="358" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Optimal asymmetric encryption</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology: EUROCRYPT &apos;94</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">950</biblScope>
			<biblScope unit="page" from="92" to="111" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Security and composition of multiparty cryptographic protocols</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="143" to="202" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Universally composable security: A new paradigm for cryptographic protocols</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="m">Proc. 42nd IEEE Symposium on Foundations of Computer Science (FOCS)</title>
		<meeting>42nd IEEE Symposium on Foundations of Computer Science (FOCS)</meeting>
		<imprint>
			<date type="published" when="2000">2001. 2000/67</date>
			<biblScope unit="page" from="136" to="145" />
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
	<note>Extended version in Cryptology ePrint Archive</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Secure protocol composition (extended abstract)</title>
		<author>
			<persName><forename type="first">A</forename><surname>Datta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Derek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pavlovic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1st ACM Workshop on Formal Methods in Security Engineering (FMSE)</title>
		<meeting>1st ACM Workshop on Formal Methods in Security Engineering (FMSE)</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="11" to="23" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<title level="m">Foundations of Cryptography: Basic Tools</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">How to play any mental game -or -a completeness theorem for protocols with honest majority</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 19th Annual ACM Symposium on Theory of Computing (STOC)</title>
		<meeting>19th Annual ACM Symposium on Theory of Computing (STOC)</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="218" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Fair computation of general functions in presence of immoral majority</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Levin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology: CRYPTO &apos;90</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">537</biblScope>
			<biblScope unit="page" from="77" to="93" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Probabilistic encryption</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="270" to="299" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Player simulation and general adversary structures in perfect multiparty computation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hirt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Maurer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="31" to="60" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
		<title level="m">Communicating Sequential Processes. International Series in Computer Science</title>
		<meeting><address><addrLine>Hemel Hempstead</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Security and the composition of machines</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Javier</forename><surname>Thayer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1st IEEE Computer Security Foundations Workshop (CSFW)</title>
		<meeting>1st IEEE Computer Security Foundations Workshop (CSFW)</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="72" to="89" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A probabilistic poly-time framework for protocol analysis</title>
		<author>
			<persName><forename type="first">P</forename><surname>Lincoln</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Scedrov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 5th ACM Conference on Computer and Communications Security</title>
		<meeting>5th ACM Conference on Computer and Communications Security</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="112" to="121" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Probabilistic polynomial-time equivalence and security analysis</title>
		<author>
			<persName><forename type="first">P</forename><surname>Lincoln</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Scedrov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 8th Symposium on Formal Methods Europe (FME 1999</title>
		<meeting>8th Symposium on Formal Methods Europe (FME 1999</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1708</biblScope>
			<biblScope unit="page" from="776" to="793" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Distributed Algorithms</title>
		<author>
			<persName><forename type="first">N</forename><surname>Lynch</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Morgan Kaufmann Publishers</publisher>
			<pubPlace>San Francisco</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">On the composition of secure systems</title>
		<author>
			<persName><forename type="first">H</forename><surname>Mantel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 23rd IEEE Symposium on Security &amp; Privacy</title>
		<meeting>23rd IEEE Symposium on Security &amp; Privacy</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="88" to="101" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Specifications for multi-level security and a hook-up property</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mccullough</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 8th IEEE Symposium on Security &amp; Privacy</title>
		<meeting>8th IEEE Symposium on Security &amp; Privacy</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="161" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A hookup theorem for multilevel security</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mccullough</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="563" to="568" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A general theory of composition for trace sets closed under selective interleaving functions</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mclean</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 15th IEEE Symposium on Security &amp; Privacy</title>
		<meeting>15th IEEE Symposium on Security &amp; Privacy</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="79" to="93" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A general theory of composition for a class of &quot;possibilistic&quot; security properties</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mclean</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="53" to="67" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Secure computation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology: CRYPTO &apos;91</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">576</biblScope>
			<biblScope unit="page" from="392" to="404" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Proofs of network of processes</title>
		<author>
			<persName><forename type="first">J</forename><surname>Misra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">M</forename><surname>Chandy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="417" to="426" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A general framework for formal notions of &quot;secure</title>
		<author>
			<persName><forename type="first">B</forename><surname>Pfitzmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Waidner</surname></persName>
		</author>
		<ptr target="http://www.semper.org/sirene/lit/abstr94.html#PfWa_94" />
	</analytic>
	<monogr>
		<title level="j">systems. Research Report</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">94</biblScope>
			<date type="published" when="1994-04">Apr. 1994</date>
		</imprint>
		<respStmt>
			<orgName>University of Hildesheim</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Composition and integrity preservation of secure reactive systems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Pfitzmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Waidner</surname></persName>
		</author>
		<ptr target="http://www.semper.org/sirene/publ/PfSW1_00ReactSimulIBM.ps.gz" />
	</analytic>
	<monogr>
		<title level="m">Proc. 7th ACM Conference on Computer and Communications Security</title>
		<meeting>7th ACM Conference on Computer and Communications Security</meeting>
		<imprint>
			<date type="published" when="2000-05">2000. May 2000</date>
			<biblScope unit="volume">3206</biblScope>
			<biblScope unit="page" from="245" to="254" />
		</imprint>
	</monogr>
	<note>Extended version. with Matthias Schunter</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">A model for asynchronous reactive systems and its application to secure message transmission</title>
		<author>
			<persName><forename type="first">B</forename><surname>Pfitzmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Waidner</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="m">Proc. 22nd IEEE Symposium on Security &amp; Privacy</title>
		<meeting>22nd IEEE Symposium on Security &amp; Privacy</meeting>
		<imprint>
			<date type="published" when="2000">2001. 2000/066</date>
			<biblScope unit="page" from="184" to="200" />
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
	<note>Extended version in Cryptology ePrint Archive</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Trace-based network proof systems: Expressiveness and completeness</title>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gries</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">B</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="396" to="416" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Protocols for secure computations</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 23rd IEEE Symposium on Foundations of Computer Science (FOCS)</title>
		<meeting>23rd IEEE Symposium on Foundations of Computer Science (FOCS)</meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="160" to="164" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Theory and applications of trapdoor functions</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 23rd IEEE Symposium on Foundations of Computer Science (FOCS)</title>
		<meeting>23rd IEEE Symposium on Foundations of Computer Science (FOCS)</meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="80" to="91" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
