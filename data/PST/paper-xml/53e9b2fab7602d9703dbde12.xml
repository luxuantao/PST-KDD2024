<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Architectural Models for Resource Management in the Grid</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Rajkumar</forename><surname>Buyya</surname></persName>
							<email>rajkumar@csse.monash.edu.au</email>
							<affiliation key="aff1">
								<orgName type="institution">Monash University</orgName>
								<address>
									<settlement>Melbourne</settlement>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Steve</forename><surname>Chapin</surname></persName>
							<email>chapin@ecs.syr.edu</email>
						</author>
						<author>
							<persName><forename type="first">David</forename><surname>Dinucci</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">School of Computer Science and Software Engineering</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Dept. of Electrical Engineering and Computer Science</orgName>
								<orgName type="institution">Syracuse University</orgName>
								<address>
									<settlement>Syracuse</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<address>
									<addrLine>14380 N W Hunters Dr</addrLine>
									<settlement>Beaverton, Oregon</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Architectural Models for Resource Management in the Grid</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">850280D493B0B845C8565AAEF8F92953</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:25+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The concept of coupling geographically distributed (high-end) resources for solving large-scale problems is becoming increasingly popular, forming what is popularly called grid computing. The management of resources in the grid environment becomes complex as they are (geographically) distributed, heterogeneous in nature, owned by different individuals/organizations each having their own resource management policies and different access-and-cost models. In this scenario, a number of alternatives exist while creating a framework for grid resource management. In this paper, we discuss the three alternative models-hierarchical, abstract owner, and market-for grid resource management architectures. The hierarchical model exhibits the approach followed in (many) contemporary grid systems. The abstract owner model follows an order and delivery approach in job submission and result gathering. The (computational) market model captures the essentials of both hierarchical and abstract owner models and proposes the use of computational economy in the development of grid resource management systems.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>The growing popularity of the Internet and the availability of powerful computers and high-speed networks as low-cost commodity components are changing the way we do computing and use computers today. The interest in coupling geographically distributed (computational) resources is also growing for solving large-scale problems, leading to what is popularly known as grid computing. In this environment, a wide variety of computational resources (such as supercomputers, clusters, and SMPs including low-end systems such as PCs/workstations), visualisation devices, storage systems and databases, special class of scientific instruments (such as radio telescopes), computational kernels, and so on are logically coupled together and presented as a single integrated resource to the user (see Figure <ref type="figure" target="#fig_0">1</ref>). The user essentially interacts with a resource broker that hides the complexities of grid computing. The broker discovers resources that the user can access through grid information server(s), negotiates with (grid-enabled) resources or their agents using middleware services, maps tasks to resources (scheduling), stages the application and data for processing (deployment) and finally gathers results. It is also responsible for monitoring application execution progress along with managing changes in the grid infrastructure and resource failures. There are a number of projects worldwide <ref type="bibr" target="#b4">[5]</ref>, which are actively exploring the development of various grid computing system components, services, and applications. They include Globus <ref type="bibr" target="#b6">[7]</ref>, Legion <ref type="bibr" target="#b8">[9]</ref>, NetSolve <ref type="bibr" target="#b9">[10]</ref>, Ninf <ref type="bibr" target="#b13">[15]</ref>, AppLes <ref type="bibr" target="#b10">[11]</ref>, Nimrod/G <ref type="bibr" target="#b2">[3]</ref>, and JaWS <ref type="bibr" target="#b14">[16]</ref>. In <ref type="bibr" target="#b1">[2]</ref>, all these grid systems have been discussed. The current research and investment into computational grids is motivated by an assumption that coordinated access to diverse and geographically distributed resources is valuable. In this paradigm, it is not only important to determine mechanisms and policies that allows such coordinated access, but it also seems reasonable that owners of those resources, or of mechanisms to connect and utilize them should be able to recoup some of the resulting value from users or clients. Approaches to recouping such value in the existing Internet/web infrastructure, where e-commerce sites use advertising and/or mark-ups on products sold to show revenue, do not translate well (or are unsuitable) to a computational grid framework, primarily due to the fact that the immediate user of any specific resource in a computational grid is often not a human. Instead, in a grid, many different resources, potentially controlled by diverse organizations with diverse policies in widely-distributed locations, must all be used together, and the relationship between the value provided by each resource and the value of the product or service delivered to the eventual human consumer may be very complex. In addition, it is unrealistic to assume that human-created contracts can be developed between all potential resource users and resource owners in these situations, since the potential of computational grids can only be fully exploited if similar resources owned by different owners can be used almost interchangeably.</p><p>Still, the existing real world must be acknowledged. Grid resources are largely owned and used by individuals or institutions who often provide "free" access for solving problems of common interest/public good (e.g., SETI@Home <ref type="bibr" target="#b12">[13]</ref>), prize/fame (e.g., distributed.net <ref type="bibr">[14]</ref> response to challenge for breaking RSA security algorithms), collaborative resources (GUSTO <ref type="bibr" target="#b5">[6]</ref>), or by companies that are loathe to allow others to use them, primarily due to concerns about competition and security. The existing control over resources is subject to different policies and restrictions, as well as different software infrastructure used to schedule them. Any new approach to manage or share these resources will not be viable unless it allows a gradual layering of functionality or at least a gradual transition schedule from existing approaches to more novel ones. Even in the existing cases where money does not actually change hands, it is often important to provide a proper accounting of cross-organizational resource usage. In order to address these concerns, we propose different approaches for modeling grid resource management systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Architecture Models</head><p>As the grid logically couples multiple resources owned by different individuals or organisations, the choice of the right model for resource management architecture plays a major role in its eventual (commercial) success. There are a number of approaches that one can follow in developing grid resource management systems. In the next three sections, we discuss the following three different models for grid resource management architecture:</p><formula xml:id="formula_0">• Hierarchical Model • Abstract Owner Model • Computational Market/Economy Model</formula><p>In the first, we characterize existing resource management and scheduling mechanisms by suggesting a more general view of those mechanisms. Next, we suggest a rather idealistic and extensive proposal for resource sharing and economy, which for the most part, ignores existing infrastructure in order to focus on long-term goals. Finally, we describe a more incremental architecture that is already underway to integrate some aspects of a computational economy into the existing grid infrastructure. Table <ref type="table">1</ref> shows a few representative systems whose architecture complies with one of these models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MODEL REMARKS SYSTEMS</head><p>Hierarchical It captures architecture model followed in most contemporary systems.</p><p>Globus, Legion, Ninf, NetSolve.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Abstract Owner</head><p>It follows an order and delivery model for resource sharing, which for the most part, ignores existing infrastructure in order to focus on long-term goals.</p><p>Expected to emerge.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Economy/Market</head><p>It follows economic model in resource discovery and scheduling that can coexist or work with contemporary systems and captures the essence of both hierarchical and abstract owner models.</p><p>Nimrod/G, JaWS, Myriposa, JavaMarket.</p><p>Table <ref type="table">1</ref>: Three Models for a Grid Resource Management Architecture.</p><p>The grid architecture models need to encourage resource owners to contribute their resources, offer a fair basis for sharing resources among users, and regulate resource demand and supply. They influence the way scheduling systems are built as they are responsible for mapping user requests to the right set of resources. The grid scheduling systems need to follow multilevel scheduling architecture as each resource has its own scheduling system and users schedule their applications on the grid using super-schedulers called resource brokers (see Figure <ref type="figure" target="#fig_0">1</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Hierarchical Resource Management</head><p>The hierarchical model for grid resource management architecture (shown in Figure <ref type="figure" target="#fig_1">2</ref>) is an outcome of the Grid Forum [20] second meeting proposed in <ref type="bibr" target="#b18">[21]</ref>. The major components of this architecture are divided into passive and active components. The passive components are:</p><p>• Resources are things that can be used for a period of time, and may or may not be renewable. They have owners, who may charge others for using resources and they can be shared, or exclusive. Resources might be explicitly named, or be described parametrically. Examples of resources include disk space, network bandwidth, specialized device time, and CPU time. • Tasks are consumers of resources, and include both traditional computational tasks and non-computational tasks such as file staging and communication. • Jobs are hierarchical entities, and may have recursive structure; i.e., jobs can be composed of subjobs or tasks, and subjobs may themselves contain subjobs. The leaves of this structure are tasks. The simplest form of a job is one containing a single task. • Schedules are mappings of tasks to resources over time. Note that we map tasks to resources, not jobs, because jobs are containers for tasks, and tasks are the actual resource consumers. The active components are:</p><p>• Schedulers compute one or more schedules for input lists of jobs, subject to constraints that can be specified at runtime. The unit of scheduling is the job, meaning that schedulers attempt to map all the tasks in a job at once, and jobs, not tasks, are submitted to schedulers. • Information Services act as databases for describing items of interest to the resource management systems, such as resources, jobs, schedulers, agents, etc. We do not require any particular access method or implementation; it could be LDAP, a commercial database, or something else entirely. • Admission Control Agents determine whether the system can accommodate additional jobs, and reject or postpone jobs when the system is saturated. • Monitors track the progress of jobs. Monitors obtain job status from the tasks comprising the job and from the Domain Control Agents where those tasks are running. Based on this status, the Monitor may perform outcalls to Job Control Agents and Schedulers to effect remapping of the job. • Job Control Agents are responsible for shepherding a job through the system, and can act both as a proxy for the user and as a persistent control point for a job. It is the responsibility of the job control agent to coordinate between different components within the resource management system, e.g. to coordinate between monitors and schedulers.</p><p>We have striven to be as general as is feasible in our definitions. Many of these distinctions are logical distinctions. For example, we have divided the responsibilities of schedulers, deployment agents, and monitors, although it is entirely reasonable and expected that some scheduling systems may combine two or all three of these in a single program. Schedulers outside control domains cannot commit resources; these are known as metaschedulers or super schedulers. In our early discussions, we intentionally referred to control domains as "the box" because it connotes an important separation of "inside the box" vs. "outside the box." Actions outside the box are requests; actions inside the box may be commands. It may well be that the system is fractal in nature, and that entire grid scheduling systems may exist inside the box. Therefore, we can treat the control domain as a black box from the outside.</p><p>We have intentionally not defined any relationship between the number of users, jobs, and the major entities in the system (admission agents, schedulers, deployment agents, and monitors). Possibilities range from per-user or per-job agents to a single monolithic agent per system; each approach has strengths and weaknesses, and nothing in our definitions precludes or favors a particular use of the system. We expect to see local system defaults (e.g. a default scheduler or deployment agent) with users substituting their personal agents when they desire to do so.</p><p>One can notice that the word queue has not been mentioned in this model; queuing systems imply homogeneity of resources and a degree of control that simply will not be present in true grid systems. Queuing systems will most certainly exist within control domains.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Interaction of Components</head><p>The interactions between components of the resource management system are shown in Figure <ref type="figure" target="#fig_1">2</ref>. An arrow in the figure means that communication is taking place between components. We will next describe, at a high level, what we envision these interactions to be. This is the beginning of a protocol definition. Once the high-level operations are agreed upon, we can concern ourselves with wire-level protocols. We will begin with an example. A user submits a job to a job control agent, which calls an admission agent. The admission agent examines the resource demands of the job (perhaps consulting with a grid information system) and determines that it is safe to add the job to the current pool of work for the system. The admission agent passes the job to a scheduler, which performs resource discovery using the grid information system and then consults with domain control agents to determine the current state and availability of resources.</p><p>The scheduler then computes a set of mappings and passes these mappings to a deployment agent. The deployment agent negotiates with the domain control agents for the resources indicated in the schedule, and obtains reservations for the resources. These reservations are passed to the job control agent. At the proper time, the job control agent works with a different deployment agent, and the deployment agent coordinates with the appropriate domain control agents to start the tasks running. A monitor tracks progress of the job, and may later decide to reschedule if performance is lower than expected. This is but one way in which these components might coordinate. Some systems will omit certain functionality (e.g. the job control agent), while others will combine multiple roles in a single agent. For example, a single process might naturally perform the roles of job control agent and monitor.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Abstract Owner (AO) Model</head><p>Where is the grid, and who owns it? These puzzles are not unique to the grid. When one makes a long distance phone call, who "owns" the resource being used? Who owns the generators that create the electricity to run an appliance? Who owns the Internet? Users of these resources don't care, and don't want to care. What they do want is the ability to make an agreement with some entity regarding the conditions under which the resources can be used, the mechanisms for using the resources, the cost of the resources, and the means of payment. The entity with which the user deals (the phone company, power company, or ISP) is almost certainly not the owner of the resources, but the user can think of them that way abstractly. They are actually brokers, who may in turn deal with the owners, or perhaps with more brokers. At each stage, the broker is an abstraction for all of the owners and so it is with the grid.</p><p>The grid user wants an abstraction of an entity that "owns" the grid, and to make an arrangement with that "owner" regarding the use of their resources, possibly involving a trade of something of value for the usage (which could be nothing more tangible than goodwill or the future use of their own resources). It is proposed here that each grid resource, ranging in complexity from individual processors and instruments to the grid itself, be represented by one or more "abstract owners" (abbreviated as AOs) that are strongly related to schedulers. For complex resources, an AO will certainly be a broker for the actual owners or other brokers, though the resource user doesn't need to be aware of this. (A resource user will hereafter be assumed to be a program, and referred to as a client. Human clients are assumed to use automated agents to represent him/her in negotiations with an AO.) The arrangement between the client and an AO for acquiring and using the resource can be made through a pre-existing contract (e.g. flat rate or sliding scale depending on time until resource available) or based on a dialogue between client and AO regarding the price and availability of the resource.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The remainder of this AO proposal describes what an AO looks like (externally and internally</head><p>), what a resource looks like, how a client negotiates with an AO to acquire a resource, how a client interacts with a resource, and how AOs can be assembled into other constructs which may more closely resemble traditional schedulers. This work is still in the high-level design stages, in hopes that it will draw out refinements, corrections, and extensions that might help it to become viable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>General Structure of AO</head><p>At its most abstract, an AO outwardly resembles a fast-food restaurant (see Figure <ref type="figure" target="#fig_2">3a</ref>). To acquire access to a resource from an AO that "owns" it, the prospective client (which may be another AO) negotiates with that AO through its Order Window. These negotiations may include asking how soon the resource may become available, how much it might cost, etc. If the prospective client is not happy with the results of the negotiations, it may just terminate negotiations, or might actually place an order. After being ordered, the resources are delivered from the AO to the client through the Pickup Window. The precise protocol to be used for acquiring the resources is flexible and may also be negotiated at order time--e.g. the client may be expected to pick up the resource at a given time, or the AO may alert the client (via an interrupt or signal) when the resource is ready. Even if an order is placed (but the resource has not yet been delivered), the client may cancel the order through the order window. Little more is said here about the actual form of these "windows" except that they need to be accessible remotely, and must support a standard procedure-like interface in which values are passed to and returned from the window. Since interaction with an AO is likely to be rather infrequent and requires a relatively small amount of information flow, maximum efficiency is not necessarily required: CORBA or any number of other remote procedure invocation techniques can be used.</p><p>For the purposes of this discussion, a resource is roughly defined as any combination of hardware and software that helps the client to solve a problem, and a task is that part of a problem that is specified by the client after the resource has been delivered ("picked up") from the AO. Note that, unlike some other definitions of "task", these tasks may be very simple (e.g. a data set to be analyzed or a message to be sent), more general (e.g. a process to be executed), or very complex (e.g. a complete multi-process program and/or set of programs or processes to be executed in some order). While AOs do not specifically deal with entities called "jobs", techniques for applying the AO approach to traditional job scheduling will be addressed in the last subsection.</p><p>Resources can (and will) be regarded as objects, in the sense that they have an identity, a set of methods for initiating and controlling tasks, and attributes that serve to customize the resource. In general, the desired attributes will be determined during negotiation through the Order Window, when the client requests the resource, and will only be queried (not altered) after the resource is delivered. The methods may take many different forms, depending upon circumstances such as the type of resource, availability of hardware protections, and whether the method is to be invoked locally or remotely. For example, access to a local memory resource may have virtually no method protocol interfering with standard memory access operations, while initiating a process on a distant processor may require more substantial method invocation protocol. A resource is relinquished by invoking its "relinquish" method (or by timing out).</p><p>The external structure of an AO was formulated to allow any level of nesting. Internally, an AO will differ in structure depending on whether it is a broker or an owner (or a combination). A pure owner of a single physical resource might be very simple (see Figure <ref type="figure" target="#fig_2">3b</ref>), where the "manager" includes the intelligence required to negotiate, keep the schedule, and deliver the resource. For a higher-level broker, it might be more complex (see Figure <ref type="figure" target="#fig_2">3c</ref>). Here, AO1, AO2, and AO3 represent other Abstract Owners, each with an Order Window used by the Sales Representative, and a Pickup Window used by the Delivery representative. Though these subordinate AOs are shown within a single parent AO, there is no reason that this relation must be hierarchical; a single AO may provide resources to a number of different parent AOs, which may assemble these into more complex resources in different ways or for different clients sets or may support different protocols or strategies or policies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Grid Resources</head><p>Three primary classes are proposed here to represent resources: Instruments, Channels, and Complexes. An Instrument is a resource which logically exists at some location for some specific period of time, and which creates, consumes, or transforms data or information. The term "location" may be as specific or general as the situation merits. A Channel is a resource that exists to facilitate the explicit transfer of data or information between two or more instruments, either at different locations, or in the same location at different times (acting as sort of a temporary file in that case), or instruments which share space-time coordinates but have different protection domains. A Channel connects to an Instrument through a Port (on the instrument). A Complex is nothing more than a collection of (connected) Channel and Instrument resources. Some important sub-classes of the Instrument class are the Compute instrument, the Archival instrument, and the Personal instrument. The Compute instrument corresponds to a processor or set of processors along with associated memory, temp files, software, etc. Archival Instruments (of which a permanent file is one sub-class) correspond to persistent storage of information. Personal instruments are those that are assumed to interface directly to a human being, ranging from a simple terminal to a more complex CAVE or speech recognition/synthesis device, and its specification may include the identity of the person involved. Of course, the Instrument class is also meant to accommodate other machines and instruments such as telescopes, electron microscopes, automatic milling machines, or any other sink or source for grid data.</p><p>As stated, an instrument exists in a location, and its methods may need to be called either locally (from the instrument itself) or remotely. For example, if a (reference to a) Compute instrument is acquired from an AO, the potentially distant process may want to invoke a "load_software" method to initiate a program on the resource. This new program may then want to invoke methods to access the temporary files or ports associated with the resource. Since the latter accesses will be local and must be efficient, it is desirable to provide separate method invocation protocols for remote and local method invocation. Moreover, remote method invocations (RMIs) may themselves require the use of intermediate communication resources between the client and the resource, perhaps with associated quality of service (QoS) constraints.</p><p>To facilitate remote method invocations, any port(s) of an instrument can be specially designated as an RMI port. Such ports will have the appropriate RMI protocol handlers assigned to them. This designation is an attribute of the port--i.e., specified at resource negotiation time, through the "order window", just as authorization and notification style are. Methods can be invoked through such a port either by connecting a channel to the port and issuing the RMI request through the channel or in a connectionless mode by specifying the object and port. The former approach is best when issuing repeated RMI calls or when QoS is desired for RMI calls, the latter is best for one-time-only calls such as initializing an instrument which has just been acquired from an AO.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Negotiating with an AO</head><p>When negotiating through the order window, the client first effectively creates a "sample" resource object of the appropriate structure and assigns each attribute either (1) a constant value, (2) a "don't care" value, or (3) a variable name (which will actually take the form of, and be interpreted as, an index into a variable value table). If the same variable name is used in multiple places, it has the effect of constraining those attributes to have the same value. An example of this is to use a single variable to specify the "beginning time" attribute on several Instrument objects to cause them to be co-scheduled. Another is to specify variables for Instruments' object IDs, then to use those same variables when specifying the endpoints of the channels between them. The client may also specify simple constraints on the variables in a separate constraint list.</p><p>Usually, the values in the variable value table are filled and returned by the AO when the resource is acquired, but the client can designate some subset of those variables as negotiating variables. For these, the AO will propose values during negotiation, which the client can then examine to decide whether or not to accept the resource. (If accepted, these values essentially become constants.) In general, it is quicker for the client to specify additional constraints instead of using negotiation variables, allowing the decision on suitability to be made wholly within the AO, but negotiating variables can help when more complex constraints are required or when a client must decide between similar resources offered by different AOs.</p><p>In all, submissions to the Order Window from the client include the sample object attributes, the variable constraint list, a Negotiation Style, a Pickup Approach, an Authorization, a Bid, and a Negotiation ID. The Negotiation Style specifies whether the AO is to schedule the resource immediately (known as "Immediate"), or is to return a specified number of sets of proposed values for the negotiation variables (known as "Pending"), or is to finish scheduling based on an earlier-returned set of negotiation variable values (known as "Confirmation"), or is to cancel an earlier Pending negotiation (known as "Cancel"). The Pickup Approach specifies the protocol to be used between the AO and client at the Pickup Window-i.e. whether the AO will alert the client with a signal, interrupt, or message when the resource becomes available, or the client will poll the Pickup Window for the resource, or the client can expect to find the resource ready at the window at a specified time. The Authorization is a capability or key which allows the AO to determine the authority of the client to access resources (and to bill the client accordingly when the resources are delivered). The Bid is a maximum price that the client is willing to pay for the resource, and may denote a pre-understood algorithm (or "contract") specifying how much the resource will cost under certain conditions. The Negotiation ID serves as a "cookie", and is passed back and forth between the client and AO to provide an identity and continuity for a multi-interaction negotiation, and continuity between the negotiation of a resource and the ultimate delivery of the resource through the Pickup Window. (A zero Negotiation ID designates the beginning of a new negotiation.) If a Pending negotiation style is specified, the AO returns a value table containing sets of proposed values for the negotation variables, and an "Ask" price for each set. The intent of the Ask price is to inform the client of a sufficient Bid price to be used when requesting the resource, but the AO may conceivably accept even lower Bid prices depending upon the specific situation. For all negotiations, the AO returns a return code informing the client of the success of the operation, a Negotiation ID, (equal to that submitted, if it was nonzero), and an expiration date for the Negotiation ID. A single negotiation can continue until the Negotiation ID expires or a Negotiation Style other than "pending" is specified.</p><p>On a successful Immediate or Confirm request, the client can then submit the Negotiation ID to the Pickup Window, (at a time consistent with the Negotiation Style), to retrieve the resource. The Pickup Window returns the resource object, the variable value table, and a return code. Although the returned resource is logically an object, it is assumed that any attribute values that the client is concerned with are being returned in the Variable Value table, so the resource object just takes the form of a handle to access the resource object's methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Job Shops</head><p>AOs apparently perform only part of the standard job scheduling process-i.e. acquiring a resource-leaving the remainder to the client-i.e. assigning tasks to the resources and monitoring their completion and/or cleanup, often in sequential and dependent steps. But this is only partially true. Recall that a Compute Instrument, exclusive of the task that is eventually assigned to it by the client, may consist of both hardware and software components. While the software components often serve to create an environment in which the eventual task will execute (such as libraries or interpreters), they may also be compilers and/or complete user programs. That is, the Compute Instrument itself can be defined as a processor executing a specific program. The task assigned to such an instrument may be a data-set or source code to be read by that program (or compiler), or even nothing at all if the resource is completely selfcontained. Since the AO is responsible for preparing the instrument for delivery through the Pickup Window and recovering it after it has been relinquished, it is indeed responsible for initiating this software and cleaning up after it.</p><p>The traditional sequential nature of job steps has resulted from the prevalence of uniprocessors and traditional sequential thinking, but it is already common for parallel "make" utilities, for example, to exploit potential parallelism in job-like scripts. Similarly, in an AO resource, compute instruments running the individual "job steps" can be connected to communicate through channels, allowing them to be scheduled locally or in a distributed fashion, and scheduled sequentially or in parallel by the AO, subject to the dependences dictated by the channels and the QoS constraints assigned to those channels by the client. In this way, a job can be represented as a Complex Instrument in the AO infrastructure, where it will be scheduled.</p><p>Even with these capabilities, there is always the possibility that a more traditional job scheduler is required. In such a case, consider a new construct called a job shop, which uses AOs only to acquire resources, as shown in Figure <ref type="figure" target="#fig_2">3d</ref>. See Figure <ref type="figure" target="#fig_2">3e</ref> for an example of the internals of a standard job shop. The job shop primarily comprises "estimator" and "executor", much like an auto repair shop. The estimator deals with the customer to help determine how soon the job might be done and how much it might cost, requests the resources needed from the grid AO (through its order window), and records what needs to be done (in a job queue) when the resources are ready. The executor takes ready resources from the AO delivery window, dequeues the associated work from the job queue, builds any necessary environment for those tasks (e.g. telling message passing routines which channels to use), initiates tasks, collects answers, and notifies and returns the answer to the client.</p><p>Nesting job shops (or traditional job schedulers in general) is not as natural as nesting AOs, primarily because a job shop provides little feedback to the client until it has acquired resources and assigned tasks to them. This means that tasks are often assigned to some resources even before others have been allocated, and may be shipped around to where the resources are, long before they are needed there.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>AO Summary</head><p>There are many remaining gaps in the above description, both in detail and in functionality. For example, little has been said about how any client, whether an enduser or another AO, will find AOs that own the desired kind of resources. Certainly, one approach is to imagine a tree of AOs (as in Figure <ref type="figure" target="#fig_2">3c</ref>), with the client always interacting with the root AO, but it is unrealistic to consider this tree as being hardwired when residing in an environment as dynamic as a computational grid. More likely, existing Internet protocols can be adapted for this purpose, and an AO might have a third "business dealings" window to facilitate them. Before an approach like AO has any likelihood of acceptance in a large community, it must address many such challenges. Even a potentially useful and well-defined (successfully prototyped) AO protocol will not be viable unless it can coexist with other contemporary approaches. It is therefore important to understand how AOs and constructs in these other systems can build upon one another and mimic one another.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Economy/Market Model</head><p>The resources in the grid environment are geographically distributed and each of them is owned by a different organisation. Each of them has its own resource management mechanisms and policies and may charge different prices for different users necessitating the need for the support of computational economy in resource management. In <ref type="bibr" target="#b15">[17]</ref>, we have presented a number of arguments for the need of an economy (market) driven resource management system for the grid. It offers resource owners better "incentive" for contributing their resources and help recover cost they incur while serving grid users or finance services that they offer to users and also make some profit. This return-on-investment mechanism also helps in enhancing/expanding computational services and upgrading resources. It is important to note that an economy 1 is one of the best institutions for regulating demand and supply. Naturally, in a computational market environment, resource users want to minimise their expenses (the price they pay) and owners want to maximise their return-on-investment. This necessitates a grid resource management system that provides appropriate tools and services to allow both resource users and owners to express their requirements. For instance, users should be allowed to specify their "QoS requirements" such as minimise the computational cost (amount) that they are willing to pay and yet meet the deadline by which they need results. Resource owners should be allowed to specify their charges-that can vary from time to time and users to users-and terms of use. Systems such as Mariposa <ref type="bibr" target="#b15">[17]</ref>, Nimrod/G <ref type="bibr" target="#b2">[3]</ref>, and JaWS <ref type="bibr" target="#b14">[16]</ref>, architect their user service model based on the economy of computations and it is likely that more and more systems are going to emerge based on this concept. The economy/market model for grid resource management captures the essentials of both hierarchical and AO model presented above. Many of the contemporary grid systems fit to the hierarchical model and AO appears to be futuristic, but points out the need for economy in computation implicitly. The issues discussed in the hierarchical model apply to the market model, but it emphasizes the use of economic 1 We use terms "economy" and "market" interchangeably. based resource management and scheduling. One of the possible architectures for grid resource management based on computational market model is shown in Figure <ref type="figure" target="#fig_3">4</ref>. Resource trading model can vary depending on the method/protocol used (by trade manager) in determining the resource access cost.</p><p>The following are the key components of economy-driven resource management system:</p><p>• User Applications (sequential, parametric, parallel, or collaborative applications) </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Grid Resource Broker (GRB)</head><p>The resource broker acts as a mediator between the user and grid resources using middleware services. It is responsible for resource discovery, resource selection, binding of software (application), data, and hardware resources, initiating computations, adapting to the changes in grid resources and presenting the grid to the user as a single, unified resource. The components of resource broker are the following:</p><p>• Job Control Agent (JCA): This component is a persistent central component responsible for shepherding a job through the system. It takes care of schedule generation, the actual creation of jobs, maintenance of job status, interacting with clients/users, schedule advisor, and dispatcher. • Schedule Advisor (Scheduler): This component is responsible for resource discovery (using grid explorer), resource selection, and job assignment (schedule generation). Its key function is to select those resources that meet user requirements such as meet the deadline and minimize the cost of computation while assigning jobs to resources.</p><p>• Grid Explorer: This is responsible for resource discovery by interacting with grid-information server and identifying the list of authorized machines, and keeping track of resource status information.</p><p>• Trade Manager (TM): This works under the direction of resource selection algorithm (schedule advisor) to identify resource access costs. It interacts with trade servers (using middleware services/protocols such as those presented in <ref type="bibr" target="#b3">[4]</ref>) and negotiates for access to resources at low cost. It can find out access cost through grid information server if owners post it. • Deployment Agent: It is responsible for activating task execution on the selected resource as per the scheduler's instruction. It periodically updates the status of task execution to JCA.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Grid Middleware</head><p>The grid middleware offers services that help in coupling a grid user and (remote) resources through a resource broker or grid enabled application. It offers core services <ref type="bibr" target="#b11">[12]</ref> such as remote process management, co-allocation of resources, storage access, information (directory), security, authentication, and Quality of Service (QoS) such as resource reservation for guaranteed availability and trading for minimising computational cost. Some of these services have already been discussed in the hierarchical model, here we point out components that are specifically responsible for helping out in offering computational economy services:</p><p>• Trade Server (TS): It is a resource owner agent that negotiates with resource users and sells access to resources. It aims to maximize the resource utility and profit for its owner (earn as much money as possible). It consults pricing algorithms/models defined by the users during negotiation and directs the accounting system to record resource usage. • Pricing Algorithms/Methods: These define the prices that resource owners would like to charge users. The resource owners may follow various policies to maximise profit and resource utilisation and the price they charge may vary from time to time and one user to another user and may also be driven by demand and supply like in the real market environment. • Accounting System: It is responsible for recording resource usage and bills the user as per the usage agreement between resource broker (TM, user agent) and trade server (resource owner agent) <ref type="bibr" target="#b17">[19]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Domain Resource Manager</head><p>Local resource managers are responsible for managing and scheduling computations across local resources such as workstations and clusters. They are even responsible for offering access to storage devices, databases, and special scientific instruments such as a radio telescope. Example local resource managers include, cluster operating systems such as MOSIX <ref type="bibr" target="#b16">[18]</ref> and queuing systems such as Condor <ref type="bibr" target="#b11">[12]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Comments</head><p>The services offered by trade server could also be accessed from or offered by grid information servers (like yellow pages/advertised services or posted prices). In this case a trade manager or broker can directly access information services to identify resource access cost and then contact resource agents for confirmation of access. The trade manager can use these advertised/posted prices (through information server) or ask/invite for competitive quotes (tenders) or bids (from trade server/resource owner agents) and choose resources that meet user requirements.</p><p>From the above discussion it is clear that there exist numerous methods for determining/knowing access cost. Therefore resource trading shown in Figure <ref type="figure" target="#fig_3">4</ref> is one of the possible alternatives for computational market model and it can vary depending on, particularly, trading protocols like in real world economy. Some of the real-world trading methods that can also be applied for computational economies include:</p><p>• Advertised/posted prices (classified advertisements) through information server Each of these methods can be applied in situations for computational economies and they create a competitive computational market depending on the demand and supply and the quality of service. The mechanism for informing resource owners about the availability of service opportunities can vary depending on its implementation. One of the simplest mechanisms is users (buyers) or/and resource owners (sellers or their agents renting/leasing computational services) make available or post/publicise their requirements in a known location (for instance, "exchange centre, share market, or grid information service directory"). Any one or all can initiate computational service trading. Through these mechanisms one can perform the following types of actions like in real world market economies:</p><p>• Users can post their intentions/offers to buy access to resources/services (e.g., "20 cluster nodes for 2 hours for $50); • Resource owners/grid nodes/providers/agents can post offers to sell (e.g., systems like NetSolve can announce "we solve 1000 simultaneous linear equations for $5"); • Users/resource owners can query about current opportunities including prices/bids and historical information. The different grid systems may follow different approaches in making this happen and it will be beneficial if they are all interoperable. The interoperability standards can be evolved through grid user/developer community forums or standardization organisations such as GF [20] and eGRID <ref type="bibr" target="#b19">[22]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Discussion and Conclusions</head><p>In this paper we have discussed three different models for grid resource management architecture inspired by three different philosophies. The hierarchical model captures the approach followed in many contemporary grid systems. The abstract owner shows the potential of an order and delivery approach in job submission and result gathering. The (computational) market model captures the essentials of both hierarchical and abstract owner models and uses the concept of computational economy. We have attempted to present these models in abstract high-level form as much as possible and have skipped low-level details for developers to decide (as they mostly change from one system to another). Many of the existing, upcoming and future grid systems can easily be mapped to one or more of the models discussed here (see Table <ref type="table">1</ref>). It is also obvious that real grid systems (as they evolve) are most likely to combine many of these ideas into a hybridized model (that captures essentials of all models) in their architecture. For instance, our Grid Economy <ref type="bibr" target="#b3">[4]</ref> is developed as a combination of Globus and GRACE services based on a (hybridized) market model.</p><p>The importance of market models for grid computing is also reported in the journal of Scientific American <ref type="bibr" target="#b20">[23]</ref>: "So far not even the most ambitious metacomputing prototypes have tackled accounting: determining a fair price for idle processor cycles. It all depends on the risk, on the speed of the machine, on the cost of communication, on the importance of the problem--on a million variables, none of them well understood. If only for that reason, metacomputing will probably arrive with a whimper, not a bang". We hope that (our proposed) computational market model for grid systems architecture along with others will help the arrival of computational grids with a big bang (not a whimper)!</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: A Generic View of GRID System.</figDesc><graphic coords="2,124.89,253.25,343.56,160.08" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Hierarchical Model for Grid Resource Management.</figDesc><graphic coords="6,126.09,184.25,343.44,237.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Abstract Owner Model for Grid Resource Management Architecture.</figDesc><graphic coords="8,126.09,175.01,343.78,200.16" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Economy Model for Grid Resource Management Architecture.</figDesc><graphic coords="13,124.89,384.65,351.50,195.96" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>• Grid Resource Broker (a.k.a., Super/Global/Meta Scheduler) • Grid Middleware • Domain Resource Manager (Local Scheduler or Queuing system)</figDesc><table /></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m">The Grid: Blueprint for a Future Computing Infrastructure</title>
		<editor>
			<persName><forename type="first">Ian</forename><surname>Foster</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Carl</forename><surname>Kesselman</surname></persName>
		</editor>
		<meeting><address><addrLine>USA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann Publishers</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">Mark</forename><surname>Baker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rajkumar</forename><surname>Buyya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domenico</forename><surname>Laforenza</surname></persName>
		</author>
		<title level="m">The Grid: International Efforts in Global Computing, Intl. Conference on Advances in Infrastructure for Electronic Business, Science, and Education on the Internet</title>
		<meeting><address><addrLine>Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Nimrod/G: An Architecture for a Resource Management and Scheduling System in a Global Computational Grid, 4th Intl. Conf. on High Performance Computing in Asia-Pacific Region</title>
		<author>
			<persName><forename type="first">Rajkumar</forename><surname>Buyya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Abramson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jon</forename><surname>Giddy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>HPC Asia</publisher>
			<pubPlace>China</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Economy Driven Resource Management Architecture for Computational Power Grids</title>
		<author>
			<persName><forename type="first">Rajkumar</forename><surname>Buyya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Abramson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jon</forename><surname>Giddy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Intl. Conf. on Parallel and Distributed Processing Techniques and Applications (PDPTA 2000)</title>
		<meeting><address><addrLine>USA</addrLine></address></meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">Rajkumar</forename><surname>Buyya</surname></persName>
		</author>
		<ptr target="http://www.gridcomputing.com" />
		<title level="m">Grid Computing Info Centre</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<ptr target="http://www.globus.org/testbeds/" />
		<title level="m">Globus Testbeds</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Globus: A Metacomputing Infrastructure Toolkit</title>
		<author>
			<persName><forename type="first">Ian</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carl</forename><surname>Kesselman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Supercomputer Applications</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="115" to="128" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName><forename type="first">Jack</forename><surname>Dongarra</surname></persName>
		</author>
		<title level="m">An Overview of Computational Grids and Survey of a Few Research Projects, Symposium on Global Information Processing Technology</title>
		<meeting><address><addrLine>Japan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">The Legion Resource Management System, 5 th Workshop on Job Scheduling Strategies for Parallel Processing</title>
		<author>
			<persName><forename type="first">Steve</forename><surname>Chapin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Karpovich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Grimshaw</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999-04">April 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">NetSolve: A Network Server for Solving Computational Science Problems, Intl</title>
		<author>
			<persName><forename type="first">Henri</forename><surname>Casanova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jack</forename><surname>Dongarra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Supercomputing Applications and High Performance Computing</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">Fran</forename><surname>Berman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rich</forename><surname>Wolski</surname></persName>
		</author>
		<ptr target="http://apples.ucsd.edu" />
		<title level="m">The AppLeS Project: A Status Report, 8th NEC Research Symposium</title>
		<meeting><address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-05">May 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Deploying a High Throughput Computing Cluster, High Performance Cluster Computing</title>
		<author>
			<persName><forename type="first">Jim</forename><surname>Basney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Miron</forename><surname>Livny</surname></persName>
		</author>
		<ptr target="http://www.cs.wisc.edu/condor/" />
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title/>
		<author>
			<persName><surname>Seti@home</surname></persName>
		</author>
		<ptr target="http://setiathome.ssl.berkeley.edu/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Design and Implementations of Ninf: towards a Global Computing Infrastructure</title>
		<author>
			<persName><forename type="first">Hidemoto</forename><surname>Nakada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mitsuhisa</forename><surname>Sato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Satoshi</forename><surname>Sekiguchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">FGCS Journal</title>
		<imprint>
			<date type="published" when="1999-10">October 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">JaWS: An Open Market-Based Framework for Distributed Computing over the Internet</title>
		<author>
			<persName><forename type="first">Spyros</forename><surname>Lalis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexandros</forename><surname>Karipidis</surname></persName>
		</author>
		<ptr target="http://roadrunner.ics.forth.gr:8080/" />
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM International Workshop on Grid Computing</title>
		<imprint>
			<date type="published" when="2000-12">2000. Dec. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">An Economic Paradigm for Query Processing and Data Migration in Mariposa</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Stonebraker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Devine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marcel</forename><surname>Kornacker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Witold</forename><surname>Litwin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Avi</forename><surname>Pfeffer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adam</forename><surname>Sah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carl</forename><surname>Staelin</surname></persName>
		</author>
		<ptr target="http://mariposa.cs.berkeley.edu:8000/mariposa/" />
	</analytic>
	<monogr>
		<title level="m">3rd International Conference on Parallel and Distributed Information Systems</title>
		<imprint>
			<date type="published" when="1994-09">Sept. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The MOSIX Multicomputer Operating System for High Performance Cluster Computing</title>
		<author>
			<persName><forename type="first">Amnon</forename><surname>Barak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oren</forename><surname>Laadan</surname></persName>
		</author>
		<ptr target="www.mosix.cs.huji.ac.il" />
	</analytic>
	<monogr>
		<title level="j">FGCS Journal</title>
		<imprint>
			<date type="published" when="1998-03">March 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Distributed Accounting on the Grid, The Grid Forum Working Drafts</title>
		<author>
			<persName><forename type="first">Bill</forename><surname>Thigpen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tom</forename><surname>Hacker</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">A Grid Resource Management Architecture, Strawman 1, Grid Forum Scheduling Working Group</title>
		<author>
			<persName><forename type="first">Steve</forename><surname>Chapin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><surname>Clement</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Quinn</forename><surname>Snell</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999-11">November 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title/>
		<ptr target="http://www.egrid.org" />
	</analytic>
	<monogr>
		<title level="j">European Grid Forum</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">Wayt</forename><surname>Gibbs</surname></persName>
		</author>
		<ptr target="http://www.sciam.com/0597issue/0597cyber.html" />
	</analytic>
	<monogr>
		<title level="m">Cyber View-World Wide Widgets</title>
		<meeting><address><addrLine>San Francisco, USA</addrLine></address></meeting>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
