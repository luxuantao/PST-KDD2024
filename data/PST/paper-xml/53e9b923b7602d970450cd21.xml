<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Indexing of Moving Objects for Location-Based Services</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Simonas</forename><surname>Šaltenis</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Christian</forename><forename type="middle">S</forename><surname>Jensen</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Michael</forename><forename type="middle">H</forename><surname>Böhlen</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Heidi</forename><surname>Gregersen</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Dieter</forename><surname>Pfoser</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Janne</forename><surname>Skyt</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Giedrius</forename><surname>Slivinskas</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Kristian</forename><surname>Torp</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Richard</forename><forename type="middle">T</forename><surname>Snodgrass</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Dengfeng</forename><surname>Gao</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Vijay</forename><surname>Khatri</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Bongki</forename><surname>Moon</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Sudha</forename><surname>Ram</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Curtis</forename><forename type="middle">E</forename><surname>Dyreson</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Gerhard</forename><surname>Knolmayer</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Mario</forename><forename type="middle">A</forename><surname>Nascimento</surname></persName>
						</author>
						<author>
							<persName><forename type="first">John</forename><forename type="middle">F</forename><surname>Roddick</surname></persName>
						</author>
						<author>
							<persName><roleName>TimeConsult, Switzerland</roleName><forename type="first">Andreas</forename><surname>Steiner</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Jef</forename><surname>Wijsen</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Carlo</forename><surname>Zaniolo</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Aalborg University</orgName>
								<address>
									<country key="DK">Denmark</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">University of Arizona</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Washington State University</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="department">Fabio Grandi</orgName>
								<orgName type="institution">University of Bologna</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution">Nick Kline</orgName>
								<address>
									<settlement>Microsoft</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="institution">Universty of Bern</orgName>
								<address>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff6">
								<orgName type="institution" key="instit1">Thomas Myrach</orgName>
								<orgName type="institution" key="instit2">Universty of Bern</orgName>
								<address>
									<country>Switzerland Kwang</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff7">
								<orgName type="institution">Chungbuk National University</orgName>
								<address>
									<settlement>Nam</settlement>
									<country key="KR">Korea</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff8">
								<orgName type="institution">University of Alberta</orgName>
								<address>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff9">
								<orgName type="institution">University of South Australia</orgName>
								<address>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff10">
								<orgName type="institution" key="instit1">Keun H. Ryu</orgName>
								<orgName type="institution" key="instit2">Chungbuk National University</orgName>
								<address>
									<addrLine>Korea Michael D. Soo, amazon.com</addrLine>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff11">
								<orgName type="department">Vassilis Tsotras</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Riverside</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff12">
								<orgName type="institution">University of Mons-Hainaut</orgName>
								<address>
									<country key="BE">Belgium</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff13">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Los Angeles</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Indexing of Moving Objects for Location-Based Services</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">CF07A3D4CC97628232D87C548566BCDF</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:01+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>For additional information, see The TIMECENTER Homepage: URL: &lt;http://www.cs.auc.dk/TimeCenter&gt;</p><p>Any software made available via TIMECENTER is provided "as is" and without any express or implied warranties, including, without limitation, the implied warranty of merchantability and fitness for a particular purpose.</p><p>The TIMECENTER icon on the cover combines two "arrows." These "arrows" are letters in the so-called Rune alphabet used one millennium ago by the Vikings, as well as by their precedessors and successors. The Rune alphabet (second phase) has 16 letters, all of which have angular shapes and lack horizontal lines because the primary storage medium was wood. Runes may also be found on jewelry, tools, and weapons and were perceived by many as having magic, hidden powers. The two Rune arrows in the icon denote "T" and "C," respectively.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>We are currently experiencing rapid developments in technology areas, such as wireless technology, miniaturization of electronics, and ergonomics. This development promises widespread use of mobile personal information appliances, most of which will be on-line, i.e., on the Internet. Industry analysts uniformly predict that wireless, mobile Internet terminals will outnumber the desktop computers in the Internet.</p><p>This proliferation of devices offers companies the opportunity to provide a diverse range of e-services. Successful services are expected to be relevant, unobtrusive, personalized, and context aware; and it is essential for many services, termed location-based services, that they be sensitive to the user's changing location. Location awareness is made possible by a combination of political developments, e.g., the descrambling of the GPS signals and the US E911 mandate, and the continued advances in both infrastructurebased and handset-based positioning technologies.</p><p>The area of location-based games offers good examples of services where there is a need to track the positions of the mobile users. In the recent released BotFighters game, by Swedish company It's Alive, players get points for finding and "shooting"other players via their mobile phones (using SMS messages or using WAP). Only players close by can be shot. To enable the game, players can request the positions of other nearby players. In such mixed-reality games, the real physical world becomes the backdrop of the game, instead of the world created on the limited displays of wireless devices <ref type="bibr" target="#b7">[8]</ref>. These games are expected to generate very large revenues in the years to come. Datamonitor, a market research company, estimates that 200 million mobile phone users in western Europe and the United States will play Web games via handsets, generating $6 billion in revenues <ref type="bibr" target="#b18">[19]</ref>. To track and coordinate large numbers of continuously moving objects, their positions are stored in databases.</p><p>Continuous movement poses new challenges to database technology. The conventional assumption is that data remains constant unless it is explicitly modified. Capturing continuous movement accurately with this assumption requires very frequent updates. To reduce the number of updates required, functions of time that express the objects' positions may be stored instead of simply the static positions <ref type="bibr" target="#b22">[23]</ref>. Then updates are necessary only when the parameters of the functions change "significantly." We use one linear function per object, with the parameters of a function being the position and velocity vector of the object at the time the function is reported.</p><p>Independently of how object positions are represented, the accuracy of the positions and, thus, their utility for providing a location-based service decreases as time passes, so when an object has not reported its position for a certain period of time, the recorded position is likely to be of little use. Consequently, it is natural to associate expiration times with positions so that these can be disregarded. The system, then, should automatically remove such "expired" information.</p><p>To provide fast answers to queries that locate the mobile objects in a certain area, an index on object positions must be maintained. No previous work on the indexing of the positions of continuously moving objects (discussed in Section 2.2) has addressed the issue of "expiring" information. This paper proposes the RI CP RQ -tree, an RS -tree <ref type="bibr" target="#b4">[5]</ref> based access method that builds on the ideas of the TPR-tree <ref type="bibr" target="#b20">[21]</ref>. The RI CP RQ -tree indexes the current and anticipated future positions of moving point objects, assuming that their positions expire after specified time periods.</p><p>To take advantage of information being valid only for a limited time, the proposed index uses a new type of bounding region. We show that the choice of bounding regions is non-trivial, and we experimentally compare a number of possible alternatives. In addition, we propose a modification of the R S -tree insertion and deletion algorithms that, during the regular index update operations, lazily removes expired information from the index. We provide also a mechanism by which the RI CP RQ -tree algorithms automatically tune themselves to match an important characteristic of the workloads they are subjected to-the average update rate. Finally we provide experimental comparison of the new index with the existing index, the TPR-tree, which assumes non-expiring information.</p><p>The next section presents the problem addressed by the paper and covers related research. As a precursor to presenting the new index, Section 3 explores issues related to the use of existing moving-object indexes, e.g., the TPR-tree, for the indexing of data with expiration times. In Section 4, this is followed by a description of the bounding regions and algorithms employed by the new index. It is assumed that the reader has some familiarity with the RS -tree. Section 5 reports on performance experiments, and Section 6 summarizes and offers research directions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Problem Statement and Related Work</head><p>We describe in turn the data being indexed, the queries being supported, and related work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Problem Statement</head><p>An object's position at time T is given by U V XW T Y a`W bV dc eW T Y 8f V hg HW T Y 8f 0i 0i 0i ef V Rp W T qY Y , where it is assumed that the times T are not before the current time. We model this position as a linear function of time, which is specified by two parameters. The first is a position for the object at some specified time T sr ut wv , U V $W T 8r ut Fv DY , termed the reference position. The second parameter is a velocity vector for the object, U</p><p>x `W bx 3c f x )g f 0i 0i 0i f x p Y . Thus, U V $W T qY ỳU V $W T r ut wv Y d U x W T 5T r ut wv Y . Although the times (T ) when different objects were most recently sampled may differ, it is convenient for the indexing purposes to have the reference position for all objects be associated with a single reference time, T 0r ut wv . Such a reference position can always be computed knowing the velocity vector U x observed at T q and the position U V $W T q Y observed at T .</p><p>Modeling object positions as functions of time not only enables us to make tentative near-future predictions, but, more importantly, alleviates the problem of the frequent updates that would otherwise be required to approximate continuous movement in a traditional setting where only positions are stored. In our setting, objects may report their parameter values when their actual positions deviate from what they have previously reported by some threshold. The choice of update frequency then depends on the type of movement, the desired accuracy, and the technical limitations <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b15">16]</ref>. For example, a mobile yellow pages service is likely to be much less sensitive than a traffic monitoring system to imprecise positions. An object's reference position and velocity vector describe its predicted movement from now and indefinitely far into the future. In the applications we consider, such far-reaching predictions are not possible. An object does not usually move for a long period of time within a useful threshold of its predicted movement.</p><p>Rather, if such an object does not report the new, up-to-date position and velocity, after some time, its old positional information becomes too imprecise to be useful-we say that it expires.</p><p>To avoid reporting such expired objects in response to queries, we associate an expiration time, T t , with each object and call them expiring objects. If unknown, the expiration time can be set to infinity, although, it in most cases should be easy to find a finite upper bound. Upper bounds can be dictated by a number of application specific factors. For example, moving objects may be forced to make changes in their movement due to an underlying infrastructure such as a road network, or objects may move according to some predetermined routes and schedules, as in a public transportation system <ref type="bibr" target="#b5">[6]</ref>. Finally, trivial upper bounds on the expiration times can be derived from the finite extents of the space where the objects move. objects are updated before they expire, while some expire before being updated. For example, object was updated at time -before its expiration time ( ). But then no update occurred prior to its new expiration time (d ). The latter may be more common in applications with unreliable or intermittent connectivity. For example, mobile telephones that are turned off may not be guaranteed to report to the system. In these cases, only expiration times guarantee that objects are removed from the data set.</p><p>The figure also exemplifies the types of queries that we aim to support. These queries retrieve all objects with predicted positions within specified regions at specified times. We distinguish between three kinds, based on the space-time regions they specify. In the sequel, a e -dimensional rectangle f is specified by its e projections g h ji c f qh k c sl f 0i 0i 0i eg h Ci p f qh k p l , h i m on h k m , onto the coordinate axes. Let f , f c , and f g be three e -dimensional rectangles and T , T i , and T k (T i p T k ) be three times that do not precede the current time. Type 1 timeslice query: q r`W f sf T ¥Y specifies a hyper-rectangle f located at time point T . Type 2 window query: q t`W f sf T i f T k Y specifies a hyper-rectangle f that covers the interval g T i f T k l . Stated differently, this query retrieves points with trajectories in ( U V , T )-space crossing the (e h u )-dimensional hyper-rectangle (g h i c f qh k c l , g h i g f qh k g l , . . . , g h i p f qh k p Hl , g T i f T k l ). Type 3 moving query: q v`W f c f qf g f T i wf T k CY specifies the (e ¢ x )-dimensional trapezoid obtained by con- necting f c at time T i to f g at time T k .</p><p>The second type of query generalizes the first, and is itself a special case of the third type. The types of queries are exemplified in Figure <ref type="figure">1</ref>, where q a is a timeslice query, q ¢ is a window query, and q ¢ is a moving query.</p><p>Notice that queries are positioned on the time axis according to the times T , T 0i , and T k specified in the queries, not according to the time they were issued. The greater the distance between these times and the query issue time, the more tentative the answer of the query is because objects update their parameters as time goes. For example, the answer to query q y would have been , if it were issued before time , and no object would have qualified for this query if it were issued later because was updated at time .</p><p>This example illustrates that queries far in the future are likely to be of little value, because the positions as predicted at the query time become less and less accurate as queries move into the future and because updates may occur. (The usage of expiration times will eliminate many "wrong" objects from the answers to such queries.) We expect applications to issue queries that are concentrated in some limited time window extending from the current time. The more frequently the parameters of the objects are updated, the shorter this window is likely to be.</p><p>We introduce a problem parameter, querying window length (W), which represents an expected upper bound on how far queries "look" into the future. Thus, z u{ 8{ W q |Y n T n z u{ 8{ W q |Y } W, for Type 1 queries, and z ~{ 7{ W q |Y n T i n T k n z u{ 8{ W q |Y W for queries of Types 2 and 3, where z ~{ 7{ W q |Y is the query issue time. The querying window is one of the important problem parameters used by our proposed index algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Previous Work</head><p>We consider first approaches that involve the partitioning the space into which the objects are embedded, then consider R-tree based approaches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1">Approaches Based on Data Space Partitioning</head><p>Early work on the considered indexing problem has concentrated mostly on points moving in one-dimensional space.</p><p>Tayeb et al. <ref type="bibr" target="#b21">[22]</ref> use PMR-Quadtrees <ref type="bibr" target="#b19">[20]</ref> for indexing the future trajectories of one-dimensional moving points as line segments in W bV f T qY -space (cf. Figure <ref type="figure">1</ref>). The segments span the time interval that starts at the index construction time and extends some fixed number of time units into the future, which leads to a tree that has to be rebuilt periodically. This approach introduces substantial data replication in the index-a line segment is usually stored in several nodes.</p><p>Kollios et al. <ref type="bibr" target="#b12">[13]</ref> employ the so-called dual data transformation where a line V `V $W T r ut wv Y X x 3W T ¢ T 8r ut Fv HY is transformed to the point ( V $W T "r ut wv Y 8f x ), enabling the use of regular spatial indices. It is argued that indices based on Kd-trees are well suited for this problem because these best accommodate the shapes of the (transformed) queries on the data. Kollios et al. suggest, but do not investigate in any detail, how this approach may be extended to two and higher dimensions. Kollios et al. also propose two other methods that achieve better query performance at the cost of data replication. These methods do not seem to apply to more than one dimension.</p><p>Basch et al. <ref type="bibr" target="#b3">[4]</ref> propose so-called kinetic main-memory data structures for mobile objects. The idea is that even though the objects move continuously, the relevant combinatorial structure changes only at certain discrete times, e.g., when two points pass each other. Thus, future events are scheduled that update a data structure at these times so that necessary invariants of the structure hold. Agarwal et al. <ref type="bibr" target="#b0">[1]</ref> apply these ideas to external range trees <ref type="bibr" target="#b2">[3]</ref>, obtaining a data structure can answer a Type 2 query in optimal W @ ) s aY I/Os using only slightly more than a linear number of disk blocks (here is the disk block size, is the number of objects, and is the size of the query result). This result holds only when queries arrive in chronological order-once a kinetic event has changed the data structure, no queries can refer to time points before the event. Agarwal et al. address non-chronological queries using partial persistence techniques and also show how to combine kinetic range trees with partition trees to achieve a trade-off between the number of kinetic events and query performance. Although achieving good asymptotic bounds that are very important from a theoretical point of view, the practical utility of the structures remain in question.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2">Approaches Based on Time-Parameterized Bounding Rectangles</head><p>As the technique proposed in this paper builds on the basic ideas of the TPR-tree, we review briefly the main ideas of the TPR-tree and other related access methods.</p><p>The TPR-tree is based on the RS -tree and indexes points that move in one, two, or three dimensions. It employs the basic structure and algorithms of the RS -tree, but the indexed points as well as the bounding rectangles in non-leaf entries are augmented with velocity vectors. This way, bounding rectangles are timeparameterized-they can be computed for different time points. The velocities of the edges of bounding rectangles are chosen so that the enclosed moving objects remain inside the rectangles at all times in the future. Figure <ref type="figure" target="#fig_1">2</ref> demonstrates this. Here, three one-dimensional moving points are shown together with their one-dimensional bounding rectangle (i.e., a bounding interval). The figure shows that answering window or moving queries in the TPR-tree involves the checking for intersection between two W e Y -dimensional trapezoids-a query and a bounding rectangle.</p><p>In addition to the usage of the time param-Bounding interval Query eterized bounding rectangles, the TPR-tree differs from the RS -tree in how its insertion algorithms group points into nodes. The RS -tree uses the heuristics of minimized area, overlap, and margin of bounding rectangles to assign points to the nodes of a tree. To take into account the temporal evolution of these heuristics, they are replaced by their integrals over time in the TPR-tree. The area of the shaded region in Figure <ref type="figure" target="#fig_1">2</ref> shows the time integral of the length of the bounding interval. This use of integrals in the algorithms allows the index to systematically take the objects' velocities as well as their current positions into account when grouping them. The bounding interval in Figure <ref type="figure" target="#fig_1">2</ref> is minimum only at the current time (CT). At later times, it is larger than the true minimum bounding interval. It is possible to record a true minimum bounding interval by storing all future events when the true minimum bounding interval changes ( c , g , and in the figure), but this is impractical because the number of such events in the worst case is equal to the number of objects enclosed by the bounding interval.</p><p>Agarwal et al. <ref type="bibr" target="#b1">[2]</ref> show how to reduce the number of events to a constant depending on by allowing the bounding interval at all times to have a length no larger than W Y of the length of the minimum bounding interval.</p><p>Based on these ideas, Pocopiuc et al. <ref type="bibr" target="#b17">[18]</ref> propose the STAR-tree index for moving objects. In contrast to the TPR-tree, the STAR-tree groups points according to their current locations. This may result in points moving with very different speeds being included in the same rectangle. To avoid such bounding rectangles growing too much, special events are scheduled to regroup the points. The STAR-tree is most suited for workloads with very infrequent updates.</p><p>Revesz et al. <ref type="bibr" target="#b5">[6]</ref> present a data model for spatiotemporal data based on parameteric rectangles that closely resemble the bounding rectangles inside the TPR-tree. The spatiotemporal evolution of an object with extent is described by a number of parametric rectangles, each associated with a specific validity time interval.</p><p>Cai and Ravesz have recently proposed a Parametric R-tree <ref type="bibr" target="#b6">[7]</ref> that is quite similar to the TPR-tree. The main difference is that they index the past evolution of objects with extent, meaning that they know at index construction time the entire evolution of the objects. This is a different and, in some ways, simpler problem than the one addressed here. Indexing of the past trajectories of moving points represented as polylines (connected line segments) in ( U V , T )-space is also the theme of papers by Pfoser et al. [17] and Kollios et   al. <ref type="bibr" target="#b13">[14]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Indexing Expiring Objects With the TPR-Tree</head><p>The TPR-tree presented in the previous section indexes the future trajectories of moving objects as infinite lines. The future trajectories of expiring objects may also be indexed with the TPR-tree, by replacing the finite line segments of the expiring objects with corresponding infinite lines. This setup introduces two issues that must be addressed. First, objects that have expired by the times specified in a query may introduce false drops in query answers, leading to overly large intermediate results from the index that must be filtered to produce the correct answer. Second, it may be desirable to have automatic means of deleting expired objects, which clutter the index.</p><p>One way of eliminating expired entries is to schedule deletions. To accomplish this, a secondary data structure is required that maintains the resulting queue of scheduled deletions. This structure must support operations not only for checking and removing the top element of the queue and inserting the new element, but also for efficiently deleting or updating any of the scheduled deletion events in the queue. This latter functionality is necessary because objects may be deleted or updated before they expire.</p><p>Such a structure does not generally fit in main memory, as its size is on the order of the size of the primary index structure. A B-tree on the composite key of the expiration time and the object id could be used. The topmost element of the queue can be found easily in the leftmost leaf page of the tree, and the insertion, deletion, and update operations can be performed efficiently.</p><p>In such a setting, the amortized cost of introducing one expiring object consists of four terms. First, the object has to be inserted into the TPR-tree. Next, the scheduled deletion event has to be inserted into the B-tree. Finally, when processing the scheduled deletion event, the event has to be removed from the B-tree, and the scheduled deletion has to be performed in the TPR-tree. In Section 5, where we describe our performance experiments, we show that this approach can be competitive with the RI CP RQ -tree only if the B-tree costs are ignored.</p><p>It should be also mentioned that unless queries arrive in chronological order, the scheduling of deletions does not allow to avoid the filtering step in answering future queries. Objects that expire after the current time, but before the query time, are reported as false drops and must be filtered.</p><p>In the following, when only one-dimensional moving points or bounding intervals are mentioned, it is assumed that the extension to higher dimensions is trivially done by applying the same procedure or definition to each of the dimensions, or by exchanging the length of the interval with the area, volume, or hyper-volume. Also, we use the term rectangle for any e -dimensional hyper-rectangle.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Index Structure and Time Parameterized Bounding Rectangles</head><p>The RI CP hQ -tree is a balanced, multi-way tree with the structure of an R-tree. Entries in leaf nodes are pairs of the position of a moving point and a pointer to the moving point, and entries in internal nodes are pairs of a pointer to a subtree and a (time-parameterized) region that bounds the positions of all moving points or other bounding regions in that subtree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">Representation of Points and Bounding Rectangles in the Index</head><p>As suggested in Section 2, the position of a moving point is represented by a reference position, a corresponding velocity vector, and an expiration time-W bV f x f T t Y in the one-dimensional case, where V VW T r ut wv Y . We let T r ut wv be equal to the index creation time, T 7 .</p><p>To bound a group of e -dimensional moving points, e -dimensional rectangles are used that are also time- parameterized and that enclose all enclosed points or rectangles at all times not earlier than the current time.</p><p>A tradeoff exists between how tightly a bounding rectangle bounds the enclosed moving points or rectangles across time and the storage needed to capture the bounding rectangle. It would be ideal to employ time-parameterized bounding rectangles that are always minimum, but, as noted in Section 2.2, doing so deteriorates in the general case to enumerating all the enclosed moving points or rectangles. Consider Figure <ref type="figure">3</ref>. Here, four one-dimensional moving points are bounded with an always minimum bounding interval, which bounds the positions of points tightly at all future time points. Each of the four points defines the upper or lower bound at some time in the evolution of the bounding interval.</p><p>To achieve a compact description of the enclosed entries, we use a single linear function as the bound (upper or lower) of the bounding interval. Following the representation of moving points, we let T r ~t Fv T and capture a one-dimensional time-parameterized bounding interval g</p><formula xml:id="formula_0">V i W T 0Y 8f V k W T "Y l g V i W T Y x i W T T 0Y 8f V k W T Y j x k W T T Y l for T p T k t as W bV i f V k f x i f x k f T k t Y .</formula><p>Here T t a s s i 1T t @ w , where ¡ ranges over the moving points or bounding intervals to be enclosed.</p><p>Note that we could as well choose not to record T t for bounding rectangles, reducing the size of internal index entries. Even in this case, a "natural," finite T t @ can be derived for bounding rectangles that shrink in some dimension, i.e., x i £¢ x k , for some ¡ . For such a rectangle, T t should be set to the time when its area becomes zero. In performance experiments, we investigate whether it pays off to record expiration times in internal index entries. In the following, we assume that bounding rectangles have expiration times even though some of them may be infinite.</p><p>There are a number of possible ways to compute V i , V k , x i , and x k . One goal is to choose these param- eters so as to minimize the integral of the interval's length from the time of bounding interval computation, T 8¤ ¥ , to T 8¤ ¥ r¦ , where ¦ x § aü© h Hf T t ªT 8¤ ¥ and H approximates how far into the future queries are most likely to access the computed bounding rectangle. We discuss how the value of H is estimated in Section 4.2.</p><p>Minimizing this integral is equivalent to minimizing the area (or the part of it between T ¤ ¥ and T ¤ 8¥ h «¦ ) of a trapezoid that bounds the trajectories of the enclosed points or intervals and that has bases orthogonal to the time axis. The shaded region in Figure <ref type="figure" target="#fig_1">2</ref> exemplifies such a trapezoid. In the following, the term "bounding trapezoid" is used to refer to this kind of a trapezoid.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">Simple Time-Parameterized Bounding Rectangles</head><p>If all entries are infinite, the only reasonable choice-if the interval is described by the above four parametersis what we term conservative bounding rectangles, which are minimum at the point of their computation, but possibly (and most likely!) not at later times. To ensure that a conservative bounding interval is bounding for all future times, the lower bound of the interval is set to move with the minimum speed of the enclosed points, while the upper bound is set to move with the maximum speed of the enclosed points (speeds are negative or positive, depending on the direction). This is a very simple construction that is independent of H. T , but to keep all points enclosed at all future times (assuming that objects have infinite trajectories), the upper bound of the interval moves at the speed of object , while the lower bound of the interval moves at the speed of object ) . Although the figure illustrates the concept, it should be noted that the TPR-tree algorithms most likely would not place and ) in the same node as ¬ and e .</p><p>The straightforward bounding interval for finite entries has both x i and x k equal to zero and is termed a static bounding interval. Figure <ref type="figure">3</ref> illustrates such a bounding interval. In addition to being simple, the main advantage of this type of interval is that by not storing x i and x k in the internal index entries, we increase the fan-out of internal tree nodes by almost a factor of two.</p><p>The last obvious and simple way of taking advantage of the expiration times is to use improved conservative bounding intervals, where the speed of the upper bound is reduced as much as possible and, analogously, the speed of the lower bound is increased as much as possible. We term such bounding intervals update-minimum intervals because, like conservative intervals, they are minimum at the time of the last update. Figure <ref type="figure">4</ref> shows how the speeds of the bounds are reduced or increased. Here, the speed of the upper bound of the bounding interval is not set to the speed of the fastest object ( ), but to some smaller speed that is enough to contain , knowing its expiration time. Notice that because the resulting bounding interval is relatively "nice" (it barely grows), the tree algorithms are very likely to group the four given objects in a single node. However, if the bounding interval is recomputed at some later time (T ¤ ¥ ), e.g., because of the insertion of a new object ( )d ), the interval-length integral is increased unnecessarily. How often this will happen and how it will effect the performance of the index is investigated in performance experiments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.3">One-Dimensional Optimal Time-Parameterized Bounding Rectangles</head><p>As mentioned earlier, the goal is to minimize the area of a trapezoid that is bounding and extends from T s®T ¤ 8¥ to T s®T ¤ ¥ x¦ . To find such a minimum bounding trapezoid, it suffices to consider only the endpoints of trajectories. When we are to bound moving points, each trajectory has one endpoint, and when we are to bound time-parameterized intervals, each trajectory has two endpoints-V i W T t Y and V k W T t Y . In the following, we denote this set of points by ¯. To capture the positions of points or intervals at T ¬¤ 8¥ , the minimum and maximum of these positions at T ¤ 8¥ are included in ¯. Figure <ref type="figure" target="#fig_3">5</ref> shows these points-V d°± ³² a©</p><formula xml:id="formula_1">s i V i W T 8¤ 8¥ Y and V }°´ μ a s ¶ s i V k W T 7¤ 8¥ Y , where s i V i W T 7¤ 8¥ Y •μ s i V k W T 7¤ 8¥ Y ¸ s i V W T 8¤ ¥ Y when</formula><p>points, not intervals, are being bounded. As noted by Cai and Revesz <ref type="bibr" target="#b6">[7]</ref>, the following lemma holds. Lemma 4. <ref type="bibr" target="#b0">1</ref> The lower and the upper bounds of a bounding trapezoid of ¯with minimum area between times T ¤ ¥ and T ¤ ¥ ¹¦ are the lines containing the edges of the convex hull of ¯that intersect the median line T òT 8¤ 8¥ ¹¦ R ¬ .</p><p>Here, the lower and upper bounds of the trapezoid are the lines described by the trajectories of the lower and the upper bound of the corresponding time-parameterized interval.</p><p>To understand why this lemma holds, con- let » be the rightmost of these (cf. Figure <ref type="figure" target="#fig_3">5</ref>).</p><p>Then we can reduce the area of the trapezoid by replacing this upper bound (¼ ½ ) with a line ¼ that has a smaller slope and contains the edge of the convex hull with » as its left point.</p><p>Figure <ref type="figure" target="#fig_3">5</ref> illustrates why the area is reduced.</p><p>The shaded triangle to the right of » shows the area that was eliminated, which is larger than the area of the shaded triangle to the left of » that shows the area that was gained. This is true for any » to the left of the median line.</p><p>We can continue this process until the upper bound contains vertices both to the left of the median line and to the right of it. Similar argument can be made when we start with an upper bound that contains only points to the right of the median line and when the lower bound is considered.</p><p>It should be noted that if the median line contains one of the vertices of the convex hull, the median line can be said to cross either the hull's edge to the right of the vertex or to the left of it; either interpretation produces a minimum trapezoid with the same area.</p><p>Any of a number of convex-hull computation algorithms (e.g., a Graham scan <ref type="bibr" target="#b8">[9]</ref>) can be used to find the convex hull of ¯in W q¾ ¯¾ w ) ¾ ¯¾ Y time. However, observe that we need to find only the edges of the convex hull that intersect the median line. This can be formulated as a linear programming problem.</p><p>Inspired by linear programming algorithms, Kirkpatrick and Seidel <ref type="bibr" target="#b11">[12]</ref> provide a linear algorithm to find such edges, which they call "bridges." Nevertheless, compared to the Graham scan, the algorithm is quite complex, and its implementation using finite precision floating point arithmetics is complicated. Therefore our implementation uses a bridge-finding algorithm based on the Graham scan.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.4">Multi-Dimensional Time-Parameterized Bounding Rectangles</head><p>The more general problem of finding a minimum Time-Parameterized Bounding Rectangles (TPBR) in multiple dimensions is much harder. It is a non-convex, non-linear mathematics programming problem. We desire simple algorithm that produces "satisfactory" results. One approach is to compute the parameters of the bounding rectangle independently in each dimension <ref type="bibr" target="#b6">[7]</ref>. For the ¡ -th dimension, the bridge-finding algorithm could be applied to the projections of the trajectories into the ( V f T )-plane.</p><p>It is very easy to improve such a straight- The idea is to introduce dependencies among the dimensions. Specifically, when considering the ¡ -th dimension, the already computed dimensions can be taken into account by adjusting the position of the median line in the bridge-finding algorithm. Note that in the proof of Lemma 4.1, we relied on the fact that a shaded triangle to the left of any point » that is to the left of the median has a smaller area that the triangle to the right of » (cf. Figure <ref type="figure" target="#fig_3">5</ref>). If » lies on the median line, both triangles have the same are. In multiple dimensions, not simple areas, but time integrals of hyper-volumes have to be compared.</p><p>To understand the issue, consider an example (illustrated in Figure <ref type="figure" target="#fig_4">6</ref>). In the first dimension V c , the computed bounding interval grows from left to right, i.e., with increasing time. Then a unit of bounding interval length in the second dimension V g has less weight at smaller times than at later times. Thus, the median line should be shifted to the right when computing its bounding interval.</p><p>In the following assume, without loss of generality, that T ¤ 8¥ À¿ . Suppose dimensions are already computed and we want to find a median line for the computation of the W Á Y -st dimension. Let h V k V i and Â `x k x i , n ¡ n , be the spatial and velocity extents of the bounding rectangle. Then, considering only the computed dimensions, the hyper-volume at time</p><formula xml:id="formula_2">T is Ã Ä Å c W h 5Â T "Y rAE Ä Å 3 Ç W ¡ Y T ,</formula><p>where Ç W ¡ Y is the sum of the coefficients at the ¡ -th power of T in the above polynomial. Lemma 4.2 If the parameters of a TPBR in the first dimensions are computed and fixed, the optimal parameters of a TPBR in the W | Y -st dimension can be computed using the median line T ÈòÉ , where</p><formula xml:id="formula_3">É ®`AE Ä Å 3 •Ê ¥Ë ÍÌ Î Ï g Ç W ¡ Y AE Ä Å 3 Ê Ë Ï c Ç W ¡ Y i PROOF:</formula><p>As mentioned earlier, the median line has the property that, for any point contained in it, the hyper-volume integral corresponding to its left "shaded triangle" is equal to the integral corresponding to its right "shaded triangle" (cf. Figure <ref type="figure" target="#fig_4">6</ref>). The left integral is</p><formula xml:id="formula_4">Ð )Ñ 3tÒ Ó W bÔ )© ¸Õ Ö Ô )© 6× Y W É Ø T qY AE Ä Å 3 jÇ W ¡ Y T e T . The right integral is Ð ¥Ù «`Ò Ê Ó W bÔ )© ¸Õ 5 Ô )© Ú× dY W T • ¹É ÛY AE Ä Å 3 Ç W ¡ Y T e HT . It is not difficult to see that Ð ¥Ù uÐ 0Ñ C W bÔ )© ¸Õ Ö Ô )© × dY W AE Ä Å 3 Ê ¥Ë ÍÌ Î Ï g Ç W ¡ Y É tAE Ä Å 3 Ê ¥Ë Ï c Ç W ¡ Y Y .</formula><p>Solving the equation Ð Ñ rÐ "Ù for É proves the lemma.</p><p>Ü As an example, if a , É ®¦ W ¬h c ¹ sÂ c ¦ RY W ¬h c Ý sÂ c ¦ hY . Using this lemma, our algorithm for computing a multi-dimensional TPBR visits dimensions one by one until TPBR parameters in all the dimensions have been computed. The order in which dimensions are visited may influence the resulting TPBR. We choose a random order, so that no dimension is given preference. This algorithm, combined with a linear bridge-finding algorithm, has an expected-case running time of W e ¾ ¯¾ Y , where e is the number of dimensions. We term the bounding rectangles produced by this algorithm near-optimal.</p><p>To measure the loss in performance caused by using near-optimal TPBRs, we implemented an algorithm that computes optimal multi-dimensional TPBRs. The idea is to compute convex hulls in each of the ( V f T )- planes. Then, by using sweeping median lines in each of the first e • dimensions, we consider all possible combinations of choices of bridge-edges in these dimensions. Finally, for each of the combinations, using Lemma 4.2, we compute É for the e -th dimension and find the bridge-edges in this dimension using binary search on the edges of the convex hull in this dimension. The worst-case running time of this algorithm is</p><formula xml:id="formula_5">W q¾ ¯¾ p "Þ c w ) ¾ ¯¾ Y .</formula><p>Although we do not discuss this in detail, the presented algorithms can be easily generalized to handling the case when some of the bounded points or rectangles have infinite expiration times.</p><p>Section 5 investigates the differences in performance resulting from using static, update-minimum, nearoptimal, or optimal TPBRs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.5">Using TPBRs when Querying</head><p>When answering a query in the RI DP hQ -tree, we need to be able to check whether the trapezoid formed by the query intersects the trapezoid formed by a TPBR. The same algorithm as in TPR-tree can be used <ref type="bibr" target="#b20">[21]</ref>, the only modification being that intersection should be checked between T i μT i ß and T k a© W T k ß f T t Y , where g T qi ß f T k ß l is the time interval specified in the query.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Heuristics for Tree Organization</head><p>We proceed to describe the heuristics that determine how to group moving objects and their TPBRs into nodes so that the tree most efficiently supports queries when assuming a querying window length, W.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Integrated RS -Tree Heuristics</head><p>Intuitively, when the index is under continuous change due to time parameterization, the decision of where to place an object's updated, time-varying position should take into account the evolution of the relevant parts of the index from the current time to the next update of the same object or to the time the object expires. Thus, the average duration ( à já ) between the two successive updates of an object is an important problem parameter, which is directly related to the frequency of index updates. Similar considerations apply to node splits. On average, a split-generated distribution of entries will not persist longer than à já time units, upon which most of the entries of both nodes have been updated.</p><p>Although the decisions about an entry's placement will affect queries only for à já time units, some queries may be future queries that look as far as W time units into the future. Thus, the total length of the time duration when queries will "see" the current insertion is H Øà já 6 W. We term this the time horizon.</p><p>It should be noted that the above considerations about a single object cannot be stated strictly because, in addition to the continuous change due to time-parameterization, the index is constantly changing due to the updates of other objects. Nevertheless, performance experiments with the TPR-tree demonstrate that insertion algorithms using the time horizon H Øà já W consistently show good query performance.</p><p>The insertion algorithms of the RS -tree, which we extend to moving points, aim to minimize objective functions such as the areas of the bounding rectangles, their margins (perimeters), and the overlap among the bounding rectangles. In our context, these functions are time dependent, and we should consider their evolution in the interval g T ¤ ¥ f T ¤ 8¥ H l . Specifically, given an objective function â ¢Ù W T 0Y of a bounding rectangle ã , we replace it with the following integral in the insertion algorithms.</p><p>ä 5å ~ae bç è Ï hé Èê 1ë 0ì í î Ù ï å ð Fñ ç 0ò å ~ae bç è â Ù W T "Y e T</p><p>If â Ù W T "Y is area, the integral computes the area (volume) of the trapezoid that represents part of the tra- jectory of a bounding rectangle in ( U V f T )-space (see Figure <ref type="figure" target="#fig_1">2</ref>). Note, that for objective functions de- pending on the two bounding rectangles, say ã c and ã g , the upper integration bound becomes T ¤ ¥ a© h só of ã c i 1T t @ f ã g i 1T t @ . The computation of such integrals is described in more detail in <ref type="bibr" target="#b20">[21]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Bounding Rectangles and Grouping of Entries</head><p>While the replacement of the objective functions of area, distance, margin, and overlap of bounding rectangles with the corresponding integrals represents a natural and simple adoption of the R S -tree algorithms, additional issues may need to be addressed.</p><p>One of them is what we term the non-associativity of TPBR computation. In the R-trees, with the Hilbert R-tree <ref type="bibr" target="#b10">[11]</ref> as a notable exception, the bounding rectangles are used for two purposes-pruning search (in queries) and guiding insertion decisions. Suppose that the insertion algorithm has reached a node that is a parent to leaf nodes and it must be decided which of the child nodes should receive a new entry. The RS -tree chooses a child node using the ChooseSubtree algorithm, which asks a "what if" question for each child node. Specifically, for each child node, the algorithm computes the area of the overlap between the sibling bounding rectangles and the existing "old" bounding rectangle, and then compares it with the area of overlap between the "new" bounding rectangle, obtained by extending the existing bounding rectangle to include the new entry, and the sibling rectangles. In the RS -tree, the "new" bounding rectangle is exactly equal to the bounding rectangle that the node would have if the new entry were inserted into it and the bounding rectangle were computed by looking at all its entries, including the new one. We use the term associativity for this property of bounding rectangle computation.</p><p>The TPBRs of the same entries computed at different times may be different. Thus, the TPBR computation is non-associative, if computations of the "old" and "new" TPBRs are performed at different times. In addition, for optimal or near-optimal TPBRs, the computation is non-associative even if the computations are performed simultaneously. This is illustrated in Figure <ref type="figure">7</ref>. Here, four objects c f 0i 0i 0i f q sô are bounded with old TPBR. The ChooseSubtree algorithm has to determine how the TPBR would look if a new object were added. The figure shows that the TPBR computed by ChooseSubtree based on old TBPR and new object is different from the TPBR that would be obtained if the new entry were actually added, i.e., õ ö ø÷ ù W õ ö $÷ Xù W c f q g f q ¬ ¬f q eô eY 8f 0ú 3û "ü ªý þ ÿ 0û ¡ ¢ Y ¤£`õ ö $÷ ù W c f q g f q ¬ ¬f q sô )f 0ú hû "ü ý þ ÿ 0û ¡ ¢ Y . This non-associativity means that insertion heuristics work with inaccurate information. Thus, even if an optimal TPBR means the best TPBR for a given set of entries, the same TPBR, used for insertion decisions may in the long term lead to worse groupings of entries than when using other types of bounding rectangles. That is why our performance experiments consider the range of possible types of bounding rectangles described in Section 4.1.</p><p>Intuitively  <ref type="figure">7</ref>, object g is the main cause of the difference between the differently computed TPBRs. The grouping of entries with different velocities also leads to update-minimum bounding rectangles that deteriorate, as shown in Figure <ref type="figure">4</ref>. In addition, a node of entries with significantly different velocities is more difficult to split.</p><p>A simple way to avoid grouping entries with very different velocities together is to consider all entries (representing both objects and bounding rectangles) as being infinite when making insertion decisions. Performance experiments in Section 5 investigates the effect of this on query performance.</p><p>Not considering the differences of the types of TPBRs used, the ChooseSubtree, Split, and RemoveTop<ref type="foot" target="#foot_1">1</ref> algorithms of the RI DP hQ -tree are the same as those of the TPR-tree. The only difference is that the Choos- eSubtree does not use overlap enlargement as a heuristic <ref type="bibr" target="#b4">[5]</ref>. This simplifies the algorithm, making it linear instead of quadratic. Our performance experiments with different types of TPBRs show that using overlap enlargement as heuristics in the ChooseSubtree of the RI DP hQ -tree does not improve query performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Dynamic Maintenance of the Time Horizon</head><p>As discussed in Section 4.2.1, the decisions made in insertion algorithms depend on the time horizon H, which, in turn, depends on the average update interval length ( à já ) and the average querying window length (W). To obtain a versatile and robust index, the values of these parameters should be maintained automatically by tracking the operations on the index.</p><p>To maintain an approximate value of à á , the RI DP hQ -tree tracks the current number of entries (¥ ) in the leaf level of the tree. It is increased every time a new leaf entry is inserted and decreased when a leaf-entry is deleted or discarded due to expiration. In addition, every insertions, a special timer is reset to measure the time duration (¦ sT ) it took to receive the last insertions. Here, is the number of entries in a node. Parameter à já is also updated every insertions. It is set to be W ¦ yT Y §¥ . One could also choose other periodic policies for updating à já , but, at least initially, it should not be done less frequently than every insertions, so that, when H is used for the first time (in the first split of the root), the initial estimate of à á is available.</p><p>The above à á is used for making decisions in the insertion algorithm. When computing optimal and near-optimal TPBRs, a value that is smaller than the computed à já should be used because the TPBR can be recomputed any time one of the enclosed objects is updated. Thus, in addition to ¥ `¥ u , the number of leaf-entries, the RI CP RQ -tree maintains the number of entries at each level of the tree (¥ ). Then, à já D , the average time between two recomputations of a bounding rectangle that bounds a node of level ¡ C , is equal to à já Þ c W ¥ Þ c ©¥ Y , where ¥ Þ c ©¥ is the average number of entries in a node at level ¡ } .</p><p>To compute the H parameter, the query window length W is needed. One could track queries to estimate W, but this approach has the disadvantage that an index may not be queried for long periods of time, leaving W outdated. We employ a different approach. In realistic scenarios, W is intimately related to à já . It makes little sense to ask queries that reach much further into the future than à já because the results of such queries will most probably be grossly invalidated by future updates. Thus, we choose W × ¤ sà já , where ¿ p × p in most realistic scenarios.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Removal of Expired Entries</head><p>To contend with expiring entries in both the leaf level and in internal nodes of a tree, the insertion and deletion algorithms must be adjusted further.</p><p>First, the expired entries should be discarded from the tree at one time or the another. Second, a node may be noticed to be underfull, counting only non-expired entries, termed live, not only after removing an entry from a node during a deletion operation, but at any stage in both deletion and insertion algorithms.</p><p>To address this, a range of strategies can be adopted, ranging from very eager strategies, where expired entries are deleted by scheduled deletions as soon as they expire, to lazy strategies, where expired entries are allowed to stay in the index. We adopt a lazy strategy for the removal of expired index entries. Only live entries are considered during search, insertion, and deletion operations, but expired entries are physically removed from a node only when the contents of the node is modified and the node is written to disk. In addition, when an expired entry in an internal node is discarded, either when writing the node to the disk or deallocating it, the whole subtree rooted at this entry has to be deallocated.</p><p>To handle consistently the events of nodes becoming underfull (and overfull), the algorithms for insertion or deletion are modified to become very similar. First, as in the regular RS -tree, the leaf node is found where a new entry has to be inserted or the existing one deleted. From here, both algorithms proceed in the same way by calling the function "! # $ W §% û ¡&amp; (' Y , below, for the leaf node that was changed.</p><p>) 10 32 42 65 87 @9 ©A B2 65 85 DC FE HG (I FP DQ : CT1 Initialize a list of orphaned entries, orphans, to be empty. The level of the tree from which the entry was removed is recorded with each entry in orphans. CT2 Call R 6S UT 3V I @W YX $ba c2 40 ed B0 f eg Y9 h5 8i pd qC rE HG (I sP t R @S UT YV I @W YX @Q . CT3 While orphans is not empty CT3.1 Remove an entry with the highest level from orphans and insert it into a node at the appropriate tree level (in the same way as a data entry is inserted at leaf level), or if the root node of the tree is empty, insert it into the root node. Let node be the node where the entry was inserted. CT3.2 Call R 6S UT 3V I 6W 3X $ùa c2 60 ed B0 ef g "9 ©5 i d qC FW R hv G t R @S UT YV I @W YX 6Q . CT4 If the root node was modified and has only one entry, reduce the number of tree levels by declaring the child of it a new root.</p><p>The exotic case of the root becoming empty in CT3.1 may occur if all but one entry in the root expire and the single live entry is removed from the root by function w x y ! e y . This function checks for both the node being underfull or overfull (counting only live entries) and propagates the necessary changes up the tree.</p><formula xml:id="formula_7">a c2 60 3d 0 ef g "9 h5 8i d C FW R ©v G t R 6S UT 3V I 6W 3X 4Q</formula><p>: PU1 If node is overfull, then, as in R -tree, either move a number of its live entries to orphans for later reinsertion (if that was not yet performed at this level), or split node. PU2 If node is underfull, then move all its live entries to orphans and deallocate the node. PU3 Remove the entry from node's parent, parent, if the node was deallocated; install a new entry in parent, if the node was split (a new root is created if the root was split). Otherwise, update the bounding rectangle in the parent's entry that points to the node, if necessary. PU4 If node is not the root, call R 6S UT 3V I 6W 3X cùa c2 60 ed B0 f eg "9 ©5 8i pd qC T I S G W e t R @S UT YV I 6W YX 6Q</p><p>. Return orphans.</p><p>The presented algorithm ensures that all nodes modified by the algorithm have the right number of live entries. All other nodes, even if read by the algorithm, may be underfull.</p><p>It should be noted that the deletion algorithm in the RI DP hQ -tree uses a regular search procedure to find a leaf entry to be deleted. This procedure does not "see" expired entries. Consequently, if a delete operation is performed on an expired entry, the operation fails. This could be changed to allow the deletion algorithm to see the expired entries, but, as performance experiments show, this is unnecessary. The lazy strategy of purging expired entries as described above is able to maintain a very low percentage of expired entries in the index. Figure <ref type="figure" target="#fig_6">8</ref> illustrates the workings of the algorithm. Here, an insertion of a new entry purges expired entries in part of the tree, and shrinks the tree in the process. The example assumes a maximum of 5 and a minimum of 3 entries in a node. In the first step, the entry X/20 is directed to leaf node C. As G and H in C have expired (the current time is 5), C is underfull and is discarded, while its live entries are temporarily stored in ý 8 F &amp; ¬ú w{ . After removing C's entry from B, we notice that B is underfull. Again, B is discarded,  and its live entries are posted to ý " s D&amp; ¬ú w{ , now at the list of level 1. In addition, when discarding B's expired entry E, we take care to deallocate the whole subtree rooted at E, which in this case happens to be a single leaf node. It is also worth noting that after this step, if A had expired, the algorithm would run into the situation of an empty root (CT3.1) when a new root is created from entries in ý " s D&amp; ¬ú w{ . In the last two steps, entries from ý 8 F &amp; ¬ú w{ are inserted one by one, starting with the higher-level entries. Finally, the tree is shrunk by discarding the single entry root.</p><p>Except for always checking for underfull or overfull nodes, the presented algorithm does not differ substantially from the RS -tree insertion and deletion algorithms. It should be noted, though, that in the new algorithm, the number of entries in the list orphans in the worst case is bounded only by the number of entries in the whole tree, meaning that the list may not fit in main memory. For example, this could happen after a long period during which the system, for some reason, did not receive any updates. A natural solution to this problem is to fix the maximum size of orphans and stop handling underfull nodes in step PU2 when orphans is almost full. Limiting the size of orphans also limits the cost of any single update operation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Performance Experiments</head><p>This section reports on performance experiments with the RI DP hQ -tree. The generation of two-dimensional moving point data and the settings for the experiments are described first, followed by the presentation of the results of the experiments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Experimental Setup and Workload Generation</head><p>The RI CP hQ -tree was implemented in C++ using, as the basis, an adapted GiST <ref type="bibr" target="#b9">[10]</ref> class library implementa- tion. The page size (and tree node size) is set to 4k bytes, which results in 170 entries in a full leaf node and 102 entries in a full non-leaf node. A page buffer of 200k bytes, i.e., 50 pages, is used <ref type="bibr" target="#b14">[15]</ref>, where the root of a tree is pinned and the least-recently-used page replacement policy is employed. Nodes modified during an index operation are marked as "dirty" in the buffer and are written to disk at the end of the operation or when they otherwise have to be removed from the buffer.</p><p>The performance studies are based on artificially generated workloads that intermix queries and update operations, thus simulating index usage across a period of time. Initially, the index is empty and is populated gradually, with entries being added when simulated objects send their first positions. After the initial insertion of an object into the index, each subsequent update consists of the deletion of the old positional information, followed immediately by the insertion of the new. We proceed to describe how the updates and the queries are generated.</p><p>Because it is unrealistic to expect uniformly distributed positions and velocities for moving objects, we attempt to generate more realistic (and skewed) two-dimensional data by simulating a scenario where the objects, e.g., cars, move in a network of routes, e.g., roads, connecting a number of destinations, e.g., cities or intersections. Twenty destinations are distributed uniformly in the space with dimensions 0¿ )¿ )¿ 0¿ )¿ )¿ kilometers. The destinations serve as the vertices in a fully connected graph of 380 one-way routes. When a new object is introduced, it is placed at a random position on a random route. The object is assigned with equal probability to one of three groups of objects with maximum speeds of ¿ i H ¬d , ¬i ³d , and km min ( d , ¿ , and @d ¬¿ km h). During the first sixth of a route, objects accelerate from zero speed to their maximum speeds; during the middle two thirds, they travel at their maximum speeds; and during the last one sixth of a route, they decelerate. When an object reaches its destination, a new destination is assigned to it at random. The workload generation algorithm distributes the updates of an object's movement so that updates are performed during the acceleration and deceleration stretches of a route. The number of updates is chosen so that the total average time interval between two subsequent updates is approximately equal to a given parameter à já , which is fixed at ¬¿ in most experiments.</p><p>In addition to using the above-described data, some experiments also use workloads with uniform data. In these workloads, the initial coordinates of a newly introduced object are chosen randomly. The directions of the velocity vectors are assigned randomly as well, both initially and on each update. The speeds (lengths of velocity vectors) are uniformly distributed between 0 and 3 km min. The time interval between successive updates is uniformly distributed between 0 and à á .</p><p>Two different approaches are used for generating expiration times. In one set of the experiments, the expiration time of an object is set to be equal to the time of the update plus the expiration period ExpT that is common to all objects. Most experiments use à já for ExpT. In the other approach, expiration times are dependent on the speeds of the objects. The positional information of fast objects becomes imprecise sooner than the positional information of slow objects. Consequently, fast objects should expire sooner. To achieve this, we introduce the concept of expiration distance. On an update, an object with speed x is assigned the expiration time T ¤ 8¥ fe hg © i « x , where ExpD is varied in the experiments.</p><p>Depending on how expiration times are generated, a large portion of objects may expire and be removed from the index before they are updated. This means that the number of objects in the index is smaller than the number of objects participating in the simulated scenario. Based on the assumption that the time interval between successive updates is uniformly distributed between 0 and à já , the workload generation algorithm, if necessary, increases the number of objects participating in the scenario so that the average number of leaf entries is around 100,000.</p><p>As mentioned in Section 2.1, there may be application scenarios where objects that stop reporting their positions are not guaranteed to notify the system and be deleted from the index. Our workload generation algorithm simulates this scenario by randomly "turning off" objects. To maintain a constant number of objects, a new object is introduced for each turned off object. A workload generation parameter NewOb specifies the fraction of objects initially participating in the simulated scenario that are replaced by new objects during the course of the workload.</p><p>All workloads contain one million insertion operations. In addition to insertions and deletions, workloads include one query for each 100 insertions (10,000 in total). Timeslice, window, and moving queries are generated with probabilities ¿ i ³ , ¿ i ³ , and ¿ i ³ . The temporal parts of queries are generated randomly in an interval of length W `à á ¬ and starting at the current time. Thus, the × parameter mentioned at the end of Section 4.2.3 is set to ¿ i ³d . Only for workloads with e hg © õ À ¬¿ , the setting of W ` ¥d was used. The spatial part of each query is a square occupying ¿ i ³ )d % of the space. The spatial parts of timeslice and window queries have random locations. For moving queries, the center of a query follows the trajectory of one of the points currently in the index.</p><p>The workload generation parameters that are varied in the experiments are given in Table <ref type="table" target="#tab_1">1</ref>. Standard values, used if a parameter is not varied in an experiment, are given in bold-face. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Experiments with Near-Optimal Time Parameterized Bounding Rectangles</head><p>As mentioned in Section 4.2.2, the ChooseSubtree algorithm may need slight modifications when combined with near-optimal TPBRs. In addition, not recording expiration times in TPBRs (as suggested in Section 4.1.1) may be beneficial. To investigate these issues, we compared four flavors of the RI CP RQ -tree algorithms. Two use the regular ChooseSubtree algorithm, and the other two use the modified ChooseSubtree algorithm that assumes (only for decision-making purposes) the entry being inserted and the entries of the tree to have infinite expiration times. The latter should result in a more pronounced grouping of objects according to their velocities. For either choice of the ChooseSubtree algorithm, both options-recording TPBR expiration times and not recording them-are explored (expiration times for data entries are always recorded).  <ref type="figure">10</ref>). Nevertheless, in most cases, the best results are produced when the normal ChooseSubtree algorithm is combined with TPBRs without expiration times. Other types of bounding rectangles also lead to better search performance when their expiration times are not recorded.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Comparing Different Time Parameterized Bounding Rectangles</head><p>A set of experiments with varying workloads was performed in order to compare the relative performance of near-optimal, optimal, static, and update-minimum bounding rectangles. For update-minimum bounding rectangles, both versions of the ChooseSubtree algorithm, discussed in the previous subsection, were explored. The version of the ChooseSubtree algorithm that ignores expiration times should avoid grouping regions in a way that causes update-minimum bounding rectangles to degrade later (illustrated in Figure <ref type="figure">4</ref>). Figure <ref type="figure" target="#fig_0">11</ref> shows the average number of I/O operations for uniform workloads, when ExpT is varied, and Figure <ref type="figure" target="#fig_8">12</ref> shows the result of experiments with workloads with speed-dependent expiration times.</p><p>The graphs demonstrate that, in most cases, near-optimal bounding rectangles perform best, and we use them in the experiments reported in the next subsection. Usage of the optimal bounding rectangles does not improve query performance. Most interestingly, update-minimum bounding rectangles are almost as good as near-optimal ones. Observe though that, in Figure <ref type="figure" target="#fig_0">11</ref>, update-minimum TPBRs give better results when combined with the normal ChooseSubtree algorithm; and in Figure <ref type="figure" target="#fig_8">12</ref>, update-minimum bounding rectangles are better when combined with the ChooseSubtree algorithm that ignores expiration times. This can be explained by observing that the situations similar to the one shown in Figure <ref type="figure">4</ref> are much more common in workloads where expiration times are dependent on the speeds. In these workloads, fast objects, such as and ) in Figure <ref type="figure">4</ref>, expire sooner than slow objects.</p><p>For the same reasons, static TPBRs perform quite well for workloads with speed-dependent expiration times. Static TPBRs can effectively bound the trajectories of objects only if the trajectories with long expiration times have speeds close to zero, i.e., such trajectories are parallel to time axis (cf. Figure <ref type="figure">3</ref>). This is exactly the case for workloads with speed-dependent expiration times.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Comparing the RI CP RQ -Tree with Alternative Approaches</head><p>To evaluate the RI DP hQ -tree, we compared it with the TPR-tree and the TPR-tree with an associated B-tree for storing scheduled deletions as described in Section 3. To evaluate the difference between the lazy approach to purging expired entries and the approach where deletions are scheduled, we consider also the R I CP RQ -tree with scheduled deletions. Figures <ref type="figure" target="#fig_10">13</ref> and<ref type="figure" target="#fig_11">14</ref> show the search performance for workloads with varying ExpD and NewOb. The graphs demonstrate that if expiration durations are not too large, the RI CP RQ -tree outperforms the TPR-tree by almost a factor of two even for workloads with no new objects being introduced. Naturally, when the number of "turned off" objects increases, the performance of the TPR-tree drops significantly because the size of the index increases (see Figure <ref type="figure" target="#fig_13">15</ref>).</p><p>The performance of the RI DP hQ -tree is only slightly worse than that of the approaches that employ sched- uled deletions (which, as we shall see shortly, have excessive update costs). Most of the difference can be attributed to the better organized index that results from more updates when scheduled deletions are added to regular update operations. As Figure <ref type="figure" target="#fig_13">15</ref> shows, the difference in sizes between the RI CP RQ -tree and the RI CP RQ -tree with scheduled deletions is negligible. This means that at any moment, the frequency of updates is high enough for the algorithms described in Section 4.3 to remove most of the expired entries. Figure <ref type="figure" target="#fig_11">14</ref> also shows that the difference between search performances of the TPR-tree with scheduled deletions and the RI DP hQ -tree with scheduled deletions is very small. Note that the RI DP hQ -tree is penalized in this setting by unnecessarily recording expiration times. This is illustrated by the size differences of the two indices (see Figure <ref type="figure" target="#fig_13">15</ref>). Nevertheless, the above-mentioned small difference demonstrates that most of the performance gain of the RI DP hQ -tree when compared to the TPR-tree is achieved by the regrouping of entries that occurs due to the lazy removal of expired entries.</p><p>Figure <ref type="figure" target="#fig_14">16</ref> shows that automatic removal of expired entries does not result in bad update performance. Here the average number of I/O operations per single insertion or deletion operation is shown. Note that the provided graphs do not include the costs associated with B-trees for the approaches with scheduled deletions. Adding these costs to the performance numbers of the TPR-tree with scheduled deletions would almost double them and, thus, make the update performance of this approach much worse than the update performance of the RI CP RQ -tree. Rexp-tree TPR-tree Rexp-tree with scheduled deletions TPR-tree with scheduled deletions  The proposed RI DP hQ -tree captures the future trajectories of moving points as linear functions of time.</p><p>To address the issue that, in many applications, the positional information is expected to be irrelevant and outdated soon after it is recorded, the RI DP hQ -tree stores expiration times in leaf entries of the index.</p><p>We provide insertion and deletion algorithms for the index that support expiration times. The algorithms implement a lazy technique for removing expired entries from the index. Performance experiments show that, for realistically dynamic index workloads, the algorithms are able to eliminate all but a very small fraction of the expired entries. By removing expired entries and, in the process, recomputing bounding rectangles and handling the resulting underfull nodes, the RI DP hQ -tree algorithms reorganize the index to improve query performance. In addition, the removal of expired entries does not result in high update costs.</p><p>The RI CP RQ -tree borrows the idea of time-parameterized bounding rectangles from the TPR-tree, but to take advantage of expiration times, we have investigated a number of different ways of computing such rectangles. Performance experiments show that choosing the right bounding rectangles and corresponding algorithms for grouping entries is not trivial and is dependent on the characteristics of the workloads. The so-called near-optimal time-parameterized bounding rectangles exhibited overall good query performance.</p><p>The long-term effect that different types of bounding shapes have on the grouping of finite line segments deserves a more detailed study (see Section 4.2.2). A possible approach would involve separating the information that guides the grouping decisions from the information that guides search. Such studies may be also useful in connection with the indexing of the histories of moving points.   </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 Figure 1 :</head><label>11</label><figDesc>Figure 1: Example One-Dimensional Data Set and Queries</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: A Bounding Interval and a Query in the TPR-tree</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :Figure 4 :</head><label>34</label><figDesc>Figure 3: Conservative (Bold), Always Minimum (Dashed), and Static (Dotted) Bounding Intervals</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: A Convex Hull and an Optimal Bounding Interval</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Finding a Median Line for the Second Dimension (Top), When the First Dimension is Computed (Bottom)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Purging of Expired Entries Triggered by an Insertion (Expiration Times Are Shown After Slashes)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: Search Performance for Varying ExpD</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 13 :</head><label>13</label><figDesc>Figure 13: Search Performance For Varying ExpD</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 14 :</head><label>14</label><figDesc>Figure 14: Search Performance for Varying Fraction of New Objects, NewOb</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>Rexp-tree with scheduled deletions TPR-tree with scheduled deletions</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 15 :</head><label>15</label><figDesc>Figure 15: Index Size for Varying Fraction of New Objects, NewOb</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 16 :</head><label>16</label><figDesc>Figure 16: Update Performance for Varying Fraction of New Objects, NewOb</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Workload Parameters</figDesc><table><row><cell cols="2">Parameter Description</cell><cell>Values Used</cell></row><row><cell>ExpT</cell><cell>Expiration duration (time interval until expiration)</cell><cell>30, 60, 120, 180, 240</cell></row><row><cell>ExpD</cell><cell>Expiration distance (distance traveled until expiration)</cell><cell>45, 90, 180, 270, 360</cell></row><row><cell>NewOb</cell><cell>Fraction of new objects</cell><cell>0, 0.5, 1, 1.5, 2</cell></row><row><cell>UI</cell><cell>Update interval length</cell><cell>30, 60, 90, 120</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Figure 10: Search Performance For Varying UI that, if TPBR expiration times are recorded, ChooseSubtree has to be modified to consider all entries as infinite (cf. the top two lines in Figure</figDesc><table><row><cell></cell><cell>100</cell><cell cols="3">BRs with exp.t., algs with exp.t.</cell><cell></cell><cell>80</cell><cell cols="2">BRs with exp.t., algs with exp.t.</cell></row><row><cell></cell><cell>90</cell><cell cols="3">BRs w/o exp.t., algs with exp.t. BRs with exp.t., algs w/o exp.t.</cell><cell></cell><cell>70</cell><cell cols="2">BRs w/o exp.t., algs with exp.t. BRs with exp.t., algs w/o exp.t.</cell></row><row><cell></cell><cell>80</cell><cell cols="3">BRs w/o exp., algs w/o exp.t.</cell><cell></cell><cell></cell><cell cols="2">BRs w/o exp., algs w/o exp.t.</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>60</cell><cell></cell><cell></cell></row><row><cell></cell><cell>70</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Search I/O</cell><cell>50 60</cell><cell></cell><cell></cell><cell></cell><cell>Search I/O</cell><cell>40 50</cell><cell></cell><cell></cell></row><row><cell></cell><cell>40</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>30</cell><cell></cell><cell></cell></row><row><cell></cell><cell>30</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>20</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>20</cell><cell></cell><cell></cell></row><row><cell></cell><cell>10</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>10</cell><cell></cell><cell></cell></row><row><cell></cell><cell>30</cell><cell>60</cell><cell>120</cell><cell>180</cell><cell>240</cell><cell>30</cell><cell>60</cell><cell>90</cell><cell>120</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">Expiration Period, ExpT</cell><cell></cell><cell></cell><cell cols="2">Update Interval, UI</cell></row><row><cell cols="6">Figure 9: Search Performance For Varying ExpT</cell><cell></cell><cell></cell><cell></cell></row></table><note><p>Figures 9 and 10 show the average numbers of I/O operations per query for workloads with varying ExpT and à já parameters. The graphs, as well as the results of a number of other experiments, demonstrate</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_0"><p>Structure and AlgorithmsThis section presents the structure and algorithms of the RI CP RQ -tree. First, we explore possibilities for computing time-parameterized bounding rectangles by maximally exploiting expiration times. Next, we investigate how the different types of bounding rectangles can be used to guide the grouping of entries in the tree, and how this grouping is automatically adjusted depending on a specific update rate and querying window length. Finally, we describe the modified insertion and deletion algorithms that ensure the efficient disposal of expired entries.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1"><p>RemoveTop is used in connection with forced reinsert<ref type="bibr" target="#b4">[5]</ref>.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Indexing Moving Points</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">K</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Arge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Erickson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the PODS Conf</title>
		<meeting>of the PODS Conf</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="175" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Peled Maintaining Approximate Extent Measures of Moving Points</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">K</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Har</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the ACM-SIAM Symposium on Discrete Algorithms</title>
		<meeting>of the ACM-SIAM Symposium on Discrete Algorithms</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="148" to="157" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">On Two-Dimensional Indexability and Optimal Range Search Indexing</title>
		<author>
			<persName><forename type="first">L</forename><surname>Arge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Samoladas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Vitter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the PODS Conf</title>
		<meeting>of the PODS Conf</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="346" to="357" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Data Structures for Mobile Data</title>
		<author>
			<persName><forename type="first">J</forename><surname>Basch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Guibas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hershberger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 8th ACM-SIAM Symposium on Discrete Algorithms</title>
		<meeting>of the 8th ACM-SIAM Symposium on Discrete Algorithms</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="747" to="756" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The R -tree: An Efficient and Robust Access Method for Points and Rectangles</title>
		<author>
			<persName><forename type="first">N</forename><surname>Beckmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-P</forename><surname>Kriegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Seeger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the ACM SIGMOD Conf</title>
		<meeting>of the ACM SIGMOD Conf</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="322" to="331" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Parametric Rectangles: A Model for Querying and Animation of Spatiotemporal Databases</title>
		<author>
			<persName><forename type="first">M</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Keshwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">Z</forename><surname>Revesz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the EDBT Conf</title>
		<meeting>of the EDBT Conf</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="430" to="444" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Parametric R-Tree: An Index Structure for Moving Objects</title>
		<author>
			<persName><forename type="first">M</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">Z</forename><surname>Revesz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the COMAD Conf</title>
		<meeting>of the COMAD Conf</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Text Messages Turn Towns into Giant Computer Game</title>
		<author>
			<persName><forename type="first">J</forename><surname>Elliott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sunday Times</title>
		<imprint>
			<date type="published" when="2001-04-29">April 29. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">An Efficient Algorithm for Determining the Convex Hull of a Finite Planar Set</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Graham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="132" to="133" />
			<date type="published" when="1972">1972</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Generalized Search Trees for Database Systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Naughton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pfeffer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the VLDB Conf</title>
		<meeting>of the VLDB Conf</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="562" to="573" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Hilbert R-tree: An Improved R-tree using Fractals</title>
		<author>
			<persName><forename type="first">I</forename><surname>Kamel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the VLDB Conf</title>
		<meeting>of the VLDB Conf</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="500" to="509" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The Ultimate Planar Convex Hull Algorithm?</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Kirkpatrick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Seidel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="287" to="299" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">On Indexing Mobile Objects</title>
		<author>
			<persName><forename type="first">G</forename><surname>Kollios</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gunopulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">J</forename><surname>Tsotras</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the PODS Conf</title>
		<meeting>of the PODS Conf</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="261" to="272" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">G</forename><surname>Kollios</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Indexing Animated Objects Using Spatiotemporal Access Methods. TimeCenter Tech. Rep. TR</title>
		<imprint>
			<biblScope unit="page">54</biblScope>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The Effect of Buffering on the Performance of R-Trees</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>Leutenegger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Lopez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the ICDE Conf</title>
		<meeting>of the ICDE Conf</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="164" to="171" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Capturing the Uncertainty of Moving-Object Representations</title>
		<author>
			<persName><forename type="first">D</forename><surname>Pfoser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Jensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the Proc. of the SSDBM Conf</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="111" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Novel Approaches in Query Processing for Moving Object Trajectories</title>
		<author>
			<persName><forename type="first">D</forename><surname>Pfoser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Theodoridis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Jensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the VLDB Conf</title>
		<meeting>of the VLDB Conf</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="395" to="406" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">STAR-Tree: An Efficient Self-Adjusting Index for Moving Objects</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Procopiuc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">K</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Har-Peled</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
	<note>Manuscript</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Games Find Home in Mobile Phones</title>
		<author>
			<persName><forename type="middle">E</forename><surname>Ch</surname></persName>
		</author>
		<author>
			<persName><surname>Ramirez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Detroit News</title>
		<imprint>
			<date type="published" when="2001-03-26">March 26. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">The Design and Analysis of Spatial Data Structures</title>
		<author>
			<persName><forename type="first">H</forename><surname>Samet</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Indexing the Positions of Continuously Moving Objects</title>
		<author>
			<persName><forename type="first">S</forename><surname>Šaltenis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>Leutenegger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Lopez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the ACM SIGMOD Conf</title>
		<meeting>of the ACM SIGMOD Conf</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="331" to="342" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A Quadtree Based Dynamic Attribute Indexing Method</title>
		<author>
			<persName><forename type="first">J</forename><surname>Tayeb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ö</forename><surname>Ulusoy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Wolfson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Computer Journal</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="185" to="200" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Moving Objects Databases: Issues and Solutions</title>
		<author>
			<persName><forename type="first">O</forename><surname>Wolfson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chamberlain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Jiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the SSDBM Conf</title>
		<meeting>of the SSDBM Conf</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="111" to="122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Updating and Querying Databases that Track Mobile Units. Distributed and Parallel Databases</title>
		<author>
			<persName><forename type="first">O</forename><surname>Wolfson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Sistla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chamberlain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yesha</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="257" to="387" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
