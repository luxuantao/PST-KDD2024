<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Semantic Structure Matching for Assessing Web-Service Similarity</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Yiqiao</forename><surname>Wang</surname></persName>
							<email>yiqiao@cs.ualberta.ca</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">University of Alberta</orgName>
								<address>
									<postCode>T6G 2E8</postCode>
									<settlement>Edmonton</settlement>
									<region>AB</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Eleni</forename><surname>Stroulia</surname></persName>
							<email>stroulia@cs.ualberta.ca</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">University of Alberta</orgName>
								<address>
									<postCode>T6G 2E8</postCode>
									<settlement>Edmonton</settlement>
									<region>AB</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Semantic Structure Matching for Assessing Web-Service Similarity</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">1A57ECDCCE8FA7A58E0D284C58FA6C32</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T06:18+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The web-services stack of standards is designed to support the reuse and interoperation of software components on the web. A critical step in the process of developing applications based on web services is service discovery, i.e., the identification of existing web services that can potentially be used in the context of a new web application. UDDI, the standard API for publishing webservices specifications, provides a simple browsing-by-business-category mechanism for developers to review and select published services. To support programmatic service discovery, we have developed a suite of methods that utilizes both the semantics of the identifiers of WSDL descriptions and the structure of their operations, messages and data types to assess the similarity of two WSDL files. Given only a textual description of the desired service, a semantic information-retrieval method can be used to identify and order the most similar service-description files. This step assesses the similarity of the provided description of the desired service with the available services. If a (potentially partial) specification of the desired service behavior is also available, this set of likely candidates can be further refined by a semantic structure-matching step assessing the structural similarity of the desired vs. the retrieved services and the semantic similarity of their identifier. In this paper, we describe and experimentally evaluate our suite of service-similarity assessment methods.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The development of web-based applications in the service-oriented architecture style, as implied by the web-services stack of standards, relies on a set of related specifications, defining how reusable components should be specified (through the Web-Service Description Language -WSDL <ref type="bibr" target="#b13">[15]</ref>), how they should be advertised so that they can be discovered and reused (through the Universal Description, Discovery, and Integration API -UDDI <ref type="bibr">[12]</ref>), and how they should be invoked at run time (through the Simple Object Access Protocol API -SOAP <ref type="bibr" target="#b10">[11]</ref>). A critical step in the process of reusing existing WSDL-specified components for building web-based applications is the discovery of potentially relevant components. UDDI servers are essentially catalogs of published WSDL specifications of reusable components. These catalogs are organized according to categories of business activities. Service providers advertise services by adding their WSDL specifications to the appropriate UDDI directory category. Through a well-defined API, software developers can browse the UDDI catalog by category. This category-based service-discovery method is clearly insufficient. It is quite informal and relies, to a great extent, on the shared common-sense understanding of the domain by publishers and consumers. It is the responsibility of the provider developer to publish the services in the appropriate UDDI category. The consumer developer must, in turn, browse the "right" category to discover the potentially relevant services. More importantly, this discovery process does not provide any support for selecting among competing alternative services that could potentially be reused; prioritization of the candidates is again the responsibility of the consumer.</p><p>In this paper, we discuss a set of WSDL similarity-assessment methods, which can be used, in conjunction with the current UDDI API, to support a more automated service-discovery process, by distinguishing among the potentially useful and the likely irrelevant services and by ordering the candidates in the first category according to their relevance to the task at hand. This method utilizes both the semantics of the identifiers of WSDL descriptions and the structures of their operations, messages and types to assess the similarity of two WSDL files. Given only a textual description of the desired service, a semantic information-retrieval method can be used to identify and order the most similar service-description files. This step assesses the similarity of the provided desired-service description, extended to include semantically similar words according to wordNet <ref type="bibr">[16]</ref>, with the available services. If a (potentially partial) specification of the desired service behavior is also available, this set of likely candidates can be further refined by a semantic structurematching step assessing the structure and semantic similarity of the desired vs. the retrieved services.</p><p>The intuition underlying this method is that a plausible means of querying UDDI servers is "query by example", i.e., by providing a (potentially partial) specification of the desired service. The consumer developer may define various aspects of the desired service, such as descriptions in natural language, the namespaces of its data types and the input/output parameters of its operations, and the proposed method will return a set of candidate services with an estimate of their similarity to the provided example.</p><p>The remainder of the paper is organized as follows: section 2 discusses related work; section 3 explains in detail the design and implementation of our approach; section 4 discusses the results of our experimentation; section 5 outlines our plans for future work and concludes with a summary of our results to date.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Research</head><p>The problem of service discovery is similar to the well-studied problems of component retrieval and information retrieval. On one hand, a WSDL specification is the description of a "software component" including a description of its interface and a description of where the actual implementation exists and how it can be used. On the other, a WSDL specification usually includes a set of natural-language description of the service itself and comments on its elements. Thus, we looked at both these research areas for applicable results to the service-discovery and similarityassessment problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Component retrieval</head><p>In general, there are two categories of methods for component discovery: signature matching <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b15">18]</ref> and specification matching <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b16">19]</ref>.</p><p>Polylith <ref type="bibr" target="#b7">[8]</ref> proposed one of the earliest signature-matching methods for interface adaptation and interoperation. Through its NIMBLE language, coercion rules could be specified so that the parameters of the invoking module could be matched to the signature of the invoked module, including reordering, type mapping and parameter elimination. Zaremski and Wing <ref type="bibr" target="#b15">[18]</ref> described exact and relaxed signature matching as a means for retrieving functions and modules from a software library.</p><p>Signature matching is an efficient means for component retrieval, for several reasons. Function signatures can be automatically generated from the function code. Furthermore, signature matching efficiently prunes down the functions and/or modules that do not match the query, so that more expensive and precise techniques can be used on the smaller set of remaining candidate components. However, signature matching considers only function types and ignores their behaviors; and two functions with the same signature can have completely opposite behaviors. Specification matching aims at addressing this problem by comparing software components based on formal descriptions of the semantics of their behaviors. However, because these specifications are developed independently from the module code, there is no guarantee that they correctly and completely reflect the component's behavior. Moreover, it is hard to motivate programmers to provide a formal specification for each component they write.</p><p>Zaremski and Wing <ref type="bibr" target="#b16">[19]</ref> extended their signature-matching work with a specification-matching scheme.</p><p>WSDL <ref type="bibr" target="#b13">[15]</ref>, the Web-Services Definition Language, is an XML-based interfacedefinition language. It describes "services" as a set of operations implemented by a set of messages involving a given set of data types at a high level of abstraction. WSDL specifications of service-providing components are published in UDDI registries. <ref type="bibr">UDDI [12]</ref> is designed as an online marketplace providing a standardized format for general business discovery. Developers can browse and query a UDDI registry using the UDDI API to identify businesses that offer services in a particular business category and/or services that are provided by a certain service provider.</p><p>WSDL service specifications do not include semantics. On the other hand, DAML-S <ref type="bibr" target="#b1">[2]</ref> is a formal logic-based language that supports the specification of semantic information in RDF format. As part of the "semantic web" effort, it is intended as the means for specifying domain-specific semantics of ontologies. An extension of DAML-S supports service specification, including behavioral specifications of their operations; as a result, it enables discovery through specification matching, such as the method proposed in LARKS <ref type="bibr" target="#b3">[4]</ref>. If indeed services were specified in DAML-S instead of WSDL it would be possible to formally prove that the requirements of the desired service and a discovered service do not conflict. However, there is no widespread adoption yet of DAML and DAML-S, and the high cost of formally defining of provided and required services makes this adoption unlikely. This is the underlying motivation for this research: to provide some lightweight semantic comparison of syntactic specifications in WSDL, based on the syntactic structure of the specifications and the natural-language semantics of their identifiers, comments and descriptions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Information retrieval</head><p>Traditional information-retrieval methods rely on textual descriptions of artifacts to assess their similarity and organize them in clusters or retrieve them in a "query-byexample" mode <ref type="bibr" target="#b2">[3]</ref>. According to the vector-space model, documents and queries are represented as t-dimensional vectors, where t is the number of distinct words in the document; similarity assessment then becomes equivalent to vector-distance calculation.</p><p>WordNet [16] is a lexical database, inspired by current psycholinguistic theories of human lexical memory. English nouns, verbs, adjectives and adverbs are organized into synonym sets, each representing one underlying lexical concept. Relationships between conceptions such as hyponym and hypernym relations are represented as semantic pointers linking between related concepts <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref>. WordNet has been used in numerous natural language processing applications, hoping to ameliorate traditional information-retrieval results <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b11">13]</ref> with limited success.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">The Web-service Discovery Method</head><p>Our service-discovery method is aimed at enabling programmatic service discovery and integrates information-and component-retrieval ideas. The method assumes as input a (potentially partial) specification of the desired WSDL specification and a set of WSDL specifications of available services, such as the services advertised in UDDI. First, a traditional vector-space model information-retrieval step, enhanced with WordNet, retrieves the most similar services according to their WSDL service descriptions specified in natural language. Given the retrieved list of candidate services, a structure-matching algorithm, extended by a second WordNet method that calculates semantic distances between identifiers of WSDLs, further refines and assesses the quality of the candidate service set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">WordNet-Powered Vector-Space Model Information Retrieval</head><p>In traditional vector-space model, documents and queries are represented as Tdimensional vectors, where T is the total number of distinct words in the document collection after the preprocessing step. Preprocessing includes eliminating stop words (very commonly used words) and conflating related words to a common word stem. Each term in the vector is assigned a weight that reflects the importance of a word in the document. This value is proportional to the frequency a word appears in a document and inversely proportional to number of documents in which this word appears <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b11">13]</ref>. A common term importance indicator is tf-idf weighting the importance of a word i in document j is as follows:</p><formula xml:id="formula_0">w ij = tf ij idf i = tf ij log 2 (N/df i )<label>(1)</label></formula><p>In the above formula, tf ij is the normalized term frequency across the entire document collection, and idf i is the inverse document frequency of term i. N is total number of documents in the collection, and Log is used to dampen the effect relative to tf. The WordNet-powered vector-space model extension involves the maintenance of three sub-vectors for each document and query: stems of original words in a document, stems of words' synonyms for all word senses, and stems of words' direct hypernyms, hyponyms and siblings for all word senses. All document terms' word senses are included, and therefore we bypass the problem of lacking effective automated word sense disambiguation techniques, frequently discussed in the literature.</p><p>The WSDL syntax allows textual descriptions for services, their types and operations, grouped under &lt;documentation&gt; tags. Given a natural language description of the desired service, we employ the WordNet-powered vector space model to retrieve published WSDL services that are most similar to the input description on the respective vectors. Corresponding sub-vectors from documents and queries are matched and we obtain three similarity scores accordingly. Different weights are assigned to sub-vector matching scores: matching scores of original word stems (first sub-vectors) are assigned twice the weight assigned to matching scores of synonyms (second sub-vectors), hypernyms, hyponyms, and siblings (third subvectors). A higher overall score indicates a closer similarity between the source and target specifications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">WSDL Structure Matching</head><p>A straight-forward extension of the signature-matching method to WSDL specifications involves the comparison of the operations' set offered by the services, which is based on the comparison of the structures of the operations' input and output messages, which, in turn, is based on the comparison of the data types of the objects communicated by these messages.</p><p>The overall process starts by comparing the data types involved in the two WSDL specifications. The result of this step is a matrix assessing the matching scores, i.e., the degree of similarity, of all pair-wise combinations of source and target data types. It is interesting to note here that the data types of web services specified in WSDL are XML elements; as such, they can potentially be highly complex structures.</p><p>The next step in the process is the matching of the service messages. The result of this step is a matrix assessing the matching scores of all pair-wise combinations of source and target messages. The degree to which two messages are similar is decided on the basis of how similar their parameter lists are, in terms of the data types they contain and their organization.</p><p>The third step of the process is the matching of the service operations. The result of this step is a matrix assessing the matching score of all pair-wise combinations of source and target operations. The degree to which two operations are similar is decided on the basis of how similar their input and output messages are, which has already been assessed in the previous level.</p><p>Finally, the overall score of how well the two services match is computed by identifying the pair-wise correspondence of their operations that maximizes the sum total of the matching scores of the individual pairs. After all target WSDL specifications have been matched against the source WSDL specification, they are ordered according to their "overall matching scores": a higher score indicates a closer similarity between the source and target specifications. For each target specification, the algorithm also returns the mapping of its data types and operations to the corresponding data types and operations of the source specification as an "explanation" of its assigned match score. This algorithm is described in detail in <ref type="bibr" target="#b12">[14]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Semantic WSDL Structure Matching</head><p>The WSDL structure-matching algorithm of section 3.2 aims at optimizing the mapping of the corresponding service structures. The semantic WSDL structurematching algorithm is an extension to it: it also tries to find an optimal mapping between source and target service components based both on the similarity of their syntactic structures and also the semantic similarity between the identifiers of data types, operations and services to assess service similarities. The intuition behind it is that the chosen names of the types, operations, and services usually reflect the semantics of the underlying capabilities of the service.</p><p>The identifier-matching process is similar to that of the original WSDL structure matching. It starts by comparing the names of the data types (identifiers) involved in the two WSDL specifications. The result of this step is a matrix assessing the matching scores of all pair-wise combinations of source and target data-types. The next step in the process is the matching of the service operations. The result of this step is a matrix assessing the matching scores of all pair-wise combinations of source and target operations. The degree to which two operations are similar is decided on the semantic distance between operations' names and how similar their parameter lists are, in terms of the identifiers they contain. Finally, the overall score for how well the two services match is computed by matching the services' names and by identifying the pair-wise correspondence of their operations that maximizes the sum total of the matching scores of the individual pairs. Figure <ref type="figure" target="#fig_0">1</ref> lists the algorithm matchDocumentTerms that explains the WordNetbased "cost structure" for assessing the similarity of two identifiers. If two words are identical or synonymous (regardless of words' senses), they are assigned a maximum score of 10 and 8 respectively. Otherwise, if two words are in a hierarchical semantic relation, i.e. they are hypernyms, hyponyms or siblings to each other we count the number of semantic links between these words along their shortest path in WordNet hierarchy. The identifier-similarity score between two such terms is calculated by dividing 6 by the number of links found between them. Thus, the term-similarity score is a function of the terms' semantic distance in the WordNet hierarchy: terms that are farther away from each other have smaller similarity scores than terms that are located closer to each other in WordNet. Similar to the WordNet-based information-retrieval step, word senses are not disambiguated.  In the end, the semantic structure-matching score between a web service S and a query service Q, Sim semantic-structure-matching (S,Q), is a function of its structure matching score and its identifier matching score as follows:</p><p>Sim semantic-structure-matching (S,Q) = Sim structure-matching (S,Q) + Sim identifier-matching (S,Q)</p><p>In the above formula, Sim structure-matching (S,Q) and Sim identifier-matching (S,Q) are similarity scores calculated by the structure matching and the identifier matching method respectively. We assume that programmers follow Java-style naming conventions and use meaningful names for methods and data types. Under this assumption, all identifiers and names are broken into tokens by identifying delimiter characters such as underscores and capital letters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Evaluation</head><p>To evaluate our service-discovery method as a whole and the effectiveness of its constituent elements, we had to obtain families of related specifications in order to evaluate the degree to which our algorithm can distinguish among them. We found such a collection published by XMethods <ref type="bibr" target="#b14">[17]</ref>. The XMethods collection provided us with nineteen service descriptions from five categories: currency rate converter (three services), email address verifier (three services), stock quote finder (four services), weather information finder (four services), and DNA information searcher (five services).</p><p>In this section, we report on four sets of experiments: service discovery with WordNet-powered vector space model, discovery with structure matching, discovery with semantic structure matching, and discovery with WordNet-powered vector space model combined with semantic structure matching.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Currency: Currencyws</head><formula xml:id="formula_2">Stock: MBSoapService (2)</formula><p>The similarity score between a given web service S and service requests from a given category C is the average of the similarity scores calculated between S and each request from category C. The candidate web services are ranked according to their similarity to the requests and the top 50% of services in the list are returned. We assume that if a web service ranks in the second half of the list, chances are that this web service is irrelevant to the request. Table <ref type="table">1</ref> summarizes the results of this experiment.</p><p>We evaluate the effectiveness of our retrieval methods by calculating their precision and recall. "Precision is the proportion of retrieved documents that are relevant, and recall is the proportion of relevant documents that are retrieved" <ref type="bibr" target="#b11">[13]</ref>. Average precision and recall for each test collection from each category of service requests are calculated and are listed in the first column of Table <ref type="table">1</ref>. Retrieved matching service advertisements are listed in column 2 of Table <ref type="table">1</ref>. They are sorted according to their similarity to requests from a given category. The WordNet-powered vector space model achieves a precision of 41.8% at 100% recall on average on this set of experiments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Structure Matching</head><p>Experiments with structure matching were conducted in a similar manner: we matched the structure of each service from each category (requests) against the structures of all other services from all categories (candidates). Averages are calculated between service requests from each category and all candidate services. The candidate web services are ranked according to their similarity scores to the requests, and the top 70% of the list are returned. The results of this set of experiments are listed in Table <ref type="table" target="#tab_1">2</ref>. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Matching Document Terms Using WordNet.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 .</head><label>2</label><figDesc>Structure Matching on the XMethods Collection</figDesc><table><row><cell>Requests Currency rate converter Precision: 14% Recall: 67% DNA info Searcher Precision: 36%</cell><cell>Retrieved Matching Advertisements (Category: service name) Email: AdvancedemailcheckService Stock: StockQuote1 DNA: TxSearch, Blast, Fasta Stock: MBSoapService(1) Stock: MBSoapService (2) DNA: ClustalW, SRS Stock: StockQuote2 Email: ValidateEmail Currency: Currencyws Weather: USWeather Currency: pwspNoCentrebankCurRates DNA: Fasta Stock: MBSoapService(1) Stock: MBSoapService (2) DNA: Blast</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>The authors wish to thank Tu Hoang for his help in developing parts of these algorithms. This research was supported by an IRIS grant.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">WordNet-Powered Vector-Space Model</head><p>In this experiment, we matched service descriptions specified in natural language of each service from each category (requests) against the text descriptions of all other services from all categories (candidates). Average precision and recall are calculated for each set of queries, and on average, structure matching achieves a precision of 20% at 72% recall. Both precision and recall are considerably poor in this set of experiments because some related services have substantially different structures and some irrelevant services can often have higher matching scores because they have many spurious substructures that happen to match the query structure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Semantic Structure Matching</head><p>In this experiment, we matched the services' structures and their chosen identifiers. The experiments were conducted in a similar manner as the experiments of sections 4.1 and 4.2 described above. Web services are ranked according to their similarity scores to the requests, and top 50% of web services on the lists are considered to be relevant to the requests and are returned to the users. The results of this set of experiments are listed in Table <ref type="table">3</ref>.</p><p>Semantic structure matching method achieves a precision of 35.2% at 81.8% recall on average. Please note that compare to performance of pure structure matching method, precision is improved by 15.2% from 20% and recalled is improved by 9.8% from 72%. Based on this experiment, we can infer that considering the implicit semantics of the WSDL identifiers is, in fact, enabling a more precise service matching. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">WordNet-Powered Vector-Space Model and Semantic Structure Matching</head><p>Looking at the services retrieved with each query in the various experiments, we noticed that each method "picks" different types of similarity, which led us to hypothesize that their combination might be more effective than the best one of them.</p><p>To investigate this hypothesis we conducted a fourth set of experiments where WordNet-powered vector space model and semantic structure matching method are combined. The WordNet-powered vector-space model was first used on all services as described in section 4.1 to obtain relevant web services compared to the query (top 50% of the services in the ranked list). Then, semantic structure matching was applied to the pruned list of candidates as described in section 4.3. The candidate services were matched and re-ranked, and the top 50% of the services in the list were returned. Therefore, after the two-step matching and refining, only the top 25% of all web services are returned as relevant services. The results of these experiments are shown in Table <ref type="table">4</ref>. On average, this retrieval method that uses both the WordNet-powered vector space model and the semantic structure matching achieves a precision of 72% at 95% recall. Compared to the performance of WordNet-powered vector space model, precision is increased by 30.2% from 41.8% and recall dropped by 5% from 100%. Both precision and recall improved significantly compared to the results obtained by semantic structure matching method alone.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusions and Future Work</head><p>In this paper, we described a web-service discovery method that combines two WordNet-based techniques with a structure-matching algorithm leveraging the structure of the XML-based service specification in WSDL. Currently developers can only browse UDDI registries and query the advertised services by business category. This is a very blunt and imprecise service-discovery mechanism.</p><p>Our web-service discovery method is inspired by traditional information retrieval methods, signature matching methods and many experiments conducted with WordNet for component retrieval. It is designed to calculate semantic and structural similarity between a desired service and a set of advertised services. WordNet-based methods do not attempt to resolve word senses; this problem has been proven difficult by current research, but fortunately it does not apply in the case of the WSDL descriptions, comments and identifiers, which are not likely to be complete grammatical sentences. WordNet is used as a "query expansion" mechanism: it includes semantically similar words retrieved from WordNet database for all documents and queries to ameliorate information retrieval results. The structurematching algorithm respects the structural information of data types and is flexible enough to allow relaxed matching and matching between parameters that come in different orders in parameter lists. Our web service discovery method that combines WordNet-powered vector space model with semantic structure matching constitutes an important extension to the UDDI API, because it enables a substantially more precise service-discovery process.</p><p>We have conducted various experiments to evaluate the effectiveness of our retrieval system with very positive results. In the future, we plan to extend this algorithm to exploit the full WSDL syntax. Currently, we are not considering some of the syntax WSDL offers such as minOccurs, maxOccurs that indicate minimum and maximum occurrences of data types, and some other attributes of element tags. We also plan to experiment with larger sets of web services.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A protocol-based approach to specifying interoperability between objects</title>
		<author>
			<persName><forename type="first">I</forename><surname>Cho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mcgregor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Krause</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th Technology of Object-Oriented Languages and Systems (TOOLS&apos;26)</title>
		<meeting>the 26th Technology of Object-Oriented Languages and Systems (TOOLS&apos;26)<address><addrLine>Santa Barbara, CA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="1998-08">August 1998</date>
			<biblScope unit="page" from="84" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="http://www.daml.org/" />
		<title level="m">The DARPA Agent Markup Language Homepage</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">A survey of Information Retrieval and Filtering Methods, University of Maryland</title>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">W</forename><surname>Oard</surname></persName>
		</author>
		<idno>CS-TR-3514</idno>
		<imprint>
			<date type="published" when="1995-08">August 1995</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">LARKS: Dynamic Matchmaking Among Heterogeneous Software Agents in Cyberspace</title>
		<author>
			<persName><forename type="first">K</forename><surname>Sycara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Widoff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Klusch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Autonomous Agents and Multi-Agent Systems</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="173" to="203" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Introduction to WordNet: An On-line Lexical Database</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">A</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Beckwith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Felbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Lexicography</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="235" to="244" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Nouns in WordNet: A Lexical Inheritance System</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">A</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Lexicography</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="245" to="264" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The Use of WordNet in Information Retrieval</title>
		<author>
			<persName><forename type="first">R</forename><surname>Mandala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Takenobu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Hozumi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the COLING/ACL Workshop on Usage of WordNet in Natural Language Processing Systems</title>
		<meeting>the COLING/ACL Workshop on Usage of WordNet in Natural Language Processing Systems<address><addrLine>Montreal</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="31" to="37" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Module Reuse by Interface Adaptation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Purtilo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Atlee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software Practice and Experience</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="539" to="556" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Using WordNet in a knowledge-based approach to information retrieval</title>
		<author>
			<persName><forename type="first">R</forename><surname>Richardson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">F</forename><surname>Smeaton</surname></persName>
		</author>
		<idno>CA-0395</idno>
		<imprint/>
		<respStmt>
			<orgName>Dublin City University School of Computer Applications Working Paper</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A vector-space model for information retrieval</title>
		<author>
			<persName><forename type="first">G</forename><surname>Salton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the American Society for Information Science</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="13" to="620" />
			<date type="published" when="1975-11">November 1975</date>
			<publisher>ACM Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title/>
		<ptr target="http://www.w3.org/TR/2003/REC-soap12-part0-20030624/" />
	</analytic>
	<monogr>
		<title level="j">Simple Object Access Protocol</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">WordNet: An Electronic Lexical Database</title>
		<author>
			<persName><forename type="first">E</forename><surname>Voorhees</surname></persName>
		</author>
		<editor>C.Fellbaum</editor>
		<imprint>
			<date type="published" when="1998">1998. 1999</date>
			<publisher>The MIT Press</publisher>
			<biblScope unit="page" from="285" to="303" />
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
	</monogr>
	<note>Using WordNet for Text Retrieval</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Flexible Interface Matching for Web-Service Discovery</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Stroulia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 4th International Conference on Web Information Systems Engineering</title>
		<meeting>4th International Conference on Web Information Systems Engineering</meeting>
		<imprint>
			<date type="published" when="2003">December 10th -12th, 2003</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<ptr target="http://www.w3.org/TR/wsdl" />
		<title level="m">Web Services Description Language (WSDL) (WSDL)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<ptr target="http://www.xmethods.com/" />
		<title level="m">XMethods homepage</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Signature Matching: a Tool for Using Software Libraries</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Zaremski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Wing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Software Engineering and Methodology</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="146" to="170" />
			<date type="published" when="1995-04">Apr. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Specifications Matching of Software Components</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Zaremski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Wing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Software Engineering and Methodology</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="333" to="369" />
			<date type="published" when="1997-10">Oct. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
