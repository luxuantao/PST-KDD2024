<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Physically Based Approach to 2-D Shape Blending</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Thomas</forename><forename type="middle">W</forename><surname>Sederberg</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Brigham Young University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Eugene</forename><surname>Greenwood</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Brigham Young University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">A Physically Based Approach to 2-D Shape Blending</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">A97834C8A00B93C412510C476CED4ABF</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T09:34+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>1.3.3 [Computer Graphics]: Picture/Image Generation; 1.3.5 [Computer Graphics]: Computational Geometry and Object Modeling Computer graphics</term>
					<term>shape blending</term>
					<term>animation</term>
					<term>physically based algorithms</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper presents a new afgorithm for smoothly blending between two 2-D polygonal shapes. The algorithm is based on a physical model wherein one of the shapes is considered to be constructed of wire, and a solution is found whereby the first shape can be bent and/or stretched into the second shape with a minimum amount of work. The resulting solution tends to associate regions on the two shapes which look alike. If the two polYgons have m and n vertices respectively, the afgorithm is O(mn). The algorithm avoids local shape inversions in whkh intermediate polygons self-intersect, if such a solution exists.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The topic of this paper is illustrated in Figures This operation is known variously as shape averaging, shape interpolation, metamorphosis, shape evolving, and shape blending. It has widespread application in illustration, animation, and industrial design. 2-D shape blending is an increasingly popular feature in man ~;~;;;ial illustration software packages (such as <ref type="bibr">[1]</ref>, <ref type="bibr">[6]</ref>, [7% Figure <ref type="figure">3</ref>: Shape blend example Solutions to the 3-D shape interpolation problem have also been proposed <ref type="bibr">([4]</ref>, [1o], <ref type="bibr">[14]</ref>). Indeed, the research effort reported in this paper initially focused on the 3-D problem. However, the authors soon realized that even the 2-D problem had many open questions, such a how can a shape blend algorithm avoid chaotic intermediate shapes and how can an ] Engineering Computer Graphics Laboratory 368 Clyde Building Brigham Young University Provo, UT 84602 algorithm recognize similar, t bough not identical, features on the two terminal shapes (such as the feet and head of the chicken in Figure <ref type="figure">1</ref>) and maintain those features throughout the blend. We tested several commercial shape blending software packages on some of our shape examples. The best of any results for the chicken outline is shown in Figure <ref type="figure">4</ref> and the best E to F blend is shown in Figure <ref type="figure">5</ref>. Notice how the chicken feet in Figure <ref type="figure">4</ref> degenerate to a self-intersecting scribble.</p><p>Figure <ref type="figure">4</ref>: Shape blend of chicken using commercial software</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>EEFFFF</head><p>Figure <ref type="figure">5</ref>: Shape blend of E to F using commercial software</p><p>The algorithm presented in this paper is baaed on a physical model. Imagining that each shape is made of a piece of wire, the blend is determined by computing the minimum work required to bend and stretch one wire shape into the other. The user can specify some physical properties of the wire, which control the relative difficulty with which it can be bent or stretched. A severe penalty is charged for blends which experience a local self intersection due to the wire bending through an angle of zero degrees. This penalty nearly always prevents the self intersection problem in Figure <ref type="figure">4</ref>. AU of the blends in this paper were generated automatically with no user intervention (Figures 4 and 5 by commercial packages, the rest by our algorithm) except for initially specifying the physical attributes of the wire.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1.1</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related work</head><p>Shape blending is a problem which has been motivated by several different applications and attacked in several different ways. For example, if we envision the family of blend polygons aa formin a ruled surface in (z, y, t) space, as shown in f Figure <ref type="figure">6</ref> These approaches give impressive results, but leave some room for further investigation.</p><p>For example, two non-convex objects Figure <ref type="figure">6</ref>: Family of blend polygons as a function oft with similar features (such aa a dog and a horse) will lose protruding detaUs such as legs during intermediate shapes.</p><p>In fact, the blend of a non-convex object with itself is not a constant shape.</p><p>Problems related to 2-D shape blending arise in shape recognition [2], [19] and curve matching for graphical search L and replace [16 . In these applications, the primary concern is determining ow similar two complete objects are. Shape blending also resembles the computer vision problem of contour identification, for which one solution is based on energy minimization</p><p>[13], as is the shape blendhg algorithm described herein.</p><p>When the two shapes to be blended are taken to be key frames in a character animation (such as in Figure <ref type="figure">1</ref>) shape blending is similar to inbetweening -an important component of the general problem of computer-assisted animation [3). The problem addressed in this paper, inbetweening of poly onal shape outlines, is simpler than the more general f prob em of inbetweening complete drawings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1.2</head><p>Overview Section 2 discusses geometric aspects of the shape blending problem. The physical work model is discussed in section 3. The minimum work solution is found by means of a directed graph, as discussed in section 4. Section 5 presents several examples and discusses the relative influence of stretching and bending work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Geometric preliminaries</head><p>Given  Different blends can be achieved if we insert new vertices in each polygon. In Figure <ref type="figure">10</ref>, a vertex labeled "5" is inserted in PO and a vertex labeled "I" is inserted in P1 as shown. Another variation is obtained by adding two new vertices at the same point. In Figure <ref type="figure">11</ref>, vertices labeled "5" and "6" are inserted in P. and vertices labeled "1" and "2" are inserted in PI as shown.</p><p>Typically, two polygons to be blended do not initially have the same number of vertices, and even if they do, the correspondence will not generally produce a pleasing blend. The examples in Figures 8-11 suggest that the principle task in shape blending is that of adding vertices to each polygon such that each polygon ends up with the same number of vertices, and the resulting vertex correspondences produce the desired blend.</p><p>So, how can an algorithm automatically decide, with little or no human intervention, where to add the vertices? Section 2.] shows two geometric conditions that an algorithm can identify and try to avoid, and section 3 discusses a physical model which can further guide an algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Angles</head><p>Consider the solution to the step problem shown in Figure <ref type="figure" target="#fig_0">12</ref>.</p><p>This blend serves little useful purpose (except to illustrate shape blending gone awry), because the angle at the circled vertex goes to zero, so that the two edges meeting at that izllixY211 po pl vertex pass over one another. When this happens, at least part of the sha~e is turnin~itself "inside out".</p><p>Another ex;mple of ii-behaved intermediate angles is shown in Figure <ref type="figure">13</ref>. Here, the terminaf angles at vertices 4 and 6 are both 90°, yet those angles in the intermediate blends exceed 130°. Also, vertex 5 begins and ends on a straight line, yet that line becomes noticeably bent during the blend operation.</p><p>Figures <ref type="figure" target="#fig_0">12</ref> and<ref type="figure">13</ref> suggest two angle constraints that should be imposed on blend solutions.</p><p>First, if at all possible we should avoid Oi</p><formula xml:id="formula_0">(t) = O O&lt;t&lt;l (3)</formula><p>at each vertex, since that implies that an intermediate shape is self-intersecting. Second, it seems preferable, when possible, for each intermediate angle to be bounded by its terminaf angles. That is, @i(i!) should change monotonically from @i(0) t08:(l).</p><p>It happens that there is an unexpectedly simple representation for the angle Oi(t) which greatly aids the understanding and analysis of these two conditions. In the following, </p><formula xml:id="formula_1">PI . P2 COS(LP1,O, P2) = IIPIII llP~ll; PI x P2 tan(LPl, O,Pz) = P1. P2' (5) (F~(l -t)+ F;t) X (Bf(l -t) +B;t) tan(ei(~)) = (F~(~_ t) + Fit) . (B~(l -t) + '~t) Yo(l -t)2 +Y12t(l -t) + y# = (6) ~o(l -~)2 + ~lz~(l -t) +z2~2</formula><p>where (8) Equation 6 can be interpreted as a degree two B6zier curve</p><formula xml:id="formula_2">Q(t) = (Zo, yo)(l -t)2 + (ZI, ~I)2t(1 -t) + (Z2, y2)t2 = Qo(l -t)2+Q12t(1 -t)+ Q2i2. (<label>9</label></formula><formula xml:id="formula_3">)</formula><p>As illustrated in Figure <ref type="figure" target="#fig_5">14</ref> intersects the positive z axis (as shown in Figure <ref type="figure">15</ref>). Angle monotonicity is assured if no line through the origin \ intersects Q(t) more than once as shown in Figure <ref type="figure">16</ref>). The angle function Oi</p><formula xml:id="formula_4">(t) = L[( 1, O), O,O), Q(t)</formula><p>] haa four possible extrema: 01(0), di(l), Oi(tl), or i(t2) where tl and t2 satisfy the equation</p><formula xml:id="formula_5">(Q(t) -o) x Q'(t) = O.</formula><p>This produces a cubic polynomial which always degree reduces to a quadratic polynomial in Bernstein form:</p><formula xml:id="formula_6">d(t) = di)(l -t)z + d~2t(l -i) +d2t2 = o; (lo) 28 I 30°Y 0).."" . .0 L \ \ QI 290°' Q , P i i+ 1 Pi Pi ~! Pi+I Pi+, q(o) = 30°q(o.% = 5°4 ! 'j-1 b q-1 b %.1 q(o.5) = 337°~(0.75) = 311°~(l)= 290°F</formula><p>igure 15: Oi(t) goes to zero </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Coincident vertices</head><p>Coincident vertices are a common occurrence which invite special attention.</p><p>When n adjacent vertices on one polygon lie at the same point, n -1 edges on the other polygon collapse to that point. Since Z(Pi -1, Pi, Pi+l ) is undefined if Pi is coincident with either of its neighbors, the angle change when such a case is involved in a shape blend is also undefined, as is the bending work discussed in section 3.2. Our tests verify that the following heuristic for assessing angle change when vertices are coincident gives good results.</p><p>We imagine that coincident vertices actually lie evenly spaced along the base of an infinitesimal isosceles triangle, as shown in Figure <ref type="figure" target="#fig_2">19</ref>. In this case, 6'z = 194= 90°+ ~and f13= 180°in radians. In general, if vertices Pi, . . . . Pj are coinciderrt, Oi =81 =90°+ ~and(?i+l =f?i+2 = . =oj_I = 180°.</p><p>In Figure <ref type="figure" target="#fig_0">20</ref>, all three vertices of one polygon are coincident. However, as portrayed in Figure <ref type="figure" target="#fig_2">19</ref>, those vertices are treated as though they are infinitesimally spaced along a line segment. Thus, in such cases, control point Q2 (or Qo) of the Q curve will always be located an infinitesimal distance from the origin along the -z axis. Figure <ref type="figure" target="#fig_0">21</ref> shows the Q curve for vertex i = 2 in Figure <ref type="figure" target="#fig_0">20</ref>. In this case, Q2 lies an infinitesimal distance from the origin along a ray 110°from the +Z axis as shown, and A6' = 38°. Figure <ref type="figure" target="#fig_0">22</ref> shows an example of coincident vertices in which an inter mediate angle goes to zero. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>close-up</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Physically based model</head><p>Section 2 defined the shape blending problem to be one of deciding where to add vertices to two polygons so that intermediate polygons in the blend could be defined by interpolating corresponding vertices on the given polygons.</p><p>The decision on where to add vertices must be guided by some heuristic. The heuristic we propose is to model polygon PO M a piece of wire made of some idealized metal. The "best" shape blend is the one which requires the least work to deform PO into P1 through bending and stretching.</p><p>This section discusses a simplified model for aasessing the work involved in moving each vertex and line segment through the shape blend. Section 4 shows how to compute a globally optimal le~t work solution for all possible vertex correspondences.</p><p>We distinguish between work which causes bending, and work which causes stretching.</p><p>Stretching work is computed for each line segment (that is, each adjacent pair of vertices) whereas bending work is computed for each adjacent pair of line segments (that is, for each set of three adjacent vertices).  where 6 = L1 -Lo and cs is a user definable constant which cent rols the penalty for edges collapsing to points, The exponent 2 in equations 13 and 14 assumes the wire is linearly elastic, which is the case if the wire has not stretched very much. If excessive st retching occurs, less work is required to elongate the wire because it undergoes plastic deformation 30 <ref type="bibr">[12]</ref>. In this case, an exponent of 1 more closely expresses the work expended. Thus, we make one final modification to our stretching work equation: e. 'a = "(1 -c,)min(!o~;l~!cs max(Lo, L1)' ( <ref type="formula">15</ref>)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Stretching</head><p>where k~, c~, and e, are user definable constants.</p><p>In physical reality, these work equations only make sense if the wire is getting longer (Ll &gt; Lo), not if it is gettin shorter f" (Ll &lt; Lo). For our purposea, we compute both stretc mg and compressing work using equation 15.</p><p>Section 4 calls for notation which expresses which se ment f' of wire is being stretched.</p><p>Letting where il=iooril=io+ land jl=joorjl=jo+l.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Bending work</head><p>Analogous to the equation for stretching work developed in section 3.1, work which causes bending is defined in equation 18 for angle Z(P~O, P~l, P~2) bending into angle Z(P;O, P;, ,P}2): The constant kb indicates bending stiffness, mb penahzes angles which are not monotonic, eb is an exponent which plays a role similar to es, and pb penalizes angles from going to zero.</p><formula xml:id="formula_7">wb([if), ~()],[i~,~l], [lz,jz]) = (17) { kb(&amp;? + m@6'*)eb [ if<label>8</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Normalization</head><p>Notice that the work due to bending is independent of the size of the shapes. Thus, if the two shapes are scaled uniformly, the bending work computation does not change. However, the stretching work varies with the scale of the shapes. To make the constants k~and es independent of scale, it is a good idea to map each shape to a unit rectangle, scaling the same amount in z and y, so that the largest dimension of the bounding box is one. It is important to scale uniformly, or else the angles will change, along with the bending work computation.</p><p>It is noteworthy that uniform scaling of the shapes does affect the Q(t) curves, but not the bending work computation. If P1 is scaled by a constant c, then Q. is unchanged, Q1 is scaled by C, and Q2 is scaled by c*. This creates a different Q(t) curve, but the angle function L((O, 1), (O, O), Q(t))= @(t) does not change. One of the first papers written on contour triangulation, [15], employs a directed graph to compute an optimal triangulation between a pair of contour lines. [8] further refined the use of the directed graph for that problem. Our leaat work o Iution is primarily based on those two excellent papers. This section briefly reviews the use of directed raphs, giving only r enough detail to explain how the ideas in 8] are adapted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Numerical examples</head><p>Given two polygons PO = [P:, P~, ., ., P%] and P* = [P:, P;, . . . . P:],</p><p>all vertex correspondences can be represented in an m x n rectangular matrix, or "graph". The columns of the graph represent vertices on PO and the rows of the graph represent vertices on P 1. The point at which column i meets row j signifies a correspondence between P:</p><p>and P;.</p><p>Denote by <ref type="bibr">[i, j]</ref> a correspondence between P! and P}, which can be represented on the graph as a dot at the junction of column i and row j. A complete shape transformation requires every vertex in PO to correspond to it least one vertex in P1 and vice versa. Furthermore, we only allow [i, "] to be i a correspondence if [i -l,j], [i)j -1], or [i -I,j -1 is also a correspondence -else intermediate polygons in the shape transformation would split apart.</p><p>Given that [0, O] = [m, n is a correspondence, a complete solution can be represent eJ on the raph as a string of dots starting at [0, O] and ending T at [m, n , with each subsequent dot positioned one step East, South, or Southeast from the preceding dot. This is illustrated in Figure <ref type="figure" target="#fig_0">25</ref>, where the dots are connected by arrows. We will refer to such a sequence of dots as a path, denoted by W2 = k, ( . For example if k, = kb = .5, e, = eb = 1 and ~, = 0.5, ItTl = 1.91 and W2 = 1,96. However, if we change k, = 0.4 and kb = 0.6, then W1 = 2.16 and W2 = 1.88. So, if the wire stretches more easily than it bends, blend 2 uses less work.</p><formula xml:id="formula_8">;+ 1 + .414C, ) + kb[2(.393)eb + .785"].<label>414"</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Least work solution</head><p>This section presents a method for determining whereto insert vertices so that the shape transformation is accomplished with the least work.</p><p>This method determines a globally optimal least work SCE lution for all ~ossible correspondences of ezistina vertices, so vertices can only be inserted at existing vertices. As a preprocessing step, additional vertices can be added to break up long line segments. The reason the optimization search is restricted to existing vertices is that otherwise it becomes a non-linear constrained optimization problem whose solution is very expensive and whose global optimality is difficult to verify. By contrast, the discrete solution presented here can be solved in 0(~7zrr) time in the number of respective vertices, and global optimality is assured. {Co, cl, ,Ck). In Figure <ref type="figure" target="#fig_0">25</ref>, co = [0,0], C3 = [2,3], etc. Note that k is the number of vertices in each intermediate polygon in the blend, with max(rn, n) &lt; k &lt; m + n.</p><p>We do not allow a South step to be immediately followed by an East step, or an East step to be followed by a South step, because such a combination is more expensive than a single Southemt step, except possibly under unusual work co efficient.</p><p>The main re~on for this rule is to save some computation.</p><p>Thus, we may say that a path must travel in a Southeasterly direction, and make no 90°turns. Consider how to evaluate the bending and stretching work for the example in Figure <ref type="figure" target="#fig_0">25</ref>. Stretching work is computed for each pair of neighboring dots on the path (cl_ 1, c1), since each such pair of dots on the path represents two points on PO transforming to two points on P1 Bending work must be computed using three neighboring dots on the path (cl-1, cl, C{+l ), since an angle change involves three points on PO moving to three points on P1. The work equations in section 3 contain seven user definable constants: k~, kb, e8, eb, pb, mb, and Ca. k8 and kb can be restricted to the unit interval. Table <ref type="table">1</ref> shows the coefficients used by our algorithm to blend the figures in this paper. The meaning of diagonal deviation dd is discussed in section 5.2.</p><p>Figures 8-11 underscore the inherent ambiguity of the shape blending problem.</p><p>Without human guidance, no algorithm could discern which of these four solutions is ap propriate, since one can think of specific instances in which each of them might be preferred.</p><p>Note that for these shape pairs, parameter adjustment can achieve the different desired results. As mentioned, the only user intervention for the examples in this paper is the specification of starting points and of the seven constants.</p><p>However, it is easy to contrive examples where no set of seven constants will produce a prescribed blend (such ss in Figure <ref type="figure" target="#fig_0">26</ref>, which consists of a combination of Figures <ref type="figure">8</ref> and<ref type="figure">11</ref>). In some cases, it may be needful for the user to specify a few other correspondences as well.</p><p>0 F" lgure dd lk s h es eb Pb 'b Cs n  Figure <ref type="figure" target="#fig_13">27</ref> shows a blend from a cow to a deer. Notice that some of the antlers cross each other in the intermediate shapes.</p><p>A high value of pb prevents local self-intersections (angles going to zero) but not global self intersections.</p><p>Figure <ref type="figure" target="#fig_0">28</ref> involves excessive movement of the dancer's arm. Due to the linear motion between corresponding vertices, the arm shortens as it moves. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Preprocessing</head><p>The heuristic described in this paper relies on a reasonable initial distribution of polygon vertices. For example, Figure <ref type="figure" target="#fig_0">2</ref> requires additional vertices to be inserted along some of the straight segments of the F shape in order to provide a pleasing correspondence with the base of the E. Since the work equations are more realistic for distinct vertices than for coincident vertices, the algorithm tends to work best if the two polygons have roughly the same number of vertices. This tends to reduce the number of coincident vertices in the final solution, since there must be a minimum of Im-rzl coincident vertices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Speedups</head><p>We timed an example in which each polygon has 100 vertices, and the execution time on an IBM RS6000 Model 530 workstation is 8 seconds using unoptimized code. Using the simplified alorithm in section 4.1, the execution time is 3 seconds.</p><p>In most cases, the graph of the Ieaxt work solution has a path (see Figure <ref type="figure" target="#fig_0">25</ref>) which does not deviate very far from the diagonal of the graph. Recall that a polygon PO with m vertices and a polygon P] with n vertices create a graph with m columns and n rows. The amount which graph point c[i, j] deviates from the graph diagonal is  <ref type="table">1</ref>). Thus, instead of searching the entire rectangular graph, the Iesst work solution can generally be determined by visiting only those elements of the graph within a distance dd from the diagonal. The authors are currently looking at several follow-up problems. For example, to make this process useful for key frame animation and morphing, an interior preserving map is needed for interpolating raster images which are enclosed by the terminal polygons. We are currently studying how well Schwartz-Christoffel transformations solve this problem.</p><p>How do we deal with cases where a scene composed of m number of polygons blends into a scene composed of n polygons, perhaps including holes? Ideas from [5] may help decide.</p><p>What about using periodic B-splines instead of polygons? An easy answer is to simply polygonize ~he ,curves and. ap ply the current algorithm? but a more satwfymg answer M to develop energy minimization methods which work directly on the curves. The caJculus of variations may provide help here.</p><p>All the blends in this paper involve moving corresponding vertices along linear paths. This can create some undesirable effects, such as the withering arm in blend 4 of Figure <ref type="figure" target="#fig_0">28</ref>. Q curves are easily extended to express angle change and segment length when vertices travel along B6zier curves of any degree. Study is underway in identifying curved paths which relieve the withering arm problem.</p><p>The work model assumes that each wire has uniform stiffness. There may be merit to specifying that some portions of the wire are more stiff than others, suggesting a relative discouragement towards altering those portions. For example, in the cow-to-deer blend, it may be helpful to assign a smaller stiffness to the antlers than to the rest of the deer.</p><p>Of course, extending this algorithm to polygonal surfaces in 3-D is a worthwhile goal.</p><p>Applications to other fields such as pattern and signature recognition are also being studied.</p><p>More detail on the material in this paper can be found in <ref type="bibr">[II]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>FigureFigure 2 :</head><label>2</label><figDesc>Figure 1: Shape blend example</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>, the s ape blending problem bears strong similarity to the contour triangulation problem [5], [8], [9], [15]. This is the background from which we approached the problem, and our solution borrows graph theory concepts from [15] and [8]. The algorithms used in the commercial illustration software cited above probably resemble the triangulation algorithms in [5] and [9] since these are O(n) in time and memory, thus more suitable for PC applications than ones based on raph theory. [ The first paper on 3-D shape interpolation 4] was motivated by industrial design. It tackles the pro Iem by slicing the two 3-D shapes into contours, blendlng corresponding contours, then reconstructing the 3-D blended surface. More 7 recent solutions, [10] and [14 , are based on Minkowski sums.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 9 :</head><label>9</label><figDesc>Figure 7: Blending of three adjacent vertices</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure</head><label></label><figDesc>Figure 10: Simple example, solution 3</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 12 :Figure 13 :</head><label>1213</label><figDesc>Figure 12: Simple example, "solution" 5</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 14 :</head><label>14</label><figDesc>Figure 14: Relationship between Oi(t) and Q(t)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>FigureFigure 18 :</head><label>18</label><figDesc>Figure 16: Oi(t) is not monotonic</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure</head><label></label><figDesc>Figure 19: Treatment of coincident vertices</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>work A force F' will stretch an actual wire of length Lo [12] an arnouut .. -(12)where ,4 is the cross sectional area and E is the modulus of rlas/icity, a constant of the material (for example, E for steel '*,y'+'p~'i+'</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>required to map PiO-Pil to PjOjl,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>Figure 23: Work computation example, blend 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>Figure 24: Work computation example, blend 2 Figure 25: Graph representation of a shape transformation By selecting different coefficients ks, kb, es, eb, and cs, we can coerce either blend to have a smaller work requirement.For example if k, = kb = .5, e, = eb = 1 and ~, = 0.5, ItTl = 1.91 and W2 = 1,96. However, if we change k, = 0.4 and kb = 0.6, then W1 = 2.16 and W2 = 1.88. So, if the wire stretches more easily than it bends, blend 2 uses less work.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>For-large m = n, there are O (~) = O (~) legal paths. However, using a graph, the least work solution can be determined by visiting each junction only once (O(m2) and discussion</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 27 :</head><label>27</label><figDesc>Figure 27: Cow to deer</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure</head><label></label><figDesc>Figure 28: Dancer</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>j]~path ~n The cow-to-deer blend path (see Figure 27) is shown in Figure 29. Its diagonal deviation of .245 is the largest of any of the examples in this paper (see Table</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 29 :</head><label>29</label><figDesc>Figure 29: Cow to deer least work path; diagonal deviation</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>Peisheng Gao sketched several of the illustrations in the paper. Thanks to Andrew Glassner for motivating discussions and for the initial shapes in Figure <ref type="figure">3</ref>. Bruce Brereton provided valuable assistance in evaluating commercial illustration software that supports blending, This work was supported under NSF grant DMC-8657057, and under a grant from IBM.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>computation expense).</head><p>The basic strategy proceeds by considering polygon fragments consisting of vertices O, . . . . i of PO and vertices O, ..., j of PI. Denote these polygon fragments PO(i) and P1 (j). We wish to compute the minimum work required to transform PO(i) into P1 (j), according to the work equations in section 3. In gra h theory language, we want to r find the path which connects O, O] to <ref type="bibr">[i, j]</ref> using the minimum amount of work, denoted W'(i, j). This is easily accomplished using the simple observation that if we know the minimum work vrdues W(i -1, j), W(i, j -1), and W(i -1, j -1), then W(i, j) must equal one of those three predecessors plus the incremental work involved in connecting that predecessor with [i,j .</p><p>J o accomplish this, we must actually concern ourselves with three values of W(i, j), denoted by Wt (i, j), W\(i, j), and W+ (i, j), which indicate the minimum work required to trans-</p><p>respectively is the preceding dot on the path.</p><p>These three values are required because each bending work computation relies on three dots on the path. We thus proceed by sssign- </p><p>where wb [ii, jl], [;z, jz], [is, js]) = co for al &lt;0 or jl &lt;0. The v ue min(w+(m, n), W\(m, n), kk'T(m, fl)) is the global least work. This is of secondary interest~what we realiy want to know is what path results in this mmimum work. The path is determined by backtracking through the graph, a process discussed in <ref type="bibr">[8]</ref>. Actually, our backtrackhg is slightly more complicated because each graph node must keep track of three backpointers, one for each direction from which the node can be approached in the backtrack.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Implementation</head><p>There is no need to store more than two rows of W+ (i, j), WN (i, j), WT(i, j) information.</p><p>Once a complete row of work values has been computed, the previous row can be discarded.</p><p>The algorithm u stated goes to a lot of effort to assure that it has found a path of globally minimal work. In particular, the bending work costs much more to compute than does the stretching work, since each node in the graph can represent the middle vertex of seven different angle changes. A much more economical (three times faster!) implementation is possible, which no longer assures a global minimum work solution, but which provides virtually identical results to the rigorous algorithm dicussed above. The simplified al orithm $"" uses only one value of W (i, j) (instead of calculating t (t, j ), W\(i, j), and W+ (i, j)) as follows.</p><p>For purposes of discussion, if point [i, j] lies on a path, the preceding point on the path is indicated using the functions 1 ( west(i, j and north(i, j . If the preceding oint is directly [ West of i,j], then west i,j) = 1 and north i,j) = O. If the preceding point is straig t up from [i, j], then west(i, j) = O 32 and north (i, j) = 1. If the preceding point is North-West of [i, j], then west(i, j) = 1 and north(i, j) = 1. Define <ref type="formula">25</ref>) W~ <ref type="bibr">([i-l-west(i-l,j-l)</ref>, j-l-north(i-l,j-1)],</p><p>[i-l, j-l],</p><p>[i, j])</p><p>where W. is undefined for i = O, WI is undefined for j = O, and W2 is undefined for i = O or j = O. Then if wo ~wl, w2 : W(i, j) = wo; west(i, j) = 1; north(i, j) = O (26) if W1 ~WO,W2 : W(i, j) = w1; west(i, j) = O; north(i, j) = 1 (27) if W2 ~WO,W1 : W(i, j) = wz; west(i, j) = 1; north(i, j) = 1 (28)</p><p>The algorithm for computing the least work solution amounts to setting,W(O, O) = O and from equations 23 -28 computing W(I, j); t = 0,. ... m; j = 0,. ... n. W(m, n) is then the optimal total least work, and the north and west information can be used to backtrace the path which leads to this least work SOIUtion. We recommend using this simplified algorithm, because it is easier to implement, it runs three times faster than the theoretically precise algorithm, and the results are visually similar.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Starting points</head><p>The above discussion assumes that point P: corresponds to point Pi. A globally minimum work solution for any initial correspondence can be computed in O(mn inn) time (see <ref type="bibr">[8]</ref>). The example in Figure <ref type="figure">9</ref> shows a zero work solution which was found by considering all possible starting correspondences. All the other Figures in the paper had the initial correspondence specified.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Geometric Modeling jor Computer Vision</title>
		<author>
			<persName><forename type="first">G</forename><surname>Bruce</surname></persName>
		</author>
		<author>
			<persName><surname>Baumgart</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1974">1974</date>
			<publisher>Adobe Systems, Inc</publisher>
		</imprint>
		<respStmt>
			<orgName>Stanford University, Computer Science Department</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Phd thesis</note>
	<note>Adobe Illustrator 88</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The problems of computer-assisted animation</title>
		<author>
			<persName><forename type="first">Edwin</forename><surname>Catmull</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="348" to="353" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Conversion of comcdex contour tine definitions into DokzG nrd element m~saics</title>
		<author>
			<persName><forename type="first">Eric</forename><surname>Shenchang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">;</forename><surname>Parent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Henry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomss</forename><forename type="middle">W</forename><surname>Christiansen</surname></persName>
		</author>
		<author>
			<persName><surname>Sederberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics (Pro:. ~~G-GRAPH)</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="187" to="192" />
			<date type="published" when="1978">1989. 1978</date>
		</imprint>
	</monogr>
	<note>IEEE CG</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Computer Support Corporation. Arts &amp; Letters</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Optimal surface reconstruction from planar contours</title>
		<author>
			<persName><forename type="first">Henry</forename><surname>Fuchs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">M</forename><surname>Kedem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Uselton</surname></persName>
		</author>
		<imprint>
			<publisher>Comm</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A new general triangulation method for planar contours</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ganapathy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">G</forename><surname>Dennehy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics (Proc. SIGGRAPH)</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="69" to="75" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Glassner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
	<note type="report_type">Metamorphosis. preprint</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">A physically based approach to 2-d shape interpolation</title>
		<author>
			<persName><forename type="first">Eugene</forename><surname>Greenwood</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
		<respStmt>
			<orgName>Brigham Young University, Department of Mechanical Engineering</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Master&apos;s thesis</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">Archie</forename><surname>Higdon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Edward</forename><forename type="middle">H</forename><surname>Ohksen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">B</forename><surname>Stiles</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">A</forename><surname>Weese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">F</forename><surname>Riiey</surname></persName>
		</author>
		<title level="m">Mechanics of Materials</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>John Wiley &amp; Sons, Inc</publisher>
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Snakes: Active contour models</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Kass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Witkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Demetri</forename><surname>Terzopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal oj Computer Vision</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="321" to="331" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Solid-interpolating deformations: Construction and animation of PIPs</title>
		<author>
			<persName><forename type="first">Kaul</forename><surname>Nil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jarek</forename><surname>Rossignac</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m">Proc. Eurographics &apos;9I</title>
		<editor>
			<persName><forename type="first">F</forename><forename type="middle">H</forename><surname>Post</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><surname>Barth</surname></persName>
		</editor>
		<meeting>Eurographics &apos;9I</meeting>
		<imprint>
			<publisher>Elsevier Science Publishers B.V</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="493" to="505" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Approximating complex surfaces by triangulation of contour lines</title>
		<author>
			<persName><forename type="first">E</forename><surname>Keppel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM Journal of Research and Development</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="2" to="11" />
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Graphical search and replace</title>
		<author>
			<persName><forename type="first">David</forename><surname>Kurlander</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><forename type="middle">A</forename><surname>Bier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="113" to="120" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Automatic shape model acquisition using multiscale segment matching</title>
		<author>
			<persName><forename type="first">Inc</forename><surname>Micrografx</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">X</forename><surname>Richardson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 10th ICPR</title>
		<meeting>10th ICPR<address><addrLine>Sunnyvale, CA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="897" to="902" />
		</imprint>
	</monogr>
	<note>Harvard Graphics 3.0, 1991. Naonori Ueda and Satoshi Suzuki</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
