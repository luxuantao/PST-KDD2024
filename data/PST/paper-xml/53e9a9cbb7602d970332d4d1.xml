<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Macros for Context-Free Grammars</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Peter</forename><surname>Thiemann</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Institut für Informatik</orgName>
								<orgName type="institution">Universität Freiburg</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Matthias</forename><surname>Neubauer</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Institut für Informatik</orgName>
								<orgName type="institution">Universität Freiburg</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Macros for Context-Free Grammars</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">BD401BD0AFC3BA465D426E3F16BE0394</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:32+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Current parser generators are based on context-free grammars. Because such grammars lack abstraction facilities, the resulting specications are often not easy to read. Fischer's macro grammars provide the equivalent of procedural abstraction by extending context-free grammars with macrolike productions. Unfortunately, macro grammars generate context-sensitive languages, in general, so they do not have ecient parsers.</p><p>To enable the specication of a language using a macro grammar, we dene specialization for macro grammars. This specialization always yields context-free rules, but it does not always terminate. We present a sound and complete static analysis that decides whether specialization terminates for a given macro grammar and thus yields a (nite) context-free grammar. The analysis is based on an intuitive notion of self-embedding nonterminals, which is easy to check by hand and which gives the expected answer for all examples that we tried.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Current parser generators are based on context-free grammars because their word problem is solvable in cubic time in the worst case or in linear time for deterministic grammars like LL-or LR-grammars <ref type="bibr" target="#b0">[1]</ref>. While context-free grammars are a suitable and successful assembly language for specifying context-free languages, they are not really good for dening languages in a high-level way. In particular, they lack abstraction facilities so that grammars are neither modular nor easy to reuse. While parser generators and related tools have evolved with respect to the modularization of parsing actions and integration of the specications of parsing and scanning, the actual raw matter, the grammar, remains in its original form in the parser specication. As large grammars may well run into several hundred productions, grammar maintenance can become a tedious task. Hence, it is surprising that none of the parser generators has a facility for introducing abstractions over grammar rules.</p><p>The main attempt to introduce some abbreviation mechanism into grammars is the consideration of regular righthand sides for rules <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b19">18]</ref>. Even though this facility falls short from providing exible abstractions, only a few LR parser generators (e.g., Eli <ref type="bibr" target="#b10">[11]</ref>) and several LL parser generators (e.g., ANTLR <ref type="bibr" target="#b19">[18]</ref> and the formalization in Wilhelm and Maurer's textbook <ref type="bibr" target="#b28">[27]</ref>) support regular right hand sides or extended BNF directly. Consequently, typical grammars for parser generators are full of rule groups that implement common grammatical patterns. Figure <ref type="figure" target="#fig_0">1</ref> contains some examples with the number of uses of the respective pattern in a randomly picked grammar. Often, even the semantic actions coincide or can be made to coincide easily.</p><p>Our proposal derives directly from these observations. Instead of relying on a xed set of (regular) operators for use in the right-hand side of a grammar rule, we make available an arbitrary, user-denable set of operators in the form of parameterizable nonterminal symbols. These nonterminals behave like macros. They can be invoked on the right-hand side of a production with any string of terminals, nonterminals, and macro applications as actual parameters. This notion coincides exactly with Fischer's macro grammars <ref type="bibr" target="#b7">[8]</ref>.</p><p>The generative power of macro grammars is properly contained between the context-free languages and the contextsensitive languages. That is, the word problem is decid-  able for general macro grammars, but not as ecient as for context-free grammars.</p><p>Hence, we impose an intuitive (and eectively checkable) restriction on macro grammars to ensure that they are specializable to context-free grammars. The specialization process creates a specialized nonterminal for each invocation of a macro-nonterminal with a particular arguments. The specialization is a straightforward adaption of standard techniques for program-point specialization <ref type="bibr" target="#b16">[15,</ref><ref type="bibr" target="#b11">12]</ref>, the main challenge is to guarantee the termination of this specialization. If the specialization terminates, then it yields a context-free grammar equivalent to the original macro grammar.</p><p>With our approach, the author of a grammar can write parameterized productions corresponding to the patterns exhibited above once and for all. Sets of parameterized nonterminals may be collected in modules and reused between grammars. At the same time, the specialization process yields plain context-free grammars that have ecient parsers implemented using standard techniques.</p><p>The parameterized rules in Figure <ref type="figure">2</ref> capture the grammatical patterns identied in Figure <ref type="figure" target="#fig_0">1</ref>. By convention, nonterminals have capitalized names whereas their parameters start with a lowercase letter. Terminal symbols are enclosed in single quotes. Figure <ref type="figure" target="#fig_16">3</ref> suggests uses of the parameterized rules that match the uses of the respective patterns in the original grammar (Figure <ref type="figure" target="#fig_0">1</ref>). For the examples in Figure <ref type="figure">2</ref> it also makes sense to dene generic semantic actions. The only requirement is that these actions are polymorphic with respect to the semantic values of the parameters. Hence, the (SepList sep item) and the (List item) might both return a value of type List item and the (Option item) might return a value of type Maybe item.</p><p>In earlier work <ref type="bibr" target="#b24">[23]</ref>, we have investigated the related notion of parameterized LR parsing.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">ADVANCED USES OF MACROS IN GRAMMAR SPECIFICATIONS</head><p>Our prior work <ref type="bibr" target="#b24">[23]</ref> is restricted to simple macro grammars, as already mentioned. This notion can already express many patterns that occur in grammars describing real-world programming language, as demonstrated in the introduction. However, the restriction of arguments to single symbols turns out to be too limiting. Many natural abstractions do not obey this restriction and either require a cumbersome workaround (the introduction of an additional nonterminal)</p><p>or are not expressible at all.</p><p>The following examples show how lifting the restriction further helps to shorten the syntactical description of real-world programming languages.</p><p>Encoding Operator Precedence. the in token is also a valid relational operator. However, in the header of a for statement the in is not allowed because it has a dierent use. The ocial JavaScript grammar literally duplicates the rules for relational expressions and for the ten subordinate stages to capture both variations. The rules in Figure <ref type="figure">6</ref> show three stages in both variations.</p><p>There are at least two ways to circumvent the duplication by making use of parameterized grammar rules. The rst approach abstracts over the operators allowed in a relational expression, species two dierent nonterminals expressing the operation symbols allowed in either contexts, and use those to instantiate the parametric expression rule. Figure <ref type="figure">7</ref> shows this alternative.</p><p>Another alternative is to employ a more exible rule for binary operators: a parametric rule for binary operators that abstracts not only over the operator symbols but also over an additional way to derive the operator expression.</p><p>( The additional condition stating that A compile-time error occurs if the same modier appears more than once in a eld declaration is only specied by an informal annotation to the grammar. Checking this side condition of a permutation phrase is usually left to the compiler's semantic analysis because it is cumbersome to express in a context-free grammar (it requires exponentially many productions).</p><p>We can encode the additional condition concisely in the grammar by using macro productions as shown in Figure <ref type="figure" target="#fig_3">8</ref>.</p><p>The nonterminal Perm3 implements permutation phrases by taking three parameters that correspond to the three alternatives. The rst production indicates the end of the phrase.</p><p>The remaining three productions correspond to taking the rst (second, third) alternative and they continue by disabling the taken alternative in the recursive call to Perm3. Disabling takes place by substituting the nonterminal NUL (which has no productions) for the chosen alternative.</p><p>Specialization generates exponentially many context-free productions from these productions. It is also expected that useless rules and unreachable nonterminals are removed from the specialized grammar. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">MACRO GRAMMARS</head><p>To dene macro grammars properly, we need some standard denitions inspired by universal algebra. As we will frequently be speaking about indexed lists of syntactic entities, we write xn as a shorthand for x0, . . . , xn-1 and omit the index n if it is not important.</p><p>Definition 3.1. A signature is a pair Γ = (N, a) of a nite set N and an arity function a : N → A, where the set A is dened inductively by: If n ∈ N and, for all 0 ≤ i &lt; n, αi ∈ A, then αn ∈ A.</p><p>The set A generalizes numeric arities as follows. A constant has arity . An n-argument macro has as arity the n-place vector αn where αi-1 is the arity of the ith argument.</p><p>If we are only interested in the number of arguments, we consider a as a function from N → N.</p><p>Arities serve to categorize dierent kinds of nonterminals.</p><p>They are best compared with function types where the return type is xed and left implicit. This choice is suitable for nonterminals because they will always turn into strings in the end.</p><p>In this work, the signature Γ always contains a binary operator • (concatenation) and a constant ε (empty string) where a(•) = , and a(ε) = .</p><p>Definition 3.2. Let Γ = (N, a) be a signature. The set</p><formula xml:id="formula_0">T α Γ (X)</formula><p>of Γ-terms of arity α with variables X = (X α ) (a set disjoint from N indexed by arities α) is dened inductively by</p><formula xml:id="formula_1">• X α ⊆ T α Γ (X), • ∀A ∈ N, A ∈ T a(A) Γ (X), • ∀n ∈ N, (∀0 ≤ i &lt; n, ti ∈ T α i Γ (X)), ∀t ∈ T αn Γ (X) t(t0, . . . , tn-1) ∈ T Γ (X).</formula><p>That is, each variable is a term, each nonterminal is a term with its respective arity, and terms can be built from a function/macro term and an argument list, provided their arities match the argument arities of the function term. However, the facilities for actually constructing a function term are limited to symbols taken from the signature.</p><p>Example 3.3. A signature providing for the lists and optional items from the introduction allows only constants as arguments. It is dened by a table of its arity function.</p><formula xml:id="formula_2">a(SepList) = , a(NESepList) = , a(List) = a(NEList) = a(Option) = Definition 3.4.</formula><p>A macro grammar is a tuple (Γ, Σ, P, S) where Γ = (N, a) is a signature with N the nonterminal symbols, Σ is a nite set of terminal symbols of arity ,</p><formula xml:id="formula_3">P ⊆ {(A, w) | A ∈ N, w ∈ T Γ(A) (Σ)}</formula><p>is a nite set of macro productions, and S ∈ N with a(S) = is the start symbol. The productions are subject to the following restriction which is already indicated in the type above.</p><formula xml:id="formula_4">If A → w ∈ P with a(A) = αn , then w ∈ T Γ(A) (Σ) where Γ(A) = Γ ∪ {a(0) = α0, . . . , a(n -1) = αn-1}.</formula><p>To increase readability of the examples, we take the liberty of naming the parameters of the nonterminals as in the introduction instead of using the numbering scheme. In addition, we drop the parentheses after nullary nonterminals and parameters. In formal statements, we will stick to the positional notation and the parameters.</p><p>A macro grammar generates words over the set of terminal symbols using the following derivation relation ⇒ on T Γ (Σ). The denition uses the notation w[i → t] to denote the term w with all occurrences of parameter i replaced by term t.</p><formula xml:id="formula_5">• If A → w ∈ P , a(A) = αn , (∀0 ≤ i &lt; n) ti ∈ T α i Γ (Σ), then A(t0, . . . , tn-1) ⇒ w[0 → t0, . . . , n -1 → tn-1],</formula><p>and</p><formula xml:id="formula_6">• if f ∈ Γ, a(f ) = αn , (∀0 ≤ i &lt; n) ti ∈ T α i Γ (Σ)</formula><p>, tj ⇒ t j , then f (t0, . . . , tj, . . . , tn-1) ⇒ f (t0, . . . , t j , . . . , tn-1).</p><p>That is, the relation comprises all pairs of terms which are instances of a production and it is closed under compatibility with operators from Γ. As usual, * ⇒ denotes the reexive transitive closure of the derivation relation.</p><p>A term w is in the language generated by the grammar if S * ⇒ w and w ∈ T •,ε (Σ), which can be considered as an element of Σ * in the obvious way.</p><p>Often the derivation relation is restricted to either substitute nonterminals inside-out (IO) or outside-in (OI). OI reduction the reduction rule for ⇒OI is the same as for ⇒, but compatibility is restricted to f ∈ {•, ε} so that reduction does not proceed into argument positions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IO reduction</head><formula xml:id="formula_7">A(t0, . . . , tn-1) ⇒IO w[0 → t0, . . . , n -1 → tn-1] only if t0, . . . , tn-1 ∈ T •,ε (Σ) do not contain non-</formula><p>G abc : The respective languages are called IO-and OI-macro languages. They have been investigated in detail <ref type="bibr" target="#b7">[8]</ref> and we recall some of their properties below. 1</p><formula xml:id="formula_8">S → F (ε, ε, ε) F → 012 F → F (a0, b1, c2) G list : S → L(a) S → L(b) L → ε L → N (0) N → 0L(0)</formula><p>1. In general, the language generated from a grammar under IO reduction is dierent from the language generated under OI reduction. (IO corresponds roughly to call-by-value and OI to call-by-name.)</p><p>2. The classes of IO-and OI-macro languages are incomparable.</p><p>3. The IO-and OI-macro languages form a strict hierarchy of languages between context-free languages and context-sensitive languages <ref type="bibr" target="#b5">[6]</ref>.</p><p>As an example for a macro grammar dening a language that is not context-free consider the grammar G abc in Figure <ref type="figure" target="#fig_5">9</ref>. This grammar generates the language {a n b n c n | n ∈ N} which is context-sensitive but not context-free. The extra generative power comes from the possibility to pass arbitrary terms as parameters, in particular nontrivial terms that contain parameters themselves. The language of this grammar is indepedent of the reduction order because each sentential form contains at most one invocation of a macro.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">CONTEXT-FREE GRAMMARS FROM MACRO GRAMMARS</head><p>The macro grammar for generating the context-sensitive language {a n b n c n | n ∈ N} is not typical for the grammars that we are interested in in this paper. We are interested in macro grammars like G list in Figure <ref type="figure" target="#fig_5">9</ref> that merely abbreviate a context-free grammar and where this context-free grammar can be obtained by specialization. Some notation 1 The denition we are giving above is not the one that has been used to obtain the cited results. The original denition considers strings as trees build from monadic operators (the characters) so that standard nonterminals in a context-free grammar are also monadic operators serving as placeholders for trees. In a macro grammar, nonterminals receive additional parameters that range over monadic operators. Adding further parameter sets leads to higher levels in the mentioned hierarchy. Our denition achieves higherorderness through the arity system.</p><p>is needed to dene this specialization and to prove that a specialized grammar is equivalent to its underlying original macro grammar.</p><p>Definition 4.1. A parameter instance for arity αm is a tuple of terms rm without free parameter variables, that is rj ∈ T α j Γ (Σ). We write rm : αm to indicate this case. A parameter instantiation from arity αm to arity β l is an l-tuple of terms s l where sj ∈ T β j Γ∪{a(i) →α i |0≤i&lt;l} (Σ). Let PI be the set of all parameter instantiations. The application of a parameter instantiation s (from arity αm to arity β l ) to parameter instance r (of arity αm ) is dened by r l := rm • s l where</p><formula xml:id="formula_9">r j = sj[i → ri | 0 ≤ i &lt; m].</formula><p>The composition of parameter instantiations s l : αm → β l and s k :</p><formula xml:id="formula_10">β l → γ k is dened by s k := s l ; s k : αm → γ k where s j = s j [i → si | 0 ≤ j &lt; k]. Lemma 4.2.</formula><p>1. Composition of parameter instantiations is associative and there is a unit element for each arity, namely (0, . . . , k -1) :</p><formula xml:id="formula_11">α k → α k . 2.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Composition of parameter instantiations is compatible</head><p>with application in the sense that (r • s) • s = r • (s; s ) (assuming that the arities t).</p><p>In the following we make use of a slightly nonstandard denition of a (labeled) directed graph. In our denition, there may be more than one directed edge between a given pair of nodes. This setting is mostly useful for labeled graphs, where these edges may have dierent labels.</p><p>Definition 4.3. A directed graph is a tuple (V, E, src,trg) where V is the set of vertices and E is the set of edges. The two components src and trg are both mappings E → V that determine the source vertex and the target vertex of an edge. Often the mappings and E are given implicitly. Stating that v1 -→ v2 is an edge means that there is an element e ∈ E such that src(e) = v1 and trg(e) = v2. A Λ-labeled directed graph has a fth component lab : E → Λ that maps each edge to a label. Here the notation v1 l -→ v2 means that there is some e ∈ E such that src(e) = v1, trg(e) = v2, and lab(e) = l.</p><p>Often we just state the sets of vertices and edges as in (V, E) and add the labeling informally.</p><p>The instantiation graph is the registry of all calls (with parameters) to a nonterminal during the transformation of a macro grammar to a context-free grammar. It also encompasses all calls that may ever occur in a derivation of the macro grammar. A node of this graph is a pair of a nonterminal and a suitable parameter instance. The edges of the graph indicate the caller-callee relationship and their labels indicate the parameter instantiation taking place. Definition 4.4. The instantiation graph IG(M) of a macro grammar M = ((N, a), Σ, P, S) is the smallest PIlabeled graph G = (V, E) such that the following holds.</p><formula xml:id="formula_12">• V ⊆ {(A, rm) | A ∈ N, rm : a(A)}. • (S, ()) ∈ V is a node of G if S is the start symbol of M. • If X = (A, r) ∈ V is a node, A → w a production of M, and B(s) is a subterm of w, then Y = (B, r•s) ∈ V is also a node and X s -→ Y ∈ E is a labeled edge.</formula><p>Example 4.5. As an example, consider the instantiation graphs for the grammars from Figure <ref type="figure" target="#fig_5">9</ref>. <ref type="figure">,</ref><ref type="figure">(a,</ref><ref type="figure">b,</ref><ref type="figure">c</ref>)) → (F, (aa, bb, cc)) → . . . This graph has innitely many vertices, so that the specialization would not terminate. This graph has nitely many vertices and its grammar's specialization terminates.</p><formula xml:id="formula_13">IG(G abc ): (S, ()) → (F, (ε, ε, ε)) → (F</formula><p>The instantiation graph contains all the information needed to extract a context-free grammar equivalent to the underlying macro grammar M. To state this equivalence, we need to make the extraction of the macro invocations (B(s) in Denition 4.4) more formal using the following denition.</p><p>Definition 4.6. The following function is dened inductively on terms (for</p><formula xml:id="formula_14">x ∈ Σ, C ∈ N , n ∈ N, 0 ≤ &lt; n). |x|r = x |C|r = C |j|r = rj |s(s0, . . . , s l-1 )|r = (|s|r, |s0| * r . . . |s l-1 | * r )</formula><p>We write |w| * r for the obvious homomorphic extension to words and we write |a| if r does not matter. Lemma 4.7. Let M = (Γ, Σ, P, S) be a macro grammar. If IG(M) is nite, then there exists a context-free grammar G = (N , Σ, P , S ) such that S() * ⇒M,OI w i S * ⇒G w.</p><p>Proof. Let IG(M) = (V, E) and dene G by N = V , S = (S, ε), and</p><formula xml:id="formula_15">P = {(A, r) → |w| * r | (A, r) ∈ V, A → w ∈ P }.</formula><p>G is a well-dened context-free grammar because V is nite.</p><p>It remains to show that the two grammars are equivalent.</p><p>To this end, we need to generalize the claim as follows: for all v and w, v * ⇒M,OI w i |v| * * ⇒G |w| * . In this case, r does not matter because neither v nor w contain any j.</p><p>The proof is by induction on n, the number of derivation steps. For n = 0 the result is trivial. If n &gt; 0 then the derivation for M splits as follows: ⇒ G |w| * as desired.</p><formula xml:id="formula_16">v = u1A(r)u2⇒M,OI u1t[j → rj]u2 (n-1) ⇒ M,OI w if A → t is</formula><p>The above development yields a necessary and sucient criterion when a macro grammar generates a context-free language. All we need to do is to test the instantiation graph for niteness. To perform this test eectively, we dene another graphthe transition graphand consider a nite abstraction of this graph. This abstraction will help us decide niteness of the instantiation graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">THE TRANSITION GRAPH AND ITS AB-STRACTION</head><p>The transition graph contains the same information as the instantiation graph, but presents it in a dierent packaging.</p><p>While it is guaranteed to have nitely many nodes, it may have innitely many edges.</p><p>Definition 5.1. Let M = ((N, a), Σ, P, S) be a macro grammar. The transition graph T G(M) is a labeled directed graph with N as the set of nodes and edges labeled with parameter instantiations. The set of edges characterizes the primitive transitions with correspond directly to macro calls from one production to another:</p><formula xml:id="formula_17">E = {A s -→ B | A → w ∈ P, B(s) ∈ w} ⊆ N × PI × N.</formula><p>The closed transition graph CT G(M) is the closure of T G(M) under transitivity. That is, its set of nodes is also N but its set of edges is the smallest set E * such that E ⊆ E * and if</p><formula xml:id="formula_18">A s -→ B ∈ E * and B s -→ C ∈ E * then A s;s -→ C ∈ E * .</formula><p>By construction, each path in the transition graph corresponds to an edge in the closed transition graph. The transition graph of a macro grammar is always nite whereas the closed transition graph is nite if and only if the instantiation graph is nite.</p><p>Lemma 5.2. There is a path in IG(M) that visits innitely many dierent nodes of IG(M) i there is an innite number of edges in CT G(M).  Coming back to niteness of IG(M), we wish to check for the criterion specied in the following denition.</p><p>Definition 5.4. An edge A s -→ A in CT G(M) is selfembedding if there is some j such that sj contains j but sj = j.</p><p>While it is straightforward to prove that the existence of a self-embedding transition is sucient to construct an innite IG(M), it is surprisingly hard to prove that the nonexistence of a self-embedding guarantees niteness of the instantiation graph. In addition, there is the issue of nding a suitable, nite abstraction of the transitions s without loosing the ability to detect self-embeddings.</p><p>To dene this abstraction, we need to recall some basic denitions about multisets. A multiset M is a function A → N, for some underlying set A, which contains each element a ∈ A with some multiplicity M (a) ∈ N. The union M1 ∪ M2 of multisets is dened by taking the maximum of the elements' multiplicities. In contrast, the join operation M1 M2 takes the sum of the the multiplicities.</p><p>The cardinality |M | of a multiset is the sum of its elements' multiplicities.</p><p>To proceed, we rst construct a suitable abstraction for transitions. To create this abstraction in a compositional way requires to work with an instrumented instantiation graph.</p><p>The instrumentation keeps track of the parameter positions of primitive transitions through which a value has been propagated already and if it has been augmented on that path.</p><p>It does so by augmenting each component with a multiset of pairs (p, i) of a primitive transition and an argument number.</p><p>Hence, the instrumentation of a primitive transition A p -→ B is a vector of multisets M where, for 0 ≤ j &lt; a(B),</p><formula xml:id="formula_19">Mj =  { } if pj = ε ∨ pj ∈ {0, . . . , a(A) -1} {(p, j)} otherwise.</formula><p>The composition of instrumented parameter instantiations is dened in the obvious way. The composition of s l ; s k is s k where the components of the instantiation are dened as before in Denition 4.1. If M l and M k are the multisets associated with s l and s k , then the components of M k are dened by</p><formula xml:id="formula_20">M i = M i [ j∈var (s i )</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Mi</head><p>where ∪ is the union of multisets and is the join operation.</p><p>While the union collects contributions to the result from dierent sources, the join operation models the sequential composition.</p><p>To build an abstraction of an instrumented parameter instantiation requires to abstract the term part as well as the multiset. We abstract multisets to 2-bounded multisets.</p><p>They limit the multiplicity function by abstracting the multiplicities 2, . . . to ∞. This cuto yields a nite abstraction, provided the underlying set of elements is nite.</p><p>More formally, a 2-bounded multiset with elements from set A is a mapping M from A to B = {0, 1, ∞}. The operations + and max on B are the obvious abstractions of addition and maximum of positive integers. If M (a) = 0 then a is absent from the multiset, M (a) = 1 denotes a's presence with multipicity 1, and M (a) = ∞ indicates that a is present more than once.</p><p>For a 2-bounded multiset over a nite set, the cardinality is ∞ if there is at least one element with multiplicity ∞.</p><p>While a concrete transition consists of a vector of terms (the parameter instantiation) and a vector of multisets, an abstract transition is a vector of abstract terms and a vector of 2-bounded multisets. (Where convenient we view either kind of transition as a vector of pairs, too.)</p><p>An abstract term abstracts from a term by capturing the variables contained in the term and by identifying whether a transition constructs a nontrivial term. Here, a term is nontrivial if it is neither ε nor i (just a parameter). Hence, an abstract term, v, is one of E, the abstraction of the empty word ε, J(i), which denotes a value copied from argument position i ∈ N, C(K), which denotes a nontrivial term built from values from the argument positions mentioned in K ⊆ N.</p><p>Abstract terms support a commutative operation ⊕. This operation abstracts the concatenation operation • on concrete terms. E is the unit of ⊕.</p><formula xml:id="formula_21">J(i) ⊕ J(k) = C({i, k}) J(i) ⊕ C(K) = C(K ∪ {i}) C(K) ⊕ C(L) = C(K ∪ L)</formula><p>The intuition behind this operation is as follows. The abstraction function is a monoid homomorphism from concrete terms TΓ∪I with ε and concatenation to abstract terms with E and ⊕. Hence, ε must be mapped to the unit E. If the original word refers twice to arguments i and k (not necessarily dierent), it does not copy the arguments anymore, but builds a term containing both arguments (or one argument twice). Joining a term building operation with a copy operations (or another term building operation) yields a term building operation containing the union of the argument positions.</p><p>Definition 5.5. The abstraction of a concrete transition, an abstract parameter instantiation, is dened by</p><formula xml:id="formula_22">α(A s -→ B) = A c -→ B</formula><p>where cj = (α(sj), α(Mj)) and Mj are the multisets associated with s. Let AP I be the set of all abstract parameter instantiations. The abstraction of a term is dened by</p><formula xml:id="formula_23">α(ε) = E α(x) = C(∅) x ∈ Σ α(i) = J(i) α(D(w1, . . . , wn)) = C(∅) ⊕ α(w1) ⊕ • • • ⊕ α(wn) D ∈ N, a(D) = n α(v • w) = α(v) ⊕ α(w).</formula><p>The abstraction of a multiset M is dened by</p><formula xml:id="formula_24">α(M )(a) = 8 &lt; : 0 M (a) = 0 1 M (a) = 1 ∞ M (a) &gt; 1. Definition 5.6. Dene abstract composition A e -→ C = A c -→ B; B d -→ C by ej = 8 &gt; &gt; &lt; &gt; &gt; : dj if dj = (E, M ) (v, M M ) if dj = (J(i), M ), ci = (v, M ) (v, M M ) if dj = (C({k1, . . . , km}), M ) and (v, M ) = (C(∅), { }) ⊕ L m i=1 c k i</formula><p>Clearly, abstraction is compatible with composition.</p><p>Lemma 5.7. If α(A s</p><formula xml:id="formula_25">-→ B) = A c -→ B and α(B t -→ C) = B d -→ C then α(A s;t --→ C) = A c;d --→ C.</formula><p>We can also go back from abstract transitions to concrete ones. However, some care must be taken to only obtain realizable concretizations, i.e., transitions which are actually composable from primitive ones.</p><p>Definition 5.8. The concretization function γ is</p><formula xml:id="formula_26">γ(A c -→ B) = { A0 p (1) ;...;p (m) --------→ Am | A0 = A, Ai-1 p (i) --→ Ai ∈ E(T G(M)), Am = B, A c -→ B = α(A0 p (1) ;...;p (m) --------→ Am)}</formula><p>where the p (i) are drawn from the primitive transitions.</p><p>Definition 5.9. Let M = ((N, a), Σ, P, S) be a macro grammar. The abstract transition graph AT G(M) is a labeled directed graph with set of nodes N and edges E ⊆ N × API × N labeled with abstract parameter instantiations:</p><formula xml:id="formula_27">E = {A c -→ B | A → w ∈ P, B(s) ∈ w, c = α(s)}.</formula><p>The closed abstract transition graph CAT G(M) is the closure of AT G(M) under transitivity. Its set of nodes is N and its set of edges is the smallest set   <ref type="figure">(E,</ref><ref type="figure">E,</ref><ref type="figure">E</ref>)</p><formula xml:id="formula_28">E * such that E ⊆ E * and if A c -→ B ∈ E * and B d -→ C ∈ E * then A c;d --→ C ∈ E * . Both AT G(M)</formula><formula xml:id="formula_29">G list : S L N (J0) (J0) (C{}) (J0) (J0) (C{})</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">FINITENESS OF THE ABSTRACT TRANSITION GRAPH</head><p>Having established a nite abstraction of the transition graph in the previous section, this section is devoted to deciding if an abstract transition has innitely many concretizations.</p><p>To this end, we rst dene a size function for abstract transitions, which counts the number of elements in all multisets associated to a term-building position. Then, an abstract transition is innite if its size is innite. Definition 6.1. Let A c -→ B be an abstract transition. The size of c is dened as</p><formula xml:id="formula_30">|c| = | [ j {Mj | cj = (vj, Mj), ∃K.vj = C(K)}|. The c is nite if its size is nite, that is, if |c| &lt; ∞. Theorem 6.2. Suppose that A c -→ B is nite. Then the associated set of concrete transitions γ(A c -→ B) is nite.</formula><p>This theorem can be proved by induction on the (nite) size of the abstract transition. However, getting the induction through requires a strengthened assumption as stated in the following lemma. </p><formula xml:id="formula_31">(C({0}), {(p, 0)}); (E, { }) = (E, { }).</formula><p>The set N indicates the argument positions which are not canceled by subsequent constituends, which makes the Nindexed size monotonic (subject to the correct choice of N ).</p><p>Proof. The proof of Lemma 6.3 is by course-of-value induction on the size |c|N where c has components cj = (vj, Mj).</p><formula xml:id="formula_32">If |c|N = 0 then, for each j ∈ N , vj ∈ {E} ∪ {J(i) | 0 ≤ i &lt; a(A)}.</formula><p>Hence, for each s ∈ γ(c) and for each j ∈ N , sj = ε or sj = i, for some 0 ≤ i &lt; a(A).</p><p>If |c|N &gt; 0 then let N = S j∈N,∃K.v j =C(K) Mj and split γ(c) = S I⊆N SI into disjoint subsets (some of which may be empty) indexed by the subsets I of N as follows.</p><p>A transition s = p (1) ; • • • ; p (m) (considered as composition of primitive transitions) belongs to subset SI where I = {(p (k) , i1), . . . , (p (k) , iq)} ⊆ N if k ∈ {1, . . . , m} is maximal such that |α(p (k+1) );</p><formula xml:id="formula_33">• • • ; α(p (m) )|N = 0, but for c (2) = α(p (k) ); • • • ; α(p (m) ) it holds that I = S {Mj | j ∈ N, c<label>(2) j</label></formula><p>= (vj, Mj), ∃K.vj = C(K)} and thus |c (2) |N = q &gt; 0. Such a k must exist, otherwise there is a contradiction to |c|N &gt; 0. Essentially, p (k) is the last primitive transition that contributes to the growth in the N -components of s. The subsequent transitions only pass on values, cancel values, or perform computation outside of N .</p><p>The point is that for each sequence in SI there is such a k and the abstraction of the sequence can be split into</p><formula xml:id="formula_34">• c (1) = α(p (1) ); • • • ; α(p (k-1) ), • c (2) = α(p (k) ); • • • ; α(p (m) ), where D p (k) ---→ D such that • 0 &lt; |c (2) |N = q ≤ |c|N</formula><p>, that is, while its size is not necessarily less than the original size, the size q can be attributed to a single primitive transition p (k) , which we analyse next;</p><p>• there exists some N1 ⊆ {0, . . . , a(D ) -1} such that |c (1) |N 1 = |c|N -q &lt; |c|N . N1 consists of the positions not ignored by c (2) . These positions are exactly the indices that occur in the abstract terms of the Ncomponents of c (2) .</p><p>The inductive hypothesis is applicable to c (1) so that the N1-components of the composition p (1) ; • • • ; p (k-1) assume only nitely many dierent values. Next, the primitive transition p (k) is fully determined by I. 2 Clearly, it only produces nitely many results in the components that only depend on N1. Now, by construction, the N -components of p (k+1) ; • • • ; p (m) must be drawn from ε and {0, . . . , a(D)-1} so that this transition can only perform one of nitely many possible choices from the output components of p (k) . Hence, the N -components only assume nitely many values.</p><p>The desired result follows from the observation that there are nitely many subsets I ⊆ N and each of them yields nitely many values as just explained. Some of the subsets SI may be empty, for example, the one indexed with I = { } or any index which mentions dierent primitive transitions.</p><p>Lemma 6.4. The following statements are equivalent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">There exists an innite transition</head><formula xml:id="formula_35">A c -→ B.</formula><p>2. There exists an innite transition D d -→ D.</p><p>3. There exists an innite, idempotent transition D e -→ D.</p><p>4. There exists an idempotent, self-embedding transition Proof. Case (1) ⇒ (2). Suppose that there exists an innite transition A c -→ B. Take any concretization s of c. Because c is innite, there is some j such that cj = (vj, Mj) with vj = C(K) and, for some p and i, the multiplicity of (p, i) in Mj is greater than one, and D p -→ D. But that means that s splits up into  2 There may be innitely many lengths m of sequences and innitely many positions k; the point is that each such sequence may be split into parts c (1) and c (2) with well-dened behavior.</p><formula xml:id="formula_36">A -→ D p -→ D t -→ D p -→ D -→ B where α(t; p)i = (C(K ), M ) with (p, i) ∈ M and i ∈ K .</formula><p>Because the set of abstractions is nite, the sequence (d), (d; d), (d; d; d), and so on must become stationary at some n &gt; 1. Choosing e = d (n) yields an innite, idempotent transition.</p><p>Case (2) ⇐ (3). Trivial.</p><p>Case (1) ⇒ (4). Select t and p as in the proof for (1) ⇒ (2).</p><p>Because of the choice of t and p, d = α(t; p) is self-embedding in position i. By niteness of the abstraction, there is a nite power of d which is idempotent (each power is also self-embedding).</p><p>Case (4) ⇒ (3). Suppose that D e -→ D is idempotent and self-embedding, say, ei = (C(K ), M ) with i ∈ K . In any concretization s = p (1) ; . . . ; p (m) there must be some k and j so that p (k) j is responsible for the C in ei which means that (p (k) , j) ∈ M . Thus, for d = e; e it holds that di = (C(K ), M ) with (p (k) , j) ∈ M with multiplicity &gt; 1 so that d is innite and idempotent. Theorem 6.2 gives rise to a sucient criterion for ensuring quasi-termination. Theorem 6.5. The concrete transition graph CT G(M) is nite i all idempotent transitions in CAT G(M) are nite.</p><p>Proof. If all idempotent c ∈ CAT G(M) are nite, then Lemma 6.4 ensures that all transitions in CAT G(M) arenite. Hence, Theorem 6.2 ensures that there are only nitely many concretizations for each abstract transition, so that CT G(M) is nite.</p><p>If any idempotent c is innite, then Lemma 6.4 tells us that there is also some self-embedding transition d. From the concretizations of d, we can construct innitely many congurations.</p><p>An analysis based on Theorem 6.5 is still very expensive. It amounts to constructing CAT G(M) and then checking all idempotent transitions for niteness. However, Lemma 6.4 yields a simplication. By item 4 of the lemma, the existence of an innite abstract transition is equivalent to the existence of a self-embedding idempotent transition. Hence, an implementation of the analysis need not keep track of the 2-bounded multisets but that it is sucient to work with just the term abstraction and detect self-embedding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">IMPLEMENTATION</head><p>We have implemented grammar specialization as a standalone tool 3 geared at specializing input grammars for bi- son <ref type="bibr" target="#b6">[7]</ref> or yacc <ref type="bibr" target="#b15">[14]</ref>. It extends the syntax of rules slightly by allowing a macro denition on the left-hand side of a rule and macro invocations on the right-hand side. Figure <ref type="figure" target="#fig_17">10</ref> contains an example excerpted from a yacc grammar extended with parameterized rules and Figure <ref type="figure" target="#fig_18">11</ref>    corresponding fragment of the specialized grammar (which is suitable for processing with yacc).</p><p>The implementation consists of roughly 1000 lines of Haskell code <ref type="bibr" target="#b20">[19]</ref>. About half of the code deals with parsing and printing bison grammars. The code is written in a framework style which abstracts over the representation of grammars, so that specialization backends for other kinds of parser generators can be written easily. The main eort is in writing the parser for grammar les.</p><p>One extension that we have contemplated, but not implemented is code parameters. Right now, a grammar author must resort to design generic datastructures like the List type in Figure <ref type="figure" target="#fig_17">10</ref> with parameterized rules.</p><p>While this choice is pragmatic, it does have a number of drawbacks.</p><p>First, type safety is not guaranteed in a language like C which does not have generics. The users of the rules have to insert the correct casts to extract values out of the generic datastructures. Second, inside of one program, the use of the rules is restricted to one particular implementation of the generic datastructure (List in the example).</p><p>These drawbacks could be addressed with code parameters.</p><p>A code parameter is an additional parameter to a nonterminal that takes an action, i.e., a code fragment surrounded by curly braces, as an argument. The specialization process then not only expands grammatical parameters (as demonstrated in this paper), but also actions. For instance, a parameterized nonterminal like commalist.1 might take two action parameters to be used in place of the generic actions.</p><p>This way, each call to commalist.1 could provide its own implementation for makeSingleton and addLast, thus solving the two problems outlined in the previous paragraph.</p><p>This extension would t in nicely with the theory developed for detecting termination.</p><p>However, we have refrained from implementing this extension because a realistic implemention would have to support code splices, where a code parameter is inserted into an action skeleton specied with the parameterized rule. A good implementation of code splices, in turn, requires dealing with the delicate issues of hygiene and name capture and thus parsing of C code. Such a project would go well beyond the proof-of-purpose implementation that we provide.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">RELATED WORK</head><p>Parser combinators <ref type="bibr" target="#b23">[22,</ref><ref type="bibr" target="#b14">13]</ref> are a highly exible way of specifying parsers in functional programming languages. In particular, the use of polymorphic functions and parameterized parsers is a natural way of structuring code. In contrast to the present work, parser combinators are restricted to perform predictive or top-down parsing. Recent advances <ref type="bibr" target="#b22">[21]</ref> have widened their scope considerably with respect to earlier, inecient proof-of-concept implementations. The present work makes some of the polymorphism and exibility that make parser combinators attractive available to all parser generators.</p><p>Cameron introduced a syntactic extension for context-free grammars to speciy permutation phrases <ref type="bibr" target="#b2">[3]</ref> and presents imperative pseudo-code demonstrating how to extend a predictive parser with the new construct without just simply expanding the grammar. Baars et al. <ref type="bibr" target="#b1">[2]</ref> show how to add permutation phrases to a functional parser combinator library. Such extensions come for free with our grammar specialization technology.</p><p>The syntax denition formalism SDF <ref type="bibr" target="#b26">[25]</ref> supports arbitrary context-free grammars and creates GLR parsers <ref type="bibr" target="#b17">[16,</ref><ref type="bibr" target="#b25">24,</ref><ref type="bibr" target="#b21">20]</ref> for them. For convenience, right-hand sides may contain an extended set of regular operators. An SDF specication also denes a lexical syntax. SDF includes an abbreviation mechanism which works by expansion. However, the mechanism is much weaker because SDF neither specializes the grammars nor does it analyse the termination of the specialization.</p><p>Extensions of LR parsing with regular operators on the right-hand sides of productions have been explored by Chapman <ref type="bibr" target="#b3">[4]</ref>. He extends the standard item set construction with new cases for these operators. However, the attached semantic actions are xed to e.g. list construction.</p><p>The compiler construction toolkit Eli <ref type="bibr" target="#b10">[11]</ref>  for describing context-sensitive aspects of programming languages. They lack the conciseness and ease of use of direct parameterization, which is a familiar concept from programming practice. This two-level mechanism could be encoded with macro grammars (indeed, the expression of semantic conditions was one of Fischer's motivations for inventing them). However, the thus constructed macro grammars generate context-sensitive languages and are thus not amenable to our specialization framework.</p><p>The method for analyzing termination of the specialization are inspired by work on the termination of program specialization <ref type="bibr" target="#b8">[9]</ref> and size-change termination <ref type="bibr" target="#b18">[17]</ref>. The termination of program specialization is a much broader topic than the termination of grammar specialization. The latter is a special case of specialization for a rst-order functional programming language which has some peculiar restrictions.</p><p>First, the language does not have a conditional, that is, the invocation of a macro rule always invokes all macros in all right-hand sides of the rule. Second, the language has only increasing operators. A rule can either ignore a parameter, pass it along unchanged, or pass it on as part of a larger term. However, it cannot decompose or otherwise decrease a parameter. Thus, while the termination of grammar specialization is simpler than that of program specialization, it Figure <ref type="figure" target="#fig_15">12</ref>: A variable-length permutation phrase.</p><p>is suciently dierent to require its only analysis, as presented in the present paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">FUTURE WORK</head><p>The main drawback of the present work is its restriction to rst-order macros. For some problems, a higher-order formulation is the most appropriate. As an example, let's reconsider the encoding of permutation phrases from Section 2. It can be adjusted to permutation phrases of any number of items. However, each number n of items requires the denition of a separate nonterminal PermPn with the associated productions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>If we admit arbitrary arities (other than</head><p>) as parameters and also allow partial macro applications, as customary in functional programming, then we can state rules for encoding permutation phrases with a variable numbers of tokens to permute. Figure <ref type="figure" target="#fig_15">12</ref> shows support macros for such phrases.</p><p>The main workhorse is the Perm nonterminal, which takes three parameters. The m parameter contains the current parsing alternative. The rest parameter contains the remaining alternatives. The acc parameter accumulates unused parsing alternatives in the form of a list composed of Pcons and Pnil.</p><p>The idea is that (Perm x rest acc) tries to parse a phrase that either starts with x (rst production) or with one of the remaining alternatives (second production). If parsing</p><p>x succeeds, then (acc rest) resurrects the unused parsing alternatives by prepending them to the unused alternatives.</p><p>This prepending is performed by the productions for Pcons and Pnil, they reactivate their elements at the same time by changing Pcons back to Perm. If parsing x does not succeed, then the unused alternative is Pconsed on top of the accumulator acc.</p><p>If Pend is reached, then all alternatives have been tried and they are dismissed because there is no way to parse the phrase, anymore.</p><p>The specialization procedure would also work for this kind of grammar, but our analysis would require a signicant extension.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">CONCLUSION</head><p>Macro grammars extend context-free grammars with macrolike productions. Each nonterminal symbol may have pa-rameters which can be arbitrarily instantiated at every invocation of the nonterminal. This extension enhances contextfree grammars with procedural abstraction.</p><p>In general, macro grammars recognize context-sensitive grammars, which are inecient to parse. We have dened grammar specialization to transform the productions of a macro grammar into a set of context-free productions. In general, this set is innite, but we have developed a static analysis which gives sucient and necessary conditions as to when the resulting set of context-free productions is nite (thus giving rise to a context-free grammar).</p><p>We have implemented grammar specialization in the YSpec tool, which is available from http://www.informatik.uni-freiburg. de/~thiemann/haskell/YSPEC.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>•Figure 1 :</head><label>1</label><figDesc>Figure 1: Patterns in existing grammars.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :Figure 3 :</head><label>23</label><figDesc>Figure 2: Examples for parameterized rules. DelimTypeSchemes : (SepList ',' TypeScheme) ; TypeVars : (List TypeVar) ; OptRenaming : (Option Renaming) ; Figure 3: Uses of the parameterized rules.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Excerpt from JavaScript inx expressions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>(Figure 8 :</head><label>8</label><figDesc>Figure 8: A xed-length permutation phrase.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>terminals and the relation is closed under compatibility as before.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Example macro grammars. G abc generates a context-sensitive language. G list is a variation of the parameterized list-generating grammar from the introduction. It generates the language {a n | n ∈ N} ∪ {b n | n ∈ N}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>a production. Now it holds that |v| * = |u1A(r)u2| * = |u1| * |A(r)||u2| * ⇒G |u1| * |t| * r |u2| * by denition of G. Because |t| * r = |t[j → rj]| * and the inductive hypothesis is applicable to the n -1 step derivation, it follows that |u1t[j → rj]u2| * (n-1)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Example 5 . 3 .</head><label>53</label><figDesc>Let's have a look at the (closed) transition graphs of the two examples from Figure9. The solid arrows correspond to T G() whereas the dashed arrows are the additional edges in CT G().</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>GG</head><label></label><figDesc>abc : This graph has innitely many edges and is cut o on the right. list : This graph has nitely many edges.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>and CAT G(M) are nite because there are only nitely many pairs of nonterminals A and B and, for each pair A and B, there are nitely many abstract transitions A c -→ B: Each of the nitely many components of c contains one of the nitely many possible term abstractions and a 2-bounded multiset over a nite set, of which there are also nitely many. Example 5.10. The term abstraction parts of the transition graphs for the grammars from Figure 9 look as follows.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Lemma 6 . 3 .</head><label>63</label><figDesc>Let A c -→ B be an abstract transition and N ⊆ {0, . . . , a(B) -1}, a subset of B's argument positions. Let further |c|N = | S j∈N {Mj | cj = (vj, Mj), ∃K.vj = C(K)}| be the size of the N -components of c. If |c|N is nite then the set γ(A c -→ B) projected on its Ncomponents is nite. Theorem 6.2 follows from the lemma by choosing N = {0, . . . , a(B) -1}. The use of N is required because the size of an abstract transition is only subadditive: The size of a composed transition may be smaller than the size of its constituends because a subsequent constituend may ignore argument positions and thus cancel intermediate growth. As an example consider the composition of two one-component abstract transitions where the second cancels the eort of the former:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>Thus, D t;p;t;p ----→ D abstracts to an innite transition D d -→ D where d = α(t; p; t; p).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Case ( 1 )</head><label>1</label><figDesc>⇐ (2). Trivial. Case (2) ⇒ (3). If D d -→ D is innite, then its concretizations can be split as in the previous case to nd some concrete D tp -→ D . Wlog, let D = D and d = α(tp; tp).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>contains the 3</head><label>3</label><figDesc>The code is available at http://www.informatik. uni-freiburg.de/~thiemann/haskell/YSPEC. %{ /* API for generic list construction */ List makeSingleton (void * elem); List addLast (List, void * elem); %} /* parameterized rule */ commalist.1 (item) : item { $$ = makeSingleton ((void *)$1); } | commalist.1 (item) ',' item { $$ = addLast ($1, (void *)$3); } ; /* two uses, both returning results of type List */ patternlist: commalist.1(pattern) ; explist1: commalist.1(expr) ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Excerpt of a parameterized Yacc grammar.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Specialized fragment.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head></head><label></label><figDesc>also constructs bottom-up parsers from grammars with regular right-hand sides. The regular operators are expanded in a preceding grammar transformation. Extended BNF productions are more often supported by LL parser generators [18]. Our work makes such an expansion mechanism accessible to the programmer. Van Wijngaarden (or W-) grammars [26] are a Turing-complete parameterized grammar formalism used in the denition of ALGOL 68. Conceptually, W-grammars consist of twolevels. The rst level denes context-free languages of interpretations of grammar symbols. These interpretations are used to generate the actual grammar productions by substitution into rule templates. However, W-grammars are a conceptual modeling tool and are not geared at generating ecient recognizers. Rather, they have been designed</figDesc></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sethi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<title level="m">Compilers Principles, Techniques, and Tools</title>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Functional pearl: Parsing permutation phrases</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">I</forename><surname>Baars</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Löh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Swierstra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Functional Programming</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page">635646</biblScope>
			<date type="published" when="2004-11">Nov. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Extending context-free grammars with permutation phrases</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">D</forename><surname>Cameron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Letters on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1-4</biblScope>
			<biblScope unit="page">8594</biblScope>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">LR parsing: theory and practice</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Chapman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
			<publisher>Cambridge University Press</publisher>
			<pubPlace>Cambridge, UK</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">LR-regular grammarsan extension of LR(k) grammars</title>
		<author>
			<persName><forename type="first">K</forename><surname>Culik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cohen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page">6696</biblScope>
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The IO-and OI-hierarchies</title>
		<author>
			<persName><forename type="first">W</forename><surname>Damm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">95207</biblScope>
			<date type="published" when="1982-05">May 1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Donnelly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Stallman</surname></persName>
		</author>
		<title level="m">BisonThe YACC-compatible Parser Generator. Free Software Foundation</title>
		<meeting><address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995-11">Nov. 1995</date>
		</imprint>
	</monogr>
	<note>Part of the Bison distribution</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Grammars with macro-like productions</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Fischer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Conference Record of 9th Annual Symposium on Switching and Automata Theory</title>
		<imprint>
			<date type="published" when="1968">1968</date>
			<biblScope unit="page">131142</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Termination analysis and specialization-point insertion in oine partial evaluation</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Glenstrup</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">D</forename><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Prog. Lang. and Systems</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page">11471215</biblScope>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">The Java Language Specication</title>
		<author>
			<persName><forename type="first">J</forename><surname>Gosling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Joy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Steele</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Bracha</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005-06">June 2005</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
	<note>third edition</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Eli: A complete, exible compiler construction system</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">P</forename><surname>Heuring</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Levi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Sloane</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M</forename><surname>Waite</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">121130</biblScope>
			<date type="published" when="1992-02">Feb. 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">An introduction to online and oine partial evaluation using a simple owchart language</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hatcli</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">In</forename><forename type="middle">J</forename><surname>Hatcli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">Ae</forename><surname>Mogensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Thiemann</surname></persName>
		</author>
		<title level="m">Partial EvaluationPractice and Theory. Proceedings of the 1998 DIKU International Summerschool, number 1706 in LNCS</title>
		<imprint>
			<biblScope unit="page">2082</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<pubPlace>Copenhagen, Denmark</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Monadic parsing in Haskell</title>
		<author>
			<persName><forename type="first">G</forename><surname>Hutton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Meijer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Functional Programming</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Yaccyet another compiler compiler</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Johnson</surname></persName>
		</author>
		<idno>32</idno>
		<imprint>
			<date type="published" when="1975">1975</date>
			<pubPlace>Murray Hill, NJ</pubPlace>
		</imprint>
		<respStmt>
			<orgName>AT&amp;T Bell Laboratories</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Partial Evaluation and Automatic Program Generation</title>
		<author>
			<persName><forename type="first">N</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gomard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sestoft</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>Prentice-Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Deterministic techniques for ecient non-deterministic parsers</title>
		<author>
			<persName><forename type="first">B</forename><surname>Lang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP1974</title>
		<imprint>
			<date type="published" when="1974">1974</date>
			<biblScope unit="page">255269</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The size-change principle for program termination</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">D</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Ben-Amram</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2001 ACM Symp. POPL</title>
		<editor>
			<persName><forename type="first">H</forename><forename type="middle">R</forename><surname>Nielson</surname></persName>
		</editor>
		<meeting>2001 ACM Symp. POPL<address><addrLine>London, England</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2001-01">Jan. 2001</date>
			<biblScope unit="volume">8192</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">ANTLR: A predicated-LL(k) parser generator</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Parr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Quong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SoftwarePractice &amp; Experience</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page">789810</biblScope>
			<date type="published" when="1995-07">July 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m">Haskell 98 Language and Libraries</title>
		<editor>
			<persName><forename type="first">S</forename></persName>
		</editor>
		<editor>
			<persName><forename type="first">Peyton</forename><surname>Jones</surname></persName>
		</editor>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
	<note type="report_type">The Revised Report</note>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Parser Generation for Interactive Environments</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rekers</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
		<respStmt>
			<orgName>University of Amsterdam</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Swierstra</surname></persName>
		</author>
		<ptr target="http://www.cs.uu.nl/groups/ST/Software/UU_Parsing/" />
		<title level="m">Fast, error repairing parsing combinators</title>
		<imprint>
			<date type="published" when="2003-08">Aug. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Deterministic, error-correcting combinator parsers</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Swierstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Duponcheel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advanced Functional Programming</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Launchbury</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Meijer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Sheard</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1129</biblScope>
			<biblScope unit="page">184207</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Parameterized LR parsing</title>
		<author>
			<persName><forename type="first">P</forename><surname>Thiemann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Neubauer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fourth Workshop on Language Descriptions, Tools and Applications</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Hedin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Van Wyk</surname></persName>
		</editor>
		<meeting><address><addrLine>Barcelona, Spain</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier Science</publisher>
			<date type="published" when="2004">2004. 115132. Apr. 2004</date>
			<biblScope unit="volume">110</biblScope>
		</imprint>
	</monogr>
	<note>LDTA</note>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Ecient Parsing for Natural Languages</title>
		<author>
			<persName><forename type="first">M</forename><surname>Tomita</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
			<publisher>Kluwer Academic Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Van Den Brand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Klint</surname></persName>
		</author>
		<ptr target="http://www.cwi.nl/projects/MetaEnv/meta/doc/manual/user-manual.html" />
		<title level="m">ASF+SDF meta-environment user manual</title>
		<imprint>
			<date type="published" when="2002-07">July 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Report on the algorithmic language ALGOL 68</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">E</forename><surname>Van Wijngaarden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Numerische Mathematik</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">79218</biblScope>
			<date type="published" when="1969">1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Wilhelm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Maurer</surname></persName>
		</author>
		<title level="m">Compiler Design</title>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
