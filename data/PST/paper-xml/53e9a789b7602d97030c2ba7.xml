<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">TeenyLIME: Transiently Shared Tuple Space Middleware for Wireless Sensor Networks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Paolo</forename><surname>Costa</surname></persName>
							<email>costa@elet.polimi.it</email>
							<affiliation key="aff0">
								<address>
									<settlement>Politecnico di Milano</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Luca</forename><surname>Mottola</surname></persName>
							<email>mottola@elet.polimi.it</email>
							<affiliation key="aff1">
								<address>
									<settlement>Politecnico di Milano</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Amy</forename><forename type="middle">L</forename><surname>Murphy</surname></persName>
							<email>amy.murphy@unisi.ch</email>
							<affiliation key="aff2">
								<orgName type="institution">University of Lugano</orgName>
								<address>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Gian</forename><forename type="middle">Pietro</forename><surname>Picco</surname></persName>
							<email>picco@elet.polimi.it</email>
							<affiliation key="aff3">
								<address>
									<settlement>Politecnico di Milano</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">TeenyLIME: Transiently Shared Tuple Space Middleware for Wireless Sensor Networks</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">520D8E31473A4F9CEC5BBC44EC9683D9</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T04:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C.2.4 [Distributed Systems]; D.2.11 [Software Architectures] Wireless Sensor Networks</term>
					<term>Tuple Spaces</term>
					<term>Middleware</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Recent developments in wireless sensor networks (WSNs) are pushing scenarios where application intelligence is no longer relegated to the fringes of the system (i.e., on a data sink running on a powerful node) rather it is distributed within the WSN itself.</p><p>To support this scenario, we propose TeenyLIME, a tuple space model and middleware supporting applications where sensing and acting devices themselves drive the network behavior. In other words, the application core is not confined to the powerful sinks, rather it is deployed on the devices embedded within the physical world. Tuple space operations are used both for data collection as well as to effect coordination among sensing and acting devices. This paper describes the TeenyLIME model and corresponding middleware implementation.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Wireless sensor networks (WSNs) are evolving from mainstream architectures characterized by a single sink gathering data and executing the application tasks, to more decentralized architectures where the application intelligence is distributed among the devices. A prominent example of these decentralized architectures is constituted by networks composed of sensors and actuators <ref type="bibr" target="#b2">[2]</ref>, where the latter base their actions on the data gathered by the former.</p><p>Clearly, such a decentralized architecture requires coordination among application components running on different devices. Unfortunately, the programming support available to application developers is often very low-level, and forces them to focus on im-plementation details rather than on the high-level interactions. Appropriate programming abstractions are necessary to deal with the complexity of managing coordination in these dynamic and decentralized WSN environments.</p><p>In this paper, we propose TeenyLIME, a new middleware for sensor networks based on the tuple space model made popular by Linda <ref type="bibr" target="#b6">[6]</ref>. TeenyLIME leverages off our experience in coordination technology, as it is based on the LIME <ref type="bibr" target="#b12">[12]</ref> middleware we developed for mobile ad hoc networks (MANETs), briefly outlined in Section 2. Like LIME, TeenyLIME operates by distributing the tuple space among the devices, transiently sharing the tuple spaces contents as connectivity allows, and introducing reactive operations that fire when data matching a template appears in the tuple space. TeenyLIME is part of a broader vision concerning the application of tuple spaces to mobile and wireless sensor networks <ref type="bibr" target="#b11">[11]</ref>.</p><p>Section 3 discusses the peculiarities of the TeenyLIME model. One significant design decision in TeenyLIME is to restrict transient sharing only to the tuple spaces of one-hop neighbors. This choice is not only energy-conscious, but is also in line with similar research efforts in the field (most notably the Hood system <ref type="bibr" target="#b15">[15]</ref>), as we discuss when examining related work in Section 7. Indeed, control of the one-hop neighborhood around a device, augmented with the powerful and expressive primitives provided by TeenyLIME, is versatile enough to enable a number of application-level uses, as we illustrate in Section 6.</p><p>A model becomes truly useful to developers only when incarnated in a real programming platform. For this reason, we designed and implemented a version of TeenyLIME for TinyOS <ref type="bibr" target="#b7">[7]</ref>. The application programming interface (API), designed for the nesC <ref type="bibr" target="#b4">[4]</ref> language, is illustrated in Section 4. In addition to providing the usual Linda primitives and those added by LIME, our API provides features introduced explicitly to address the specific requirements of WSNs. The internal architecture of our middleware implementation is discussed in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">BACKGROUND: LINDA AND LIME</head><p>In this section we provide a concise introduction to the notion of tuple space made popular by Linda, and to its adaptation to the mobile environment put forth by LIME.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Linda and Tuple Spaces</head><p>Linda <ref type="bibr" target="#b6">[6]</ref> is a shared memory model where the data is represented as elementary data structures called tuples and the memory is a multiset of tuples called a tuple space. Each tuple is a sequence of typed fields, such as "foo", 9, 27.5 and coordination among processes occurs through the writing and reading of tuples. Conceptually all processes have a handle to the tuple space and can add tuples by performing an out(t) operation and read and remove tuples using rd(p) and in(p) which specify a pattern, p, for the desired data. The pattern is a tuple whose fields contain either actuals or formals. Actuals are values; the fields of the previous tuple are all actuals, while the last two fields of "foo", ?integer, ?float are formals. Formals act like "wild cards", and are matched against actuals when selecting a tuple from the tuple space. For instance, the pattern above matches the tuple defined earlier. If multiple tuples match a pattern, the one returned by in or rd is selected nondeterministically. One typical extension is a pair of primitives, ing and rdg, used to retrieve all matching tuples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">LIME: Linda in a Mobile Environment</head><p>To support mobility, the LIME <ref type="bibr" target="#b12">[12]</ref> model breaks up the Linda tuple space into multiple tuple spaces each permanently attached to a mobile component, and defines rules for the sharing of their contents when components are able to communicate. The union of all the tuple spaces, based on connectivity, yields a dynamically changing federated tuple space. Access to the federated tuple space remains very similar to Linda, with each application component issuing Linda operations on its own tuple space. The semantics of the operations, however, is as if they were executed over a single tuple space containing the tuples of all connected components.</p><p>Besides transient sharing, LIME adds two new notions to Linda: tuple locations and reactions. Although tuples are accessible to all connected hosts, each exists only at a single point in the system, with one of the mobile components. When a tuple is inserted, it remains in the tuple space of the outputting application component. LIME also allows tuples to be shipped to another host by extending the out operation to include a destination. Reactions allow an application to register a code fragment (a listener) to be executed asynchronously whenever a tuple matching a particular pattern is found anywhere in the federated tuple space. This feature is very useful in the highly dynamic mobile environment, as it frees the programmer from the burden of explicitly monitoring the system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">THE TEENYLIME MODEL</head><p>As previously stated, TeenyLIME targets a scenario in which all WSN components participate in the computation without relying on an external base station. Applications exhibiting such behavior include those where actuators collect information from neighboring sensors and perform some action based on the value returned <ref type="bibr" target="#b2">[2]</ref>.</p><p>This need for coordination among peer devices mimics the coordination supported by LIME, thus it is natural to adopt the transiently shared tuple space as the core abstraction of TeenyLIME. The coordination operations in TeenyLIME are essentially those of LIME, including operations to insert, read, remove, and react-to tuples. TeenyLIME tuple spaces are physically located on the devices themselves but unlike LIME they are shared only with onehop neighbors. Because each device has a different set of one-hop neighbors, the shared tuple space view is different for each device. This is fundamentally in contrast to LIME in which the view of the transiently shared tuple space is composed of the tuple spaces of all connected hosts, and connectivity is assumed transitive.</p><p>In general, limiting the scope of operations to one hop is natural for many WSN applications that need access to nearby information. For example, a fire extinguisher can make a local decision to activate based only on readings from several sensors in its vicinity, and inform other nearby extinguishers after it activates. Activation can be effected by installing a reaction on neighboring sensors for temperature readings. When sufficiently many high readings are received, the extinguisher should be activated. Notification to the other extinguishers in the area can be handled by outputting a "notification" tuple to their tuple space.</p><p>The information about which devices are currently directly reachable is stored in a special tuple space called TeenyLIME system, providing a single unified abstraction for representing both the application and system context. This is similar to the LimeSystem tuple space of LIME that reports which hosts are currently sharing tuple spaces, although the TeenyLIME system supports weaker semantics, as explained in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">THE TEENYLIME API</head><p>TeenyLIME is implemented on top of TinyOS <ref type="bibr" target="#b7">[7]</ref>. Figure <ref type="figure">1</ref> shows the nesC interface the application uses (in the TinyOS sense) to access the transiently shared tuple space composed of the local tuple space and that of the one-hop neighbors. The first parameter of each nesC command requires a target, a specification of the tuple space repositories in the federation over which the operation should execute. Possible values restrict the scope of the operation to the local tuple space (indicated with TL LOCAL), the tuple space hosted by a specific one-hop neighbor (indicated with the address of the device), the union of all tuple spaces hosted by one-hop neighbors (TL NEIGHBORHOOD), or the latter plus the local tuple space (TL ANY).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Concurrency</head><p>In TeenyLIME, all read/write operations are asynchronous, allowing the application to continue while the middleware completes a tuple space operation. This approach blends well with the nesC event-driven concurrency model. Therefore, all read operations are split-phase <ref type="bibr" target="#b4">[4]</ref>: first the operation is issued, then the tupleReady event is signaled when the operation completes. The return parameter for each operation is an identifier, or a special constant (TL OP FAIL) in case of error. The identifier and the data tuple(s) form the contents of the tupleReady event, allowing the application to associate the data with its earlier request. If multiple tuples are returned, the number parameter indicates how many.</p><p>Analogously, two asynchronous commands are offered to install or remove reactions, taking a pattern as the parameter. When matching data is present, the tupleReady event is signaled, returning the tuple that triggered the reaction along with the corresponding operation identifier.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Reliable Read/Write Operations</head><p>Typical WSN applications that focus on collecting sensor data are inherently state-less, as the core task is that of communicating sensor readings to a given collection point. Conversely, applications composed of tasks that affect the environment often require stateful coordination mechanisms, e.g., using current conditions (state) to act collaboratively. This poses more stringent requirements on the consistency of state, and consequently on the reliability of operations on the tuple space. To address both scenarios, the commands to perform read or write operations can be issued as either unreliable or reliable, using a flag. The former operations do not provide any guarantee on their successful completion, thus yielding a lightweight form of communication that is suited for state-less applications. Instead, reliable operations offer stronger guarantees at the price of higher resource consumption, allowing them to be used for coordination purposes, e.g., to implement control loops based on the representation of the current state of the environment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Freshness</head><p>Sensor data is inherently time sensitive, a dimension that is even more important when actions must be taken based on the values themselves. For instance, a temperature reading might require dif- The first customizes a pattern to impose the additional constraint to match tuples no more than freshness epochs old 1 . Conversely, getFreshness(tuple) returns the number of epochs that elapsed since the tuple was created.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Range Matching</head><p>While the standard matching semantics of LIME discussed in Section 2 suffice for basic coordination, some WSN applications require additional expressive power. For example, a fire extinguisher application only needs to obtain temperature readings above a safety threshold. However, using the standard matching semantics based on exact values, we must issue a reaction over the neighborhood with a pattern matching any temperature reading and filter the results when they arrive. This causes unnecessary communication when data is discarded upon arrival, therefore TeenyLIME extends patterns to support range matching. For example, the reaction can be issued stating that the field representing the temperature value must be greater than a given value.</p><p>Figure <ref type="figure">2</ref> illustrates how this is achieved with TeenyLIME. In addition to the usual formal and actual tuple fields, patterns can also contain customized fields whose matching semantics account for (bounded or unbounded) intervals. Figure <ref type="figure">2</ref> specifies that a tuple matches the pattern when the first field is equal to the constant 1 If a pattern does not specify freshness, it matches any tuple regardless of its timestamp.  TEMPERATURE, and the second field is an integer value above 30. This mechanism is easily extensible because the matching semantics is decoupled w.r.t. distribution mechanisms. A developer needing alternate matching semantics must only define two functions: one creating a customized field for patterns, and one defining the conditions for an actual value to match the customized field.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Capability Tuples</head><p>Consider a small modification of the aforementioned scenario, namely a device needing to read a single temperature value from a nearby device. For the pattern to find a match, at least one tuple must be present in the tuple space of the neighboring nodes at the time the rd(p) operation is issued. Therefore, because a device cannot predict when a rd operation will be issued, any sensor that can produce a temperature reading is forced to periodically take fresh readings, and proactively output the values in the local tuple space even if no device is currently interested in them. This clearly constitutes a waste of resources.</p><p>To manage this problem, TeenyLIME developers are given the ability to output capability tuples, as illustrated in Figure <ref type="figure" target="#fig_0">3</ref>, indicating that a device has the capability to produce data of a given pattern. From the point of the view of the application performing a query (e.g., for TEMPERATURE, ?integer ) nothing changes: a matching tuple containing a temperature value is returned by raising a tupleReady event. Behind the scenes, however, the processing occurring at the device hosting the capability tuple is different from the normal one. A capability tuple enjoys the same matching semantics as a normal tuple, but is not returned directly as a result. Instead, it essentially works as a placeholder for the real data. A positive match triggers the event reifyCapabilityTuple, which reports the matched capability tuple to the application running on the device hosting it. The application can then perform the operation associated with it (e.g., reading the current temperature), build a tuple on the fly, and output it to the tuple space. TeenyLIME takes care of returning the tuple to the querying node as the result of the read operation.</p><p>Our original concept for capability tuples was to act as placeholders for real data, providing a mechanism to reduce the number of sensor readings to those strictly needed to answer queries. However, the concept naturally generalizes yielding a powerful abstraction. Consider that with a capability tuple a device triggers the execution of a set of operations on a neighboring device merely by issuing a query matching the pattern of the capability tuple. This set of operations can be more general than simply taking a sensor reading. For example, a programmer could define a capability tuple representing its ability to average some sensor readings taken over a given time period. When a rd(p) operation is issued with a pattern matching this average capability tuple, the corresponding function is triggered and the result returned. Additionally, actual values in the pattern can be used as parameters, further customizing execution, e.g., to specify the desired time period in this example.</p><p>To exploit this general capability function feature, the developer simply defines a suitable capability tuple and the function to be called when the corresponding reifyCapabilityTuple event is raised. The result of the function is placed in a tuple, stored in the tuple space, and returned to the calling device.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">TeenyLIME System</head><p>As previously mentioned, the system context is represented and accessible in TeenyLIME in the same way as application data, i.e., as tuples. In particular, TeenyLIME automatically provides access to the current neighbor set by storing a NeighborTuple for each device in range. The content of this tuple is defined by the application developer, allowing customization to include information such as the current location and/or the remaining energy. To keep the information up to date, the system periodically signals a reifyDeviceInfo event, which the application should handle by locally outputting a new version of its NeighborTuple. If the event is ignored, TeenyLIME keeps the previous tuple <ref type="foot" target="#foot_0">2</ref> .</p><p>The mechanisms for populating the TeenyLIME System are described next, along with the design underlying the rest of the API.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">THE TEENYLIME ARCHITECTURE</head><p>The overall architecture of TeenyLIME is depicted in Figure <ref type="figure" target="#fig_1">4</ref>. It consists of three TinyOS components wired together in the Teeny-LIME configuration. This is the only nesC component the application must include to access the TeenyLIME system through the aforementioned TupleSpace interface. In this configuration, the TupleSpaceM component takes care of delegating the actual operation to either the LocalTeenyLIME or the Distribu-tedTeenyLIME component, depending on the scope of the re-quested operation. This supports a separation of concerns allowing independent customization of the two orthogonal aspects of Teeny-LIME: local storage and distributed processing.</p><p>The LocalTeenyLIME component stores the tuples output to the local tuple space, and performs the actual matching process for query operations. This component is connected to the rest of Teeny-LIME through the LocalTupleSpace interface, which mirrors the TupleSpace interface without specifying an explicit target for the operation. In addition, LocalTeenyLIME takes care of storing reactions installed on the local tuple space, matching reactions against newly arrived tuples, and handling capability tuples. The latter are stored within the LocalTeenyLIME component as any other tuple. However, when a request matching such a tuple arrives and the application outputs the real tuple, the capability tuple is not removed from the local tuple space. When further requests arrive for the same capability tuple, the LocalTeenyLIME returns the real tuple if it meets the freshness requirement in the pattern. Otherwise, it asks the application again for a real tuple.</p><p>The DistributedTeenyLIME component is in charge of implementing the operations whose scope is different from the local device. To this end, we define a suitable encoding of operations and parameters into standard TinyOS messages. For unreliable operations, no additional network-level mechanism is required above the basic functionality provided by the TinyOS GenericComm module. To implement the out(t) operation, the tuple is packed in a message and sent to a specific target. Instead, the rd(p) and in(p) operations are realized by sending a message containing the pattern. In this case, the DistributedTeenyLIME component on the receiving side delegates the matching process to Local-TeenyLIME. This returns any matching tuple to Distributed-TeenyLIME by signalling a tupleReady event through the Lo-calTupleSpace interface connecting the two.</p><p>To implement reliable operations we are exploring what mechanisms can be borrowed from existing WSN proposals for reliable transport (e.g., <ref type="bibr" target="#b13">[13]</ref>). In doing so, we are not limiting ourselves to simply reusing established solutions. The application scenarios we target-composed of localized, distributed interactions-and the specific patterns of query-reply operations of the tuple space abstraction are likely to require specific adaptations and extensions to be used effectively. An extensive study of these mechanisms and possible extensions is currently under way.</p><p>Reactions on remote devices are realized within the Distri-butedTeenyLIME component using a soft-state approach, i.e., they are periodically refreshed. This mechanism has been used extensively in WSN (e.g., in <ref type="bibr" target="#b8">[8]</ref>) and naturally accounts for devices dynamically joining or leaving. Indeed, if some device joins the neighborhood after the addReaction command has been issued, it is likely to receive the reaction in a later refresh message. Conversely, if some node leaves, the reactions expire after a timeout.</p><p>Finally, the management of the TeenyLIME system, composed of tuples representing the devices in range, is carried out by passively listening for messages from neighboring devices. A message always contains the NeighborTuple of the sending device, which is used to populate the TeenyLIME system of the devices overhearing it. At start-up, a device wishing to advertise its presence and also gather information on its neighbors can simply issue a rdg operation for tuples of type NeighborTuple. This avoids periodic broadcasting of identification information, a waste of resources for devices not actively involved in any processing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">APPLYING TEENYLIME</head><p>Most existing middleware for WSNs target specific use cases, limiting their re-usability. As one of the primary motivations for middleware development is the reliability that comes from reuse, this is a major limitation. TeenyLIME, instead, enjoys wide applicability because the tuple space paradigm, enhanced with reactions, supports a wide range of possible applications. To support this claim, this section outlines several ways of applying TeenyLIME, along with motivating application scenarios.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Reading Sensor Data</head><p>TeenyLIME can be naturally used as a high-level interface to gather sensor readings. The expressiveness given by range matching, together with the energy-aware mechanism of capability tuples, enables flexible, efficient data logging using TeenyLIME.</p><p>Sensed data can be locally stored as tuples, and made available for time-aware queries from neighboring devices, using the freshness mechanism. Alternately, sensor readings can be used for localized, collaborative tasks such as in sensing/acting applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Multi-hop Communication</head><p>Although TeenyLIME enables direct interactions only among neighboring devices, its model and implementation allows the implementation of multi-hop communication in terms of single-hop operations and reactions.</p><p>As an example, consider a simplified location-based routing protocol that routes to a given physical location. Thanks to the Teeny-LIME system, each node can include its location inside its Nei-ghborTuple. Sending a packet is as simple as wrapping the data and the destination location in a tuple, and inserting it into the local tuple space. This triggers a locally-installed reaction to remove the tuple, and query the TeenyLIME system for the neighbor closest to the destination. Such a query can be done using a rd operation with a pattern matching tuples of type NeighborTuple. Once the closest neighbor to the destination is determined, the data tuple is written, using out, with the target set to that neighbor. Assuming each device installs a similar local reaction, the tuple will propagate towards the destination <ref type="foot" target="#foot_1">3</ref> . The latter is recognized by checking that no neighbor closer to the destination exists.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Remote Function Invocation</head><p>Capability tuples provide a way to implement rich interaction patterns beyond the simple sense-and-send functionality of traditional WSN applications. They can be used to request some processing on a set of tuples and have a single value returned, as shown by the average function in Section 4. Alternately, capability tuples also offer a means to request a node to perform some actions.</p><p>In a sensing/acting application, commanding actuator nodes remotely requires the application developer to implement explicitly the (distributed) processing needed to encode in messages the required operation and its parameters, and parse these messages on the receiver side to perform the corresponding operation. Teeny-LIME enables the same behavior with a higher level of abstraction. Simply, an actuator node locally outputs a capability tuple for each actuator it is connected to. When this capability tuple is matched by a remote query, the application is notified through the reifyCapabilityTuple event, which is interpreted as a request to operate the actuator with the parameters contained in the query pattern. This way, the programmer abstracts away the distribution aspects, and concentrates on the operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Coordination</head><p>In general, coordination implies a separation of concerns between application functionality and communication constructs. In TeenyLIME, we can easily support localized coordination through the data sharing abstraction and the ability to install reactions on neighboring hosts. This can be useful to implement collaborative tasks and decentralized algorithms. For instance, in object tracking applications the nodes currently sensing a moving object must coordinate to elect a leader, that triangulates the position of the tracked entity <ref type="bibr" target="#b1">[1]</ref>. This is achieved easily in TeenyLIME: each device registers a reaction on its neighbors for tuples representing a moving object. Whenever a device recognize the presence of such an object, it outputs the corresponding information in its local tuple space. This triggers the aforementioned reaction, notifying the neighbors about the detected object. Under common assumptions for object tracking applications <ref type="foot" target="#foot_2">4</ref> and within an application-defined timeout, the set of devices sensing the target constitutes a clique. Electing a leader from this set is trivial, e.g., selecting the device with the most recent measurement, according to the freshness field of the tuple.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Node and Service Discovery</head><p>The tuple space abstraction provided by TeenyLIME enables a simple and yet effective solution for node and service discovery. The set of nodes in range is automatically managed by the Teeny-LIME system, and highly customizable using the appropriate NeighborTuple. Similarly, the tuple abstraction provides a general way to describe any service a device can offer, e.g., the list of actuators and sensors on board, or the functions available for remote invocation. Node (service) discovery is implemented by performing a rdg operation, discovering the nodes (services) available in the neighborhood. Alternately, the reaction mechanism can announce when a node (service) becomes available.</p><p>These mechanisms can be effectively employed to deal with the addition of new nodes and the related problem of sensing coverage <ref type="bibr" target="#b10">[10]</ref>. Consider a WSN composed of nodes with either seismic or acoustic sensors. When new nodes are added to replace failed ones, they must discover each other and adjust their sensing ranges and periods to guarantee a minimal quality of service. For instance, each point in space must be covered by at least one seismic and one acoustic sensor at all times. An algorithm to perform this distributed adaptation is easily encoded in TeenyLIME. Simply, each node augments its NeighborTuple with its position, current schedule, and installed sensors. At start-up, a new node performs a rdg for tuples of type NeighborTuple to discover nodes and their services, i.e., installed sensors. In doing this, the new device also makes explicit its presence, which is automatically reflected in the TeenyLIME system of the existing devices. A previously installed reaction on the local tuple space of these devices notifies the application of the appearance of a new neighbor. At this point, each device has enough information to reschedule its sensing period and/or adjust the sensing range.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">RELATED WORK</head><p>The work most closely related to TeenyLIME is Hood <ref type="bibr" target="#b15">[15]</ref>. In this work, each node has access to a local cache of attributes of interest provided by neighboring nodes. Therefore, data flows proactively according to a many-to-one paradigm. The current implementation considers one-hop neighbors and is based on periodic broadcasting of all node attributes and filtering on the receiver's side. Conversely, TeenyLIME provides a more general programming model encompassing both proactive and reactive operations. In addition, the ability to express different devices as targets en-ables also the one-to-many and many-to-many communication paradigms. At the network layer, no periodic broadcasting is built into TeenyLIME. Rather, the programmer is given the freedom to explore the trade-offs between reliability and resource consumption, according to the semantics of each operation.</p><p>Context Shadow <ref type="bibr">[9]</ref> exploits multiple tuple spaces, each hosting only locally sensed information. This way, the system is able to provide contextual information, at the price of increased application complexity. Indeed, the application is required to explicitly connect with the tuple space of interest to retrieve the corresponding information. Conversely, context in TeenyLIME can be managed in a more natural way using the TeenyLIME system, according to the application-defined information provided by each device.</p><p>Agilla <ref type="bibr" target="#b5">[5]</ref> is a mobile agent platform that uses tuple spaces for local coordination of co-located agents. Agents also interact with remote tuple spaces, which are nonetheless distinct. Conversely, TeenyLIME provides a higher level of abstraction, where data in a neighborhood is transiently shared, and perceived as belonging to a single memory space. Furthermore, capability tuples and the TeenyLIME system give the programmer flexible mechanisms to address specific aspects of WSNs, e.g., energy management.</p><p>Abstract Regions <ref type="bibr" target="#b14">[14]</ref> proposes a model reminiscent of tuple spaces to enable communication among the nodes in a region (i.e., a set of geographically related nodes). However, the model is fairly limited, as only synchronous read/write operations on key, value pairs are allowed. Differently from TeenyLIME, the programmer has no way to be notified when some particular data appears in the system. From an implementation perspective, the nodes belonging to a region can communicate despite being multiple hops away. However, each particular region requires a dedicated implementation. Therefore, their applicability is rather limited.</p><p>Our prior research has explored tuple spaces in both MANET and WSN. TeenyLIME itself is inspired by LIME <ref type="bibr" target="#b12">[12]</ref>, which introduced federated tuple spaces in MANETs. Compared to LIME, TeenyLIME introduces novel features specifically targeted to WSNs, e.g., one hop operations, range matching, and capability tuples. In addition, the system has been completely re-engineered to fit the event-based programming model of TinyOS, in contrast to LIME's Java implementation. Instead, TinyLIME <ref type="bibr" target="#b3">[3]</ref> targets sensor networks where mobile PDAs are the main consumers of data from their immediate vicinity. Here, tuple spaces do not span the sensor devices, which are instead relegated to the role of data producers. Conversely, TeenyLIME applications are deployed directly on the WSN devices, which play an active distributed coordination role even with no base stations in the system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUSIONS</head><p>In this paper we outlined TeenyLIME, a model and middleware for WSNs. The abstraction available to the TeenyLIME programmer is that of a shared tuple space formed by the union of the data of the local device and the one-hop neighbors. Our future plans include refinement of the implementation to efficiently support reliable operations. Although our initial investigations clearly demonstrate the versatility of TeenyLIME to support a wide range of applications, we also plan to extensively evaluate both qualitatively and quantitatively the advantages brought by TeenyLIME to the application developers, e.g., in terms of code complexity and inter-component dependencies.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Outputting a capability tuple for temperature readings.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: TeenyLIME architecture. (Timer components omitted).</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>The programmer is required at system start-up to provide a tuple identifying the local device, thus if the reifyDeviceInfo event is always ignored, the device will still have a NeighborTuple.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>We do not solve here the local minima problem of position-based routing. Nonetheless, such mechanisms can be added easily.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>Usually, one assumes to have the communication range at least twice the sensing range<ref type="bibr" target="#b1">[1]</ref>.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements. The authors wish to thank Fabrizio Bonfanti for his contribution to the first implementation of TeenyLIME. The work described in this paper was partially supported by the European Community under the IST-004536 RUNES project, by the European Science Foundation (ESF) under the MINEMA project, and by the National Competence Center in Research on Mobile Information and Communication Systems (NCCR-MICS), a center supported by the Swiss National Science Foundation under grant number 5005-67322.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Envirotrack: Towards an environmental computing paradigm for distributed sensor networks</title>
		<author>
			<persName><forename type="first">T</forename><surname>Abdelzaher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 24 th Int. Conf. on Distributed Computing Systems</title>
		<meeting>of the 24 th Int. Conf. on Distributed Computing Systems</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Wireless sensor and actor networks: Research challenges</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">F</forename><surname>Akyildiz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">H</forename><surname>Kasimoglu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ad Hoc Networks Journal</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="351" to="367" />
			<date type="published" when="2004-10">October 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Mobile data collection in sensor networks: The TINYLIME Middleware</title>
		<author>
			<persName><forename type="first">C</forename><surname>Curino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Giani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Giorgetta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Giusti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Murphy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">P</forename><surname>Picco</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pervasive and Mobile Computing Journal</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="446" to="469" />
			<date type="published" when="2005-12">Dec. 2005</date>
			<publisher>Elsevier</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The NesC language: A holistic approach to networked embedded systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Gay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Levis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Von Behren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the ACM SIGPLAN 2003 Conf. on Programming Language Design and Implementation</title>
		<meeting>of the ACM SIGPLAN 2003 Conf. on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Rapid development and flexible deployment of adaptive wireless sensor network applications</title>
		<author>
			<persName><forename type="first">C.-L</forename><surname>Fok</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G.-C</forename><surname>Roman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 25 th IEEE Int. Conf. on Distributed Computing Systems (ICDCS)</title>
		<meeting>of the 25 th IEEE Int. Conf. on Distributed Computing Systems (ICDCS)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Generative communication in Linda</title>
		<author>
			<persName><forename type="first">D</forename><surname>Gelernter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="80" to="112" />
			<date type="published" when="1985-01">January 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">System architecture directions for network sensors</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 9 th Int. Conf. on Architectural Support for Programming Languages and Operating Systems</title>
		<meeting>of the 9 th Int. Conf. on Architectural Support for Programming Languages and Operating Systems</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Directed Diffusion: A scalable and robust communication paradigm for sensor networks</title>
		<author>
			<persName><forename type="first">C</forename><surname>Intanagonwiwat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Govindan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Estrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 6 th Int. Conf. on Mobile Computing and Networks (MobiCom)</title>
		<meeting>of the 6 th Int. Conf. on Mobile Computing and Networks (MobiCom)</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Supporting context awareness with the context shadow infrastructure</title>
		<author>
			<persName><forename type="first">M</forename><surname>Jonsson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Wkshp. on Affordable Wireless Services and Infrastructure</title>
		<imprint>
			<date type="published" when="2003-06">June 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Coverage problems in wireless ad-hoc sensor networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Meguerduchian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Koushanfar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Potkonjak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">B</forename><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 20 th Int. Conf. on Computer Communications (INFOCOM)</title>
		<meeting>of the 20 th Int. Conf. on Computer Communications (INFOCOM)</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Transiently Shared Tuple Spaces for Sensor Networks</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Murphy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">P</forename><surname>Picco</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Euro-American Workshop on Middleware for Sensor Networks</title>
		<meeting>of the Euro-American Workshop on Middleware for Sensor Networks</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">LIME: A Coordination Model and Middleware Supporting Mobility of Hosts and Agents</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Murphy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">P</forename><surname>Picco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G.-C</forename><surname>Roman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Software Engineering and Methodology</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Reliable transport for sensor networks: PSFQ-Pump slowly fetch quickly paradigm. Wireless sensor networks</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">Y</forename><surname>Wan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">T</forename><surname>Campbell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Programming sensor networks using abstract regions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Welsh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Mainland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 1 st Symp. on Networked Systems Design and Implementation</title>
		<meeting>of the 1 st Symp. on Networked Systems Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Hood: A neighborhood abstraction for sensor networks</title>
		<author>
			<persName><forename type="first">K</forename><surname>Whitehouse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sharp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Brewer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Culler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 2 nd Int. Conf. on Mobile systems, applications, and services</title>
		<meeting>of 2 nd Int. Conf. on Mobile systems, applications, and services</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
