<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Constraint Solving for Bounded-Process Cryptographic Protocol Analysis</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Jonathan</forename><surname>Millen</surname></persName>
							<email>millen@csl.sri.com</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Laboratory</orgName>
								<orgName type="institution">SRI International</orgName>
								<address>
									<postCode>94025</postCode>
									<settlement>Menlo Park</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Vitaly</forename><surname>Shmatikov</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Laboratory</orgName>
								<orgName type="institution">SRI International</orgName>
								<address>
									<postCode>94025</postCode>
									<settlement>Menlo Park</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Constraint Solving for Bounded-Process Cryptographic Protocol Analysis</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">AEA9F715BE1AD5F47EC37FDDCD1E5FD0</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:58+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The reachability problem for cryptographic protocols with nonatomic keys can be solved via a simple constraint satisfaction procedure.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Many protocol security properties can be characterized as reachability problems. This is the case for properties such as secrecy, where the objective of protocol analysis is to search for a state that violates a particular invariant, such as a state in which some secret data has been released publicly by an attacker or dishonest party.</p><p>It is known that reachability is undecidable for cryptographic protocols in the general case <ref type="bibr" target="#b9">[9,</ref><ref type="bibr" target="#b5">5]</ref>. Undecidability results from a context where the number of distinct processes instantiating protocol roles is unbounded, and there is an active attacker who can intercept and forge messages. It has been demonstrated that reachability is decidable for the finite number of processes <ref type="bibr" target="#b1">[1,</ref><ref type="bibr" target="#b13">13]</ref>.</p><p>The main contribution of this paper is to develop a complete and practical decision procedure for the reachability problem in the presence of constructed (non-atomic) keys. Support for constructed keys is important for formal analysis of "real-world" protocols, as it is fairly common in protocol design to construct symmetric keys from shared secrets and other data exchanged as part of the protocol -see, for example, SSL 3.0 <ref type="bibr" target="#b7">[7]</ref>. Some of the techniques for constructing symmetric keys involve commutative operators such as xor or Diffie-Hellman exponentiation, and thus lie beyond the scope of the unmodified free-algebra approach as taken in this paper.</p><p>We show how to convert the reachability problem into a constraint solving problem and present a relatively simple decision algorithm for the latter that is easy to understand and justify. The algorithm is sound and complete. We use the standard Dolev-Yao attacker model with a free term algebra for messages, and do not impose any bounds on the size of terms or cryptographic function applications by the attacker. Our cryptographic primitives include symmetric-key encryption with arbitrary non-atomic keys, publickey encryption, signatures, and hashes. There is a small, fast Prolog implementation.</p><p>Related work. Formal methods have been extensively applied to security protocol analysis. Typically, the tradeoff is between incompleteness (e.g., for finite-state checking, it is necessary to impose a bound on both attacker capabilities and number of protocol instances) and possible non-termination (e.g., in many methods based on theorem proving). Our work is closest in spirit to the approaches that use symbolic techniques to enumerate the infinite state space generated by a limited number of participants.</p><p>Huima <ref type="bibr" target="#b10">[10]</ref> developed a method for symbolic state-space exploration, using a term algebra with canonical reductions (e.g., decryption cancels encryption). Completeness was claimed but full details of the decision algorithm were not in the workshop paper, and, to the best of our knowledge, never published.</p><p>Amadio, Lugiez, and Vanackère <ref type="bibr" target="#b1">[1,</ref><ref type="bibr" target="#b2">2]</ref> also use symbolic techniques to characterize the unbounded set of possible messages generated by the attacker. These techniques are similar to ours in that they combine the use of variables in message schemas and constraints defining the allowable set of substitutions for those variables. Amadio et al. proved decidability in the bounded-process case, but only for atomic encryption keys (with variables in key positions handled by exhaustive substitutions) and using a simpler free term algebra. Fiore and Abadi <ref type="bibr" target="#b6">[6]</ref> and Boreale <ref type="bibr" target="#b3">[3]</ref> present algorithms for computing symbolic traces of infinite-state cryptographic protocols. Both methods are technically involved, and, in <ref type="bibr" target="#b6">[6]</ref>, completeness is proved only for atomic keys. Rusinowitch and Turuani <ref type="bibr" target="#b13">[13]</ref> show the problem to be NP-complete with a free term algebra and constructed keys.</p><p>Our use of the strand space model is similar to that of Athena <ref type="bibr" target="#b14">[14]</ref>. Athena, however, only supports atomic keys. Another difference is that Athena uses penetrator strands as specified in the original strand space model, while in our approach, no penetrator strands are constructed. Instead, we use a term closure operator based on message constructors, similar to Paulson's synth and analz <ref type="bibr" target="#b12">[12]</ref>, to characterize attacker capabilities. The result is an extremely concise representation of the problem and a clean transition from the process aspects of the protocol model to a pure constraintsolving problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PROTOCOL MODEL</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Parametric strands and reachability</head><p>Protocol roles are specified with parametric strands, in which message terms may contain variables. Different strands are distinguished by different values for the set of variables (parameters) associated with a role. For example, the initiator role of Lowe's fixed version of the Needham-Schroeder public-key protocol handshake (NSL) <ref type="bibr" target="#b11">[11]</ref> can be specified as:</p><p>Init ¢¡ ¤£ ¦¥ §£ ¦© £ ¦¤ ¡ £ ¨© ! #" $ &amp;% (' 0) 01 ¨© £ ¦¨ £ ¦¥ #" $ &amp;% 2' © 3) 4 ¨ 5 #" $ &amp;% 2' 0)</p><p>The responder role Resp ¢¡ £ ¦¥ §£ ¤© 6£ ¦¤ is the same except that and 1 are interchanged.</p><p>The notation above uses 7 8" $ &amp;% 2' © 3) for public-key encryption of 7 using the public key of principal ¡ . The signs and 1 denote messages sent and received, respectively, and a sent message is called a node. Term variables in messages are denoted by capital letters. The protocol as given above is actually slightly different from Lowe's; the first message in the original is ¤© 6£ ¦¡ " $ &amp;% 2' 0) , with the nonce first in the encrypted field. This apparently inconsequential difference leads to an attack, as shown below in Section 6.</p><p>Our constraint solving procedure analyzes a set of parametric strands, in which some of the parameters may be instantiated by constants. A set of parametric strands is called a semibundle in the Athena paper <ref type="bibr" target="#b14">[14]</ref>. The sequence of nodes in each strand of a semibundle implicitly specifies the state sequencing relation 9 in the strand space model. Thus, for example, @ Init ¢¡ ¤£ ¦¥ §£ ¦© £ ¦¤ 6 A£ Resp ¢¡ CB D£ ¦¥ B ¢£ ¦ËB© £ ËB ¦F is a semibundle. A strand in a semibundle need not be complete; it may be an initial subsequence of the full node sequence of a role.</p><p>A semibundle can be completed to a bundle by supplying the attacker computations and the communication causality relation G between received messages and sent messages. Completion of a semibundle implies that the network state described by the bundle is reachable from an empty initial state. Some semibundles are not completable. The task of reachability analysis is to determine whether a semibundle is completable or not, and, if so, what substitution (instantiating the semibundle variables) is necessary to make it possible. The representation of security attacks as bundles is discussed in Section 2.4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">The term algebra</head><p>Messages and message fields are represented as terms in a free algebra generated by the operators in Fig. <ref type="figure">1</ref> from a finite set of symbolic constants. We do not distinguish different types of constants, e.g., nonces, keys, and principal names, but such types could be introduced if desired. Analysis of particular semibundles will dictate how many distinct constants are needed. One particular constant is always available, the name of the attacker, H .</p><p>The term algebra allows any term to be used as an encryption key both for public-key and symmetric encryption. We make, however, a (fairly realistic) assumption that private keys are never leaked. Also, while the model supports constructed keys, the only construction operators that can be used are those, such as hashing, that can be expressed in a free term algebra. Support for operators with associative and commutative properties such as xor, explicit decryption operators, and relaxing the secure private keys assumption will require us to add an equational theory to the term algebra. This is a topic of current research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>H</head><p>The attacker or a principal compromised by the attacker (constant)</p><formula xml:id="formula_0">I QP £ I R</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Pairing pk ¢S</head><p>Messages encrypted with this public key can be decrypted by S using its corresponding private key. We assume that the private key of a publicprivate key pair is never transmitted as part of the protocol, or compromised in any way that might make it available as initial knowledge of the attacker. Therefore, the attacker can only decrypt terms encrypted with its own public key T VU W XH Y .</p><p>` I</p><p>Hash (modeled as a one-way function)</p><formula xml:id="formula_1">I #a b</formula><p>Term I encrypted with c using a symmetric algorithm. Keys are not required to be atomic terms. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">The attacker model</head><p>In strand space models, attacker computations are represented by penetrator strands. In this paper, we use a term set closure operation, instead, to characterize attacker capabilities. Given a time ordering of nodes consistent with 9 , a minus node is realizable iff its message can be synthesized by the attacker from the set of messages sent in prior plus nodes. A semibundle is completable iff it has a node ordering in which every minus node is realizable.</p><p>We use the standard Dolev-Yao model for attacker computations. The attacker can simply pass along a sent message, or construct a new message by decomposing the previously sent messages into their parts and recombining those parts.</p><p>In the following definition we assume that i is a set of ground terms. If I is a term and p is a set of terms, we write p rq I rather than p sq @ I F to avoid notational clutter, since it is unambiguous. The fake operation t s 8i u is defined as the smallest set p containing i and closed under the following term set operators: Analysis Encryption hiding operators are a technical device needed to support analysis of constructed keys. They are explained in more detail in sections 4 and 5.</p><p>A v operator can be applied to a term set whenever the set contains a "target" term with the appropriate structure. One can show that t is a closure operation: it is idempotent, monotonic (with respect to set inclusion), and extensive (a set is a subset of its closure). t characterizes attacker capabilities in the sense that, for any non-empty term set i , t 8i u is the (infinite) set of terms that can be constructed by the attacker from i . A received message ¡ can be synthesized from a set i of sent messages if and only if it can be derived through t , i.e., ¡ y v £¢ gf &amp;f Qf v P 8i u for some <ref type="bibr" target="#b12">[12]</ref>, t 8i u could be expressed as synth analz 8i u where synth and analz are, respectively, sequences of ¤ synth and ¤ analz operators, but this formula is not general enough when keys can be constructed. Consider, for example, i ¥ a ¦ ' ¨ § ) q © where ¥ y t 8i u but ¥ y synth analz 8i u . It is important to keep in mind that the characterization of the attacker capability as t E 8i works only when <ref type="bibr" target="#b1">(1)</ref> i is a set of ground terms, and (2) we have chosen a time ordering of nodes to establish which sent messages are "prior" to a received message and are therefore included in i .</p><formula xml:id="formula_2">v P £ &amp;f &amp;f &amp;f 3£ v £¢ . Define ¤ synth @ v pair £ v penc £ v senc £ v hash £ v sig F , and ¤ analz @ v split £ v pdec £ v sdec F . In Paulson's method</formula><p>It is not difficult to see how any operator assumed available to the Dolev-Yao attacker can be represented either as one of the v term set operators in the definition of t , or a penetrator strand in the conventional strand space model. The formal presentation of the attacker model does not, in itself, imply any difference in attacker capabilities between the term closure approach and the penetrator strand approach. With respect to the class of attacks that can be represented as a reachability problem for an instantiation of a single protocol trace (e.g., secrecy and authentication), the two approaches are equivalent -if an attack can be discovered by one, it can be discovered by the other. Moreover, our model supports "programmable" attacker capabilities by changing v operators in a way that is similar to penetrator strands. Extending the model with new message term constructors and corresponding v operators will, however, affect our ability to solve the generated constraint sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Secrecy and authentication goals</head><p>A secrecy goal states that some designated message should not be made public. Compromise of a secret message can be detected by adding an artificial secret reception strand to the semibundle. In the case of NSL, if the responder wants to keep ¨B secret, we would add the one-node strand 1 ¨B to the semibundle. Then the problem of determining whether the secret is compromised is equivalent to deciding if the semibundle with the secret reception strand is reachable (completable in our terminology).</p><p>Secrecy is violated if the secret is made public at any time, not just after all honest strands have completed normally. Thus, to analyze secrecy, one must consider semibundles in which role strands terminate prematurely. "Secret" is a relative term, in the sense that there is no security violation if a "secret" is generated by, or knowingly given to, the attacker. In order to associate a secret with honest principals, we instantiate the secret and the principals with symbolic constants. In the NSL example, we supply constants in the responder strand for the responder ¥ B © , the initiator ¡ B ¥ with whom © intends to share his secret, and the secret nonce ¨B § .</p><p>In proof terms, this is a skolemization step. A proof of reachability or non-reachability applies to all possible values of the constants, subject to the implicit assumption that constants with different names are unequal. Skolemization is used in general to in-stantiate a nonce in the strand that generates the nonce (or other session-specific data).</p><p>In strand space models, authentication is typically expressed as the unreachability of a bundle that contains a strand that receives a message to be authenticated but does not contain another legitimate strand that sends it <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b14">14]</ref>. A goal of this kind can be tested by a procedure to determine completability of semibundles that contain the authenticated strand but no authenticating strand.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">The origination assumption</head><p>In our model, strands in a semibundle satisfy the origination assumption, namely, that a variable always occurs for the first time in any strand in a minus node. This assumption helps us to state and prove secrecy goals, and it plays a role in proving completeness of the decision procedure. It is satisfied for nonces and session secrets because of skolemization. For non-secret session parameters, such as principals, we can make it true by prefixing a strand with an artificial received message containing the variables that would otherwise be sent first. Because they are variables, this does not constrain their values, and because they are not secret, exposing them in a message does no harm and does not, in principle, affect implementability of the attack.</p><p>In our NSL example, the initiator strand contains the variables ¡ for the initiator principal, and ¥ for the responder chosen by that principal. We add the node 1 ¡ ¤£ ¥ to the beginning of the node sequence, so that it satisfies the origination assumption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">CONSTRAINT GENERATION</head><p>Constraints are created from a node sequence consistent with the given semibundle, obtained by interleaving the strands in any of the possible ways. The result may be viewed as a singleton semibundle. For example, one possible merge of the NSL initiator and responder strands is:</p><formula xml:id="formula_3">1 ¡ ¤£ g¥ ¡ ¤£ 8" $ Q% (' ) 1 ¥ £ ¦¨© ! #" $ &amp;% (' § ) ¨© £ § £ © #" $ &amp;% 2' ) f &amp;f Qf f &amp;f 2f 1 £ ¨ £ h¥ " $ &amp;% &amp;' © 3) ¨ " $ Q% (' ) 1 §</formula><p>This node sequence includes the secret reception strand consisting of the single node 1 § , and omits the last responder node 1 § " $ &amp;% 2' ¨ § ) because it cannot affect the outcome.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Enumeration of interleavings</head><p>Different interleavings give rise to different constraint sets, and we attempt to solve each constraint set until we find one that has a solution or show that none of them are satisfiable. The number of possible interleaved node sequences can be very large. In general, the number of interleavings of a sequence of length ¡ and one of length (if the elements are distinct) is ! #" %$ ¢ " &amp; , yielding an exponential number of cases. However, it is not necessary to consider all possible interleavings, because some interleavings are dominated by others, in the sense that any solution to one is a solution to the other. Dominated interleavings are redundant, and an optimization technique would eliminate them. For example, one can show that once a send node is enabled, there is no need to consider interleavings in which it is delayed until after later send or receive nodes. With this optimization, the number of interleavings is determined by the number of receive nodes alone. Further optimizations are possible as well. Since there are cases where different interleavings lead to incompatible constraint sets with different solution characteristics, we must deal with particular interleavings (rather than just the partial order of nodes given by a semibundle) before proceeding to the constraint solving phase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Generation of a constraint set</head><p>A constraint is a pair ¡ ¡ i where ¡ is a term and i is a term set. The term set represents the set of messages known to the attacker. The constraint ¡ ¢ i asserts that the attacker must be able to synthesize term ¡ from the term set i .</p><p>A sequence of constraints and term sets is constructed from the sequence of nodes. Each plus node expands the last term set with its message, and each minus node creates a constraint ¡ ¢ i where ¡ is the message in the node and i is the last term set.</p><p>The first term set i ¤£ contains ground terms assumed known to the attacker. This should include constants representing principals, including at least the attacker's identity H , and their public keys, including at least T U W XH Y . For example, we could have</p><formula xml:id="formula_4">i £ = @ alice, bob, srv, H , pk(srv), T VU W XH ¦F or i ¤£ = @ ¥ £ © , pk( ¥ ), pk(© ), H , T VU W XH Y ¦F .</formula><p>The first example assumes that the server srv will deliver public keys on request, or that they are made available in the protocol through certificates or some other way so that they need not be known initially.</p><p>The node sequence above generates the following term sets and constraints:</p><formula xml:id="formula_5">¡ ¤£ ¦¥ i ¤£ C @ ¥ £ © £ H £ T U W XH Y ¦F ¥ £ h© " $ &amp;% (' § ) i P i £ q @ ¡ £ " $ &amp;% ' 0) F £ V£ ¨ £ h¥ #" $ &amp;% &amp;' © 3) i R i P q @ ¨© £ § £ © #" $ &amp;% 2' ) F § i ¤¥ C i R q @ ¨ " $ &amp;% 2' 0) F</formula><p>Note that the term sets are non-decreasing in this order, so that i ¤¦ § i ¤¦ $ P for all ¨. This is a special case of an invariant property called monotonicity in Section 5.1.</p><p>Let © be a substitution of ground terms for all the variables, and let @ ¡ ¦ i ¤¦ gF be a set of constraints. We say that © is a solution of , or © satisfies , if © by the definition © ¨ ¤© ¡ ¦ y t © 3i ¤¦ D Deciding satisfiability of the constraint set induced by the protocol requires reasoning about t sets that can be generated from a set of arbitrary terms, possibly involving variables.</p><p>As a shorthand, in the context of a particular , we'll write</p><formula xml:id="formula_6">i P i R if ( !© " # 5t © i P § t s © i R . If i P $ i R and i R ! i P , then i P &amp;% i R .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">SOLVING THE CONSTRAINT SET</head><p>In general, a constraint set is solved by the reduction procedure in which each application of a reduction rule replaces or eliminates some constraint. (We will often refer to a constraint sequence as a constraint set when we do not need to emphasize the ordering.) A sequence of reductions terminates successfully when the constraint set is reduced to a simple set, in which the left side of each remaining constraint, if any are left, is a variable. Such sets are always satisfiable (see section 4.4). A sequence of reductions can also terminate unsuccessfully by producing a constraint set that is neither simple, nor reducible.</p><p>A constraint set may be reducible in more than one way. The reduction procedure therefore creates a directed tree rooted in the initial constraint set '£ . Set '£ has a solution (i.e., there exists a successful attack on the protocol) if at least one path in the tree leads to a simple constraint set.</p><p>The reduction procedure is terminating, sound and complete, as proved in section 5. Therefore, substitution © is a solution of the initial constraint set if and only if it is a solution of the simple constraint set at the end of at least one path in the tree.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Reduction procedure</head><p>A reduction tree has reduction states containing constraint sets as nodes, and instances of reduction rules as edges. The root of the tree is the initial constraint set induced by the protocol. The reduction tree is created by the reduction procedure P in Fig. <ref type="figure" target="#fig_1">2</ref> where (elim) is the variable elimination rule (see section 4.2) and 3 is the set of reduction rules (see section 4.3).</p><p>Procedure P finds the first constraint where the left side ¡ is not a variable ( ¡ may contain variables inside terms). We will call the constraint selected by P active. It then applies rule (elim) repeatedly to remove all standalone variables from the term set on the right side of the active constraint. Then one reduction rule is applied, and the procedure is repeated. If more than one rule is applicable to the active constraint, the reduction tree branches. Reduction rules maintain the relative ordering of the constraints. This is necessary for variable elimination to be sound (see section 4.2).</p><p>The state of the reduction is represented by a pair 5 © where is the current constraint set and © is a partial substitution for variables that occurred in the initial constraint set. The initial state is associated with a null substitution. If application of a reduction rule requires a substitution that instantiates some of the variables, we apply the substitution immediately to the entire constraint set and add it to © (see rules (un) and (ksub) in section 4.3). The accu- mulated substitution is thus carried with the reduced constraint set along every path in the reduction tree. If the path terminates in a satisfiable constraint set, © contains variable instantiations that the attacker has to make in order to stage a successful attack.</p><p>In the rule definitions below, we refer to all constraints @ A¦ i ¤¦ preceding the active constraint ¡ B i as DC , and to all constraints ¡ FE G i E following ¡ ¢ i as IH .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Variable elimination</head><p>Rule (elim) removes a standalone variable from the term set of a constraint. P applies it as many times as necessary to eliminate all standalone variables from the term set of the active constraint.</p><formula xml:id="formula_7">IC 5£ ¡ ¢ @ q xi £ P H 5 © C £ ¡ Q i £ P IH 5 © (elim) @ is a variable</formula><p>This rule is formally justified by proposition 5.1. Informally, removing a standalone variable @ from a term set i " does not change t s © i " for any © R S . By the origination assumption, each vari- able appears for the first time on the left side of some constraint. Since P selects as the active constraint the first constraint where the</p><formula xml:id="formula_8">IC £ ¡ ¢ i C£ H 5 © ¡ C £ ¡ IH 5 ¡ q © (un)</formula><p>where</p><formula xml:id="formula_9">¡ mgu ¡ £ I A£ I y i 5 C £ ¡ P £ ¡ R i £ P IH 5 © IC £ ¡ P i C£ ¡ R i £ P H 5 © (pair) IC £ ` ¡ i £ H 5 © IC £ ¡ ¢ i C£ H 5 © (hash) IC £ ¡ #" b i £ H 5 © IC £ ¦c i £ ¡ ¢ i £ H 5 © (penc) IC £ ¡ a b i £ P H 5 © C £ ¦c i £ ¡ ¢ i C£ IH 5 © (senc) C £ sig$ Q% (' ed ) ¡ i £ IH 5 © C £ ¡ Q i £ IH 5 © (sig) IC £ ¡ ¢ I QP £ I R q §i C£ H 5 © C £ ¡ ¢ I P q I R q §i £ IH 5 © (split) C £ ¡ ¢ I " $ &amp;% 2' ed ) q i £ P IH 5 © IC £ ¡ ¢ I q i £ P H 5 © (pdec) IC £ ¡ Q I " b q i £ P H 5 © ¡ IC 5£ ¡ ¡ Q ¡ I " b q ¡ i £ ¡ H 5 ¡ q © (ksub) where ¡ mgu ¢c W£ T U W XH Y A£ gc ¢ T U W XH Y C £ ¡ i q I #a b £ IH 5 © IC £ ¦c i q I g b £ ¡ ¢ i q I</formula><p>q Ec £ H 5 © (sdec) Note:</p><formula xml:id="formula_10">7 unifies with 7 B a ¤£ iff ¥ © s.t. © 7 © 7 B £ © w © w B</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 3: Reduction rules</head><p>left side is not a variable, it must be the case that ¡ @ §q ri is preceded by a constraint @ i §¦ y IC . We can show that i ¨¦ i , thus any term that might be used to instantiate @ can instead be constructed directly from i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Constraint reduction rules</head><p>Reduction rules are listed in Fig. <ref type="figure">3</ref>. They should be understood as rewrite rules on the constraint set, and read from top to bottom. To facilitate explanation, we gave matching names to term set operators v and reduction rules. Each reduction rule applies to the same term(s) as the corresponding term set operator.</p><p>Notice that analysis operators correspond to reduction rules that decompose some term in the term set on the right side of a constraint, while synthesis operators correspond to rules that decompose the term on the left of a constraint.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">Unification</head><p>The unification rule attempts to recognize ¡ as a member of i , by unifying ¡ with some non-variable term I y i , using the most general unifier. Informally, application of this rule represents "replay" of a term known to the attacker. For example, the attacker can replay an encrypted term even if it has not been able to break the encryption. Different successful choices for I result in different branches in the reduction tree. A successful unification may cause one or more variables to be instantiated, in both ¡ and I , and this substitution is applied to every constraint in the set. A successful unification eliminates the current constraint.</p><p>The unification rule (un) is applied only to constraints ¡ i where ¡ is not a variable due to the way P selects the active con- straint. Note that i does not contain any standalone variables since P applies rule (elim) to ¡ 9 i before applying any reduction rule, including (un). Unification does not distinguish and a terms, i.e., 7 unifies with does not exist, the rule is not applicable. Note that if ¡ is a constant, the rule will succeed only if ¡ y i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2">Decomposition</head><p>Decomposition rules (pair), (hash), (penc), (senc), (sig) model the case when term ¡ can be constructed from components which are synthesizable from terms in i . Intuitively, the rules should be read "backwards." For example, rule (penc) can be informally understood as "one of the ways the attacker can construct term ¡ 8" b is by constructing terms ¡ and c , and then encrypting ¡ with c ." Note that the attacker can construct only its own public-key signature.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.3">Analysis</head><p>Analysis rules (split) and (pdec) attempt to break up terms on the right side of the constraint as far as possible without variable instantiation. If a term is encrypted with a public key which does not belong to the attacker, it cannot be decrypted since our model assumes that private keys are never leaked. Symmetric-key decryption is handled by the (sdec) rule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.4">Key substitution</head><p>Application of the key substitution rule (ksub) corresponds to the case when the attacker decrypts a term encrypted with a public key, i.e., the right side of the active constraint must contain a</p><formula xml:id="formula_11">I X" b</formula><p>term. The rule is applicable only if term c in the key position unifies nonidentically with the attacker's public key T VU XH (the case when c T U W XH Y is covered by the (pdec) rule). The attacker can only decrypt terms encrypted with its own public key since it is assumed that the private key of a key pair is never leaked. If c does not unify with T VU W XH , this means that term I is not encrypted with the attacker's public key, and the rule does not apply.</p><p>The domains of ¡ and © are disjoint since © has already been applied to the constraint set. Note that successful application of rule (ksub) enables rule (pdec) which can replace 7 X" $ &amp;% 2' ed ) by 7 on the right side of the current constraint as well as all those containing terms encrypted with c before the substitution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.5">Symmetric-key decryption</head><p>The symmetric-key decryption rule (sdec) can be applied when the right side of the active constraint contains a term encrypted with a symmetric key. This corresponds to the case when the attacker succeeds in decrypting a symmetrically encrypted term by synthesizing the right key.</p><p>As far as unification and satisfiability are concerned, the special term in order to avoid subsequent application of the same rule to the newly added constraint c i b . The intuition behind this is that decrypting terms encrypted with c is never necessary in order to construct c . The term as a whole may still be necessary. Consider constraint</p><formula xml:id="formula_12">I</formula><formula xml:id="formula_13">c I g b £ c a ¡ £¢ ¥¤ ¦</formula><p>where the entire term I g b must be used, without being decrypted itself, to decrypt another term and extract c . Note that</p><formula xml:id="formula_14">I 8a b</formula><p>is replaced in the term set of the original constraint by I and c . Addition of c to the term set is sound if constraint c i b is satisfiable, as proved in proposition 5.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Checking satisfiability</head><p>Every path in the reduction tree generated by procedure P terminates either in a constraint set to which no rule can be applied, or in a simple set that has only variables on the left, i.e., @ P i P £ &amp;f &amp;f &amp;f 3£ @ ¢ i ¢ . A simple constraint set is always satisfiable as long as the attacker has at least one constant in its initial term set. One can check by inspecting the reduction rules that such constants remain in the term set of every constraint. If ) is such a constant, © ) @ P £ &amp;f &amp;f &amp;f 3£ ) @ ¢ satisfies all constraints. In the future, we may wish to distinguish different types of constants. We will ensure then that the attacker knows one constant of each type.</p><p>We have not performed a detailed analysis of the complexity of the constraint solving algorithm. Rusinowitch and Turuani <ref type="bibr" target="#b13">[13]</ref> demonstrated that the problem is NP-complete in a similar setting (free term algebra with arbitrary terms as symmetric encryption keys). The proof of NP-completeness in <ref type="bibr" target="#b13">[13]</ref> relies on guessing the right substitution for variables and the right sequence of attacker operators that derives ¡ from i " for each constraint ¡ ¢ i " . It is likely that while our algorithm has the same worst-case complexity, it is significantly more efficient in practice since in our case substitutions are performed only when they may possibly result in satisfying a constraint (rules (un) and (ksub)), and generation of the sequences of v operators deriving ¡ from i " is driven by the structure of the terms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">SOUNDNESS AND COMPLETENESS</head><p>In this section, we prove that P terminates and that it preserves all solutions of '£ without introducing any new ones.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Invariant properties of P</head><p>Let § ©¨be the set of all constraint sequences generated by P. The origination assumption (see section 2.5) implies that, in the initial sequence of constraints, each variable appears for the first time on the left side of a constraint, and not in the right side of that constraint. This origination property is an invariant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem (Invariance of Origination) y § 6£ P satisfies the origination property.</head><p>Proof in Appendix A.1.</p><p>Consider constraint ¡ ¦ i ¦ in which variable @ appears for the first time. By the origination property, i §¦ does not mention @ , or any variable that appears later than @ . A constraint sequence is monotonic, if, for any constraint ¡ i s.t. i mentions variable @ , ¥ i ¦ § i such that i ¦ does not mention @ or any variable that appears later than @ , and i §¦ i ¦ . Furthermore, i ¤£ § i . Monotonicity captures the fact that the attacker never forgets information. Every message received by the attacker can only add to its knowledge and cannot possibly remove any terms it already knows. If at some point the attacker had access to terms in i ¦ , then at any later point these terms, possibly transformed in a way that preserves t E 8i ¦ , are still available to the attacker.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem (Invariance of Monotonicity) ¤ y § ¨£ P is mono- tonic.</head><p>Proof in Appendix A.2.</p><p>PROPOSITION 5.1. If ¡ i q R@ is the active constraint, then i % i q S@ . Clearly, i i q @ , so it suffices to show that i q @ i . By the origination property, there exists an earlier constraint ¡ ¦ i ¦</p><p>where @ appears for the first time in ¡ ¦ . It must be the case that ¡ ¦ r Q@ , since constraints earlier than the active constraint have standalone variables on the left.</p><p>Suppose © R S . We must show that t © 8i q !@ § t E © i u Af It suffices to show that © 8i q R@ § t s © i u , since t is idempotent. Since © i § t E © 3i u , we just need © @ y t E © i u . By monotonicity of the constraint sequence , ¥ §i ¦ § i q @ such that i ¦ does not mention @ and i ¨¦ i ¦ . In particular, i ¦ § i , so © ¤@ y t E © 3i ¨¦ § t E © i u .</p><p>PROPOSITION 5.2. If i " i q I #a b , then i " % i q I g b</p><p>Follows immediately from the fact that t is closed under v open and v hide .</p><p>PROPOSITION 5.3. Suppose</p><formula xml:id="formula_15">I 8a b y i . If ¥ © s.t. © c i b and i b i , then i % 8i I a b q I q Ec Let i i q I #a b . If ¥ © s.t. © c i b and i b i , then © 0c y t E © i u and, since t is closed, t E © i u x t E © i q © I #a b q © c t 0 . Since t 0 is closed under v sdec and v senc, t !0 t s © i q © I a b q © c q © I t s © i q © 0c q © I Af By definition, i % 8i I #a b § 3q I q c .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Termination</head><p>The termination measure of a constraint set is a tuple ¢¨¦ £ ¦! 2 where ¨¦ is the number of distinct variables and " is a special expansion measure. Tuples are ordered lexicographically.</p><p>To define the expansion measure, first define the structure size # ¡ # of a term ¡ to be the number of operator applications plus the number of constants and variables in it (the number of nodes in the parse tree). The expansion measure of a constraint set is the sum of the expansion measures of the constraints. The expansion measure We have to show that each rule reduces the termination measure. Checking the rules one by one, we see that: (elim) reduces ! by eliminating a factor variable by substitution and hence reduces ¨¦ , or matches a constant on the left without a substitution, which leaves ¨¦ unchanged but reduces ¨ by eliminating the constraint; (sig), (pair), (hash), (penc), and (senc) reduce " by leaving i alone but decomposing the left side into components with a smaller structure sum; (split) and (pdec) reduce " by decreasing a factor ; and (ksub) instantiates a variable and thus reduces ¨¦ . The most interesting case is (sdec), which replaces ¡ i q I 8a b</p><formula xml:id="formula_16">of a constraint ¡ ¢ i is # ¡ # %$ '&amp;</formula><p>with expansion measure</p><formula xml:id="formula_17"># ¡ # &amp; 8i Q &amp; I &amp; ¢c # c # 0</formula><p>by c i q I g b and ¡ ¢ i q I q 6c</p><p>with total expansion measure</p><formula xml:id="formula_18"># c # &amp; 8i u # ¡ # &amp; 8i u &amp; I &amp; ¢c V . This measure is smaller because that # c # 76 8# ¡ # # c # 90</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Soundness</head><p>A constraint reduction procedure is sound if reduction rules do not introduce new solutions. To prove soundness, it is sufficient to show for every rule 2 that © R 2 V 6 implies © . Each reduction rule is sound (proof in Appendix A.3). By induction over the length of the reduction sequence, P is sound.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Completeness</head><p>The basic idea of completeness is to show that any solution of the initial constraint set is preserved along at least one path in the reduction tree. If © is a substitution such that © £ , then P is complete if, among all the simple, satisfiable constraint sets produced by P, there is at least one set such that © R S .</p><p>Our proof of completeness is quite delicate. In particular, completeness does not hold inductively for any constraint set, i.e., it is not always the case that if © , then there is a rule 2 such that © 2 6 . Consider constraint ) § ` ¢c Xc ¦ ' b ) q ` ¢c V . Applying reduction rule (hash) to this constraint, we obtain constraint ) B 4c Xc ¦ ' b ) q ` ¢c . This constraint is satisfiable since ` ¢c V to obtain c . Unfortunately, there is no reduction rule in section 4.3 that can be applied to ) B . The problem arises because 7 can be "opened" by v open and subsequently decrypted when computing t , but there is no corresponding reduction rule that could be applied to the constraint.</p><formula xml:id="formula_19">c y t E 2 Xc</formula><p>Observe, however, that completeness is not violated in this example. There exists another rule that is applicable to ) , namely, (un), which unifies ` ¢c with ` ¢c V and successfully eliminates the constraint. This observation is the intuition behind our proof of completeness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem (Completeness)</head><p>For any substitution © such that © '£ , P will generate a simple constraint set such that © . Informally, the proof can be understood as follows. Procedure P may generate "bad" states which are satisfiable but not reducible, thus violating completeness. However, "bad" states cannot appear in an arbitrary place in the reduction tree. We show that they appear only in branches rooted in "bad-root" states of a particular type, namely, those generated by the (sdec) rule. For each "badroot" state we prove that, given any solution, there always exists at least one branch out of the state that preserves this solution and leads to a "good" state. This will guarantee completeness, since any solution of the initial constraint set (but not necessarily of every set generated by P) is preserved along at least one path in the reduction tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Details of the proof can be found in</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">EXAMPLES</head><p>The NSL protocol, as modified, was analyzed using a Prolog program based on the constraint reduction rules in Section 4.3. The program was given several semibundles to look at, with as many as four legitimate strands. On a semibundle with two responder strands, it found an interleaving with a solvable constraint set. One constraint reduction path leading to a solution (and hence an attack) is traced below.</p><p>Consider the interleaving of strands for responders © and some ¡ , in which © expects to share § with a particular ¥ . The last reply in each strand has been omitted for simplicity, but the secretreception strand 1 § is added to test secrecy of § . The actual analyzed semibundle had more strands, and they were complete.</p><formula xml:id="formula_20">1 ¥ £ ¦¨© ! 8" $ Q% (' ¨ § ) to b ¨© £ § £ © #" $ &amp;% (' ) from b to a 1 ¥ §£ ¦¤ " $ &amp;% (' © )</formula><p>to any A from any B</p><formula xml:id="formula_21">¨ £ £ V£ ¡ #" $ &amp;% 2' 0) from A to B 1 § secret reception</formula><p>The constraint set from this interleaving is:</p><formula xml:id="formula_22">0 f ¥ £ ¦¨© ! #" $ &amp;% 2' ¨ § ) i ¤£ @ ¥ £ © Y£ H £ T VU W ¥ A£ gT U W © 2 ¦F ( f ¥ £ ¨ " $ &amp;% (' © ) i P i £ q @ ¤© £ § £ © e " $ &amp;% (' ) F f § i P q @ ¨ £ £ V£ ¦¡ #" $ &amp;% 2' ) F</formula><p>We will follow one path leading to a solution. Note that we are treating concatenation as a binary right-associative operation. First, apply (penc) to (1):</p><formula xml:id="formula_23">0 f 0 f T U W © &amp; i £ 0 f ( f ¥ £ ¦¨© ! i ¤£ ( f ¥ §£ h¨ #" $ &amp;% (' © ) i P i ¤£ q @ ¨© £ § £ © e #" $ &amp;% (' ) F f § i P q @ ¤ £ £ ¦¡ " $ &amp;% 2' ) F</formula><p>Eliminate (1.1) with (un) and expand (1.2) with (pair):</p><formula xml:id="formula_24">0 f ( f 0 f ¥ i £ 0 f ( f ( f ¨© i ¤£ ( f ¥ §£ h¨ " $ &amp;% (' © ) i P i ¤£ q @ ¨© £ § £ © e " $ &amp;% (' ) F f § i P q @ ¤ C£ £ ¦¡ " $ &amp;% 2' ) F</formula><p>Eliminate (1.2.1) with (un) and skip (1.2.2) because it has a variable on the left. Apply (un) to (2) with the substitutions ¥ ¢¡ G ¨© , ¤ £¡ G § £ © and ¡ ¤¡ G ¥ , eliminating (2).</p><formula xml:id="formula_25">0 f ( f ( f ¨© i ¤£ f § i P q @ § £ © £ £ V£ ¥</formula><p>e #" $ &amp;% (' ¦¥ ¨ § ) F Finally, apply (ksub) to (3) with ¨© ¡ G H . It should be clear after this that § will be exposed and the solution can be finished up eas- ily. Installing the substitutions into the original semibundle yields the attack.</p><p>The attack requires two somewhat implausible but not impossible type confusions: H in the first message is occupying a nonce field, and § £ © in the first message of the ¥ strand is also occu- pying a nonce field. This could work if agent names are the same length as nonces and the protocol could handle two sizes of nonce (single or double). The point is not that this is a realistic attack, but that it illustrates the power of the analysis technique to find surprising results, in this case by permitting a type flaw. Protocols can also be encoded in such a way as to reflect type protection, if the implementation is believed to work that way.</p><p>To illustrate how the algorithm handles constructed keys, we present partial analysis of a toy, faulty mutual authentication protocol inspired by Gong's mutual authentication protocol <ref type="bibr">[8]</ref> (we did not discover any bugs in the original protocol).</p><formula xml:id="formula_26">¡ G ¥ ¡ ¤£ g¨© ¥ G p ¡ £ ¦¥ £ ¤© 6£ ¦¤ ¥ © p £ ` 0£ ¦¨© £ ¥ £ © 0 a ¦ ' ¥ ¨ ¥ ¨ © ¢ ) ¡ © ¥ £ ` ` £ ¦¨© £ ¦¥ £ ! © 0 ¡ G ¥ ` ` £ ¦¨© £ ¦¥ £ ! © 0 A£ " W</formula><p>The goal of the protocol is to preserve the secrecy of the key §© 3 ` ¨ £ ¦© £ h¥ £ ! §© shared between ¡ and ¥ .</p><p>One of the possible interleavings of the protocol and the secret reception strand ¡ ¤© © 3 gives rise to the following constraint:</p><formula xml:id="formula_27">© 3 @ ¡ ¤£ ¥ £ ¦¨© £ ¦¨ £ " £ © 3 a ¦ ' ¥ ¥ ¨ © ¢ ) F</formula><p>Rule (sdec) transforms this constraint into:</p><formula xml:id="formula_28">` £ ¦¨ £ h¡ @ ¡ ¤£ ¥ £ ¦¨© £ ¦¨ £ " £ §© 3 ¦ ' ¥ ¨ ¥ © ¢ ) F © 3 @ ¡ ¤£ Qf &amp;f &amp;f 3£ h" £ © £ ` 0£ ¦¨ £ ¦¡ ¦F</formula><p>Rules (hash) and (un) dispose of the first constraint (this corresponds to the fact that ` £ h¨ £ ¦¡ can be constructed by the attacker who knows ¡ ¤£ ¨ £ and ¨ ) and (un) disposes of the second constraint. Therefore, the constraint set is satisfiable, proving that the secret reception semibundle is reachable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSION</head><p>By using the strand space model only for honest processes and the term set closure characterization of the attacker, our model achieves a clean transition from the process model to the constraint solving problem. Models that put individual attacker actions (such as in penetrator strands) in the process side must mix the two, because they cannot predict which actions the attacker will perform. In terms of attacker capabilities, the term set closure characterization of the attacker results in the same (infinite) set of synthesizable messages as penetrator strands.</p><p>Using the free term algebra simplifies the model, enabling us to handle constructed keys even in cases of self-encryption. However, without cryptographic reduction rules, we cannot handle protocols where both keys in a public-private key pair are used explicitly. A free algebra also fails to represent the properties of encryption operations with associative and commutative characteristics, such as xor and Diffie-Hellman exponentiation. We are currently investigating how the constraint solving algorithm presented in this paper may be extended to support such operations.</p><p>The finite semibundle node-merge generation and the constraint reduction rules lend themselves well to implementation in Prolog, with its built-in depth-first search strategy and unification. We have implemented the decision procedure in XSB (SUNY Stony Brook) Prolog, and it often runs in a small fraction of a second on the examples we have tried, even when the vulnerability search fails. The program is less than three pages. The approach can be extended in a natural way to unbounded process analysis by iteratively adding strands to the initial finite set, though there is no guarantee of termination if this is done.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX A. PROOFS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1 Invariance of origination</head><p>The origination property for a constraint sequence states that each variable appears for the first time on the left side of a constraint, and not in the right side of that constraint. This property can only be violated by a reduction rule which, given a constraint ¡ ¢ i , changes it to ¡ B i B such that i B contains a variable @ B but there is no preceding constraint that has @ B only on the left side.</p><p>With the exception of rules (un) and (ksub), constraint reduction rules do not instantiate existing variables or introduce new variables or change the order of constraints. Therefore, they cannot violate the origination property. Rules (un) and (ksub) may introduce a new variable on the right side as a result of applying substitution ¡ . Consider constraint ¡ i such that i mentions variable @ , and substitution ¡ such that ¡ @ mentions some other variable @ B . If the origination property is true for the constraint set to which the rule is applied, then there exists another constraint ¡ @ i ¦ that precedes ¡ i in the chronologically ordered constraint list such that @ is mentioned in ¡ @ but not in i §¦ . Consider two cases. @ B y i ¦ By the origination property for the constraint set before rule application, there exists ¡ @ B i ¦ £ preceding ¡ @ i ¦ such that @ B is mentioned in ¡ @ B but not in i ¦ £ . But this constraint must also precede ¡ i and, therefore, ¡ B i B , since neither (un), nor (ksub) changes the relative order of constraints. Application of ¡ does not substitute @ B , other- wise @ B would not appear in ¡ i . Therefore, @ B is mentioned in ¡ ¡ @ B but not in ¡ i ¦ £ , thus there exists a constraint preceding ¡ B i B , namely, ¡ ¡ @ B ¡ i ¦ £ that mentions @ B only on the left side. @ B y i ¨¦ Then ¡ ¡ @ mentions @ B , but ¡ i ¨¦ does not. Therefore, there exists a constraint preceding ¡ B i B , namely, ¡ ¡ @ ¡ i ¨¦ such that @ B is mentioned only on the left side.</p><p>By induction over the length of the reduction sequence, the origination property is true for all constraints generated by P.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 Invariance of monotonicity</head><p>The initial constraint set is monotonic by simple term set inclusion. To prove that all constraint sets produced by P are monotonic, it is sufficient to show that monotonicity is invariant with respect to every reduction rule from section 4.3.</p><p>Rule (elim) eliminates one of @ ¦ from i but does not affect i ¦ .</p><p>Rules (split) and (pdec) do not introduce new variables and do not affect t s © i ¦ for any @ ¦ £ © . For example, if </p><formula xml:id="formula_29">© c i b £ P is not affected if I a b</formula><p>is replaced by I g b or I q sc . This follows from propositions 5.2 and 5.3.</p><p>Finally, consider rule (un). Suppose ¡ includes substitution @ E ¡ G I @ ¦ for some variables @ ¦ ¦£ @ E where I @ ¦ D is an arbitrary term men- tioning @ ¦ . Even though ¡ may introduce @ ¦ into some terms of i that did not mention @ ¦ before, we'll prove that either these terms are not in i ¦ , or ¡ , when applied to the entire constraint set, replaces @ E with I @ ¦ in some constraint ) preceding ¡ @ ¦ i ¦ and makes that constraint the first constraint mentioning @ ¦ . We'll also show that i must contain a superset of i ¢¡ which is not affected by ¡ , thus preserving monotonicity. Consider two cases. £ ¥¤ ¨By definition, i ¦ does not mention @ E , and ¡ does not in- troduce @ ¦ to i ¦ . £ 6 ¨By the origination property, ¥ constraint ) ¡ @ E i E preceding ¡ @ ¦ D i ¤¦ such that i E does not mention @ ¦ or @ E .</p><p>By the induction hypothesis, the constraint set to which rule (un) is applied is monotonic. Therefore,</p><formula xml:id="formula_30">¥ i ¦ §¦ § i such that i E i ¦ ¦ . Observe that i ¦ ¦ § i ¦ since i ¦ ¦ contains all</formula><p>terms of i that do not mention @ E £ &amp;f &amp;f Qf £ @ ¦ g£ &amp;f &amp;f 2f £ @ b , while i ¦ contains all terms of i that do not mention @ ¦ £ Qf &amp;f &amp;f 3£ @ b only.</p><p>Substitution ¡ does not affect any terms in i ¦ ¦ since they do not mention @ E . Therefore, i ¦ ¦ § ¡ i . After ¡ is applied to the constraint set, ) B ¡ ) ¡ ¡ @ E ¡ i E ¡ I @ ¦ D i E . Note that ¡ I @ ¦ mentions @ ¦ . Therefore, ) B and not ¡ ¦ i ¦ is now the first constraint that mentions @ ¦ . But ¥ i ¦ ¦ § ¡ i such that i ¦ ¦ does not mention @ E £ Qf &amp;f &amp;f 3£ @ ¦ £ &amp;f &amp;f Qf £ @ b and ¡ i E i E i ¦ ¦ .</p><p>By induction over the length of the reduction sequence, all constraint sets generated by procedure P are monotonic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.3 Soundness</head><p>For rule (elim), soundness follows from proposition 5.1. Rules (split) and (pdec) are sound because t is closed under v pair and v pdec . For example, in case of rule (pdec), t E © 3i §q I© I 5 t s © i q © I q © I " $ &amp;% &amp;' ed ) 5 t s © i q © I " $ &amp;% 2' ed ) . Therefore, if © ¡ y t s © I q © 3i u , then © ¡ y t E © I " $ &amp;% 2' ed ) q S© i u . For rule (un), consider that if © ¡ DC £ ¡ H , then © q ¡ C £ P IH . Also, © q ¡ ¡ I q i because ¡ mgu ¡ £ I , thus ¡ ¡ ¡ I by definition of the most general unifier. Therefore, © q ¡ . For rules (pair), (hash), (penc), (senc), and (sig), soundness follows from the fact that t is closed under the corresponding v operator. For example, consider rule (penc). If penc 6 C £ hc i £ ¡ i £ H is satisfiable, then ¥ © s.t. © IC 5£ H and © 0c y t s © i u A£ © ¡ y t © i . Since t is closed under v penc, © ¡ " b y t s © i u . Therefore, © R S DC £ ¡ " b i £ P H .</p><p>For rule (ksub), if © ¡ DC 5£ ¡ ¡ ¡ I " b q ¡ i £ ¡ " , then © xq ¡ S IC £ ¡ Q I #" b q xi £ P H . Finally, consider © sdec 6 DC £ ¦c i b £ ¡ 8i I a b 3q I q c W£ P IH where i b I g b q i . Clearly, © C £ P IH . By proposition 5.</p><formula xml:id="formula_31">2, i b % i , thus © c i . Given © c i , i % 8i I a b Wq I q c by proposition 5.3. Therefore, © R ¡ Q i . It follows that © IC £ ¡ Q i £ P H .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.4 Completeness</head><p>This proof is long because it requires consideration of many cases. Because of space limitations, and in the interests of readability, what follows is a fairly detailed proof sketch.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.4.1 Completeness without encryption hiding</head><p>Suppose ¡ i " is the active constraint and ¡ £ gi " contain no terms of 7 form. For any © 9 C £ ¡ i " £ P IH , we show that there is a rule 2 such that (i) 2 is applicable to , and (ii) © 2 6 . Note that the solution does not have to be preserved in every possible reduction. As long as in every state there is at least one rule that preserves the solution, completeness will hold. The proof that an applicable rule can always be found relies on the existence of a normal derivation for any term that can be constructed by the attacker.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.4.1.1 Normal derivation.</head><p>For any ground term I and set of ground terms i , where neither  : either 7 8a y i £ (in this case the proof is complete), or 7 8a y i ¦ i ¦ ¨P for some ¨. In this case, also, 7 a was created from its components by one of the ¤ synth operations and the v sdec operation is redundant and can be removed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.4.1.2 Finding an applicable rule.</head><p>Consider the active constraint ¡ i " and a satisfying substitu- tion © . Given a normal derivation of © ¡ from © i " , we must find a reduction rule applicable to i " that is compatible with © .</p><p>By definition of the active constraint (see section 4.1), ¡ is not a variable and i " does not contain any standalone variables after application of the (elim) rule. Suppose © ¡ i " , i.e., © ¡ y t E © 3i " . Then, by proposition A. .</p><p>If © ¡ y © i " , then the unification rule (un) can be applied to the ¡ i " constraint, and since the rule applies the most gen- eral unifier, it will be consistent with © . Otherwise, an applicable reduction rule can be found by pattern matching given the normal derivation which satisfies one of the three conditions given above. First, consider the case of v P y ¤ analz . The reduction rule corresponding to v P will be applicable to © i " . It must be the case that © i " contains a "target" term I such that v P operates on © I . There are no standalone variables in i " , so I has the necessary top-level structure. The case of v £¢ y ¤ synth is handled similarly. Since © ¡ is the result of applying v ¢ , © ¡ must have the corresponding structure. Since ¡ is not a standalone variable, ¡ must have the same top-level structure as © ¡ , and the corresponding decomposi- tion rule is applicable to ¡ ¢ i " .</p><p>Finally, consider the case when v ¦ v sdec and © 3i " contains a 7 a term. Since there are no standalone variables in i " , i " must also contain a 7 B a ¤£ term, and the (sdec) rule can be applied to ¡ ¢ i " .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.4.1.3 Preserving the solution.</head><p>The proof that the applicable rule preserves the solution of the constraint set proceeds on cases of  i " for some terms 7 and w and rule (sdec) is applicable to . It will reduce to B IC £ w 8i " 7 a q 7 £ ¡ ¢ 8i " 7 a 3q 7 q w £ H . By proposition 5.2, i " % 8i " 7 a q 7 . Observe that © 3w y i ¤¦ ¨P where i ¦ ¨P v ¦ ©¨P gf &amp;f 2f © i " (otherwise, v sdec would not be applicable to i ¦ ©¨P ). Therefore, © xw 8i " 7 a q E 7 .</p><p>In this case, according to proposition 5.3, i " % 8i " 7 8a ¦q 7 q 5w . This implies that if © R ¡ ¢ i " , then © ¡ ¢ 8i " 7 a q 7 q Cw . Therefore, © C £ w 8i " 7 #a 0q 7 £ ¡ 8i " 7 #a !q 7 q w £ H B .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.4.2 Completeness with encryption hiding</head><p>The initial constraint set contains no 7 terms. The first time an 7 term can appear in the reduction sequence is as a result of (sdec) application, which generates a constraint of the form c i q I g b . We will show that such a constraint can be solved without applying (sdec) to the hidden term. Let i ¦ v ¦ ¨P gf &amp;f &amp;f v P © i b . Since v sdec 4 © I a b 7 can be ap- plied to i ¤¦ , it must be the case that © I 8a b y i ¤¦ and © 0c y i ¤¦ . This implies that © c y v ¦ ¨P gf &amp;f &amp;f v P © 3i b where £ B a b £ P H . By induction over the length of the derivation, every reduction rule 2 ¦ is applicable to its respective constraint, and ¨y 0 f ef c , if © Q2 1¦ ©¨P gf &amp;f &amp;f 2 P 6 , then © 2 ¦ 2 ¦ ©¨P gf &amp;f &amp;f where IC £ c i q I b £ ¡ Q i q I q c W£ H</p><p>is the constraint set after the first application of rule (sdec). Solution © is preserved along the reduction sequence 2 b gf &amp;f 2f 2 P 6 by the same inductive argument as in the case of term sets without encryption hiding. Since constraint c i q I g b is satisfiable, by the end of the reduction sequence all constraints derived from it will be disposed of (either eliminated by unification, or reduced to @ i where @ is variable), and no unifications involve substi- tuting I b for a variable since it appears as a standalone term in i q r I g b . Therefore, 0 2 b gf &amp;f &amp;f 2 P 6 contains no terms of the form 7 , and the inductive completeness argument is true for the reduction sequences rooted in 0 .</p><p>To summarize, whenever rule (sdec) introduces a constraint containing 7 to the constraint set, for any solution © there exists a sequence of reduction rules that preserves © . None of the rules in the sequence require terms. Therefore, the sequence is applicable to constraint c 8i " 7 a q I b and leads to a constraint set in which there are no 7 terms.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Dp= p Eq sig$&amp;% &amp;' ed )   </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Reduction procedure P</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>7 B</head><label>7</label><figDesc>, and w with w B . Since © has already been applied to the constraint set, neither ¡ , nor I contains any variables in the domain of © , thus the domains of ¡ and © are disjoint. If the most general unifier mgu ¡ £ I</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>g b is indistinguishable from I #a b . Its purpose is purely technical: to "hide" the symmetrically encrypted term I a b</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>¦</head><label></label><figDesc>) to obtain c a ¦ ' b ) , and then v sdec on c a ¦ ' b ) and</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>for some 7 £</head><label>7</label><figDesc>w . There are two possibilities for term 7 a</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>brevity, we omit the details and explain the proof for the case of v ¦ 0 v sdec . By the applicability argument,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>PROPOSITION A. 2 . 7 . 7</head><label>277</label><figDesc>Suppose c i b is satisfiable and i b contains terms of the form I a b . Then I c i b is satisfiable without decrypting I 8a b . Assume the statement of the proposition is not true. Then every construction of c using terms from i b must involve an application of v sdec on I a b for some I . Below, we annotate each application of v sdec with the encrypted term on which it operates, so that if If the assumption is true, then for any solution © c i b and any sequence for some I . Consider the shortest such sequence.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>7 . 7 ,</head><label>77</label><figDesc>This contradicts the shortest-sequence assumption and completes the proof of the proposition. Now consider constraint c i q I g b created by (sdec) application. Since t is closed under v open and v hide , © c i q 4 I b iff © c i q I #a b . By proposition A.2, ¥ v P £ Qf &amp;f 2f £ v b s.t. © c y v b gf &amp;f Qf v P © 3i q © I a b and ¨v ¦ ¢ v sdec 4 © I a b 7 . Note that © i q R© I 8a b contains no terms of 7 form. By the same argument as was used in normal derivation construction, we can show that ¨v ¦ ¢ v open or v hide . This implies ¨t hat if v ¦ operates on the © I a b term, v ¦ is also applicable to the © I g b term because the only operators that distinguish between © and the sequence does not contain any such operators. Given that © 0c may not contain © I 8a b as a subterm, we conclude that © 0c y v b gf Qf &amp;f v P © 3i q © C I g b iff © c y v b gf &amp;f &amp;f v P © i q © I #a b . Moreover, each v ¦ has the corresponding reduction rule 2 ¦ 2 v ¦ since that are no v open or v hide in the sequence. Because ¨v ¦ ¢ v sdec 4 © I a b 7 , none of 2 ¦ are (sdec) applied to IC £ ¡ B i B q I</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>do not affect i at all. Rule (ksub) does not introduce any new variables or terms to i and, therefore, cannot change i ¦ .Rule (sdec) does not introduce new variables. Suppose</figDesc><table><row><cell>i</cell><cell>¦ , then i ¦ % 8i</cell><cell>¦</cell><cell>I</cell><cell>" $ &amp;% (' d ) 3q</cell><cell>I .</cell><cell>I 8" $ &amp;% 2' ed ) y</cell></row><row><cell cols="7">Rules (pair), (hash), (penc), (senc), (sig) I Xa b y i ¦ . Since t is closed under v open and v sdec , t E © 3i ¦ for any</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>¦ is one of the term set operators defining t . For notational convenience, let i £ i , and let i ¦</figDesc><table><row><cell>proposition holds. If if, for some c , v b y</cell><cell>¤</cell><cell>I analz and y i ¤£ , the proposition can only be violated v E y ¤ synth for £ 6 c .</cell></row><row><cell>Since</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="2">I , nor i contain any occurrences of terms of that if I y t 8i u , then there exists a normal derivation of 7 form, we prove I from i which either ends with an operator from ¤ synth , starts with an operator from ¤ analz , or starts with a sequence of operators from ¤ synth , followed by v sdec which is applied to a term from i .</cell></row><row><cell></cell><cell></cell><cell cols="2">PROPOSITION A.1. If any occurrences of 7 terms, then there exists a normal sequence I y t s 8i u and neither I , nor i contain v P £ 2f &amp;f &amp;f 3£ v £¢ such that I y v £¢ gf Qf &amp;f v P 8i u . A sequence is normal iff</cell></row><row><cell></cell><cell></cell><cell>one of the following conditions holds: -v £¢ y ¤ synth , or -v P y ¤ analz , or -v ¦ v sdec for some ¨,v P £ &amp;f &amp;f &amp;f 3£ v ¦ ©¨P y ¤ synth , and to term 7 8a y i for some 7 £ gw .</cell><cell>v ¦ is applied</cell></row><row><cell></cell><cell></cell><cell cols="2">Suppose set operators I y t E 8i u . Since t is defined as a closure of term v (see section 2.3), this means that either I y i , or I y v gf &amp;f &amp;f v P 8i where each stand for v ¦ gf &amp;f Qf v P 8i ¤£ 2 for any ¨. Step 1. First, we observe that I with no hidden terms can be derived without v open and v hide operators, since any operator application</cell></row><row><cell></cell><cell></cell><cell cols="2">using a hidden encryption could be replaced by one using the cor-</cell></row><row><cell></cell><cell></cell><cell cols="2">responding ordinary encryption. Step 2. Following Step 1, we obtain a sequence ¨v ¦ y ¤ synth or ¤ analz , and I y v ¢ gf &amp;f &amp;f v P 8i £ . If I v P £ &amp;f &amp;f &amp;f 3£ v £¢ y i £ , the s.t.</cell></row></table><note><p>v</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>1, either © ¡ y © i " , or there</figDesc><table><row><cell>exists a normal derivation and v £¢ y ¤ synth , or v P and v ¦ 0 v sdec applied to y v P £ Qf &amp;f &amp;f 3£ v ¢ s.t. © ¡ y v ¢ gf &amp;f Qf ¤ analz , or 7 a y © i " for some 7 v P © 3i " £ gw 7 8a</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>&amp; I &amp; ¢c # c</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>&amp; ` I &amp; I 30</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>&amp; @ 5( ; (un) either eliminates a</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_3"><p>&amp; I</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">On the reachability problem in cryptographic protocols</title>
		<author>
			<persName><forename type="first">R</forename><surname>Amadio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lugiez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CONCUR (2000)</title>
		<imprint>
			<publisher>Springer</publisher>
			<biblScope unit="volume">1877</biblScope>
			<biblScope unit="page" from="380" to="394" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">On the symbolic reduction of processes with cryptographic functions</title>
		<author>
			<persName><forename type="first">R</forename><surname>Amadio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lugiez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vanack Ère</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">INRIA</title>
		<imprint>
			<date type="published" when="2001-03">March 2001</date>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep. 4147</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Symbolic analysis of cryptographic protocols in the spi-calculus</title>
		<author>
			<persName><forename type="first">M</forename><surname>Boreale</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Relating strands and multiset rewriting for security protocol analysis</title>
		<author>
			<persName><forename type="first">I</forename><surname>Cervesato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Durgin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lincoln</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Scedrov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">13th IEEE Computer Security Foundations Workshop</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="35" to="51" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Undecidability of bounded security protocols</title>
		<author>
			<persName><forename type="first">N</forename><surname>Durgin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lincoln</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Scedrov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Formal Methods and Security Protocols</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
	<note>FLOC</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Computing symbolic models for verifying cryptographic protocols</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fiore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">14th IEEE Computer Security Foundations Workshop</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="160" to="173" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">The SSL protocol</title>
		<author>
			<persName><forename type="first">A</forename><surname>Freier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Karlton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kocher</surname></persName>
		</author>
		<ptr target="http://home.netscape.com/eng/ssl3/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Using one-way functions for authentication</title>
		<author>
			<persName><forename type="first">L</forename><surname>Gong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Communication Review</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="8" to="11" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A model for secure protocols and their compositions</title>
		<author>
			<persName><forename type="first">N</forename><surname>Heintze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tygar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="16" to="30" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Efficient infinite-state analysis of security protocols</title>
		<author>
			<persName><forename type="first">A</forename><surname>Huima</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Formal Methods and Security Protocols</title>
		<imprint>
			<publisher>FLOC</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Breaking and fixing the Needham-Schroeder public-key protocol using FDR</title>
		<author>
			<persName><forename type="first">G</forename><surname>Lowe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1055</biblScope>
			<biblScope unit="page" from="147" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The inductive approach to verifying cryptographic protocols</title>
		<author>
			<persName><forename type="first">L</forename><surname>Paulson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Security</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="85" to="128" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Protocol insecurity with finite number of sessions is NP-complete</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rusinowitch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Turuani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">14th IEEE Computer Security Foundations Workshop</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="174" to="190" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Athena: a new efficient automatic checker for security protocol analysis</title>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th IEEE Computer Security Foundations Workshop</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="192" to="202" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Honest ideals on strand spaces</title>
		<author>
			<persName><forename type="first">F</forename><surname>Thayer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Herzog</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Guttman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">11th IEEE Computer Security Foundations Workshop</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="66" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Strand spaces: Why is a security protocol correct?</title>
		<author>
			<persName><forename type="first">F</forename><surname>Thayer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Herzog</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Guttman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="160" to="171" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
