<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">RegionScout: Exploiting Coarse Grain Sharing in Snoop-Based Coherence</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Andreas</forename><surname>Moshovos</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Electrical and Computer Engineering</orgName>
								<orgName type="institution">Univerisity of Toronto</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">RegionScout: Exploiting Coarse Grain Sharing in Snoop-Based Coherence</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">629D660AAFE791E01A4EBBC368970180</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T05:20+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>It has been shown that many requests miss in all remote nodes in shared memory multiprocessors. We are motivated by the observation that this behavior extends to much coarser grain areas of memory. We define a region to be a continuous, aligned memory area whose size is a power of two and observe that many requests find that no other node caches a block in the same region even for regions as large as 16K bytes. We propose RegionScout, a family of simple filter mechanisms that dynamically detect most non-shared regions. A node with a RegionScout filter can determine in advance that a request will miss in all remote nodes. RegionScout filters are implemented as a layered extension over existing snoop-based coherence systems. They require no changes to existing coherence protocols or caches and impose no constraints on what can be cached simultaneously. Their operation is completely transparent to software and the operating system. RegionScout filters require little additional storage and a single additional global signal. These characteristics are made possible by utilizing imprecise information about the regions cached in each node. Since they rely on dynamically collected information RegionScout filters can adapt to changing sharing patterns. We present two applications of RegionScout: In the first RegionScout is used to avoid broadcasts for non-shared regions thus reducing bandwidth. In the second RegionScout is used to avoid snoop induced tag lookups thus reducing energy.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>There are workload, technology and cost trends that make shared memory multiprocessors an increasingly popular architecture <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b33">34]</ref>. Today there are applications (e.g., databases, file and mail servers, multimedia/entertainment and communications) with sufficient parallelism that shared memory multiprocessors can exploit. In addition, the increasing levels of chip integration make single chip/module multiprocessors viable and an attractive alternative for utilizing additional on-chip resources <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b31">32]</ref>. Also, the increased cost and complexity of building modern processors make using multiple identical cores a cost-effective option for high integration devices. Finally, there is a proliferation of devices that look increasingly like small-scale shared memory multiprocessors (e.g., cell phones and game consoles). Accordingly the focus of this work is on small-scale shared multiprocessors. With the increased popularity of shared memory multiprocessors comes renewed interest in techniques for improving their efficiency and performance, particularly in techniques related to coherence and for both small and large scale systems. This is exemplified by the recent advances in coherence speculation (e.g., <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b28">29]</ref>) and in power-aware coherence <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b29">30]</ref>. The same cost and technology trends that favor using multiple identical cores also favor techniques that are as little intrusive as possible at the hardware and software levels. At the same time, the abundance of on-chip resources creates opportunities for novel coherence implementations <ref type="bibr" target="#b3">[4]</ref>.</p><p>We propose RegionScout a technique that exploits coarse grain sharing patterns in snoop-based shared memory multiprocessors with potential applications in reducing bandwidth, latency and energy. We observe that many shared memory requests not only do not find a matching block in any remote node but also they do not find a block in the same region (where a region is a continuous, aligned memory area whose size is a power of two).</p><p>RegionScout comprises a family of filters that dynamically observe coarse grain sharing and allow nodes to detect in advance that a request will miss in all remote nodes. Such information is not available in conventional snoop-or directory-based coherence. With RegionScout when a node sends a request in addition to block-level sharing information it receives region-level sharing information. If a region is identified as not shared subsequent requests for any block within the region from the same node are identified as nonshared without having to probe any other node. Normal coherence activity allows the detection of regions that become shared preserving correctness. RegionScout filters utilize imprecise information about the regions that are cached in each node in the form of a hashed bit vector <ref type="bibr" target="#b4">[5]</ref>. For this reason, they detect many but not all requests that would miss in all other nodes. This loss in coverage allows RegionScout to be completely transparent to software and avoids imposing artificial constraints on what can be cached simultaneously. RegionScout filters require no changes to the underlying coherence mechanisms: when possible they simply return a "not shared" response without having to consult the existing coherence protocol. Their implementation is flexible allowing a trade-off between filter storage cost and accuracy. To demonstrate the utility of RegionScout filters we investigate two applications. In the first, RegionScout filters are used to avoid snoop-induced tag lookups thus reducing energy in the memory hierarchy. In the second, RegionScout filters are used to avoid broadcasts for some requests. Techniques for avoiding broadcasts are becoming important even for smallscale multiprocessors. This is because technology trends favor switch-based point-to-point interconnects as opposed to busses. Avoiding broadcasts improves performance in several ways: it reduces latency directly since the originating node does not have to wait for every other node to respond, it reduces contention on the interconnect thus reducing latency indirectly and finally it frees bandwidth which may be used more fruitfully. The rest of this paper is organized as follows: In Section 2 we detail our simulation environment and methodology. In Section 3 we show that many requests do not find a block in the same region in remote nodes for various shared memory multiprocessor configurations. We comment on related work in Section 4. We present the principle of operation for RegionScout filters in Section 5. We also discuss their implementation and additional benefits that come "for free". We explain how RegionScout fundamentally differs from directories in Section 5. <ref type="bibr" target="#b3">4</ref>. In Section 6, we show experimentally that RegionScout filters are effective and can reduce bandwidth and energy. Finally, we summarize this work in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Methodology</head><p>Our simulator is based on Simplescalar v2.0 <ref type="bibr" target="#b5">[6]</ref> with Manjikian's shared memory extensions <ref type="bibr" target="#b20">[21]</ref>. We made extensive changes to the simulator and the shared memory support libraries since Manjikian's model is limited to directmapped caches, uses pseudo system calls for synchronization and does not implement all PARMACS macros necessary to run all the SPLASH2 benchmarks. For synchronization we modelled the load linked and store conditional MIPS instructions which we used to implement all synchronization primitives including MCS locks <ref type="bibr" target="#b24">[25]</ref>. We added support for set-associative caches, shared or private L2 caches and a bus model. We used a modified version of GNU's gcc v2.7.2 to produce optimized PISA binaries for the SPLASH2 benchmarks <ref type="bibr" target="#b32">[33]</ref> shown in Table <ref type="table" target="#tab_0">1</ref>. We do not include Water as a result of a math library bug. We use the two models of shared multiprocessor systems shown in Figure <ref type="figure" target="#fig_0">1</ref>. Under model LocalL2 each node has private L1 and L2 caches and there is a shared L3 or main memory. This is representative of conventional SMPs. Under model SharedL2 nodes have private L1 caches and there is a shared L2. This is representative of simple CMPs <ref type="bibr" target="#b13">[14]</ref> and to a lesser extend of processors like Power4 <ref type="bibr" target="#b31">[32]</ref> that are popular as building blocks for larger SMP systems. We include both models since energy-and bandwidth-wise they behave differently (with the differences being primarily a function of block and cache sizes). We use a MESI coherence protocol. We modelled systems with two, four, eight or 16 processors. Unless otherwise noted, LocalL2 systems have L2 caches of the specified size that are eight-way set-associative with 64byte blocks and 32Kbyte L1 caches that are four-way setassociative with 32-byte blocks. In SharedL2 systems the L1 caches use 32-byte blocks and are four-way set-associative and of the specified size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Motivation</head><p>For clarity, we first define the terms region, region miss and global region miss. A region is an aligned, continuous section of memory whose size is a power of two. A request for a block B in a cache C results in a region miss if C holds no block in the same region as B including B itself. We were motivated by the observation that often memory requests result in region misses in all remote caches, or, in a global region miss or GRM for short. This is a generalization of observations made by earlier work in snoop energy reduction. Specifically, earlier work has shown that this property holds for cache blocks <ref type="bibr" target="#b26">[27]</ref> or pages <ref type="bibr" target="#b11">[12]</ref>. Intuitively, one would expect that this property would apply to other region sizes as well. This intuition holds true as shown in Figure <ref type="figure">2</ref> where we measure the global region miss ratio for systems with different number of nodes and cache sizes. The global region miss ratio is the fraction of all coherent memory requests that result in a global region miss. We consider regions of 256 bytes up to 16K bytes and systems with two, four, eight and 16 processors. In part (a) the per node L2 cache size is varied from 512K bytes to four megabytes. In part (b) the per node L1 cache size is varied from 32Kbytes to 128Kbytes. We do not model SharedL2 systems with 16 processors since they do not appear to be a reasonable design (i.e., the L1 caches do not effectively reduce coherence traffic for such a system). In general, the average global region miss ratio is inversely proportional to private cache sizes, node count and region size. (An anomaly is observed in (a) when the number of nodes increases from four to eight. This is primarily a result of our barrier implementation and of the memory allocation of related structures.) Even if we consider the worst case (four node LocalL2 with four Mbyte L2 caches) more than one in  local L1 caches and a shared L2. The interconnect is functionally a bus but may be implemented via other components <ref type="bibr" target="#b10">[11]</ref>. three requests results in a global region miss for a region as large as 16K bytes. For typical organizations the fraction of global region misses is much higher. For example, for the four node LocalL2 system with 512K L2 caches, the average global region miss ratio varies from 74% down to 48% depending on the region size. For the SharedL2 four node system with 64K L1 caches the average global region miss ratio varies from 79% down to 58%. Individual program behavior varies greatly as we will see in Section 6.1. Global region misses decrease as the node count increases. But, the relative decrease gradually diminishes suggesting that potential may exist even with more nodes. These results suggest that if we could detect or predict a priori that a shared memory request would result in global region miss then we could avoid broadcasts for anywhere between 88% and 34% of all requests depending on the specific organization. There are potential energy, latency and bandwidth benefits: 1. We could reduce the bandwidth requirements by avoiding the snoops that would result in a global region misses. Such snoops are unnecessary. 2. We could reduce energy by avoiding the tag lookups in all remote caches similarly to previous work <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b26">27]</ref>. Furthermore, if the interconnect permits it, we could avoid communicating will all remote nodes reducing energy even further. For example, in systems where broadcasts are implemented over a switch-based interconnect this may be possible <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b21">22]</ref>. This may also be possible in bus-based CMPs. or systems that use a separate bus for snoops. 3. Finally, by avoiding some snoops we could reduce the latency of the corresponding memory requests.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CPU</head><p>Of the aforementioned potential applications we limit our attention to bandwidth and tag lookup energy reduction. Previous work has also shown that a significant fraction of requests that hit in some remote caches rarely hit in all or even many of them <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b29">30]</ref>. In Section 5. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(a) LocalL2</head><p>Region size</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>All Requests global region miss ratio global region miss ratio</head><p>the frequent and often the common case of regions that are not shared at all. For this reason and because it utilizes imprecise information, RegionScout requires a single additional global signal as opposed to a sharing vector and requires only surgical changes to the existing infrastructure. RegionScout never has to be turned off for correct operation and disassociates the choice of region size from the rest of the design provided that physical addresses are used. Saldanha and Lipasti proposed serial snooping to reduce energy in shared multiprocessors <ref type="bibr" target="#b29">[30]</ref>. Ekman et. al., evaluated Jetty and serial snooping for chip multiprocessors demonstrating little or no benefit <ref type="bibr" target="#b12">[13]</ref>. Li et. al., proposed the thrifty barrier to reduce processor energy. It uses wait time prediction to selectively place a processor into a lower power state while it waits on a barrier <ref type="bibr" target="#b19">[20]</ref>. Recently, several coherence predictors have been proposed <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b28">29]</ref>. While some predictors may be able to capture the same behavior (e.g., by predicting the destination set or by using an "all or nothing" policy <ref type="bibr" target="#b22">[23]</ref>) RegionScout obviates the need to predict the destination set for many requests thus freeing bandwidth for more aggressive optimizations and reducing the working set of accesses that a predictor will have to track. While the potential for synergy exists, an investigation of combinining RegionScout with coherence predictors is beyond the scope of this paper. A preliminary evaluation of RegionScout appears in <ref type="bibr" target="#b25">[26]</ref>. Cantin, Lipast and Smith have also proposed exploiting coarse sharing for snoop coherence bandwidth reduction <ref type="bibr" target="#b7">[8]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">RegionScout Filters</head><p>RegionScout filters allow each node to locally determine that a request will result in a global region miss and thus avoid the corresponding remote snoops and transactions. Informally, whenever a node issues a memory request it also asks all other nodes whether they hold any block in the same region. If they do not, it records the region as not shared. Next time the node requests a block in the same region it knows that it does not need to probe any other node. Correctness is maintained since whenever another node requests a block in the same region, it will broadcast its request invalidating the "not shared" region records held by other nodes. What allows RegionScout to be effective yet inexpensive is that it works for most and not all requests that would result in a global region miss. Formally, the RegionScout filters comprise two structures local to each node: (a) a "not shared" region table, or NSRT, and (b) a cached region hash, or CRH. The NSRT records non-shared regions. The CRH is a Bloom filter (similar to the inclusive Jetty <ref type="bibr" target="#b26">[27]</ref>) that records a superset of all regions that are locally cached. Example organizations of CRH and NSRT are given in Section 5.2.</p><p>Here is how RegionScout works: Initially, all caches, CRHs and NSRTs are empty. Whenever a node N issues a memory request, the other nodes respond normally via the existing coherence protocol but in addition, using their CRH, they report (see Section 5.2.3 for a discussion) whether they cache any other block in the block's region. If the region is not shared node N then record it in its NSRT. Next time node N requests a block it first checks its NSRT. If a valid record is found then it knows that no other node holds this block and can avoid broadcasting this request. To ensure correctness it is imperative to invalidate NSRT entries whenever any other node requests a block in the corresponding region. This is easily done as part of the existing protocol actions. Specifically, if another node N' requests a block in the same region, it too will check its own NSRT and since it will not find a valid record it will broadcast its request to all other nodes. The NSRT of node N will then invalidate the corresponding entry and subsequent requests will be broadcast as they should. Key to RegionScout's success is the ability at each node and given a block to determine whether there is any other block in the same region that is locally cached. One possibility would be to use a table to keep a precise record of all regions that are locally cached similarly to what is done for pages in PST <ref type="bibr" target="#b11">[12]</ref>. The size of the table would artificially limit what can be cached and special actions would required to avoid exceeding these limits. RegionScout avoids these issues by using the CRH, an imprecise record of all locally cached regions. Without the loss of generality we limit our attention to the LocalL2 model. CRH works as follows: Whenever a block is allocated in or evicted from the L2, we use the region part of its address and hash into the CRH. Because there are much fewer CRH entries than regions many regions may map onto the same CRH entry. Each CRH entry counts the number of locally cached blocks in the regions that hash to it. Accordingly, when a block is allocated in the L2 we increment the corresponding CRH entry and when a block is evicted we decrement it. These updates are local at each node. Given a remote request for a block, the CRH can be used to indicate whether it would result in a region miss. If the corresponding CRH counter is zero then we know for sure that no block within the region is cached locally . Otherwise, blocks in the same region may be cached. It is the uncertainty of the latter response that allows us to use a small structure effectively. Figure <ref type="figure" target="#fig_2">3</ref> shows an example of RegionScout at work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">RegionScout as a Layered Extension</head><p>RegionScout can be implemented as a layered extension over existing coherence protocols and multiprocessor systems. No changes are required in the underlying coherence protocol, cache hierarchy and software (with the exception of reporting clean replacements to the CRH). RegionScout can operate in parallel with existing structures, inhibiting snoops and broadcasts by intervening when necessary. To existing mechanisms it appears as if the coherence protocol reported a miss. RegionScout is also completely transparent to software and the operating system. It does not impose any artificial limits on the choice of region size or on what can be locally cached. Finally, since it uses dynamically collected information it can adapt to changing sharing behavior identifying regions that are only temporarily not shared. Since every request has to probe the NSRT prior to being issued on the interconnect the latency of handling such requests will increase. The NSRT is comparatively small (we consider NSRTs of up to 64 entries) and as such its latency will be comparatively small. As we explain in Section 5.3 the CRH can also be used as a simplified inclusive Jetty filter filtering many snoop-induced tag lookups that would otherwise miss. <ref type="figure" target="#fig_3">4</ref> illustrates the NSRT and CRH organization and how physical addresses are used to index them (we assume a 42 bit physical address space and 16K regions). NSRT is a simple table with entries comprising a valid bit (V) and a region tag (the upper part of the address). The NSRT can be set-associative. Prior to issuing a coherent request each node checks whether a matching record exists in its NSRT. If so, it knows that this block is not shared. NSRT entries are evicted either as a result of limited space or when a remote node requests a block in a matching region.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Structures</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">NSRT and CRH. Figure</head><p>CRH is a table whose entries comprise a counter (count) field and a present bit (p). Essentially it is a inclusive Jetty with just one array <ref type="bibr" target="#b26">[27]</ref> or a Bloom filter implementation <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b17">18]</ref>. The count field counts the number of matching blocks in the regions that map onto it. In the worst case, all blocks in the cache would belong to the same region. Hence, the count field needs lg(Cache Size/Block Size) bits. The p-bit indicates whether count is non-zero. We use the p-bits to reduce energy and delay when probing the CRH <ref type="bibr" target="#b26">[27]</ref>. Updating the CRH is done when blocks are allocated or evicted from the L2 or the L1 for models LocalL2 and SharedL2 respectively. Only when a count entry changes value from or to zero the p-bits are updated. Small CRHs and NSRTs are sufficient for our purposes. For example, a 256 entry CRH needs 256 bits for the p-bit array and less than 4Kbits for the counter array assuming an 1Mbyte cache with 64 byte blocks. A 64 entry NSRT requires 1Kbits. In principle the choice of the CRH indexing function can impact how well it manages to differentiate amongst cached and uncached regions. In this work, we simply use the low order bits of an address.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">Simplified CRH Counter Array.</head><p>In the inclusive Jetty design the count fields are updated arithmetically. We propose a simpler design that replaces the adder with a reversible linear feedback shift register or LFSR <ref type="bibr" target="#b1">[2]</ref>. Appropriately designed n-bit LFSRs generate sequences of 2 n -1 states. LFSRs are used as pseudo-random number generators in many applications including testing and communications. LFSRs are much simpler, faster and energy efficient than arithmetic counters. For example, for a 4Mbyte L2 cache (worst case scenario we considered) we need 2 16  states or 17 bit LFSRs. Each of these requires just eight XOR gates or few tens of transistors. The key advantage of the LFSR-based design is that LFSRs can be embedded in the SRAM array thus drastically reducing power. Due to space limitations we do not describe the complete design here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.3">Communicating Region Sharing Information and</head><p>Inhibiting Snoops. In a bus inteconnect, an additional, wired-OR bus signal, RegionHit, can be used to identify global region misses. This represents a small overhead compared to typical bus implementations that use several tens of signals  (e.g., approximately 90 in MIPS R10000 <ref type="bibr" target="#b0">[1]</ref>). Prior to issuing a request RegionHit is de-asserted. In response, a node whose CRH reports a region "hit" asserts RegionHit. On global region misses no node will assert RegionHit. To inhibit snoops in a true bus implementation RegionHit can be overloaded as follows: Prior to issuing a request that would otherwise result in a global region miss (as reported by the NSRT) a node asserts RegionHit. Other nodes can sample RegionHit prior to snooping and thus avoid snooping altogether. For other requests RegionHit is de-asserted as before so that other nodes can snoop and report region hits.</p><p>The information necessary for detecting global region misses and inhibiting snoops is a single bit. For this reason we expect that it will represent a small overhead for other interconnect architectures also. Moreover, it may be possible to embed this information in the existing protocol (i.e., in the control information) with no physical overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Avoiding Tag Lookups for Non-Global Region Misses</head><p>As described RegionScout can avoid broadcasts for those requests that would result in a global region miss. Additional benefits are possible "for free" for requests that would result in region misses in some but not all remote nodes. The CRH can be used as a simplified inclusive Jetty as follows: Whenever node N makes a request, all other nodes probe their CRHs to determine whether they will report a region miss. If a node N' determines that it has no matching block in the same region then it does not need to probe its local L2 or L1 tag array (for LocalL2 and SharedL2 respectively). By avoiding these lookups we can further reduce tag energy and tag bandwidth requirements. This comes at the expense of increased latency while probing the local tag arrays in response to a remote request. Since, only the small p-bit array is probed, the latency penalty will be small. How much potential is there for this optimization? In the interest of space we limit our attention to the 16K byte region and to four node LocalL2 and SharedL1 systems with 512K L2 and 64K L1 caches respectively. Table <ref type="table" target="#tab_2">2</ref> reports the remote region hit count distribution. The fist column corresponds to global regions misses. The fraction of requests that incur a region miss in some remote caches (columns "1" and "2") is significant for all programs. In barnes, radiosity, radix, raytrace, volrend and to a lesser extend fmm many requests result in a region hit in all other nodes (column "3'). This may seem to contradict previous findings that most requests miss in remote caches but we emphasize that here we look at much larger regions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">RegionScout and Directories</head><p>RegionScout provides region-level sharing information that is not available in a conventional directory. It is possible to track such coarse grain information in a directory and our results of Section 3 may serve as good motivation for doing so. But there are bandwidth and complexity trade-offs since nodes would have to communicate block evictions in addition to regular coherence traffic. For this reason, even in this case opting for RegionScout may be preferable offering some of the benefits of a full-blown region-level directory at a minimal cost. In particular, RegionScout can be used to inhibit broadcasts for non-shared regions. It is also straightforward to extend RegionScout by including per node sharing information similarly to what was done in the PST <ref type="bibr" target="#b11">[12]</ref>. In this case, RegionScout can act as an imprecise, distributed region-level directory. The results of Section 5.4 serve as motivation for doing so. However, this investigation is beyond the scope of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Evaluation</head><p>In the interest of space and unless otherwise noted we limit our attention to the LocalL2 and SharedL2 models with 512K L2 and 64K L1 caches respectively. In Section 6.1 we show the global region miss behavior of individual programs as a function of region size. In Section 6.2 we demonstrate that practical RegionScout filters can capture many global region misses. We chose a large enough NSRT and focus on region and CRH size. We identify the trade offs among region size, detected global region misses and RegionScout filter storage requirements. In Section 6.3 we demonstrate that RegionScout can be used to avoid broadcasts in snoop coherence. In Section 6.4 we show that it can be used to avoid many snoop induced tag lookups thus reducing tag energy and also compare it to Jetty. The two applications also serve to demonstrate that we can tailor the RegionScout filters to meet different trade-offs. The specific choice depends on what is the primary consideration: energy or performance. In Section 6.5 we demonstrate that the potential exists for RegionScout to be useful under commercial workloads. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Per Program Global Region Miss Behavior</head><p>Since average behavior can be misleading we also look at individual program behavior. Figure <ref type="figure">5</ref> reports the global region miss ratio per program for regions of 256 through 16K bytes. Parts (a) and (b) are for models LocalL2 and SharedL2 respectively. In the interest of space we restrict our attention to four node systems. In addition to the intrinsic sharing characteristics of each program the observed global miss ratios are mostly inversely proportional to the region and cache sizes. Programs can be classified in three categories based on how sensitive they are to the choice of region size. Cholesky, fft and ocean exhibit high global region miss ratios and are mostly insensitive to region (and cache) size. In barnes, fmm, raytrace and volrend the global region miss ratio decreases almost linearly as the region size increases. Finally, radix, radiosity and to a lesser extend, lu, exhibit abrupt changes in their global miss ratio when the region size increases above 2K, 8K and 4K respectively. For the smallest region size of 256 bytes the global miss ratio is above 37% for all programs under both models. With the largest region of 16K bytes the miss ratio remains above 30% for all programs except barnes and raytrace under the LocalL2 model (and under the SharedL2 for barnes). This result is important as it suggests that sufficient global misses occur even when we look at very coarse grain sharing. Using large regions is attractive as smaller structures could be used to track them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Can Practical RegionScout Filters Detect Many Global Region Misses?</head><p>We have seen that sufficient global region misses occur in the programs we studied. The question we answer affirmatively in this section is whether practical RegionScout filters can capture most of them. For this purpose we use an NSRT with 64 entries (16 sets, 4-way set associative) and measure the filter rate for different CRHs. We define the filter rate as the fraction of all requests that are detected as global region misses by the RegionScout filter. A global region miss is detected when the originating node finds a matching entry in its NSRT prior to issuing the request. We found that an NSRT of 64 entries approximates one with infinite entries. We consider CRHs of 256 through 2K entries and regions of 2K through 16K bytes. The resulting average filter rates are shown in Figure <ref type="figure" target="#fig_5">6</ref>. Each of the curves corresponds to a different region size and to a system with a different number of nodes. The curves are identified as pN.C.RS where N is the number of nodes, C is the cache size (L2 for LocalL2 and L1 for SharedL2) and S is the region size. While we have seen that using smaller regions typically results in higher global miss ratios here we observe a trade-off between region and CRH size. In most cases using a larger region results in a higher filter rate with the difference being greater for the smaller CRHs (i.e., 256 or 512 entries). The CRH is an imprecise representation of cached regions. Using larger regions results in fewer regions and improves the CRH's ability to separate among them. Only when the size ratio "CRH over cache" becomes large enough we see a benefit in using smaller region sizes. This can be seen under the SharedL2 model when the local caches are only 64K and for the 2K entry CRH Figure <ref type="figure" target="#fig_6">7</ref> shows the per program filter rates for various CRH sizes. We restrict our attention to the 16K byte regions and to four node systems with 512K L2 and 64K L1 caches. Under the SharedL2 model (part (b)) it is conflict misses that dominate traffic and this results in much higher temporal and spatial locality in the request stream. For this reason and given that there are fewer regions per node even the 256 entry CRH can capture most global region misses. While the filter rates increase with CRH size these improvements are modest. Under the LocalL2 model in part (a), the filter rate is more sensitive to CRH size. This is because a much larger portion of data and thus more regions remain resident in the caches. Under LocalL2, larger CRHs result in significantly higher filter rates for some programs (e.g., ocean, cholesky and fmm). Lu, barnes and raytrace are mostly insensitive to CRH size. An anomaly is observed for radiosity where the filter rate decreases when the CRH entries are increased from 256 to 512. In this case we have thrashing in the NSRT: more regions are identified as non-shared but their base addresses are such that they trash few sets in the NSRT. This thrashing persists for the 2K CRH but the resulting filter rate is higher since additional non-shared regions are identified which map to different sets in the NSRT.</p><p>In summary, we have found that practical RegionScout filters can detect most global region misses. While there are more global region misses for smaller regions, detecting them requires larger RegionScout filters. For the configurations we studied using a large region (e.g., 16K) is typically better. For a given region size, filter rates improve with CRH size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Bandwidth Reduction</head><p>We demonstrate that RegionScout can reduce the broadcasts in snoopy coherence systems and hence reduce bandwidth demand. We use a first-order approximation model to identify trends in the reduction in average processing time for snoops in a bus-based system. In lack of an accurate timing model we do not demonstrate any other tangible benefits.</p><p>Emerging technology trade-offs favor point-to-point links over buses for high performance interconnects <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b21">22]</ref>. Accordingly, we modelled two systems. The first is based on Sun's Starfire architecture <ref type="bibr" target="#b8">[9]</ref>. It uses a bus for control information (all requests appear on this bus) and a switchbased interconnect for data (Starfire, targeted at a much larger number of processors uses four buses for snoops). The second model is for a hypothetical system where nodes are connected via a switch for both data and control. For this application we can afford to use the larger RegionScout filters as performance is our primary goal. Accordingly, in all experiments the NSRT has 64 entries and is four-way setassociative and the CRH has 2K entries.    L2 and 64K L1 for LocalL2 and SharedL2 respectively). The reduction is proportional to the filter rate taking into account the additional traffic due to writebacks. With eight processors RegionScout reduces traffic to 73% and 65% of the base system for the LocalL2 and SharedL2 models respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Bus-Based Model:</head><p>We model the control bus as an M/M/1 queue. We restrict our attention to the 16K region and to four way systems. We estimate response times for snoop processing latencies of two, four, eight and 12 processor cycles (labels c2, c4, c8 and c12 respectively). These latencies are optimistic given existing systems and the relative scaling properties of bus vs. processor cycle times. Using optimistic latencies is acceptable in this experiment since the slower the bus the higher the impact of reducing bandwidth demand. To estimate the arrival rate we used an average IPC value of 1.4 as per published measurements for scientific applications on commercial systems <ref type="bibr" target="#b9">[10]</ref>. Larger IPC values would have lead to higher benefits from RegionScout. Figures <ref type="figure" target="#fig_7">8(b</ref>) and 8(c) report results for the LocalL2 and SharedL2 systems respectively. Shown is the ratio of the average snoop response time with RegionScout over that without RegionScout. In general, the slower the bus the higher the benefits with RegionScout. With the exception of ocean and to a lesser extend cholesky and raytrace, there is little change in response time for the LocalL2 system. This suggests that the shared control bus is under-utilized and hence reducing bandwidth by itself would not lead to performance improvements. A much higher reduction in average response time is observed for the SharedL2 system. With a 12 processor cycle snoop processing latency a reduction of 15% or more is observed for cholesky, fft, lu, ocean, radix and raytrace. While we do not report these results, the reduction in response time in higher for the eight way SharedL2 system. This result suggests that snoop-based coherence coupled with RegionScout can be a viable low cost and high performance alterative for on-chip CMPs.</p><p>Point-to-Point Interconnect Model: Under the assumptions for the point-to-point interconnect a broadcast requires N-1 messages in an N node system (more would have been required for other interconnects such as a torus). Each link is capable of transferring 64-bits of data per message plus address and control information. Transferring a 32 byte block requires five messages at a minimum (one is for the request and the other four are for the data). With RegionScout it is not necessary to probe all other nodes for some requests. We count the number of messages sent during execution with and without RegionScout and report the ratio: Figure <ref type="figure">9</ref>(a) reports the message ratio for the point-to-point interconnect model for the same RegionScout filters as in Figure <ref type="figure" target="#fig_7">8</ref>. We observe a reduction in messages in the range of 6% and up to 34%. The reduction is higher for the SharedL2 system (grey marks) for two reasons: Coherence messages are a higher percentage of all messages due to the smaller cache block size and the filter rates are higher as compared to the LocalL2 systems. In some cases, using larger regions results in higher benefits since it allows the CRH to better separate among the fewer regions. For the configurations we studied using smaller regions does not result in significantly higher benefits even though we have seen that there are more global misses with smaller regions. This suggests that the CRH configurations we studied are incapable of separating among many small regions and better suited for larger regions. For completeness we report per program message ratios for the four node SharedL2 system in Figure <ref type="figure">9(b)</ref>. Individual program behavior varies as the resulting behavior is a function of the filter rate and the fraction of messages used for coherence. Programs with a higher fraction of coherence messages are more sensitive to changes in the filter rate. We do not attempt an analytical model of response time since this interconnect does not behave as a simple queue.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Tag Energy Reduction</head><p>Previous work has shown that snoop induced tag lookups represent a significant fraction of cache energy <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b26">27]</ref>. We restrict our attention to 16Kbyte regions and the LocalL2 and SharedL2 systems with 512K L2 and 64K L1 caches. Since the RegionScout filters consume energy they represent an overhead which should be amortized by the benefits. Accordingly, we select small RegionScout filters. The NSRT has 16 entries and is direct mapped and the CRH has 256 entries. Using larger RegionScout filters resulted in lower energy benefits and in some cases in an increase in energy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4.1">Comparing to Jetty.</head><p>We first compare to the previously proposed JETTY filters <ref type="bibr" target="#b26">[27]</ref>. Specifically, we simulated hybrid Jetty filters comprising an exclusive Jetty of 16 entries with 32 bit vectors and one out of four inclusive Jetty filters. The first three inclusive Jetty filters use three tables of 1K, 512 or 256 entries and we will use the acronyms 10x3, 9x3 and 8x3 to refer to them respectively. The fourth inclusive Jetty filter uses four tables of 128 entries each (acronym 7x4). We chose these four configurations after experimenting with several others. The specific sizes are in par with what was reported in the original Jetty study <ref type="bibr" target="#b26">[27]</ref> except in that we use fewer sub-arrays and hence incur less energy overhead. We do so since in our simulation environment only the lower 32bits of addresses are non-zero. For clarity we use a "pN.filter" naming scheme where N is the number of nodes and filter is the snoop filter which can be a Jetty (10x3, 9x3, 8x3 or 7x4) or the aforementioned RegionScout configuration (RS). Figure <ref type="figure" target="#fig_8">10</ref>(a) reports the average filter rate for SharedL2 configurations with two, four and eight nodes. The filter rate here is measured as a fraction of all snoop-induced tag lookups and is different from the filter rate reported in earlier sections (previously we were concerned with coherence requests where here we are interested in the tag lookups these induce in remote nodes). The grey bars correspond to Jetty filters while the white bars to RegionScout. It can be seen that the filter rate with RegionScout is comparable to the 8x3 Jetty. The latter utilizes at least three times as much resources. Figure <ref type="figure" target="#fig_8">10</ref>(b) compares the various filters for the LocalL2 systems. Here RegionScout performs even better offering filtering rates that are higher than those possible even with the 9x3 Jetty which uses at least six times as much <ref type="figure">--------------------------------------------------------------------------------------------------</ref>resources than RegionScout. Due to the lack of space we do not report per program results noting that the trends are similar for all programs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MessageCountWithRegionScout MessageCountWithoutRegionScout</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4.2">Energy Reduction.</head><p>We measure the energy consumed during tag lookups in the L2 and L1 caches (all accesses, local or snoop induced) and report the energy ratio:</p><p>To measure energy we use the WATTCH models <ref type="bibr" target="#b6">[7]</ref>. The L1 and L2 caches were auto-partitioned using CACTI and modelled as SRAM arrays. We modelled the NSRT and the CRH as SRAM arrays also. The NSRT comprises a small SRAM while the CRH comprises two SRAMs, one for the present bits and one for the LFSR counters. We take into account the energy overhead of all RegionScout probes and updates. In the interest of space we not report energy results for Jetty. In most cases, the Jetty filters did not reduce energy for the SharedL2 systems (this corroborates earlier findings <ref type="bibr" target="#b12">[13]</ref>). For the LocalL2 systems, Jetty filters did reduce energy but the reduction was smaller or comparable to that possible with RegionScout. Jetty utilizes much larger structures hence it incurs a much larger overhead than RegionScout.</p><p>Figure <ref type="figure" target="#fig_9">11</ref> reports the tag energy ratio per program and for systems with different number of nodes. The RegionScout filters energy overhead is included in the ratio and also reported separately. The resulting energy savings are primarily a function of (1) the fraction of tag accesses that are snoop-induced versus those that are generated locally, (2) the global region miss filter rate and (3) the filter rate of each CRH for those requests that are not identified as global region misses. In some cases the energy savings are higher than the filter rate for global region misses. This suggests that the CRHs filter some snoops that are not identified as global region misses by RegionScout. Most of these tag lookups are for requests that result in region misses in some but not all nodes (as per the discussion of section 5.3) and the others are for global region misses that are not identified by the requestor's NSRT. The LocalL2 systems benefit more from RegionScout since there snoop-induced tag lookups represent a higher fraction of overall tag accesses. This result corroborates previous findings <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b12">13]</ref>. RegionScout overhead is typically low.   <ref type="figure">--------------------------------------------------------------------------------------------------------------------------------------------=</ref> Compared to Jetty, RegionScout offers competitive energy reduction at a fraction of the cost. Moreover, RegionScout could also save energy on the interconnect. The reduction of messages reported in Section 6.3 serves as a first order approximation of the energy savings if we assume that energy consumption is proportional to the number of messages sent. We can also save energy in a bus-based CMP implementation by disabling the bus transceivers of remote nodes (an optimization not possible with Jetty). The overhead of an additional control signal would be negligible given typical bus signal counts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Commercial Workloads</head><p>We finally, consider a few non-numerical applications and demonstrate that a large number of global region misses exists. For this purpose we use traces generated by the SimFlex full-system simulator <ref type="bibr" target="#b14">[15]</ref>. The simulated system has 16 processors. Using these traces we simulated nodes with 512K local L2 caches to gather region miss statistics. All accesses are included including those from the operating system. We consider three workloads <ref type="bibr" target="#b30">[31]</ref>: (1) SpecWEB99 comprising two web servers Apache and Zeus (2000 client connections), (2) SpecJBB2000 (Sun HotSpot JVM 1.4.2 with 16 warehouses and 16 clients), and (3) IBM's db2 (online transaction processing workload with 100 warehouses and 400 clients with zero think time). The traces include the first 100 million requests after initialization. As it can be seen in Figure <ref type="figure" target="#fig_10">12</ref> significant potential exists for all the workloads even with large regions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Summary</head><p>We observed that many requests in shared memory multiprocessors not only do not hit in any remote node but also do not find any other block in a much larger surrounding region (global region miss). We proposed RegionScout a family of small and effective filters that can detect most of the requests that would result in a global region miss. RegionScout filters utilize imprecise information about the regions that are cached at each node in the form of hashed bit vector. This has several advantages as it requires only surgical additions over the existing infrastructure of conventional shared multiprocessors. This is especially important as the complexity of modern processors and the variability in behavior amongst different applications favors building systems out or pre-existing components using glue logic. RegionScout filters are transparent to software and do  not impose any artificial limits on what can be cached and when. We have demonstrated that RegionScout filters can be used to reduce bandwidth by avoiding broadcasts for some requests. Moreover, we have shown that can reduce energy by avoiding some of the tag lookups for snoops that would miss. RegionScout filters are fundamentally different than previous snoop filters and directory-based coherence. We expect that region-level information tracking and imprecise information tracking will have applications beyond coherence.  </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Two shared memory multiprocessor models. (a) LocalL2: local L1 and L2 caches and a shared L3. (b) SharedL2: local L1 caches and a shared L2. The interconnect is functionallya bus but may be implemented via other components<ref type="bibr" target="#b10">[11]</ref>.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: An example illustrating how RegionScout works. Without the loss of generality we use the LocalL2 model and show only two nodes. (a.1) Node N requests block B in region RB. The request is broadcast to all nodes (N first checked its NSRT and since it was empty it found no matching entry for region RB). (a.2) All remote notes probe their CRH and report that they do not cache any block in region B. (a.3) Node N records RB as not shared and increments the corresponding CRH entry. (b.1) Node N is about to request block B' in region RB and first checks that its NSRT. (b.2) Since an entry is found the request is send only to main memory. (c.1) Node N' requests block B'' in region RB. It first checks its NSRT. (c.2) Since the region is not recorded in its NSRT, it broadcasts its request. Node N invalidates its NSRT entry since now RB is shared.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: NSRT and CRH organization for 16Kbyte regions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 8 (Figure 5 :</head><label>85</label><figDesc>Figure 5: Global Region Miss ratios per program for various region sizes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Average global region miss filter rates (see text for the definition) for various CRH sizes (X-axis). The NSRT has 64 entries organized in 16 sets of four entries each. The curves correspond to systems with different number of nodes N and to different region sizes S as identified by the pN.C.RS labels. C is the size of the L2 and L1 caches for models LocalL2 (a) and SharedL2 (b) respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Filter rates per program for 16K byte regions on four node systems with 512K L2 (a) and 64K L1 (b) caches respectively. The NSRT is fixed at 64 entries (16 sets, 4-way set-associative) and the number of CRH entries varies as shown on the X-axis.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: (a) Relative control traffic for the bus-based interconnect model. Reported is the ratio of the average control traffic for the system with RegionScout over the base system. (b) and (c): Estimated average snoop response time ratio with RegionScout over the base system for LocalL2 and SharedL2 respectively. We report results for various snoop processing latencies. Per snoop latency is modelled in N processor cycles (labels cN) where N is 2, 4, 8 or 12. The NSRT has 64-entries and is 4-way set-associative and the CRH has 2K entries.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Snoop-induced tag lookups avoided with Jetty and RegionScout. The RegionScout filter used comprises a 256-entry CRH and a 16-entry 2-way set-associative NSRT and uses 16K regions. See text for a description of the four hybrid Jetty filters. We use a pN.filter naming scheme where N is the number of nodes and filter can be a Jetty (10x3, 9x3, 8x3 or 7x4) or RegionScout (RS).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Tag energy ratio and RegionScout energy overhead. 16K Region, 16-entry direct-mapped NSRTs and 256-entry CRHs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: (a) Global Region Miss ratios for four commercial application workloads with the LocalL2 model and 512K L2 caches and 16 processors.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 . SPLASH2 applications and input parameters.</head><label>1</label><figDesc></figDesc><table><row><cell>Benchmark</cell><cell>Input Parameters</cell></row><row><cell>barnes</cell><cell>16k particles</cell></row><row><cell>cholesky</cell><cell>tl29.O</cell></row><row><cell>fft</cell><cell>256k complex data points</cell></row><row><cell>fmm</cell><cell>16k particles</cell></row><row><cell>lu (contig.)</cell><cell>512x512 matrix, B=16</cell></row><row><cell>ocean (contig.)</cell><cell>258x258 grid w/ defaults</cell></row><row><cell>radiosity</cell><cell>-batch -room</cell></row><row><cell>radix</cell><cell>2M keys</cell></row><row><cell>raytrace</cell><cell>balls4.env</cell></row><row><cell>volrend</cell><cell>256x256x126 voxels</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 . Remote region hit count distribution for four node LocalL2 and SharedL2 systems with 512K L2 and 64K L1 caches respectively. The region is 16Kbytes. Column "0" corresponds to global region misses.</head><label>2</label><figDesc></figDesc><table><row><cell></cell><cell cols="3">Four Nodes, 16Kbyte Regions</cell><cell></cell></row><row><cell></cell><cell cols="3">LocalL2 Region Hit Count (%)</cell><cell></cell></row><row><cell>0</cell><cell>1</cell><cell>2</cell><cell>3</cell><cell></cell></row><row><cell>barnes</cell><cell>9.38</cell><cell>13.89</cell><cell>12.84</cell><cell>63.89</cell></row><row><cell>cholesky</cell><cell>87.87</cell><cell>6.22</cell><cell>4.88</cell><cell>1.03</cell></row><row><cell>fft</cell><cell>95.22</cell><cell>4.47</cell><cell>0.19</cell><cell>0.12</cell></row><row><cell>fmm</cell><cell>35.20</cell><cell>28.22</cell><cell>19.69</cell><cell>16.9</cell></row><row><cell>lu</cell><cell>48.78</cell><cell>44.95</cell><cell>3.73</cell><cell>2.55</cell></row><row><cell>ocean</cell><cell>85.52</cell><cell>11.77</cell><cell>1.66</cell><cell>1.05</cell></row><row><cell>radiosity</cell><cell>37.75</cell><cell>35.56</cell><cell>4.15</cell><cell>22.54</cell></row><row><cell>radix</cell><cell>33.32</cell><cell>15.15</cell><cell>25.99</cell><cell>25.54</cell></row><row><cell>raytrace</cell><cell>16.01</cell><cell>10.86</cell><cell>28.23</cell><cell>44.90</cell></row><row><cell>volrend</cell><cell>30.94</cell><cell>5.07</cell><cell>37.87</cell><cell>26.13</cell></row><row><cell>average</cell><cell>47.99</cell><cell>17.61</cell><cell>13.92</cell><cell>20.46</cell></row><row><cell></cell><cell cols="3">SharedL2 Region Hit Count (%)</cell><cell></cell></row><row><cell>0</cell><cell>1</cell><cell>2</cell><cell>3</cell><cell></cell></row><row><cell>barnes</cell><cell>15.12</cell><cell>14.03</cell><cell>10.61</cell><cell>60.24</cell></row><row><cell>cholesky</cell><cell>89.36</cell><cell>7.88</cell><cell>2.27</cell><cell>0.49</cell></row><row><cell>fft</cell><cell>99.14</cell><cell>0.74</cell><cell>0.02</cell><cell>0.09</cell></row><row><cell>fmm</cell><cell>47.00</cell><cell>21.32</cell><cell>5.61</cell><cell>26.06</cell></row><row><cell>lu</cell><cell>58.45</cell><cell>39.28</cell><cell>1.50</cell><cell>0.77</cell></row><row><cell>ocean</cell><cell>94.75</cell><cell>3.73</cell><cell>1.26</cell><cell>0.26</cell></row><row><cell>radiosity</cell><cell>31.10</cell><cell>19.07</cell><cell>1.97</cell><cell>47.86</cell></row><row><cell>radix</cell><cell>51.55</cell><cell>28.13</cell><cell>15.24</cell><cell>5.09</cell></row><row><cell>raytrace</cell><cell>61.16</cell><cell>23.24</cell><cell>9.80</cell><cell>5.80</cell></row><row><cell>volrend</cell><cell>33.31</cell><cell>9.72</cell><cell>26.96</cell><cell>30.01</cell></row><row><cell>average</cell><cell>58.09</cell><cell>16.71</cell><cell>7.52</cell><cell>17.66</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>CRH entries global region filter rate CRH entries global region filter rate 16K Regions, 16x4 NSRT 16K Regions, 16x4 NSRT All Requests All Requests</head><label></label><figDesc></figDesc><table><row><cell cols="2">100%</cell><cell cols="3">global region miss ratio</cell><cell></cell><cell>barnes</cell><cell></cell><cell></cell><cell>100%</cell><cell cols="2">global region miss ratio</cell><cell>barnes</cell></row><row><cell></cell><cell>90%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>cholesky</cell><cell></cell><cell></cell><cell>90%</cell><cell></cell><cell>cholesky</cell></row><row><cell></cell><cell>80%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>fft</cell><cell></cell><cell></cell><cell>80%</cell><cell></cell><cell>fft</cell></row><row><cell>All Requests</cell><cell>70% 30% 40% 50% 60%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>fmm lu ocean radiosity</cell><cell cols="2">All Requests</cell><cell>30% 40% 50% 60% 70%</cell><cell></cell><cell>fmm lu ocean radiosity</cell></row><row><cell></cell><cell>20%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>radix</cell><cell></cell><cell></cell><cell>20%</cell><cell></cell><cell>radix</cell></row><row><cell></cell><cell>10%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>raytrace</cell><cell></cell><cell></cell><cell>10%</cell><cell></cell><cell>raytrace</cell></row><row><cell></cell><cell>0%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>volrend</cell><cell></cell><cell></cell><cell>0%</cell><cell></cell><cell>volrend</cell></row><row><cell></cell><cell cols="4">256 (a) LocalL2: 4 nodes, 512K L2 512 1K 2K 4K 8K region size</cell><cell>16K</cell><cell></cell><cell></cell><cell></cell><cell cols="3">256 (b) SharedL2: 4 nodes, 64K L1 512 1 2 4 8 region size</cell><cell>16</cell></row><row><cell cols="2">90% 100%</cell><cell cols="4">NSRT: 16x4 entries global region filter rate</cell><cell>p2.512K.R4K p2.512K.R2K</cell><cell></cell><cell cols="2">90% 100%</cell><cell cols="2">NSRT: 16x4 entries NSRT: 16x4 entries global region filter rate</cell><cell>p2.64K.R2K</cell></row><row><cell></cell><cell>80%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>p2.512K.R8K</cell><cell></cell><cell cols="2">80%</cell><cell></cell><cell>p2.64K.R4K</cell></row><row><cell>All Requests</cell><cell>70% 40% 50% 60%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>p2.512K.R16K p4.512K.R2K p4.512K.R4K p4.512K.R8K p4.512K.R16K</cell><cell>All Requests</cell><cell cols="2">40% 50% 60% 70%</cell><cell></cell><cell>p2.64K.R8K p2.64K.R16K p4.64K.R2K p4.64K.R4K p4.64K.R8K</cell></row><row><cell></cell><cell>30%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>p8.512K.R2K</cell><cell></cell><cell cols="2">30%</cell><cell></cell><cell>p4.64K.R16K</cell></row><row><cell></cell><cell>20%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>p8.512K.R4K</cell><cell></cell><cell cols="2">20%</cell><cell></cell><cell>p8.64K.R2K</cell></row><row><cell></cell><cell>10%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>p8.512K.R8K</cell><cell></cell><cell cols="2">10%</cell><cell></cell><cell>p8.64K.R4K</cell></row><row><cell></cell><cell>0%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>p8.512K.R16K</cell><cell></cell><cell></cell><cell>0%</cell><cell></cell><cell>p8.64K.R8K</cell></row><row><cell></cell><cell>256</cell><cell>512</cell><cell>1K CRH entries</cell><cell cols="2">2K</cell><cell></cell><cell></cell><cell></cell><cell>256</cell><cell cols="2">CRH entries 512 1K CRH entries</cell><cell>2K</cell><cell>p8.64K.R16K</cell></row><row><cell></cell><cell></cell><cell cols="3">(a) LocalL2: 512K L2</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">(b) SharedL2: 64K L1</cell></row><row><cell cols="2">100%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>barnes</cell><cell></cell><cell></cell><cell>100%</cell><cell></cell></row><row><cell></cell><cell>90%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>cholesky</cell><cell></cell><cell></cell><cell>90%</cell><cell></cell><cell>barnes</cell></row><row><cell></cell><cell>80%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>80%</cell><cell></cell><cell>cholesky</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>fft</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>70%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>70%</cell><cell></cell><cell>fft</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>fmm</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>60%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>60%</cell><cell></cell><cell>fmm</cell></row><row><cell></cell><cell>50%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>lu</cell><cell></cell><cell></cell><cell>50%</cell><cell></cell><cell>lu</cell></row><row><cell></cell><cell>40%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>ocean</cell><cell></cell><cell></cell><cell>40%</cell><cell></cell><cell>ocean</cell></row><row><cell></cell><cell>30%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>radiosity</cell><cell></cell><cell></cell><cell>30%</cell><cell></cell><cell>radiosity</cell></row><row><cell></cell><cell>20%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>radix</cell><cell></cell><cell></cell><cell>20%</cell><cell></cell><cell>radix</cell></row><row><cell></cell><cell>10%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>raytrace</cell><cell></cell><cell></cell><cell>10%</cell><cell></cell><cell>raytrace</cell></row><row><cell></cell><cell>0%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>volrend</cell><cell></cell><cell></cell><cell>0%</cell><cell></cell></row><row><cell></cell><cell>256</cell><cell>512</cell><cell>1K</cell><cell>2K</cell><cell>infinite</cell><cell></cell><cell></cell><cell></cell><cell>256</cell><cell>512</cell><cell>1K</cell><cell>2K</cell><cell>infinite</cell><cell>volrend</cell></row><row><cell></cell><cell></cell><cell cols="4">(a) LocalL2: 4 nodes, 512K L2</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">(b) SharedL2: 4 nodes, 64K L1</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Region size All Messages (Data + Control) Region size All Messages (Data + Control) 16x4 NSRT, 2K CRH 16x4 NSRT, 2K CRH Message Ratio per Program Average Message Ratio</head><label></label><figDesc></figDesc><table><row><cell>Control Traffic Ratio</cell><cell>0% 10% 20% 30% 40% 50% 60% 70% 80% 100% 90%</cell><cell cols="3">16x4 NSRT, 2K CRH</cell><cell>p2.512K p4.512K p8.512K p2.64K p4.64K</cell><cell>Avg. Response Time Ratio</cell><cell>16x4 NSRT, 2K CRH</cell><cell>Avg. Response Time Ratio</cell><cell>16x4 NSRT, 2K CRH</cell></row><row><cell></cell><cell>2K</cell><cell>4K</cell><cell>8K</cell><cell>16K</cell><cell>p8.64K</cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="4">(a) Average Control Traffic Ratio</cell><cell cols="4">(b) Resp. Time Ratio: LocalL2, 4 Nodes, 512K L2 (c) Resp. Time Ratio: SharedL2, 4 Nodes, 64K L1</cell></row><row><cell></cell><cell>100%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>90%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>p2.512K</cell><cell></cell></row><row><cell></cell><cell>70% 80%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>p4.512K</cell><cell>EnergyRatio</cell><cell>TagEnergyWithRegionScout RegionScoutEnergy + TagEnergyWithoutRegionScout</cell></row><row><cell></cell><cell>60%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>p8.512K</cell><cell></cell></row><row><cell></cell><cell>50%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>40%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>p2.64K</cell><cell></cell></row><row><cell></cell><cell>30%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>20%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>p4.64K</cell><cell></cell></row><row><cell></cell><cell>10%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>p8.64K</cell><cell></cell></row><row><cell></cell><cell>0%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>2K</cell><cell>4K</cell><cell>8K</cell><cell>16K</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="5">(a) LocalL2: four nodes, 512K L2</cell><cell></cell></row><row><cell></cell><cell>100%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>barnes</cell><cell></cell></row><row><cell></cell><cell>90%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>cholesky</cell><cell></cell></row><row><cell></cell><cell>80%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>fft</cell><cell></cell></row><row><cell></cell><cell>70%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>fmm</cell><cell></cell></row><row><cell></cell><cell>60%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>50%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>lu</cell><cell></cell></row><row><cell></cell><cell>40%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>ocean</cell><cell></cell></row><row><cell></cell><cell>30%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>radiosity</cell><cell></cell></row><row><cell></cell><cell>20%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>radix</cell><cell></cell></row><row><cell></cell><cell>10%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>raytrace</cell><cell></cell></row><row><cell></cell><cell>0%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>volrend</cell><cell></cell></row><row><cell></cell><cell></cell><cell>2K</cell><cell>4K</cell><cell>8K</cell><cell>16K</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="5">(b) SharedL2: four nodes, 64K L1.</cell><cell></cell></row><row><cell cols="7">Figure 9: Avoiding broadcasts with RegionScout for various</cell><cell></cell></row><row><cell cols="8">region sizes. NSRT is 64-entries, 4-way set-associative and the</cell></row><row><cell cols="7">CRH has 2K entries. Shown is the ratio of messages sent with</cell><cell></cell></row><row><cell cols="8">RegionScout over those sent without it. (a) Average message ratio</cell></row><row><cell cols="7">for LocalL2 and SharedL2 systems with 512K L2 and 64K L1</cell><cell></cell></row><row><cell></cell><cell cols="6">caches respectively. (b) Message ratio per program for the</cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="5">SharedL2 system with 64K L1 caches.</cell><cell></cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>I would like to thank the reviewers of this and previous conferences for their valuable comments. My understanding of multiprocessors and the ideas presented in this paper have benefited significantly from discussions with Angelos Bilas, Babak Falsafi and Dionisios Pnevmatikatos. I would like to thank Babak Falsafi also for explaining how to develop the analytical performance estimation model and all the members of the CMU Impetus group for providing the commercial workload traces. I would also like to thank Mark Hill for pointing out the similarities between inclusive Jetty filters and Bloom filters. This work was supported by the Semiconductor Research Corporation under contract 901.001 and by an NSERC Discovery Grant.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><forename type="first">Mips</forename><surname>____</surname></persName>
		</author>
		<title level="m">R10000 Microprocessor User&apos;s Manual v2.0</title>
		<imprint>
			<publisher>MIPS Technologies, Inc</publisher>
			<date type="published" when="1997-01">January 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Abramovici</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Breuer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Friedman</surname></persName>
		</author>
		<title level="m">Digital Systems Testing &amp; Testable Design</title>
		<imprint>
			<publisher>Wiley-IEEE Computer Society Press</publisher>
			<date type="published" when="1993-01">January 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Alpha 21364: A Single-Chip Shared Memory Multiprocessor</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bannon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Lilly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Asher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Steinman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Webb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Litt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Government Microcircuits Applications Conference 2001, Digest of Papers</title>
		<meeting><address><addrLine>Belvoir, Va</addrLine></address></meeting>
		<imprint>
			<publisher>Defense Technical Information Center</publisher>
			<date type="published" when="2001-03">March 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Piranha: A Scalable Architecture Based on Single-Chip Multiprocessing</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Barroso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Gharachorloo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mcnamara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Nowatzyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Qadeer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Sano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Stets</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Verghese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 27th Annual International Symposium on Computer Architecture</title>
		<meeting>of the 27th Annual International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2000-06">June 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">B</forename><surname>Bloom</surname></persName>
		</author>
		<title level="m">Space/time trade-offs in hash coding with allowable errors. Communications of ACM</title>
		<imprint>
			<date type="published" when="1970-07">July 1970</date>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="422" to="426" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><surname>Burger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Austin</surname></persName>
		</author>
		<idno>UW-CS-97-1342</idno>
		<title level="m">The Simplescalar Tool Set v2.0</title>
		<imprint>
			<date type="published" when="1997-06">June 1997</date>
		</imprint>
		<respStmt>
			<orgName>Computer Sciences Department, University of Wisconsin-Madison</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Wattch: A Framework for Architectural-Level Power Analysis and Optimization</title>
		<author>
			<persName><forename type="first">D</forename><surname>Brooks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Tiwari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Martonosi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 27th Annual International Symposium on Computer Architecture</title>
		<meeting>of the 27th Annual International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2000-06">June 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Improving Multiprocessor Performance with Coarse-Grain Coherence Tracking</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Cantin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Lipasti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 32nd Annual International Symposium on Computer Architecture</title>
		<meeting>of the 32nd Annual International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2005-06">June 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Starfire: Extending the SMP Envelope</title>
		<author>
			<persName><forename type="first">A</forename><surname>Charlesworth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="1998-02">Jan/Feb 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Cvetanovic: Performance Analysis of the Alpha 21364-Based HP GS1280 Multiprocessor</title>
		<author>
			<persName><forename type="first">Z</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 30th Annual International Symposium on Computer Architecture</title>
		<meeting>of the 30th Annual International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2003-06">June 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Dally</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Poulton</surname></persName>
		</author>
		<title level="m">Digital Systems Engineering</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">TLB and Snoop Energy-Reduction using Virtual Caches for Low-Power Chip-Multiprocessors</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ekman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Dahlgren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Stenstrm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM International Symposium on Low Power Electronics and Design</title>
		<meeting>of ACM International Symposium on Low Power Electronics and Design</meeting>
		<imprint>
			<date type="published" when="2002-08">August 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Evaluation of Snoop-Energy Reduction Techniques for Chip-Multiprocessors</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ekman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Dahlgren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Stenstrm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the First Workshop on Duplicating, Deconstructing, and Debunking</title>
		<meeting>of the First Workshop on Duplicating, Deconstructing, and Debunking</meeting>
		<imprint>
			<date type="published" when="2002-05">May 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The Stanford Hydra CMP</title>
		<author>
			<persName><forename type="first">L</forename><surname>Hammond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hubbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Siu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Prabhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Olukotun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE MICRO Magazine</title>
		<imprint>
			<date type="published" when="2000-04">March-April 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">SimFlex: A Fast, Accurate, Flexible Full-System Simulation Framework for Performance Evaluation of Server Architecture</title>
		<author>
			<persName><forename type="first">N</forename><surname>Hardavellas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Somogyi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Wenisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Wunderlich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Falsafi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hoe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Nowatzyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">SIGMETRICS Performance Evaluation Review</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="31" to="35" />
			<date type="published" when="2004-03">March 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Exploring the design space of future CMPs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Huh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Burger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Keckler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 10th International Conference on Parallel Architectures and Compilation Techniques</title>
		<meeting>10th International Conference on Parallel Architectures and Compilation Techniques</meeting>
		<imprint>
			<date type="published" when="2001-09">September 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Coherence Communication Prediction in Shared-Memory Multiprocessors</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kaxiras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Young</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Sixth IEEE Symposium on High-Performance Computer Architecture</title>
		<meeting>of the Sixth IEEE Symposium on High-Performance Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2000-01">Jan. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Inexpensive implementations of set-associativity</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Kessler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jooss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lebeck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the Proceedings of the 16th Annual International Symposium on Computer Architecture</title>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Memory Sharing Predictor: The Key to a Speculative Coherent DSM</title>
		<author>
			<persName><forename type="first">A.-C</forename><surname>Lai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Falsafi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 26th Annual International Symposium on Computer Architecture</title>
		<meeting>of the 26th Annual International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="1999-05">May 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The Thrifty Barrier: Energy-Aware Synchronization in Shared-Memory Multiprocessors</title>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Mrtinz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 10th Annual International Symposium on High Performance Computer Architecture</title>
		<meeting>of the 10th Annual International Symposium on High Performance Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2004-02">Feb. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Multiprocessor Enhancements of the SimpleScalar Tool Set</title>
		<author>
			<persName><forename type="first">N</forename><surname>Manjikian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2001-03">March 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Token Coherence: Decoupling Performance and Correctness</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M K</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 30th Annual International Symposium on Computer Architecture</title>
		<meeting>of the 30th Annual International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2003-06">June 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Using Destination-Set Prediction to Improve the Latency/Bandwidth Tradeoff in Shared-Memory Multiprocessors</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M K</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Harper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Sorin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 30th Annual International Symposium on Computer Architecture</title>
		<meeting>of the 30th Annual International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2003-06">June 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Bandwidth Adaptive Snooping</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M K</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Sorin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 8th International Symposium on High-Performance Computer Architecture</title>
		<meeting>of the 8th International Symposium on High-Performance Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2002-01">January 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Algorithms for Scalable Synchronization on Shared-Memory Multiprocessors</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Mellor-Crummey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<date type="published" when="1991-02">February 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Exploiting Coarse Grain Non-Shared Regions in Snoopy Coherent Multiprocessors</title>
		<author>
			<persName><forename type="first">A</forename><surname>Moshovos</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003-12">Dec. 2003</date>
		</imprint>
		<respStmt>
			<orgName>Computer Engineering Group, University of Toronto</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Jetty: Filtering snoops for reduced energy consumption in SMP servers</title>
		<author>
			<persName><forename type="first">A</forename><surname>Moshovos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Memik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Falsafi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Choudhary</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 7th International Symposium on High-Performance Computer Architecture</title>
		<meeting>of the 7th International Symposium on High-Performance Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2001-01">January 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Using Prediction to Accelerate Coherence Protocols</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Mukherjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 25th Annual International Symposium on Computer Architecture</title>
		<meeting>of the 25th Annual International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="1998-06">June 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Coherence Predictor Cache: A Resource Efficient Coherence Message Prediction Infrastructure</title>
		<author>
			<persName><forename type="first">J</forename><surname>Nilsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Landin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Stenstrm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 6th IEEE International Symposium on Parallel and Distributed Processing Symposium</title>
		<meeting>of the 6th IEEE International Symposium on Parallel and Distributed essing Symposium</meeting>
		<imprint>
			<date type="published" when="2003-04">April 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Power Efficient Cache Coherence, High Performance Memory Systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Saldanha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Lipasti</surname></persName>
		</author>
		<editor>H. Hadimiouglu, D. Kaeli, J. Kuskin, A. Nanda, and J. Torrellas</editor>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Memory Coherence Activity Prediction in Commercial Workloads</title>
		<author>
			<persName><forename type="first">S</forename><surname>Somogyi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Wenisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Hardavellas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ailamaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Falsafi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Workshop on Memory Performance Issues</title>
		<imprint>
			<date type="published" when="2004-06">June 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">POWER4 system microarchitecture</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Tendler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Dodson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Fields</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Sinharoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM Journal of Research and Development</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2002-01">January 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">The SPLASH-2 programs: Characterization and methodological considerations</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Woo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ohara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Torrie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 22nd Annual International Symposium on Computer Architecture</title>
		<meeting>of the 22nd Annual International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="1995-06">June 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Cost-effective parallel computing</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Wood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Magazine</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1995-02">Feb. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
