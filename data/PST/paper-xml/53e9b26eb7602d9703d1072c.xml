<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Generic Type System for the Pi-Calculus *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2009-04-20">April 20, 2009</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Atsushi</forename><surname>Igarashi</surname></persName>
							<email>igarashi@kuis.kyoto-u.ac.jp</email>
							<affiliation key="aff0">
								<orgName type="institution">Kyoto University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Naoki</forename><surname>Kobayashi</surname></persName>
							<email>kobayasi@cs.titech.ac.jp</email>
							<affiliation key="aff1">
								<orgName type="institution">Tokyo Institute of Technology</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">A Generic Type System for the Pi-Calculus *</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2009-04-20">April 20, 2009</date>
						</imprint>
					</monogr>
					<idno type="MD5">9BCC177CCD2559BFF0F9083D4B4BE5A5</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:26+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We propose a general, powerful framework of type systems for the π-calculus, and show that we can obtain as its instances a variety of type systems guaranteeing non-trivial properties like deadlock-freedom and race-freedom. A key idea is to express types and type environments as abstract processes: We can check various properties of a process by checking the corresponding properties of its type environment. The framework clarifies the essence of recent complex type systems, and it also enables sharing of a large amount of work such as a proof of type preservation, making it easy to develop new type systems.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction 1.Motivation</head><p>Static guarantee of the correctness of concurrent programs is important: Since concurrent programs are more complex than sequential programs (due to non-determinism, deadlock, etc.), it is hard for programmers to debug concurrent programs or reason about their behavior.</p><p>A number of advanced type systems have recently been proposed to analyze various properties of concurrent programs, such as input/output modes <ref type="bibr" target="#b39">[40]</ref>, multiplicities (how often each channel is used) <ref type="bibr" target="#b29">[30]</ref>, race conditions <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b11">12]</ref>, deadlock <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b42">43,</ref><ref type="bibr" target="#b51">52]</ref>, livelock <ref type="bibr" target="#b27">[28]</ref>, and information flow <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b22">23]</ref>.</p><p>Unfortunately, however, there has been no satisfactorily general framework of type systems for concurrent programming languages: Most type systems have been designed in a rather ad hoc manner for guaranteeing certain specific properties. The lack of a general framework kept it difficult to compare, integrate, or extend the existing type systems. Moreover, a lot of tasks (such as proving type soundness) had to be repeated for each type system. This situation stands in contrast with that of type systems for functional programming languages, where a number of useful analyses (such as side-effect analysis, region inference <ref type="bibr" target="#b48">[49]</ref>, and exception analysis <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b38">39]</ref>) can be obtained as instances of the effect analysis <ref type="bibr" target="#b46">[47,</ref><ref type="bibr" target="#b47">48]</ref>.</p><p>The goal of this paper is therefore to establish a general framework of type systems for concurrent processes, so that various advanced type systems can be derived as its instances. As in many other type systems, we use the π-calculus as a target language: It is simple yet expressive enough to model modern concurrent/distributed programming languages. relation and a consistency condition of types and it can be instantiated to a variety of type systems by changing the subtyping relation and the consistency condition (see Section 3).</p><p>• We prove that the general type system satisfies several important properties (such as subject reduction), independently of a choice of the subtyping relation and the consistency condition. Therefore, there is no need to prove them for each type system. Using those properties, we also prove a general type soundness property, from which the soundness of a certain class of instances of the generic type system can be immediately obtained (see <ref type="bibr">Section 4)</ref>.</p><p>• We show that a variety of non-trivial type systems (such as those ensuring deadlock-freedom and race-freedom) can indeed be derived as instances of the general type system, and prove their soundness. Thanks to the general properties mentioned above, the proof for each instance of the generic type system is quite short; indeed, the soundness of most of the instances follows as an immediate corollary of the general type soundness theorem (see Sections 5 and 6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">The Rest of This Paper</head><p>Section 2 introduces the syntax and the operational semantics of our target process calculus. Section 3 presents our generic type system and Section 4 discusses the soundness of the generic type system. Section 5 derives a variety of type systems as instances of the generic type system. To further demonstrate the strength of our framework, Section 6 shows that deadlock and race conditions of concurrent objects can also be analyzed within our generic type system. Section 7 formalizes a part of type-checking/reconstruction algorithms that is common to all instances of the generic type system. Section 8 discusses limitations and extensions of our generic type system. Section 9 discusses related work and Section 10 concludes this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Target Language</head><p>This section introduces the syntax and the operational semantics of our target language.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Syntax</head><p>Our calculus is basically a subset of the polyadic π-calculus <ref type="bibr" target="#b35">[36]</ref>. To state properties of a process, we annotate each input or output operation with a label.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.1.1 [processes]:</head><p>The set of processes is defined by the following syntax.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>P (processes)</head><p>: Here, x, y, and z range over a countably infinite set Var of variables. t ranges over a countably infinite set T of labels called events. We assume that Var ∩ T = ∅. Notation 2.1.2: We write x for a (possibly empty) sequence x 1 , . . . , x n , and x for the length n of the sequence x. (ν x1 ) • • • (ν xn ) P is abbreviated to ( νx 1..n ) P or ( νx) P . As usual, ỹ in x? <ref type="bibr">[ỹ]</ref>. P and x in (ν x) P are called bound variables. The other variables are called free variables. We assume that α-conversions are implicitly applied so that bound variables are always different from each other and from free variables. The expression [z 1 /x 1 , . . . , z n /x n ]P , abbreviated to [z/x]P , denotes a process obtained from P by replacing all free occurrences of x 1 , . . . , x n with z 1 , . . . , z n . We often omit the</p><formula xml:id="formula_0">:= 0 | G 1 + • • • + G n | (P | Q) | (</formula><formula xml:id="formula_1">P | 0 ≡ P (SP-Zero) P | Q ≡ Q | P (SP-Commut) P | (Q | R) ≡ (P | Q) | R (SP-Assoc) * P * P | P (SP-Rep) (ν x) P | Q (ν x) (P | Q)(if x are not free in Q)</formula><p>(SP-New) (where G 1 , . . . , G n are input or output processes) denotes an external choice: It behaves like one of G 1 , . . . , G n depending on enabled communications. (ν x) P creates fresh channels x and then executes P .<ref type="foot" target="#foot_0">1</ref> * P denotes infinitely many copies of P running in parallel.</p><formula xml:id="formula_2">P P Q Q P | Q P | Q (SP-Par) P Q (ν x) P (ν x) Q (SP-CNew)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Operational Semantics</head><p>As usual <ref type="bibr" target="#b35">[36]</ref>, we define a reduction semantics by using a structural relation and a reduction relation. For technical convenience, we do not require the structural relation to be symmetric. The reduction relation P -→ Q is annotated with a label (which we call a reduction label) of the form x t,t or t,t . A reduction label records which channels and events are involved in the reduction: The label x t,t means that a communication occurss on a channel x and the output and input processes are labeled with t and t respectively. The reduction label t,t means that a communication occurs on a bound channel and the output and input processes are labeled with with t and t respectively. Reduction labels are used to state properties of a process in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.2.1:</head><p>The structural preorder is the least reflexive and transitive relation closed under the rules in Figure <ref type="figure">1</ref> </p><formula xml:id="formula_3">(P ≡ Q denotes (P Q) ∧ (Q P )).</formula><p>Definition 2.2.2: Let l be a reduction label, and S be a set of variables. We define l↑ S by: Notation 2.2.4:</p><formula xml:id="formula_4">(x t,t )↑ S = t,t if x ∈ S x t,t otherwise ( t,t )↑ S = t,t • • • + x! t [z]. P + • • • | • • • + x? t [ỹ]. Q + • • • x t,t -→ P | [z/ỹ]Q (R-Com) P l -→ Q P | R l -→ Q | R (R-Par) P l -→ Q (ν x) P l↑ {x} -→ (ν x) Q (R-New) P P P l -→ Q Q Q P l -→ Q (R-SP)</formula><formula xml:id="formula_5">We write P -→ Q if P l -→ Q for some l.</formula><p>Notation 2.2.5: When R 1 , R 2 are binary relations on a set S, we write R * 1 for the reflexive and transitive closure of R 1 , and R 1 R 2 for the composition of R 1 and R 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Generic Type System</head><p>This section introduces our generic type system and shows its properties.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Types</head><p>We first define the syntax of types. We have two kinds of types: types of tuples (called tuple types) and those of processes (called process types). Process types correspond to the type environments mentioned in Section 1; they express abstract behavior of processes. We assume that we have countably infinite sets of type variables for each size of tuples. We write α (n) for a type variable ranging over a type of n-tuples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.1.1 [types]:</head><p>The sets of tuple types and process types are defined by the following syntax.</p><formula xml:id="formula_6">τ (n) (n-ary tuple types) ::= α (n) | (x 1 , . . . , x n )Γ | µα (n) .τ (n) Γ (process types) ::= 0 | γ 1 + • • • + γ n | (Γ 1 | Γ 2 ) | Γ 1 &amp;Γ 2 | τ (n) v 1 , . . . , v n γ ::= v! t [τ (n) ]. Γ | v? t [τ (n) ]. Γ v ::= x | •</formula><p>The meta-variable τ (n) ranges over the type of n-tuples. The meta-variable x ranges over Var. We often omit n when it is not important or it is clear form the context. The tuple type (x 1 , . . . , x n )Γ is the type of an n-tuple, whose elements x 1 , . . . , x n should be used according to Γ. We use the standard notation µα.τ for recursive types. Recursive types are used to express a channel that is used infinitely often (e.g., a channel that is repeatedly used for input), as well as a channel that carries itself (e.g., x! t [x]). Examples are given later in Example 3.1.6.</p><p>0 is the type of the inaction. v! t [τ (n) ]. Γ is the type of a process that uses v for sending an n-tuple of type τ , and then behaves according to Γ. The output on x must be tagged with t. The special variable • denotes an unknown channel name, so that •! t [τ (n) ]. Γ means that an n-tuple of type τ is sent on some channel. Similarly, v? t [τ (n) ]. Γ is the type of a process that uses v for receiving an n-tuple of type τ , and then behaves according to Γ. In this way, we can express more precise information on the usage of channels than previous type systems <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b39">40]</ref>. Γ 1 | Γ 2 is the type of a process that behaves according to Γ 1 and Γ 2 in parallel. The type γ 1 + • • • + γ n represents an external choice: A process of that type must behave according to one of γ 1 , . . . , γ n , depending on the communications provided by the environment. On the other hand, the type Γ 1 &amp;Γ 2 represents an internal choice: A process of that type can behave according to either Γ 1 or Γ 2 , irrespectively of what communications are provided by the environment. The type τ (n) v 1 , . . . , v n describes a process that uses channels v 1 , . . . , v n according to type τ . Here, the arity information is used to exclude out ill-formed types like ((x)Γ) y, z .</p><p>In the rest of the paper, we do not distinguish between ) ]. Γ, and just write t.Γ for them. Thus, t.Γ is the type of a process that behaves according to Γ after some action annotated with t (which is an input or an output action on some channel) occurs. <ref type="foot" target="#foot_1">2</ref>Notation 3.1.2: We write τ (n) for the arity n. We have two kinds of binders: one for (channel) variables and the other for type variables. The tuple type (x)Γ binds the variables x in Γ. We assume that µα.Γ binds the type variable α in Γ. We assume that α-conversions are implicitly applied so that bound variables are always different from each other and free variables. We write [ỹ/x] and [τ /α] for the capture-avoiding substitution of ỹ for x and that of τ for α respectively. We write * Γ for (µα.( )(Γ | α )) (where α does not appear in Γ); It is the type of infinitely many copies of a process of type Γ. We often omit 0 and write x! t [τ ], x? t [τ ], and t for x! t [τ ]. 0, x? t [τ ]. 0, and t.0 respectively. We also abbreviate x! t [( )0]. Γ and x? t [( )0]. Γ to x! t . Γ and x? t . Γ respectively. We write Null (Γ) if Γ does not contain a process type of the form x? </p><formula xml:id="formula_7">•! t [τ (n) ]. Γ and •? t [τ (n</formula><formula xml:id="formula_8">[τ ]. α x )].α x is semi-closed, but not closed. x![α] is contractive in α but x?[α]. α is not.</formula><p>Notice that for most of the process constructors introduced in the previous section, there are the corresponding constructors for process types. The same symbols are used for them to clarify the correspondence. Unlike the π-calculus processes in Section 2, however, the process types contain no operators for creating fresh channels or passing channels through other channels. Thanks to this, we can check properties of types (as abstract processes) more easily than those of the π-calculus processes. Instead, we have some operators that do not have their counterparts in processes. An internal choice Γ 1 &amp;Γ 2 is necessary to express non-deterministic behavior of a process. For example, suppose that a process P 1 behaves like Γ 1 and a process P 2 behaves like Γ 2 . Then, the process νx(x! | x?. P 1 | x?. P 2 ) behaves like Γ 1 &amp;Γ 2 . A process type of the form t.Γ plays an important role in guaranteeing complex properties like deadlock-freedom. For example, we can express the type of (νx) (x? t 1 . y! t 2 | y? t<ref type="foot" target="#foot_2">3</ref> ) as t 1 .y! t 2 | y? t 3 , which implies that the output on y is not performed until an action labeled with t 1 succeeds. Since actually it never succeeds, we know that the input from y is kept waiting forever.</p><p>Example 3.1.5: The process type x? t 1 . y! t 2 describes a process that uses x for input and then uses y for output. So, the process x? t 1 . y! t 2 has this type, but neither y! t 2 . x? t 1 nor x? t 1 | y! t 2 has this type. The process type x! t . y! t &amp;y! t . x! t describes a process that uses x and y once for output sequentially in any order; So, both x! t . y! t and y! t . x! t can have this type. 3 The process x! t | y! t , however, does not have this type.</p><p>Example 3.1.6: The type (x, y)(x? <ref type="bibr">[τ ]</ref>. y![τ ]) describes a pair whose first element should be first used for sending a value of type τ , and then whose second element should be used for receiving a value of type τ . The type µα.(x)(x? t [τ ]. α x ) describes a channel that is used for receiving a tuple of type τ repeatedly. The type µα.(x)(x? t [α]) describes a channel that is used for receiving a channel of the same type (so, the received channel is again used for receiving a channel of the same type).</p><p>We define the set of free (channel) variables in a process type as follows. Note that FV(Γ) is sometimes different from the set of variables appearing free syntactically: For example, x is not an element of FV(((y)0) x ). Intuitively, FV(Γ) denotes the set of free variables whose renaming changes the meaning of Γ. For example, x is in the set FV(x? t ) since renaming of x with a different variable (y, for example) changes the meaning of the process type. On the other hand, x is not an element of FV(((z)0) x ) since ((z)0) x is essentially equivalent to 0 (with respect to the subtyping relation introduced later) and renaming of x with y does not change its meaning. Definition 3.1.7: Let Γ be a process type. The set FV(Γ) of variables is defined by:</p><formula xml:id="formula_9">FV(Γ) = FVaux ∅ (Γ) FVaux f (0) = ∅ FVaux f (x? t [τ ]. Γ) = {x} ∪ FVaux f (τ ) ∪ FVaux f (Γ) FVaux f (x! t [τ ]. Γ) = {x} ∪ FVaux f (τ ) ∪ FVaux f (Γ) FVaux f (•? t [τ ]. Γ) = FVaux f (τ ) ∪ FVaux f (Γ) FVaux f (•! t [τ ]. Γ) = FVaux f (τ ) ∪ FVaux f (Γ) FVaux f (γ 1 + • • • + γ n ) = FVaux f (γ 1 ) ∪ • • • ∪ FVaux f (γ n ) FVaux f (Γ 1 | Γ 2 ) = FVaux f (Γ 1 ) ∪ FVaux f (Γ 2 ) FVaux f (Γ 1 &amp;Γ 2 ) = FVaux f (Γ 1 ) ∪ FVaux f (Γ 2 ) FVaux f (τ ṽ ) = (FVaux f (τ ) \ Nat) ∪ {v i | i ∈ FVaux f (τ )} FVaux f (α) = f (α) FVaux f ((x)Γ) = (FVaux f (Γ) \ {x}) ∪ {i | x i ∈ FVaux f (Γ)} FVaux f (µα.τ ) = {S ⊆ Var ∪ Nat | S ⊇ FVaux f {α →S} (τ )}</formula><p>Here, FVaux f (Γ) and FVaux f (τ ) are subsets of Var ∪ Nat, where f is a map from a finite set of type variables to the powerset of Var ∪ Nat.</p><p>We define operations on types. The operation Γ↓ S defined below extracts from Γ information on the usage of only the channels in S, while Γ↑ S extracts information on the usage of the channels not in S. Definition 3.1.8: Let S be a subset of Var. Then, unary operations •↓ S and •↑ S on semi-closed tuple types and process types are defined by:</p><formula xml:id="formula_10">0↓ S = 0 (v? t [τ ]. Γ)↓ S = v? t [τ ↓ S ]. (Γ↓ S ) if v ∈ S •? t [τ ↓ S ]. (Γ↓ S )(= t.(Γ↓ S )) otherwise (v! t [τ ]. Γ)↓ S = v! t [τ ↓ S ]. (Γ↓ S ) if v ∈ S •! t [τ ↓ S ]. (Γ↓ S )(= t.(Γ↓ S )) otherwise (γ 1 + • • • + γ n )↓ S = (γ 1 ↓ S ) + • • • + (γ n ↓ S ) (Γ 1 | Γ 2 )↓ S = (Γ 1 ↓ S ) | (Γ 2 ↓ S ) (Γ 1 &amp;Γ 2 )↓ S = (Γ 1 ↓ S )&amp;(Γ 2 ↓ S ) (τ v 1 , . . . , v n )↓ S = (τ ↓ S ) v 1 ↓ S , . . . , v n ↓ S where v↓ S is v if v ∈ S, and • otherwise α↓ S = α ((x 1 , . . . , x n )Γ)↓ S = (x 1 , . . . , x n )(Γ↓ S∪{x 1 ,...,xn} ) (µα.τ )↓ S = µα.(τ ↓ S ) Γ↑ S = Γ↓ Var\S Example 3.1.9: Let Γ = y? t [τ ]. x! t [τ ]. Then Γ↓ {x} = t.x! t [τ ] and Γ↑ {x} = y? t [τ ]. t .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Subtyping</head><p>We introduce a subtyping relation Γ 1 ≤ Γ 2 , meaning that a process of type Γ 1 may behave like that of type Γ 2 . For example, Γ 1 &amp;Γ 2 ≤ Γ 1 should hold. The subtyping relation depends on the property we want to guarantee: For example, if we are only concerned with arity-mismatch errors <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b49">50]</ref>, we may identify t.Γ with Γ, and x! t [τ ]. Γ with x! t [τ ] | Γ, but we cannot do so if we are concerned with more complex properties like deadlock-freedom. Therefore, we state here only necessary conditions that should be satisfied by the subtyping relations of all instances of our type system. Definition 3.2.1 [subtyping]: A preorder ≤ on process types and tuple types is a proper subtyping relation if it satisfies the rules given in Figure <ref type="figure">3</ref> </p><formula xml:id="formula_11">(Γ 1 ∼ = Γ 2 denotes Γ 1 ≤ Γ 2 ∧ Γ 2 ≤ Γ 1 ).</formula><p>In the rest of this paper, we assume that ≤ always denotes a proper subtyping relation. Some explanation of the rules for recursive types would be required. The rule (Sub-Unfold) allows some occurences of a recursive type variable α to be replaced by its definition. The rule (Sub-Rec) is the same as the contraction rule of Amadio and Cardelli <ref type="bibr" target="#b0">[1]</ref>, except for the definition of contractiveness. The standard rule for unfolding recursive types: µα.τ ∼ = [µα.τ /α]τ can be obtained from (Sub-Unfold) and (Sub-Rec). The rule (Sub-Rep) is a degenerated case of the following standard rule:</p><formula xml:id="formula_12">Σ, α ≤ α τ ≤ τ Σ µα.τ ≤ µα .τ</formula><p>Here, Σ is a sequence of assumptions of the form α 1 ≤ α 2 . It is possible to replace (Sub-Rep) with the above rule. Then, (Sub-Rep) is derivable using this rule as follows:</p><formula xml:id="formula_13">Γ ≤ Γ α ≤ α α ≤ α • • • α ≤ α ( )(Γ | α ) ≤ ( )(Γ | α ) µα.( )(Γ | α ) ≤ µα .( )(Γ | α ) (µα.( )(Γ | α )) ≤ (µα .( )(Γ | α ))</formula><p>In addition to the rules in Figure <ref type="figure">3</ref>, we sometimes use the following axiom in examples.</p><p>Γ is closed (i.e., Γ contains no free type variables)</p><formula xml:id="formula_14">(Γ↓ S | Γ↑ S ) ≤ Γ (Sub-Divide)</formula><p>This axiom is not required for type soundness to hold, but it makes more processes to be typed.</p><p>The rule allows us to forget information about dependencies between some channels. For example, if</p><formula xml:id="formula_15">Γ = y? t [τ ]. x! t [τ ], then Γ↓ {x} | Γ↑ {x} = t.x! t [τ ] | y? t [τ ]. t is a subtype of Γ.</formula><p>Note that the closedness of Γ is required since, without that condition, we would get α | α ≤ α . Notice that Γ↓ {x} | Γ↑ {x} expresses a more liberal usage of x, y than Γ: While Γ means that x is used for output only after y is used for input, Γ↓ {x} | Γ↑ {x} only says that x is used for output after some event t, not necessarily an input from y.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Reduction of Process Types</head><p>We want to reason about the behavior of a process by inspecting the behavior of its abstraction, i.e., process type. We therefore define reduction of process types, so that each reduction step of a process is matched by a reduction step of its process type. For example, the reduction of a process</p><formula xml:id="formula_16">x? t 1 [z]. z! t 2 | x! t 3 [y] -→ y! t 2</formula><p>is matched by:</p><formula xml:id="formula_17">x? t 1 [τ ] | x! t 3 [τ ]. y! t 2 -→ y! t 2 for τ = (z)z! t 2 .</formula><p>As in the case for reductions of processes, we annotate each reduction with information about which channel and events are involved in the reduction.</p><formula xml:id="formula_18">Definition 3.3.1: A reduction relation Γ 1 L -→ Γ 2 on process types (where L ∈ T ∪ {x t 1 ,t 2 | (x ∈ Var) ∧ (t 1 , t 2 ∈ T)} ∪ { t 1 ,t 2 | t 1 , t 2 ∈ T})</formula><p>is the least relation closed under the rules in Figure <ref type="figure" target="#fig_1">4</ref>.</p><p>We write Γ -→ Γ when Γ L -→ Γ for some L. The rule (TER-Com2) is used to simulate communication on inner channels. For example, the process reduction:</p><formula xml:id="formula_19">(νx) (x! t 1 | x? t 2 ) t 1 ,t 2 -→ (νx) 0 is simulated by: t 1 | t 2 t 1 ,t 2 -→ 0.</formula><p>The rule (TER-Ev) allows a process type of the form t.Γ to be reduced by itself. This is used to model communication of a process with an unknown environment. This rule is necessary to reason about behavior of a process in a compositional manner. For example, consider a process:</p><formula xml:id="formula_20">(νx) (y? t 1 . x! t 2 [1] | x? t 3 [y]. z! t 4 [y + 1]), Γ | 0 ∼ = Γ (Sub-Empty) Γ 1 | Γ 2 ∼ = Γ 2 | Γ 1 (Sub-Commut) Γ 1 | (Γ 2 | Γ 3 ) ∼ = (Γ 1 | Γ 2 ) | Γ 3 (Sub-Assoc) [α/β]τ = τ µα.τ ∼ = µα.[µα.τ /β]τ (Sub-Unfold) [τ /α]τ ∼ = τ τ is contractive in α τ ∼ = µα.τ (Sub-Rec) ((x)Γ) ṽ ∼ = [ṽ/x]Γ (Sub-Beta) Γ ≤ Γ (x)Γ ≤ (x)Γ (Sub-Abs) τ ≤ τ τ ṽ ≤ τ ṽ (Sub-App) Γ 1 &amp;Γ 2 ≤ Γ i (i ∈ {1, 2}) (Sub-IChoice) Γ ≤ Γ * Γ ≤ * Γ (Sub-Rep) Γ 1 ≤ Γ 1 Γ 2 ≤ Γ 2 Γ 1 | Γ 2 ≤ Γ 1 | Γ 2 (Sub-Par) γ i ≤ γ i for each i ∈ {1, . . . , n} γ 1 + • • • + γ n ≤ γ 1 + • • • + γ n (Sub-Choice) Γ ≤ Γ Γ↓ S ≤ Γ ↓ S (Sub-Restrict) Γ ≤ Γ [v/x]Γ ≤ [v/x]Γ (Sub-Subst)</formula><p>Figure <ref type="figure">3</ref>: Necessary Conditions on Subtyping Relation</p><formula xml:id="formula_21">τ 1 ≤ τ 2 • • • + x! t 1 [τ 1 ]. Γ 1 + • • • | • • • + x? t 2 [τ 2 ]. Γ 2 + • • • x t 1 ,t 2 -→ Γ 1 | Γ 2 (TER-Com1) • • • + t 1 .Γ 1 + • • • | • • • + t 2 .Γ 2 + • • • t 1 ,t 2 -→ Γ 1 | Γ 2 (TER-Com2) • • • + t.Γ + • • • t -→ Γ (TER-Ev) Γ 1 L -→ Γ 1 Γ 1 | Γ 2 L -→ Γ 1 | Γ 2 (TER-Par) Γ 1 ≤ Γ 1 Γ 1 L -→ Γ 2 Γ 2 ≤ Γ 2 Γ 1 L -→ Γ 2 (TER-Sub)</formula><p>Figure <ref type="figure" target="#fig_1">4</ref>: Reduction of Process Types which communicates with an environment through channels y and z. To check that the channel x is used in a consistent manner (without looking at the environment), we drop information about y and z and check the behavior of the following type:</p><formula xml:id="formula_22">t 1 .x! t 2 [int]. | x? t 3 [int]. t 4 .</formula><p>By reducing the type:</p><formula xml:id="formula_23">t 1 .x! t 2 [int]. | x? t 3 [int]. t 4 t 1 -→ x! t 2 [int]. | x? t 3 [int]. t 4 x t 2 ,t 3 -→ t 4 t 4 -→ 0,</formula><p>we find that there is no wrong communication on x.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Consistency of Process Types</head><p>If a process type is a correct abstraction of a process, we can verify a property of the process by verifying the corresponding property of the process type instead. We write ok for the corresponding property of process types and call it a consistency condition. The consistency condition depends on the property that we require for processes. So, we state here only necessary conditions that every consistency condition should satisfy. Consistency conditions for specific instances are given in Section 5.</p><p>The following well-formedness condition requires that there is no disagreement about communication between input and output processes. For example, the process type x?[string] | x![int] is ill-formed, since it specifies that a sub-process is waiting to receive a string along x and another sub-process is trying to send an integer along the same channel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.4.1 [well-formedness]:</head><p>A process type Γ is well-formed, written WF (Γ), if there exist no x, τ 1 , τ 2 , t 1 , t 2 , Γ 1 , Γ 2 , and Γ 3 that satisfy the following conditions:</p><formula xml:id="formula_24">1. Γ -→ * ≤ • • • + x! t 1 [τ 1 ]. Γ 1 + • • • | • • • + x? t 2 [τ 2 ]. Γ 2 + • • • | Γ 3 . 2. τ 1 τ 2 .</formula><p>Remark 3.4.2: It is possible to replace the first condition with "Γ contains x! t 1 [τ 1 ] and x? t 2 [τ 2 ]," which can be checked more easily. We do not do so, however, to make type systems flexible. Under the above condition, we can allow process types like x?</p><formula xml:id="formula_25">t 1 [τ 1 ]. x! t 2 [τ 2 ] | x! t 3 [τ 1 ]. x? t 4 [τ 2 ]</formula><p>, which allows x to be used for first communicating a value of type τ 1 , and then for communicating a value of type τ 2 .</p><p>Definition 3.4.3 [consistency]: A predicate ok on process types is a proper consistency predicate if it satisfies the following conditions:</p><p>1. If ok (Γ), then WF (Γ).</p><p>2. If ok (Γ) and Γ -→ Γ , then ok (Γ ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">If ok</head><formula xml:id="formula_26">(Γ 1 ) and Null (Γ 2 ), then ok (Γ 1 | Γ 2 )</formula><p>In the rest of this paper, we assume that ok always refers to a proper consistency predicate. We say that a process type Γ is consistent if WF (Γ) holds.</p><p>Because process types form a much simpler process calculus than the π-calculus, we expect that the predicate ok is normally much easier to verify than the corresponding property of a process. The actual procedure to verify ok , however, depends on the definition of the subtyping relation ≤ : If we are not interested in linearity information <ref type="bibr" target="#b29">[30]</ref>, we can introduce the rule Γ | Γ ∼ = Γ so that the reductions of a process type can be reduced to a finite-state machine. If we take ≤ to be the least proper subtyping relation, however, we need to use a more complex system like Petri nets, as in the case for our previous type system for deadlock-freedom <ref type="bibr" target="#b30">[31]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Typing</head><p>A type judgment is of the form Γ P , where Γ is a closed (i.e., containing no free type variables) process type. It means that P behaves as specified by Γ.</p><p>Typing rules are given in Figure <ref type="figure">5</ref>. The rules (T-Par), (T-Choice), and (T-Rep) say that an abstraction of a process constructed by using a process constructor | , +, or * can be obtained by composing abstractions of its subprocesses with the corresponding constructor for process types.</p><p>The key rules are (T-Out), (T-In), and (T-New). Note that channels can be dynamically created and passed through other channels in the process calculus, while in the calculus of process types, there are no corresponding mechanisms. So, we must somehow approximate the behavior of a process in those rules.</p><p>In the rule (T-Out), we cannot express information that [z] is passed through x at the type level. Instead, we put [z/ỹ]Γ 2 , which expresses how the channels z are used by a receiver, into the continuation of the output action.</p><p>In the rule (T-In), the lefthand assumption means that P uses free channels according to Γ 1 | Γ 2 , and the righthand assumption means that information about the usage of received channels ỹ is not in Γ 2 but in Γ 1 . In the conclusion, the information about the usage of ỹ is put into the tuple type (ỹ)Γ 2 . Information about the usage of other channels is put into either the tuple type (ỹ)Γ 2 , so that the usage of those channels is taken into account by the output process, or the continuation Γ 1 , so that the usage of those channels is taken into account by this input process. For example, consider a process x? t 1 [y]. y? t 2 . z! t 3 . Its subprocess y? t 2 . z! t 3 has the process type y? t 2 . z! t 3 . By applying (T-Sub) and (Sub-Divide), we obtain the following type judgment:</p><formula xml:id="formula_27">t 2 .z! t 3 | y? t 2 . t 3 y? t 2 . z! t 3 0 0 (T-Zero) Γ 1 P 1 Γ 2 P 2 Γ 1 | Γ 2 P 1 | P 2 (T-Par) Γ P * Γ * P (T-Rep) Γ P Γ ≤ Γ Γ P (T-Sub) γ i G i for each i ∈ {1, . . . , n} γ 1 + • • • + γ n G 1 + • • • + G n (T-Choice) Γ 1 P x! t [(ỹ)Γ 2 ]. (Γ 1 | [z/ỹ]Γ 2 ) x! t [z]. P (T-Out) Γ 1 | Γ 2 P FV(Γ 1 ) ∩ {ỹ} = ∅ x? t [(ỹ)Γ 2 ]. Γ 1 x? t [ỹ]. P (T-In) Γ P ok (Γ↓ {x} ) FV(Γ↑ {x} ) ∩ {x} = ∅ Γ↑ {x} (ν x) P (T-New)</formula><p>Figure <ref type="figure">5</ref>: Typing Rules By applying (T-In), we obtain:</p><formula xml:id="formula_28">x? t 1 [(y)y? t 2 . t 3 ]. t 2 .z! t 3 x? t 1 [y]. y? t 2 . z! t 3</formula><p>The parameter type (y)y? t 2 . t 3 of the channel x carries information that y is used for input and then some event t 3 occurs. On the other hand, the continuation part t 2 .z! t 3 says that some event t 2 occurs after the input on x, and then z is used for output. Alternatively, we can obtain the following type judgment:</p><formula xml:id="formula_29">x? t 1 [(y)y? t 2 . z! t 3 ] x? t 1 [y]. y? t 2 . z! t 3</formula><p>This judgment means that y is used for input and then z is used for output.</p><p>In the rule (T-New), we check by the condition ok (Γ↓ {x} ) that x are used in a consistent manner, and forget information about the use of x by •↑ {x} . The condition FV(Γ↑ {x} ) ∩ {x} = ∅ ensures that x is no longer visible from the outside.</p><p>The rules (T-Out) and (T-In) are asymmetric in the sense that information about the continuation of a receiver process is transfered to a sender process but not vice versa. This design choice is motivated by the observation that the names of the channels transmitted via a communication are statically known only to the sender, so that we must put information about how the transmitted channels are used by the receiver into the type of the sender. For example, consider a process containing x? <ref type="bibr">[y]</ref>. y! and x![z] as sub-processes. Since the name z may not be in the scope of the sub-process x? <ref type="bibr">[y]</ref>. y!, we have to put information that z is used for output into the type of x![z], as x![τ ]. z!. An extension to treat input and output processes in a more symmetric manner is discussed in Section 8.</p><p>Example 3.5.1: Consider a process x? t 1 [y]. l? t 2 . y! t 3 . l! t 4 . After receiving a channel y on x, it receives a null tuple on l, sends a null tuple on y, and sends a null tuple on l. (If l is used as a lock, "receiving a value on l" and "sending a value on l" are interpreted as "acquiring lock l" and "releasing lock l" respectively: See Section 6.) The parallel composition of the above process with x! t 5 [z] is typed as follows:</p><formula xml:id="formula_30">• • • l? t 2 . y! t 3 . l! t 4 l? t 2 . y! t 3 . l! t 4 x? t 1 [τ ] x? t 1 [y]. l? t 2 . y! t 3 . l! t 4 • • • x! t 5 [τ ]. l? t 2 . z! t 3 . l! t 4 x! t 5 [z] x? t 1 [τ ] | x! t 5 [τ ]. l? t 2 . z! t 3 . l! t 4 x? t 1 [y]. l? t 2 . y! t 3 . l! t 4 | x! t 5 [z]</formula><p>In the derivation above, τ denotes (y)l? t 2 . y! t 3 . l! t 4 . The conclusion implies that after a communication on x, lock l is acquired, a null tuple is sent on z, and then l is released.</p><formula xml:id="formula_31">Example 3.5.2: Consider a process x! t 1 [x] | * x? t 2 [y]. y! t 3 [y]. Let τ be µα.(x)(x! t 3 [α]. α x ) and τ be its expansion: (x)(x! t 3 [τ ]. τ x ).</formula><p>Then, the process is typed as follows:</p><formula xml:id="formula_32">x! t 1 [τ ]. τ x x! t 1 [x] y! t 3 [τ ]. τ y y! t 3 [y] 0 | y! t 3 [τ ]. τ y y! t 3 [y] x? t 2 [τ ] x? t 2 [y]. y! t 3 [y] * x? t 2 [τ ] * x? t 2 [y]. y! t 3 [y] x! t 1 [τ ]. τ x | * x? t 2 [τ ] x! t 1 [x] | * x? t 2 [y]. y! t 3 [y]</formula><p>4 Type Soundness The general type system given above is parameterized by the subtyping relation ≤ and the consistency predicate ok , which determine the exact properties of each instance of the type system. Therefore, proofs of type soundness also depend on each instance. As we show below, however, several important properties can be proved independently of a choice of the subtyping relation and the consistency predicate. In Section 4.1, we show a collection of basic properties of the generic type system. These properties imply that the behavior of a process is simulated by its type in a certain sense, so that we can check properties of a process by checking the corresponding properties of the process's type.</p><p>Since the properties in Section 4.1 are rather low-level, some work is still necessary to prove the type soundness of each instance of the generic type system (though the work would be much easier than proving soundness of each type system from scratch). In Section 4.2, we show a more "high-level" theorem about type soundness. From the theorem, we can automatically obtain type soundness of a certain class of instances of the generic type system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Basic Properties of the Generic Type System</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Type Preservation</head><p>First, Theorem 4.1.1 below guarantees that if Γ P holds, for every reduction of P , there is a corresponding reduction of Γ and the reduced process has the reduced process type. In this sense the behavior of a well-typed process is modeled by its process type. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>As a corollary, it follows that a process satisfies a certain invariant condition p if the type of P satisfies the corresponding consistency condition. Theorem 4.1.2: Suppose p(P ) holds for any Γ such that Γ P and ok (Γ). If Γ P and ok (Γ), then p(Q) holds for every Q such that P -→ * Q.</p><p>Proof: By mathematical induction on the length of the reduction sequence P -→ • • • -→ Q, using Theorem 4.1.1 and the fact that ok is preserved by reduction (of process types).</p><p>2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Normalization of Type Derivation</head><p>The normal derivation theorem given below states that, from any type derivation, it is possible to obtain a "syntax-directed" type derivation of the same conclusion. It is useful for studying a relationship between a process and its process type, and also for developing type-check/reconstruction algorithms.</p><p>We write Γ N P if Γ P is derivable by using (T-Sub) only immediately before (T-In) or (T-Out). As a corollary, it follows that if a process is trying to perform an input action, its process type is also trying to perform the corresponding action. (A similar property holds also for output.) </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">If y</head><formula xml:id="formula_33">∈ { x1 , . . . , xk }, then Γ ≤ • • • + t.Γ 1 + • • • | Γ 2 for some Γ 1 and Γ 2 .</formula><p>Conversely, if a process type obtained by normal derivation is trying to perform some action, the process is also trying to perform the corresponding action. Theorem 4.1.5:</p><formula xml:id="formula_34">1. If • • • + t.Γ 1 + • • • | Γ 2 N P , then P ( νx 1..k ) (• • • + y? t [z]. Q + • • • | R) or P ( νx 1..k ) (• • • + y! t [z]. Q + • • • | R) with y ∈ { x1 , . . . , xk }. 2. If • • • + y? t [τ ]. Γ 1 + • • • | Γ 2 N P , then P ( νx 1..k ) (• • • + y? t [z]. Q + • • • | R) with y ∈ { x1 , . . . , xk }.</formula><p>Proof: Trivial by the definition of Γ N P . 2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">General Type Soundness Theorem</head><p>In Section 4.1, we have shown that a process satisfies a certain property p if its process type satisfies the corresponding consistency condition ok . However, it is left to the designer of a specific type system to find a consistency condition that corresponds to a process property of interest and prove that the correspondence is indeed correct. There also remains a general question about the power of our generic type system: What kind of type system can be obtained as an instance? Clearly, not all properties can be verified in our type system: For example, the property "a process can create at most n channels" cannot be verified, because process types does not carry information about channel creation. This section gives a partial answer to those questions: For a certain class of properties of processes, there is indeed a systematic way for obtaining the corresponding consistency condition ok on process types, so that the instantiated type system is sound. We first introduce logical formulas <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b44">45]</ref> to formally state properties of processes and types.</p><p>Definition 4.2.6: The set Prop of formulas is given by the following syntax:</p><formula xml:id="formula_35">A ::= true | x! t n | x? t n | (A | B) | l A | ev (A) | ¬A | A ∨ B | ∃x.A | ∃t.A | ∃ζ : C.A C ::= {m 1 = n 1 , . . . , m k = n k }</formula><p>Here, the meta-variable ζ ranges over the set IVar of variables (called integer variables), disjoint from Var. The meta-variables n, m i , n i range over the union of the set IVar and the set Nat of non-negative integers. We often abbreviate ¬(¬A ∨ ¬B) to A ∧ B.</p><p>A formula A describes a property of both processes and types. Intuitively, x! t n means that some sub-process is ready to output an n-tuple on the channel x and that the output is tagged with t. Similarly, x? t n means that some sub-process is ready to input an n-tuple. A formula A | B means that the process is parallel composition of a process satisfying A and another process satisfying B. A formula l A means that the process can be reduced in one step to a process satisfying A and that the reduction is labeled with l. A formula ev (A) means that the process can be reduced to a process satisfying A in a finite number of steps. <ref type="foot" target="#foot_3">4</ref> For example, the formula</p><formula xml:id="formula_36">¬∃t, t .∃ζ 1 , ζ 2 : ∅.ev (x! t ζ 1 | x! t ζ 2 )</formula><p>means that no two processes try to output a value on x simultaneously.</p><p>We define the formal semantics of formulas below. As usual, ∃x.A, ∃t.A, and ∃ζ : C.A bind x, t, and ζ respectively. We write FIV(A) for the set of free integer variables in A. We define substitutions for variables, events, and integer variables in a customary manner. For example, [n/ζ]A denotes the formula obtained from A by substituting n for all free occurrences of ζ. We write FV(A) for the set of free variables (in Var), and FIV(A) for the set of free integer variables (in IVar). Definition 4.2.7: The size of a formula A, written size(A), is defined by:</p><formula xml:id="formula_37">size(true) = size(x! t n) = size(x? t n) = 1 size(A | B) = size(A ∨ B) = size(A) + size(B) + 1 size( l A) = size(ev (A)) = size(¬A) = size(∃x.A) = size(∃t.A) = size(∃ζ : C.A) = size(A) + 1</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>We define the semantics [[A]] pr of a formula A as the set of processes satisfying A. To define it, we introduce an auxiliary function [[A]] S</head><p>pr , which denotes the set of processes satisfying A provided that all channels in S are invisible.</p><p>• Case A = A 1 | A 2 : the required property follows by: </p><formula xml:id="formula_38">(ν x) P ∈ [[A]] S pr ⇐⇒ (ν x) P (ν x) ( νx 1..k ) (P 1 | P 2 ) ∧P 1 ∈ [[A 1 ]] S∪{x}∪{ x1 ,..., xk } pr ∧ P 2 ∈ [[A 2 ]] S∪{x}∪{ x1 ,..., xk } pr ⇐⇒ P ( νx 1..k ) (P 1 | P 2 ) ∧P 1 ∈ [[A 1 ]] S∪{x}∪{ x1 ,..., xk } pr ∧ P 2 ∈ [[A 2 ]] S∪{x}∪{ x1 ,..., xk } pr ⇐⇒ P ∈ [[A]] S∪{x}</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>By applying the induction hypothesis to</head><formula xml:id="formula_39">Q ∈ [[B]] S∪{x} pr , we obtain (ν x) Q ∈ [[B]] S pr . Since (l ↑ {x} )↑ S = l ↑ S∪{x} = l, we have (ν x) P ∈ [[A]] S pr as required.<label>2</label></formula><p>A formula is interpreted also as a property of process types (Type is the set of process types):</p><p>Definition 4.2.12: Let A be a formula such that FIV(A) = ∅, and The set [[A]] ty and [[A]] S ty of process types are defined by:</p><formula xml:id="formula_40">[[true]] ty = Type [[x! t n]] ty = {Γ | Γ ≤ • • • + x! t [τ ]. ∆ 1 + • • • | ∆ 2 , τ = n} [[x? t n]] ty = {Γ | Γ ≤ • • • + x? t [τ ]. ∆ 1 + • • • | ∆ 2 , τ = n} [[A | B]] ty = {Γ | Γ ≤ (∆ 1 | ∆ 2 ), ∆ 1 ∈ [[A]] ty , ∆ 2 ∈ [[B]] ty } [[ l A]] ty = {Γ | Γ l -→ ∆, ∆ ∈ [[A]] ty } [[ev (A)]] ty = {Γ | Γ -→ * ∆, ∆ ∈ [[A]] ty } [[¬A]] ty = Type\[[A]] ty [[A ∨ B]] ty = [[A]] ty ∪ [[B]] ty [[∃x.A]] ty = y∈Var [[[y/x]A]] ty [[∃t.A]] ty = t ∈T [[[t /t]A]] ty [[∃ζ : C.A]] ty = {Γ | Γ ∈ [[[n/ζ]A]] ty , n ∈ Nat, |= [n/ζ]C} [[A]] S ty = {Γ | Γ↑ S ∈ [[A]] ty } We write Γ |= A when Γ ∈ [[A]] ty holds.</formula><p>To formally define what property of process types corresponds to a property of processes, we introduce two binary relations on formulas. </p><formula xml:id="formula_41">x! t n → x! t n (F-Out) x? t n → x? t n (F-In) A → B l A → l B (F-Red) A → B ev (A) → ev (B) (F-Ev) A 1 → B 1 A 2 → B 2 A 1 | A 2 → B 1 | B 2 (F-Par) A B ¬B → ¬A (F-Neg1) A → B ¬B ¬A (F-Neg2)</formula><formula xml:id="formula_42">((Γ P ∧ WF (Γ) ∧ P ∈ [[θA]] S pr ) ⇒ Γ ∈ [[θB]] S ty )</formula><p>Intuitively, A B means that if a process type satisfies the property A, every process of that type satisfies the property B. Conversely, A → B means that if a process satisfies A, its type satisfies B.</p><p>We obtain sound inference rules to derive the relations A B and A → B as shown in Figure <ref type="figure">6</ref>. We have also standard logical rules like:</p><formula xml:id="formula_43">A B A B ∨ C A C B C A ∨ B C</formula><p>The soundness of inference rules is proved as follows. </p><formula xml:id="formula_44">∆ ∈ [[B]] S ty , that is, ∆↑ S ∈ [[B]] ty . So, we have Γ↑ S ∈ [[ l B]] ty , that is, Γ ∈ [[ l B]] S</formula><p>ty as required. The soundness of (F-Ev) follows similarly. To show the soundness of (F-Par), suppose</p><formula xml:id="formula_45">A 1 → B 1 , A 2 → B 2 , P ∈ [[A 1 | A 2 ]] S</formula><p>pr , and Γ P with WF (Γ). By the assumption P ∈</p><formula xml:id="formula_46">[[A 1 | A 2 ]] S</formula><p>pr , there exists P 1 , P 2 , x1 , . . . , xk such that </p><formula xml:id="formula_47">P ( νx 1..k ) (P 1 | P 2 ) P 1 ∈ [[A 1 ]] S∪{ x1 ,..., xk } pr P 2 ∈ [[A 2 ]] S∪{ x1 ,...,</formula><formula xml:id="formula_48">∆ 1 P 1 ∆ 2 P 2 Γ ≤ ∆ 1 ↑ { x1 ,..., xn } | ∆ 2 ↑ { x1 ,..., xn } WF ((∆ 1 | ∆ 2 )↓ {x i } ) for i = 1, . . . , k</formula><p>Note that WF (∆ 1 ) and WF (∆ 2 ) follows from the last two conditions and WF (Γ). So, by the assumptions By using Lemma 4.2.15, we can show that for any negative formula A defined below, a process P satisfies A (i.e., P ∈ [[A]] pr ) if its process type Γ satisfies the same formula A. Therefore, our type system can be used at least for reasoning about properties described using negative formulas. Definition 4.2.16 [positive/negative formulas]: The set F + (F -, resp.) of positive (negative, resp.) formulas are the least set satisfying the following rules:</p><formula xml:id="formula_49">A 1 → B 1 and A 2 → B 2 , we have ∆ 1 ∈ [[B 1 ]] S∪{ x1 ,..., xk } ty and ∆ 2 ∈ [[B 2 ]] S∪{ x1 ,..., xk } ty , which implies ∆ 1 ↑ { x1 ,..., xn} ∈ [[B 1 ]] S ty and ∆ 2 ↑ { x1 ,..., xn} ∈ [[B 2 ]] S ty . By Γ ≤ ∆ 1 ↑ { x1 ,..., xn} | ∆ 1 ↑ { x1 ,..., xn} , we have Γ ∈ [[B 1 | B 2 ]]</formula><formula xml:id="formula_50">true ∈ F + ∩ F - x! t n, x? t n ∈ F + A, B ∈ F + ⇒ A | B, A ∨ B, l A, ev (A), ∃x.A, ∃t.A, ∃ζ : C.A ∈ F + A, B ∈ F -⇒ A ∨ B, ∃x.A, ∃t.A, ∃ζ : C.A ∈ F - A ∈ F + ⇒ ¬A ∈ F - A ∈ F -⇒ ¬A ∈ F +</formula><p>Intuitively, a formula is positive (negative, resp.) if sub-formulas of the form A | B, l A, ev (A), x! t n, x? t n appear only in positions where the negation is applied an even (odd, resp.) number of times. Theorem 4.2.17: Suppose Γ P and WF (Γ). For any </p><formula xml:id="formula_51">S ⊆ Var, if A ∈ F -with FIV(A) = ∅ and Γ ∈ [[A]] S</formula><formula xml:id="formula_52">∨ ( t 1 true ∧ t 1 ≺ t )))).</formula><p>Table <ref type="table">2</ref>: Consistency Conditions after the action annotated with t. For example, the process (νx) (x! t 1 | x! t 2 | x? t 3 . x? t ) satisfies this property. p 4 (P ) means that P is not deadlocked on any actions annotated with t in the sense that whenever P is trying to perform an action annotated with t, P can be reduced further.</p><p>Table <ref type="table">2</ref> shows the consistency condition for each type system. ok 2 (Γ) means that no race occurs on output actions annotated with t during reduction of the abstract process Γ. ok 3 (Γ) means that, after Γ has been reduced on an action involving a channel x and the event t, the reduced process type no longer performs an input or output action on the same channel. ok 4 (Γ) means that whenever Γ is reduced to a process type trying to perform an action annotated with an event t 1 less than or equal to t, Γ can be further reduced on some channel or on an event t 2 less than t 1 . Here, we assume that ≺ is some well-founded relation on events, and t 1 t 2 means t 1 ≺ t 2 or t 1 = t 2 . We added new formulas t 1 t 2 , t 1 ≺ t 2 , and t A to express properties of process types; their semantics is defined by:</p><formula xml:id="formula_53">[[t 1 ≺ t 2 ]] ty = Type if t 1 ≺ t 2 ∅ otherwise [[t 1 t 2 ]] ty = Type if t 1 t 2 ∅ otherwise [[ t A]] ty = {Γ | Γ t -→ Γ ∧ Γ ∈ [[A]] ty }</formula><p>Soundness of the first three type systems follows immediately from Corollary 4.2.19.</p><p>Theorem 5.1: Let ok be ok i (i ∈ {1, 2, 3}). If Γ P and ok (Γ), then p i (Q) holds for every Q such that P -→ * Q.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof:</head><p>• Case for i = 1: Suppose that Γ P , ok (Γ), and P -→ * Q. Let A be:</p><formula xml:id="formula_54">¬ev (∃x.∃t 1 , t 2 .∃ζ 1 , ζ 2 : {ζ 1 = ζ 2 }.(x! t 1 ζ 1 | x? t 2 ζ 2 )). To show p 1 (Q), it is sufficient to show that Q ( νw) (ν ũ) Q implies ( νw) Q |= A. Since ok 1 (Γ)</formula><p>implies Γ |= A and A is a negative formula, Corollary 4.2.19 implies the sufficient condition.</p><p>• Case for i = 2: Since ok 2 is an invariant condition, ok 2 is a proper consistency predicate. Suppose that Γ P , ok (Γ), and P -→ * Q. Let A be:</p><formula xml:id="formula_55">¬ev (¬∃x.∃t 1 .∃ζ 1 , ζ 2 : {ζ 1 = ζ 2 }.(x! t ζ 1 | x! t 1 ζ 2 )). To show p 2 (Q), it is sufficient to show that Q ( νw) (ν ũ) Q implies ( νw) Q |= A. Since ok 2 (Γ)</formula><p>implies Γ |= A and A is a negative formula, Corollary 4.2.19 implies the sufficient condition.</p><p>• Case for i = 3: Similar to the case for i = 2. 2</p><p>In the theorem above, ≤ can be any proper subtyping relation. Choosing an appropriate subtyping relation for each type system would simplify type-checking or type-reconstruction. For example, we can identify t.Γ with Γ by the rule t.Γ ∼ = Γ, except for the case i = 4. For a naive arity-mismatch check <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b49">50]</ref>, we can ignore the order of communications by introducing rules like</p><formula xml:id="formula_56">x? t [τ ]. Γ ∼ = x? t [τ ] | Γ.</formula><p>For the type system for deadlock-freedom (ok = ok 4 ), we need to choose a particular subtyping relation. Let ≤ 1 be the least proper subtyping relation and ≤ 2 be the least subtyping relation closed under the rules in Figure <ref type="figure">3</ref> with Sub-Divide. Then, deadlock-freedom holds for both relations: Theorem 5.2: Let ok be ok 4 and ≤ be ≤ i (i ∈ {1, 2}). If Γ P and ok (Γ), then p 4 (Q) holds for every Q such that P -→ * Q.</p><p>We cannot use Corollary 4.2.19 to prove the theorem above, because p 4 (P ) is described using a nonnegative formula. Using more basic theorems shown in Section 4, however, we can easily prove the above theorem. By Theorem 4.1.2, it suffices to show that Γ P and ok 4 (Γ) imply p 4 (P ), by using Theorems 4.1.3-4.1.5: See Appendix A.2 for a proof.</p><p>The following examples indicate that our framework not only has many of the existing type systems as instances but also can express more expressive type systems than them (see also Section 6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 5.3: The process x?[y]. x? | x![w].</head><p>x! is well typed in the first (i = 1) type system. So, unlike in earlier type systems for arity-mismatch check <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b49">50]</ref>, the same channel can be used for communicating values of different types. <ref type="foot" target="#foot_4">5</ref>Example 5.4: The second type system guarantees that the process</p><formula xml:id="formula_57">(νl, x) (l! t 0 | * l? t 1 . x! t . l! t 3 | x? t 4 )</formula><p>is race-free on the channel x. So, unlike the linear type system <ref type="bibr" target="#b29">[30]</ref> for the π-calculus, our type system can guarantee lack of race conditions even on channels that are used more than once. <ref type="foot" target="#foot_5">6</ref>Example 5.5: The fourth type system (for deadlock-freedom) rejects the process</p><formula xml:id="formula_58">P = (νx) (νy) (x? t . y! t 1 | y? t 2 . x! t 3 ).</formula><p>The type of the sub-process x? t . y! t 1 | y? t 2 . x! t 3 is x? t . y! t 1 | y? t 2 . x! t 3 . So, in order for P to be welltyped, the following constraints must be satisfied:</p><formula xml:id="formula_59">ok 4 (x? t . t 1 | t 2 .x! t 3 ) ok 4 (t.y! t 1 | y? t 2 . t 3 )</formula><p>The former constraint requires that t 2 ≺ t (because the input from x succeeds only after the event t 2 succeeds), while the latter requires that t ≺ t 2 , hence a contradiction. Remark 5.6: A type environment in a usual type system corresponds to the equivalence class of a process type with respect to the relation ∼ = derived from an appropriate subtyping relation.</p><formula xml:id="formula_60">(Recall that Γ 1 ∼ = Γ 2 means Γ 1 ≤ Γ 2 ∧ Γ 2 ≤ Γ 1 .</formula><p>) For example, the type environment</p><formula xml:id="formula_61">x : [[ ]/O]/(O|I), z : [ ]/(O|I.I)</formula><p>given in Section 1 corresponds to the equivalence class of a process type</p><formula xml:id="formula_62">x! t [(y)y! t ] | x? t [(y)y! t ] | z! t | z? t . z? t , with respect to ∼ = that satisfy the rules x! t [τ ]. Γ ∼ = x! t [τ ]. Γ, x? t [τ ]. Γ ∼ = x? t [τ ]. Γ, t.Γ ∼ = Γ, and (Γ↓ S | Γ↑ S ) ∼ = Γ.</formula><p>The last rule removes information about the order of communications between different channels. A type environment of the linear π-calculus <ref type="bibr" target="#b29">[30]</ref> is obtained by further removing information about channel usage, by adding the rules</p><formula xml:id="formula_63">x! t [τ ]. Γ ∼ = x! t [τ ] | Γ, x? t [τ ]. Γ ∼ = x? t [τ ] | Γ, and Γ | Γ ∼ = * Γ.</formula><p>A type environment of the input-only/output-only channel type system <ref type="bibr" target="#b39">[40]</ref> is obtained by further adding the rule * Γ ∼ = Γ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Further Applications: Analysis of Race and Deadlock of Concurrent Objects</head><p>The type systems for race-and deadlock-freedom, presented in the last section, are indeed powerful enough to guarantee some useful properties about concurrent objects. In essence, a concurrent object is regarded as a set of processes that provides a collection of services (e.g., methods) <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b41">42]</ref>, just as a sequential object is a set of functions. Clients refer to an object through a record of channels that represent locations of those services. Hence, by giving an appropriate type to the record, we can enforce a certain protocol that clients should respect. Since our type system can capture, in particular, temporal dependency on the invoked services, it is possible to guarantee race-freedom of accesses to methods, studied by Abadi, Flanagan and Freund <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b11">12]</ref>, and deadlock-freedom for objects with non-uniform service availability, studied by Puntigam <ref type="bibr" target="#b42">[43]</ref>. Note that, so far, these properties have been discussed only for languages with primitive notion of objects. This section demonstrates how our type system can guarantee these properties. We first describe how to enforce race-free accesses to methods. For example, the following process waits for a request on newob, and upon receiving a request, creates an object with a lock l and a method m to print out the string "Hello, " appended to a given string, and exports its interface [l, m] through the reply channel r. * newob?</p><formula xml:id="formula_64">[r]. (νl, m) ( l! t | * m? t [s, r ]. print! t ["Hello, "]. print! t [s]. r ! t | r![l, m])</formula><p>Since the method m should not be invoked concurrently, <ref type="foot" target="#foot_6">7</ref> clients should acquire and release the lock l before and after the invocation of m, respectively. Indeed by using ok 2 , it is guaranteed that there are no simultaneous outputs to m:</p><p>The exported interface [l, m] (through which clients access to the object) can be given a type:</p><formula xml:id="formula_65">(l, m) l? t . m! t [(s : String, r)(r! t [()l! t ])],</formula><p>where Γ abbreviates µα.(0&amp;(Γ | α)), meaning that the tuple can be used according to Γ by arbitrarily many processes. (Here, we assume that the subtyping relation ≤ satisfies t.Γ ∼ = Γ and that String is some unary tuple type; the notation (s : String, r)Γ stands for (s, r)(String s | Γ).) The process type l? t . m! t [(s : String, r)(r! t [()l! t ])] means that (1) the lock must be acquired (by an input from l) before the method is invoked (by an output to m); (2) the method argument must be a pair of string s and a reply channel r; and (3) the lock must be released (by an output to l) but only after the reply from the object is sent to r. Note that the tuple type (s : String, r)(r! t [()l! t ]) refers to the lock l as a free variable, making it possible to express temporal dependency between l, which is not passed to the method body, and the reply channel r.</p><p>Then, a client (νr 1 ) (l? t . m! t ["Atsushi",</p><formula xml:id="formula_66">r 1 ]. r 1 ? t . l! t ) | (νr 2 ) (l? t . m! t ["Naoki", r 2 ]. r 2 ? t . l! t ) is well typed, but neither (νr 3 ) (m! t ["Atsushi", r 3 ]. r 3 ? t . P ) nor (νr 4 ) (l? t . m! t ["Naoki", r 4 ]. (r 4 ? t | l! t ))</formula><p>is. The above type of the interface roughly corresponds to the object type [m : ς(l)String → U nit • {l} • +] of Abadi and Flanagan's type system <ref type="bibr" target="#b9">[10]</ref>, which means that the method m can be invoked only after the lock on the object is acquired. Unfortunately, our type system is less expressive than theirs in some respects. As the example shows, channels representing a lock l and a method m guarded by the lock must be created at once; Otherwise, our type system will lose dependency among those channels. See Section 8 for a possible remedy against the problem. Similarly, we can express non-uniform service availability in our type system. For example, this is a process that creates a one-place buffer:</p><formula xml:id="formula_67">* newbuf ? [r]. (νput, get, b) ( b! | * b?. put?[x]. get?[r ]. (r ![x] | b!) | r![put, get])</formula><p>Now, two methods put and get are provided but they are available only alternately. By using ok 4 , we can guarantee that invocations of the methods put and get never get deadlocked. The interface [put, get] can be given a type:</p><formula xml:id="formula_68">(put, get)∞.µα.(0&amp;(put! t [τ ] | ∞.get! t [(r)r! t [τ ]]. ∞.α)),</formula><p>which says that an output to put must come in parallel to or before an output to get. (Here, ∞.Γ abbreviates µα.(Γ&amp;t 1 .α&amp; • • • &amp;t n .α) where {t 1 , . . . , t n } is the set of events occurring in the program. It means that it is allowed to wait for arbitrary events before using the value according to Γ.) <ref type="bibr">Then</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Type Checking/Reconstruction</head><p>By using Theorem 4.1.3, we can also formalize a common part of type-check/reconstruction algorithms: By reading the typing rules in a bottom-up manner, we can develop an algorithm that inputs a process expression and outputs a process type with a set of subtype constraints and consistency conditions on the type. The pair of a process type and a set of constraints is principal in the sense that a process is typeable if and only if the set of constraints output by the algorithm is satisfiable. Indeed, the algorithm presented here is essentially the same as the first half of an existing type reconstruction algorithm <ref type="bibr" target="#b30">[31]</ref>.</p><p>To complete a type-check/reconstruction algorithm, it will be only required to develop an algorithm to solve constraints on process types. Since the definitions of a subtype relation and a consistency condition vary, such algorithms have to be developed for each instance. Some of them, which have prototype implementations, can be found in the literature <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b30">31]</ref>.</p><p>In this section, we mainly discuss the common part: the definition of principal typings and an algorithm to compute them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Principal Typings</head><p>We first define the notion of principal typings in our type system. A principal typing is defined as a pair of a process type including process type variables and a set of constraints on the process type variables; all the possible process types, under which the process expression is well typed, are obtained from the process type in the pair, by replacing process type variables in the constraint so that the constraint is satisfied.</p><p>To define principal typings, we introduce a countably infinite set of process type variables, ranged over by ρ, and extend the definition of process types with the process type variables and the expressions Γ↓ The metavariable C denotes a set of constraints of the form Γ 1 ≤ Γ 2 , FV(Γ) ∩ {x} = ∅ or ok (Γ). Notation 7.1.2: We write θ for a substitution of (non-extended) process types and tuple types for process type variables and tuple type variables, respectively. We write FTV(Γ) and FTV(C) for the sets of (process and tuple) type variables appearing free in Γ and C, respectively.</p><p>Then, principal typings are defined as follows.</p><p>Definition 7.1.3 [principal typing]: A pair (Γ, C) of an extended process type and a set of constraints is a principal typing of a process P if it satisfies the following conditions:</p><p>1. If θ is chosen so that dom(θ) ⊇ FTV(Γ) ∪ FTV(C) and θC is satisfied, then θΓ P .</p><p>2. If Γ P , then there exists a substitution θ such that θC and Γ ≤ θΓ hold. P T (P ) = (Γ, C) :</p><formula xml:id="formula_69">P T (0) = (∅, ∅) P T (P 1 | P 2 ) = let (Γ 1 , C 1 ) = P T (P 1 ) (Γ 2 , C 2 ) = P T (P 2 ) in (Γ 1 | Γ 2 , C 1 ∪ C 2 ) P T ( * P 0 ) = let (Γ 0 , C 0 ) = P T (P 0 ) in ( * Γ 0 , C 0 ) P T (P 1 + • • • + P n ) = let (Γ 1 , C 1 ) = P T (P 1 ) . . . (Γ n , C n ) = P T (P n ) in (Γ 1 + • • • + Γ n , C 1 ∪ • • • ∪ C n ) P T (x! t [z]. P 0 ) = let (Γ 0 , C 0 ) = P T (P 0 ) in (x! t [α (n) ]. (ρ | α (n) z ), C 0 ∪ {ρ ≤ Γ 0 })</formula><p>(where α and ρ are fresh)</p><formula xml:id="formula_70">P T (x? t [ỹ]. P 0 ) = let (Γ 0 , C 0 ) = P T (P 0 ) in (x? t [α (n) ]. ρ, C 0 ∪ {(ρ | α (n) ỹ ) ≤ Γ 0 , FV(ρ) ∩ {ỹ} = ∅})</formula><p>(where α and ρ are fresh) Although a variety of type systems can be obtained as its instances, our generic type system is of course not general enough to obtain all kinds of type systems. There are two major sources of limitations of our type system: One is the way in which processes are abstracted, and the other is the way the consistency condition ok on types is formalized.</p><formula xml:id="formula_71">P T ((ν x) P 0 ) = let (Γ 0 , C 0 ) = P T (P 0 ) in (Γ 0 ↑ {x} , C 0 ∪ {ok (Γ 0 ↓ {x} ), FV(Γ 0 ↑ {x} ) ∩ {x} = ∅})</formula><p>Limitations caused by abstraction Because information on channel creation is lost in process types (recall the rule (T-New)), we cannot obtain type systems to guarantee properties like "at most n channels are created." We can overcome that limitation to some extent, by introducing a process type new k .Γ, which means that the process behaves like Γ after creating k channels.</p><p>Limitations caused by the formalization of ok To obtain common properties useful for proving type soundness (in Section 4), we required that the consistency condition ok must be an invariant condition (recall Definition 3.4.3). This requirement is, however, sometimes too strong. For example, suppose that we want to guarantee a property "Before a channel x is used for output, y must be used for input." (This kind of requirement arises, for example, in ensuring safe locking <ref type="bibr" target="#b10">[11]</ref>.) Note that this property is not an invariant condition: Once y is used for input, x can be used immediately. One way to overcome this limitation would be to annotate each channel creation (ν x) with the history of reductions, and parameterize ok with the history. Another limitation comes from the side condition ok (Γ↓ {x} ) of the rule (T-New): Because of the operation •↓ {x} , only the causality between simultaneously created channels can be directly controlled.</p><p>The above rule allows Γ 1 to specify causality between new channels x and other channels. Since Γ 1 may change during reductions, we also need to fix the reduction semantics so that the subject reduction property holds. For example, rule (R-New) should be replaced by the following rule:</p><formula xml:id="formula_72">P x t 1 ,t 2 i -→ Q x i ∈ {x} ∆ ≤ ∆ for all ∆ such that Γ x t 1 ,t 2 i -→ ∆ (ν x : Γ) P t 1 ,t 2 -→ (ν x : ∆) Q</formula><p>(We show only the case for x i ∈ {x}; The case for x i ∈ {x} is uglier.) It is left for future work to formalize these extensions elegantly.</p><p>Symmetric treatment of input and output processes As remarked in Section 3.5, the rules (T-In) and (T-Out) are asymmetric in the sense that information about the continuation of a receiver process is transfered to a sender process but not vice versa. Sometimes it is useful to propagate information in the reverse direction. For example, consider the following process:</p><p>(νsync) (x?. sync? | sync!. x!)</p><p>The two sub-processes synchronize on channel sync, so that x is first used for input and then used for output. In order to obtain such information, we need to put into the type of process sync? information that x is used for output after the synchronization (so that the process x?. sync? has a type of the form x?. sync?[τ ]. x!). That is achieved by represent input process types and output process types in the form</p><formula xml:id="formula_73">x? t [τ I ; τ O ]. Γ and x! t [τ I ; τ O ]. Γ</formula><p>, where τ I describes information about the continuation of an input process (which was already present in the type system in Section 3) and τ O describes information about the continuation of an output process. The new typing rules for output and input are:</p><formula xml:id="formula_74">Γ 1 | Γ 3 P x! t [(ỹ)Γ 2 ; ()Γ 3 ]. (Γ 1 | [z/ỹ]Γ 2 ) x! t [z]. P (T-Out-Sym) Γ 1 | Γ 2 P FV(Γ 1 ) ∩ {ỹ} = ∅ x? t [(ỹ)Γ 2 ; ()Γ 3 ]. (Γ 1 | Γ 3 ) x? t [ỹ]. P (T-In-Sym)</formula><p>The two sub-processes in the above example is then typed as follows:</p><p>x</p><formula xml:id="formula_75">?. sync?[τ 1 ; τ 2 ]. x! x?. sync? sync![τ 1 ; τ 2 ] sync!. x!</formula><p>for τ 1 = ( )0 and τ 2 = ( )x!.</p><p>Other extensions There are many other useful extensions. Combining our type system with polymorphism, existential types, etc. would be useful. We expect that polymorphism can be introduced in a similar manner to Pierce and Sangiorgi's polymorphic π-calculus <ref type="bibr" target="#b40">[41]</ref>.</p><p>Besides type-soundness proofs and type inference issues studied in this paper, it would be interesting to formalize other aspects of type systems through our generic type system. Typed process equivalence would be especially important, because it is hard to study even for specific type systems <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b39">40,</ref><ref type="bibr" target="#b40">41]</ref>.</p><p>Another interesting extension is generalization of the target language. If we can replace the πcalculus with a more abstract process calculus like Milner's action calculi <ref type="bibr" target="#b36">[37]</ref>, type systems for other process calculi can also be discussed uniformly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Related Work</head><p>General framework of type systems Previous proposals of a general framework <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b33">34]</ref> are (i) so abstract (e.g., <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b32">33]</ref>) that only a limited amount of work can be shared for developing concrete type systems, and/or (ii) not general (e.g., <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b33">34]</ref>) enough to account for recent advanced type systems <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b30">31</ref>]. Honda's work <ref type="bibr" target="#b19">[20]</ref> aims to develop a general theory of type systems for various process calculi, while our work in the present paper focuses on a specific process calculus (the πcalculus) and aims to develop a general theory of various type systems for the π-calculus. Being viewed as a theory of type systems for the π-calculus, Honda's framework <ref type="bibr" target="#b19">[20]</ref> seems to be more abstract and restrictive than ours. For example, his framework only deals with what he call additive systems, where the composability of processes are determined solely by channel-wise compatibility: So, it cannot deal with properties like deadlock-freedom, for which inter-channel dependency is important. Honda <ref type="bibr" target="#b20">[21]</ref> also developed a type theory for the π-calculus from the viewpoint of denotational semantics (as opposed to our study of the generic type system from an operational point of view); It is left for future work to study how these different approaches are related to each other. In König's framework of type systems <ref type="bibr" target="#b32">[33]</ref>, type environments do not change during reduction of a process. So, it cannot deal with dynamically changing properties like linearity <ref type="bibr" target="#b29">[30]</ref>. Moreover, the target calculus is less expressive than the π-calculus: It cannot express dynamic creation of channels. Conchon and Pottier <ref type="bibr" target="#b3">[4]</ref> proposes a framework of type systems for the join-calculus <ref type="bibr" target="#b13">[14]</ref>. The main focus of their work is a general study of type inference for the join-calculus in the presence of ML-style polymorphism. Their type system only guarantees a basic type soundness property that there is no arity mismatch error.</p><p>Other type systems viewing types as processes As mentioned in Section 1, the idea of expressing types as abstract processes has been inspired by our previous type systems for the πcalculus <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b45">46]</ref>. The development of the generic type system has been motivated by the observation that the underlying ideas and proofs of those type systems are very similar so that most of them can be shared. Besides the genericity, a technical novelty of our generic type system compared with our previous type systems is that we can express the order of communications on different channels directly using CCS-like processes (while in previous our type systems, we used a smaller process calculus as outlined in Section 1). Thanks to this extension, as observed in Section 6, our generic type system can also be used to analyze properties of concurrent objects.</p><p>Inspired by our work, Rehof et al. <ref type="bibr" target="#b2">[3]</ref> recently proposed a variant of our type system. In their type system, types are represented as a fragment of CCS <ref type="bibr" target="#b34">[35]</ref> which, unlike in our type system, includes the hiding (or channel creation) operator. It is not difficult to extend our types with the hiding operator as in their type system. While the main focus of their type system is on checking whether senders and receivers on each channel agrees on a communication protocol (like in which order senders and receivers use communicated channels), the focus of our type system is on checking channel-wise behavior of processes (like whether some process suffers from a race or deadlock condition on a particular channel). This difference resulted in slightly different formalization of the type systems. In particular, they <ref type="bibr" target="#b2">[3]</ref> chooses an open simulation relation as a specific subtyping relation and shows how to use a model checker to check the subtyping relation.</p><p>Some previous type systems also use process-like structures to express types. Yoshida's type system <ref type="bibr" target="#b51">[52]</ref> (which guarantees a certain deadlock-freedom property) and its successors <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b52">53]</ref> uses graphs to express the order of communications. Her type system is, however, specialized for a particular property, and the condition corresponding to our consistency condition seems too strong, even for guaranteeing deadlock-freedom. For example, there is no graph type corresponding to the type environment x? t . x? t | x! t | x! t of our type system.</p><p>Nielson and Nielson <ref type="bibr" target="#b37">[38]</ref> also use CCS-like process terms to express the behavior of CML programs. Because their analysis approximates a set of channels by using an abstract channel called a region, it is not suitable for analyses of deadlock-freedom (see <ref type="bibr" target="#b26">[27]</ref> for the reason), race detection, linearity analysis, etc., where the identity of a channel is important.</p><p>Process-like terms have been used as types also in type systems for deadlock-freedom <ref type="bibr" target="#b42">[43]</ref> and related properties <ref type="bibr" target="#b43">[44]</ref> of concurrent objects. As briefly outlined in Section 6, our type system can guarantee such properties without having concurrent objects as primitives.</p><p>Gordon and Jeffrey <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b17">18]</ref> proposed a type system for checking correspondence assertions. Two primitives begin(x) (for asserting the begin of a protocol) and end(x) (for asserting the end of a protocol) are introduced into the π-calculus and their type system checks that every execution of end(x) is preceded by one begin(x). To check that property, they introduced channel types of the form Ch(y : T )[{ x1 }, . . . , { x1 }], which expresses information that a receiver on that channel may perform the end actions end( x1 ), . . . , end( xn ). Their type system can be almost subsumed by our generic type system: By extending the syntax of types with begin(x) and end(x), we can express the channel type Ch (Alternatively, if a begin or end assertion mentions only a single name, the assertion can be encoded into an ordinary output.) However, in order to automatically obtain soundness of the type system from the soundness of our generic type system, we need to extend rules for channel creation as discussed in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Abstract interpretation</head><p>As mentioned in Section 1, our generic type system can be viewed as a kind of abstract interpretation framework <ref type="bibr" target="#b4">[5]</ref>, in the sense that properties of programs are verified by reasoning about abstract versions of those programs. From this viewpoint, our contribution is a novel formalization of a specific subclass of abstract interpretation for the π-calculus (for which no satisfactory general abstract interpretation framework has been developed to the authors' knowledge) as a type system. Another novelty seems to be that while conventional abstract interpretation often uses a denotational semantics to claim the soundness of an analysis, our type system uses an operational semantics, which seems to be more convenient for analyses of concurrent processes.</p><p>There are some studies of abstract interpretation for the π-calculus <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b50">51]</ref>, but they are quite different from our generic type system. While their abstract interpretation maps a process to one abstract process and analyzes its behavior, our generic type system maps a process to multiple process types (introduced for each (ν x) P ) and analyzes their behavior, so that the analysis is performed in a compositional manner.</p><p>Non-standard type systems for sequential languages Unlike standard type systems for functional languages, our type system keeps track of not only the shape of each value but also information about how and in which order each value (a communication channel in our case) is accessed. Nonstandard type systems for analyzing such properties have been recently studied to guarantee safe usage of resources such as memory and files <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b28">29]</ref>. Among them, our type systems for resource usage analysis <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b28">29]</ref> have been inspired by the generic type system in the present paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">Conclusion</head><p>We have proposed a general type system for concurrent processes, where types are expressed as abstract processes. We have shown that a variety of non-trivial type systems can be obtained as its instances, and that their correctness can be proved in a uniform manner.</p><p>Future work includes study of a more general version of the type soundness theorem in Section 4.2, and extensions of our generic type system discussed in Section 8, to give a complete account of the existing type systems for the π-calculus. Applications of our type system to programming languages and verification systems are also future work. The generic type system would be useful both (1) as a theoretical framework to design a type system for analyzing specific properties of programs (e.g., deadlock and race conditions), and (2) as a basis for constructing a general-purpose program verification tool with which properties to be verified can be specified as a formula of the process logic introduced in Section 4.2. Since the generic type system itself is not suitable for complete type inference (because of the non-determinism of the choice of Γ 1 and Γ 2 in rule (T-In), etc.), we need to either restrict the type system or allow a programmer to explicitly declare type information for the latter goal. We also need to study a model checking algorithm, which, given a type and a formula of the process logic, checks whether the type satisfies the formula.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Reduction Relation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Theorem 4 .</head><label>4</label><figDesc>1.1 [subject reduction]: If Γ P and P l -→ P with WF (Γ), then there exists Γ such that Γ l -→ Γ and Γ P . Proof: See Appendix A.1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Theorem 4 . 1 . 3 [</head><label>413</label><figDesc>normal derivation]: If Γ P , then Γ N P for some Γ such that Γ ≤ Γ .Proof: This follows from the fact that each application of the rule (T-Sub) above a rule except for (T-In) and (T-Out) can be permuted downwards.2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Corollary 4 . 1 . 4 : 1 .</head><label>4141</label><figDesc>If Γ ( νx 1..k ) (• • • + y? t [z]. P + • • • | Q) and ok (Γ), then the following conditions hold. If y ∈ { x1 , . . . , xk }, then Γ ≤ • • • + y? t [τ ]. Γ 1 + • • • | Γ 2 for some τ, Γ 1 , and Γ 2 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>pr•</head><label></label><figDesc>Case A = l B: Suppose (ν x) P ∈ [[A]] S pr . Then, there exists Q such that (ν x)P l -→ Q with l ↑ S = l and Q ∈ [[B]] Spr . By Lemma 4.2.9, there existsQ such that P l -→ Q with (ν x) Q Q and l ↑ {x} = l . By Lemma 4.2.10 and Q ∈ [[B]] S pr , we have (ν x) Q ∈ [[B]] S pr . By induction hypothesis, we have Q ∈ [[B]] S∪{x} pr . Since l ↑ S∪{x} = l ↑ S = l, we have P ∈ [[A]] S∪{x} pr as required.On the other hand, suppose P ∈ [[A]] S∪{x} pr , with S∩{x} = ∅. Then, there exists Q and l such thatP l -→ Q with l ↑ S∪{x} = l and Q ∈ [[B]] S∪{x}pr . By rule (R-New), we have (ν x) P l ↑ {x} -→ (ν x) Q.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :Notation 4 . 2 . 13 :</head><label>64213</label><figDesc>Figure 6: Inference Rules for Proving A B and A → B</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Lemma 4 . 2 . 15 :</head><label>4215</label><figDesc>The inference rules in Figure 6 are sound. Proof: Without loss of generality, we can assume that formulas do not contain free integer variables. The soundness of the rules (F-Out) and (F-In) follow immediately from Corollary 4.1.4. To show the soundness of (F-Red), suppose that A → B, P ∈ [[ l A]] S pr , and Γ P . By P ∈ [[ l A]] S pr , there must exist Q and l such that P l -→ Q with l ↑ S = l and Q ∈ [[A]] S pr . By Theorem 4.1.1, there exists ∆ such that Γ l -→ ∆ and ∆ Q. By Lemma A.1.3 in Appendix, we have Γ↑ S l -→ ∆↑ S . By the assumption A → B, we have</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>S ty as required. To show the soundness of (F-Neg1), suppose that A B, P ∈ [[¬B]] S pr , and Γ P . It suffices to show Γ ∈ [[A]] S ty . Suppose Γ ∈ [[A]] S ty . Then, by A B, it must be the case that P ∈ [[B]] S pr . But this contradicts with the assumption P ∈ [[¬B]] S pr = Proc\[[B]] S pr . The proof of the soundness of (F-Neg2) is similar. 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>{x 1 ,...,xn} and Γ↑ {x 1 ,...,xn} . Definition 7.1.1 [extended process type]: The set of process types is extended as follows. Γ ::= • • • | ρ | Γ↓ {x 1 ,...,xn} | Γ↑ {x 1 ,...,xn}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 7 : 7 . 7 . 2 . 1 :</head><label>77721</label><figDesc>Figure 7: Algorithm P T</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>(y : T )[{ x1 }, . . . , { x1 }] as: (x)( * x?[(y)(y : T | end( x1 ) | • • • | end( xn ))] | * x![(y)(y : T | end( x1 ) | • • • | end( xn ))]).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>νx 1 , . . . , x n ) P | * P G (guarded processes) ::= x! t [y 1 , . . . , y n ]. P | x? t [y 1 , . . . , y n ]. P</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Definition 3.1.3: A tuple type or process type is closed if it contains no free type variables. A tuple or process type is semi-closed if it contains no free type variables inside [ ]. A tuple type τ is contractive in α if τ contains free occurences of α only inside [ ].</figDesc><table /><note><p>t [τ ]. Γ 1 or x! t [τ ]. Γ 1 . We give precedence to prefixes (t., x! t [τ ]. , and x? t [τ ]. ), +, &amp;, and | in this order. Example 3.1.4: A process type x?[µα.(x)(x? t</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>xk } pr By Lemma A.1.6, we have Γ ( νx 1..k ) (P 1 | P 2 ). By Theorem 4.1.3, we have</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 1 :</head><label>1</label><figDesc>|= ¬∃x.∃t 1 , t 2 .∃ζ 1 , ζ 2 : {ζ 1 = ζ 2 }.(x! t 1 ζ 1 | x? t 2 ζ 2 ) p 2 (P ) P ( νw) P implies P |= ¬∃x.∃t 1 .∃ζ 1 , ζ 2 .(x! t ζ 1 | x! t 1 ζ 2 ) p 3 (P ) P ( νw) P implies P |= ¬∃x.∃t 1 , t 2 .∃ζ. x t 1 ,t ev (x! t 2 ζ ∨ x? t 2 ζ) p 4 (P ) P ( νw) P implies P |= ¬∃x, ∃ζ.((x! t ζ ∨ x? t ζ) ∧ ¬∃y.∃t 1 , t 2 .( y t 1 ,t 2 true ∨ t 1 ,t 2 true)) Properties of Processes ok 1 (Γ) WF (Γ) ok 2 (Γ) WF (Γ) and Γ |= ¬ev (∃x.∃t 1 .∃ζ 1 , ζ 2 : {ζ 1 = ζ 2 }.(x! t ζ 1 | x! t 1 ζ 2 )) ok 3 (Γ) WF (Γ) and Γ |= ¬ev (∃x.∃t 1 , t 2 .∃ζ. x t 1 ,t ev (x! t 2 ζ ∨ x? t 2 ζ)) , t 2 .( y t 1 ,t 2 true</figDesc><table><row><cell></cell><cell>WF (Γ) and</cell><cell></cell></row><row><cell>ok 4 (Γ)</cell><cell>Γ |= ¬ev (∃t .∃x.∃ζ.(t</cell><cell>t ∧ (x! t ζ ∨ x? t ζ)</cell></row><row><cell></cell><cell></cell><cell>∧ ¬∃y.∃t 1</cell></row></table><note><p>ty , then P ∈ [[A]] S pr holds. Conversely, for any S ⊆ Var, if A ∈ F + with FIV(A) = ∅ and P ∈ [[A]] S pr , then Γ ∈ [[A]] S ty holds. p 1 (P ) P ( νw) P implies P</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>This is operationally the same as (νx1) • • • (νxn) P , but we distinguish them in the type system given in Section 3.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>This is just for the sake of simplicity. By distinguishing between •! t [τ(n)  ]. Γ and •? t [τ(n)  ]. Γ, we can obtain a slightly more precise analysis.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>So, Γ 1 &amp;Γ 2 is similar to an intersection type Γ 1 ∧ Γ 2 . The difference is that a value of type Γ 1 &amp;Γ 2 can be used only once according to either Γ1 or Γ2.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>It is possible to introduce a general fixed-point operator<ref type="bibr" target="#b44">[45]</ref> instead, but we did not do so in this paper for simplicity.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>Yoshida's type system<ref type="bibr" target="#b51">[52]</ref> also allows such use of channels.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>Flanagan and  Abadi's type system<ref type="bibr" target="#b9">[10]</ref> also gives such a guarantee. Since their target calculus has locks as primitives, the problem is a little simpler.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_6"><p>We do not want an output like "Hello, Hello, ".</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_7"><p>Because of this restriction, unlike Abadi and Flanagan's type system for concurrent objects, we cannot deal with the case where an object and its lock are separately created.One way to remove the restrictions mentioned above would be to add type annotation of the form (ν x : Γ) P to the channel creation primitive. Here, Γ specifies how newly created channels x should be used in combination with other channels. For example, (νx :l? t 1 []. x! t 2 [τ ]. l! t 3 [] | * x? t 4 [τ ]) P means that a new channel x is created and that whenever x is used for output, the lock l is acquired beforehand and l is released afterwards. This extension, however, requires a substantial amount of change in the type system and the proof of subject reduction. First, we need to replace the typing rule for channel creation with something like:Γ 1 | Γ 2 P WF (Γ 1 ↓ {x} ) FV(Γ 1 ↑ {x} | Γ 2 ) ∩ {x} = ∅ Γ 1 ↑ {x} | Γ 2 (ν x : Γ 1 ) P (T-New')</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_8"><p>Case R-Com:P = • • • + x! t [z]. P 0 + • • • | • • • + x? t [ỹ]. Q 0 + • • • Q = P 0 | [z/ỹ]Q 0 l = x t,t By Lemma A.1.2 and the subtyping rules, there exist Γ 1 , Γ 2 , Γ 3 , and Γ 4 such thatΓ ≤ • • • + x! t [( w)Γ 2 ]. (Γ 1 | [z/ w]Γ 2 ) + • • • | • • • + x? t [(ỹ)Γ 4 ]. Γ 3 + • • • Γ 1 P 0 Γ 3 | Γ 4 Q 0 FV(Γ 3 ) ∩ {ỹ} = ∅.Then, since WF (Γ), it must be the case that ( w)Γ 2 ≤ (ỹ)Γ 4 , that is, Γ 2 ≤ [ w/ỹ]Γ 4 . We can show Γ x t,t -→ Γ 1 | [ỹ/ w](Γ 3 | Γ 4 )</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We would like to thank Andrew Gordon, Jakob Rehof, and Eijiro Sumii for useful discussions and comments. We would also like to thank anonymous referees for useful comments and suggestions, and Naokata Shikuma for spotting errors in an earlier version of the paper.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Main Ideas</head><p>Definition 4.2.8: Let A be a formula such that FIV(A) = ∅, and let S be a finite set of variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The sets [[A]] pr and [[A]] S</head><p>pr of processes are defined by (Proc is the set of processes): </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>It is easy to prove that [[A]] pr and [[A]] S</head><p>pr are well defined, by induction on the size of A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>We show some properties of [[A]] S</head><p>pr .</p><p>Lemma 4.2.9:</p><p>Proof: This follows by straightforward induction on derivation of (ν x)</p><p>Proof: This lemma follows by induction on the size of A. Proof: The proof proceeds by induction on the size of A. We show only main cases; The other cases are similar or trivial.</p><p>• Case A = x! t n: the required property follows by: . By using Theorem 4.2.17, we obtain</p><p>Intuitively, the last sentence of the above corollary means that all the channels created during reductions of P are used according to A. The corollary implies that, in order to guarantee that property, it suffices to define the consistency condition ok by ok</p><p>Using the above corollary, we can obtain various type systems. For example, we can obtain a variant of the linear channel type system <ref type="bibr" target="#b29">[30]</ref>. Let A be ¬∃x.∃t 1 , t 2 , t 3 .∃ζ.ev ( x t 1 ,t 2 ev (x! t 3 ζ ∨ x? t 3 ζ)); Then it is guaranteed that every channel is used at most once. More examples are given in Section 5.</p><p>Note that our generic type system can be used also for reasoning about properties described by some non-negative formulas: Indeed, the deadlock-freedom property is not described as a non-negative formula, but as we show in Section 5, we can obtain a type system for deadlock-freedom as an instance of our generic type system and show its soundness (by using not the above corollary but more basic theorems presented in Section 4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Applications</head><p>We show that a variety of type systems -those for arity-mismatch check, race detection, static garbage-channel collection, and deadlock detection, -can indeed be obtained as instances of the generic type system. Thanks to the common properties shown in Section 4, only a small amount of extra work is necessary to define each instance and prove its correctness.</p><p>Table <ref type="table">1</ref> shows the invariant properties of processes that should be guaranteed by those type systems. The condition p 1 (P ) means that no arity-mismatch error occurs immediately. (So, if p 1 is an invariant condition, no arity-mismatch error occurs during reduction of P .) p 2 (P ) means that P is not in a race condition on any output actions annotated with t. p 3 (P ) means that it is not the case that an input process labeled with t can be reduced and the same channel is used for input or output after that. The invariance of that property means that after a channel has been used for an input action annotated with t, the channel is no longer used. So, it is safe to deallocate the channel </p><p>Proof: By induction on the structure of Γ. 5. If P = (ν x) P 0 , then there exists Γ 0 such that Γ 0 P 0 and Γ ≤ Γ 0 ↑ {x} with ok (Γ↓ {x} ) and FV(Γ 0 ↑ {x} ) ∩ {x} = ∅.</p><p>6. If P = * P 0 , then there exists Γ 0 such that Γ 0 P 0 and Γ ≤ * Γ 0 .</p><p>Proof: Immediate from the fact that a type derivation of Γ P must end with an application of the rule corresponding to the form of P , followed by zero or more applications of the rule T-Sub.</p><p>where L is defined by:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>and y ∈ {x} L otherwise</head><p>Proof: By induction on the derivation of Γ L -→ Γ with a case analysis on the last rule used. We show only the main base case below; The other cases are easy.</p><p>Case TER-Com:</p><p>We have two subcases according to whether y ∈ {x} or not. We will show the subcase where y Proof: Suppose WF (Γ) does not hold. Then, there exist x, τ 1 , τ 2 , t 1 , t 2 , Γ 1 , Γ 2 , and Γ 3 such that</p><p>and τ 1 τ 2 . By using Lemma A.1.3 repeatedly, either</p><p>contradicting the assumptions WF (Γ↓ S ) and WF (Γ↑ S ). 2</p><p>Lemma A.1.5 [substitution]:</p><p>Proof: By straightforward induction on the derivation of Γ P . 2</p><p>Lemma A.1.6: If Γ P and P Q, then Γ Q.</p><p>Proof: By structural induction on the derivation of P Q with a case analysis of the last rule used. We show a few interesting cases below; The other cases are easy.</p><p>Case:  by the following calculation:</p><p>Case R-Par:</p><p>To use the induction hypothesis, we show WF (Γ 1 ) by contradiction. Suppose WF (Γ 1 ) does not hold. Then, WF (Γ 1 | Γ 2 ) does not hold, either; It means WF (Γ) does not hold. Thus, WF (Γ 1 ).</p><p>By the induction hypothesis, there exists Γ 1 such that Γ 1 l -→ Γ 1 and Γ 1 Q 0 . By the rules TER-Skip, TER-Par, and TER-Sub,</p><p>We show the subcase where l = x t,t i for some i, thus l = t,t ; The other cases (l = t,t or l = y t,t with y ∈ {x}) are similar. By Lemma A.1.2, there exists Γ 0 such that</p><p>Since WF (Γ 0 ↓ {x} ) and WF (Γ 0 ↑ {x} ) from the assumptions, we have WF (Γ 0 ) by Lemma A. We first show properties of ≤ 1 and ≤ 2 .</p><p>Lemma A.2.7: Let ≤ be ≤ i (i ∈ {1, 2}), and suppose Γ N P for some P . Then, the following conditions hold: </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Subtyping recursive types</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Amadio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="575" to="631" />
			<date type="published" when="1993-09">September 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Anytime, anywhere: Modal logics for mobile ambients</title>
		<author>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Gordon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages</title>
		<meeting>ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="365" to="377" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Types as models: Model checking message-passing programs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rajamani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rehof</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages</title>
		<meeting>ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="45" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">JOIN(X): Constraint-based type inference for the join-calculus</title>
		<author>
			<persName><forename type="first">S</forename><surname>Conchon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pottier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th European Symposium on Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>the 10th European Symposium on Programming</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2028</biblScope>
			<biblScope unit="page" from="221" to="236" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints</title>
		<author>
			<persName><forename type="first">P</forename><surname>Cousot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cousot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIG-PLAN/SIGACT Symposium on Principles of Programming Languages</title>
		<meeting>ACM SIG-PLAN/SIGACT Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1977">1977</date>
			<biblScope unit="page" from="238" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Enforcing high-level protocols in low-level software</title>
		<author>
			<persName><forename type="first">R</forename><surname>Deline</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fähndrich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>ACM SIGPLAN Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="59" to="69" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Adoption and focus: Practical linear types for imperative programming</title>
		<author>
			<persName><forename type="first">R</forename><surname>Deline</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fähndrich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>ACM SIGPLAN Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Program analysis using mixed term and set constraints</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fähndrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SAS&apos;97</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>SAS&apos;97</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1302</biblScope>
			<biblScope unit="page" from="114" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Occurrence counting analysis for the pi-calculus</title>
		<author>
			<persName><forename type="first">J</forename><surname>Feret</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Electronic Notes in Theoretical Computer Science</title>
		<imprint>
			<publisher>Elsevier Science Publishers</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="55" to="77" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Object types against races</title>
		<author>
			<persName><forename type="first">C</forename><surname>Flanagan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CONCUR&apos;99</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1664</biblScope>
			<biblScope unit="page" from="288" to="303" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Types for safe locking</title>
		<author>
			<persName><forename type="first">C</forename><surname>Flanagan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ESOP 1999</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>ESOP 1999</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1576</biblScope>
			<biblScope unit="page" from="91" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Type-based race detection for Java</title>
		<author>
			<persName><forename type="first">C</forename><surname>Flanagan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">N</forename><surname>Freund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>ACM SIGPLAN Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="219" to="232" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Flow-sensitive type qualifiers</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Terauchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>ACM SIGPLAN Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The reflexive CHAM and the join-calculus</title>
		<author>
			<persName><forename type="first">C</forename><surname>Fournet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gonthier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages</title>
		<meeting>ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="372" to="385" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The type system for object initialization in the Java bytecode language</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">N</forename><surname>Freund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1196" to="1250" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A sort inference algorithm for the polyadic π-calculus</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Gay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIG-PLAN/SIGACT Symposium on Principles of Programming Languages</title>
		<meeting>ACM SIG-PLAN/SIGACT Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="429" to="438" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Typing correspondence assertions for communication protocols. Theoretical Computer Science</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jeffrey</surname></persName>
		</author>
		<idno>ENTCS 45</idno>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>Elsevier</publisher>
		</imprint>
	</monogr>
	<note>To appear. A preliminary version appeared in Seventeenth Conference on the Mathematical Foundations of Programming Semantics (MFPS 2001</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Authenticity by typing for security protocols</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jeffrey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th IEEE Computer Security Foundations Workshop (CSFW 2001)</title>
		<meeting>the 14th IEEE Computer Security Foundations Workshop (CSFW 2001)</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="145" to="159" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Information flow vs. resource access in the information asynchronous pi-calculus</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hennessy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Riely</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ICALP 2000</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>ICALP 2000</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000-07">July 2000</date>
			<biblScope unit="volume">1853</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Composing processes</title>
		<author>
			<persName><forename type="first">K</forename><surname>Honda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages</title>
		<meeting>ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="344" to="357" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">A theory of types for π-calculus. Typescript</title>
		<author>
			<persName><forename type="first">K</forename><surname>Honda</surname></persName>
		</author>
		<ptr target="http://www.dcs.qmul.ac.uk/~kohei/" />
		<imprint>
			<date type="published" when="1998-11">November 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Secure information flow as typed process behaviour</title>
		<author>
			<persName><forename type="first">K</forename><surname>Honda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vasconcelos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Yoshida</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of European Symposium on Programming (ESOP)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>of European Symposium on Programming (ESOP)</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000. 2000</date>
			<biblScope unit="volume">1782</biblScope>
			<biblScope unit="page" from="180" to="199" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A uniform type structure for secure information flow</title>
		<author>
			<persName><forename type="first">K</forename><surname>Honda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Yoshida</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages</title>
		<meeting>ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="81" to="92" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Type reconstruction for linear pi-calculus with I/O subtyping</title>
		<author>
			<persName><forename type="first">A</forename><surname>Igarashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Kobayashi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">161</biblScope>
			<biblScope unit="page" from="1" to="44" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Resource usage analysis</title>
		<author>
			<persName><forename type="first">A</forename><surname>Igarashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Kobayashi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIG-PLAN/SIGACT Symposium on Principles of Programming Languages</title>
		<meeting>ACM SIG-PLAN/SIGACT Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="331" to="342" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A pi-calculus semantics for an object-based design notation</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">B</forename><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CONCUR&apos;93</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>CONCUR&apos;93</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="158" to="172" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A partially deadlock-free typed process calculus</title>
		<author>
			<persName><forename type="first">N</forename><surname>Kobayashi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="436" to="482" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A type system for lock-free processes</title>
		<author>
			<persName><forename type="first">N</forename><surname>Kobayashi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">177</biblScope>
			<biblScope unit="page" from="122" to="159" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Time regions and effects for resource usage analysis</title>
		<author>
			<persName><forename type="first">N</forename><surname>Kobayashi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIG-PLAN International Workshop on Types in Languages Design and Implementation (TLDI&apos;03)</title>
		<meeting>ACM SIG-PLAN International Workshop on Types in Languages Design and Implementation (TLDI&apos;03)</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="50" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Linearity and the pi-calculus</title>
		<author>
			<persName><forename type="first">N</forename><surname>Kobayashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">N</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="914" to="947" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">An implicitly-typed deadlock-free process calculus</title>
		<author>
			<persName><forename type="first">N</forename><surname>Kobayashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Saito</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Sumii</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CONCUR2000</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>CONCUR2000</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000-08">August 2000</date>
			<biblScope unit="volume">1877</biblScope>
			<biblScope unit="page" from="489" to="503" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Towards foundations for concurrent object-oriented programming -types and language design</title>
		<author>
			<persName><forename type="first">N</forename><surname>Kobayashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Yonezawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theory and Practice of Object Systems</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="243" to="268" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Generating type systems for process graphs</title>
		<author>
			<persName><forename type="first">B</forename><surname>König</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CONCUR&apos;99</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>CONCUR&apos;99</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1664</biblScope>
			<biblScope unit="page" from="352" to="367" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Analysing input/output-capabilities of mobile processes with a generic type system</title>
		<author>
			<persName><forename type="first">B</forename><surname>König</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ICALP2000</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>ICALP2000</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1853</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<title level="m">Communication and Concurrency</title>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">The polyadic π-calculus: a tutorial</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic and Algebra of Specification</title>
		<editor>
			<persName><forename type="first">F</forename><forename type="middle">L</forename><surname>Bauer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><surname>Brauer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Schwichtenberg</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Calculi for interaction</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="707" to="737" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Higher-order concurrent programs with finite communication topology</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">R</forename><surname>Nielson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Nielson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages</title>
		<meeting>ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="84" to="97" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Type-based analysis of uncaught exceptions</title>
		<author>
			<persName><forename type="first">F</forename><surname>Pessaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Leroy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages</title>
		<meeting>ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="276" to="290" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Typing and subtyping for mobile processes</title>
		<author>
			<persName><forename type="first">B</forename><surname>Pierce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sangiorgi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Structures in Computer Science</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="409" to="454" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Behavioral equivalence in the polymorphic pi-calculus</title>
		<author>
			<persName><forename type="first">B</forename><surname>Pierce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sangiorgi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the Association for Computing Machinery (JACM)</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="531" to="584" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Concurrent objects in a process calculus</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">N</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theory and Practice of Parallel Programming (TPPP)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>Sendai, Japan</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1994-11">Nov. 1994. 1995</date>
			<biblScope unit="volume">907</biblScope>
			<biblScope unit="page" from="187" to="215" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Changeable interfaces and promised messages for concurrent components</title>
		<author>
			<persName><forename type="first">F</forename><surname>Puntigam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Peter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1999 ACM Symposium on Applied Computing</title>
		<meeting>the 1999 ACM Symposium on Applied Computing</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="141" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Typing non-uniform concurrent objects</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ravara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vasconcelos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CON-CUR2000</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>CON-CUR2000</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1877</biblScope>
			<biblScope unit="page" from="474" to="488" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Modal and temporal logics for processes</title>
		<author>
			<persName><forename type="first">C</forename><surname>Stirling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logics for Concurrency</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1043</biblScope>
			<biblScope unit="page" from="149" to="237" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">A generalized deadlock-free process calculus</title>
		<author>
			<persName><forename type="first">E</forename><surname>Sumii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Kobayashi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Workshop on High-Level Concurrent Language (HLCL&apos;98)</title>
		<meeting>of Workshop on High-Level Concurrent Language (HLCL&apos;98)</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="55" to="77" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Polymorphic type, region and effect inference</title>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Talpin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Jouvelot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Functional Programming</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="245" to="271" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">The type and effect discipline</title>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Talpin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Jouvelot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">111</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="245" to="296" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Implementation of the call-by-value lambda-calculus using a stack of regions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Tofte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Talpin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages</title>
		<meeting>ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="188" to="201" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Principal typing schemes in a polyadic π-calculus</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">T</forename><surname>Vasconcelos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Honda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CON-CUR&apos;93</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">715</biblScope>
			<biblScope unit="page" from="524" to="538" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Automatic determination of communication topologies in mobile systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Venet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 5th International Symposium on Static Analysis (SAS &apos;98)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>5th International Symposium on Static Analysis (SAS &apos;98)</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1503</biblScope>
			<biblScope unit="page" from="152" to="167" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Graph types for monadic mobile processes</title>
		<author>
			<persName><forename type="first">N</forename><surname>Yoshida</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FST/TCS&apos;16</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1180</biblScope>
			<biblScope unit="page" from="371" to="387" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Strong normalization in the π-calculus</title>
		<author>
			<persName><forename type="first">N</forename><surname>Yoshida</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Honda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Symposium on Logic in Computer Science</title>
		<meeting>IEEE Symposium on Logic in Computer Science</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
