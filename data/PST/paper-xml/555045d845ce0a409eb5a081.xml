<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Towards Efficient Privacy-preserving Image Feature Extraction in Cloud Computing</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Zhan</forename><surname>Qin</surname></persName>
							<email>zhanqin@buffalo.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">SUNY at Buffalo</orgName>
								<address>
									<postCode>14214</postCode>
									<settlement>Buffalo</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jingbo</forename><surname>Yan</surname></persName>
							<email>jbyan@xidian.edu.cn</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">SUNY at Buffalo</orgName>
								<address>
									<postCode>14214</postCode>
									<settlement>Buffalo</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Kui</forename><surname>Ren</surname></persName>
							<email>kuiren@buffalo.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">SUNY at Buffalo</orgName>
								<address>
									<postCode>14214</postCode>
									<settlement>Buffalo</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Chang</forename><forename type="middle">Wen</forename><surname>Chen</surname></persName>
							<email>chencw@buffalo.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">SUNY at Buffalo</orgName>
								<address>
									<postCode>14214</postCode>
									<settlement>Buffalo</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Cong</forename><surname>Wang</surname></persName>
							<email>congwang@cityu.edu.hk</email>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">City University of Hong Kong</orgName>
								<address>
									<settlement>Hong Kong</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Towards Efficient Privacy-preserving Image Feature Extraction in Cloud Computing</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">E16F8376ECBA87183CABC48E9C7FE96A</idno>
					<idno type="DOI">10.1145/2647868.2654941</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:45+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>H.3.3 [Information Systems Applications]: Information Search and Retrieval Security, Algorithm Image Feature Detection</term>
					<term>SIFT</term>
					<term>Privacy-preserving</term>
					<term>Cloud Computing Client Generators Comparer Image Encryption Scale-space Cube Generation Interesting Point Localization Descriptor Generation Descriptor Decryption</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>As the image data produced by individuals and enterprises is rapidly increasing, Scalar Invariant Feature Transform (SIFT), as a local feature detection algorithm, has been heavily employed in various areas, including object recognition, robotic mapping, etc. In this context, there is a growing need to outsource such image computation with high complexity to cloud for its economic computing resources and on-demand ubiquitous access. However, how to protect the private image data while enabling image computation becomes a major concern. To address this fundamental challenge, we study the privacy requirements in outsourcing SIFT computation and propose SecSIFT, a high performance privacy-preserving SIFT feature detection system. In previous private image computation works, one common approach is to encrypt the private image in a public key based homomorphic scheme that enables the original processing algorithms designed for plaintext domain to be performed over ciphertext domain. In contrast to these works, our system is not restricted by the efficiency limitations of homomorphic encryption scheme. The proposed system distributes the computation procedures of SIFT to a set of independent, co-operative cloud servers, and keeps the outsourced computation procedures as simple as possible to avoid utilizing homomorphic encryption scheme. Thus, it enables implementation with practical computation and communication complexity. Extensive experimental results demonstrate that SecSIFT performs comparably to original SIFT on image benchmarks while capable of preserving the privacy in an efficient way.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Nowadays, it is getting more and more popular for owners to outsource image data from local devices to cloud for its great flexibility and cost saving <ref type="bibr" target="#b2">[2]</ref>. Popular social network providers commonly utilize image data to realize behavioral advertising, preference analytics, etc., <ref type="bibr" target="#b16">[16]</ref>. For example, Facebook and Flickr are extracting qualified features from users' images and constructing corresponding data mining models to improve their user experiences in social discovery <ref type="bibr" target="#b20">[20]</ref>. To manage the massive computation workload in image feature extraction and utilization on the "Big Data", more and more image owners choose to outsource the computation of image feature extractions to cloud <ref type="bibr" target="#b32">[32]</ref>. However, this trend creates the privacy concerns. The outsourced image data reveals private information of the owner, like personal identity, location, or even financial profiles. Moreover, even features extracted from the image may leak important private information. The attacker can deduce the content of image via feature comparisons in a benchmark image database, or even recover part of the image based on these features. Thus, exploring privacy-preserving image feature detection over encrypted cloud data becomes of paramount importance.</p><p>There is an emerging research field on discovering solutions to enable image processing over encrypted data <ref type="bibr" target="#b15">[15]</ref>. In secure multimedia data search <ref type="bibr" target="#b26">[26,</ref><ref type="bibr" target="#b19">19]</ref>, the authors propose designs to protect the privacy of the query image when searching over a public database by utilizing oblivious retrieval techniques. Some existing works are interested in the manipulation of encrypted image data in different forms, e.g., face recognition system <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b25">25,</ref><ref type="bibr" target="#b23">23]</ref>, ECG signals <ref type="bibr" target="#b4">[4]</ref>, and fingercode authentication system <ref type="bibr" target="#b3">[3]</ref>. Others focus on extracting/detecting image features from the ciphertext domain, e.g., Scalar Invariant Feature Transform (SIFT) <ref type="bibr" target="#b14">[14]</ref>, and shape-based image features <ref type="bibr" target="#b29">[29]</ref>.</p><p>However, all previous works on private image feature detection impose either heavy workload for image owners or unacceptable computational complexity at the cloud side, if not both. Thus, none of them is suitable for practical usages. In <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b5">5]</ref>, image owners have to perform very expensive operations of homomorphic encryption before outsourcing. In <ref type="bibr" target="#b12">[12,</ref><ref type="bibr" target="#b14">14]</ref>, existing solutions require the cloud to perform massive homomorphic evaluations in the ciphertext domain (Details refer to Sec. 6). Another common weakness is that no previous work can protect the location information of the feature points, which may subsequently lead to significant information leakage to the cloud server depending the nature of the images <ref type="bibr" target="#b29">[29]</ref>.</p><p>Hence, in this paper, we focus on enabling practical and privacy-preserving SIFT computation over outsourced image. We present SecSIFT, a system for performing privacypreserving image feature detection over private user image data, which scales substantially better than the previous systems. SecSIFT operates under the similar trust model as used in several recent private proposals, i.e., honest-butcurious and independent servers. There are two key points that differentiate our proposal from other homomorphic encryption based solutions <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b29">29,</ref><ref type="bibr" target="#b12">12]</ref>: How the privacy of local feature's locations is defined, and How the computation procedures are distributed among cloud servers. Prior works only protect the image data by encrypting them through a homomorphic encryption scheme. They either leak the locations of feature points to the cloud <ref type="bibr" target="#b13">[13]</ref> or require impractical computational resources <ref type="bibr" target="#b19">[19]</ref>. In our security model, the privacy of image content is defined in two aspects: the confidentiality of values and the delocalization of keypoints. Both of them are protected. The proposed design also divides the SIFT algorithm into several computation procedures and distributing them to different cloud entities. The efficiency of the proposed system is promised by utilizing splitting based encryption, Order Preserving Encryption (OPE), random permutation, and dummy point perturbation as its crypto primitives in different components of the system.</p><p>Altogether, this paper makes the following contributions:</p><p>• It presents the design of SecSIFT, a private system for performing SIFT computation without leaking the private information of the processed image. SecSIFT is typically one to two orders of magnitude more efficient in bandwidth and computation complexity than previous comparable systems (i.e., the systems with similar features and trust model).</p><p>• It gives formal security proofs to justify the correctness and privacy-preserving guarantee of the proposed mechanism. A detailed evaluation on the utility, privacy, and efficiency of SecSIFT is provided.</p><p>• It describes a complete implementation of SecSIFT.</p><p>Extensive experiments on Microsoft Azure cloud instance with real dataset across thousands of images (Caltech256) demonstrate the effectiveness and efficiency of the proposed system.</p><p>The rest of this paper is organized as follows: The next section gives a brief introduction to SIFT algorithm. Section 3 gives the problem formulation of SecSIFT, and states the design goals of the proposed system. Section 4 presents the system design. We describe analysis and evaluation of the correctness, privacy, and efficiency of the proposed system in Section 5.1, 5.2, and 5.3. Finally, we present related work and conclude in Section 6 and 7, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PRELIMINARY ON SIFT</head><p>Scale Invariant Feature Transform (SIFT) is one of the most popular algorithms in computer vision to extract and describe local features in images. We separate it into mainly two stages to describe the algorithm briefly below. Detailed elaboration can be found in <ref type="bibr" target="#b17">[17]</ref>: • Scale-space Extrema Detection: This is the stage where the keypoints are detected (located). In this stage, the image is convolved with Gaussian filters at multiple scales, and then successive Gaussian-blurred images are taken. The keypoints are taken as extreme points of the Difference of Gaussians (DoG) that occur at multiple scales. Specifically, a DoG image D(x, y, σ) is given by</p><formula xml:id="formula_0">D(x, y, σ) = L(x, y, kiσ) -L(x, y, kjσ) (1)</formula><p>where L(x, y, kσ) is the convolution of the original image I(x, y) with the Gaussian-blur G(x, y, kσ) at scale kσ, i.e., L(x, y, kσ) = G(x, y, kσ) * I(x, y). Hence a DoG image between scales kiσ and kjσ is just the difference of the Gaussian-blurred images at scales kiσ and kjσ. As shown in Fig. <ref type="figure" target="#fig_0">1</ref>, for Scale-space Extrema Detection, the convolved images are grouped by octave (an octave corresponds to doubling the value of σ).</p><p>The DoG images are taken from adjacent Gaussianblurred images per octave.</p><p>Once DoG images are obtained, keypoints are identified as local extrema of the DoG images across scales. This is done by comparing each pixel in the DoG images to its eight neighbors at the same scale and nine corresponding neighboring pixels in each of the neighboring scales. If a pixel value is an extrema among all neighboring pixels, it is selected as a keypoint.</p><p>• Feature Descriptor Generation: In this step, the keypoints are assigned orientations based on local image gradient directions. The keypoint descriptor can be represented relative to this orientation, which explaines the invariance to image rotation.</p><p>First, the Gaussian-blurred image L(x, y, σ) at the keypoint's scale σ is taken so that all computations are performed in a scale-invariant manner. For an image sample L(x, y, σ), the gradient vector consists of magnitude m(x, y) and orientation θ(x, y), which are calculated using pixel differences: Let the gradient magnitudes be, respectively, denoted as</p><formula xml:id="formula_1">Diff X = L(x + 1, y, σ) -L(x -1, y, σ), and Diff Y = L(x, y + 1, σ) - L(x, y -1, σ) along different directions.</formula><p>For each 4 × 4 block, the gradient magnitude and orientation are, respectively, computed for each position (x, y) within the block as: The magnitude and direction computations for the gradient are done for every pixel in a neighboring region around the keypoint in the Gaussian-blurred image. Note that this gradient vector can also be represented in other forms, besides magnitude and direction, while the accuracy of the SIFT algorithm can still remain largely unchanged. However, different representation forms may lead to different computational complexity in the ciphertext domain, which will be discussed in Sec 4.4. After the computations of the magnitude and direction, an orientation histogram with 36 bins is formed, with each bin covering 10 degrees. Each sample in the neighboring window added to a histogram bin is weighted by its gradient magnitude and a Gaussian-weighted circular window with a σ that is 1.5 times that of the keypoint's scale. The peaks in this histogram correspond to dominant orientations. Once the histogram is filled, the orientations corresponding to the highest peak and local peaks that are larger than 80% of the highest peaks are assigned to the keypoint.</p><formula xml:id="formula_2">m(x, y) = (Diff X ) 2 + (Diff Y ) 2 (2) θ(x, y) = tan -1 Diff X Diff Y<label>(3)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">PROBLEM FORMULATION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">System Architecture</head><p>As illustrated in Fig. <ref type="figure" target="#fig_1">2</ref>, we consider a high-level architecture of SecSIFT. At the core, the system consists of two parties: Client and Cloud. Client may represent either an individual or an enterprise customer, who owns private image data and aims to outsource the computation task on SIFT Feature Descriptors (FDs) over these images to cloud. Specifically, to keep sensitive image data confidential against unauthorized access, cryptographic techniques need to be applied to the image data before outsourcing. In our system, Client encrypts the image, denoted by plaintext matrix I, into a ciphertext matrix, denoted by C, and then uploads it to Cloud. The expected image processing results from Cloud are a set of SIFT descriptors, which are FD vectors of keypoints in the image obtained by the SIFT algorithm. Cloud consists of three entities: two Generators and a Comparer, which are independent cloud server providers. These entities are named according to the functionality they perform in SecSIFT:</p><p>• Generators: Generators are composed of two cloud entities (servers) that perform mirrored procedures over encrypted image. Thus, for simplicity, we consider them as one entity: It receives encrypted image from Client. And then it generates the scale-space and corresponding scale-space cubes (27 neighboring pixels from 3 scales). After that, it sends permuted scale-space cubes to Comparer, and receives the locations of keypoints from Comparer. Finally it outputs FD vectors as the results of SIFT algorithm to Client.</p><p>• Comparer: Comparer performs the comparison procedures, which is designed for performing the discovery of keypoints in SIFT algorithm. More specifically, this procedure is performed through a series of comparisons of neighboring pixels in the scale-space to find local extrema in the image. In our design, the output of Comparer is the cube identifier of the corresponding the keypoint, which is conducted to protect the privacy of the image against both Generator and Comparer at the same time (formally defined in Sec. 4.2.2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Security Model</head><p>We consider the image I owned by Client to be private. The clients' goal is to protect the privacy of the image content, while enabling Cloud to execute SIFT algorithm over it. Specifically, we consider the information of image content: pixel values, keypoint locations, and descriptive features extracted from the image, to be clients' private information.</p><p>In our security model, we consider the Cloud to be "honestbut-curious" and "independent". We assume that Cloud acts in an "honest but curious" fashion, which means it correctly follows the designated protocol specification, but is interested in inferring from or analyzes the data flow to learn additional information. In our design, Client uploads his/her image in a split form to multiple cloud entities, which carry out the computations regarding SIFT. Similar to the secure multiparty computation schemes, we assume the cloud entities to be "independent" to each other. This assumption is promised by the independent reputation and financial interests of the cloud server provider. Here, Generators and Comparer would explicitly state non-collusion in their legally binding documents. Thus, the independence among cloud entities can be assured in practice <ref type="bibr" target="#b8">[8]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Design Goals</head><p>Our ultimate goal is to design a privacy-preserving SIFT feature detection system that supports the outsourced image feature detection service, while providing the strongest possible protection on the image content privacy and simultaneously maintaining the efficiency. In particular, we have the following design goals:</p><p>Image Content Privacy: As claimed in our security model, the cloud entities should get no access to the image content like pixel values and detected features. According to the accepted security standard in image encryption <ref type="bibr" target="#b28">[28]</ref>, the confidentiality of the image is protected when each pixel of the image is encrypted. Consider an image as a matrix, if ev- ery element is protected (depending on different encryption scheme), the whole matrix, i.e., the image is protected. Following this methodology, we define the privacy of image data values to be the confidentiality of values. Moreover, in outsourced image local feature extraction like SIFT algorithm, the location of keypoints may also leak image content, e.g., the shape of objects in the image. As shown in Fig. <ref type="figure" target="#fig_3">4</ref>, though not considered in general image retrieval applications, intermediate result such as feature points along strong edges and their locations form crude object shapes, which reveal sensitive information of images. To solve this problem, we define the delocalization of keypoints: For each cloud entities, it is computationally hard to get the location of keypoints in the image, which means the keypoint's location of the image is protected against Cloud. The delocalization property can prevent the cloud entities deducing private content shapes from the images.</p><p>Computational Savings: Client's workload in SecSIFT should be substantially less than the workload of completing a local SIFT program.</p><p>Cloud Efficiency: It is further desirable to reduce the computational complexity on Cloud process as much as possible and finally make it acceptable when compared with a local SIFT program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">SecSIFT SYSTEM DESIGN</head><p>As shown in Fig. <ref type="figure" target="#fig_2">3</ref>, SecSIFT algorithm consists of five sequential components: Image Encryption, Scale-space Cube Generation, Keypoint Discovering, Descriptor Generation, and Descriptor Decryption. The detailed construction of each component will be shown in Sec. 4.1-4.5. Here, we first give a high-level description on the system workflow of SecSIFT.</p><p>At the beginning, Client takes an image and security parameters as the system inputs and passes the encrypted (split) image C and seedc to Generators and seed d to Comparer (Sec. 4.1). After receiving the ciphertext from Client, Generator generates the corresponding scale-space and cubes. Then it shuffles surrounding pixels and encrypts the cube through an OPE scheme and passes the encrypted cubes attached with corresponding identifiers to Comparer (Sec. 4.2). Comparer decrypts the received cubes from both Generators and locates the keypoints by discovering the cubes that include extrema. The corresponding identifiers attached to the keypoints are then sent back to two Generators, inserted with some dummy identifiers (Sec. 4.3). Generators locate the</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1 Splitting based Image Encryption Input:</head><p>The matrix of the image, I, security parameter κ; Output:</p><p>The ciphertext pair: C1 and C2; Control parameters s id , sp, and s d ; 1: Generate prime modulus t := Genprime(1 κ ), and matrix R ← P RG(1 κ ); 2: for each pixel at position (x, y) in I do 3:</p><p>Encrypt I(x, y) by splitting the value: C1(x, y) = R(x, y), C2(x, y) = (I -R(x, y)) mod q; 4: end for 5: Generate control parameters s id ← P RG id (1 κ ), sp ← P RGp(1 κ ), and s d ← P RG d (1 κ ); 6: return C1, C2, s id , sp, and s d . corresponding pixel points in the image after receiving those identifiers from Comparer, and then generate feature descriptors of keypoints over ciphertext domain and sends them back to Client (Sec. 4.4). Finally, Client discards the feature descriptors corresponding to the dummy identifiers, and then decrypts the rest of feature descriptors as the system output (Sec. 4.5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Client: Image Encryption</head><p>Before outsourcing an image to Cloud, Client needs to encrypt the image and generate a set of control parameters to control the privacy-preserving mechanisms on different cloud entities. Instead of encrypting each pixel of the image through a public key based homomorphic encryption scheme as in the existing works <ref type="bibr" target="#b25">[25,</ref><ref type="bibr" target="#b14">14]</ref>, Client additively splits the image matrix I into two ciphertext matrices: It first generates a prime modulus q, which defines the message space of the encryption scheme, and a random matrix R, whose elements are chosen from [0, q-1]. Then, it encrypts the image by splitting the matrix I into two matrices: C1 = R and C2 = (I -R) mod q and sends them to Generators, respectively: Client → Generator1 : C1; Client → Generator2 : C2. The details are illustrated in Alg. 1. After that, Client generates and sends control parameters s id , sp, and s d to Generators and Comparer: Client → Generators : (s id , sp); Client → Comparer : s d . Specifically, s id and sp synchronize the generation of scale-space cubes' identifiers and permutations on Generators (Sec. 4.2.2). And s d controls the generation of dummy identifiers on Comparer (Sec. 4.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Generator: Scale-space Cube Generation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Scale-space Generation</head><p>After receiving ciphertexts C1 and C2 from Client, both Generators perform convolutions and subtractions, as in the original SIFT algorithm, to generate scale-space. Specifically, for each pixel in the ciphertext matrix Ci, Generator performs the following computations to generate the DoG images at scale σ:</p><formula xml:id="formula_3">D(x, y, σ) = (G(x, y, kiσ) -G(x, y, kjσ)) * Ci(x, y) (4)</formula><p>where G(x, y, σ) = 1 2πσ 2 e -(x 2 +y 2 )/2σ 2 . The results of Gaussian function at different scales are a set of constant matrices, which are considered to be public information to all participants. Thus, the generation of these matrices can be performed by Generator over plaintext domain. Note that Generators work over encrypted images, which are split into two homologous ciphertexts. Therefore, both Generators must compute in the same operation order for each encrypted pixel to generate a homologous scale-space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Cube Encryption</head><p>After generating the scale-space, Cloud needs to discover keypoints as local extrema from the scale-space through comparisons. However, these comparisons cannot be performed by a cloud entity. It could leak the pixel values in the image, though the image is encrypted. If only one cloud entity performs all the tasks, it will lead to pixel value leakage to the cloud. Note that even if the cloud performs the comparisons in the ciphertext domain, it can still learn the values of encrypted pixels: The comparable ciphertexts enables Cloud to deduce the content of the image through comparing all encrypted pixel values in the image. To solve this problem, we assume the existence of three non-colluding cloud entities. Our scheme is designed in such a way that none of them alone can deduce any pixel value information by itself.</p><p>Comparer is introduced as a cloud server to discover keypoints through comparing neighboring pixels in scale-space. To better illustrate the balance between privacy and effectiveness of the proposed solution, we first analyze two naive solutions and their shortcomings:</p><p>• Cube Permutation: A naive solution is dividing the scale-space into multiple cubes, which contain 27 pixels acrossing 3 scales, and permutating these cubes randomly before sending them to Comparer. However, only permutation alone cannot break the space correlations of neighboring cubes completely. It is still computationally possible for Comparer to discover the space order of cubes through traversing all cubes and finding the overlapping pixels (18 pixels at maximum) among neighboring cubes.</p><p>• Noise Perturbation: Another naive solution is perturbing noises into pixels to hide the overlapping pixels in neighboring cubes. The perturbed noises make it computational impossible for Comparer to find overlapping pixels in neighboring cubes. However, the noise perturbation based solution may badly weaken the effectiveness of the system. Specifically, the precision of comparisons is compromised by noise perturbation. The reason is that the effectiveness on comparisons and the protection on ciphertexts inherently contradict to each other in noise perturbation mechanisms.</p><p>Based on the previous analysis on the possible solutions, we propose a novel solution to discover the keypoints in the scale-space without compromising the privacy of the image. In this solution, the OPE scheme proposed in <ref type="bibr" target="#b1">[1]</ref> is adopted to enable the ciphertext comparisons to be performed by Comparer. However, since the image data uploaded by Client is over ciphertext domain, we cannot directly use the scheme in <ref type="bibr" target="#b1">[1]</ref>. Thus, we need to carefully modify a piece-wise linear spline to enable Comparer to recover the split image from OPE ciphertexts. The complete construction is explained in the following:</p><p>Cube Encryption: As illustrated in the Cube Permutation, Generator first divides the scale-space into cubes, as shown in Fig. <ref type="figure" target="#fig_0">1</ref>. At the beginning, Generator encrypts all pixels in the processed image cubes through an OPE scheme, as shown in Alg. The split image cube Cubei; Ensure:</p><p>The encrypted split image cube Cubei; 1: for each pixel in Cubei do 2:</p><p>for predefined bucket j = 1... m do 3:</p><p>Generating a set of bucket [p l , p h ), with hl -1 points; 4:</p><p>end for 5:</p><p>if a distribution over [0, p h ) has the density function pq + r for constant q and r; then 6:</p><p>For any constant z &gt; 0; 7:</p><p>M(p) = z( q 2r p 2 + p); 8:</p><p>end if</p><formula xml:id="formula_4">9: At bucket width w, flat value f is f = fmin + i-1 j=1 w f j + Mi(p -pmin - i-1 j=1 wj); 10: Encrypted the pixel in split image Cubei := cmin + i-1 j=1 w c j + (M c i ) -1 (f -fmin - i-1 j=1</formula><p>w f j ), 11: end for 12: return Cubei; w t , we also get the mapping function M t and associated parameters s t and z t . Assume the maximum width for each bucket is K = max <ref type="bibr">[wi]</ref>. Note that f denotes flatten space, t denotes target stage, and c denotes cipher space:</p><formula xml:id="formula_5">M c (w c ) = z c (s c (w c ) 2 + w c ), z = K t n t s t (w t ) 2 + w t ;<label>( 5 )</label></formula><p>where s = q/2r. After that, we save the bucket boundaries in the cipher space in the data structure K c . For every bucket, we also save the quadratic coefficients s c and the scale factor z c . The scheme enables the split image recovery as follows: First, when computing the scale factors for each bucket by using the constraint. In this step, the bucket should map to a space proportional to the number of points in the bucket, in which the duplicate points are excluded. Thus, adjacent plaintext values in the regions will be mapped to flattened values that are relatively close. Suppose that using our modified scheme, a plaintext value p maps into a value f in the flat space, and p + 1 maps into f . When encrypting p, we choose the random value close to the interval's center [ f -f 2 ). Thus, the encrypted value of p will be uniformly spread in the interval [f, f ). Combining the intra-bucket uniformity generated by the linear splines, and the interbucket uniformity from the scale factors together results in the flattened distribution to be uniform. In addition, to identify the extent, the OPE scheme maintains distance between plaintexts, and we start from analyzing the distance of any two random plaintexts. The size of the ciphertext depends on the skew in the plaintext and target distributions. Assume g p min to be the smallest gap between sorted values in the plaintext. Similarly, we can define g p max , g t min , and g t max . Then, the additional number of bits needed by the ciphertext in the worst case is approximated as:</p><formula xml:id="formula_6">l add = log( g p max g p min ) + log( g t max g t min )<label>( 6 )</label></formula><p>Algorithm 3 Cube ID Perturbation Input:</p><p>The random number s id , the ID set of keypiont {ID}; Output:</p><p>The perturbed cube ID: { Ī D}; 1: Generating a binomial pseudorandom matrix M = P RGM (|I|, s id ); 2: for All (x, y) ∈ I do 3:</p><p>if M (x, y) &gt; 0 then 4:</p><p>Computing DID := H(s id , x, y); 5:</p><p>for each DID / ∈ {ID} 6:</p><p>{ Ī D} = {ID} ∪ {DID}; 7:</p><p>end if 8: end for 9: return { Ī D};.</p><p>Note that we can explicitly control g t , i.e., the length introduced by the target stage, while g p depends on the different format of the image data.</p><p>Permutation: After the encryption of OPE scheme, both Generators generate cube identifiers and permutate the cubes under a same set of control parameters. First, each Generator generates an identifier for each cube, denoted as CID. It generates it with the control parameter and corresponding position in the image matrix as the inputs: CID = H(s id , x, y). Recall that (x, y) is the position in the image matrix, and H is a predefined random hash function. Since both Generators use the same control parameter sid in identifier generation, the identifiers of the cubes at same positions can be synchronized. After that, Generators performs the permutation of cubes with the sp from Client, pixel position and scales as the inputs: Seq = Hp(sp, x, y, σ). For this procedure, sid from CID generation and sp from cube permutation guarantee the synchronization of operations in Generators.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Comparer: Keypoint Discovering</head><p>After receiving split image cubes Cube1 and Cube2 from Generators, Comparer recovers the encrypted cubes through additions: Cube = Cube1 + Cube2. Then, it identifies cubes that include extremum through comparing 26 pixels with the centre pixel in the cube. After that, to protect the location of keypoints against Generators, Comparer generates a set of dummy identifiers, i.e., DIDs, with the s d from Client. Then, it mixes them with CIDs connected with extrema, before sending them back to Generators, as shown in Alg. 3. The detailed privacy analysis of inserting DIDs will be shown in Sec. 5.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Generator: Descriptor Generation</head><p>Generators perform the adjusted feature descriptor generation procedures, after receiving the perturbed cube ID set { Ī D} from Comparer. As described in Sec. 2, SIFT derives the feature descriptor of keypoint from computing the magnitude and direction of its neighboring pixels in the plaintext domain. The orientation assignment is executed for each detected feature point. The histogram of weighted magnitudes, which are defined on a number of restrictive directions, is derived based on the Eq. (3). A normalized region of size 16 × 16, which is expanded from the region covering the derived orientation, is built. A 128-dimensional SIFT feature descriptor is established for the 16×16 region, which is further divided into sixteen 4 × 4 blocks, around a feature point.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 4 Descriptor Generation Input:</head><p>The perturbed cube ID set { Ī D}; Output:</p><p>The descriptor of keypoint V di ; 1: for Each Ī D ∈ { Ī D} do 2:</p><p>Compute the position of keypoint from the ID set: (x, y) = H -1 ( Ī D); 3:</p><p>for each surrounding block of keypoint do 4:</p><formula xml:id="formula_7">V (0) = V (0) + (L(x + 1, y, σ) -(L(x -1, y, σ); 5: V (1) = V (1) + (L(x, y + 1, σ) -(L(x, y -1, σ); 6: V (2) = V (2)+(L(x-1, y-1, σ)-(L(x+1, y+1, σ); 7: V (3) = V (3)+(L(x+1, y-1, σ)-(L(x-1, y+1, σ); 8:</formula><p>Concatenate region features together: <ref type="formula">1</ref>)||V ( <ref type="formula">2</ref>)||V ( <ref type="formula" target="#formula_2">3</ref>)); 9:</p><formula xml:id="formula_8">V d = (V d ||V (0)||V (</formula><p>end for 10: end for 11: return V di ;.</p><p>For feature descriptor extraction conducted over ciphertext domain, the histogram and vector computations require high computational complexity and are too complicated to be implemented over ciphertext domain. Thus, we modify the original descriptor to generate the weighted magnitudes located at four directions (i.e., 0 • , 45 • , 90 • , and 135 • ) in the proposed system, which constitutes a 4-dimensional vector, as shown in Fig. <ref type="figure" target="#fig_5">5</ref>. Since a 16 × 16 region contains sixteen 4 × 4 blocks, a 64-dimensional feature descriptor for a keypoint is established. Due to the security constraint on comparisons, no additional information of encrypted feature descriptor can be extracted from the ciphertext domain by Generators. Our experimental results reveal that modified SecSIFT descriptors successfully maintain the robustness of the proposed system, as illustrated in Fig. <ref type="figure" target="#fig_7">6(b)</ref>.</p><p>In our design, the feature descriptor calculated in the ciphertext domain for each 4 × 4 block is conducted as follows: Let V (k), k = {0, 1, 2, 3, } denote the feature vector of a 16 × 16 block:</p><formula xml:id="formula_9">Diff 0 • = (L(x + 1, y, σ) -(L(x -1, y, σ) Diff 90 • = (L(x, y + 1, σ) -(L(x, y -1, σ) Diff 45 • = (L(x -1, y -1, σ) -(L(x + 1, y + 1, σ) Diff 135 • = (L(x + 1, y -1, σ) -(L(x -1, y + 1, σ) (7)</formula><p>As shown in Alg. 4, each Generator generates a descriptor as split 64-dimensional vector V d . Then, it sends V d attached with the CID to Client. Note that the descriptors of keypoints include vectors of dummy points. To protect the privacy of location of the keypoints, Generator is designed to perform the descriptor generation of these dummy points. The corresponding computation complexity depends on the number of inserted dummy points from the security parameter settings. However, these dummy points do not affect the decryption workload on Client end. Client can distinguish the dummy descriptors from the real descriptors by simulating Comparer to generate {DID}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Descriptor Decryption</head><p>Before recovering the encrypted descriptor (feature vector) by subtracting the split feature descriptors: V d = V d2 -V d1 , Client needs to identify and discard the dummy feature descriptors. Recall that DIDs are computed from the pseudorandom matrix M , which only depends on the size of the image and the control parameter s id . Thus, Client can ef-  ficiently regenerate the dummy matrix M and discard the descriptors with the corresponding DIDs.</p><p>After recovering the feature vectors, Client can perform the orientation calculation to get the assigned orientations and convert the feature vectors of each block to the main orientation as the original SIFT. The effectiveness of adjusted descriptors will be discussed in Sec. 5.1. From the client's perspective, the encryption and decryption computational complexity are both linear to the size of the image. The communication complexity between Cloud and Client contains the upload bandwidth (2|I|) and the download bandwidth (|F D|), which depend on the size and content of the image.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">SYSTEM EVALUATION</head><p>We conduct a thorough experimental evaluation of the proposed system on real image database: Caltech256, which contains 30,607 images with total size 1.2GB. Our experiment is implemented using C programming language on both local workstation and Microsoft Azure cloud instance. The local workstation runs with an Intel Core2 Duo CPU (E6550) running at 2.33GHz, 4GB of RAM and a 7200RPM disk drive. The cloud side process is conducted on Azure with large standard instance type. We analyze and present our evaluation result in three aspects: correctness, privacy, and efficiency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Correctness Analysis and Evaluation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1">Correctness of Feature Descriptors</head><p>Since neighboring input value must have similar output ciphertext under order preserving encryption, the proposed algorithm may not return the exact answers. In the scenario of SIFT algorithm, SecSIFT algorithm should output a noisy list of keypoint at Comparer. Recall that given a plaintext space of size M , i.e., the domain size |D| = M , and ciphertext space N , assuming m1 &lt; m2 ∈ [M ]. The following theorem provides the utility guarantee of SecSIFT: Theorem 1. Let t = (N -1)/(M -1), and assume t &gt; 7.</p><formula xml:id="formula_10">Let m1 ← [M ], m2 ← [M ]{m1}, (c1, c2) = Enc r,k (m1, m2), w = c2 -c1 mod M , and d = m2 -m1 mod M . Then P rm 1 ,m 2 [2d &gt; w] &lt; 3 t 1 (M -1)/lnM<label>(8)</label></formula><p>Proof. Let t = (N -1)(M -1). Let b be a fixed value (less than √ M -1) to be determined later. Define  Define dR = min{(M -1)w/N + b(M -1)/ √ M -1, M -1}. Note that (M -1)w/N is the most likely plaintext distance of w. Then we can deduce that dR &lt; w/2, whenever w &gt; β+1. Hence</p><formula xml:id="formula_11">β = 2tb √ M -1 t-2 . Assume w is uniformly random in [N -1], so P rm 1 ,m 2 [w &lt; β + 1] &lt; β + 1 N -1<label>(9)</label></formula><formula xml:id="formula_12">P rm 1 ,m 2 [2d &gt; w] &lt; P rm 1 ,m 2 [2d &gt; w|w &gt; β + 1] +P rm 1 ,m 2 [|w &lt; β + 1] &lt; 2/M + 2b (t -2) √ M -1 + 1 N -1 &lt; 2/M + 2 t -2 1 (M -1)/lnM (<label>10</label></formula><formula xml:id="formula_13">)</formula><p>assuming t &gt; 7. This bound gives us the idea of good values for t = N/M . In particular, we can find that choosing a constant for t &gt; 7, which means choosing N to be a constant multiple of M , is sufficient in order to make the above probability negligible. Whether the constant should be large or small depends on the tolerance for random intervals to be shallow. The upper bound of noise introduced by the OPE scheme to the image value is 3 t ln (1/M ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2">Experimental Results</head><p>We first analyze the correctness of the proposed system from the view of keypoint localizations. We conduct the experiments regarding comparison between keypoints detected from the plaintext domain and the ones from the ciphertext domain in SecSIFT. The Euclidean distances between the closest keypoints from different domains are computed: The keypoints from SecSIFT and original SIFT are obtained respectively. After that, the corresponding keypoints in SecSIFT based on the ones from original SIFT are discovered. The standard Euclidean Distance is utilized to quantify these distances. Fig. <ref type="figure" target="#fig_7">6</ref>(a) illustrates the average error distance between corresponding keypoints. The error is introduced by the randomness from the OPE scheme. In fact the maximum distance between corresponding keypoints from different domains is smaller than 3.56, which means they still have more than 63% overlapping neighboring pixels.</p><p>Given the descriptor generated by SecSIFT, we next focus on the precision of the matching results. Basically, the experiments are analogous to the application of image matching. We randomly select 1, 000 images from 10 categories, and perform original SIFT, SIFT with modified descriptors and SecSIFT to extract their feature descriptors. Then these descriptors are utilized to compute their Euclidean distance to find the corresponding matching image in the image set. The results regarding the top-k matching images are examined here. As shown in Fig. <ref type="figure" target="#fig_9">7</ref>, the left column images are the query (target) image, and the right column images are the top-k (k=4) matching images in the database.  with modified descriptors and SecSIFT, compared with the original SIFT as the ground truth. When k = 1, the precision is above 99%. The matching results are almost the same. When k &gt; 2, the precision of the proposed system reduces, but still remains above 80% on average.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Privacy Analysis and Evaluation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">Confidentiality of Pixel Values &amp; Descriptive Feature Vectors</head><p>To analyze the confidentiality of the image content, we start with the observed data by each cloud entity. For Generator, it can only observe the encrypted (split) image and the cube identifier CID returned by Comparer. The image splitting mechanism provides the security guarantee of image content against Generator, as long as the client generate a new key every time to encrypt the image. The security strength of the ciphertext depends on the security of the utilized pseudorandom generator function. The information leakage from CID like the location of the keypoints to Generator will be analyzed in Sec. 5.2.2.</p><p>For Comparer, though the OPE scheme leaks the order of the ciphertext, the information disclosed to Comparer contains only the statistical information <ref type="bibr" target="#b31">[31]</ref> (e.g., the counts of different pixel values) over ciphertexts in the scale-space domain. The confidentiality of the image values relies on the security strength of the OPE scheme. Recall that the security of the image content against Comparer is quantified by the domain size |D| = M . Assume for any challenge set size z, there exists an efficient adversary A as a curious Comparer, and we have the following theorem: Theorem 2. For any z and A, if N &gt; 2M , M &gt; 16 + z, such that:</p><formula xml:id="formula_14">Adv z [M ],[N ] (A) &lt; 4z √ M -z + 1<label>(11)</label></formula><p>Proof. Let N &gt; M, 0 &lt; y &lt; N, 0 &lt; x &lt; M. Recall hypergeometric and negative hypergeometric probabilities:</p><formula xml:id="formula_15">P hgd (N, M, y, x) &lt; ( y x )( N -y M -x ) ( N M ) P nhgd (N, M, y, x) &lt; ( y-1 x-1 )( N -y M -x ) ( N M )<label>(12)</label></formula><p>As shown in <ref type="bibr" target="#b6">[6]</ref>, random OPE are naturally linked to negative hypergeometric probabilities. This allows us to construct an efficient adversary against OPE scheme, which yields the result that:  where the security experiment is as follows: The experiment Exp z</p><formula xml:id="formula_16">Adv z [M ],[N ] (A) &lt; P r[Exp z [M ],[N ] (A) = 1]<label>(13)</label></formula><p>[M ],[N ] (A) is performed by the adversary. It returns 1, if (mR -mL + 1 mod M ) &lt; r, while m0 ∈ [mL, mR], and returns 0 otherwise. Note that the experiment demands that the adversary returns the specified ciphertext that c0 ∈ c, rather than any ciphertext from ciphertext set c. Thus we can use the simple bound deduced from Eq. 12 and 13:</p><formula xml:id="formula_17">P r[Exp z [M ],[N ] (A) = 1] = 4z √ M -z + 1 (14)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">Delocalization of Keypoint Locations</head><p>Since Comparer is enabled to read the encrypted pixels in scale cubes for comparisons, Comparer can only attack the system through reconstructing the image from cubes, which means reconstructing the relative location relations among pixels. The permutation algorithm is utilized in our design to protect the locations of keypoints against Comparer. In this case, the permutation of surrounding pixels in a scale cube can effectively sabotage the reconstruction algorithm. For neighboring cubes, the maximum number of overlapping pixels is 18. Assume each cube has 6 directions to discover its neighboring cube. The maximum number of overlapping pixels for two neighboring directions is 12. Through probability deduction, we can discover that the permutation algorithm can decrease the probability of discovering the correct neighboring cubes to be one out of six, which is 16.6%. Assume the size of the image is n, then the possibility of reconstruct the half of the image is approximately 2 3n .</p><p>For Generators, the dummy points are inserted into the returned cube identifiers to hide the keypoints locations in the image. Due to the functionality requirements in SIFT, the locations of real keypoints must be revealed to Generators for generating descriptors. However, the dummy keypoints observed by Generators can effectively prevent it distinguishing the location of real keypoints. The experiment Exp |r|,|d| (A) for adversary A, which has |r| real keypoints and |d| dummy points, is described as follows: It returns 1, if A choose a real keypoint from the mixed keypoints group, and returns 0 otherwise. Thus we can get a simple bound:</p><formula xml:id="formula_18">P r[Exp z |r|,|d| (A) = 1] = |r| |r| + |d| (15)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.3">Experimental Results</head><p>We conduct the experiments regarding computation time of OPE procedure and additional descriptor generation time for dummy points to test the additional computation complexity introduced by privacy-preserving mechanisms. Fig. <ref type="figure" target="#fig_11">8</ref> Comparer 7 % Client 1.72%  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Workload Distribution</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Efficiency Evaluation</head><p>In order to evaluate the efficiency of the proposed system, the experiments are conducted regarding the time cost of data preprocessing phase and image feature detection phase. Fig. <ref type="figure" target="#fig_12">9</ref> shows the computational complexity on the different entities in SecSIFT for an image with size of 300 × 300. The result shows that the Client takes a minimum computational complexity, since most of the workloads, like scale-space generation and extreme discovering, are taken by Generators and Comparer. As shown in Fig. <ref type="figure" target="#fig_14">10</ref>, the time complexity of the proposed system remains to be fully practical, i.e., about the order of seconds. Meanwhile, the homomorphic encryption based scheme requires time complexity at the order of minutes <ref type="bibr" target="#b12">[12]</ref> under the same security parameters. The reason is that the public key based homomorphic encryption schemes require massive multiplications and exponentials over ciphertext domain as the homomorphic additions and multiplications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RELATED WORK</head><p>This outsourced privacy-preserving SIFT is proposed to explore the prospects of private image computation outsourcing, inspired by works <ref type="bibr" target="#b19">[19]</ref>, <ref type="bibr" target="#b14">[14]</ref>, <ref type="bibr" target="#b18">[18]</ref>, <ref type="bibr" target="#b21">[21]</ref>. In secure multimedia data search <ref type="bibr" target="#b26">[26]</ref>, the authors propose a design to protect the privacy of the query image when searching over a public non-encrypted database. In <ref type="bibr" target="#b19">[19]</ref>, features extracted from images are encrypted in a distance-preserving scheme to enable the direct comparisons for similarity evaluation. Secure image retrieval allows content-based search over encrypted multimedia databases, and therefore offers flexible approaches to manage private multimedia collections online <ref type="bibr" target="#b15">[15]</ref>. In <ref type="bibr" target="#b18">[18]</ref>, the state-of-the-art search indexes for multimedia data are encrypted while the efficient search capabilities are preserved. In <ref type="bibr">[9]</ref>, authors analyze the security flaws of the typical technology blocks used in state-of-theart content-based image retrieval system. Most of existing works are interested in the manipulation of encrypted image data: A privacy-preserving face recognition system, based on Paillier cryptosystem, is proposed by Erkin <ref type="bibr" target="#b10">[10]</ref>. Bianchi <ref type="bibr" target="#b5">[5]</ref> generalizes the packing encryption technique proposed by Troncoso-Pastoriza <ref type="bibr" target="#b27">[27]</ref>. By utilizing the garbled circuit and homomorphic encryption scheme, <ref type="bibr" target="#b25">[25]</ref> and <ref type="bibr" target="#b23">[23]</ref> propose privacy-preserving face recognition systems. The privacy-preserving classification of ECG signal and privacypreserving fingercode authentication system are presented in <ref type="bibr" target="#b4">[4]</ref> and <ref type="bibr" target="#b3">[3]</ref> by Barni. Another orthogonal work <ref type="bibr" target="#b22">[22]</ref> proposes a privacy-preserving identical image copies searching system based on the signs of DCT image coefficient. In <ref type="bibr" target="#b7">[7]</ref>, the utilization of secure multiparty computation techniques is proposed in a biometric identification system. The most similar work to this paper is Hsu's work <ref type="bibr" target="#b12">[12]</ref>, which utilizes homomorphic encryption scheme (Paillier) to enable a secure SIFT computation over the ciphertext. However, the proposed scheme has two drawbacks: 1) It introduces unrealistic computational complexity on encrypted data comparison. The proposed algorithm requires the cloud to traverse half of the ciphertext space for each comparison. Assuming a 512-bit modulus of the Paillier cryptosystem, the cloud needs to perform 2 256 multiplications (homomorphic additions) for each ciphertext comparison. 2) The data owner needs to encrypt and decrypt each pixel in the image under Paillier scheme. It is an unpractical workload to the data owner, especially compared with the splitting based encryption scheme in our system (0.02-0.5s/pixel vs. 0.04-0.08μs/pixel). Another work <ref type="bibr" target="#b29">[29]</ref> demonstrates that shapebased image feature extraction can be carried out within ciphertext domain in a multiple cloud server structure.</p><p>Based on Yao's garbled circuits <ref type="bibr" target="#b30">[30]</ref> and Gentry's work on fully homomorphic encryption (FHE) <ref type="bibr" target="#b11">[11]</ref>, a general solution has been shown to allow homomorphic evaluations over ciphertext domain. However, applying these general mechanisms to our image computation application would be far from practical, due to its extremely large size of the circuit that cannot be handled in practice and the huge computation complexity of FHE operations. Another existing list of work that loosely relates to (but is also significantly different from) our research proposal is secure multiparty computation (SMC) <ref type="bibr" target="#b30">[30]</ref>. However, schemes in the context of SMC are in general ill-suited when applied to practical system models, as they usually assume no single party knows all the problem input and impose comparable computation burden on each involved parties <ref type="bibr" target="#b24">[24]</ref>. In short, practically efficient mechanisms with immediate practices for private image computation outsourcing in cloud are still missing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSION</head><p>In this paper, we proposed a privacy-preserving SIFT system over encrypted image data. The proposed system explores the techniques of splitting based encryption, orderpreserving encryption, random permutation, and dummy points perturbation to enable secure image computation outsourcing with practical performance. The correctness, privacy, and efficiency of the proposed system were analyzed and evaluated. We further constructed a prototype system SecSIFT and conducted extensive experiments. The experimental results show that the proposed system is correct and effective for different image categories in Caltech256 image database. As our ongoing work, we will continue to research on privacy-preserving image detection algorithms for the effective utilization over encrypted data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">ACKNOWLEDGEMENT</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Scale-space Extrema Detection: The image forms a series of octave via convolutions and subtractions [17].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: System Architecture: Three independent entities (cloud servers) ensure the privacy of image is preserved in SecSIFT.</figDesc><graphic coords="3,129.83,62.33,149.58,82.46" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Architecture and Workflow of SecSIFT.</figDesc><graphic coords="3,476.63,74.81,69.20,87.86" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: SIFT features (intermediate) in plaintext domain (a), (b), (c) and ciphertext domain (d), (e), (f ).ery element is protected (depending on different encryption scheme), the whole matrix, i.e., the image is protected. Following this methodology, we define the privacy of image data values to be the confidentiality of values. Moreover, in outsourced image local feature extraction like SIFT algorithm, the location of keypoints may also leak image content, e.g., the shape of objects in the image. As shown in Fig.4, though not considered in general image retrieval applications, intermediate result such as feature points along strong edges and their locations form crude object shapes, which reveal sensitive information of images. To solve this problem, we define the delocalization of keypoints: For each cloud entities, it is computationally hard to get the location of keypoints in the image, which means the keypoint's location of the image is protected against Cloud. The delocalization property can prevent the cloud entities deducing private content shapes from the images.Computational Savings: Client's workload in SecSIFT should be substantially less than the workload of completing a local SIFT program.Cloud Efficiency: It is further desirable to reduce the computational complexity on Cloud process as much as possible and finally make it acceptable when compared with a local SIFT program.</figDesc><graphic coords="4,136.91,129.17,60.87,60.62" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Original SIFT feature gradient vector (a) and modified feature descriptor (b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Correctness Evaluation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>Fig. 6(b) illustrates the result of image matching performed over SIFT Target Image Top-4 Matching Image</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: An example of image matching using SecSIFT.with modified descriptors and SecSIFT, compared with the original SIFT as the ground truth. When k = 1, the precision is above 99%. The matching results are almost the same. When k &gt; 2, the precision of the proposed system reduces, but still remains above 80% on average.</figDesc><graphic coords="8,99.83,61.97,145.87,117.50" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 8 :</head><label>8</label><figDesc>Privacy Evaluation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: The workload distribution of SecSIFT.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>(a), (b) show the results. As the strength of the strength of the confidentiality and delocalization property grows, the additional time complexity increases: The time complexity of one OPE encryption procedure grows, as the domain size |D| of OPE increases (from 20 to 30 bits). In Fig.8(b), we conduct the experiments of the additional computational time of descriptor generation procedures for different scales of dummy point insertion. Regarding the growth additional time complexity of descriptor generation, the probability of distinguishing the dummy points from the mixed descriptors decreases.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: The computation time of SecSIFT on different size of images.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>2. The modeling of target distribution yields a set of buckets {B t</figDesc><table /><note><p>1 , ..., B t k }. For every bucket of length Algorithm 2 OPE based Cube Encryption Require:</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We thank the helpful comments from the anonymous reviewers and Mohan S. Kankanhalli for shepherding our paper. This work was supported in part by US National Science Foundation under grants CNS-1262277 and CNS-1262275, and by RGC of Hong Kong under the ECS grant 9041983.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Order preserving encryption for numeric data</title>
		<author>
			<persName><forename type="first">R</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kiernan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Srikant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM SIGMOD</title>
		<meeting>of ACM SIGMOD</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Secure outsourcing of scientific computations</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Atallah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">N</forename><surname>Pantazopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Rice</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">E</forename><surname>Spafford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Advances in Computers</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="page" from="215" to="272" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Privacy-preserving fingercode authentication</title>
		<author>
			<persName><forename type="first">M</forename><surname>Barni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Bianchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Catalano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Di Raimondo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM MMSec</title>
		<meeting>of ACM MMSec</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Privacy-preserving ecg classification with branching programs and neural networks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Barni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Failla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lazzeretti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sadeghi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TIFS</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="452" to="468" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Composite signal representation for fast and storage-efficient processing of encrypted signals</title>
		<author>
			<persName><forename type="first">T</forename><surname>Bianchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Piva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Barni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TIFS</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="180" to="187" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Order-preserving symmetric encryption</title>
		<author>
			<persName><forename type="first">A</forename><surname>Boldyreva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Chenette</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Oneill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of EUROCRYPT</title>
		<meeting>of EUROCRYPT</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Privacy-preserving biometric identification using secure multiparty computation: An overview and recent trends</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bringer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Chabanne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Patey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Signal Processing Magazine</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Splitx: high-performance private analytics</title>
		<author>
			<persName><forename type="first">R</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">E</forename><surname>Akkus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Francis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM SIGCOMM</title>
		<meeting>of ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Challenging the security of content-based image retrieval systems</title>
		<author>
			<persName><forename type="first">T.-T</forename><surname>Do</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kijak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Furon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Amsaleg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE MMSP</title>
		<meeting>of IEEE MMSP</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Privacy-preserving face recognition</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Erkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Franz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Guajardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Katzenbeisser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Lagendijk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Toft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of PET</title>
		<meeting>of PET</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">A fully homomorphic encryption scheme</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
		<respStmt>
			<orgName>Stanford University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Image feature extraction in encrypted domain with privacy-preserving sift</title>
		<author>
			<persName><forename type="first">C.-Y</forename><surname>Hsu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-C</forename><surname>Pei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Image Processing</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="4593" to="4607" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Secure and robust sift</title>
		<author>
			<persName><forename type="first">C.-Y</forename><surname>Hsu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-C</forename><surname>Pei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM MM</title>
		<meeting>of ACM MM</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Homomorphic encryption-based secure sift for privacy-preserving feature extraction</title>
		<author>
			<persName><forename type="first">C.-Y</forename><surname>Hsu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-C</forename><surname>Pei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc of IEEE SPIE</title>
		<meeting>of IEEE SPIE</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Pca-sift: A more distinctive representation for local image descriptors</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sukthankar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE CVPR</title>
		<meeting>of IEEE CVPR</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Why johnny can&apos;t opt out: A usability evaluation of tools to limit online behavioral advertising</title>
		<author>
			<persName><forename type="first">P</forename><surname>Leon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Ur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Shay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Balebako</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Cranor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM SIGCHI</title>
		<meeting>of ACM SIGCHI</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Distinctive image features from scale-invariant keypoints</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">G</forename><surname>Lowe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International journal of computer vision</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="31" to="110" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Enabling search over encrypted multimedia databases</title>
		<author>
			<persName><forename type="first">W</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Swaminathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Varna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE SPIE</title>
		<meeting>of IEEE SPIE</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Secure image retrieval through feature protection</title>
		<author>
			<persName><forename type="first">W</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Varna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Swaminathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE ICASSP</title>
		<meeting>of IEEE ICASSP</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Too close for comfort: A study of the effectiveness and acceptability of rich-media personalized advertising</title>
		<author>
			<persName><forename type="first">M</forename><surname>Malheiros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Jennett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Patel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Brostoff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Sasse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM SIGCHI</title>
		<meeting>of ACM SIGCHI</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Illumination invariant representation for privacy preserving face identification</title>
		<author>
			<persName><forename type="first">B</forename><surname>Moskovich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Osadchy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE CVPRW</title>
		<meeting>of IEEE CVPRW</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Privacy-preserving function computation by exploitation of friendships in social networks</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">Movahedi</forename><surname>Naini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Thiran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vetterli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Unnikrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE ICASSP</title>
		<meeting>of IEEE ICASSP</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Scifi-a system for secure face identification</title>
		<author>
			<persName><forename type="first">M</forename><surname>Osadchy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jarrous</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Moskovich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE S&amp;P</title>
		<meeting>of IEEE S&amp;P</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Comparative evaluation of elliptic curve cryptography based homomorphic encryption schemes for a novel secure multiparty computation</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Patel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Chouhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Jinwala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Information Security</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="12" to="18" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Efficient privacy-preserving face recognition</title>
		<author>
			<persName><forename type="first">A.-R</forename><surname>Sadeghi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Wehrenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ICISC</title>
		<meeting>of ICISC</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Private content based image retrieval</title>
		<author>
			<persName><forename type="first">J</forename><surname>Shashank</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kowshik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Srinathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Jawahar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE CVPR</title>
		<meeting>of IEEE CVPR</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A secure multidimensional point inclusion protocol</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Troncoso-Pastoriza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Katzenbeisser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Celik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lemma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM MMSec</title>
		<meeting>of ACM MMSec</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A new chaos-based fast image encryption algorithm</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K.-W</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Liao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Applied soft computing</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="514" to="522" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Secure and private outsourcing of shape-based feature extraction</title>
		<author>
			<persName><forename type="first">S</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Nassar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Atallah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Malluhi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ICISC</title>
		<meeting>of ICISC</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Protocols for secure computations</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename></persName>
		</author>
		<author>
			<persName><forename type="first">-C</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE FOCS</title>
		<meeting>of IEEE FOCS</meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Privacy-preserving Outsourcing of Image Global Feature Detection</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Fu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Globecom</title>
		<meeting>of IEEE Globecom</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Enabling Privacy-preserving Image-centric Social Discovery</title>
		<author>
			<persName><forename type="first">X</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Squicciarini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE ICDCS</title>
		<meeting>of IEEE ICDCS</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
