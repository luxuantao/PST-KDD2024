<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">RockSalt: Better, Faster, Stronger SFI for the x86</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Greg</forename><surname>Morrisett</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Joseph</forename><surname>Tassarotti</surname></persName>
							<email>tassarotti@college.harvard.edu</email>
						</author>
						<author>
							<persName><forename type="first">Jean-Baptiste</forename><surname>Tristan</surname></persName>
							<email>tristan@seas.harvard.edu</email>
						</author>
						<author>
							<persName><forename type="first">Edward</forename><surname>Gan</surname></persName>
							<email>gtan@cse.lehigh.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Harvard University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Lehigh University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Harvard University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">Harvard University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution">Harvard University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">RockSalt: Better, Faster, Stronger SFI for the x86</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">1CEF5FD0063F67C4A4B23C185D901361</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.2.4 [Software Engineering]: Software/Program Verification General Terms security</term>
					<term>verification software fault isolation</term>
					<term>domain-specific languages Inductive grammar : Type → Type | Char: char → grammar char | Any: grammar char | Eps: grammar unit | Cat:∀T1 T2</term>
					<term>grammar T1 → grammar T2 → grammar (T1*T2) | Void: ∀T</term>
					<term>grammar T | Alt: ∀T</term>
					<term>grammar T → grammar T → grammar T | Star: ∀T</term>
					<term>grammar T → grammar (list T) | Map: ∀T1 T2</term>
					<term>(T1 → T2) → grammar T1 → grammar T2</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Software-based fault isolation (SFI), as used in Google's Native Client (NaCl), relies upon a conceptually simple machine-code analysis to enforce a security policy. But for complicated architectures such as the x86, it is all too easy to get the details of the analysis wrong. We have built a new checker that is smaller, faster, and has a much reduced trusted computing base when compared to Google's original analysis. The key to our approach is automatically generating the bulk of the analysis from a declarative description which we relate to a formal model of a subset of the x86 instruction set architecture. The x86 model, developed in Coq, is of independent interest and should be usable for a wide range of machine-level verification tasks.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Native Client (NaCl) is a new service provided by Google's Chrome browser that allows native executable code to be run directly in the context of the browser <ref type="bibr" target="#b45">[35]</ref>. To prevent buggy or malicious code from corrupting the browser's state, leaking information, or directly accessing system resources, the NaCl loader checks that the binary code respects a sandbox security policy. The sandbox policy is meant to ensure that, when loaded and executed, the untrusted code (a) will only read or write data in specified segments of memory, (b) will only execute code from a specified segment of memory, disjoint from the data segments, (c) will not execute a specific class of instructions (e.g., system calls), and (d) will only communicate with the browser through a well-defined set of entry points.</p><p>Ensuring the correctness of the NaCl checker is crucial for preventing vulnerabilities, yet early versions had bugs that attackers could exploit, as demonstrated by a contest that Google ran <ref type="bibr">[23]</ref>. A high-level goal of this work is to produce a high-assurance checker for the NaCl sandbox policy. Thus far, we have managed to construct a new NaCl checker for the 32-bit x86 (IA-32) processor (minus floating-point) which we call RockSalt. The RockSalt checker is smaller, marginally faster, and easier to modify than Google's original code. Furthermore, the core of RockSalt is automatically generated from a higher-level specification, and this generator has been proven correct with respect to a model of the x86 using the Coq proof assistant <ref type="bibr">[8]</ref>.</p><p>We are not the first to address assurance for SFI using formal methods. In particular, Zhao et al. <ref type="bibr" target="#b46">[36]</ref> built a provably correct verifier for a sandbox policy similar to NaCl's. Specifically, building upon a model of the ARM processor in HOL <ref type="bibr" target="#b21">[11]</ref>, they constructed a program logic and a provably correct verification condition generator, which when coupled with an abstract interpretation, generates proofs that assembly code respects the policy.</p><p>Our work has two key differences: First, there is no formal model for the subset of x86 that NaCl supports. Consequently, we have constructed a new model for the x86 in Coq. We believe that this model is an important contribution of our work, as it can be used to validate reasoning about the behavior of x86 machine code in other contexts (e.g., for verified compilers).</p><p>Second, Zhao et al.'s approach takes about 2.5 hours to check a 300 instruction program, whereas RockSalt checks roughly 1M instructions per second. Instead of a general-purpose theorem prover, RockSalt only relies upon a set of tables that encode a deterministic finite-state automaton (DFA) and a few tens of lines of (trusted) C code. Consequently, the checker is extremely fast, has a much smaller run-time trusted computing base, and can be easily integrated into the NaCl runtime.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Overview</head><p>This paper has two major parts: the first part describes our model of the x86 in Coq and the second describes the RockSalt NaCl checker and its proof of correctness with respect to the model. The x86 architecture is notoriously complicated, and our fragment includes a parser for over 130 different instructions with se-mantic definitions for over 70 instructions <ref type="foot" target="#foot_0">1</ref> . This includes support for operands that include byte and word immediates, registers, and complicated addressing modes (e.g., scaled index plus offset). Furthermore, the x86 allows prefix bytes, such as operand size override, locking, and string repeat, that can be combined in many different ways to change the behavior of an instruction. Finally, the instruction set architecture is so complex, that it is unlikely that we can produce a faithful model from documentation, so we must be able to validate our model against implementations.</p><p>To address these issues, we have constructed a pair of domainspecific languages (DSLs), inspired by the work on SLED <ref type="bibr" target="#b38">[28]</ref> and λ-RTL <ref type="bibr" target="#b37">[27]</ref> (as well as more recent work <ref type="bibr" target="#b20">[10,</ref><ref type="bibr">17]</ref>), for specifying the semantics of machine architectures, and have embedded those languages within Coq. Our DSLs are declarative and reasonably high-level, yet we can use them to generate OCaml code that can be run as a simulator. Furthermore, the tools are architecture independent and can thus be re-used to specify the semantics of other machine architectures. For example, one of the undergraduate co-authors constructed a model of the MIPS architecture using our DSLs in just a few days.</p><p>The Decoder DSL provides support for specifying the translation from bits to abstract syntax in a declarative fashion. We were able to take the tables from Intel's manual <ref type="bibr">[12]</ref> and use them to directly construct patterns for our decoder. Our embedding of the Decoder DSL includes both a denotational and operational semantics, and a proof of adequacy for the two interpretations. We use the denotational semantics for proving important properties about the decode stage of execution, and the operational semantics for execution validation.</p><p>The RTL (register transfer list) DSL is a small RISC-like core language parameterized by a notion of machine state. The RTL library includes an executable, small-step operational semantics. Each step in the semantics is specified as a (pure) function from machine states to machine states. We give meaning to x86 instructions by translating their abstract syntax to appropriate sequences of RTL instructions, similar to the way that a modern processor works. Reasoning about RTL is much easier than x86 code, as the number of instructions is smaller and orthogonal.</p><p>In what follows, we describe our DSLs and how they were used to construct the x86 model. We also describe our framework for validating the model against existing x86 implementations. We then describe the NaCl sandbox policy in detail, and the new RockSalt checker we have built to enforce it. Next, we describe the actual verification code and the proof of correctness. Finally, we close with a discussion of related work, future directions, and lessons learned.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">A Coq Model of the x86</head><p>Our Coq model of the x86 instruction set architecture has three major stages: (1) a decoder that translates bytes into abstract syntax for instructions, (2) a compiler that translates abstract syntax into sequences of RTL instructions, (3) an interpreter for RTL instructions. The interface between the first two components is the definition of the abstract syntax, which is specified using a set of inductive datatype definitions that are informally sketched in Figure <ref type="figure">1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">The Decoder Specification</head><p>The job of the x86 model's decoder is to translate bytes into abstract syntax. We specify the translation using generic grammars constructed in a domain-specific language, which is embedded into</p><formula xml:id="formula_0">Register reg ::= EAX | ECX | EDX | • • • Segment Reg. sreg ::= ES | CS | SS | • • • Scale scale ::= 1 | 2 | 4 | 8 Operand op ::= int32 | reg int32 × option reg × option(scale × reg) Instruction i ::= AAA | AAD | AAM | AAS | ADC(bool × op1 × op2) | ADD(bool × op1 × op2) | AND(bool × op1 × op2) | • • • Figure 1</formula><p>. Some Definitions for the x86 Abstract Syntax</p><p>Definition CALL_p : grammar instr := "1110" $$ "1000" $$ word @ (fun w =&gt; CALL true false (Imm_op w) None) || "1111" $$ "1111" $$ ext_op_modrm2 "010" @ (fun op =&gt; CALL true true op None) || "1001" $$ "1010" $$ halfword $ word @ (fun p =&gt; CALL false false (Imm_op (snd p)) (Some (fst p))) || "1111" $$ "1111" $$ ext_op_modrm2 "011" @ (fun op =&gt; CALL false true op None).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 2. Parsing Specification for the CALL instruction</head><p>Coq. The language lets users specify a pattern and associated semantic actions for transforming input strings to outputs such as abstract syntax. Our pattern language is limited to regular expressions, but the semantic actions are arbitrary Coq functions. Figure <ref type="figure">2</ref> gives an example parsing specification we use for the CALL instruction. At a high-level, this grammar specifies four alternatives that can build a CALL instruction. Each case includes a pattern specifying literal sequences of bits (e.g., "1110"), followed by other components like word or modrm2 that are themselves grammars that compute values of an appropriate type. The "@" separates the pattern from a Coq function that can be used to transform the values returned from the pattern match. For example, in the first case, we take the word value and use it to build the abstract syntax for a version of the CALL instruction with an immediate operand.</p><p>We chose to specify patterns at the bit-level, instead of the bytelevel, because this avoids the need to introduce or reason about shifts and masks in the semantic actions. Furthermore, we were able to take the tables from the Intel IA-32 instruction manual and translate them directly into appropriate patterns.</p><p>Our decoding specifications take advantage of Coq's notation mechanism, as well as some derived forms to make the grammar readable, but these are defined in terms of a small set of constructors given by the following type-indexed datatype:</p><p>A value of type grammar T represents a relation between lists of chars 2 and semantic values of type T. Alternatively, we can think of the grammar as matching an input string and returning a set of associated semantic values. Formally, the denotation of a grammar is the least relation over strings and values satisfying the following equations: The last constructor, Map, is our constructor for semantic actions. When g is a grammar that returns T1 values, and f is a function of type T1 → T2, then Map f g is the grammar that matches the same set of strings as g, but transforms the outputs from T1 values to T2 values using f . If a grammar forgoes the use of Map, then the semantic values represent a parse tree for the input. Map makes it possible to incrementally transform the parse tree into alternate semantic values, such as abstract syntax.</p><formula xml:id="formula_1">[[Char c]] = {(c :: nil, c)} [[Any]] = c {(c :: nil, c)} [[Eps]] = {(nil, tt)} [[Void]] = ∅ [[Alt g1 g2]] = [[g1]] ∪ [[g2]] [[Cat g1 g2]] = {((s1s2), (v1, v2)) | (si, vi) ∈ [[gi]]} [[Map f g]] = {(s, f (v)) | (s, v) ∈ [[g]]} [[Star g]] = [[Map (λ . nil) Eps]] ∪ [[</formula><p>As noted above, we use Coq's notation mechanism to make the grammars more readable. In particular, the following table gives some definitions for the notation used here:</p><p>g1 || g2 := Alt g1 g2 g1 $ g2 := Cat g1 g2 g @ f := Map f g g1 $$ g2 := (g1 $ g2) @ snd</p><p>We encode the denotational semantics in Coq using an inductively defined predicate, which makes it easy to symbolically reason about grammars. For example, one of our key theorems shows that our top-level grammar, which includes all possible prefixes and all possible integer instructions, is deterministic:</p><formula xml:id="formula_2">(s, v1) ∈ [[x86grammar]] ∧ (s, v2) ∈ [[x86grammar]] =⇒ v1 = v2</formula><p>This helps provide some assurance that in transcribing the grammar from Intel's manual, we have not made a mistake. In fact, when we first tried to prove determinism, we failed because we had flipped a bit in an infrequently used encoding of the MOV instruction, causing it to overlap with another instruction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">The Decoder Implementation</head><p>While the denotational specification makes it easy to reason about grammars, it cannot be directly executed. Consequently, we define a parsing function which, when given a record representing a machine state, fetches bytes from the address specified by the program counter and attempts to match them against the grammar and build the appropriate instruction abstract syntax.</p><p>Our parsing function is defined by taking the derivative of the x86grammar with respect to the sequence of bits in each byte, and then checking to see if the resulting grammar accepts the empty string. The notion of derivatives is based on the ideas of Brzozowski <ref type="bibr" target="#b14">[4]</ref> and more recently, Owens et al. <ref type="bibr" target="#b34">[24]</ref> and Might et al. <ref type="bibr" target="#b32">[22]</ref>. Reasoning about derivatives is much easier in Coq than attempting to transform grammars into the usual graph-based formalisms, as we need not worry about issues such as naming nodes, equivalence on graphs, or induction principles for graphs. Rather, all of our computation and reasoning can be done directly on the algebraic datatype of grammars.</p><p>Semantically, the derivative of a grammar g with respect to a character c is the relation:</p><formula xml:id="formula_3">derivc g = {(s, v) | (c :: s, v) ∈ [[g]]}</formula><p>That is, derivc g matches the tail of any string that starts with c and matches g.</p><p>Fortunately, calculating the derivative, including the appropriate transformation on the semantic actions, can be written as a straightforward function:</p><formula xml:id="formula_4">derivc Any = Map (λ . c) Eps derivc (Char c) = Map (λ . c) Eps derivc (Alt g1 g2) = Alt (derivc g1) (derivc g2) derivc (Star g) = Map (::) (Cat(derivc g) (Star g)) derivc (Cat g1 g2) = Alt(Cat (derivc g1) g2) (Cat (null g1) (derivc g2)) derivc (Map f g) = Map f (derivc g) derivc g = Void otherwise</formula><p>where null g is defined as:</p><formula xml:id="formula_5">null Eps = Eps null (Alt g1 g2) = Alt (null g1) (null g2) null (Cat g1 g2) = Cat (null g1) (null g2) null (Star g) = Map (λ . nil) Eps null (Map f g) = Map f (null g) null g = Void otherwise</formula><p>Effectively, deriv strips off a leading pattern that matches c, and adjusts the grammar with a Map so that it continues to calculate the same set of values. If the grammar cannot match a string that starts with c, then the resulting grammar is Void. The null function returns a grammar equivalent to Eps when its argument accepts the empty string, and Void otherwise. It is used to calculate the derivative of a Cat, which is simply the chain-rule for derivatives.</p><p>Once we calculate the iterated derivative of the grammar with respect to a string of bits, we can extract the set of related semantic values by running the extract function, which returns those semantic values associated with the empty string:</p><formula xml:id="formula_6">extract Eps = {tt} extract (Star g) = {nil} extract (Alt g1 g2) = (extract g1) ∪ (extract g2) extract (Cat g1 g2) = {(v1, v2) | vi ∈ extract gi} extract (Map f g) = {f (v) | v ∈ extract g} extract g = ∅ otherwise</formula><p>To be reasonably efficient, it is important that we optimize the grammar as we calculate derivatives. In particular, when we build a grammar, we always use a set of "smart" constructors, which are functions that perform local reductions, including:</p><formula xml:id="formula_7">Cat g Eps → g Cat Eps g → g Cat g Void → Void Cat Void g → Void Alt g Void → g Alt Void g → g Star (Star g) → Star g Alt g g → g</formula><p>Of course, the optimizations must add appropriate Maps to adjust the semantic actions. Proving the optimizations correct is an easy exercise using the denotational semantics. Unfortunately, the last of these optimizations (Alt g g → g) cannot be directly implemented as it demands a decidable notion of equality for grammars, yet our grammars include arbitrary Coq functions (and types). To work around these problems, we first translate grammars to an internal form, where all types and functions are replaced with a name that we can easily compare. An environment is used to track the</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Machine locations loc</head><formula xml:id="formula_8">::= PC | EAX | • • • | CF | • • • | SS | • • • Local variables x, y, z ∈ identifier Arithmetic operators op ::= add | xor | shl | • • • Comparison operators cmp ::= lt | eq | gt RTL instructions rt ::= x := y op z | x := y cmp z | x := imm | x := load loc | store loc x | x := Mem[y] | Mem[x] := y | x := choose | • • • Figure 3.</formula><p>The RTL Language mapping from names back to their definitions, and is consulted in the extract function to build appropriate semantic values.</p><p>In the end, we get a reasonably efficient parser that we can extract to executable OCaml code. Furthermore, we prove that the parser, when given a grammar g and string s, produces a (finite</p><formula xml:id="formula_9">) set of values {v1, • • • , vn} such that (s, vi) ∈ [[g]].</formula><p>Since we have proven that our instruction grammar is deterministic, we know that in fact, we will get out at most one instruction for each sequence of bytes that we feed to the parser.</p><p>Finally, we note that calculating derivatives in this fashion corresponds to a lazy, on-line construction of a deterministic finitestate transducer. Our efficient NaCl checker, described in Section 3 is built from a deterministic finite-state automaton (DFA) generated off-line, re-using the definitions for the grammars, derivatives, etc. in the parsing library.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Translation To RTL</head><p>After parsing bytes into abstract syntax, we translate the corresponding instruction into a sequence of RTL (register transfer list) operations. RTL is a small RISC-like language for computing with bit-vectors. The language abstracts over an architecture's definition of machine state, which in the case of the x86 includes the various kinds of registers shown in Figure <ref type="figure">1</ref> as well as a memory, represented as a finite map from addresses to bytes. Internally, the language supports a countably infinite supply of local variables that can be used to hold intermediate bit-vector values.</p><p>The RTL instruction set is sketched in Figure <ref type="figure">3</ref> and includes standard arithmetic, logic, and comparison operations for bit vectors; operations to sign/zero-extend and truncate bit vectors; an operation to load an immediate value into a local variable; operations to load/store values in local variables from/to registers; operations to load and store bytes into memory; and a special operation for non-deterministically choosing a bit-vector value of a particular size. We use dependent types to embed the language into Coq and ensure that only bit-vectors of the appropriate size are used in instructions.</p><p>For each x86 constructor, we define a function that translates the abstract syntax into a sequence of RTL instructions. The translation is encapsulated in a monad that takes care of allocating fresh local variables, and that allows us to build higher-level operations out of sequences of RTL commands.</p><p>Figure <ref type="figure">4</ref> presents an excerpt of the translation of the ADD instruction. The ADD constructor is parameterized by a prefix record, a boolean mode, and two operands. The prefix record records modifiers including any segment, operand, or address override. The boolean mode is set when the default operand size is to be used The first two local definitions specialize the load and store RTL to the given prefix and mode. The third definition selects the appropriate segment. Next, we load constant expressions 0 and 1 (of bit-size 1) into local variables zero and up. Then we fetch the bit-vector values from the operands and store them in local variables p0 and p1. At this point, we actually add the two bitvectors and place the result in local variable p2. Then we update the machine state at the location specified by the first operand. Afterwards, we set the various flag registers to hold the appropriate 1-bit value based on the outcome of the operation. Here, we have only shown the code needed to set the overflow (OF) flag.</p><p>Occasionally, the effect of an operation, particularly on flags, is under-specified or unclear. To over-approximate the set of possible behaviors, we use the choose operation, which nondeterministically selects a bit-vector value and stores this value in the appropriate location.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">The RTL Interpreter</head><p>Once we have defined our decoder and translation to RTL, we need only give a semantics to the RTL instructions to complete the x86 model. One option would be to use a small-step operational semantics for modeling RTL execution, encoded as an inductive predicate. However, this would prevent us from extracting an executable interpreter which we need for validation.</p><p>Instead, we encode a step in the semantics as a function from RTL machine states to RTL machine states. RTL machine states record the values of the various x86 locations, the memory, and the values of the local variables. To support the non-determinism in the choose operation, the RTL machine state includes a stream of bits that serves as an oracle. Whenever we need to choose a new value, we simply pull bits from the oracle stream. Of course, when reasoning about the behavior of instructions, we must consider all possible oracle streams. This is a standard trick for turning a nondeterministic step relation into a function.</p><p>Most of the operations are simple bit-vector computations for which we use the CompCert integer bit-vector library <ref type="bibr" target="#b26">[16]</ref>. Consequently, the definition of the interpreter is fairly straightforward and extracts to reasonable OCaml code that we can use for testing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Model Validation</head><p>Any model of the x86 is complicated enough that it undoubtably has bugs. The only way we can gain any confidence is to test it against real x86 processors (and even they have bugs!). As described above, we have carefully engineered our model so that we can extract an executable OCaml simulator from our Coq definitions. We use this simulator to compare against an actual x86 processor.</p><p>One challenge in validating the simulator is extracting the machine state from the real processor. We use Intel's Pin tool <ref type="bibr" target="#b28">[18]</ref> to insert dynamic instrumentation into a binary. The instrumentation dumps the values of the registers to a file after each instruction, and the values in memory after each system call. We then take the original binary and run it through our OCaml simulator, comparing the values of the registers after the RTL sequence for an instruction has been generated and interpreted. Unfortunately, this procedure sometimes generates false positives because of our occasional use of the oracle to handle undefined or under specified behaviors.</p><p>We use two different techniques to generate test cases to exercise the simulator. First, we generate small, random C programs using Csmith <ref type="bibr" target="#b44">[34]</ref> and compile them using GCC. In this way, we simulated and verified over 10 million instruction instances in about 60 hours on an 8 core intel Xeon running at 2.6Ghz.</p><p>However, this technique does not exercise instructions that are avoided by compilers, and even some common instructions have encodings that are rarely emitted by assemblers. For example, our previously discussed bug in the encoding of the MOV instruction was not uncovered by such testing because it falls in this category.</p><p>A more thorough technique is to fuzz test our simulator by generating random sequences of bytes, which has previously proved effective in debugging CPU emulators <ref type="bibr" target="#b29">[19]</ref>. Using our generative grammar, we randomly produce byte sequences that correspond to instructions we have specified. This lets us exercise unusual forms of all the instructions we define. For instance, an instruction like add with carry comes in fourteen different flavors, depending on the width and types of the operands, whether immediates are signextended, etc. Fuzzing such an instruction guarantees with some probability that all of these forms will be exercised.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">The RockSalt NaCl Checker</head><p>Recall that our high level goal is to produce a checker for Native Client, which when given an x86 binary image, returns true only when the image respects the sandbox policy: when executed, the code will only read/write data from specified contiguous segments in memory, will not directly execute a particular set of instructions (e.g., system calls), and will only transfer control within its own image or to a specified set of entry points in the NaCl run-time.</p><p>The 32-bit x86 version of NaCl takes advantage of the segment registers to enforce most aspects of this policy. In particular, by setting the CS (code), DS (data), SS (stack), and GS (thread-local) segment registers appropriately, the machine itself will ensure that data reads and writes are contained in the data segments, and that jumps are contained within the code segment. However, we must make sure that the untrusted instructions do not change the values of the segment registers, nor override the segments inappropriately.</p><p>At first glance, it appears sufficient to simply parse the binary into a sequence of instructions, and check that each instruction in the sequence preserves the values of the segment registers and does not override the segment registers with a prefix. Unfortunately, this simple strategy does not suffice. The problem is that, since the x86 has variable length instructions, we must not only consider the parse starting at the first byte, but all possible parses of the image. While most programs will respect the initial parse, a malicious or buggy program may not. For example, in a program that has a buffer overrun, a return address may be overwritten by a value that points into the middle of an instruction from the original parse.</p><p>To avoid this problem, NaCl provides a modified compiler that rewrites code to respect a stronger alignment policy, following the ideas of McCamant and Morrisett <ref type="bibr" target="#b30">[20]</ref>. The alignment policy requires that all computed jumps (i.e., jumps through a register) are aligned on a 32-byte boundary. This is ensured by inserting code to mask the target address with an appropriate constant, and by inserting no-ops so that potential jump targets are suitably aligned. In more detail, the aligned, sandbox policy requires that:</p><p>1. Starting with the first byte, the image parses into a legal sequence of instructions that preserve the segment registers;</p><p>2. Every 32 nd byte is the beginning of an instruction in our parse;</p><p>3. Every indirect jump through a register r is immediately preceded by an instruction that masks r so that it is 32-byte aligned;</p><p>4. The masking operation and jump are both contained within a 32-byte-aligned block of instructions;</p><p>5. Each direct jump targets the beginning of an instruction and that instruction is not an indirect jump.</p><p>Requirements 4 and 5 are needed to ensure that the code cannot jump over the masking operation that protects an indirect jump.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Constructing a NaCl Checker</head><p>Google's NaCl checker is a hand-written C program that is intended to enforce the aligned, sandbox policy. Their checker partially decodes the binary, looking at fields such as the op-codes and mod/rm bits to determine whether the instruction is legal, and how long it is. Two auxiliary data structures are used: One is a bit-map that records which addresses are the starts of instructions. Each time an instruction is parsed, the corresponding bit for the address of the first byte is set. The other is an array of addresses for forward, direct jumps. After checking that the instructions are legal, the bitmap is checked to ensure that every 32nd byte is the start of an instruction. Then, the array of direct jump targets is checked to make sure they are valid according to the policy above.</p><p>There are two disadvantages with Google's checker: it is difficult to reason about because it is somewhat large (about 600 statements of code) <ref type="foot" target="#foot_2">3</ref> and the process of partial decoding is intertwined with policy enforcement. In particular, it is difficult to tell what instructions are supported and with what prefixes, and even more difficult to gain assurance that the resulting code enforces the appropriate sandbox policy. Furthermore, it is difficult to modify the code to e.g., add new kinds of safe instructions or combinations of prefixes.</p><p>In contrast, the RockSalt checker we constructed and verified is relatively small, consisting of only about 80 lines of Coq code. This is because the checker uses table-driven DFA matching to handle the aspects of decoding, following an idea first proposed by Seaborn <ref type="bibr" target="#b41">[31]</ref>. The basic idea is to break all instructions into four categories: (1) those that perform no control-flow, and are easily seen as okay; (2) those that perform a direct jump-we must check that the target is a valid instruction; (3) those that perform an indirect jump-we must check that the destination is appropriately masked; and (4) those instructions that should be rejected. Each of these classes, except the third one, can be described using a simple regular expression. The third class can be captured by a regular expression if we make the restriction that the masking operation must occur directly before the jump, which in practice is what the NaCl compiler does.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 5. Main Routine of our NaCl Checker</head><p>It is possible to extract OCaml code from our Coq definitions and use that as the core of the checker, but we elected to manually translate the code into C so that it would more easily integrate into the NaCl run-time. This avoids adding the OCaml compiler and run-time system to the trusted computing base, at the risk that our translation to C may have introduced an error. However, at under 100 lines of C code, we felt that this was a reasonable risk, since the vast majority of the information is contained in the DFA tables which are automatically generated and proven correct. Of course, one could try to use a verification tool, such as Frama-C/WP <ref type="bibr" target="#b19">[9]</ref> or VCC <ref type="bibr" target="#b17">[7]</ref>, to prove the correctness of this version, in which case the functional code in Coq could serve as a specification.</p><p>Figure <ref type="figure">5</ref> shows the C code for the high-level verifier routine. This function relies upon two sub-routines, match and extract that we will explain later, but intuitively handle the aspects of decoding. Like Google's checker, the routine uses two auxiliary arrays: the valid array records those addresses in the code that are valid jump destinations, whereas the target array records those addresses that are jumped to by some direct control-flow operation. We used byte arrays instead of bit arrays to avoid having to reason about shifts and masks to read/write bits.</p><p>The main loop (line 10) iterates through the bytes in the code starting at position 0. This position is marked as valid and then we attempt to match the bytes at the current position against three patterns. The first pattern, MaskedJump, matches only when the bytes specify a mask of register r followed immediately by an indirect jump or call through r. Note that a successful match increments the position by size which records the length of the instruction(s), whereas a failure to match leaves the position unmodified. The second pattern, NoControlFlow, matches only when the bytes specify a legal NaCl instruction that does not affect control flow (e.g., an arithmetic instruction). The third pattern, DirectJump matches only when the bytes specify a direct JMP, Jcc or CALL instruction. The routine extract then extracts the destination address of the jump, and marks that address in the target array. If none of these cases match, then the checker returns FALSE indicating that an illegal sequence of bytes was found in the code. After the main loop terminates, we must check that (a) if an address is the target of a direct jump, then that address is the beginning of an instruction in our parse (line 22), and (b) if an address is aligned on a 32-byte boundary, then that address is the beginning of an instruction in our parse (line 23).</p><p>The process of matching a sequence of bytes against a pattern is handled by the routine match which is shown in Figure <ref type="figure" target="#fig_0">6</ref>. The function simply executes the transitions of a DFA using the bytes at the current position in the code. The DFA has four fields: a starting state, a boolean array of accepting states, a boolean array of rejecting states, and a transition table that maps a state and byte to a new state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">DFA Generation</head><p>What we have yet to show are the definitions of the DFAs for the MaskedJump, NoControlFlow, and DirectJump patterns, and the correctness of our checker hinges crucially upon these definitions. These are generated from within Coq using higher-level specifications. In particular, for each of the patterns, we specify a grammar re-using the parsing DSL described in Section 2.1, and then compile that grammar to appropriate DFA tables. For example, the grammar for a MaskedJump is given below: Definition nacl_MASK_p (r: register) := "1000" $$ "0011" $$ "11" $$ "100" $$ bitslist (register_to_bools r) $ bitslist (int_to_bools safeMask).</p><p>Definition nacl_JMP_p (r: register) := "1111" $$ "1111" $$ "11" $$ "100" $$ bitslist (register_to_bools r).</p><p>Definition nacl_CALL_p (r: register) := "1111" $$ "1111" $$ "11" $$ "010" $$ bitslist (register_to_bools r). The nacl MASK p function takes a register name and generates a pattern for an "AND r, safeMask" instruction. The nacl JMP p and nacl CALL p functions take a register and generate patterns for a jump or call instruction (respectively) through that register. Thus, nacljmp mask and the top-level grammar match any combination of a mask and jump through the same register (excluding ESP).</p><p>We compile grammars to DFAs from within Coq as follows: First, we strip off the semantic actions from the grammars so that we are left with a regular expression r0. This regular expression corresponds to the starting state of the DFA. We use the null routine to check if this is an accepting state and a similar routine to check for rejection, and record this in a table. We then calculate the derivative of r0 with respect to all 256 possible input bytes. This yields a set of regular expressions {r1, r2, • • • , rn}. Each ri corresponds to a state in the DFA that is reachable from r0. We assign each regular expression a state, and record whether that state is an accepting or rejecting state. We continue calculating derivatives of each of the ri with respect to all possible inputs until we no longer create a new regular expression. The fact that there are a finite number of unique derivatives (up to the reductions performed by our smart constructors) was proven by Brzozowski <ref type="bibr" target="#b14">[4]</ref> so we are ensured that the procedure terminates.</p><p>In practice, calculating a DFA in this fashion is almost as good as the usual construction <ref type="bibr" target="#b34">[24]</ref>, but avoids the need to formalize and reason about graphs. The degree to which we simplify regular expressions as we calculate derivatives determines how few states are left in the resulting DFA. In our case, the number of states is small enough (61 for the largest DFA) that we do not need to worry about further minimization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Testing the C Checker</head><p>In the following section, we discuss the formal proof of correctness for the Coq version of the RockSalt checker. But as noted above, in practice we expect to use the C version, partially shown in figures 5 and 6. Although this code is a rather direct translation from the Coq code, to gain further assurance, we did extensive testing, comparing both positive and negative examples against Google's original checker.</p><p>For testing purposes, the ncval (Native Client Validator) command line tool was modified so that our verification routine can be used instead of Google's. We ensured that both verifiers reject a set of hand-crafted unsafe programs, and we also ensured that they both accept a set of benchmark programs once processed by the NaCl version of GCC which inserts appropriate no-ops and mask instructions. To work around the lack of floating-point support in our checker, we use the "-msoft-float" flag so that GCC avoids generating floating-point instructions. The benchmark programs were drawn from the same set as used in CompCert <ref type="bibr" target="#b26">[16]</ref> and include an implementation of AES, SHA1, a virtual machine, fractal computation, a Perl interpreter, and 16 other programs representing more than 4,000 lines of code. We also used Csmith <ref type="bibr" target="#b44">[34]</ref> to automatically generate C programs, and compiled them with NaCl's version of GCC. We then verified that our driver and Google's always agreed on a program's safety. Using this method we have verified over two thousand small C programs.</p><p>Finally, we measured the time it takes to check binaries using both our C checker and Google's original code. For the small benchmarks mentioned above, there was no measurable difference in checking times. However, on an artificially generated C program of about 200,000 lines of code, running on a 2.6 GHz Intel Xeon core, Google's checker took 0.90 seconds and our checker took 0.24 seconds (averaging over one hundred runs). Consequently, we believe that RockSalt is competitive with Google's approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Proof of Correctness for the Checker</head><p>After building and testing the checker, we wanted to prove its correctness with respect to the sandbox policy. That is, we wanted a proof that if the checker returns TRUE for a given input binary, and if that binary is loaded and executed in an appropriate environment (in particular, where the code and data segments are disjoint), then executing the binary would ensure that only the prescribed data segments are read and written, and control only transfers within the prescribed code segment.</p><p>At a high-level, our proof shows that at every step of the program execution, the values of the segment registers are the same as those in the initial state, and furthermore, that the bytes that make up the code-segment are the same bytes that were analyzed by the checker. These invariants are sufficient to show NaCl's sandbox policy is not violated. Furthermore, the checker should have ruled out system calls and other instructions that are not allowed. But of course, formalizing this argument requires a much more detailed set of invariants that connect the matching work done in the checker to the semantics, along with the issues of alignment, masking, and jump-destination checks.</p><p>We begin by defining the notion of an appropriate machine state: DEFINITION 1. A machine state is appropriate when:</p><p>1. the original data and code segments are disjoint, 2. the DS, SS, and GS segment registers point to their respective original segments, 3. the CS segment registers point to the original code segment, 4. the program counter points within the code segment, and 5. the original bytes of the program are stored in the code segment.</p><p>Appropriateness captures the key data invariants that we need to maintain throughout execution of the program. We augment these data invariants with a predicate on the program counter to reach the definition of a locally-safe machine state: DEFINITION 2. A machine state is locally-safe when it is appropriate and the program counter holds an address corresponding to the start of an instruction that was matched by the verify process using one of the three generated DFAs.</p><p>In other words, for a locally safe state, the pc is marked as valid.</p><p>We would like to argue that, starting from a locally-safe state, we can always execute an instruction and end up in a locallysafe state. This would imply that the segment registers have not changed, that the code has not changed, that any read or write done by the instruction would be limited to the original data segments, and that control remains within the original code segment.</p><p>Alas, we do not immediately reach a locally-safe state after executing one instruction. The problem is that our MaskedJump DFA operates over two instructions (the mask of the register, followed by the indirect jump). Thus, we introduce the notion of a k-safe state: DEFINITION 3. An appropriate state s is k-safe when k &gt; 0 and, for any s such that s -→ s , either s is locally-safe or s is (k -1)-safe.</p><p>With the definitions given above, it suffices to show that if a state is locally-safe, then it is also k-safe for some k (and in fact, k is either 1 or 2). Indeed, each locally-safe state s should be k-safe for some k: if s -→ s then either s is locally-safe or we executed the mask of a MaskedJump and we should be in an appropriate state, ready to execute a branch instruction that will target a masked (and therefore valid) address. Then, assuming the computation starts in a locally-safe state (e.g., with the pc at any valid address), it is easy to see that the code cannot step to a state where the segment registers have changed, or the bytes in the code segment have changed. THEOREM 1. If s is locally-safe, then it is also k-safe for some k.</p><p>Since a locally-safe instruction has a program counter drawn from the set of valid instructions, and since the verifier did not return FALSE, we can conclude that a prefix of the bytes starting at this address matches one of the three DFAs. We must then argue that for each class of instructions that match the DFAs, after executing the instruction, we either end up in a locally-safe state or else after executing one more instruction, end up in a locally safe-state.</p><p>In the Section 4.1, we sketch the connection we formalized between the DFAs and a set of inversion principles that characterize the possible instructions that they can match. These principles allow us to do a case analysis on a subset of the possible instructions. For example, in the case that the MaskedJump DFA matches, we know that the bytes referenced by the program counter must decode into a masking operation on some register r, followed by bytes that decode into a jump or call to register r. The proof proceeds by case analysis for each of the three DFAs utilizing these inversion principles.</p><p>The easiest (though largest) case is when the NoControlFlow DFA has the successful match. We prove three properties for each non-control-flow instruction I that the inversion principle gives us:</p><p>(1) executing I does not modify segment registers;</p><p>(2) executing I modifies only the data segments' memory;</p><p>(3) after executing I, the new program counter is equal to the old program counter plus the length of I.</p><p>For the most part, arguing these cases is simple: For the first property, we simply iterate over the generated list of RTLs for I and ensure there are no writes to the segment registers. The second property follows from the inversion principles which forbid the use of a segment override prefix, and the third property follows from the semantics of non-control-flow instructions. From these three facts, it follows that after executing the instruction, we are immediately in a locally-safe state. That is, the original state was 1-safe.</p><p>In the case where I was matched by DirectJump, we must argue that the final loop in verify ensures that the target of the jump is valid. Of course, we must also show that the segment registers are preserved, the code is preserved, etc. But then we can again argue that the original state was 1-safe.</p><p>For the MaskedJump case, we must argue that the state is 2-safe. The inversion principle for the DFA restricts the first instruction to an AND of a particular register r with a constant that ensures after the step, the value of r is aligned on a 32-byte boundary, the segments are preserved, and the pc points to bytes within the code segment that decode into either a jump or call through r. We then argue that this state is 1-safe. Since the destination of the jump or call is 32-byte aligned, the final loop of the verifier has checked that this address is valid. Consequently, it is easy to show that we end up in a locally-safe state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Inverting the DFAs</head><p>A critical piece in our proof of correctness is the relationship between the DFAs generated from the NoControlFlow, DirectJump, and MaskedJump regular expressions and our semantics for machine instructions. We sketch the key results that we have proven here.</p><p>One theorem specifies the connection between a regular expression, the DFA it generates, and the match procedure: THEOREM 2. If r is a regular expression, and D is the DFA generated from that regular expression, then executing match on D with a sequence of bytes b1, . . . , bn will return true if there is some j ≤ n such that the string b1, . . . , bj is in the denotation of r.</p><p>The theorem requires proving that our DFA construction process, where we iteratively calculate all derivatives, produces a wellformed DFA with respect to r. Here, a well-formed DFA basically provides a mapping from states to derivatives of r that respect certain closure properties. Fortunately, the algebraic construction of the DFA makes proving this result relatively straightforward.</p><p>The theorem also requires showing that running match on D with b1, . . . , bn is correct which entails, among other things, showing that the array accesses are in bounds, and that when we return TRUE, we are in a state that corresponds to the derivative of the regular expression with respect to the string b1, . . . , bj .</p><p>Another key set of lemmas show that the languages accepted by the regular expressions are subsets of the languages accepted by our x86grammar. Additionally, we must prove an inversion principle for each regular expression that characterizes the possible abstract syntax we get when we run the semantics on the bytes. For example, we must show that DirectJump only matches bytes that when parsed, produce either (near) JMP, Jcc, or CALL instructions with an immediate operand. Fortunately, proving the language containment property and inversion principles is simple to do using the denotational semantics for grammars.</p><p>One of the most difficult properties to prove about the decoder was the uniqueness of parsing. In particular, we needed to show that each bit pattern corresponded to at most one instruction, and no instruction's bit pattern was a prefix of another instruction's bit pattern-i.e., that our x86grammar was unambiguous. A naive approach, where we simply explore all possible bit patterns is obviously intractable, when there are instructions up to 15 bytes long. Another approach is to construct a DFA for the grammar and then show that each accepting state has at most one semantic value associated with it. While this is possible, the challenge is getting Coq to symbolically evaluate the DFA construction and reduce the semantic actions in a reasonable amount of time <ref type="foot" target="#foot_3">4</ref> .</p><p>Consequently, we constructed a simple procedure that checks whether the intersection of two grammars is empty. The procedure, which only succeeds on star-free grammars (stripped of their semantic actions) works by generalizing the notion of a derivative from characters to star-free regular expressions: When it is defined, it is easy to show that:</p><formula xml:id="formula_10">Deriv g1 g2 = {s2 | ∃s1.s1 ∈ g2 ∧ s1s2 ∈ g1}</formula><p>and thus, when Deriv g1 g2 → Void, we can conclude that there is no string in the intersection of the domains of g1 and g2, and furthermore, g2's strings are not a prefix of those in g1. This allowed us to easily prove (through Coq's symbolic evaluation) that the x86grammar is unambiguous: We simply recursively descend into the grammar, and each time we encounter an Alt, check that the intersection of the two sub-grammars is empty.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Related Work</head><p>With the growing interest in verification of software tools, formal models of processors that support machine-checked proofs have be-come a hot topic. Often, these models have limitations, not because of any inherent design flaw, but rather because they are meant only to prove specific properties. For example, work on formal verification of compilers <ref type="bibr" target="#b15">[5,</ref><ref type="bibr" target="#b26">16]</ref> only needs to consider the subset of the instructions that compilers use. Moreover, these compilers emit assembly instructions and do not prove semantics preservation all the way down to machine code, so their model leaves out the tricky problem of decoding. The same kinds of limitations exist for the processor models used in the formal verification of operating systems <ref type="bibr">[6]</ref>. Some projects focus on one specific part of the model, for instance the media instructions <ref type="bibr" target="#b24">[14]</ref>, and some others <ref type="bibr" target="#b30">[20]</ref> model just a few instructions mostly as a proof of concept. Even though we are focused here on NaCl verification, our long term goal is to develop a general model of the x86 so we have tried hard to achieve a more open and scalable design.</p><p>There are several projects focused on the development of general formal models of processors. Some projects have considered the formalizations of RISC processors <ref type="bibr">[1,</ref><ref type="bibr" target="#b21">11,</ref><ref type="bibr" target="#b31">21]</ref>. As noted, developing a formal model for the x86 poses many new problems, partly because decoding is significantly more complex, but also for the definition and validation of such a vast number of instructions (over 1,000) with so many variations, from addressing modes to prefixes.</p><p>One model close in spirit to our own is the Y86 formalization in ACL2 by Ray <ref type="bibr" target="#b39">[29]</ref>. Like our model, Ray's provides an executable simulator. However, the Y86 is a much smaller fragment (about 30 instructions), and has a much simpler instruction encoding (e.g., no prefixes).</p><p>Perhaps the closest related research project, and the one from which we took much inspiration in our design, is the work on modeling x86 multi-processor memory models <ref type="bibr" target="#b35">[25,</ref><ref type="bibr" target="#b40">30,</ref><ref type="bibr" target="#b42">32]</ref>. This work comes with a formal model of about 20 instructions, and we borrowed many of the ideas, such as the use of high-level grammars for specifying the decoder. However, their focus was on issues of non-determinism where it is seemingly more natural to use predicates to describe the possible behaviors of programs. The price paid is that validation requires symbolic evaluation and theorem proving to compare abstract machine states to concrete ones. Although this was largely automated, we believe that our functional approach provides a more scalable way to test the model. Indeed, we have been able to run three orders of magnitude more tests. On the other hand, it remains to be seen how effective our approach will be when we add support for concurrency.</p><p>Our decoder, formalized in Coq, uses parsers generated from regular expressions using the idea of derivatives. Others have formalized derivative-based regular expression matching <ref type="bibr">[2]</ref> but not parsing. However, more general parser generators for algorithms such as SLR and LR have recently been formalized <ref type="bibr" target="#b13">[3,</ref><ref type="bibr" target="#b23">13]</ref>.</p><p>The original idea for Software-based fault isolation (SFI) was introduced by Wahbe et. al. <ref type="bibr" target="#b43">[33]</ref> in the context of a RISC machine. This work used an invariant on dedicated registers to ensure that all reads, writes, and jumps were appropriately isolated. Of course, parsing was not a problem because instructions had a uniform length. As noted earlier, McCamant and Morrisett <ref type="bibr" target="#b30">[20]</ref> introduced the idea of the alignment constraint to handle variable-length instruction sets. In that paper, they formalized a small subset of the x86 (7 instructions) using ACL2 and proved that their high-level invariants were respected by those instructions, but did not prove the correctness of their checker. In fact, even with the small number of instructions, Kroll and Dean found a number of bugs in the decoder <ref type="bibr" target="#b25">[15]</ref>, which reinforces our argument that one should be wary of a trusted decoder or disassembler.</p><p>Pilkiewicz <ref type="bibr" target="#b36">[26]</ref> developed a formally verified SFI checker in Coq for a simple assembly language.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Future work &amp; Conclusions</head><p>We have presented a formal model for a significant subset of the x86, and a new formally verified checker for Native Client called RockSalt. The primary challenge in this work was building a model for an architecture as complicated as the x86. Although we only managed to model a small subset, we believe that the design is relatively robust thanks to our ability to extract and test executable code. The experience in using the model to reason about a simple but real policy such as NaCl's sandbox, provides some assurance that the model will be useful for reasoning in other contexts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Future Work</head><p>As explained before, our x86 model is far from complete. We do not yet handle floating-point instructions, system programming instructions, nor any of the MMX, SSEn, 3dNow! or IA-64 instructions. On the other hand, we have managed to cover enough instructions that we can compile real applications and run them through the simulator. Moving forward, we would like to extend the model to cover at least those instructions that are used by compilers.</p><p>Our model of machine states is also overly simple. For example, we do not yet model concurrency, interrupts, or page tables. However, we believe that the use of RTL as a staging language makes it easier to add support for those features. For example, to model multiple processors and the total-store order (TSO) memory consistency model <ref type="bibr" target="#b42">[32]</ref>, we believe that it is sufficient to add a store buffer to the machine state for each processor. Of course, validating a concurrent model will present new challenges.</p><p>We believe that the use of domain-specific languages will further facilitate re-use and help to find and eliminate bugs. For example, one could imagine embedding these languages in other proof assistants (HOL, ACL2, etc.) to support portability of the specification across formal systems.</p><p>We would also like to close the gap on RockSalt so that the C code, derived from our verified Coq code, is itself verified and compiled with a proven-correct compiler such as CompCert. In fact, one fun idea is to simply bypass the compiler and write the checker directly in x86 assembly to see how easy it is to turn the process in on itself. Finally, there are richer classes of policies, such as XFI, for which we would like to write checkers and prove correctness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Lessons Learned</head><p>The basic idea of using domain-specific languages to build a scalable semantics worked well for us. In our first iteration of the model, we tried to directly interpret x86 instructions, but soon realized that any reasoning work would be proportional to the number of distinct instructions. Compiling instructions to a small RISC-like core simplified our reasoning, and at the same time, made it easier to factor the model into smaller, more re-usable components.</p><p>One surprising aspect of the work was that the pressure to provide reasoning principles for parsers forced us to treat the problem more algebraically than is typically done. In particular, the use of derivatives, which operate directly on the abstract syntax of grammars, made our reasoning much simpler than it would be with graphs.</p><p>It goes without saying that constructing machine-checked proofs is still very hard. The definitions for our x86 model and NaCl checker are about 5,000 lines of heavily commented Coq code, but the RockSalt proofs are another 10,000 lines. Of course, many of these proofs will be useful in other settings (e.g., that the decoder is unambiguous) but the ratio is still quite large. One reason for this is that reasoning about certain theories (e.g., bit vectors) is still rather tedious in Coq, especially when compared to modern SAT or SMT solvers. Yet, the dependent types and higher-order features of the language were crucial for constructing the model, much less proving deep properties about it.</p><p>For us, another surprising aspect of the work was the difference that comes with scale. We have a fair amount of experience modeling simple abstract machines with proof assistants. Doing a case split on five or even ten instructions and manually discharging the cases is reasonable. But once you have hundreds of cases, any of which may change as you validate the model, such an approach is no longer tenable. Consequently, many of our proofs were actually done through some form of reflection. For example, to prove that the x86grammar is unambiguous, we constructed a computable function that tests for ambiguity and proved its correctness. In turn, this made it easier to add new instructions to the grammar. Frankly, we couldn't stomach the idea of proving the correctness of a handwritten x86 decoder, and so we were forced into finding a better solution. In short, when a mechanized development reaches a certain size, we are forced to develop more automated and robust proof techniques.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. The DFA match routine</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Deriv g</head><label></label><figDesc>Eps = g Deriv g (Char c) = derivc g Deriv g Any = DrvAny g Deriv g Void = Void Deriv g (Alt g1 g2) = Alt (Deriv g g1) (Deriv g g2) Deriv g (Cat g1 g2) = Deriv (Deriv g g1) g2 where DrvAny Any = Eps DrvAny (Char c) = Eps DrvAny Eps = Void DrvAny Void = Void DrvAny (Alt g1 g2) = Alt (DrvAny g1) (DrvAny g2) DrvAny (Cat g1 g2) = Alt (Cat (DrvAny g1) g2) (Cat (null g1) (DrvAny g2))</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Some instructions have numerous encodings. For example, there are fourteen different opcode forms for the ADC instruction, but we count this as a single instruction.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Grammars are parameterized by the type char.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>To be fair, this includes CPU identification and support for floating-point and other instructions that we do not yet handle.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>Recall that that the DFAs generated for the NaCl checker strip the semantic actions, so they do not need to worry about reducing semantic actions.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>* This research was sponsored in part by NSF grants CCF-0915030, CCF-0915157, CNS-0910660, CCF-1149211, AFOSR MURI grant FA9550-09-1-0539, and a gift from Google.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">(</forename><surname>Bool Verifier</surname></persName>
		</author>
		<author>
			<persName><surname>Dfa *nocontrolflow</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Dfa *</forename><surname>Dfa *directjump</surname></persName>
		</author>
		<author>
			<persName><surname>Maskedjump</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>3. uint8_t *code. uint size</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">=</forename><surname>Bool</surname></persName>
		</author>
		<author>
			<persName><surname>True</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">10. while (pos &lt; size) { 11</title>
		<imprint/>
	</monogr>
	<note>valid[pos] = TRUE</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m">saved_pos = pos</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m">i &amp; 0x1F || valid</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Bool match(DFA *A, uint8_t *code, 2. uint *pos</title>
		<imprint/>
	</monogr>
	<note>uint size</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m">pos + off &lt; size</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">A-&gt;table</title>
		<imprint/>
	</monogr>
	<note>state. *pos + off</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">*pos +=</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The semantics of Power and ARM multiprocessor machine code</title>
		<author>
			<persName><forename type="first">J</forename><surname>Alglave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C J</forename><surname>Fox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ishtiaq</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">O</forename><surname>Myreen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sarkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sewell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">Z</forename><surname>Nardelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Workshop on Declarative Aspects of Multicore Programming</title>
		<meeting>of the Workshop on Declarative Aspects of Multicore Programming</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="13" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Partial derivative automata formalized in Coq</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Almeida</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Moreira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pereira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Sousa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 15th Intl. Conf. on Implementation and Application of Automata, number 6482 in CIAA &apos;10</title>
		<meeting>of the 15th Intl. Conf. on Implementation and Application of Automata, number 6482 in CIAA &apos;10</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2010-08">Aug. 2010</date>
			<biblScope unit="page" from="59" to="68" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Verified, executable parsing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Barthwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Norrish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Symp. on Programming, ESOP &apos;09</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="160" to="174" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Derivatives of regular expressions</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Brzozowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="481" to="494" />
			<date type="published" when="1964">1964</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A verified compiler for an impure functional language</title>
		<author>
			<persName><forename type="first">A</forename><surname>Chlipala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 37th ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages</title>
		<meeting>of the 37th ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="93" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Lyrebird: assigning meanings to machines</title>
		<author>
			<persName><forename type="first">D</forename><surname>Cock</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 5th Intl. Conf. on Systems Software Verification, SSV&apos;10</title>
		<meeting>of the 5th Intl. Conf. on Systems Software Verification, SSV&apos;10</meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="6" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">VCC: A practical system for verifying concurrent C</title>
		<author>
			<persName><forename type="first">E</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dahlweid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hillebrand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Leinenbach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Moskal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Santen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Schulte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tobies</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 22nd Intl. Conf. on Theorem Proving in Higher Order Logics, TPHOLs &apos;09</title>
		<meeting>of the 22nd Intl. Conf. on Theorem Proving in Higher Order Logics, TPHOLs &apos;09</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="23" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<ptr target="http://coq.inria.fr/" />
		<title level="m">Coq development team. The Coq proof assistant</title>
		<imprint>
			<date type="published" when="1989">1989-2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">WP plug-in manual</title>
		<author>
			<persName><forename type="first">L</forename><surname>Correnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Dargaye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pacalet</surname></persName>
		</author>
		<imprint/>
		<respStmt>
			<orgName>CEA LIST</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Automatically generating instruction selectors using declarative machine descriptions</title>
		<author>
			<persName><forename type="first">J</forename><surname>Dias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Ramsey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 37th ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, POPL &apos;10</title>
		<meeting>of the 37th ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, POPL &apos;10</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="403" to="416" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A trustworthy monadic formalization of the ARMv7 instruction set architecture</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C J</forename><surname>Fox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">O</forename><surname>Myreen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Interactive Theorem Proving</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6172</biblScope>
			<biblScope unit="page" from="243" to="258" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Pentium Processor Family Developers Manual</title>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Intel Corporation</publisher>
			<biblScope unit="volume">3</biblScope>
		</imprint>
		<respStmt>
			<orgName>Intel Corporation</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Validating LR(1) parsers</title>
		<author>
			<persName><forename type="first">J.-H</forename><surname>Jourdan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pottier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Leroy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Symp. on Programming, ESOP &apos;12</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Centaur technology media unit verification</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">A H</forename><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Swords</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Aided Verification, 21st Intl</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5643</biblScope>
			<biblScope unit="page" from="353" to="367" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">BakerSFIeld: Bringing software fault isolation to x64</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kroll</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dean</surname></persName>
		</author>
		<ptr target="http://www.cs.princeton.edu/~kroll/papers/bakersfield-sfi.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Formal verification of a realistic compiler</title>
		<author>
			<persName><forename type="first">X</forename><surname>Leroy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. of the ACM</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="107" to="115" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Transformer Specification Language: A System for Generating Analyzers and its Applications</title>
		<author>
			<persName><forename type="first">J</forename><surname>Lim</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011-05">May 2011</date>
		</imprint>
		<respStmt>
			<orgName>University of Wisconsin-Madison</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Pin: building customized program analysis tools with dynamic instrumentation</title>
		<author>
			<persName><forename type="first">C.-K</forename><surname>Luk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cohn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Muth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Patil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Klauser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lowney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wallace</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">J</forename><surname>Reddi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hazelwood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the ACM SIGPLAN Conf. on Programming Language Design and Implementation, PLDI &apos;05</title>
		<meeting>of the ACM SIGPLAN Conf. on Programming Language Design and Implementation, PLDI &apos;05</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="190" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Testing CPU emulators</title>
		<author>
			<persName><forename type="first">L</forename><surname>Martignoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Paleari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">F</forename><surname>Roglia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Bruschi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 18th Intl. Symp. on Software Testing and Analysis</title>
		<meeting>of the 18th Intl. Symp. on Software Testing and Analysis</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="261" to="272" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Evaluating SFI for a CISC architecture</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mccamant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Morrisett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 15th Conf. on USENIX Security Symp</title>
		<meeting>of the 15th Conf. on USENIX Security Symp</meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="209" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Machine instruction syntax and semantics in higher order logic. In Automated Deduction -CADE-17, 17th Intl</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">G</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Appel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">1831</biblScope>
			<biblScope unit="page" from="7" to="24" />
			<date type="published" when="2000">2000</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Parsing with derivatives: a functional pearl</title>
		<author>
			<persName><forename type="first">M</forename><surname>Might</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Darais</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Spiewak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 16th ACM SIGPLAN Intl. Conf. on Functional Programming, ICFP &apos;11</title>
		<meeting>of the 16th ACM SIGPLAN Intl. Conf. on Functional Programming, ICFP &apos;11</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="189" to="195" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<ptr target="http://code.google.com/contests/nativeclient-security/index.html" />
		<title level="m">Native Client team. Native client security contest</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Regular-expression derivatives reexamined</title>
		<author>
			<persName><forename type="first">S</forename><surname>Owens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Reppy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Turon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Funct. Program</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="173" to="190" />
			<date type="published" when="2009-03">March 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Lem: A lightweight tool for heavyweight semantics</title>
		<author>
			<persName><forename type="first">S</forename><surname>Owens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Böhm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">Z</forename><surname>Nardelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sewell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Interactive Theorem Proving</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6898</biblScope>
			<biblScope unit="page" from="363" to="369" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">A proved version of the inner sandbox. In native-clientdiscuss mailing list</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pilkiewicz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011-04">April 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Machine descriptions to build tools for embedded systems</title>
		<author>
			<persName><forename type="first">N</forename><surname>Ramsey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Davidson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Languages, Compilers, and Tools for Embedded Systems</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1474</biblScope>
			<biblScope unit="page" from="176" to="192" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Specifying representations of machine instructions</title>
		<author>
			<persName><forename type="first">N</forename><surname>Ramsey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Fernandez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="492" to="524" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Towards a formalization of the X86 instruction set architecture</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ray</surname></persName>
		</author>
		<idno>TR-08-15</idno>
		<imprint>
			<date type="published" when="2008-03">March 2008</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of Texas at Austin</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">The semantics of x86-CC multiprocessor machine code</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sarkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sewell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">Z</forename><surname>Nardelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Owens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ridge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Braibant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">O</forename><surname>Myreen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Alglave</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 36th ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages</title>
		<meeting>of the 36th ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="379" to="391" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">A DFA-based x86-32 validator for Native Client. In native-client-discuss mailing list</title>
		<author>
			<persName><forename type="first">M</forename><surname>Seaborn</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011-06">June 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">x86-TSO: a rigorous and usable programmer&apos;s model for x86 multiprocessors</title>
		<author>
			<persName><forename type="first">P</forename><surname>Sewell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sarkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Owens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">Z</forename><surname>Nardelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">O</forename><surname>Myreen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="89" to="97" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Efficient software-based fault isolation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Wahbe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lucco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">E</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">L</forename><surname>Graham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 14th ACM Symp. on Operating Systems Principles, SOSP &apos;93</title>
		<meeting>of the 14th ACM Symp. on Operating Systems Principles, SOSP &apos;93</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="203" to="216" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Finding and understanding bugs in C compilers</title>
		<author>
			<persName><forename type="first">X</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Eide</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Regehr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 32nd ACM SIGPLAN Conf. on Programming Language Design and Implementation, PLDI &apos;11</title>
		<meeting>of the 32nd ACM SIGPLAN Conf. on Programming Language Design and Implementation, PLDI &apos;11</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="283" to="294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Native Client: a sandbox for portable, untrusted x86 native code</title>
		<author>
			<persName><forename type="first">B</forename><surname>Yee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sehr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Dardyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Muth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ormandy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Okasaka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Narula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Fullagar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. of the ACM</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="91" to="99" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Armor: Fully verified software fault isolation</title>
		<author>
			<persName><forename type="first">L</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">D</forename><surname>Sutter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Regehr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">11th Intl. Conf. on Embedded Software</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
