<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Java bytecode verification: algorithms and formalizations</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Xavier</forename><surname>Leroy</surname></persName>
							<email>xavier.leroy@inria.fr</email>
							<affiliation key="aff0">
								<orgName type="institution">INRIA Rocquencourt and Trusted Logic S.A</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Java bytecode verification: algorithms and formalizations</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">43219C0C90684C2E838563D495690E8F</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T05:44+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Bytecode verification is a crucial security component for Java applets, on the Web and on embedded devices such as smart cards. This paper reviews the various bytecode verification algorithms that have been proposed, recasts them in a common framework of dataflow analysis, and surveys the use of proof assistants to specify bytecode verification and prove its correctness.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Web applets have popularized the idea of downloading and executing untrusted compiled code on the personal computer running the Web browser, without user's approval or intervention. Obviously, this raises major security issues: without appropriate security measures, a malicious applet could mount a variety of attacks against the local computer, such as destroying data (e.g. reformatting the disk), modifying sensitive data (e.g. registering a bank transfer via a home-banking software <ref type="bibr" target="#b4">[5]</ref>), divulging personal information over the network, or modifying other programs (Trojan attacks).</p><p>Beyond Web services, the applet model is now being transferred to high-security embedded devices such as smart cards: the Java Card architecture <ref type="bibr" target="#b5">[6]</ref> allows for post-issuance downloading of applets on smart cards. Smart cards are used as security tokens in sensitive application areas such as payment, mobile telephony, and authentication. This makes the security issues with applets even more acute.</p><p>The solution put forward by the Java programming environment is to execute the applets in a so-called "sandbox", which is an insulation layer preventing direct access to the hardware resources and implementing a suitable access control policy <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b53">54,</ref><ref type="bibr" target="#b33">34]</ref>. The security of the sandbox model relies on the following three components:</p><p>1. Applets are not compiled down to machine executable code, but rather to bytecode for a virtual machine. The virtual machine manipulates higher-level, more secure abstractions of data than the hardware processor, such as object references instead of memory addresses.</p><p>2. Applets are not given direct access to hardware resources such as the serial port, but only to a carefully designed set of API classes and methods that perform suitable access control before performing interactions with the outside world on behalf of the applet.</p><p>3. Upon downloading, the bytecode of the applet is subject to a static analysis called bytecode verification, whose purpose is to make sure that the code of the applet is well typed and does not attempt to bypass protections 1 and 2 above by performing ill-typed operations at run-time, such as forging object references from integers, illegal casting of an object reference from one class to another, calling directly private methods of the API, jumping in the middle of an API method, or jumping to data as if it were code <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b57">58,</ref><ref type="bibr" target="#b32">33]</ref>.</p><p>Thus, bytecode verification is a crucial security component in the Java "sandbox" model: any bug in the verifier causing an ill-typed applet to be accepted can potentially enable a security attack. At the same time, bytecode verification is a complex process involving elaborate program analyses. Consequently, considerable research efforts have been expended to specify the goals of bytecode verification, formalize bytecode verification algorithms, and prove their correctness.</p><p>The purpose of the present paper is to survey this work on bytecode verification. We explain what bytecode verification is, describe the various algorithms that have been proposed, outline the main problems they are faced with, and give references to machine-assisted proofs of correctness.</p><p>The remainder of this paper is organized as follows. Section 2 gives a quick overview of the Java virtual machine and of bytecode verification. Section 3 presents the basic bytecode verification algorithm based on dataflow analysis. Sections 4 and 5 concentrate on two delicate verification issues: checking object initialization and dealing with JVM subroutines. Section 6 presents polyvariant verification algorithms that address the subroutine issue. Some issues specific to low-resources embedded systems are discussed in section 7, followed by conclusions and perspectives in section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Overview of the JVM and of bytecode verification</head><p>The Java Virtual Machine (JVM) <ref type="bibr" target="#b32">[33]</ref> is a conventional stack-based abstract machine. Most instructions pop their arguments off the stack, and push back their results on the stack. In addition, a set of registers (also called local variables) is provided; they can be accessed via "load" and "store" instructions that push the value of a given register on the stack or store the top of the stack in the given register, respectively. While the architecture does not mandate it, most Java compilers use registers to store the values of source-level local variables and method parameters, and the stack to hold temporary results during evaluation of expressions. Both the stack and the registers are part of the activation record for a method. Thus, they are preserved across method calls. The entry point for a method specifies the number of registers and stack slots used by the method, thus allowing an activation record of the right size to be allocated on method entry.</p><p>Control is handled by a variety of intra-method branch instructions: unconditional branch ("goto"), conditional branches ("branch if top of stack is 0"), multi-way branches (corresponding to the switch Java construct). Exception handlers can be specified as a table of (pc 1 , pc 2 , C, h) quadruples, meaning that if an exception of class C or a subclass of C is raised by any instruction between locations pc 1 and pc 2 , control is transferred to the instruction at h (the exception handler).</p><p>About 200 instructions are supported, including arithmetic operations, comparisons, object creation, field accesses and method invocations. The example in Figure <ref type="figure" target="#fig_7">1</ref> should give the general flavor of JVM bytecode.</p><p>An important feature of the JVM is that most instructions are typed. For instance, the iadd instruction (integer addition) requires that the stack initially contains at least two elements, and that these two elements are of type int; it then pushes back a result of type int. Similarly, a Source Java code:</p><formula xml:id="formula_0">static int factorial(int n) {</formula><p>int res; for (res = 1; n &gt; 0; n--) res = res * n; return res; } Corresponding JVM bytecode: method static int factorial(int), 2 registers, 2 stack slots 0: iconst_1 // push the integer constant 1 1: istore_1 // store it in register 1 (the res variable) 2: iload_0 // push register 0 (the n parameter) 3: ifle 14 // if negative or null, go to PC 14 6: iload_1 // push register 1 (res) 7: iload_0 // push register 0 (n) 8: imul // multiply the two integers at top of stack 9: istore_1 // pop result and store it in register 1 10: iinc 0, -1 // decrement register 0 (n) by 1 11: goto 2 // go to PC 2 14: iload_1 // load register 1 (res) 15: ireturn // return its value to caller Figure <ref type="figure" target="#fig_7">1</ref>: An example of JVM bytecode getfield C.f.τ instruction (access the instance field f of type τ declared in class C) requires that the top of the stack contains a reference to an instance of class C or one of its sub-classes (and not, for instance, an integer -this would correspond to an attempt to forge an object reference by an unsafe cast); it then pops it and pushes back a value of type τ (the value of the field f ). More generally, proper operation of the JVM is not guaranteed unless the code meets at least the following conditions:</p><p>• Type correctness: the arguments of an instruction are always of the types expected by the instruction.</p><p>• No stack overflow or underflow: an instruction never pops an argument off an empty stack, nor pushes a result on a full stack (whose size is equal to the maximal stack size declared for the method).</p><p>• Code containment: the program counter must always point within the code for the method, to the beginning of a valid instruction encoding (no falling off the end of the method code; no branches into the middle of an instruction encoding).</p><p>• Register initialization: a load from a register must always follow at least one store in this register; in other terms, registers that do not correspond to method parameters are not initialized on method entrance, and it is an error to load from an uninitialized register.</p><p>• Object initialization: when an instance of a class C is created, one of the initialization methods for class C (corresponding to the constructors for this class) must be invoked before the class instance can be used.</p><p>One way to guarantee these conditions is to check them dynamically, while executing the bytecode. This is called the "defensive JVM approach" in the literature <ref type="bibr" target="#b10">[11]</ref>. However, checking these conditions at run-time is expensive and slows down execution significantly. The purpose of bytecode verification is to check these conditions once and for all, by static analysis of the bytecode at loading-time. Bytecode that passes verification can then be executed faster, omitting the dynamic checks for the conditions above.</p><p>It must be emphasized that bytecode verification by itself does not guarantee secure execution of the code: many crucial properties of the code still need to be checked dynamically, for instance via array bounds checks and null pointer checks in the virtual machine, and access control checks in the API. The purpose of bytecode verification is to shift the verifications listed above from run-time to loading-time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Basic verification by dataflow analysis</head><p>The first JVM bytecode verification algorithm is due to Gosling and Yellin at Sun <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b57">58,</ref><ref type="bibr" target="#b32">33]</ref>. Almost all existing bytecode verifiers implement this algorithm. It can be summarized as a dataflow analysis applied to a type-level abstract interpretation of the virtual machine. Some advanced aspects of the algorithm that go beyond standard dataflow analysis are described in sections 4 and 5. In this section, we describe the basic ingredients of this algorithm: the type-level abstract interpreter and the dataflow framework. </p><formula xml:id="formula_1">iconst n : (S, R) → (int.S, R) if |S| &lt; M stack ineg : (int.S, R) → (int.S, R) iadd : (int.int.S, R) → (int.S, R) iload n : (S, R) → (int.S, R) if 0 ≤ n &lt; M reg and R(n) = int and |S| &lt; M stack istore n : (int.S, R) → (S, R{n ← int}) if 0 ≤ n &lt; M reg aconst null : (S, R) → (null.S, R) if |S| &lt; M stack aload n : (S, R) → (R(n).S, R) if 0 ≤ n &lt; M reg and R(n) &lt;: Object and |S| &lt; M stack astore n : (τ.S, R) → (S, R{n ← τ }) if 0 ≤ n &lt; M reg and τ &lt;: Object getfield C.f.τ : (τ .S, R) → (τ.S, R) if τ &lt;: C putfield C.f.τ : (τ 1 .τ 2 .S, R) → (S, R) if τ 1 &lt;: τ and τ 2 &lt;: C invokestatic C.m.σ : (τ n . . . τ 1 .S, R) → (τ.S, R) if σ = τ (τ 1 , . . . , τ n ), τ i &lt;: τ i for i = 1 . . . n, and |τ.S| ≤ M stack invokevirtual C.m.σ : (τ n . . . τ 1 .τ .S, R) → (τ.S, R) if σ = τ (τ 1 , . . . , τ n ), τ &lt;: C, τ i &lt;: τ i for i = 1 . . . n, |τ.S| ≤ M stack</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The type-level abstract interpreter</head><p>At the heart of all bytecode verification algorithms described in this paper is an abstract interpreter for the JVM instruction set that executes JVM instructions like a defensive JVM (including type tests, stack underflow and overflow tests, etc), but operates over types instead of values. That is, the abstract interpreter manipulates a stack of types (a sequence of types) and a register type (a tuple of types associating a type to each register number). It simulates the execution of instructions at the level of types. For instance, for the iadd instruction (integer addition), it checks that the stack of types contains at least two elements, and that the top two elements are the type int. It then pops the top two elements and pushes back the type int corresponding to the result of the addition.</p><p>Figure <ref type="figure" target="#fig_0">2</ref> defines more formally the abstract interpreter on a number of representative JVM instructions. The abstract interpreter is presented as a transition relation i : (S, R) → (S , R ), where i is the instruction, S and R the stack type and register type before executing the instruction, and S and R the stack type and register type after executing the instruction. Errors such as type mismatches on the arguments, stack underflow, or stack overflow, are denoted by the absence of a transition. For instance, there is no transition on iadd from an empty stack.</p><p>Notice that method invocations (such as the invokestatic and invokevirtual instructions in Figure <ref type="figure" target="#fig_0">2</ref>) are not treated by branching to the code of the invoked method, like the concrete JVM does, but simply assume that the effect of the method invocation on the stack is as described by the method signature given in the "invoke" instruction. All bytecode verification algorithms described in this paper proceed method per method, assuming that all other methods are well-typed when verifying the code of a method. A simple coinductive argument shows that if this is the case, the program as a whole (the collection of all methods) is well typed. The types manipulated by the abstract interpreter are similar to the source-level types of the Java language. They include primitive types (int, long, float, double), array types, and object reference types represented by the fully qualified names of the corresponding classes. The boolean, byte, short and char types of Java are identified with int. Three extra types are introduced: null to represent the type of the null reference, ⊥ to represent the absence of any value (at unreachable instructions), and to represent the contents of uninitialized registers, that is, any value. ("Load" instructions explicitly check that the accessed register does not have type , thus detecting accesses to uninitialized registers.)</p><formula xml:id="formula_2">Object int float C D E Object[] C[] D[] E[] int[] float[] Object[][] C[][] D[][] E[][] null</formula><p>These types are equipped with a subtyping relation, written &lt;:, which is essentially identical to the subtyping relation of the Java language (the "assignment compatibility" predicate). Figure <ref type="figure" target="#fig_1">3</ref> illustrates the subtyping relation. Precise definitions of &lt;: can be found in <ref type="bibr" target="#b45">[46,</ref><ref type="bibr" target="#b37">38,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b26">27]</ref>, but are omitted here. For the purposes of this article, all we require from the subtyping relation is the following property: Property 1 (Well-founded semi-lattice.) The set of types ordered by the &lt;: relation is a semilattice: any pair of types has a least upper bound. Moreover, the &lt;: ordering is well founded: there does not exist infinite strictly increasing sequences of types.</p><p>The &lt;: relation between types is extended pointwise to register types and stack types. Two stack types are in the &lt;: relation only if they have the same size. It is easy to see that the &lt;: relation on register types and on stack types is well founded.</p><p>The type-level abstract interpreter must satisfy several formal properties. First and foremost is correctness with respect to the dynamic semantics of the defensive JVM: if the abstract interpreter can do a transition i : (S, R) → (S , R ), then for all concrete states (s, r) matching (S, R), the defensive JVM, started in state (s, r), will not stop on a run-time type violation: it will either loop or transition to a state (s , r ) that matches (S , R ). This correctness property was formalized and proved by several authors, including Pusch <ref type="bibr" target="#b42">[43]</ref> (using the Isabelle/HOL prover), Coglio et al <ref type="bibr" target="#b9">[10]</ref> (using SpecWare), Goldberg <ref type="bibr" target="#b16">[17]</ref> and Qian <ref type="bibr" target="#b43">[44]</ref> (using standard mathematics). </p><formula xml:id="formula_3">i : (S, R) → (S 1 , R 1 ) and i : (S, R) → (S 2 , R 2 ), then S 1 = S 2 and R 1 = R 2 .</formula><p>Property 3 (Monotonicity.) If i : (S, R) → (S , R ), then for all stack types S 1 &lt;: S and register types R 1 &lt;: R, there exists a stack type S 1 and a register type R 1 such that i : (S 1 , R 1 ) → (S 1 , R 1 ), and moreover S 1 &lt;: S and R 1 &lt;: R.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The dataflow analysis</head><p>Verifying a method whose body is a straight-line piece of code (no branches) is easy: we simply iterate the transition function of the abstract interpreter over the instructions, taking the stack type and register type "after" the preceding instruction as the stack type and register type "before" the next instruction. The initial stack and register types reflect the state of the JVM on method entrance: the stack type is empty; the types of the registers 0 . . . n -1 corresponding to the n method parameters are set to the types of the corresponding parameters in the method signature; the other registers n . . . M reg -1 corresponding to uninitialized local variables are given the type . If the abstract interpreter gets "stuck", i.e. cannot make a transition from one of the intermediate states, then verification fails and the code is rejected. Otherwise, verification succeeds, and since the abstract interpreter is a correct approximation of a defensive JVM, we are certain that a defensive JVM will not get stuck either executing the code. Thus, the code is correct and can be executed safely by a regular, non-defensive JVM.</p><p>Branches and exception handlers introduce forks and joins in the control flow of the method. Thus, an instruction can have several predecessors, with different stack and register types "after" these predecessor instructions. Sun's bytecode verifier deals with this situation in the manner customary for data flow analysis: the state (stack type and register type) "before" an instruction is taken to be the least upper bound of the states "after" all predecessors of this instruction. For instance, assume classes D and E extend C, and we analyze a conditional construct that stores a value of type D in register 0 in one arm, and a value of type E in the other arm. (See Figure <ref type="figure">4</ref>.) When the two arms meet, register 0 is assumed to have type C, which is the least upper bound (the smallest common supertype) of D and E.</p><p>More precisely, write instr (p) for the instruction at program point p, in(p) for the state "before" the instruction at p, and out(p) for the state "after" the instruction at p. The verification algorithm sets up the following forward dataflow equations:</p><formula xml:id="formula_4">instr (p) : in(p) → out(p) in(p) = lub{out(q) |</formula><p>q predecessor of p} for every valid program point p, plus in(0) = (ε, (P 0 , . . . , P n-1 , , . . . , ))</p><p>for the entry point (the P k are the types of the method parameters). These equations are then solved by standard fixpoint iteration using Kildall's worklist algorithm <ref type="bibr">[35, section 8.4</ref>]: a program point p is taken from the worklist and its state "after" out(p) is determined from its state "before" in(p) using the abstract interpreter; then, we replace in(q) by lub(in(q), out(p)) for each successor q of p, and enter those successors q for which in(q) changed in the worklist. The fixpoint is reached when the worklist is empty, in which case verification succeeds. Verification fails if a state with no transition is encountered, or one of the least upper bounds is undefined.</p><p>As a trivial optimization of the algorithm above, the dataflow equations can be set up at the level of extended basic blocks rather than individual instructions. In other terms, it suffices to keep in working memory the states in(p) where p is the beginning of an extended basic block (i.e. a branch target); the other states can be recomputed on the fly as needed.</p><p>The least upper bound of two states is taken pointwise, both on the stack types and the register types. It is undefined if the stack types have different heights, which causes verification to fail. This situation corresponds to a program point where the run-time stack can have different heights depending on the path by which the point is reached; such code cannot be proved correct in the framework described in this section, and must be rejected. (See section 6.2 for an alternate verification algorithm that can handle this situation.)</p><p>The least upper bound of two types for a register (or stack slot) can be , causing this register to have type in the merged state. This corresponds to the situation where a register holds values of incompatible types in two arms of a conditional (e.g. int in one arm and an object reference in the other), and therefore is treated as uninitialized (no further loads from this register) after the merge point.</p><p>Several formalizations and proofs (on paper or on machine) of the bytecode verification algorithm described above have been published. Nipkow and Klein's development in Isabell/HOL <ref type="bibr" target="#b37">[38,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b26">27]</ref> is the closest to the dataflow presentation that we gave above. Other formalizations and correctness proofs of the dataflow approach include those of Qian <ref type="bibr" target="#b43">[44]</ref>, Coglio et al <ref type="bibr" target="#b9">[10]</ref>, and Stärk et al <ref type="bibr" target="#b48">[49]</ref>. Bytecode verification can also be specified and proved sound using type systems <ref type="bibr" target="#b50">[51,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b12">13]</ref>; in this framework, the forward dataflow analysis algorithm that we described can be viewed as a type inference algorithm for these type systems. Hartel and Moreau <ref type="bibr" target="#b20">[21]</ref> survey other approaches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Interfaces and least upper bounds</head><p>The dataflow framework presented above requires that the type algebra, ordered by the subtyping relation, constitutes a semi-lattice. That is, every pair of types possesses a smallest common supertype (least upper bound).</p><p>Unfortunately, this property does not hold if we take the verifier type algebra to be the Java source-level type algebra (extended with and null) and the subtyping relation to be the Java source-level assignment compatibility relation. The problem is that interfaces are types, just like classes, and a class can implement several interfaces. Consider the following classes:</p><formula xml:id="formula_5">interface I { ... } interface J { ... } class C1 implements I, J { ... } class C2 implements I, J { ... }</formula><p>The subtyping relation induced by these declarations is:</p><formula xml:id="formula_6">Object I J C1 C2</formula><p>This is obviously not a semi-lattice, since the two types C1 and C2 have two common super-types I and J that are not comparable (neither is subtype of the other).</p><p>There are several ways to address this issue. One approach is to manipulate sets of types during verification instead of single types as we described earlier. These sets of types are to be interpreted as conjunctive types, i.e. the set {I, J}, like the conjunctive type I ∧ J, represents values that have both types I and J, and therefore is a suitable least upper bound for the types {C1} and {C2} in the example above. This is the approach followed in <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b42">43,</ref><ref type="bibr" target="#b48">49]</ref>.</p><p>Another approach is to complete the class and interface hierarchy of the program into a lattice before performing verification <ref type="bibr" target="#b29">[30]</ref>. This is an instance of a general mathematical construction known as the Dedekind-MacNeille completion of a poset. In the example above, the completion would add a point IandJ to the lattice of types, which is a subtype of both I and J, and a supertype of C1 and C2. We then obtain the following semi-lattice:</p><formula xml:id="formula_7">Object I J IandJ C1 C2</formula><p>The additional type IandJ plays the same role as the type set {I, J} in the first approach described above. The difference is that the completion of the class/interface hierarchy is performed once and for all, and verification manipulates only simple types rather than sets of types. This keeps verification simple and fast.</p><p>The simplest solution to the interface problem is to be found in Sun's implementation of the JDK bytecode verifier. (This approach is documented nowhere, but can easily be inferred by experimentation.) Namely, bytecode verification ignores interfaces, treating all interface types as the class type Object. Thus, the type algebra used by the verifier contains only proper classes and no interfaces, and subtyping between proper classes is simply the inheritance relation between them. Since Java has single inheritance (a class can implement several interfaces, but inherit from one class only), the subtyping relation is tree-shaped and trivially forms a semi-lattice: the least upper bound of two classes is simply their closest common ancestor in the inheritance tree.</p><p>The downside of Sun's approach, compared with the set-based or completion-based approach, is that the verifier cannot guarantee statically that an object reference implements a given interface. In particular, the invokeinterface I.m instruction, which invokes method m of interface I on an object, is not guaranteed to receive at run-time an object that actually implements I: the only guarantee provided by Sun's verifier is that it receives an argument of type Object, that is, any object reference. The invokeinterface I.m instruction must therefore check dynamically that the object actually implements I, and raise an exception if it does not.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Verifying object initialization</head><p>Object creation in the Java virtual machine is a two-step process: first, the instruction new C creates a new object, instance of the class C, with all instance fields filled with default values (0 for numerical fields and null for reference fields); second, one of the initialization methods for class C (methods named C.&lt;init&gt; resulting from the compilation of the constructors of class C) must be invoked on the newly created object. Initialization methods, just like their source-level counterpart (constructors), are typically used to initialize instance fields to non-default values, although they can also perform nearly arbitrary computations.</p><p>The JVM specification requires that this two-step object initialization protocol be respected. That is, the object instance created by the new instruction is considered uninitialized, and none of the regular object operations (i.e. store the object in a data structure, return it as method result, access one of its fields, invoke one of its methods) is allowed on this uninitialized object. Only when one of the initialization methods for its class is invoked on the new object and returns normally is the new object considered fully initialized and usable like any other object. (Additional restrictions that we will not discuss here are imposed on initialization methods themselves; see <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b12">13]</ref>.)</p><p>Unlike the register initialization property, this object initialization property is not crucial to ensure type safety at run-time: since the new instruction initializes the instance fields of the new object with correct values for their types, type safety is not broken if the resulting default-initialized object is used right away without having called an initializer method. However, the object initialization property is important to ensure that some invariants between instance fields that is established by the constructor of a class actually hold for all objects of this class.</p><p>Static verification of object initialization is made more complex by the fact that initialization methods operate by side-effect: instead of taking an uninitialized object and returning an initialized object, they simply take an uninitialized object, update its fields, and return nothing. Hence, the code generated by Java compilers for the source-level statement x = new C(arg) is generally of the following form: That is, two references to the uninitialized instance of C are held on the stack. The topmost reference is "consumed" by the invocation of C.&lt;init&gt;. When this initializer returns, the second reference is now at the top of the stack and now references a properly initialized object, which is then stored in the register allocated to x. The tricky point is that the initializer method is applied to one object reference on the stack, but it is another object reference contained in the stack (which happens to reference the same object) whose status goes from "uninitialized" to "fully initialized" in the process. As demonstrated above, static verification of object initialization requires a form of alias analysis (more precisely a must-alias analysis) to determine which object references in the current state are guaranteed to refer to the same uninitialized object that is passed as argument to an initializer method. While any must-alias analysis can be used, Sun's verifier uses a fairly simple analysis, whereas an uninitialized object is identified by the position (program counter value) of the new instruction that created it. More precisely, the type algebra is enriched by the types C p denoting an uninitialized instance of class C created by a new instruction at PC p. An invocation of an initializer method C.&lt;init&gt; checks that the first argument of the method is of type C p for some p, then pops the arguments off the stack type as usual, and finally finds all other occurrences of the type C p in the abstract interpreter state (stack type and register types) and replaces them by C.</p><p>The following example shows how this works for a nested initialization corresponding to the Java expression new C(new C(null)):</p><formula xml:id="formula_8">0: new C // stack type after: C 0 3: dup // C 0 , C 0 4: new C // C 0 , C 0 , C 4 7: dup // C 0 , C 0 , C 4 , C 4 8: aconst_null // C 0 , C 0 , C 4 , C 4 , null 9: invokespecial C.&lt;init&gt; // C 0 , C 0 , C 12: invokespecial C.&lt;init&gt; // C 15: ...</formula><p>In particular, the first invokespecial initializes only the instance created at PC 4, but not the one created at PC 0.</p><p>This approach is correct only if at any given time, the machine state contains at most one uninitialized object created at a given PC. Thus, the verifier must prevent situations where several distinct objects created by the same instruction new C at p can be "in flight": these would be given the same type C p , and initializing one would cause the verifier to assume incorrectly that the others are also initialized. This could potentially happen if a new instruction is executed repeatedly as part of a loop; another example involving subroutines is given in <ref type="bibr" target="#b14">[15]</ref>.</p><p>To avoid this problem, Sun's verifier requires that no uninitialized object type appear in the machine state when a backward branch is taken. Freund and Mitchell <ref type="bibr" target="#b14">[15]</ref> formalize a simpler, equally effective restriction: they propose that when verifying a new C instruction at location p, there must be no occurrence of the type C p in the stack type and register type at p. Bertot <ref type="bibr" target="#b2">[3]</ref> proves the correctness of this approach using the Coq theorem prover, and extracts a verification algorithm from the proof. (Bertot's algorithm is not a standard dataflow analysis, since it features an additional pass of constraint solving.) Both Sun's restriction and Freund and Mitchell's restriction are not monotone, in the sense that raising the type of a register or stack location from C p to can transform an abstract state from which no transitions are possible into an abstract state from which a transition is possible. In other terms, property 3 does not hold, and this causes difficulties with dataflow analysis. To address this issue, a modified formulation of Freund and Mitchell's restriction is introduced in <ref type="bibr" target="#b48">[49]</ref> and used in <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b12">13]</ref>: a new C instruction at location p does not fail if there are occurrences of the type C p in the stack and register types before p; instead, it sets these entries to in the resulting state.</p><p>This suffices to enforce non-aliasing (the unitialized objects whose types were set to cannot be initialized nor used later on), while respecting the monotonicity property. Subroutines, as described in section 5, complicate the verification of object initialization. As discovered by Freund and Mitchell <ref type="bibr" target="#b14">[15]</ref>, a new instruction inside a subroutine can result in distinct uninitialized objects having the same static type C p , thus fooling Sun's verifier into believing that all of them become initialized after invoking an initialization method on one of them. The solution is to prohibit or set to all registers and stack locations that have type C p across a subroutine call.</p><p>Coglio <ref type="bibr" target="#b8">[9]</ref> observes that Sun's restriction on backward branches as well as Freund and Mitchell's restriction on new are unnecessary for a bytecode verifier based on monovariant dataflow analysis. More precisely, [9, section 5.8.2] shows that, in the absence of subroutines, a register or stack location cannot have the type C p just before a program point p containing a new C instruction. Thus, the only program points where uninitialized object types in stack types or register types must be prohibited (or turned into ) are subroutine calls.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Subroutines</head><p>Subroutines in the JVM are code fragments that can be called from several points inside the code of a method. To this end, the JVM provides two instructions: jsr branches to a given label in the method code and pushes a return address to the following instruction; ret recovers a return address (from a register) and branches to the corresponding instruction. Subroutines are used to compile certain exception handling constructs, and can also be used as a general code-sharing device. The difference between a subroutine call and a method invocation is that the body of the subroutine executes in the same activation record as its caller, and therefore can access and modify the registers of the caller.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">The verification problem with subroutines</head><p>Subroutines complicate significantly bytecode verification by dataflow analysis. First, it is not obvious to determine the successors of a ret instruction, since the return address is a first-class value. As a first approximation, we can say that a ret instruction can branch to any instruction that follows a jsr in the method code. (This approximation is too coarse in practice; we will describe better approximations later.) Second, the subroutine entry point acts as a merge point in the control-flow graph, causing the register types at the points of call to this subroutine to be merged. This can lead to excessive loss of precision in the register types inferred, as the example in Figure <ref type="figure" target="#fig_3">5</ref> shows.</p><p>The two jsr 100 at 0 and 52 have 100 as successor. At 0, register 0 has type ; at 52, it has type int. Thus, at 100, register 0 has type (the least upper bound of and int). The subroutine body (between 101 and 110) does not modify register 0, hence its type at 110 is still . The ret 1 at 110 has 3 and 55 as successors (the two instructions following the two jsr 100). Thus, at 55, register 0 has type and cannot be used as an integer by instructions 55 and 56. This code is therefore rejected.</p><p>This behavior is counter-intuitive. Calling a subroutine that does not use a given register does not modify the run-time value of this register, so one could expect that it does not modify the // register 0 uninitialized here 0: jsr 100 // call subroutine at 100 3: ...  The subroutine-based compilation scheme for the try. . . finally construct produces code very much like the above, with a register being uninitialized at one call site of the subroutine and holding a value preserved by the subroutine at another call site. Hence it is crucial that similar code passes bytecode verification. In the remainder of this section and in section 6, we will present refinements of the dataflow-based verification algorithm that achieve this goal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Sun's solution</head><p>We first describe the approach implemented in Sun's JDK verifier. It is described informally in [33, section 4.9.6], and formalized (with various degrees of completeness and faithfulness to Sun's implementation) in <ref type="bibr" target="#b50">[51,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b48">49,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b49">50]</ref>. This approach implements the intuition that a call to a subroutine should not change the types of registers that are not used in the subroutine body.</p><p>First, we need to make precise what a "subroutine body" is: since JVM bytecode is unstructured, subroutines are not syntactically delimited in the code; subroutine entry points are easily detected (as targets of jsr instructions), but it is not immediately apparent which instructions can be reached from a subroutine entry point. Thus, a dataflow analysis is performed, either before or in parallel with the main type analysis. The outcome of this analysis is a consistent labeling of every instruction by the entry point(s) for the subroutine(s) it logically belongs to. From this labeling, we can then determine, for each subroutine entry point , the return instruction Ret( ) for the subroutine, and the set of registers Used ( ) that are read or written by instructions belonging to that subroutine.</p><p>The dataflow equation for subroutine calls is then as follows. Let i be an instruction jsr , and j be the instruction immediately following i. Let (S jsr , R jsr ) = out(i) be the state "after" the jsr, and (S ret , R ret ) = out(Ret( )) be the state "after" the ret that terminates the subroutine. Then:</p><formula xml:id="formula_9">in(j) = S ret , {r → R ret (r) if r ∈ Used ( ) R jsr (r) if r / ∈ Used ( ) }</formula><p>In other terms, the state "before" the instruction j following the jsr is identical to the state "after" the ret, except for the types of the registers that are not used by the subroutine, which are taken from the state "after" the jsr.</p><p>In the example above, we have Ret(100) = 110 and register 0 is not in Used (100). Hence the type of register 0 before instruction 55 (the instruction following the jsr) is equal to the type after instruction 52 (the jsr itself), that is int, instead of (the type of register 0 after the ret 1 at 110).</p><p>While effective in practice, Sun's approach to subroutine verification raises a challenging issue: determining the subroutine structure is difficult. Not only are subroutines not syntactically delimited, but return addresses are stored in general-purpose registers rather than on a subroutinespecific stack, which makes tracking return addresses and matching ret/jsr pairs more difficult. To facilitate the determination of the subroutine structure, the JVM specification states a number of restrictions on correct JVM code, such as "two different subroutines cannot 'merge' their execution to a single ret instruction" [33, section 4.9.6]. These restrictions seem rather ad-hoc and specific to the particular subroutine labeling algorithm that Sun's verifier uses. Moreover, the description of subroutine labeling given in the JVM specification is very informal and incomplete.</p><p>Several rational reconstructions and formalizations of this part of Sun's verifier have been published. The presentations closest to Sun's implementation are due to Qian <ref type="bibr" target="#b43">[44]</ref> and Stärk et al <ref type="bibr" target="#b48">[49]</ref>. A characteristic feature of Sun's implementation, correctly captured by these presentations, is that the subroutine structure and the Used ( ) sets are not determined prior to setting up and solving the dataflow equations, as we suggested above; instead, the types and the Used ( ) sets are inferred simultaneously during the dataflow analysis. This simultaneous computation of types and Used ( ) sets complicates the analysis: as shown by Qian <ref type="bibr" target="#b44">[45]</ref>, the transfer function of the dataflow analysis is no longer monotonous, and special iteration strategies are required to reach the fixpoint.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Other approaches to the verification of subroutines</head><p>Many alternatives to Sun's verification of subroutine have been proposed in the literature, often in the context of small subsets of the JVM, leading to algorithms that are simpler and more elegant, but do not scale to the whole JVM.</p><p>The first formal work on subroutine verification is due to Abadi and Stata <ref type="bibr" target="#b50">[51]</ref>: it relies on a separate analysis, performed before type verification proper, that labels bytecode instructions with the names of the subroutines they belong to, thus reconstructing the subroutine structure. The Used ( ) sets can then be computed for each subroutine , and injected in the dataflow equations as described in section 5.2.</p><p>Later work by Hagiya and Tozawa <ref type="bibr" target="#b19">[20]</ref> also relies on prior determination of the subroutine structure, but expresses the flow of types through subroutines in a different way, using special types last(n) to refer to the type of register n in the caller of the subroutine. The last(n) types behave very much like type variables in a type system featuring parametric polymorphism. In other terms, the subroutine is given a type that is polymorphic over the types of the local variables that it does not use.</p><p>While these works shed considerable light on the issue of subroutines, they are carried in the context of a small subset of the JVM that excludes exceptions and object initialization in particular. The delicate interactions between subroutines and object initialization were discussed in section 4. As for exceptions, exception handling complicates significantly the determination of the subroutine structure. Examination of bytecode produced by a Java compiler shows two possible situations: either an exception handler covers a range of instructions entirely contained in a subroutine, in which case the code of the exception handler should be considered as part of the same subroutine (e.g. it can branch back to the ret instruction that terminates the subroutine); or, an exception handler covers both instructions belonging to a subroutine and non-subroutine instructions, in which case the code of the handler should be considered as outside the subroutine. The problem is that in the second case, we have a branch (via the exception handler) from a subroutine instruction to a non-subroutine instruction, and this branch is not a ret instruction; this situation is not allowed in Abadi and Stata's subroutine labeling system.</p><p>Thus, it is desirable to develop subroutine verification strategies that do not rely on prior determination of the subroutine structure, but instead "discover" this structure during verification. The polyvariant verification algorithms that we discuss next in section 6 satisfy this requirement. O'Callahan <ref type="bibr" target="#b38">[39]</ref> proposes a different approach, based on continuation types: the type assigned to a return address contains the complete stack and register type expected at the program point following the jsr instruction. However, O'Callahan gives only type checking rules, but no effective type inference algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Polyvariant bytecode verification</head><p>In this paper so far, we have presented bytecode verification as a monovariant flow analysis: at each program point, only one abstract state (register type and stack type) is considered. Polyvariant flow analyses, also called context-sensitive analyses [37, section 3.6] lift this restriction: several states are allowed per program point. As we show in this section, polyvariant bytecode verification provides an alternate solution to the subroutine problem of section 5: polyvariant analysis allows instructions inside subroutine bodies to be analyzed several times, e.g. once per call site for the subroutine, without merging the corresponding states like the monovariant analysis of section 3.2 does.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Polyvariant verification based on contours</head><p>The first polyvariant bytecode verification analysis that we describe is based on contours, and is used in the Java Card off-card verifier <ref type="bibr" target="#b52">[53]</ref>. In contour-based polyvariant flow analysis, the distinct states maintained at each program point are indexed by contours that usually approximate the control-flow path that led to each state.</p><p>In the case of bytecode verification, contours are subroutine call stacks: lists of return addresses for the sequence of jsr instructions that led to the corresponding state. In the absence of subroutines, all the bytecode for a method is analyzed in the empty contour. Thus, only one state is associated to each instruction and the analysis degenerates into the monovariant dataflow analysis of section 3.2. However, when a jsr instruction is encountered in the current contour c, it is treated as a branch to the instruction at in the augmented contour .c. Similarly, a ret r instruction is treated as a branch that restricts the current context c by popping one or several return addresses from c (as determined by the type of the register r).</p><p>In the example of Figure <ref type="figure" target="#fig_3">5</ref>, the two jsr 100 instructions are analyzed in the empty context ε. This causes two "in" states to be associated with the instruction at 100; one has contour 3.ε, assigns type to register 0, and contains retaddr(3) at the top of the stack<ref type="foot" target="#foot_0">1</ref> ; the other state has contour 55.ε, assigns type int to register 0, and contains retaddr(55) at the top of the stack. Then, the instructions at 101. . . 110 are analyzed twice, in the two contours 3.ε and 55.ε. In the contour 3.ε, the ret 1 at 110 is treated as a branch to 3, where register 0 still has type . In the contour 55.ε, the ret 1 is treated as a branch to 55 with register 0 still having type int. By analyzing the subroutine body in a polyvariant way, under two different contours, we avoided merging the types and int of register 0 at the subroutine entry point, and thus obtained the desired type propagation behavior for register 0: before and after the jsr 100 at 3, but int before and after the jsr 100 at 52.</p><p>More formally, the polyvariant dataflow equation for a jsr instruction at i followed by an instruction at j is in( , j.c) = (retaddr(j).S, T ) where (S, T ) = out(i, c)</p><p>For a ret r instruction at i, the equation is</p><formula xml:id="formula_10">in(j, c ) = out(i, c)</formula><p>where the type of register r in the state out(i, c) is retaddr(j) and the context c is obtained from c by popping return addresses until j is found, that is, c = c .j.c . Finally, for instructions i other than jsr and ret, the equation is simply</p><formula xml:id="formula_11">i : in(i, c) → out(i, c)</formula><p>that is, the instruction triggers no change of contour. Another way to view polyvariant verification is that it is exactly equivalent to performing monovariant verification on an expanded version of the bytecode where every subroutine call has been replaced by a distinct copy of the subroutine body. Instead of actually taking N copies of the subroutine body, we analyze them N times in N different contours. Of course, duplicating subroutine bodies before the monovariant verification is not practical, because it requires prior knowledge of the subroutine structure (to determine which instructions are part of which subroutine body), and as shown in section 5.3, the subroutine structure is hard to determine exactly. The beauty of the polyvariant analysis is that it determines the subroutine structure along the way, via the computations on contours performed during the dataflow analysis. Moreover, this determination takes advantage of typing information such as the retaddr(ra) types to determine with certainty the point to which a ret instruction branches in case of an early return from nested subroutines.</p><p>Another advantage of polyvariant verification is that it handles code that is reachable both from subroutine bodies and from the main program, such as the exception handlers mentioned in section 5.3: rather than deciding whether such exception handlers are part of a subroutine or not, the polyvariant analysis simply analyzes them several times, once in the empty contour and once or several times in subroutine contours.</p><p>One downside of polyvariant verification is that it is more computationally expensive than Sun's approach. In particular, if subroutines are nested to depth N , and each subroutine is called k times, the instructions from the innermost subroutine are analyzed k N times instead of only once in Sun's algorithm. However, typical Java code has low nesting of subroutines: most methods have N ≤ 1, very few have N = 2, and N &gt; 2 is unheard of. Hence, the extra cost of polyvariant verification is entirely acceptable in practice.  A more serious drawback of this approach is that contour-based polyvariant verification can fail to accept valid JVM code because the subroutine structure that it infers through the construction of contours can be infinite. Consider the Java method shown in Figure <ref type="figure" target="#fig_4">6</ref>, along with the corresponding JVM code. The subroutine at 15 does not terminate by a ret instruction, but by a goto 0 that branches back to the non-subroutine part of the method code. (This branch corresponds to the continue statement in the source code.)</p><p>Polyvariant verification starts by analyzing instructions at 0, 3 and 6 in the empty contour ε. The jsr 15 at 3 causes instructions at 15 and 16 to be analyzed in the contour 15.ε. The goto 0 at 16 does not affect the contour (unlike a ret instruction), thus causing instructions at 0, 3 and 6 to be re-analyzed in the contour 15.ε. Iterating this process, we end up analyzing instructions 0, 3 and 6 in an infinite number of contexts: ε, 15.ε, 15.15.ε, . . . Thus, verification does not terminate.</p><p>Alternatively, termination can be ensured by requiring that contours never contain twice the same subroutine label: a jsr in a contour containing is rejected, in accordance with the JVM specification that states that subroutines cannot be recursive. (This is what the Java Card verifier <ref type="bibr" target="#b52">[53]</ref> does.) But in this case we end up rejecting a valid piece of JVM bytecode, generated by compilation of a valid (albeit artificial) Java program. As demonstrated by this example, using data-independent contours to direct polyvariant verification can cause too many -or even infinitely many -different states to be kept for a given program point, even if these states are exactly identical. (In the example, the states at point 0 in contours 15.ε, 15.15.ε, etc, are all identical.) We now describe an alternate approach to polyvariant verification, not using contours, that avoids these issues.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Model checking of abstract interpretations</head><p>It is folk lore that dataflow analyses can be viewed as model checking of abstract interpretations <ref type="bibr" target="#b47">[48]</ref>. Since a large part of bytecode verification is obviously an abstract interpretation (of a defensive JVM at the type level), it is natural to look at the remaining parts from a model-checking perspective.</p><p>Posegga and Vogt <ref type="bibr" target="#b39">[40]</ref> were the first to do so. They outline an algorithm that takes the bytecode for a method and generates a temporal logic formula that holds if and only if the bytecode is safe. They then use an off-the-shelf model checker to determine the validity of the formula. While this application uses only a small part of the power and generality of temporal logic and of the model checker, the approach sounds interesting for establishing finer properties of the bytecode that go beyond the basic safety properties of bytecode verification (see section 8). The article by <ref type="bibr">Basin et al.</ref> in this volume <ref type="bibr" target="#b1">[2]</ref> explores the model-checking approach to bytecode verification in great details.</p><p>Brisset <ref type="bibr" target="#b3">[4]</ref> and independently Coglio <ref type="bibr" target="#b7">[8]</ref> extract the essence of the "model checking" approach: the idea of exploring all reachable states of the abstract interpreter. They consider the transition relation obtained by combining the transition relation of the type-level abstract interpreter (Figure <ref type="figure" target="#fig_0">2</ref>) with the "successor" relation between instructions. This relation is of the form (p, S, R) → (p , S , R ), meaning that the abstract interpreter, started at PC p with stack type S and register type R, can abstractly execute the instruction at p and arrive at PC p with stack type S and register type R . Additional transitions (p, S, R) → err are introduce to reflect states (p, S, R) in which the abstract interpreter is "stuck" (cannot make a transition because some check failed).</p><formula xml:id="formula_12">(p, S, R) → (p , S , R ) if instr (p) : (S, R) → (S , R ) and p is a successor of p (p, S, R) → err if instr (p) : (S, R) →</formula><p>The BC (Brisset-Coglio) verification algorithm simply explores all states reachable by repeated applications of the extended transition relation starting with the initial state σ 0 = (0, ε, (P 0 , . . . , P n-1 , , . . . , )) corresponding to the method entry. In other terms, writing C(Σ) = Σ ∪ {σ | ∃σ ∈ Σ. σ → σ } for the one-step closure of a set of states Σ, the BC algorithm computes by fixpoint iteration the smallest set Σ c containing σ 0 and closed under C. If err ∈ Σ c , the error state is reachable and the bytecode is rejected. Otherwise, the bytecode passes verification. In the latter case (err is not reachable), the correctness of the abstract interpretation (as proved in <ref type="bibr" target="#b42">[43]</ref>) guarantees that the concrete, defensive JVM interpreter will never fail a safety check during the execution of the method code, hence the bytecode is safe.</p><p>This algorithm always terminates because the number of distinct states is finite (albeit large), since there is a finite number of distinct types used in the program, and the height of the stack is bounded, and the number of registers is fixed.</p><p>The problem with subroutines described in section 5.1 completely disappears in this approach. It suffices to use the following transitions for the jsr and ret instructions:</p><formula xml:id="formula_13">(p, S, R) → ( , retaddr(p + 3).S, R) if instr (p) = jsr (p, S, R) → (q, S, R) if instr (p) = ret r and R(r) = retaddr(q) (p, S, R) → err if instr (p) = ret r and R(r) = retaddr(q)</formula><p>The fact that the BC algorithm never merges the types inferred along two execution paths leading to the same instruction guarantees that subroutine bodies are analyzed as many times as necessary to propagate type information correctly across subroutine calls. However, we will never consider twice the same stack and register types at a given point, thus guaranteeing termination and avoiding the problem with contour-based polyvariance. For instance, the example of Figure <ref type="figure" target="#fig_4">6</ref> that cannot be accepted by contour-based polyvariant verification is now correctly accepted: instructions at 0, 3 and 6 are verified exactly twice, once under the assumption r 0 : , the other under the assumption r 0 : retaddr <ref type="bibr" target="#b2">(3)</ref>.</p><p>Another interest of this approach is that it allows us to reconsider some of the design decisions explained in sections 3.2, 3.3 and 4. In particular, the BC algorithm never computes least upper </p><formula xml:id="formula_14">r 0 : D or r 0 : E r 0 : D r 0 : E r 1 : D r 1 : E r 2 : D r 2 : E . . .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>. , E)</head><p>Figure <ref type="figure">7</ref>: Control-flow joins in the model-checking approach bounds of types, but simply checks subtyping relations between types. Thus, it can be applied to any well-founded subtyping relation, not just relations that form a semi-lattice. Indeed, it can keep track of interface types and verify invokeinterface instructions accurately, without having to deal with sets of types or lattice completion. Similarly, it is possible to verify code where the stack size is not the same on all paths leading to an instruction.</p><p>Brisset <ref type="bibr" target="#b3">[4]</ref> formalized and proved the correctness of this approach in the Coq proof assistant, and extracted the ML code of a bytecode verifier from the proof. Klein and Wildmoser <ref type="bibr" target="#b25">[26]</ref> also prove the correctness of this approach using Isabelle/HOL. Their proof builds on a generic dataflow analysis framework, and thus seems reusable for the variants of the BC algorithm discussed in section 6.3. Coglio <ref type="bibr" target="#b7">[8]</ref> argues that the BC verification algorithm is the most precise of all "reasonable" verification algorithms, in the sense that it accepts all bytecode that does not crash a defensive virtual machine that would follow all execution paths across conditional jumps, regardless of the value of the condition. Thus, the only correct bytecode that could be rejected by the BC algorithm is bytecode whose correctness depends on additional knowledge on the values (and not just the types) of booleans, integers and object references manipulated by the code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Widening in the model checking approach</head><p>The BC verification algorithm based on model checking, described in section 6.2, can be impractical: it runs in time exponential in the number of conditional or N -way branches in the method. Consider the control-flow joint depicted in Figure <ref type="figure">7</ref>, left part. While the dataflow-based algorithms verify the instructions following the join point only once under the assumption r : C where C = lub(D, E), the BC algorithm verifies them twice, once under the assumption r : D, once under the assumption r : E. Consider now the control-flow graph shown in the right part of Figure <ref type="figure">7</ref>. It comprises N such conditional constructs in sequence, each assigning a different type to registers r 1 . . . r N . This causes the instructions following the last conditional to be verified 2 N times under 2 N different register types.</p><p>One way to improve the efficiency of the BC algorithm is to reduce the number of states that need be explored via judicious application of widening steps: some transitions (pc, S, R) → (pc , S , R ) can be replaced by (pc, S, R) → (pc , S , R ) where R &lt;: R and S &lt;: S . If the error state err is still not reachable, the bytecode remains safe. A widening step such as the above reduces the total number of states to be explored if we judiciously choose R and S , e.g. if the widened state (pc , S , R ) is already reachable.</p><p>More formally, define a subtyping relation between states by σ &lt;: err for all states σ, and (p, S, R) &lt;: (p , S , R ) if p = p , S &lt;: S and R &lt;: R . A widening scheme W is a function from sets of states to sets of states, such that for all state σ ∈ Σ, there exists a state σ ∈ W (Σ) such that σ &lt;: σ . Note that this property implies that if err ∈ Σ, then err ∈ W (Σ).</p><p>Bytecode verification by "widened model checking", then, computes by fixpoint iteration of W • C the smallest state set Σ w containing the initial state σ 0 and such that W (C(Σ w )) = Σ w . The bytecode passes verification if and only if err / ∈ Σ w . It is easy to show that all bytecode accepted by a widened model checking algorithm is also accepted by the BC model checking algorithm, and is therefore type-safe at runtime. The proof is given in appendix A.</p><p>As proposed in <ref type="bibr" target="#b22">[23]</ref>, we can construct interesting examples of widening functions from an equivalence relation ≈ determining which states should be merged in a single state, and a merging function M from sets of equivalent states to states such that σ &lt;: M (Σ) for all σ ∈ Σ. The widening function W is then defined by</p><formula xml:id="formula_15">W (Σ) = {M (Σ 1 ), . . . , M (Σ n )}</formula><p>where Σ 1 , . . . , Σ n is a partition of Σ in equivalence classes for the ≈ relation. The W function thus defined is a widening function, since for every σ ∈ Σ, writing Σ i for the equivalence class of σ in Σ, we have σ &lt;:</p><formula xml:id="formula_16">M (Σ i ) ∈ W (Σ).</formula><p>The monovariant dataflow analysis of section 3.2 is a trivial instance of widened model checking where the widening function W merges all stack and register types associated with the same program point by taking their least upper bound. More precisely, the widening function is constructed as described above from the following equivalence relations and merging functions. The equivalence relation ≈ is defined by err ≈ err and (p 1 , S 1 , R 1 ) ≈ (p 2 , S 2 , R 2 ) if and only if p 1 = p 2 . The merging function is defined by</p><formula xml:id="formula_17">M ({err}) = err M ({(p, S 1 , R 1 ), . . . , (p, S n , R n )}) = (p, lub(S 1 , . . . , S n ), lub(R 1 , . . . , R n )) if |S 1 | = . . . = |S n | M ({(p, S 1 , R 1 ), . . . , (p, S n , R n )}) = err, otherwise</formula><p>A more interesting widening function is described by Henrio and Serpette <ref type="bibr" target="#b22">[23]</ref>. Similar ideas were implemented by Frey <ref type="bibr" target="#b15">[16]</ref> and by Coglio <ref type="bibr" target="#b7">[8]</ref>. They propose to merge stack and register types at a given program point if and only if these types agree on return addresses, that is, contain the same retaddr(p) types in the same registers or stack slots, but may differ on non-retaddr types.</p><p>More precisely, we say that two types agree on return addresses if they are equal, or none of them is a retaddr type. Two register types agree on return addresses if the types they assign to every register agree. Two stack types agree on return addresses if they have the same size, and the types they contain agree pointwise. Then, define the equivalence relation ≈ by err ≈ err and (p 1 , S 1 , R 1 ) ≈ (p 2 , S 2 , R 2 ) if and only if p 1 = p 2 and S 1 , S 2 agree on return addresses, and R 1 , R 2 agree on return addresses. The merging function is defined by</p><formula xml:id="formula_18">M ({err}) = err M ({(p, S 1 , R 1 ), . . . , (p, S n , R n )} = (p, lub(S 1 , . . . , S n ), lub(R 1 , . . . , R n ))</formula><p>(By construction of ≈, M is never presented with stack types of different heights.) The CFHS (Coglio-Frey-Henrio-Serpette) verification algorithm, then, corresponds to widened model checking using the widening function induced by the ≈ relation and M merging function.</p><p>In bytecode that contains no subroutines, stack and register types never contain return address types, thus always agree on return addresses; in this case, the CFHS algorithm essentially reduces to standard, efficient monovariant dataflow analysis<ref type="foot" target="#foot_1">2</ref> . In the presence of subroutines, however, sufficient polyvariance is ensured because return address types prevent type merging inside subroutines. In the example of Figure <ref type="figure" target="#fig_3">5</ref>, analysis of the two jsr at 0 and 52 causes two states with pc = 100 to be explored: one has retaddr(3) at the top of the stack type, and as the type of register 0; the other has retaddr(55) at the top of the stack type, and int as the type of register 0. These two states disagree on return addresses (namely, on the top element of the stack type), thus are not merged. This causes the astore_1 at 100 to be analyzed twice, resulting in two states at 101 that are not mergeable either because one has retaddr(3) for register 1 and the other has retaddr(55) for register 1. Thus, the instructions in the subroutine body (from 100 to 110) are given two independent sets of stack and register types, as needed to verify the two subroutine calls with sufficient precision.</p><p>In appendix B, we prove that the CFHS algorithm accepts exactly the same bytecode as the BC algorithm. In other terms, it turns out that the additional merging of type information performed in the CFHS algorithm does not degrade the precision of the analysis. This is a consequence of the following "continuity" property of the type-level abstract interpreter with respect to least upper bounds.</p><p>Property 4 (Continuity.) Assume that the stack types S 1 and S 2 agree on return addresses, and the register types R 1 and R 2 agree on return addresses. Further assume that i : (S 1 , R 1 ) → (S 1 , R 1 ) and i : (S 2 , R 2 ) → (S 2 , R 2 ). Then, i : (lub(S 1 , S 2 ), lub(R 1 , R 2 )) → (lub(S 1 , S 2 ), lub(R 1 , R 2 )).</p><p>7 Bytecode verification on small computers Java virtual machines run not only in personal computers and workstations, but also in a variety of embedded computers, such as personal digital assistants, mobile phones, and smart cards. Extending the Java model of safe post-issuance code downloading to these devices requires that bytecode verification be performed on the embedded system itself. However, bytecode verification is an expensive process that can exceed the resources (processing power and working memory space) of small embedded systems. For instance, a typical Java card (Java-enabled smart card) has 1 or 2 kilo-bytes of working memory, 16 to 32 kilo-bytes of rewritable persistent memory <ref type="foot" target="#foot_2">3</ref> , and an 8-bit microprocessor that is approximately 1000 times slower than a personal computer.</p><p>On such small computing devices, a conventional bytecode verification algorithm (such as Sun's or any of the polyvariant verifiers described in this paper) cannot run in working memory: the amount of RAM available is too small to store the stack and register types inferred during bytecode verification. One avenue is to use persistent rewritable memory instead of RAM to hold the data structures of the verifier. It was long believed that this solution was impractical, because these data structures change rapidly during bytecode verification, resulting in excessive writing times and "wear" on the persistent memory. Recent work by Deville and Grimaud <ref type="bibr" target="#b11">[12]</ref> develops speciallydesigned encodings of types and memory representations of the verification data that alleviate this issue, and suggests that this approach is indeed feasible.</p><p>Another avenue for fitting a bytecode verifier into a small computing device is to design new verification algorithms that can run in tiny amounts of working memory. We now discuss two such algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Lightweight bytecode verification using certificates</head><p>Inspired by Necula and Lee's proof-carrying code <ref type="bibr" target="#b35">[36]</ref>, Rose and Rose <ref type="bibr" target="#b46">[47]</ref> propose to split bytecode verification into two phases: the code producer computes the stack and register types at branch targets and transmit these so-called certificates along with the bytecode; the embedded system, then, simply checks that the code is well-typed with respect to the types given in the certificates, rather than inferring these types itself. In other terms, the embedded system no longer solves iteratively the dataflow equations characterizing correct bytecode, but simply checks (in a single, linear pass over the bytecode) that the types provided in the code certificates are indeed a solution of these equations.</p><p>The benefits of this approach are twofold. First, checking a solution is faster than inferring one, since we avoid the cost of the fixpoint iteration. This speeds up verification to some extent <ref type="foot" target="#foot_3">4</ref> . Second, certificates are only read, but never modified during verification. Hence, they can be stored in persistent rewritable memory without risking to "wear" this memory space by repeated rewriting of the data during verification.</p><p>A practical limitation of this approach is that certificates are relatively large: about 50% of the size of the code they annotate <ref type="bibr" target="#b30">[31]</ref>. Even if certificates are stored in persistent memory, they can still exceed the available memory space.</p><p>Later work by Rose <ref type="bibr" target="#b45">[46]</ref> addresses the issue of the certificate size by noticing that type information for certain branch targets can be omitted from the certificate, as long as this type information is correctly computed by the verification algorithm during its linear scan of the bytecode. This hybrid verification strategy thus reduces the size of the certificate, at the cost of increased working memory requirements to store the inferred type information for branch targets not described in the certificate.</p><p>Lightweight bytecode verification is used in the KVM, one of Sun's embedded variants of the JVM <ref type="bibr" target="#b51">[52]</ref>. It was formalized and proved sound and complete by Klein and Nipkow <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b26">27]</ref>, using the Isabelle/HOL prover. These presentations differ in their treatment of subroutines. Rose's presentation <ref type="bibr" target="#b46">[47,</ref><ref type="bibr" target="#b45">46]</ref> deals only with monovariant verification and does not handle subroutines. The KVM implementation follows this approach, and relies on subroutine expansion before verification, as part of the certificate generation phase. Klein and Nipkow's formalization, however, is applicable not only to monovariant verification, but to any verification algorithm that can be expressed using dataflow equations, including the polyvariant algorithms of section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">On-card verification with off-card code transformation</head><p>The Java Card bytecode verifier described in <ref type="bibr" target="#b30">[31]</ref> attacks the memory problem from another angle. Like the standard bytecode verifiers, it solves dataflow equations using fixpoint iteration. To reduce memory requirements, however, it has only one global register type that is shared between all control points in the method. In other terms, the solution it infers is such that a given register has the same type throughout the method. For similar reasons, it also requires that the expression stack be empty at each branch instruction and at each branch target instruction.</p><p>With these extra restrictions, bytecode verification can be done in space O(M stack + M reg ), instead of O(N branch × (M stack + M reg )) for Sun's algorithm, where N branch is the number of branch targets. In practice, the memory requirements are small enough that all data structures fit comfortably in RAM on a smart card.</p><p>One drawback of this approach is that register initialization can no longer be checked statically, and must be replaced by run-time initialization of registers to a safe value (typically, the value of null) on method entry. Another drawback is that the extra restrictions imposed by the on-card verifier cause perfectly legal bytecode (that passes Sun's verifier) to be rejected.</p><p>To address the latter issue, this verifier relies on an off-card transformation, performed on the bytecode of the applet, that transforms any legal bytecode (that passes Sun's verifier) into equivalent bytecode that passes the on-card verifier. The off-card transformations include stack normalizations around branches and register reallocation by graph coloring, and are described in <ref type="bibr" target="#b30">[31]</ref>.</p><p>These transformations can increase the size of the code, as well as the number of registers used by a method. However, experience shows that these increases are minimal: on typical Java Card code, the increase in code size is less than 2%, and the increase in registers is negligible <ref type="bibr" target="#b30">[31]</ref>.</p><p>This off-card code transformation phase plays a role similar to that of adding certificates in Rose and Rose's approach: both are off-card processing that adds enough information to the applet to facilitate its on-card verification. However, the off-card code transformer embeds directly its information inside the code, via code transformations, instead of storing it into separate certificates. Moreover, the size of the extra information is much smaller (2% vs. 50%).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusions and perspectives</head><p>Java bytecode verification is now a well-researched technique. The considerable body of formal work reviewed in this paper led not only to a precise understanding of what bytecode verification is and what it guarantees, but also to a number of new verification algorithms (besides Sun's original implementation) that cover a large part of the precision/cost spectrum.</p><p>A largely open question is whether bytecode verification can go beyond basic type safety and initialization properties, and statically establish more advanced properties of applets, such as resource usage (bounding the amount of memory allocated) and reactiveness (bounding the running time of an applet between two interactions with the outside world). Controlling resource usage is especially important for Java Card applets: since Java Card does not guarantee the presence of a garbage collector, applets are supposed to allocate all the objects they need at installation time, then run in constant space.</p><p>Other properties of interest include access control and information flow. Currently, the Java security manager performs all access control checks dynamically, using stack inspection <ref type="bibr" target="#b17">[18]</ref>. Various static analyses and program transformations have been proposed to perform some of these checks statically <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b56">57,</ref><ref type="bibr" target="#b41">42]</ref>. In the Java Card world, inter-applet communications via shared objects raises delicate security issues; <ref type="bibr" target="#b6">[7]</ref> applies model-checking technology to this problem. As for information flow (an applet does not "leak" confidential information that it can access), this property is essentially impossible to check dynamically; several type systems have been proposed to enforce it statically <ref type="bibr" target="#b55">[56,</ref><ref type="bibr" target="#b54">55,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b40">41]</ref>.</p><p>Finally, the security of the sandbox model relies not only on bytecode verification, but also on the proper implementation of the API given to the applet. The majority of known applet-based attacks exploit bugs in the API in a type-safe way, rather than breaking type safety through bugs in the verifier. Verification of the API is a promising area of application for formal methods <ref type="bibr" target="#b31">[32,</ref><ref type="bibr" target="#b23">24]</ref>. instruction at p is not a ret instruction, its successors are independent of the stack and register types "before" the instruction; thus, σ 2 → σ 2 . If the instruction at p is ret r, we have R 1 (r) = retaddr(p ). Since σ 2 → err, it must be the case that R 2 (r) is a retaddr type. Moreover, R 1 &lt;: R 2 . This entails R 2 (r) = R 1 (r) = retaddr(p ). Hence, p is the successor of the instruction at p in state (S 2 , R 2 ). The expected result σ 2 → σ 2 follows. 2</p><p>In the following, we write Σ Σ to mean that for all σ ∈ Σ, there exists σ ∈ Σ such that σ &lt;: σ . Choose σ in C(Σ). By definition of C, one of the following two cases holds:</p><p>• σ ∈ Σ. Since Σ Σ , there exists σ ∈ Σ such that σ &lt;: σ . Since Σ ⊆ C(Σ ), it follows that σ is a subtype of an element of C(Σ ).</p><p>• ρ → σ for some ρ ∈ Σ. Let ρ be an element of Σ such that ρ &lt;: ρ . By hypothesis err / ∈ C(Σ ), we have ρ = err and ρ → err. Applying lemma 1, we obtain σ such that ρ → σ and σ &lt;: σ . Moreover, σ ∈ C(Σ ) since σ is obtained by taking one transition from an element of Σ . Since the result above holds for all σ ∈ C(Σ), the expected result follows.</p><p>2 </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B Relative completeness of the CFHS algorithm</head><p>In this appendix, we prove that the CFHS verification algorithm (defined in section 6.3 as an instance of widened model checking) is complete with respect to the BC model-checking algorithm: all programs accepted by the latter algorithm are also accepted by the former. Combined with theorem 1, this result shows that the CFHS algorithm accepts exactly the same programs as the BC algorithm. We recall the definitions that describe the CFHS algorithm: the equivalence relation ≈ is defined by err ≈ err and (p 1 , S 1 , R 1 ) ≈ (p 2 , S 2 , R 2 ) iff p 1 = p 2 and S 1 , S 2 agree on return addresses and R 1 , R 2 agree on return addresses. The merging function M is defined by M ({err}) = err and M ({(p, S 1 , R 1 ), . . . , (p, S n , R n )}) = (p, lub(S 1 , . . . , S n ), lub(R 1 , . . . , R n )). Finally, the widening function W is defined by W (Σ) = {M (Σ 1 ), . . . , M (Σ n )} where Σ 1 , . . . , Σ n is a partition of Σ into equivalence classes for ≈.</p><p>The following key lemma shows that the type-level abstract machine performs parallel transitions from a set of equivalent states and from the single state obtained by merging the equivalent states. In particular, if err is not reachable from the equivalent states, it is not reachable from the merged state either. We write T (Σ) for the states reachable by one transition from a state in Σ, that is, T (Σ) = {σ | ∃σ ∈ Σ. σ → σ }.</p><p>Lemma 3 Let Σ be a non-empty set of equivalent states such that err / ∈ Σ and err / ∈ T (Σ). We then have W (T (Σ)) = T (W (Σ)).</p><p>Proof: Write Σ = {(p, S 1 , R 1 ), . . . , (p, S n , R n )} where the S i agree on return addresses, and the R i also agree on return addresses. Since err / ∈ T (Σ), for every i, there exists S i and R i such that instr (p) : (S i , R i ) → (S i , R i ). According to the continuity property 4, we thus have instr (p) : (lub(S 1 . . . S n ), lub(R 1 . . . R n )) → (lub(S 1 . . . S n ), lub(R 1 . . . R n )). Moreover, by the determinacy property 2, there are no other transitions from these initial states.</p><p>Consider the successors of the instruction at p. If instr(p) is not a ret instruction, these successors p 1 , . . . , p k depend only on instr(p) and are independent of the stack and register types. If instr(p) is a ret r instruction, the successor for the instruction is determined by the retaddr type found in R(r), where R is the register type before the instruction. However, the register types "before" considered in this proof, namely R 1 , . . . , R n and lub(R 1 , . . . , R n ), all agree on return addresses. This means that they all assign the same retaddr type to register r. Thus, the successor for the ret r instruction at p is the same in all these register types, just as in the case of a non-ret instruction at p.</p><p>It follows from this discussion of successors that the set T (Σ) of states reachable by one transition from Σ is exactly the cartesian product of the set of possible successors p 1 , . . . , p k with the set of stack and register types "after" (S 1 , R 1 ), . . . , (S n , R n ), and similarly for T (W (Σ)): T (Σ) = {(p i , S j , R j ) | i ∈ {1, . . . , k}, j ∈ {1, . . . , n}} T (W (Σ)) = {(p i , lub(S 1 . . . S n ), lub(R 1 . . . R n )) | i ∈ {1, . . . , k}} Finally, notice that the stack and register types "after" S 1 , . . . , S n and R 1 , . . . , R n agree on return addresses: if instr (p) is not a jsr instruction, any retaddr type in the state after comes from a matching retaddr type in the state before; if instr (p) is a jsr instruction, the state after contains an additional retaddr(p + 3) type at the top of the stack, but this type is the same in all stack types after. Thus, W (T (Σ)) = {(p i , lub(S 1 . . . S n ), lub(R 1 . . . R n )) | i ∈ {1, . . . , k}}.</p><p>It follows that W (T (Σ)) = T (W (Σ)) as expected.</p><p>2</p><p>We now prove a number of algebraic properties of the M and W functions. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Selected rules for the type-level abstract interpreter. M stack is the maximal stack size and M reg the maximal number of registers.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Some type expressions used by the verifier, with their subtyping relation. C, D, E are user-defined classes, with D and E extending C. Not all types are shown.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>r 0 :Figure 4 :</head><label>04</label><figDesc>Figure 4: Handling joins in the control flow</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: An example of subroutine</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: The problem with contour-based polyvariant verification (left: Java source code; right: corresponding JVM bytecode)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>r n : D r n : E 2 n</head><label>2</label><figDesc>register types (D, . . . , D) to (E, . .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Lemma 2</head><label>2</label><figDesc>Let Σ and Σ be two sets of states such that Σ Σ and err / ∈ C(Σ ). Then, C(Σ) W (C(Σ )). Proof: The relation is transitive, and by hypothesis on the widening function W , we have Σ W (Σ) for all Σ. It therefore suffices to show that C(Σ) C(Σ ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Theorem 1</head><label>1</label><figDesc>Let Σ c be the smallest set closed under C containing σ 0 , and Σ w be the smallest set closed under W •C containing σ 0 . Then, err / ∈ Σ w implies err / ∈ Σ c . In other terms, if the bytecode passes a widened model checking algorithm, it also passes the BC model-checking algorithm. Proof: Write Σ c = n∈N Σ n c and Σ w = n∈N Σ n w , where Σ 0 c = Σ 0 w = {σ 0 } and Σ n+1 c = C(Σ n c ) and Σ n+1 c = W (C(Σ n c )). We now show by induction on n that Σ n c Σ n w . The base case n = 0 is trivial. The inductive case follows from lemma 2, noticing that err / ∈ Σ w implies err / ∈ C(Σ n w ) for all n. It follows that Σ c Σ w . Assume, by way of contradiction, that err ∈ Σ c . Thus, there exists σ ∈ Σ w such that err &lt;: σ. By definition of the &lt;: relation between states, this implies σ = err and contradicts the hypothesis err / ∈ Σ w . Hence err / ∈ Σ c as claimed. 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Lemma 4 2 Lemma 7 2 Theorem 2</head><label>42722</label><figDesc>Let Σ be a non-empty set of equivalent states. Then, M (Σ) is equivalent to every σ ∈ Σ.for j = 1, . . . , k. By lemma 5,M (B j ) = M (∪{A j ∩ Σ i | i ∈ {1 . . . n}, A j ∩ Σ i = ∅}) = M (A j ) It follows that W (W (Σ 1 ) ∪ . . . ∪ W (Σ n )) = {M (B 1 ), . . . , M (B k )} = {M (A 1 ), . . . , M (A k )} = W (Σ 1 ∪ . . . ∪ Σ n )This is the expected result. Let Σ be a set of states such that err / ∈ C(Σ). Then, W (C(Σ)) = W (C(W (Σ))).Proof: Let Σ 1 , . . . , Σ n be a partition of Σ into equivalence classes. By definition of C, we haveC(Σ) = Σ 1 ∪ . . . ∪ Σ n ∪ T (Σ 1 ) ∪ . . . ∪ T (Σ n ).Applying lemma 6, we obtainW (C(Σ)) = W (W (Σ 1 ) ∪ . . . ∪ W (Σ n ) ∪ W (T (Σ 1 )) ∪ . . . ∪ W (T (Σ n ))).It follows from the hypothesis err / ∈ C(Σ) that err / ∈ Σ i and err / ∈ T (Σ i ) for all i = 1, . . . , n. By lemma 3, we thus haveW (T (Σ i )) = T (W (Σ i )). It follows that W (C(Σ)) = W (W (Σ 1 ) ∪ . . . ∪ W (Σ n ) ∪ T (W (Σ 1 )) ∪ . . . ∪ T (W (Σ n ))) = W (C(W (Σ 1 ) ∪ . . . W (Σ n ))) Since Σ 1 , . . . , Σ n is a partition of Σ into equivalence classes, we have W (Σ i ) = {M (Σ i )} and W (Σ) = {M (Σ 1 ), . . . , M (Σ n )} = W (Σ 1 ) ∪ . . . ∪ W (Σ n ).The expected result follows. Let Σ c be the smallest set closed under C containing σ 0 , and Σ w be the smallest set closed under W • C containing σ 0 . Then, err / ∈ Σ c implies err / ∈ Σ w . In other terms, if the bytecode passes the BC algorithm, it also passes the CFHS algorithm.Proof: Write Σ c = n∈N Σ n c and Σ w = n∈N Σ n w , where Σ 0 c = Σ 0 w = {σ 0 } and Σ n+1 c = C(Σ n c ) and Σ n+1 c = W (C(Σ n c )). Assume that err / ∈ Σ c . This implies err / ∈ Σ n c for any n. We now show by induction on n that Σ n w = W (Σ n c ). The base case n = 0 is trivial, since W is the identity function on singleton sets. For the inductive case, assumeΣ n w = W (Σ n c ). Then, Σ n+1 w = W (C(Σ n w )) = W (C(W (Σ n c ))). Note that err / ∈ C(Σ n c ) = Σ n+1 c . Applying lemma 7, it follows that Σ n+1 w = W (C(Σ n c )) = W (Σ n+1 c ),as desired. By construction of the widening function W , for any set of states Σ we have err ∈ W (Σ) if and only if err ∈ Σ. Thus, for any n, we have err / ∈ Σ n w since Σ n w = W (Σ n c ) and err / ∈ Σ n c . It follows that err / ∈ Σ w . 2</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The type retaddr(i) represents a return address to the instruction at i. It is subtype of and itself only.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>One minor difference with monovariant dataflow analysis is that the latter fails if the stack height differs on several paths that reach a given program point, while the CFHS algorithm does not fail immediately in this case, but analyzes the join point and its successors in a polyvariant manner, once per different stack height. At any rate, subroutine-free bytecode that passes monovariant verification also passes the CFHS algorithm, with only one state being considered for each program point.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>Rewritable persistent memory (EEPROM or Flash) is distinct from working memory (RAM) in that writes to the former take 1000-10000 times longer than writes to the latter. Moreover, rewritable persistent memory allows a limited number of writes to the same memory location.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>The speedup is not as important as one might expect, since experiments show that the fixpoint is usually reached after examining every instruction at most twice<ref type="bibr" target="#b30">[31]</ref>.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We thank Alessandro Coglio, Ludovic Henrio, and the anonymous referees for their helpful comments and suggestions for improvements.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Correctness of widened model checking</head><p>In this appendix, we formally prove that all bytecode accepted by a widened model checking algorithm (section 6.3) is also accepted by the BC model checking algorithm (section 6.2, and is therefore type-safe at runtime. In the following, W stands for an arbitrary widening function.</p><p>Lemma 1 Let σ 1 , σ 2 , σ 1 be three states such that σ 1 &lt;: σ 2 and σ 1 → σ 1 . Further assume that σ 2 = err and σ 2 → err. Then, there exists σ 2 such that σ 2 → σ 2 and σ 1 &lt;: σ 2 .</p><p>Proof: We first show that σ 1 = err. Assume, by way of contradiction, that σ 1 → err. This means that σ 1 = (pc, S 1 , R 1 ) and the type-level abstract interpreter cannot make a transition from (S 1 , R 1 ) on instruction instr (pc). By hypotheses σ 1 &lt;: σ 2 and σ 2 = err, we have σ 2 = (pc, S 2 , R 2 ) with S 1 &lt;: S 2 and R 1 &lt;: R 2 . The monotonicity property of the abstract interpreter guarantees that it cannot make a transition from (S 2 , R 2 ) on instr (pc). Thus, σ 2 → err, which is a contradiction.</p><p>Therefore, σ 1 = err, and by definition of the → and &lt;: relations, this implies σ 1 = err and σ 2 = err. We can therefore write</p><p>and the following properties hold:</p><p>By hypothesis σ 2 → err, the abstract interpreter can make a transition on instr (p) from state (S 2 , R 2 ). Let (S 2 , R 2 ) be the result of this transition. The monotonicity and determinacy properties of the type-level abstract interpreter guarantee that S 1 &lt;: S 2 and R 1 &lt;: R 2 . Define σ 2 = (p , S 2 , R 2 ). We thus have σ 1 &lt;: σ 2 .</p><p>To conclude the proof, it remains to show that σ 2 → σ 2 . Since instr (p) : (S 2 , R 2 ) → (S 2 , R 2 ), it suffices to show that p is a valid successor of the instruction at p in state (S 2 , R 2 ). By hypothesis σ 1 → σ 1 , we know that p is a valid successor of the instruction at p in state (S 1 , R 1 ). If the Proof: We first show that if two types τ 1 and τ 2 agree on return addresses, then lub(τ 1 , τ 2 ) agrees on return addresses with both τ 1 and τ 2 . Indeed, either τ 1 = τ 2 , in which case lub(τ 1 , τ 2 ) = τ 1 = τ 2 and the result is obvious; or neither τ 1 nor τ 2 are retaddr types, in which case lub(τ 1 , τ 2 ) is not a retaddr type either, thus agrees with τ 1 and with τ 2 .</p><p>The previous result extends trivially to the least upper bound of one or several stack types, or one or several register types.</p><p>Let Σ be a non-empty set of equivalent states. Either Σ = {err}, or Σ = {(p, S 1 , R 1 ), . . . , (p, S n , R n )}.</p><p>In the former case, M (Σ) = err and the expected result obviously holds. In the latter case, M (Σ) = (p, lub(S 1 , . . . , S n ), lub(R 1 , . . . , R n )). For every i, lub(S 1 , . . . , S n ) and S i agree on return addresses, and lub(R 1 , . . . , R n ) and R i agree on return addresses. Thus, M (Σ) ≈ σ for any σ ∈ Σ.</p><p>2</p><p>Lemma 5 Let Σ 1 , . . . , Σ n be non-empty sets of states such that all states in</p><p>Proof: There are two cases to consider. In the first case, the Σ i are all {err}. In this case, the expected equality trivially holds. In the second case, err does not belong to any Σ i . Write</p><p>We thus have</p><p>By hypothesis, all elements of Σ i are equivalent to all elements of Σ j . By lemma 4, M (Σ i ) is equivalent to all elements of Σ i , and M (Σ j ) is equivalent to all elements of Σ j . By transitivity, it follows that M (Σ i ) ≈ M (Σ j ). This holds for all i, j. We thus have M ({M (Σ 1 ), . . . , M (Σ n )}) = (p, lub i (lub j (S i,j )), lub i (lub j (R i,j ))).</p><p>The expected result follows from the associativity and commutativity of the lub operation. 2</p><p>for all sets of states Σ 1 , . . . , Σ n .</p><p>Proof: Let A 1 , . . . , A k be a partition of Σ 1 ∪ . . . ∪ Σ n into equivalence classes. Thus, for every i,</p><p>Consider two elements of this set, M (A j ∩ Σ i ) and M (A j ∩ Σ i ). By lemma 4, the former is equivalent to every element of A j ∩ Σ i , and the latter to every element of A j ∩ Σ i . Moreover, the A 1 , . . . , A k are disjoint equivalence classes. Hence, M (A j ∩ Σ i ) ≈ M (A j ∩ Σ i ) if and only if j = j . Therefore, the equivalence classes of W (Σ 1 ) ∪ . . . ∪ W (Σ n ) for the ≈ relation are the sets</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A core calculus of dependency</title>
		<author>
			<persName><forename type="first">Martín</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anindya</forename><surname>Banerjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nevin</forename><surname>Heintze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jon</forename><forename type="middle">G</forename><surname>Riecke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">26th symposium Principles of Programming Languages</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="147" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Bytecode verification by model checking</title>
		<author>
			<persName><forename type="first">David</forename><surname>Basin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Friedrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marek</forename><surname>Gawkowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Automated Reasoning. Special issue on</title>
		<imprint/>
	</monogr>
	<note>bytecode verification (this issue</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Formalizing a JVML verifier for initialization in a theorem prover</title>
		<author>
			<persName><forename type="first">Yves</forename><surname>Bertot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Computer Aided Verification (CAV&apos;01)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>Computer Aided Verification (CAV&apos;01)</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2102</biblScope>
			<biblScope unit="page" from="14" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Vers un vérifieur de bytecode Java certifié</title>
		<author>
			<persName><forename type="first">Pascal</forename><surname>Brisset</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Seminar given at Ecole Normale Supérieure</title>
		<imprint>
			<date type="published" when="1998-10-02">October 2nd 1998. 1998</date>
			<pubPlace>Paris</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Klaus Brunnstein. Hostile ActiveX control demonstrated. RISKS Forum</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">82</biblScope>
			<date type="published" when="1997-02">February 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Java Card Technology for Smart Cards: Architecture and Programmer&apos;s Guide. The Java Series</title>
		<author>
			<persName><forename type="first">Zhiqun</forename><surname>Chen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Model checking multi-applet Java Card applications</title>
		<author>
			<persName><forename type="first">Gennady</forename><surname>Chugunov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lars</forename><forename type="middle">Åke</forename><surname>Fredlund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dilian</forename><surname>Gurov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Smart Card Research and Advanced Applications Conference (CARDIS&apos;02)</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Simple verification technique for complex Java bytecode subroutines</title>
		<author>
			<persName><forename type="first">Alessandro</forename><surname>Coglio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">4th ECOOP Workshop on Formal Techniques for Java-like Programs</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
	<note>Extended version available as Kestrel Institute technical report</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Improving the official specification of Java bytecode verification</title>
		<author>
			<persName><forename type="first">Alessandro</forename><surname>Coglio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Concurrency and Computation: Practice and Experience</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="155" to="179" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Towards a provably-correct implementation of the JVM bytecode verifier</title>
		<author>
			<persName><forename type="first">Alessandro</forename><surname>Coglio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Allen</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhenyu</forename><surname>Qian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA Workshop on Formal Underpinnings of Java</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">The defensive Java virtual machine specification</title>
		<author>
			<persName><forename type="first">Richard</forename><surname>Cohen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Computational Logic Inc</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Building an &quot;impossible&quot; verifier on a Java Card</title>
		<author>
			<persName><forename type="first">Damien</forename><surname>Deville</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gilles</forename><surname>Grimaud</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Workshop on Industrial Experiences with Systems Software (WIESS&apos;02)</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A type system for the Java bytecode language and verifier</title>
		<author>
			<persName><forename type="first">Stephen</forename><forename type="middle">N</forename><surname>Freund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Automated Reasoning. Special issue on</title>
		<imprint/>
	</monogr>
	<note>bytecode verification (this issue</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">A formal framework for the java bytecode language and verifier. In Object-Oriented Programming Systems, Languages and Applications</title>
		<author>
			<persName><forename type="first">Stephen</forename><forename type="middle">N</forename><surname>Freund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999. 1999</date>
			<publisher>ACM Press</publisher>
			<biblScope unit="page" from="147" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A type system for object initialization in the Java bytecode language</title>
		<author>
			<persName><forename type="first">Stephen</forename><forename type="middle">N</forename><surname>Freund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1196" to="1250" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">On-terminal verifier for JEFF files</title>
		<author>
			<persName><forename type="first">Alexandre</forename><surname>Frey</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
	<note>Personal communication</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A specification of Java loading and bytecode verification</title>
		<author>
			<persName><forename type="first">Allen</forename><surname>Goldberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Computer and Communications Security</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="49" to="58" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Inside Java 2 platform security: architecture, API design, and implementation</title>
		<author>
			<persName><forename type="first">Li</forename><surname>Gong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">The Java Series</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Java intermediate bytecodes</title>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">A</forename><surname>Gosling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGPLAN Workshop on Intermediate Representations</title>
		<meeting>ACM SIGPLAN Workshop on Intermediate Representations</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="111" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">On a new method for dataflow analysis of Java virtual machine subroutines</title>
		<author>
			<persName><forename type="first">Masami</forename><surname>Hagiya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Akihiko</forename><surname>Tozawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAS&apos;98</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Giorgio</forename><surname>Levi</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1503</biblScope>
			<biblScope unit="page" from="17" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Formalizing the safety of Java, the Java virtual machine and Java Card</title>
		<author>
			<persName><forename type="first">Pieter</forename><forename type="middle">H</forename><surname>Hartel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Luc</surname></persName>
		</author>
		<author>
			<persName><surname>Moreau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="517" to="558" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The SLam calculus: programming with secrecy and integrity</title>
		<author>
			<persName><forename type="first">Nevin</forename><surname>Heintze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jon</forename><forename type="middle">G</forename><surname>Riecke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">25th symposium Principles of Programming Languages</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="365" to="377" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A framework for bytecode verifiers: Application to intra-procedural continuations</title>
		<author>
			<persName><forename type="first">Ludovic</forename><surname>Henrio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernard</forename><surname>Serpette</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Research report</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
	<note>INRIA</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A case study in class library verification: Java&apos;s Vector class</title>
		<author>
			<persName><forename type="first">Marieke</forename><surname>Huisman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bart</forename><surname>Jacobs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joachim</forename><surname>Van Den</surname></persName>
		</author>
		<author>
			<persName><surname>Berg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software Tools for Technology Transfer</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="332" to="352" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Verification of control flow based security properties</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Le Métayer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tommy</forename><surname>Thorn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Verified bytecode subroutines</title>
		<author>
			<persName><forename type="first">G</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wildmoser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Automated Reasoning. Special issue on</title>
		<imprint/>
	</monogr>
	<note>bytecode verification (this issue</note>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Verified Java bytecode verification</title>
		<author>
			<persName><forename type="first">Gerwin</forename><surname>Klein</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
		<respStmt>
			<orgName>Technische Universität München</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Verified lightweight bytecode verification</title>
		<author>
			<persName><forename type="first">Gerwin</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Nipkow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Concurrency and Computation: Practice and Experience</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="1133" to="1151" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Verified bytecode verifiers</title>
		<author>
			<persName><forename type="first">Gerwin</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Nipkow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Type elaboration and subtype completion for Java bytecode</title>
		<author>
			<persName><forename type="first">Todd</forename><surname>Knoblock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jakob</forename><surname>Rehof</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">27th symposium Principles of Programming Languages</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="228" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Bytecode verification for Java smart card</title>
		<author>
			<persName><forename type="first">Xavier</forename><surname>Leroy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software Practice &amp; Experience</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="319" to="340" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Security properties of typed applets</title>
		<author>
			<persName><forename type="first">Xavier</forename><surname>Leroy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">François</forename><surname>Rouaix</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Secure Internet Programming -Security issues for Mobile and Distributed Objects</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Vitek</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Jensen</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1603</biblScope>
			<biblScope unit="page" from="147" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">The Java Virtual Machine Specification. The Java Series</title>
		<author>
			<persName><forename type="first">Tim</forename><surname>Lindholm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Yellin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
	<note>Second edition</note>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Gary</forename><surname>Mcgraw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ed</forename><forename type="middle">Securing</forename><surname>Felten</surname></persName>
		</author>
		<author>
			<persName><surname>Java</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>John Wiley &amp; Sons</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Advanced compiler design and implementation</title>
		<author>
			<persName><forename type="first">Steven</forename><forename type="middle">S</forename><surname>Muchnick</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Morgan Kaufmann</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Proof-carrying code</title>
		<author>
			<persName><forename type="first">George</forename><forename type="middle">C</forename><surname>Necula</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">24th symposium Principles of Programming Languages</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="106" to="119" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Principles of program analysis</title>
		<author>
			<persName><forename type="first">Flemming</forename><surname>Nielson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hanne</forename><surname>Riis Nielson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chris</forename><surname>Hankin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Verified bytecode verifiers</title>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Nipkow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundations of Software Science and Computation Structures (FOSSACS&apos;01)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2030</biblScope>
			<biblScope unit="page" from="347" to="363" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">A simple, comprehensive type system for Java bytecode subroutines</title>
		<author>
			<persName><forename type="first">O'</forename><surname>Robert</surname></persName>
		</author>
		<author>
			<persName><surname>Callahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">26th symposium Principles of Programming Languages</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="70" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Java bytecode verification using model checking</title>
		<author>
			<persName><forename type="first">Joachim</forename><surname>Posegga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Harald</forename><surname>Vogt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop Fundamental Underpinnings of Java</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Information flow inference for ML</title>
		<author>
			<persName><forename type="first">François</forename><surname>Pottier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vincent</forename><surname>Simonet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">29th symposium Principles of Programming Languages</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="319" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">A systematic approach to static access control</title>
		<author>
			<persName><forename type="first">François</forename><surname>Pottier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christian</forename><surname>Skalka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th European Symposium on Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">David</forename><surname>Sands</surname></persName>
		</editor>
		<meeting>the 10th European Symposium on Programming</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2028</biblScope>
			<biblScope unit="page" from="30" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Proving the soundness of a Java bytecode verifier specification in Isabelle/HOL</title>
		<author>
			<persName><forename type="first">Cornelia</forename><surname>Pusch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS&apos;99</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">W</forename><forename type="middle">Rance</forename><surname>Cleaveland</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1579</biblScope>
			<biblScope unit="page" from="89" to="103" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">A formal specification of Java virtual machine instructions for objects, methods and subroutines</title>
		<author>
			<persName><forename type="first">Zhenyu</forename><surname>Qian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Jim</forename><surname>Alves-Foss</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">1523</biblScope>
			<date type="published" when="1998">1998</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
	<note>Formal syntax and semantics of Java</note>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Standard fixpoint iteration for Java bytecode verification</title>
		<author>
			<persName><forename type="first">Zhenyu</forename><surname>Qian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="638" to="672" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">Vérification de code d&apos;octet de la machine virtuelle Java: formalisation et implantation</title>
		<author>
			<persName><forename type="first">Eva</forename><surname>Rose</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002-09">September 2002</date>
		</imprint>
		<respStmt>
			<orgName>University Paris 7</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Lightweight bytecode verification</title>
		<author>
			<persName><forename type="first">Eva</forename><surname>Rose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kristoffer</forename><surname>Rose</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA Workshop on Formal Underpinnings of Java</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Data flow analysis is model checking of abstract interpretations</title>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">A</forename><surname>Schmidt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">25th symposium Principles of Programming Languages</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="38" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">Java and the Java Virtual Machine</title>
		<author>
			<persName><forename type="first">Robert</forename><surname>Stärk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joachim</forename><surname>Schmid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Egon</forename><surname>Börger</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Completeness of a bytecode verifier and a certifying Java-to-JVM compiler</title>
		<author>
			<persName><forename type="first">Robert</forename><forename type="middle">F</forename><surname>Stärk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joachim</forename><surname>Schmid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Automated Reasoning. Special issue on</title>
		<imprint/>
	</monogr>
	<note>bytecode verification (this issue</note>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">A type system for Java bytecode subroutines</title>
		<author>
			<persName><forename type="first">Raymie</forename><surname>Stata</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martín</forename><surname>Abadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="90" to="137" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<title level="m" type="main">Java 2 platform micro edition technology for creating mobile devices</title>
		<ptr target="http://java.sun.com/products/cldc/wp/KVMwp.pdf" />
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
		<respStmt>
			<orgName>Sun Microsystems</orgName>
		</respStmt>
	</monogr>
	<note>White paper</note>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<title level="m" type="main">Off-card bytecode verifier for Java Card</title>
		<author>
			<persName><forename type="first">Trusted</forename><surname>Logic</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
	<note>Distributed as part of Sun&apos;s Java Card Development Kit</note>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">Mobile Agents and Security</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Vigna</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1419</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">A type-based approach to program security</title>
		<author>
			<persName><forename type="first">Dennis</forename><surname>Volpano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Geoffrey</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of TAPSOFT&apos;97, Colloquium on Formal Approaches in Software Engineering</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>TAPSOFT&apos;97, Colloquium on Formal Approaches in Software Engineering</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1214</biblScope>
			<biblScope unit="page" from="607" to="621" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">A sound type system for secure flow analysis</title>
		<author>
			<persName><forename type="first">Dennis</forename><surname>Volpano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Geoffrey</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cynthia</forename><surname>Irvine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Security</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1" to="21" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">A type system for expressive security policies</title>
		<author>
			<persName><forename type="first">David</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">27th symposium Principles of Programming Languages</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="254" to="267" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Low level security in Java</title>
		<author>
			<persName><forename type="first">Frank</forename><surname>Yellin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourth International World Wide Web Conference</title>
		<meeting>the Fourth International World Wide Web Conference</meeting>
		<imprint>
			<biblScope unit="page" from="369" to="379" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<monogr>
		<title/>
		<author>
			<persName><surname>O'reilly</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
