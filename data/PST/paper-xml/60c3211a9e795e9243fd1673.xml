<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Keyword-Based Knowledge Graph Exploration Based on Quadratic Group Steiner Trees</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Yuxuan</forename><surname>Shi</surname></persName>
							<email>yxshi@smail.nju.edu.cn</email>
							<affiliation key="aff0">
								<orgName type="laboratory">State Key Laboratory for Novel Software Technology</orgName>
								<orgName type="institution">Nanjing University</orgName>
								<address>
									<country key="CN">China</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Bosch Center for Artificial Intelligence</orgName>
								<address>
									<settlement>Renningen</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Gong</forename><surname>Cheng</surname></persName>
							<email>gcheng@nju.edu.cn</email>
							<affiliation key="aff0">
								<orgName type="laboratory">State Key Laboratory for Novel Software Technology</orgName>
								<orgName type="institution">Nanjing University</orgName>
								<address>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Trung-Kien</forename><surname>Tran</surname></persName>
							<email>trungkien.tran@de.bosch.com</email>
							<affiliation key="aff1">
								<orgName type="department">Bosch Center for Artificial Intelligence</orgName>
								<address>
									<settlement>Renningen</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jie</forename><surname>Tang</surname></persName>
							<email>jietang@tsinghua.edu.cn</email>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Science and Technology</orgName>
								<orgName type="institution">Tsinghua University</orgName>
								<address>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Evgeny</forename><surname>Kharlamov</surname></persName>
							<email>evgeny.kharlamov@de.bosch.com</email>
							<affiliation key="aff1">
								<orgName type="department">Bosch Center for Artificial Intelligence</orgName>
								<address>
									<settlement>Renningen</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="department">Department of Informatics</orgName>
								<orgName type="institution">University of Oslo</orgName>
								<address>
									<country key="NO">Norway</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Keyword-Based Knowledge Graph Exploration Based on Quadratic Group Steiner Trees</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T13:16+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Exploring complex structured knowledge graphs (KGs) is challenging for non-experts as it requires knowledge of query languages and the underlying structure of the KGs. Keyword-based exploration is a convenient paradigm, and computing a group Steiner tree (GST) as an answer is a popular implementation. Recent studies suggested improving the cohesiveness of an answer where entities have small semantic distances from each other. However, how to efficiently compute such an answer is open. In this paper, to model cohesiveness in a generalized way, the quadratic group Steiner tree problem (QGSTP) is formulated where the cost function extends GST with quadratic terms representing semantic distances. For QGSTP we design a branch-and-bound best-first (B 3 F) algorithm where we exploit combinatorial methods to estimate lower bounds for costs. This exact algorithm shows practical performance on medium-sized KGs.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>A knowledge graph (KG) is a collection of annotated and interconnected entities. By offering a flexible way to structure and integrate information, KGs have been widely used in AI applications. Consider a sample KG in Fig. <ref type="figure" target="#fig_0">1</ref> which describes various relations between physicists, institutions, and cities. Task. When a user such as a data journalist looks into a machine-readable KG, a fundamental task is KG exploration. Users often explore a complex structured KG with difficulty. For those who lack expertise in formulating formal queries or whose vague information needs can hardly be formalized, machine-assisted KG exploration is crucial <ref type="bibr" target="#b12">[Lissandrini et al., 2020]</ref>. While various AI-empowered methods have been devised to support this task, such as KG summarization <ref type="bibr" target="#b1">[Cheng et al., 2016;</ref><ref type="bibr" target="#b2">Cheng et al., 2017a]</ref> and relevance-based entity recommendation <ref type="bibr" target="#b7">[Gu et al., 2019;</ref><ref type="bibr" target="#b16">Zhou et al., 2020]</ref>, the most commonly adopted user interface is based on keyword queries: a user explores a KG by easily submitting a set of keywords expressing an information need. State-of-the-art methods <ref type="bibr" target="#b13">[Shi et al., 2020]</ref> efficiently find and present an optimum subgraph extracted from the KG that contains all the keywords in the query. For example, Fig. <ref type="figure" target="#fig_0">1</ref> shows two extracted subgraphs T 1 and T 2 for answering the query "melvin schwartz, emil wolf". An optimum subgraph will be computed and returned as an answer. Motivation. In the literature it was standard to assign weights to vertices or edges in a KG and then compute a minimum-weight connected subgraph that contains all the keywords in a query as an optimum answer <ref type="bibr" target="#b6">[Ding et al., 2007;</ref><ref type="bibr" target="#b10">Li et al., 2016;</ref><ref type="bibr" target="#b13">Shi et al., 2020]</ref>, aka a group Steiner tree (GST) <ref type="bibr" target="#b8">[Ihler, 1991]</ref>. The underlying assumption is: an aggregation of salient graph elements (i.e., with small weights) constitute a good answer. However, the assumption has recently been challenged: by analyzing industrial KGs, it was suggested to improve the cohesiveness of an answer where entities (i.e., vertices) have small semantic distances from each other <ref type="bibr">[Cheng and Kharlamov, 2017</ref>], e.g., having similar types, textual annotations, or topics. The suggestion has been supported by empirical studies focusing on different concrete measures of semantic distance <ref type="bibr" target="#b3">[Cheng et al., 2017b;</ref><ref type="bibr" target="#b0">Bryson et al., 2020]</ref>. As an example, T 2 in Fig. <ref type="figure" target="#fig_0">1</ref> is an uninteresting mixture of disparate entities despite their salience, while T 1 cohesively and meaningfully describes physicists and their advisors. Although the effectiveness of such cohesive answers in KG exploration has been accepted, one problem remains: how to efficiently compute a cohesive answer. This is our research target in this paper. Quadratic GST problem. The standard GST problem minimizes the total weight of the vertices or edges in a sub-graph. This cost function cannot model implicit relationships between graph elements such as semantic distances. Recently we have extended it to calculate the total weight of graph elements and their semantic distances <ref type="bibr" target="#b13">[Shi et al., 2021]</ref>. This extended optimization problem is referred to as the quadratic group Steiner tree problem (QGSTP) since semantic distance is a quadratic term involving two graph elements. QGSTP is fundamentally more difficult than the GST problem. Indeed, quadratic terms are harder to optimize. Moreover, weights and semantic distances require joint optimization while their values could be independent from each other. Algorithm B 3 F. To solve QGSTP, we design an exact algorithm named B 3 F that guarantees to find an optimum solution. B 3 F is an iterative branch-and-bound algorithm and it performs best-first search in each iteration. We define a branch of the search space as a set of subgraphs that subsume a common path. We leverage the path to develop a lower bound estimation for the costs of the subgraphs in the branch, where we manipulate and integrate combinatorial methods including set covering and maximum matching. Contributions. Below we summarize our contributions.</p><p>• We design the first exact algorithm B 3 F for QGSTP. We significantly prune the search space of B 3 F by devising an effective lower bound estimation for costs. • We conduct extensive experiments on public KGs and queries. B 3 F computes more cohesive answers than the classical GST and it runs in comparable time.</p><p>2 Related Work</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">GST-Based Exploration</head><p>Keyword-based KG exploration has been commonly formulated as a GST problem to extract a minimum-weight tree that contains all the keywords in a query <ref type="bibr" target="#b6">[Ding et al., 2007;</ref><ref type="bibr" target="#b10">Li et al., 2016;</ref><ref type="bibr" target="#b13">Shi et al., 2020]</ref>, or as a variant of this problem <ref type="bibr">[Kargar and An, 2011;</ref><ref type="bibr" target="#b9">Le et al., 2014;</ref><ref type="bibr" target="#b15">Yang et al., 2019]</ref>. They assume that aggregating salient graph elements with small weights produces a good answer, but they ignore the semantic relationships between elements. Indeed, a set of salient elements may not form a semantically cohesive subgraph and hence not a meaningful answer. Our work extends this line of research by incorporating semantic distances between elements and formulating QGSTP to compute cohesive answers. Our cost function contains quadratic terms that are harder to optimize.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Cohesiveness Computation</head><p>The above shortcoming of GST-based exploration has been noticed when researchers processed industrial KGs and they suggested computing cohesive answers <ref type="bibr">[Cheng and Kharlamov, 2017]</ref>. The suggestion is supported by a user study where a concrete measure of semantic distance was implemented based on entity types <ref type="bibr" target="#b3">[Cheng et al., 2017b]</ref>. By comparing pairs of answers, users preferred more cohesive answers where entities have similar types. Another implemented measure of semantic distance relies on random walk with restart <ref type="bibr" target="#b0">[Bryson et al., 2020]</ref>, to which a specific heuristic algorithm was presented to compute such cohesive answers.</p><p>Our work addresses efficient computation of cohesive answers, which is not considered in <ref type="bibr">[Cheng and Kharlamov, 2017;</ref><ref type="bibr" target="#b3">Cheng et al., 2017b]</ref>. Our algorithm computes an optimum solution to QGSTP while the algorithms in <ref type="bibr" target="#b0">[Bryson et al., 2020;</ref><ref type="bibr" target="#b13">Shi et al., 2021]</ref> cannot guarantee to find an optimum solution. Regarding other studies of "cohesiveness" in graph search and exploration <ref type="bibr">[Dass et al., 2015;</ref><ref type="bibr" target="#b17">Zhu et al., 2018]</ref>, their definitions are orthogonal to ours.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Query Interpretation</head><p>To interpret a keyword query (or a natural language question) for KG exploration, one popular approach is to transform the keyword query into a formal query and then execute the formal query over a standard query engine <ref type="bibr" target="#b14">[Tran et al., 2009;</ref><ref type="bibr" target="#b12">Pound et al., 2012;</ref><ref type="bibr" target="#b12">Shekarpour et al., 2013;</ref><ref type="bibr">Sun et al., 2020]</ref>. The formal query is typically a graph pattern that formally represents the meaning of the keyword query and is matched with the KG to retrieve answers.</p><p>Our work is suitable for vague information needs that can hardly be interpreted as a precise graph pattern, e.g., exploring relationships between a set of entities <ref type="bibr">[Cheng, 2020;</ref><ref type="bibr" target="#b11">Li et al., 2020;</ref><ref type="bibr" target="#b5">Cheng et al., 2020]</ref>. The above transformationbased methods are targeted at information lookup where there is a specific query intent that can be represented by a graph pattern. The two lines of research are complementary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Problem</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Preliminaries</head><p>A KG is a directed graph denoted by G = V, E , where V is a set of vertices representing entities, and E ⊆ V × V is a set of directed edges representing relations between entities. We allow the edges in a path/tree to be in different directions.</p><p>Let K be the set of all keywords. A matching function hits : K → 2 V maps each keyword to a subset of vertices. The concrete implementation of hits, e.g., either syntactically or semantically matching keywords with vertex annotations, is not our focus. For simplicity our formulation omits edge mapping but it can be transformed into vertex mapping: for each edge (u, v) we create a vertex w with the annotation of (u, v); then replace (u, v) by two edges (u, w) and (w, v). A query Q ⊆ K is a set of g keywords Q = {k 1 , . . . , k g }. To ease the notation we write hits(k i ) as K i for 1 ≤ i ≤ g. We call K i keyword vertices.</p><p>Similar to the GST problem <ref type="bibr" target="#b8">[Ihler, 1991]</ref>, given G = V, E we define a feasible answer to Q as a subgraph of G denoted by T = V T , E T such that: (1) T is connected, (2) T contains at least one keyword vertex from each K i for 1 ≤ i ≤ g, and (3) T is structurally minimal for (1) and (2), i.e., none of its proper subgraphs satisfy both (1) and ( <ref type="formula">2</ref>), so T is a tree where leaf vertices must be keyword vertices. For example, T 1 and T 2 in Fig. <ref type="figure" target="#fig_0">1</ref> are two feasible answers to the query "melvin schwartz, emil wolf".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Problem Formulation</head><p>Let wt(v) be the non-negative weight of vertex v; small wt represents salience. Let sd(v i , v j ) be the non-negative semantic distance between vertices v i and v j ; small sd represents cohesiveness. The concrete computation of wt and sd is independent from our approach. The cost of a feasible answer T = V T , E T is the total weight of its vertices and their semantic distances:</p><formula xml:id="formula_0">cost(T ) = α v∈V T wt(v) + (1 − α) v i ,v j ∈V T i&lt;j sd(v i , v j ) ,</formula><p>(1) where α ∈ [0, 1] is a parameter. An optimum answer is a feasible answer that minimizes cost. This optimization problem is referred to as the quadratic group Steiner tree problem (QGSTP) <ref type="bibr" target="#b13">[Shi et al., 2021]</ref>. It extends the cost function of the vertex-weighted GST problem <ref type="bibr" target="#b8">[Ihler, 1991;</ref><ref type="bibr" target="#b9">Klein and Ravi, 1995]</ref> by introducing a quadratic term sd(v i , v j ) representing an extra cost that will be paid if two vertices v i and v j are both included in T .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Problem Complexity</head><p>Theorem 1. QGSTP is an NP-hard optimization problem.</p><p>Proof. We can reduce two NP-hard problems to QGSTP.</p><p>It is straightforward to reduce the vertex-weighted Steiner tree problem to an instance of QGSTP where α = 1 and</p><formula xml:id="formula_1">|K i | = 1 for 1 ≤ i ≤ g.</formula><p>Alternatively, we reduce the quadratic set cover problem to an instance of QGSTP where α = 1 − α and vertices in G are pairwise adjacent. Thus, sets containing an element correspond to vertices mapped to from a keyword.</p><p>Compared with the vertex-weighted GST problem, QGSTP is more difficult due to the extended optimization of the quadratic sd which is independent from wt. For example, vertices that are adjacent in KGs can be semantically distant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Approach</head><p>QGSTP is an NP-hard optimization problem, for which a brute-force algorithm would be computationally prohibitive even on small KGs. We present a Branch-and-Bound Best-First algorithm, abbreviated to B 3 F. It is the first exact algorithm for QGSTP. As we will see in the experiments it shows promising performance on medium-sized KGs.</p><p>Before presenting B 3 F, we define some terms. For path p, its length len(p) is the number of edges in p. The distance between two vertices is the length of a shortest path connecting them. The eccentricity of vertex v is the greatest distance between v and other vertices. The radius and diameter of graph T , denoted by rad(T ) and diam(T ), are the minimum and maximum eccentricity of the vertices in T , respectively. A central vertex is a vertex of minimum eccentricity. For two graphs T and T , we write T T if T is a subgraph of T .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Basic Idea</head><p>In general, B 3 F iteratively explores the search space in a topdown manner (i.e., branching). Branches where feasible answers cannot be better than the optimal answer found so far are discarded (i.e., bounding). In each iteration, the most promising branch is explored (i.e., best-first). Answer construction. B 3 F constructs a feasible answer by merging g paths p 1 , . . . , p g where each p i starts from a keyword vertex in K i and they end at a common vertex. For example, T 1 in Fig. <ref type="figure" target="#fig_0">1</ref>  Branching. Each path p defines a branch of the search space where each feasible answer T satisfies p T . A longer path defines a smaller search space; thus, path growing corresponds to branching. B 3 F iteratively enumerates paths that grow from keyword vertices. For each enumerated path p, we estimate cost(p). It is a lower bound for the costs of the feasible answers in the branch defined by p:</p><formula xml:id="formula_2">Algorithm 1 B 3 F Input: G = V, E , Q = {k 1 , . . . , k g },</formula><formula xml:id="formula_3">cost(p) ≤ min T : p T cost(T ) .</formula><p>(2)</p><p>Best-first search and bounding. B 3 F performs best-first search. In each iteration, it processes an enumerated path p top that minimizes cost. If cost(p top ) ≥ cost(T opt ) where T opt denotes the optimal answer found so far, B 3 F will be terminated and return T opt ; such bounding discards all feasible answers in the unprocessed branches. If cost(p top ) &lt; cost(T opt ), new feasible answers will be constructed by merging p top with other processed paths that end at the same vertex as p top ; then T opt may be updated. B 3 F completes the current iteration by growing p top to enumerate longer paths.</p><p>4.2 Algorithm B 3 F B 3 F is detailed in Algorithm 1. Following common practice <ref type="bibr" target="#b9">[Kacholia et al., 2005;</ref><ref type="bibr" target="#b3">Cheng et al., 2017b]</ref>, we introduce an extra input d representing the largest allowed depth of search to prevent large subgraphs (i.e., diam &gt; 2d) which are not favored by users <ref type="bibr" target="#b3">[Cheng et al., 2017b]</ref>.</p><p>T opt denotes the optimal answer found so far (line 1). Paths to be processed are kept in priority queue P U and sorted by their cost values in ascending order (line 2); we will elaborate the computation of cost in Section 4.4. Paths that grow from keyword vertices are iteratively enumerated. Initially, each keyword vertex is treated as a path of length zero and inserted into P Q to be processed (lines 3-4). For each keyword k i ∈ Q, we maintain the set P i of processed paths that contain a keyword vertex in K i (lines 5-6).</p><p>In each iteration (line 7), p top which minimizes cost in P Q is pulled to process (line 8). If cost(p top ) ≥ cost(T opt ), the algorithm will be terminated (lines 9-10). Otherwise, p top is added to each proper P i (lines 11-12). Specifically, V ptop is the set of vertices in p top , and we define</p><formula xml:id="formula_4">QK(Vp top ) = {ki ∈ Q : Vp top ∩ Ki = ∅} .</formula><p>(3)</p><p>New feasible answers are constructed with p top . We consider each combination of paths in P 1 × • • • × P g such that p top is in this combination where all the paths have a common end vertex (line 13). They are merged into a subgraph T which clearly is connected and covers all the keywords in Q (line 14). If T is also structurally minimal (line 15), i.e., it is a feasible answer, and its cost is smaller than cost(T opt ) (line 16), it will replace T opt (line 17).</p><p>Longer paths are enumerated by growing p top with one edge (lines 19-20), and are inserted into P Q to be processed (line 21). Growing is conditioned on the length of p top (line 18), subject to the largest allowed depth of search.</p><p>Finally, T opt is an optimum answer and is returned (line 22).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Algorithm Analysis</head><p>Correctness. Consider Lemma 2 which decomposes a feasible answer into a set of paths.</p><p>Lemma 2. Every feasible answer T s.t. diam(T ) ≤ 2d can be constructed by merging g paths p 1 , . . . , p g such that for 1 ≤ i ≤ g: (1) len(p i ) ≤ d, (2) the start vertex of p i is in K i , and (3) all p i have a common end vertex.</p><p>Proof. Since T = V T , E T is a tree, it is known in graph theory that:</p><formula xml:id="formula_5">rad(T ) = diam(T )+1 2 ≤ 2d+1 2 = d.</formula><p>Therefore, T has a central vertex c that is at most d hops away from every vertex in T . For 1 ≤ i ≤ g, since V T ∩ K i = ∅, we choose v i ∈ V T ∩ K i and let p i be the unique path between v i and c in T . All such p i satisfy (1)-(3) of the lemma, and by merging them we can construct T .</p><p>The correctness theorem follows directly from Lemma 2. Theorem 3. B 3 F returns an optimum answer s.t. diam ≤ 2d.</p><p>Proof. Consider a variant of B 3 F where we fix cost = −∞; thus branches are never discarded. When this variant is finished, P 1 , . . . , P k contain all possible paths that start from keyword vertices and are at most d long. All their combinations have been used to construct feasible answers, including the combination that produces an optimum answer according to Lemma 2. Therefore, T opt is an optimum answer. Now consider the standard version of B 3 F where cost is properly estimated. When it is terminated early, according to the definition of cost, it is impossible to discard a feasible answer better than T opt , so T opt is an optimum answer. To construct feasible answers, O(n g(d+1) ) combinations of paths are merged. Each combination uses O(gd + 1) time for merging and O((gd + 1) 2 ) time for calculating cost, assuming O(1) for computing sd. Therefore, finding an optimum answer takes O((gd + 1) 2 n g(d+1) ) time. The total time complexity of B 3 F is O(n d+1 (d + 1) log n + (gd + 1) 2 n g(d+1) ). It increases exponentially with g and d, which are very small in practice. By early termination based on our lower bound estimation of cost described in Section 4.4, B 3 F can achieve promising performance on medium-sized KGs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Lower Bound Estimation</head><p>For path p = V p , E p , properly estimating cost(p) is the key to the performance of B 3 F and is one of our main technical contributions. To ensure Eq. ( <ref type="formula">2</ref>), we analyze the cost of an arbitrary feasible answer T = V T , E T that satisfies p T . For convenience, we decompose the cost function in Eq. (1):</p><formula xml:id="formula_6">cost(T ) = α • costwt(T ) + (1 − α) • costsd(T ) , where costwt(T ) = v∈V T wt(v) , costsd(T ) = v i ,v j ∈V T s.t. i&lt;j</formula><p>sd(vi, vj) .</p><p>(4) We will separately estimate a lower bound for each part. Note that the estimated bounds must be independent from T . Moreover, the estimation per se should be computationally inexpensive to improve the overall performance of B 3 F.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lower Bound Estimation for cost wt (T )</head><p>We expand cost wt (T ) in Eq. ( <ref type="formula">4</ref>):</p><formula xml:id="formula_7">costwt(T ) = v∈Vp wt(v) + v∈(V T \Vp) wt(v) .</formula><p>(5)</p><p>The first sum is independent from T and is directly calculated. For the second sum, we estimate its lower bound using the smallest total weight of other vertices besides V p that are needed for T to cover all the keywords in Q. The computation of this total weight is formulated as the following instance of the weighted set cover problem (WSCP):</p><p>universe of elements:</p><formula xml:id="formula_8">Q \ QK(Vp) , sets of elements: each ∅ ⊂ Q ⊆ (Q \ QK(Vp)) s.t. ∃v ∈ V, QK({v}) \ QK(Vp) = Q ,</formula><p>weights of sets:</p><formula xml:id="formula_9">min v∈V : QK({v})\QK(Vp)=Q wt(v) for Q . (<label>6</label></formula><formula xml:id="formula_10">)</formula><p>Let Q opt be an optimum solution to Eq. ( <ref type="formula" target="#formula_9">6</ref>) computed by dynamic programming. The total weight of the sets in Q opt forms a lower bound for the second sum in Eq. ( <ref type="formula">5</ref>). To conclude, we estimate the following lower bound for cost wt (T ):</p><formula xml:id="formula_11">costwt(T ) ≥ v∈Vp wt(v) + Q ∈Q opt min v∈V : QK({v})\QK(Vp)=Q wt(v) ,<label>(7)</label></formula><p>which is independent from T .</p><p>Although WSCP is NP-hard, there are at most (2 g − 1) unique instances of WSCP to solve, where g is the number of keywords in Q; each instance takes a unique proper subset of Q as the universe. Since g is very small in practice, both the number of unique instances of WSCP and the size of each instance are small. Therefore, in practice the time for the above estimation is relatively neglectable in B 3 F.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lower Bound Estimation for cost sd (T )</head><p>We assume sd satisfies symmetry and triangle inequality. We expand cost sd (T ) in Eq. ( <ref type="formula">4</ref>):</p><formula xml:id="formula_12">costsd(T ) ≥ v i ,v j ∈Vp s.t. i&lt;j sd(vi, vj) + v i ∈(V T \Vp), v j ∈Vp sd(vi, vj) ≥ v i ,v j ∈Vp s.t. i&lt;j sd(vi, vj) + r • min v i ∈V v j ∈Vp sd(vi, vj) .</formula><p>(8) The first sum is independent from T and is directly calculated. In the second sum, r represents the smallest number of other vertices besides V p that are needed for T to cover all the keywords in Q. The computation of r is formulated as the following instance of the set cover problem (SCP):</p><formula xml:id="formula_13">universe of elements: Q \ QK(Vp) , sets of elements: each ∅ ⊂ Q ⊆ (Q \ QK(Vp)) s.t. ∃v ∈ V, QK({v}) \ QK(Vp) = Q . (9)</formula><p>Let Q opt be an optimum solution to Eq. ( <ref type="formula">9</ref>) computed by dynamic programming. The number of sets in Q opt forms r in Eq. ( <ref type="formula">8</ref>), i.e., r = |Q opt |.</p><p>To estimate a lower bound for the minimum in Eq. ( <ref type="formula">8</ref>), our idea is: for v i ∈ V , its semantic distance from some vertices in V p may be very small, but its total semantic distance from all the vertices in V p cannot be arbitrarily small due to triangle inequality. Therefore, we construct a complete undirected graph H where vertices are V p and the edge between v i , v j ∈ V p has weight sd(v i , v j ). Let M be a maximum weighted matching in H, which puts 2 |Vp| 2 vertices in pairs. Let M be the sum of edge weights in M . Since sd satisfies triangle inequality, we have</p><formula xml:id="formula_14">M ≤ min v i ∈V v j ∈Vp sd(vi, vj) .<label>(10)</label></formula><p>Now we can turn to estimate a lower bound for M . When |V p | is even, the edges in H can be partitioned into |V p | − 1 perfect matchings according to graph theory, so</p><formula xml:id="formula_15">M ≥ v i ,v j ∈Vp s.t. i&lt;j sd(vi, vj) |Vp| − 1 .<label>(11)</label></formula><p>When |V p | is odd, let H k be the subgraph of H from which v k ∈ V p and its incident edges are removed. Let M k be a maximum weighted matching in H k , and let M k be the sum of edge weights in M k . For each v k ∈ V p , we have</p><formula xml:id="formula_16">v i ,v j ∈Vp s.t. i&lt;j sd(vi, vj) = v i ,v j ∈(Vp\{v k }) s.t. i&lt;j sd(vi, vj) + v∈(Vp\{v k }) sd(v, v k ) .<label>(12)</label></formula><p>Summing this equation over all v k ∈ V p , we have</p><formula xml:id="formula_17">|Vp| v i ,v j ∈Vp s.t. i&lt;j sd(vi, vj) = v k ∈Vp ( v i ,v j ∈(Vp\{v k }) s.t. i&lt;j sd(vi, vj) + v∈(Vp\{v k }) sd(v, v k )) = v k ∈Vp v i ,v j ∈(Vp\{v k }) s.t. i&lt;j sd(vi, vj) + 2 v i ,v j ∈Vp s.t. i&lt;j sd(vi, vj) ,<label>(13)</label></formula><p>from which we obtain</p><formula xml:id="formula_18">v i ,v j ∈Vp s.t. i&lt;j sd(vi, vj) = v k ∈Vp v i ,v j ∈(Vp\{v k }) s.t. i&lt;j sd(vi, vj) |Vp| − 2 ≤ v k ∈Vp M k ≤ |Vp| • M ,<label>(14)</label></formula><p>that is,</p><formula xml:id="formula_19">M ≥ v i ,v j ∈Vp s.t. i&lt;j sd(vi, vj) |Vp| .<label>(15)</label></formula><p>Combining Eqs. (8)(10)(11)(15), we estimate the following lower bound for cost sd (T ):</p><formula xml:id="formula_20">costsd(T ) ≥ (1 + |Q opt | 1 + 2 |Vp|−1 2 ) v i ,v j ∈Vp s.t. i&lt;j sd(vi, vj) ,<label>(16)</label></formula><p>which is independent from T . In practice, the time for the above estimation is relatively neglectable in B 3 F because: first, following our analysis about WSCP, the time for computing |Q opt | is relatively neglectable; second, the sum in Eq. ( <ref type="formula" target="#formula_20">16</ref>) can be incrementally calculated when p is enumerated by growing its sub-path.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experiments</head><p>We experimented with a 3.5GHz CPU and 24GB memory.</p><p>Code: https://github.com/nju-websoft/B3F .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Datasets</head><p>We used five versions of three public KGs. They represent small to medium-sized KGs as shown in Table <ref type="table" target="#tab_1">1</ref>. MONDIAL<ref type="foot" target="#foot_0">1</ref> (MND) is a geographical KG that has been popularly used for evaluating keyword querying. We reused 50 queries provided by <ref type="bibr" target="#b5">[Coffman and Weaver, 2014]</ref> but removed those containing unmatchable keywords. Our matching function returns vertices whose textual annotations (i.e., literals) contain the given keyword.</p><p>LUBM<ref type="foot" target="#foot_1">2</ref> is a benchmark for generating synthetic KGs in the university domain. We generated two KGs describing one university (L1) and four universities (L4). We generated 200 synthetic queries following the procedure in <ref type="bibr" target="#b10">[Li et al., 2016]</ref>. Specifically, we varied two parameters: the number of keywords in a query (i.e., g) and the average number of vertices matched with each keyword in a query (denoted by f ). For each g ∈ {2, 3, 4, 5, 6} and each f ∈ {5, 10, 50, 100} we generated 10 queries. Given g and f , to generate a query we created g pseudo keywords and we let each pseudo keyword match with an average of f random vertices.</p><p>From the well-known encyclopedic KG of DBpedia<ref type="foot" target="#foot_2">3</ref> we extracted two subgraphs D20K and D100K consisting of different numbers of vertices with the largest degrees and all the edges between them. We reused 429 queries provided by <ref type="bibr" target="#b7">[Hasibi et al., 2017]</ref> but removed those containing unmatchable keywords, i.e., the given keyword is not contained in any label annotations (rdfs:label) of vertices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Cost Function and Parameters</head><p>Concrete implementations of wt and sd are not our research focus. We reused existing normalized PageRank for wt:</p><formula xml:id="formula_21">wt(v) = 1 − sigmoid   log PageRank(v) min v ∈V PageRank(v )   .<label>(17)</label></formula><p>For semantic distance sd, we followed <ref type="bibr" target="#b3">[Cheng et al., 2017b]</ref> to compute the Jaccard distance between sets of types of entities in DBpedia to capture ontological semantics. This is not suitable for MONDIAL and LUBM where each entity has a single type. On these datasets, we computed the angular distance between 10-dimensional embedding vectors of entities generated by pyRDF2Vec<ref type="foot" target="#foot_3">4</ref> to capture structural semantics.</p><p>For the parameter α in the cost function we compared two values: α = 0.3 and α = 0.7. For the largest allowed depth of search in B 3 F we set d = 3 since subgraphs of diam &gt; 6 would be too large to present in real applications. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Baseline</head><p>We are the first to propose an exact algorithm for QGSTP. We compared our algorithm with DPBF <ref type="bibr" target="#b6">[Ding et al., 2007]</ref>, a state-of-the-art exact algorithm for the standard vertexweighted GST problem which is a simple special case of QGSTP. DPBF minimizes the total weight of the vertices in an answer but is unaware of semantic distance. Recent faster algorithms for the GST problem <ref type="bibr" target="#b10">[Li et al., 2016;</ref><ref type="bibr" target="#b13">Shi et al., 2020]</ref> were not compared because they were designed for edge weights but could not handle vertex weights.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Efficiency Results</head><p>Recall that our research target in this paper is to efficiently solve QGSTP. Thus, run time is our main evaluation metric. Metric. We measured the mean run time of each algorithm for answering a query. The results are shown in Table <ref type="table" target="#tab_2">2</ref>.</p><p>Comparison with baseline. The run time of B 3 F and DPBF was generally at the same level of magnitude. B 3 F was 3.48-8.78 times as fast as DPBF on L1 and L4, but was 1.79-10.28 times as slow as DBPF on the other KGs. Scalability. B 3 F was fast on small KGs of 20k-40k vertices. It only used 1.31-6.52 seconds to answer a query on MND, L1, and D20K. However, it took 30.96-261.14 seconds on medium-sized KGs of about 100k vertices like L4 and D100K, i.e., the run time grew superlinearly with the number of vertices. In Fig. <ref type="figure" target="#fig_3">2</ref> we break down the results under α = 0.3 by g, the number of keywords in a query. The run time grew noticeably when g was increased. Similar results under α = 0.7 are shown in Fig. <ref type="figure" target="#fig_4">3</ref>. Discussion. On small and medium-sized KGs, B 3 F showed promising performance comparable to DPBF but note that B 3 F solved a harder problem where cohesiveness was modeled by quadratic terms to produce better answers. The performance is acceptable for many enterprise-level applications such as analytics-oriented exploration which is more focused on answer quality rather than run time. Moreover, one could easily improve the performance by parallelizing the execution of B 3 F, e.g., by processing multiple combinations of paths in parallel. However, B 3 F and DPBF are exact algorithms for NP-hard problems and they have exponential run time in the worst case. They may not be the best choice for applications where KGs are extremely large and run time rather than answer quality is the main concern. For such applications, one may consider more scalable approximation algorithms <ref type="bibr" target="#b13">[Shi et al., 2021;</ref><ref type="bibr" target="#b13">Shi et al., 2020]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Effectiveness Results</head><p>Our research is focused on efficient algorithms for the generalized QGSTP, rather than the effectiveness of its concrete im-  plementation in KG exploration which has been empirically demonstrated by case or user studies <ref type="bibr" target="#b3">[Cheng et al., 2017b;</ref><ref type="bibr" target="#b0">Bryson et al., 2020]</ref>. Here we mainly aimed to extend such qualitative studies by quantitatively comparing the cohesiveness of our quadratic GSTs with standard GSTs. Metric. For each query we measured cohesiveness ratio:</p><formula xml:id="formula_22">cohesiveness ratio = costsd(T B 3 F ) costsd(T DPBF ) , (<label>18</label></formula><formula xml:id="formula_23">)</formula><p>where cost sd is defined in Eq. (4); T B 3 F and T DPBF represent the answers computed by B 3 F and DPBF, respectively. The mean cohesiveness ratios for a query are shown in Table <ref type="table" target="#tab_2">2</ref>.</p><p>Comparison with baseline. The ratios were in the range of 0.47-0.92, i.e., quadratic GSTs were 8%-53% more cohesive than standard GSTs. It partially justified the advantage of cohesive answers reported in <ref type="bibr" target="#b3">[Cheng et al., 2017b]</ref>. Similar to our efficiency experiment, in Fig. <ref type="figure" target="#fig_3">2</ref> and Fig. <ref type="figure" target="#fig_4">3</ref> we break down the results by g, the number of keywords in a query. We did not observe explicit correlation between them.</p><p>Case study. In </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>QGSTP has been formulated for improving the cohesiveness of answers for KG exploration. This generalized model of-  fers the flexibility to measure weights, semantic distances, and tune their combination. To solve QGSTP we proposed B 3 F. Compared with exact algorithms for computing standard GSTs, our exact algorithm for QGSTP computed more cohesive answers in comparable run time. It showed promising performance on medium-sized KGs which have supported many real-life applications. It can also be used as a baseline for evaluating approximation algorithms for QGSTP.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: An example KG and two extracted subgraphs: a semantically cohesive subgraph T1 and a semantically incohesive subgraph T2 for answering the query "melvin schwartz, emil wolf".</figDesc><graphic url="image-1.png" coords="1,315.00,233.88,243.00,67.26" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>is constructed by merging two paths: M. Schwartz doctoral advisor −−−−−−−→ J. Steinberger academic advisor − −−−−−−− → E. Fermi E. Wolf notable student ← −−−−−− − M. Born notable student − −−−−−− → E. Fermi</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Time complexity. For G = V, E , let |V | = n and |E| = m. There are O(n) keyword vertices, starting from which O(n d+1 ) paths are enumerated and processed. Fibonacci heap allows O(log n d+1 ) time for pull and O(1) time for insert. All the queue operations take O(n d+1 (d+1) log n) time.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Mean cohesiveness ratio and run time of B 3 F (α = 0.3) under different values of g.</figDesc><graphic url="image-2.png" coords="7,111.72,62.00,79.12,81.76" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Mean cohesiveness ratio and run time of B 3 F (α = 0.7) under different values of g.</figDesc><graphic url="image-8.png" coords="7,194.82,195.45,73.87,81.79" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Fig. 4 we show two answers computed by different methods for a query on DBpedia in our experiments. The GST computed by DPBF is more compact and contains more salient entities such as France, but it is not a cohesive subgraph. The four entities have different types and are semantically distant from each other. They do not constitute a meaningful answer. By comparison, the quadratic GST computed by B 3 F is a cohesive subgraph where the five entities have the same type and are semantically close to each other. It meaningfully describes relations between military conflicts.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>(a) A GST computed by DPBF. (b) A quadratic GST computed by B 3 F.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Two answers computed by different methods for the query "France, World War II, Normandy" on DBpedia.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>integer d Output: T opt 1: T opt ← null; /* We define cost(null) = ∞. */ 2: P Q ← an empty min-priority queue of paths; for all p 1 , . . . , p g ∈ P 1 × • • • × P g containing p top and having a common end vertex do for all v ∈ V that is adjacent from/to the end vertex of p top and is outside p top do</figDesc><table><row><cell></cell><cell>g</cell></row><row><cell></cell><cell>K i do</cell></row><row><cell></cell><cell>i=1</cell></row><row><cell>4:</cell><cell>P Q.insert(v);</cell></row><row><cell cols="2">5: for i = 1 to g do</cell></row><row><cell>6:</cell><cell>P i ← an empty set of paths;</cell></row><row><cell cols="2">7: while P Q is not empty do</cell></row><row><cell>8:</cell><cell>p top ← P Q.pull();</cell></row><row><cell>9:</cell><cell>if cost(p top ) ≥ cost(T opt ) then</cell></row><row><cell>10:</cell><cell>break the while loop;</cell></row><row><cell>11:</cell><cell>for all k i ∈ QK(V ptop ) do</cell></row><row><cell>12:</cell><cell>P i ← P i ∪ {p top };</cell></row><row><cell>13:</cell><cell></cell></row><row><cell>14:</cell><cell>T ← merge p 1 , . . . , p g ;</cell></row><row><cell>15:</cell><cell>if T is structurally minimal then</cell></row><row><cell>16:</cell><cell>if cost(T ) &lt; cost(T opt ) then</cell></row><row><cell>17:</cell><cell>T opt ← T ;</cell></row><row><cell>18:</cell><cell>if len(p top ) &lt; d then</cell></row><row><cell>19:</cell><cell></cell></row><row><cell>20:</cell><cell></cell></row></table><note>3: for all v ∈ p ← grow p top to v with one edge; 21: P Q.insert(p); 22: return T opt</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>KGs and Queries</figDesc><table><row><cell></cell><cell>KG</cell><cell></cell><cell></cell><cell>Query</cell></row><row><cell></cell><cell>Source</cell><cell>|V |</cell><cell cols="2">|E| Qty</cell><cell>g</cell></row><row><cell>MND</cell><cell>MONDIAL</cell><cell cols="2">40,890 120,690</cell><cell>34 2-4</cell></row><row><cell>L1</cell><cell>LUBM</cell><cell>20,797</cell><cell cols="2">82,590 200 2-6</cell></row><row><cell>L4</cell><cell>LUBM</cell><cell cols="3">91,045 370,654 200 2-6</cell></row><row><cell>D20K</cell><cell>DBpedia</cell><cell>20,000</cell><cell cols="2">37,017 128 2-6</cell></row><row><cell cols="2">D100K DBpedia</cell><cell cols="3">100,000 205,743 241 2-6</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>Mean Run Time (seconds) and Mean Cohesiveness Ratio</figDesc><table><row><cell></cell><cell></cell><cell>MND</cell><cell>L1</cell><cell cols="2">L4 D20K D100K</cell></row><row><cell></cell><cell cols="4">B 3 F (α = 0.3) 1.68 1.84 30.96</cell><cell>4.09 261.14</cell></row><row><cell>Time</cell><cell cols="4">B 3 F (α = 0.7) 1.31 2.42 32.50</cell><cell>6.52 101.12</cell></row><row><cell></cell><cell>DPBF</cell><cell cols="3">0.19 16.15 113.00</cell><cell>2.29</cell><cell>25.41</cell></row><row><cell>Ratio</cell><cell cols="3">B 3 F (α = 0.3) 0.89 0.47 B 3 F (α = 0.7) 0.92 0.56</cell><cell>0.53 0.63</cell><cell>0.79 0.80</cell><cell>0.64 0.65</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0">https://www.dbis.informatik.uni-goettingen.de/Mondial</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1">http://swat.cse.lehigh.edu/projects/lubm/</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2">https://wiki.dbpedia.org/(version 2016-10)   </note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3">https://github.com/IBCNServices/pyRDF2Vec</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work was supported in part by the National Key R&amp;D Program of China (2018YFB1005100), in part by the NSFC (62072224), and in part by the Fundamental Research Funds for the Central Universities (0202-14380084).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Towards a semantic keyword search over industrial knowledge graphs (extended abstract)</title>
		<author>
			<persName><surname>Bryson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE BigData 2017</title>
				<imprint>
			<date type="published" when="2017">2020. 2020. 2017</date>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="1698" to="1700" />
		</imprint>
	</monogr>
	<note>Robust keyword search in large attributed graphs</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">HIEDS: A generic and efficient approach to hierarchical dataset summarization</title>
		<author>
			<persName><surname>Cheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI 2016</title>
				<imprint>
			<date type="published" when="2016">2016. 2016</date>
			<biblScope unit="page" from="3705" to="3711" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Generating illustrative snippets for open data on the web</title>
		<author>
			<persName><surname>Cheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WSDM 2017</title>
				<imprint>
			<date type="published" when="2017">2017a. 2017</date>
			<biblScope unit="page" from="151" to="159" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">An empirical evaluation of techniques for ranking semantic associations</title>
		<author>
			<persName><surname>Cheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Knowl. Data Eng</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="2388" to="2401" />
			<date type="published" when="2017">2017b. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Generating compact and relaxable answers to keyword queries over graphs</title>
		<author>
			<persName><surname>Cheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISWC 2020, Part I</title>
				<imprint>
			<date type="published" when="2020">2020. 2020</date>
			<biblScope unit="page" from="110" to="127" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">An empirical performance evaluation of relational keyword search techniques</title>
		<author>
			<persName><forename type="first">Joel</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alfred</forename><forename type="middle">C</forename><surname>Coffman</surname></persName>
		</author>
		<author>
			<persName><surname>Weaver</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Ananya Dass, Aggeliki Dimitriou, Cem Aksoy, and Dimitri Theodoratos</title>
				<imprint>
			<publisher>Coffman and Weaver</publisher>
			<date type="published" when="2014">2020. 2020. 2020. 2014. 2014. 2015. 2015</date>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="47" to="62" />
		</imprint>
	</monogr>
	<note>Part II</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Finding top-k mincost connected trees in databases</title>
		<author>
			<persName><surname>Ding</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE 2007</title>
				<imprint>
			<date type="published" when="2007">2007. 2007</date>
			<biblScope unit="page" from="836" to="845" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">DBpedia-Entity v2: A test collection for entity search</title>
		<author>
			<persName><surname>Gu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WSDM 2019</title>
				<imprint>
			<date type="published" when="2017">2019. 2019. 2017. 2017. 2017</date>
			<biblScope unit="page" from="1265" to="1268" />
		</imprint>
	</monogr>
	<note>Relevance search over schema-rich knowledge graphs</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Edmund Ihler. The complexity of approximating the class Steiner tree problem</title>
		<author>
			<persName><surname>Ihler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WG 1991</title>
				<imprint>
			<date type="published" when="1991">1991. 1991</date>
			<biblScope unit="page" from="85" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Anastasios Kementsietsidis, and Songyun Duan. Scalable keyword search on large RDF data</title>
		<author>
			<persName><surname>Kacholia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Mehdi Kargar and Aijun An</title>
				<imprint>
			<publisher>Kargar and An</publisher>
			<date type="published" when="1995">2005. 2005. 2011. 2011. 1995. 1995. 2014</date>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="2774" to="2788" />
		</imprint>
	</monogr>
	<note>J. Algorithms</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Efficient and progressive group Steiner tree search</title>
		<author>
			<persName><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD 2016</title>
				<imprint>
			<date type="published" when="2016">2016. 2016</date>
			<biblScope unit="page" from="91" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Relaxing relationship queries on graph data</title>
		<author>
			<persName><surname>Li</surname></persName>
		</author>
		<idno>61-62:100557</idno>
	</analytic>
	<monogr>
		<title level="j">J. Web Semant</title>
		<imprint>
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Keyword search over knowledge graphs via static and dynamic hub labelings</title>
		<author>
			<persName><surname>Lissandrini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Saeedeh Shekarpour, Axel-Cyrille Ngonga Ngomo, and Sören Auer</title>
				<imprint>
			<date type="published" when="2012">2020. 2020. 2020. 2012. 2012. 2013. 2013. 2020. 2020</date>
			<biblScope unit="page" from="235" to="245" />
		</imprint>
	</monogr>
	<note>WWW 2020</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Efficient computation of semantically cohesive subgraphs for keywordbased knowledge graph exploration</title>
		<author>
			<persName><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Yawei Sun, Lingling Zhang, Gong Cheng, and Yuzhong Qu</title>
				<imprint>
			<date type="published" when="2020">2021. 2021. 2020. 2020</date>
			<biblScope unit="page" from="8952" to="8959" />
		</imprint>
	</monogr>
	<note>AAAI-IAAI-EAAI 2020</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Top-k exploration of query candidates for efficient keyword search on graph-shaped (RDF) data</title>
		<author>
			<persName><forename type="first">Tran</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE 2009</title>
				<imprint>
			<date type="published" when="2009">2009. 2009</date>
			<biblScope unit="page" from="405" to="416" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">An efficient parallel keyword search engine on knowledge graphs</title>
		<author>
			<persName><forename type="first">Yang</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE 2019</title>
				<imprint>
			<date type="published" when="2019">2019. 2019</date>
			<biblScope unit="page" from="338" to="349" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">GREASE: A generative model for relevance search over knowledge graphs</title>
		<author>
			<persName><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WSDM 2020</title>
				<imprint>
			<date type="published" when="2020">2020. 2020</date>
			<biblScope unit="page" from="780" to="788" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Querying cohesive subgraphs by keywords</title>
		<author>
			<persName><surname>Zhu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE 2018</title>
				<imprint>
			<date type="published" when="2018">2018. 2018</date>
			<biblScope unit="page" from="1324" to="1327" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
