<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">SPECIAL SECTION ON APPLYING FOUR Ds OF MACHINE LEARNING TO ADVANCE BIOMETRICS</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">L</forename><surname>Wolf</surname></persName>
							<email>wolf@cs.tau.ac.il</email>
							<affiliation key="aff0">
								<orgName type="department">Blavatnik School of Computer Science</orgName>
								<orgName type="institution">Tel Aviv University</orgName>
								<address>
									<postCode>69978</postCode>
									<settlement>Tel Aviv</settlement>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">SPECIAL SECTION ON APPLYING FOUR Ds OF MACHINE LEARNING TO ADVANCE BIOMETRICS</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">62174630AC3B82646D9B7635F3E829B6</idno>
					<idno type="DOI">10.1109/ACCESS.2015.2494536</idno>
					<note type="submission">Received August 31, 2015, accepted October 2, 2015, date of publication October 26, 2015, date of current version November 17, 2015.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:00+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A major challenge in biometrics is performing the test at the client side, where hardware resources are often limited. Deep learning approaches pose a unique challenge: while such architectures dominate the field of face recognition with regard to accuracy, they require elaborate, multi-stage computations. Recently, there has been some work on compressing networks for the purpose of reducing run time and network size. However, it is not clear that these compression methods would work in deep face nets, which are, generally speaking, less redundant than the object recognition networks, i.e., they are already relatively lean. We propose two novel methods for compression: one based on eliminating lowly active channels and the other on coupling pruning with repeated use of already computed elements. Pruning of entire channels is an appealing idea, since it leads to direct saving in run time in almost every reasonable architecture.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Face-based authentication has several advantages for mobile applications, compared, for example, to fingerprint readers. First, it does not require a specialized hardware. Second, as a non-contact biometric it can be collected without requiring an active cooperation. Third, it is suitable as a continuous biometrics i.e., periodically performing recognition in order to maintain a level of confidence regarding the user's identity. Done locally, on the mobile device, it enables a secure authentication that promotes privacy while reducing the amount of network usage.</p><p>Recently, deep learning approaches have shown an impressive level of face recognition performance that is significantly better than other available methods. As a result, deep learning methods hold the promise of being robust enough to the challenges of mobile authentication, including extreme pose and illumination. The prominent component of deep learning in current computer vision is the Convolutional Neural Network (CNN) <ref type="bibr" target="#b0">[1]</ref>, and the main goal of this work is to enable the efficient usage of such networks on mobile devices.</p><p>In CNNs, the weights connecting one layer to the next are shared across spatial locations and are given as convolution masks. Specifically, a convolution layer transforms a three dimensional input tensor X ∈ R m×h×w into a three dimensional output tensor Y ∈ R n×h×w where m, n are the number of channels in each tensor. This is done by applying n filters of spatial size k × k on a stack of m input channels of size h × w. In general, the spatial domains might change between layers. However, for notational simplicity we assume that the spatial domain is fixed. The weights of a convolutional layer, combining all filters together, form a single tensor denoted W of size n × m × k × k.</p><p>Since CNNs employ shared filters over local receptive fields, they enjoy a relatively compact representation. This compactness, in turn, enables the construction of deeper models. Such models would not be feasible using fully connected layers since they rapidly increase the number of network parameters beyond the capabilities of even modern hardware.</p><p>Despite their compactness, convolutional layers require a great number of computations. For example, consider the layer configuration given above -for each of the h×w output pixels a filter of size mk 2 is applied. Since there are n filters, a total of nmk 2 hw multiplications are required.</p><p>In most desktop-computer implementations of CNNs, matrix multiplications are used to perform the convolutions. The matrices involved are: (i) a filter matrix -which contains the layer weights, and (ii) a patch matrix -which contains the input. Taking the layer described above as an example, the filter matrix is generated by reshaping the layer weights tensor from n × m × k × k to n × mk 2 by flattening each filter to a single matrix row. The patch matrix is generated by unfolding (using an im2col operation) the input tensor. The unfold operation extracts m patches of spatial size k × k taken from all spatial locations, resulting in a matrix of size mk 2  × hw. Finally, the activations of this layer are obtained by multiplying the filter matrix of size n × mk 2  with the patch matrix of size mk 2  × hw. While matrix multiplication is implemented very efficiently, it remains the main source of computational complexity. Reducing the number of input and output channels leads to an utilizable decrease in complexity by decreasing the size of the multiplied matrices.</p><p>Other platforms, specifically mobile platforms, do not support modern linear algebra libraries. As a result, convolutions are computed by directly computing each filter instead of converting the computation to matrix multiplication. In our implementation, we use the android port of a deep learning framework called Torch7 <ref type="bibr" target="#b1">[2]</ref>, in which computation is optimized using vectorized convolution code. Such implementations do not enjoy the optimization found in modern linear algebra libraries such as memory utilization. However, here too, reducing the number of channels is directly translated into an improvement in runtime through a reduction in the depth of each convolution and in the number of convolutions.</p><p>These improvements in performance are, therefore, platform independent and are readily achievable using the existing deep learning implementations. This is a result of eliminating entire channels and is in contrast to other methods of sparsification whose contribution requires specialized software or futuristic hardware.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. PREVIOUS WORK</head><p>A prominent example of deep learning success can be seen in the task of face recognition. Starting with the work of Taigman et al. <ref type="bibr" target="#b2">[3]</ref>, a neural network has been employed for extracting representations from face images that are shown to outperform humans. Sun et al. <ref type="bibr" target="#b3">[4]</ref>- <ref type="bibr" target="#b6">[7]</ref> further improve the state-of-art by employing various methods: (i) extraction of features from multiple face patches, (ii) combination of classification and contrastive loss and (iii) incorporating architectures into the domain of deep face recognition that are inspired by recent architectures that are used for object recognition <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref>. A recent work <ref type="bibr" target="#b9">[10]</ref> further improves the training criterion by using triplet cost to increase the discriminability between identities. Although <ref type="bibr" target="#b9">[10]</ref> trains a secondary model for mobile execution, the reported results of this model are significantly below the state of the art. Another contribution <ref type="bibr" target="#b10">[11]</ref> suggests first training a feature extraction network followed by a metric learning network to reduce the feature to a low dimension.</p><p>The deep networks mentioned above, are all trained on large scale proprietary datasets, which are not publicly available. Yi et al. <ref type="bibr" target="#b11">[12]</ref> built a publicly available dataset by mining images from the internet. Furthermore, they demonstrated the quality of the data collected by training a state-of-the-art network on it. Their network architecture is similar to that of the VGG model <ref type="bibr" target="#b7">[8]</ref>. In our work, we use the same architecture suggested in <ref type="bibr" target="#b11">[12]</ref> and accelerate it for usage on mobile platforms.</p><p>CNNs acceleration is of great interest in deep learning research. Acceleration methods can be split into two categories: (i) the creation of an approximated model either by training a new model or by modifying the existing one or (ii) the speedup of the computation without modification by improving the calculation method or better utilization of hardware.</p><p>Network mimicking by training a ''shallow network'' <ref type="bibr" target="#b12">[13]</ref> or ''fitnet'' <ref type="bibr" target="#b13">[14]</ref> trains a new model, called the student model, from scratch to mimic the original model, called the teacher model. Ba and Caruana <ref type="bibr" target="#b12">[13]</ref> do so by setting the learning objective of the new network as a regression problem striving to replicate the teacher's output log probabilities by the student network. Romero et al. <ref type="bibr" target="#b13">[14]</ref>, train deeper student models with less filters in each layer (''fit''), suggesting that network depth can improve the model performance despite the overall reduction in size. In order to overcome the overall difficulty of deep network training, a multiple step training process is suggested. First, half of the student is trained, by solving a regression problem minimizing the difference between the teacher's and the student's activations. Afterwards, the entire student network is trained to mimic the teacher by using a combination of the classification loss and knowledge distillation <ref type="bibr" target="#b14">[15]</ref>.</p><p>Network decomposition <ref type="bibr" target="#b15">[16]</ref>- <ref type="bibr" target="#b17">[18]</ref>, is another type of approximation, which exploits the low-rank structure of neural networks in order to perform filter decomposition that speeds up overall performance. Such factorization is done in a manner that reduces the computational complexity of the layer while well approximating the original layer. Recently, Zhang et al. <ref type="bibr" target="#b17">[18]</ref> developed a decomposition method that utilizes low-rank assumptions in both the network input and the network filters.</p><p>Consider, as above, a layer with n filters operating on an input of a spatial size of h × w that follows a layer with m channels. Let the spatial size of the filters be k × k.</p><p>Let X , Ŷ and Ŵ be the flattened version of the tensors defined above i.e. X ∈ R (k 2 m+1)×hw , Ŷ ∈ R n×hw and Ŵ ∈ R n×(k 2 m+1) . One additional row was added for bias. Using this flattened matrix notation, the layer activation is Ŷ = Ŵ X .</p><p>The low rank assumption implies that there exists a matrix M ∈ R n×n of rank n &lt; n such that</p><formula xml:id="formula_0">Ŷ -Y = M ( Ŷ -Y ),</formula><p>where Y is the mean matrix of Ŷ . This is done by solving min</p><formula xml:id="formula_1">M i ( Ŷi -Y i ) -M ( Ŷi -Y i ) s.t. rank(M ) &lt; n</formula><p>M is then decomposed to M = PQ T . This results in the decomposition W = Q T W and P. Put back into a CNN notation, the decomposition results in the splitting of the original layer (based on W ) into two layers: one is a convolutional layer with filters of size 1×1 that is based on P; the other is a convolutional layer with filters of size k × k that implements W . In comparison to the original layer, the second layer has only n filters instead of the initial n.</p><p>The method proposed by us also uses 1 × 1 convolutions, see also Network. In Network <ref type="bibr" target="#b18">[19]</ref>. However, we reduce the layer dimension by pruning rather than decomposition.</p><p>Earlier implementations of network pruning <ref type="bibr" target="#b19">[20]</ref>- <ref type="bibr" target="#b22">[23]</ref> are used to improve model generalization and size while not targeting CNN run-time. By pruning network connections at the single neuron, i.e. single weights in each filter thus creating sparsification, such methods reduce the overall network complexity. The pruning we perform in the study presented here also removes some of the network connections. However, we target entire channels and therefore achieve run-time improvements.</p><p>Other pruning methods are motivated by run-time, however the gains are not realized in current deep learning architectures. Han et al. <ref type="bibr" target="#b23">[24]</ref> propose a method to learn both the connections and weights of a network. This is done by pruning weights whose magnitude is under a given threshold followed by fine-tuning the pruned model. As a result, in the learned network, many of the weights are zeroed out. Unfortunately, the level of sparsification obtained is not enough to justify the usage of sparse matrix multiplications. The authors of <ref type="bibr" target="#b23">[24]</ref> suggest that acceleration may be achieved using suitable future hardware designs. In contrast, our solution, which effectively reduces the number of required multiplications is software based, and the improvements in run-time are easily measured.</p><p>Lebedev and Lempitsky <ref type="bibr" target="#b24">[25]</ref> speedup network inference time by pruning each filter in a group-wise manner generating sparse sub-filters. The induced sparse structure allows the computation of the convolutions via a dense ''thin'' matrix multiplication. The sparse sub-filter, Q i is defined for each input channel as a subset of the full filter i.e. Q i ⊂ {1 . . . k} ⊗ {1 . . . k}. Instead of computing the activations of the layer by multiplying a matrix of size n × mk 2 with a matrix of size mk 2  × hw, the computation is reduced to matrices of size n</p><formula xml:id="formula_2">× m i=1 |Q i | and m i=1 |Q i | × hw. This results a speedup of mk 2 / m i=1 |Q i |.</formula><p>In contrast, our methods prune layers at the channel level without changing the filter sizes. Our inbound prune reduces the number of incoming channels that each filter uses, while our reduce and reuse method prunes entire filters.</p><p>In <ref type="bibr" target="#b25">[26]</ref> convolutions are computed on a sparse subset of each channel while restoring the non-computed convolutions via interpolation. Thus, it prunes a permanent subset of each filter connections to incoming channels. Our methods, by contrast, perform a much more aggressive pruning which removes the filter computation over entire channels or the filter itself.</p><p>In addition to the merit of improved runtime, pruning serves as a regularizer during neural network training <ref type="bibr" target="#b26">[27]</ref>- <ref type="bibr" target="#b28">[29]</ref>. Dropout <ref type="bibr" target="#b26">[27]</ref> technique zeros network activations with probability p drop . Then, during inference, all network activations are multiplied by 1/(1 -p drop ), to maintain the same level of expected activation. DropConnect <ref type="bibr" target="#b27">[28]</ref> generalizes Dropout by pruning network connections instead of output units. SpatialDropout <ref type="bibr" target="#b28">[29]</ref> extends Dropout to entire feature maps instead of single neurons, which was shown to be effective for fully-convolutional networks. However, the methods mentioned do not target the network inference time as they prune the network only during training.</p><p>Additional methods accelerate the neural network without modifying the network structure. One family of methods targets the way in which the layer output is calculated by using FFT based convolutions <ref type="bibr" target="#b29">[30]</ref>, <ref type="bibr" target="#b30">[31]</ref>. Another family of methods improves hardware utilization <ref type="bibr" target="#b31">[32]</ref>, <ref type="bibr" target="#b32">[33]</ref> employing various techniques such as low-level parallelism, effective memory usage and low precision arithmetic. The gains of such methods can be added to the gains that are made possible by our method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. METHOD OVERVIEW</head><p>In this section, we provide an overview of our methods for accelerating deep convolutional neural networks; the following sections would provide the necessary details. In terms of positioning, the suggested methods continue a recent line of work <ref type="bibr" target="#b23">[24]</ref>- <ref type="bibr" target="#b25">[26]</ref> that utilizes pruning schemes, as opposed to retraining a mimicking network such as <ref type="bibr" target="#b12">[13]</ref> and <ref type="bibr" target="#b13">[14]</ref>. Specifically, we reduce the network inference time by pruning either the input or the output channels of each layer. This is unlike previous work <ref type="bibr" target="#b19">[20]</ref>- <ref type="bibr" target="#b22">[23]</ref> on network pruning, which typically focuses on the neuron level.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. THE SCRATCH FACE RECOGNITION MODEL</head><p>While a number of network architectures have been proposed for deep representation of faces, the scratch network <ref type="bibr" target="#b11">[12]</ref> has a few significant advantages, which make it suitable for our study. First, it relies solely on convolutions, and does not employ fully connected layers, which burden the size of the network and create a hefty memory footprint. Second, and more importantly, this architecture was shown to be able to train well on the relatively noisy CASIA dataset <ref type="bibr" target="#b11">[12]</ref>. While other networks <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b9">[10]</ref> have exhibited somewhat better performance, they were trained on proprietary datasets of better quality and larger cardinality.</p><p>The architecture of the scratch feature extraction network is detailed in Table <ref type="table" target="#tab_0">1</ref>. Note that suitable padding is applied such that convolutional layers do not change the spatial dimensions from one layer to the next. Only max-and average-pooling reduce the size of the activation maps. The table also reports the percent of the total network runtime devoted to each layer.</p><p>For the purpose of benchmarking on the LFW benchmark <ref type="bibr" target="#b33">[34]</ref>, we use the scratch network in order to extract face feature representation. This representation is the collection of  <ref type="bibr" target="#b11">[12]</ref>, which is the baseline model in our experiments. The network starts with a gray scale input image of size 1 × 100 × 100 pixels, and runs through 10 convolutional layers interleaved with max pooling layers. Following a spatial average pooling at the end of the process, a representation of size 320 is obtained.</p><p>the 320 activations of the Avg Pool layer. Afterwards, we train a Joint Bayesian model <ref type="bibr" target="#b34">[35]</ref> based on these extracted features for the face verification task.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. THE EXPERIMENTAL PIPELINE</head><p>Training is done on the public dataset published in <ref type="bibr" target="#b11">[12]</ref> which contains 494,414 images of 10,575 identities. A common practice in face recognition is to preprocess the data prior to feature extraction. As suggested by previous work <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b11">[12]</ref>, for each image the face are detected and 2D-aligned. Specifically, we use the method proposed by <ref type="bibr" target="#b35">[36]</ref>, which detects 9 facial features followed by an affine transform to place the detected features at 9 anchor points. We further augment the data set by flipping each image horizontally. This increases the size of the training set by 2. Finally, 10% of the data is used for validation during the network training. The other 90% are used to train the network. All reported models were trained on the same data partition.</p><p>During training, on top of the model, we used a fully connected layer together with a soft max activation to generate a distribution over the dataset identities. The model was trained using Stochastic Gradient Descent (SGD) with a momentum parameter of 0.9, a learning rate 0.01, and with a batch size of 128. We also applied weight decay of 0.0005 on the fully connected layer. As is commonly done, the learning rate was manually reduced once the network improvement reached saturation. To ensure simplicity, we trained the model using classification criterion only as opposed to the contrastive criterion combination employed in the original paper.</p><p>The model training and pruning was done using Torch7 <ref type="bibr" target="#b36">[37]</ref>. We used a port of Torch7 <ref type="bibr" target="#b1">[2]</ref> for the deployment and benchmarking of the various models on mobile.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. PRUNING</head><p>Once we train a model with satisfying accuracy, we opt to speed the model without loss of accuracy while avoiding the need to train it from scratch. For the task at hand, pruning is an appealing method due to the heavy reliance on training that was already performed, as long as the pruning is done without reducing the model accuracy.</p><p>The Inbound Prune approach that we suggest focuses on reducing the number of channels each filter uses by eliminating channels that do not contribute significantly to the information the filter extracts. The amount of information each channel contributes is measured by the variance of the specific channel activation output. We do not consider directly the model accuracy during the pruning process. Instead, we fine-tune the model obtained after each prune in order to allow it to adapt. The pruning of the entire network is done sequentially on the network layers: from lower layers to the top ones, pruning is followed by fine-tuning, which is followed by pruning of the next layer. The speedup of the inbound pruning scheme is achieved directly by reducing the amount of computation that each filter performs. While originally, each filter required O(mk 2 ) multiplications, after pruning only O(ck 2 ) multiplications are required, where c &lt; m is the number of channels used by the filter. Fig. <ref type="figure" target="#fig_0">1(b)</ref> illustrates the inbound pruning process.</p><p>The second method suggested in our work is Reduce and Reuse. While the previous method targets the inbound connections of a convolution layer, this method prunes the number of channels outputted. Such pruning results in the removal of some of the layer filters. The same variance-based criterion as before is used, this time on the output of each filter. The method utilizes the fact that there is sufficient information in a subset of the layer output to allow the next layer filters to extract important features. Following the prune, we reuse the output left to reconstruct the pruned channels. Fig. <ref type="figure" target="#fig_0">1(c</ref>) illustrates the pruning process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. INBOUND PRUNE</head><p>The inbound prune method targets the number of channels that each filter operates on. Our hypothesis is that each input channel has a different level of contribution to the feature map outputted by each filter. As a result, we may omit the computation of the filter on channels with low contribution, and suffer only a minor decrease in accuracy. The layer produced by inbound prune. The number of input channels for each filter is reduced, such that each filter employs a suitable subset of the channels. (c) The layer produced by reduce and reuse. Here, the number of filters is reduced from n to n followed by a new layer that reconstructs back the original channels.</p><p>In order to detect such low importance channels, we leverage the pruning scheme used previously on single connections <ref type="bibr" target="#b21">[22]</ref>. Specifically, the notion of smallest contribution variancemin(σ ) is used. Originally, <ref type="bibr" target="#b21">[22]</ref> define scores for the contribution of a single weight to the activation of a single neuron. Below, we generalize this measure to the contribution of each channel to the filter activation by using the notion of channel activation.</p><p>Recall that X , Y are the 3-dimensional input and output tensors of a convolutional layer with 4-dimensional weight tensor W. The activation of filter t is</p><formula xml:id="formula_3">Y t = m s=1 W ts * X s</formula><p>Therefore, the activation of channel s of filter t is defined by W ts * X s .</p><p>The contribution variance of channel s in filter t is defined to be</p><formula xml:id="formula_4">σ ts = var(||W ts * X s || F )</formula><p>where X s is the s channel of the input, sampled from the training dataset.</p><p>Typically, the variance score is distributed in a bi-modal manner: some channels are scored highly, while some present activations that result in low scores. Fig. <ref type="figure" target="#fig_1">2</ref> shows the distribution of channel scores for 3 randomly sampled filters from layers Conv12, Conv21 and Conv22 (as defined in Table <ref type="table" target="#tab_0">1</ref>), i.e., for each of the depicted layers, we plot results for three random t. As can be seen, the contribution of a specific channel s is not uniform between filters, which explains why each filter has different channels pruned. To verify, we tested an alternative method in which we pruned the same channels from all filters and the results achieved by this method were less satisfying.</p><p>Once we compute the contribution variance for all channels in all filters, we prune all filter connections to a given channel where the contribution variance is below a threshold τ (see below). As a result, the pruned layer operation is defined by</p><formula xml:id="formula_5">Y t = s∈ t W ts * X s</formula><p>where t is the set of channels filter t operates on after the prune operation.</p><p>The number of multiplications performed by the pruned layer is less than that of W. More concretely, the complexity of the original layer is O(nmk 2 ) while the pruned layer requires O(ck 2 ) where c = n t=1 | t | is the number of channels left after pruning. Therefore, we achieve a theoretical speedup of O( nm c ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. FINE-TUNING</head><p>Even though pruning aims to inflict only a minor decrease in accuracy, we found in our experiments that fine-tuning the pruned model, after each layer was pruned, allows it to adapt to the modified activations of the pruned layer. More specifically, fine-tuning allows us to achieve three goals: (i) Prior to pruning, the model is at a local optima in parameter space. Once pruned, the model is no longer at a local optima in the parameter space. By fine-tuning, we search a new local optima while retaining the pruned model structure.</p><p>(ii) Although we attempt to prune layers with minimal effect, </p><formula xml:id="formula_6">VOLUME 3, 2015</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1 The Inbound Pruning Scheme</head><p>The algorithm receives as input the sampled channel activation for each channel of each filter given as a tensor ∈ R N ×n×m×h×w , N being the size sampled, and a threshold τ . The algorithm outputs -a set of channels left after pruning for each filter. Input: , τ Output:</p><p>1: For each filter t and each channel s, compute over the contribution variance σ ts . 2: For each filter t and each channel s if σ ts ≥ τ then t ← s the output of pruned layers is still changed. Fine-tuning allows the next layer in line to adapt to the pruned layer output. (iii) In our method, pruning is done sequentially. Therefore, adapting the model after each modification is crucial in order to reduce the accumulated error.</p><p>The inbound pruning scheme for a single layer is summarized in Algorithm 1. As mentioned, for whole model acceleration, we prune each layer sequentially from the lowest layers to the topmost layers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. REDUCE AND REUSE</head><p>Our second scheme targets the outbound channels of a layer. Our hypothesis is that in a convolution layer, a subset of its output contains enough information to allow the next layer in line to extract the viable features with minor classification loss.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. REDUCE</head><p>In order to find candidates for pruning, we compute the variance of each filter output over a sample of the training set. Formally, using the same annotation as before, the activation of a given channel is denoted by W i * X and the variance is</p><formula xml:id="formula_7">σ t = var(||W t * X || F )</formula><p>where X is the layer input, and W t is one of the filters of the layer. Next, we prune all filters whose score is below the percentile µ. In other words, we decide beforehand what would be the number of the channels n = µn that we keep. As a result, the pruned layer weight tensor is W ∈ R n ×m×k×k where n &lt; n is the number of channels outputted by the pruned layer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. REUSE</head><p>The performed pruning requires adaptation since the next layer expects to receive input in the size prior to the pruning and with similar patterns of activations. Therefore, we reuse the remaining output channels to reconstruct each pruned channel, by the use of linear combinations. Formally, let Y i ∈ R n×hw be the output of a layer with n filters, where each row is an output of a filter. Let Y i ∈ R n ×hw be the output of the pruned layer with the remaining n layers, as observed on the ith sample. By reusing, we seek to find A ∈ R n×n such that</p><formula xml:id="formula_8">min A i Y i -AY i 2 2 (1)</formula><p>The operation of A is added to the network by introducing a convolution layer with filters of size 1 × 1, which holds the elements of A. Note that 1 × 1 convolution layers, which can be seen as dimensionality rearrangement methods, were introduced recently by <ref type="bibr" target="#b18">[19]</ref> and, as mentioned, were used by <ref type="bibr" target="#b17">[18]</ref> as part of the decomposition process.</p><p>Once A is recovered, AY i is used in lieu of the original Y i . The speedup achieved is based on the number of filters removed and the overhead required to restore those channels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 2 The Reduce and Reuse Pruning Scheme</head><p>The algorithm receives as input the sampled channel activation filter activation given as a tensor ∈ R N ×n×h×w , where N is the size sampled, and a percentile µ. The algorithm outputs , which is the set of channels remaining after pruning. Input: , µ Output:</p><p>1: For each channel t ∈ [1.</p><p>.n] compute the activation variance -σ t over . 2: υ ← µ-th percentile of {σ t } n i=1 3: For each filter t if σ t ≥ υ then ← t</p><p>The theoretical computational complexity of a layer with n filters of size m × k × k is O(nmk 2 ). Once the layer is pruned to n filters, it will require O(n mk 2 ) operations. The additional layer of 1 × 1 convolutions will require O(n n) operations. Therefore, the total speedup ratio is O( nmk 2 n n+n mk 2 ). As before, we fine-tune the entire model before pruning the next layer in order to allow the next layer to adapt. The reduce and reuse pruning scheme is summarized by Algorithm 2.</p><p>It is important to note the overall memory footprint of the network does not increase due to the added 1×1 convolutional layer. Considering the layer described above, the added layer will have n n parameters. However, the number of parameters in the convolutional layer is reduced to n mk 2 , whereas before reduction the size is nmk 2 . For n n, the pruning scheme will still reduce the size of the network and as a result the model memory footprint.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. HYBRID PRUNING</head><p>We also consider the notion of combining the two schemes. Such a combination is plausible, since each of our pruning schemes targets different sections of a layer -inbound or outbound. The hybrid method is performed by first applying reduce and reuse followed by inbound pruning. This combination allowed us to achieve an acceleration of ×2.65. We note that the speedup ratio from applying inbound prune on an already pruned model (by reduce and reuse) is less effective than when applied on the original model. Nevertheless, we show in our experiments that we are able to achieve a greater speedup by combining the two methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. IMPLEMENTATION</head><p>In this section, we elaborate on the architectures and training procedures used to train the reported models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. INBOUND PRUNE</head><p>The model was pruned sequentially, one layer at a time from bottom to top. Each filter operating on an input stack of m channels was split into m convolution layers with a single filter of size 1 × 3 × 3. Those layers operated in parallel on the input channels. As a result, each layer computes the activation of a single channel. Next, the contribution variance of each channel was calculated. The variance was calculated over 3,000 samples drawn randomly from the training set.</p><p>During our experiments, the threshold τ was chosen empirically based on the accuracy achieved after pruning the model, prior to fine-tuning. We do not let the validation accuracy on the CASIA dataset drop below 84%. The model was finetuned using SGD with a learning rate of 0.01, momentum of 0.9 and batch size of 128. Each model was fine-tuned for a maximum of 30 epochs or until there were 5 successive epochs of no error improvement. Table <ref type="table">2</ref> shows the architecture of the pruned models, each column reports the number of inbound channels per layer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TABLE 2.</head><p>Incoming prune architectures produced by the pruning scheme. We report the number of input channels to filter connections in baseline and in the pruned model. We also report the percent of surviving channels/filter interactions. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. REDUCE AND REUSE</head><p>Table <ref type="table" target="#tab_1">3</ref> depicts the architecture produced by the second pruning scheme. There are three architectures: RR50%, RR75%, and RR90%-50%. The top layers for these architectures are the same as in the baseline model, since their prune resulted in a sharp decrease in model accuracy. The RR50% and the RR75% architectures denote a cut of 50/75% of the layers. Since cutting more than 50% after a certain layer is highly detrimental (as discussed below), the third architecture cuts by 90% up to layer Conv32, and only by 50% afterwards.</p><p>As with inbound prune, the scheme is employed sequentially, one layer at a time from bottom to top. The contribution variance of each filter is computed by calculating the variance of the layer output channel norm. Given a percentile µ, we prune all filters below this percentile. The variance based score was calculated over 1,000 samples from the training set. Next, we solved the minimization problem described in Eq. 1.</p><p>The solutions are the weights of the 1 × 1 layer. The resulting model is fine-tuned using SGD with an initial learning rate of 0.01, a momentum 0.9, and a batch size of 128. We applied the same stopping condition as in the inbound prune method. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. FITNETS</head><p>Next, we describe the architectures and training of the fitnet models <ref type="bibr" target="#b13">[14]</ref>, which were used as a recent literature baseline. As the teacher model, we used the full scratch model as described in Table <ref type="table" target="#tab_0">1</ref>. The fit models architectures are detailed in Table <ref type="table" target="#tab_2">4</ref>. The models follow a similar structure of consecutive convolution layers with a spatial filter size of 3×3 with a stride of 1. After each convolution, we used the parametric rectified linear activation <ref type="bibr" target="#b37">[38]</ref>. The convolutions are zero padded to retain the input spatial size. Each stack of convolution layers is followed by a non-overlapping max pooling layer with a spatial size of 2 × 2. On top of the last convolution layer, an average pool of spatial size 6×6 is used in order to reduce each feature map to 1 × 1 generating the facial representation vector. During training, each model is followed by a fully connected layer together with a soft max activation layer to produce class probabilities.</p><p>The models were trained using the scheme presented in <ref type="bibr" target="#b13">[14]</ref>. We used exactly the same data split used in the baseline model training i.e. 90-10 for train and test. The model weights were initialized using the scheme reported in <ref type="bibr" target="#b37">[38]</ref>, which leads to a faster convergence. For both stages of the fitnet training process, we trained the models with SGD, annealing the learning manually, once we detected that the model accuracy had stopped improving. We used an initial learning rate of 0.001 and batch size of 128 throughout all of the training phase with a momentum of 0.9.</p><p>During the hint-based training phase, each model was trained for 170 epochs or until the model accuracy stopped improving. Next, we trained the model using knowledge distillation. λ was initialized to 4 and was decayed linearly for 150 epochs to 1. In the following epochs, λ was remained unchanged. The temperature parameter was set to 3. We stopped the knowledge distillation phase when we detected that the model improvement rate slowed down considerably.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. LOW-RANK NETWORK DECOMPOSITION</head><p>We next describe the architectures and decomposition scheme of the models generated by our implementation of <ref type="bibr" target="#b17">[18]</ref>, which is another very recent baseline method.</p><p>We used the ''Asymmetric non-linear reconstruction'' method suggested in <ref type="bibr" target="#b17">[18]</ref>, which seems better than the alternatives in that paper. This method decomposes each convolutional layer of size n×m×k ×k into two convolutional layers of size n × m × k × k and n × n × 1 × 1. In order to evaluate our method, we chose n n = 0.5, n n = 0.25 and n n = 0.1 for each layer we decomposed, keeping the channel-reduction ratio the same as in the methods that we suggested. In our experiments, we decompose each layer using 1,000 samples from our dataset which contains 494,414 images. This is a similar ratio to the original paper, which sampled 3,000 from the imagenet dataset which contains 1.2 million images. The ''non-linear'' optimization problem min</p><formula xml:id="formula_9">M ,b i r(y i ) -r(My i + b) 2 2 s.t. rank(M ) ≤ n</formula><p>where M ∈ R n×n is the low-rank matrix discussed above, b is the bias of the added 1x1 convolutional layer and r(•) = max(•, 0) is the rectified linear unit (ReLU) used between the network convolutional layers. {y} N i=1 are the sampled activations of the layer that is being decomposed. As mentioned above, the convolutional layer is split to two convolutional layers by the M = PQ T decomposition.</p><p>We solved the latter optimization problem using the iterative solver employed by <ref type="bibr" target="#b17">[18]</ref>. In our implementation of the solver we used the same number of iterations and hyper parameters. The architecture produced by this method is identical to the ones produced by the RR method, which are displayed in Table <ref type="table" target="#tab_1">3</ref>. As before, we do not decompose the top layers of the network since that degraded the network performance beyond an acceptable ratio. The writers of <ref type="bibr" target="#b17">[18]</ref> TABLE 5. Inbound pruning summary. For each pruned model we report model classification accuracy before and after fine-tuning, running time in seconds, number of multiplications in G-Ops and parameters. Each row indicates pruning done up to the indicated layer.</p><p>claim that the approximated model is very sensitive to finetuning (i.e. sensitive to the selection of a learning rate) and show that they are able to achieve ''very good accuracy even without fine-tuning'' -therefore in our implementation we do not apply fine-tuning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. RESULTS</head><p>We use the scratch model <ref type="bibr" target="#b11">[12]</ref>, as depicted in Table <ref type="table" target="#tab_0">1</ref>, as our baseline for the evaluation of our methods. Models are evaluated in two different ways. First, we measure the model accuracy by the classification accuracy on the CASIA dataset which we split to 90% training and 10% test. Second, we measure the score on the LFW benchmark <ref type="bibr" target="#b33">[34]</ref> in the unrestricted mode. LFW results are mean and Standard Error estimated over fixed ten cross-validation splits. In addition, the model efficiency is captured by measuring the running time on a Samsung Galaxy S6 device which is our target platform. The time results are reported in seconds; Run time was measured as the mean of 100 forward passes of a single image. The baseline network achieves the accuracy of 95.12%±1.53 on LFW and 86.04% classification accuracy on CASIA with an execution time of 0.512 seconds.</p><p>In all of our experiments, pruning is done from the layer Conv12 until a certain layer. Hence, when we report the pruning of Conv22, we mean that Conv12, Conv21, and Conv22 were all pruned. This makes sense since pruning the lower layers is more beneficial and less detrimental to the overall performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. INBOUND PRUNING</head><p>We conduct a few experiments using the first pruning method that verify the effectiveness of the used criterion as well as the overall performance.</p><p>Random vs Variance Based: In the first experiment, we verify that the filter input variance score is a good measure for pruning the incoming channels of a convolution layer. We do so by removing a fixed 50% of incoming channels without fine-tuning the network after each prune. Fig. <ref type="figure" target="#fig_2">3</ref> shows accuracy on the CASIA and LFW datasets after each prune. The CASIA validation success rate after pruning the first three layers stands at 82% using the variance based measure while the random pruning collapses to 14.5%. We also note that the rate of accuracy drop is dramatically faster when using random pruning. The Effect of Fine-Tuning: Next, we verify that fine-tuning reduces the accumulation of error rate between layers by comparing the accuracy of the models with and without finetuning after prune. Indeed, Table <ref type="table">5</ref> shows that the detrimental effect of pruning is mitigated by performing fine-tuning. However, this effect is visible only in higher layers. At layer Conv21, post pruning results are 94% on the LFW benchmark for both methods. At Conv41, fine-tuning results are 93% compared to 88.43% -a difference of 4.5% in error rate. The increasing gap can be explained by the accumulated error caused by pruning all previous layers.</p><p>Model Acceleration: Finally, we evaluate the effect of pruning each layer sequentially on the speed of representing a facial image. The accuracy and performance results are TABLE 6. RR accuracy: Accuracy for RR methods and other methods of the same architecture. We evaluate random, variance based, variance based and fine-tuned. We also compare it with low-rank approximation. For the FT approach, we also report the accuracy prior to FT. The model is pruned sequentially, i.e. the results are indicated for pruning up to the indicated layer. LOW indicates results that were clearly non-competitive and were, therefore, not prioritized for exact estimation.</p><p>summarized in Table <ref type="table">5</ref>. The percentage of pruning for each layer was chosen empirically based on the model's CASIA accuracy (prior to fine-tuning) so that the accuracy threshold was chosen to be above 84%. We note that we cannot apply our method on layer Conv11 since it operates on a single channel gray scale image. In addition, since the contribution variance of channels between filters is not uniform, the number of channels pruned from each filter is different. Finally, we achieved a speedup of roughly ×1.5 with an accuracy drop of 1.11% on LFW.</p><p>Note that the reduction in the number of multiplications is not fully realized in the actual run time. In order to separate the contribution of the channels, such that different channels contribute to different filters, we had to separate the channels, which created an additional overhead. Put differently, the software package is optimized for the case in which it is assumed that all channels contribute to all filters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. REDUCE AND REUSE</head><p>Table <ref type="table">6</ref> summarizes our results for the reduce and reuse pruning method. In this experiment we reduce and reused the model layers sequentially using different settings. First, we evaluated random pruning where we randomly pruned each layer. Second, we apply variance based reduce and reuse. Third, we add fine-tuning after each layer. In addition, we compare our results with the decomposition suggested by Zhang et al. <ref type="bibr" target="#b17">[18]</ref>. We do not reduce and reuse layer Conv11 since the amount of reduction required in order to achieve a speedup results in a major decrease in accuracy.</p><p>Reduce and reuse is evaluated in three models: RR50%, RR75% and RR90%-50%. RR50% and RR75% are models generated by applying the same reduce ratio to all layers. RR-90%-50% is the model generated by applying 90% prune up to Conv32 and continuing with 50% prune afterwards. We chose this ratio empirically by observing that either 75% or 90% degraded the accuracy significantly after Conv32.</p><p>Initially, we compare the variance based RR with random based. While there is not much difference in accuracy when pruning 50% of each layer, the advantage becomes clear in 75% pruning. When comparing 75% prune of Conv22, the LFW accuracy of variance based RR is 94.02% and for the random RR it is 93.6%. In addition, the accuracy drop with random pruning is faster. Random RR75% CASIA accuracy drops from 81.78% to 52.40% between Conv22 to Conv32 while variance based RR75% drops from 82.32% to 59.26%.</p><p>As with inbound prune, fine-tuning improves the prune scheme effectiveness in two ways. First, it improves the accuracy achieved post pruning. For example, when 75% of the filters up to layer Conv22 are pruned we are able to increase the model LFW accuracy by 0.4%. Furthermore, fine-tuning allows the model to adapt to the pruning process, and as a result the subsequent error accumulates much more slowly.</p><p>In the table, we refer to the method proposed by Zhang et al. <ref type="bibr" target="#b17">[18]</ref> as ''low-rank approximation''. We compare their method to ours by reducing each layer by the same scale for both settings -50%,75% and 90%-50%. Evidently, the error accumulation is somewhat less harsh in comparison to the variance based RR prior to fine-tuning. Nonetheless, following the fine-tuning our method is superior. This can be seen in the results of the layer Conv32, 75% setting. Our method achieved 94.1% on LFW compared with 93%. Fine-tuning is a crucial part of our method since it allows the network to adapt after each prune.</p><p>An interesting property that we found is the rapid increase in error, the deeper the network is pruned. This can be explained by the fact that modern architectures, such as in our baseline model, follow the scheme of increasing the number of output channels as the feature maps size decreases. Since our method prunes the number of channels -the amount of information loss in the deeper layers is more prominent resulting in the increased error.</p><p>We also note that in the reduce and reuse method, random pruning does almost as well as variance based RR. However, in the inbound method, it performs poorly. The inbound method is inherently more sensitive to pruning, since during the reduce and reuse method, the pruned layer output is reconstructed. The optimization performed during the reuse phase reduces the error -even for the random pruning.</p><p>Model Acceleration: We report the performance and size of the models produced by this method in Table <ref type="table">7</ref>, 8, and 9. As before, we specify the number of parameters and multiplication required by the model for extracting features from a single face image. Using the reduce and reuse scheme, we were able to speed-up the model by ×2.37 with an LFW accuracy loss of 1.52%. TABLE 7. 50% reduce performance: Time is reported in seconds; the number of multiplications is reported in G-Ops. We also report the amount of parameters that the model contains. The layer column reports the layer the network was pruned up to. TABLE 8. 75% reduce performance: Time is reported in seconds; the number of multiplications is reported in G-Ops. We also report the number of parameters that the model contains. The layer column reports the layer the network was pruned up to. TABLE 9. 90%-50% reduce performance: Time is reported in seconds; the number of multiplications is reported in G-Ops. We also report the number of parameters that the model contains. The layer column reports the layer the network was pruned up to.</p><p>We note that the theoretical speed-up, O( nmk 2 n n+n mk 2 ), is not fully realized and the actual speed-up seen during our evalu-ation is considerably lower. We attribute this to the fact that the underling mobile implementation of the computation of each layer is already optimized using vectorized operations. The added overhead of adding additional layers adds to the runtime beyond the layer's multiplications. We verified this by comparing various architectures of different depths, in which the total number of multiplications is the same. The shallower the architecture, the shorter the run time using the existing deep frameworks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. HYBRID PRUNING</head><p>In Table <ref type="table" target="#tab_3">10</ref>, we show the results for employing bi-directional pruning of the baseline model. We start with the RR version of the baseline model which achieved satisfying accuracy results, i.e. a LFW score of above 94% and apply inbound prune on that model. Specifically, we perform inbound prune of the models produced by RR50% and RR75%, pruned up to layer Conv32 using reduce and reuse, and RR90%-50% up to Conv52. In all three cases, we further prune 25% of incoming channels up to Conv32. In Table <ref type="table" target="#tab_3">10</ref> we show the accuracy and performance of the bi-directional prune products. By pruning RR90%-50% we were able to speed-up the baseline model by more than ×2.65 with a minor reduction in accuracy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. METHOD COMPARISON</head><p>In addition to low rank approximation, we also compare our method to the fitnet method, which unlike the low-rank method, produces a different network architecture. Table <ref type="table" target="#tab_0">11</ref> reports the accuracy and timing of the models that we trained using this fitnet method. Our hybrid method produced faster and more accurate models than the models produced by the fitnet method. TABLE 11. Fitnet accuracy: The running time is in seconds. We count the number of multiplications and parameters in each network. The amount of multiplications is given in G-Ops.</p><p>Moreover, the training time required for our hybrid method was less than that of the fitnet method. Although our method is composed of multiple fine-tuning steps, the total amount of epochs required is less than 400 epochs. On the other hand, the fitnet method which is based on two training steps: hint-based and knowledge distillation, required more than TABLE 12. Method comparison: the table reports the best model for each method discussed: RR, inbound prune, hybrid, fitnet and low-rank approximation. The Layer column specifies the layer that each model was pruned up to. Time is reported in seconds. Speedup is reported relative to baseline model time. The number of multiplications is reported in G-Ops. Finally, the parameter reduction depicts the number of parameters relative to baseline. 600 epochs. During the knowledge distillation phase, the fitnet model is trained by optimizing two loss function which requires more epochs to converge.</p><p>We conclude this section by comparing all of the models generated in our study. In Table <ref type="table" target="#tab_0">12</ref> we report the best model per method. Our hybrid method achieves better accuracy than that of fitnet and is faster. Our method accelerated the baseline model by more than ×2.5 with a drop of 1.77% in accuracy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. CONCLUSION</head><p>We describe two methods for network compression that are specifically suited for CNNs. The methods employ a simple variance-based criterion which is readily computed. Therefore, the pruning process does not require solving an optimization problem.</p><p>We propose two methods: in one, we selectively remove input channels from the computation of the channels of the next layer. This makes use of the fact that the computation of each channel is influenced to a different degree from the channels of the previous layers. However, this pattern of influence varies between the computed channels and therefore requires a per-channel selection process. In the second method, we eliminate entire channels making use of the redundancy in the representation. However, in order to not affect subsequent layers, we reconstruct back the removed channels.</p><p>While the compression method introduces a few extra parameters such as the number of channels to prune (µ), pruning threshold (τ ) and the size of the sample set, the number of additional parameters is small compared to the entire set of parameters, and the system does not seem to be overly sensitive to these parameters. In addition, searching over the space of these parameters, if one chooses to do so, is much faster than optimizing the convnet itself.</p><p>We compare our method to recent work in the field of network compression. This is done to the low rank approximation of <ref type="bibr" target="#b17">[18]</ref> and to fitnet <ref type="bibr" target="#b13">[14]</ref>. We demonstrate convincingly that the suggested pruning methods are more effective in the compression of the scratch face recognition network. Overall, without modifying the software to the structure of the new network, we are able to obtain a run time improvement of up to 2.65 times while suffering a very moderate loss of accuracy. This run time improvement is significant since the overall network structure, the software modules, and the performance remain unchanged.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>FIGURE 1 .</head><label>1</label><figDesc>FIGURE 1. Illustration of pruning schemes. (a)The original convolution layer, each of the n output channels is computed using all m input channels. (b) The layer produced by inbound prune. The number of input channels for each filter is reduced, such that each filter employs a suitable subset of the channels. (c) The layer produced by reduce and reuse. Here, the number of filters is reduced from n to n followed by a new layer that reconstructs back the original channels.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>FIGURE 2 .</head><label>2</label><figDesc>FIGURE 2. Distribution of channel contributions. Depict score distributions for layers Conv12,Conv21,Conv22 by order in rows. (a-c) Show (y-axis) the standard deviation score √ σ ts of each channel contribution for three random filter outputs. Each of the subplots shows results for one random t , and the x-axis are the indices of s. (d) A histogram of the score for the entire layer in log scale, created by pooling the scores from all channels and all filters. Channels with zero standard deviation are depicted as the bar on the far left side of each distribution.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>FIGURE 3 .</head><label>3</label><figDesc>FIGURE 3. Random vs. Variance. We compare the results of variance based inbound pruning to random selection. From each layer, we prune 50% of the input channels and report the accuracy for CASIA (top) and LFW (bottom). Full bars depict variance based pruning; empty bars depict the accuracy for random based prune. For the random selection, we average the accuracy over 10 experiments. As can be seen, pruning by the variance score is preferable by a large gap.</figDesc><graphic coords="9,343.58,204.37,148.21,263.47" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>TABLE 1 .</head><label>1</label><figDesc>The scratch model by the authors of</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE 3 .</head><label>3</label><figDesc>Reduce and reuse architectures.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE 4 .</head><label>4</label><figDesc>Fitnet architectures. From left to right the architectures become deeper.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>TABLE 10 .</head><label>10</label><figDesc>Hybrid method. The running time is in seconds. We count the number of multiplications and parameters in each network. The amount of multiplications is given in G-Ops.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Personal use is also permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>VOLUME 3, 2015   </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2168" xml:id="foot_2"><p>  VOLUME 3, 2015   </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2172" xml:id="foot_3"><p>  VOLUME 3, 2015   </p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>The authors would like to thank Sivan Toledo for fruitful discussions.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Backpropagation applied to handwritten zip code recognition</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lecun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neural Comput</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="541" to="551" />
			<date type="published" when="1989-12">Dec. 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="https://github.com/soumith/torch-android" />
		<title level="m">Torch7 Android Port</title>
		<imprint>
			<date type="published" when="2010-09-30">Sep. 30, 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">DeepFace: Closing the gap to human-level performance in face verification</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Taigman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ranzato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wolf</surname></persName>
		</author>
		<idno type="DOI">10.1109/CVPR.2014.220</idno>
		<ptr target="http://dx.doi.org/10.1109/CVPR.2014.220" />
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Conf. Comput. Vis. Pattern Recognit. (CVPR)</title>
		<meeting>IEEE Conf. Comput. Vis. Pattern Recognit. (CVPR)<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-06">Jun. 2014</date>
			<biblScope unit="page" from="1701" to="1708" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Deep learning face representation from predicting 10,000 classes</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Tang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Conf. Comput. Vis. Pattern Recognit. (CVPR)</title>
		<meeting>IEEE Conf. Comput. Vis. Pattern Recognit. (CVPR)</meeting>
		<imprint>
			<date type="published" when="2014-06">Jun. 2014</date>
			<biblScope unit="page" from="1891" to="1898" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Deep learning face representation by joint identification-verification</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Tang</surname></persName>
		</author>
		<ptr target="http://papers.nips.cc/paper/5416-deep-learning-face-representation-by-joint-identification-verification.pdf" />
	</analytic>
	<monogr>
		<title level="s">Advances in Neural Information Processing Systems</title>
		<editor>
			<persName><forename type="first">Z</forename><surname>Ghahramani</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Welling</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Cortes</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">N</forename><surname>Lawrence</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><surname>Weinberger</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="1988" to="1996" />
			<date type="published" when="2014">2014</date>
			<publisher>Curran Associates</publisher>
			<pubPlace>Red Hook, NY, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Deeply learned face representations are sparse, selective, and robust</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Tang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Conf. Comput. Vis. Pattern Recognit. (CVPR)</title>
		<meeting>IEEE Conf. Comput. Vis. Pattern Recognit. (CVPR)</meeting>
		<imprint>
			<date type="published" when="2015-06">Jun. 2015</date>
			<biblScope unit="page" from="2892" to="2900" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">DeepID3: Face recognition with very deep neural networks</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Tang</surname></persName>
		</author>
		<ptr target="http://arxiv.org/abs/1502.00873" />
	</analytic>
	<monogr>
		<title level="j">CoRR</title>
		<imprint>
			<date type="published" when="2015-02">Feb. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Very deep convolutional networks for large-scale image recognition</title>
		<author>
			<persName><forename type="first">K</forename><surname>Simonyan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zisserman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Learn. Represent. (ICLR)</title>
		<meeting>Int. Conf. Learn. Represent. (ICLR)</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Going deeper with convolutions</title>
		<author>
			<persName><forename type="first">C</forename><surname>Szegedy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Conf. CVPR</title>
		<meeting>IEEE Conf. CVPR</meeting>
		<imprint>
			<date type="published" when="2015-06">Jun. 2015</date>
			<biblScope unit="page" from="1" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">FaceNet: A unified embedding for face recognition and clustering</title>
		<author>
			<persName><forename type="first">F</forename><surname>Schroff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kalenichenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Philbin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Conf. Comput. Vis. Pattern Recognit. (CVPR)</title>
		<meeting>IEEE Conf. Comput. Vis. Pattern Recognit. (CVPR)</meeting>
		<imprint>
			<date type="published" when="2015-06">Jun. 2015</date>
			<biblScope unit="page" from="815" to="823" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Targeting ultimate accuracy: Face recognition via deep embedding</title>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Bai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Huang</surname></persName>
		</author>
		<ptr target="http://arxiv.org/abs/1506.07310" />
	</analytic>
	<monogr>
		<title level="j">CoRR</title>
		<imprint>
			<date type="published" when="2015-06">Jun. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Learning face representation from scratch</title>
		<author>
			<persName><forename type="first">D</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Lei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Liao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">Z</forename><surname>Li</surname></persName>
		</author>
		<ptr target="http://arxiv.org/abs/1411.7923" />
	</analytic>
	<monogr>
		<title level="j">CoRR</title>
		<imprint>
			<date type="published" when="2014-11">Nov. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Do deep nets really need to be deep?</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Caruana</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Advances in Neural Information Processing Systems</title>
		<editor>
			<persName><forename type="first">Z</forename><surname>Ghahramani</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Welling</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Cortes</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">N</forename><surname>Lawrence</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><surname>Weinberger</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="2654" to="2662" />
			<date type="published" when="2014">2014</date>
			<publisher>Curran Associates</publisher>
			<pubPlace>Red Hook, NY, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">FitNets: Hints for thin deep nets</title>
		<author>
			<persName><forename type="first">A</forename><surname>Romero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Ballas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">E</forename><surname>Kahou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Chassang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gatta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Learn. Represent. (ICLR)</title>
		<meeting>Int. Conf. Learn. Represent. (ICLR)</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Distilling the knowledge in a neural network</title>
		<author>
			<persName><forename type="first">G</forename><surname>Hinton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Vinyals</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dean</surname></persName>
		</author>
		<ptr target="http://arxiv.org/abs/1503.02531" />
	</analytic>
	<monogr>
		<title level="j">CoRR</title>
		<imprint>
			<date type="published" when="2015-03">Mar. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Exploiting linear structure within convolutional networks for efficient evaluation</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">L</forename><surname>Denton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zaremba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bruna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lecun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fergus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Advances in Neural Information Processing Systems</title>
		<editor>
			<persName><forename type="first">Z</forename><surname>Ghahramani</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Welling</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Cortes</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">N</forename><surname>Lawrence</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><surname>Weinberger</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="1269" to="1277" />
			<date type="published" when="2014">2014</date>
			<publisher>Curran Associates</publisher>
			<pubPlace>Red Hook, NY, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Speeding up convolutional neural networks with low rank expansions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Jaderberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vedaldi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zisserman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Brit. Mach. Vis. Conf</title>
		<meeting>Brit. Mach. Vis. Conf</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Accelerating very deep convolutional networks for classification and detection</title>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sun</surname></persName>
		</author>
		<ptr target="http://arxiv.org/abs/1505.06798" />
	</analytic>
	<monogr>
		<title level="j">CoRR</title>
		<imprint>
			<date type="published" when="2015-05">May 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yan</surname></persName>
		</author>
		<title level="m">Proc. Int. Conf. Learn. Represent. (ICLR)</title>
		<meeting>Int. Conf. Learn. Represent. (ICLR)</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Optimal brain damage</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lecun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Denker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Solla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Advances in Neural Information Processing Systems</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="598" to="605" />
			<date type="published" when="1990">1990</date>
			<publisher>Morgan Kaufmann</publisher>
			<pubPlace>San Mateo, CA, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Second order derivatives for network pruning: Optimal brain surgeon</title>
		<author>
			<persName><forename type="first">B</forename><surname>Hassibi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">G</forename><surname>Stork</surname></persName>
		</author>
		<ptr target="ftp://ftp.ci.tuwien.ac.at/pub/texmf/bibtex/nips-4.bib" />
	</analytic>
	<monogr>
		<title level="s">Advances in Neural Information Processing Systems</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Moody</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Hanson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Lippmann</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<date type="published" when="1992">1992</date>
			<publisher>Morgan Kaufmann</publisher>
			<pubPlace>San Francisco, CA, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Evaluating pruning methods</title>
		<author>
			<persName><forename type="first">G</forename><surname>Thimm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Fiesler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Symp. Artif</title>
		<meeting>Int. Symp. Artif</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="1" to="4" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Sparse connection and pruning in large dynamic artificial neural networks,&apos;</title>
		<author>
			<persName><forename type="first">N</forename><surname>Ström</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">&apos; in Proc. EUROSPEECH</title>
		<imprint>
			<biblScope unit="page" from="1" to="4" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Learning both weights and connections for efficient neural networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pool</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Dally</surname></persName>
		</author>
		<ptr target="http://arxiv.org/abs/1506.02626" />
	</analytic>
	<monogr>
		<title level="j">CoRR</title>
		<imprint>
			<date type="published" when="2015-07">Jul. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Fast convnets using group-wise brain damage</title>
		<author>
			<persName><forename type="first">V</forename><surname>Lebedev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Lempitsky</surname></persName>
		</author>
		<ptr target="http://arxiv.org/abs/1506.02515" />
	</analytic>
	<monogr>
		<title level="j">CoRR</title>
		<imprint>
			<date type="published" when="2015-06">Jun. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">). &apos;&apos;PerforatedCNNs: Acceleration through elimination of redundant convolutions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Figurnov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vetrov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kohli</surname></persName>
		</author>
		<ptr target="http://arxiv.org/abs/1504.08362" />
		<imprint>
			<date type="published" when="2015-04">Apr. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Improving neural networks by preventing co-adaptation of feature detectors</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Hinton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Krizhevsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Salakhutdinov</surname></persName>
		</author>
		<ptr target="http://arxiv.org/abs/1207.0580" />
		<imprint>
			<date type="published" when="2012-07">Jul. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Regularization of neural networks using dropconnect</title>
		<author>
			<persName><forename type="first">L</forename><surname>Wan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zeiler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lecun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fergus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 30th Int. Conf. Mach. Learn. (ICML)</title>
		<meeting>30th Int. Conf. Mach. Learn. (ICML)</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1058" to="1066" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Efficient object localization using convolutional networks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Tompson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Goroshin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lecun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bregler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Conf. Comput. Vis. Pattern Recognit. (CVPR)</title>
		<meeting>IEEE Conf. Comput. Vis. Pattern Recognit. (CVPR)</meeting>
		<imprint>
			<date type="published" when="2015-06">Jun. 2015</date>
			<biblScope unit="page" from="648" to="656" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Fast training of convolutional networks through FFTs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Mathieu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Henaff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lecun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Learn. Represent. (ICLR)</title>
		<meeting>Int. Conf. Learn. Represent. (ICLR)</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">). &apos;&apos;Fast convolutional nets with fbfft: A GPU performance evaluation</title>
		<author>
			<persName><forename type="first">N</forename><surname>Vasilache</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mathieu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chintala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Piantino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lecun</surname></persName>
		</author>
		<ptr target="http://arxiv.org/abs/1412.7580" />
		<imprint>
			<date type="published" when="2015-04">Apr. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Improving the speed of neural networks on CPUs</title>
		<author>
			<persName><forename type="first">V</forename><surname>Vanhoucke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Senior</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Z</forename><surname>Mao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Deep Learn. Unsupervised Feature Learn. NIPS Workshop</title>
		<meeting>Deep Learn. Unsupervised Feature Learn. NIPS Workshop</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Low precision arithmetic for deep learning</title>
		<author>
			<persName><forename type="first">M</forename><surname>Courbariaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>David</surname></persName>
		</author>
		<idno>abs/1412.7024</idno>
		<ptr target="http://arxiv.org/abs/1412.7024" />
	</analytic>
	<monogr>
		<title level="j">CoRR</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Labeled faces in the wild: Updates and new reporting procedures</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">B</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Learned-Miller</surname></persName>
		</author>
		<idno>UM-CS-2014-003</idno>
	</analytic>
	<monogr>
		<title level="j">Dept. Comput. Sci., Univ. Massachusetts Amherst</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<pubPlace>Amherst, MA, USA</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Bayesian face revisited: A joint formulation</title>
		<author>
			<persName><forename type="first">D</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Wen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 12th Eur. Conf. Comput. Vis</title>
		<meeting>12th Eur. Conf. Comput. Vis</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="566" to="579" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">&apos;&apos;Hello! My name is. . . Buffy&apos;-Automatic naming of characters in TV video</title>
		<author>
			<persName><forename type="first">M</forename><surname>Everingham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sivic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zisserman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Brit. Mach. Vis. Conf</title>
		<meeting>Brit. Mach. Vis. Conf</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Torch7: A MATLAB-like environment for machine learning</title>
		<author>
			<persName><forename type="first">R</forename><surname>Collobert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kavukcuoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Farabet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NIPS Workshop BigLearn</title>
		<meeting>NIPS Workshop BigLearn</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Delving deep into rectifiers: Surpassing human-level performance on ImageNet classification</title>
		<author>
			<persName><forename type="first">K</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sun</surname></persName>
		</author>
		<ptr target="http://arxiv.org/abs/1502.01852" />
		<imprint>
			<date type="published" when="2015-02">Feb. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">received the bachelor&apos;s degree in computer science and mathematics from BarIlan University as part of the program for mathematically talented youth, and the master&apos;s (Hons.) (magna cum laude) degree under the guidance of Prof. L. Wolf from Tel Aviv University. His current field of research is deep learning</title>
		<author>
			<persName><forename type="first">Adam</forename><surname>Polyak</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>specificially the acceleration of neural networks</note>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">He was a Post-Doctoral Associate in the Prof. Poggio&apos;s Laboratory at the Massachusetts Institute of Technology. He received the</title>
		<author>
			<persName><forename type="first">Lior</forename><surname>Wolf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">His joint work with Prof. Shashua in ECCV 2000 received the best paper award, and their work in ICCV 2001 received the Marr Prize honorable mention. He was also awarded the best paper award at the post ICCV 2009 workshop on eHeritage, and the preCVPR2013 Workshop on Action Recognition. His research focuses on computer vision and applications of machine learning and includes topics</title>
		<meeting><address><addrLine>Jerusalem</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004">2008. 2006-2008. 2004</date>
		</imprint>
		<respStmt>
			<orgName>Hebrew University ; Computer Science, Tel Aviv University</orgName>
		</respStmt>
	</monogr>
	<note>Sackler Career Development Chair, the Colton Excellence Fellowship for new faculty. such as face identification, document analysis, digital paleography, and video action recognition</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
