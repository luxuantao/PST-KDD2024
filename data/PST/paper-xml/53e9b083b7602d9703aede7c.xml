<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Ant Colony Optimization for Software Project Scheduling and Staffing with an Event-Based Scheduler</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2012-03-02">2 Mar. 2012.</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Wei-Neng</forename><surname>Chen</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">Ministry of Education, and Key Laboratory of Software Technology</orgName>
								<orgName type="department" key="dep3">Education Department of Guangdong Province</orgName>
								<orgName type="laboratory">Key Laboratory of Machine Intelligence and Sensor Network</orgName>
								<orgName type="institution">Sun Yat-Sen University</orgName>
								<address>
									<addrLine>No. 132, Wai-Huan-Dong Road, Da-Xue-Cheng</addrLine>
									<postCode>510006</postCode>
									<settlement>Guangzhou</settlement>
									<country key="CN">P.R. China</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><roleName>Senior Member, IEEE</roleName><forename type="first">Jun</forename><surname>Zhang</surname></persName>
							<email>junzhang@ieee.org</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">Ministry of Education, and Key Laboratory of Software Technology</orgName>
								<orgName type="department" key="dep3">Education Department of Guangdong Province</orgName>
								<orgName type="laboratory">Key Laboratory of Machine Intelligence and Sensor Network</orgName>
								<orgName type="institution">Sun Yat-Sen University</orgName>
								<address>
									<addrLine>No. 132, Wai-Huan-Dong Road, Da-Xue-Cheng</addrLine>
									<postCode>510006</postCode>
									<settlement>Guangzhou</settlement>
									<country key="CN">P.R. China</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Ant Colony Optimization for Software Project Scheduling and Staffing with an Event-Based Scheduler</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2012-03-02">2 Mar. 2012.</date>
						</imprint>
					</monogr>
					<idno type="MD5">C40250890B5D86B5ABE1604F6E0D492C</idno>
					<idno type="DOI">10.1109/TSE.2012.17</idno>
					<note type="submission">received 15 Dec. 2010; revised 7 Jan. 2012; accepted 8 Feb. 2012;</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:18+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Software project planning</term>
					<term>project scheduling</term>
					<term>resource allocation</term>
					<term>workload assignment</term>
					<term>ant colony optimization (ACO)</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Research into developing effective computer aided techniques for planning software projects is important and challenging for software engineering. Different from projects in other fields, software projects are people-intensive activities and their related resources are mainly human resources. Thus, an adequate model for software project planning has to deal with not only the problem of project task scheduling but also the problem of human resource allocation. But as both of these two problems are difficult, existing models either suffer from a very large search space or have to restrict the flexibility of human resource allocation to simplify the model. To develop a flexible and effective model for software project planning, this paper develops a novel approach with an event-based scheduler (EBS) and an ant colony optimization (ACO) algorithm. The proposed approach represents a plan by a task list and a planned employee allocation matrix. In this way, both the issues of task scheduling and employee allocation can be taken into account. In the EBS, the beginning time of the project, the time when resources are released from finished tasks, and the time when employees join or leave the project are regarded as events. The basic idea of the EBS is to adjust the allocation of employees at events and keep the allocation unchanged at nonevents. With this strategy, the proposed method enables the modeling of resource conflict and task preemption and preserves the flexibility in human resource allocation. To solve the planning problem, an ACO algorithm is further designed. Experimental results on 83 instances demonstrate that the proposed method is very promising.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>W ITH the rapid development of the software industry, software companies are now facing a highly competitive market. To succeed, companies have to make efficient project plans to reduce the cost of software construction <ref type="bibr" target="#b0">[1]</ref>. However, in medium to large-scale projects, the problem of project planning is very complex and challenging <ref type="bibr" target="#b1">[2]</ref>. In fact, in China it was reported that more than 40 percent of unsuccessful software projects failed because of inefficient planning of project tasks and human resources <ref type="bibr" target="#b2">[3]</ref>. Due to the importance and difficulty of software project planning, there is a growing need for developing effective computer aided tools for software project planning in recent years <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b5">[6]</ref>.</p><p>To plan a software project, the project manager needs to estimate the project workload and cost and decide the project schedule and resource allocation. For workload and cost estimation, some famous models like COCOMO <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b7">[8]</ref> have been developed and widely used. For scheduling and staffing management, similarly to other projects (e.g., construction projects), management is usually conducted by project management tools and techniques. For example, traditional project management techniques like the program evaluation and review technique (PERT), the critical path method (CPM) <ref type="bibr" target="#b8">[9]</ref>, and the resource-constrained project scheduling problem (RCPSP) model <ref type="bibr" target="#b9">[10]</ref> have been applied in software project planning. Although these methods are important and helpful, they are increasingly considered to be inadequate for modeling the unique characteristics of today's software projects <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b13">[14]</ref>. The main reason is that, differently from other projects, a software project is a people-intensive activity and its related resources are mainly human resources <ref type="bibr" target="#b3">[4]</ref>. Different software project tasks require employees with different skills, and skill proficiency of employees significantly influences the efficiency of project execution. As such, assigning employees to the best-fitted tasks is challenging for software project managers, and human resource allocation has become a crucial part in software project planning. Techniques like PERT and CPM lack the consideration of resource allocation and scheduling models like the RCPSP do not consider the allocation of employees with various skills. Therefore, the tools based on these traditional project management techniques usually regard task scheduling and human resource allocation as two separated activities and leave the job of human resource allocation to be done by project managers manually <ref type="bibr" target="#b14">[15]</ref>, resulting in inefficient resource allocation and poor management performance. Moreover, as the main resources in software development are humans instead of big machines, resources in software projects can usually be allocated in a more flexible way than those in construction or manufacturing projects. In contemporary software projects, it is common that a programmer joins multiple module development tasks simultaneously, and it is also possible that he stops his current work and joins the other more critical tasks <ref type="bibr" target="#b2">[3]</ref>. If task preemption is properly designed, human resources can be organized in a more efficient way. Some research has pointed out that task preemption can have a significant impact on reducing the time and cost of a software project <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b15">[16]</ref>. However, currently, task preemption is still sparsely considered in software project management models and tools <ref type="bibr" target="#b16">[17]</ref>. Most existing models have the assumption that each employee can only be assigned to a single task at one time <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b18">[19]</ref>, <ref type="bibr" target="#b19">[20]</ref>. This assumption reduces the flexibility of resource allocation in software project planning.</p><p>To build more suitable models and tools, traditional project management techniques need to be further extended. One noteworthy approach is to model software project planning as a search-based optimization problem. During the last decade, the idea of formulating software engineering as search-based problems has attracted increasing attention <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b21">[22]</ref>. Various software engineering activities such as cost estimation <ref type="bibr" target="#b22">[23]</ref>, module clustering <ref type="bibr" target="#b23">[24]</ref>, design <ref type="bibr" target="#b24">[25]</ref>, testing <ref type="bibr" target="#b25">[26]</ref>, <ref type="bibr" target="#b26">[27]</ref>, and software release planning <ref type="bibr" target="#b27">[28]</ref> have been modeled as search-based problems and metaheuristic algorithms have been applied successfully. Search-based approaches may also become a promising way for software project planning.</p><p>In the literature, several works have been done on developing search-based approaches for software project planning. Duggan et al. <ref type="bibr" target="#b1">[2]</ref> and Barreto et al. <ref type="bibr" target="#b3">[4]</ref> built models for the staffing problem of software projects and proposed genetic algorithm (GA) approaches. But, their models only focused on staffing and the problem of task scheduling was not considered. <ref type="bibr">Chang et al.</ref> proposed the software project management net (SPMnet) model <ref type="bibr" target="#b11">[12]</ref> and the project management net (PM-net) model <ref type="bibr" target="#b10">[11]</ref> successively, and then further improved the models to a richer version with a GA <ref type="bibr" target="#b14">[15]</ref>. Other GA-based approaches were also proposed in <ref type="bibr" target="#b4">[5]</ref> and <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b29">[30]</ref>, <ref type="bibr" target="#b30">[31]</ref>, <ref type="bibr" target="#b31">[32]</ref>. In these approaches, a plan is described by a 2D matrix which specifies the workload of each employee on each task. But, as this representation is inadequate for modeling resource conflict, these models all implicitly uses the "Mongolian Horde" strategy <ref type="bibr" target="#b5">[6]</ref> that assumes an unlimited number of employees can be assigned to a task and an employee can join an unlimited number of tasks simultaneously, which is usually not the case in practice. Bellenguez and Ne ´ron <ref type="bibr" target="#b18">[19]</ref>, <ref type="bibr" target="#b19">[20]</ref> proposed a multiskill scheduling model by extending the traditional RCPSP model. The model considers both the problems of human resource allocation and task scheduling, and takes the skill proficiency of employees and resource conflict into account. Tabu search (TS) <ref type="bibr" target="#b18">[19]</ref>, branch and bound <ref type="bibr" target="#b19">[20]</ref>, and GA <ref type="bibr" target="#b17">[18]</ref> have been developed for the model. In all of the above-mentioned models, there is an assumption that preemption is not allowed. As discussed before, this assumption reduces the flexibility of human resource allocation for software projects. Task preemption in software projects is only considered in a few studies. In Chang's recent work <ref type="bibr" target="#b5">[6]</ref>, he improved his previous scheduling model by introducing a 3D matrix representation, specifying the workload assignment of each employee for each task on each time period. Although this representation is much more flexible, it makes the search space very large and suffers from the problem of desultory assignment of workloads.</p><p>Overall, developing effective approaches for software project scheduling and employee allocation remains a challenging problem and deserves further research.</p><p>In this paper, we develop a practical and effective approach for the task scheduling and human resource allocation problem in software project planning with an ant colony optimization (ACO) algorithm. Different from the existing approaches, the proposed method is characterized by the following two features.</p><p>First, a representation scheme with a novel event-based scheduler (EBS) is developed. The representation scheme is composed of a task list and a planned employee allocation matrix. The task list defines the priorities of tasks to consume resources, and the planned employee allocation matrix specifies the originally planned workload assignments. In this way, the representation takes both the issues of task scheduling and resource allocation into account. The EBS regards the beginning time of the project, the time when resources are released from any finished task, and the time when employees join or leave the project as events. To generate an actual timetable, the EBS adjusts the workload assignments of employees at events and resource conflict is solved according to the priority defined by the task list. In this way, the proposed scheme is practical and flexible as it enables the modeling of task preemption and resource conflict. At the same time, compared with the 3D matrix representation <ref type="bibr" target="#b5">[6]</ref>, the proposed scheme reduces the size of the search space and thus accelerates the search process. In addition, as the EBS only makes new assignments at events, it is able to keep the implementation of tasks in a more stable manner.</p><p>Second, different from the GA and TS approaches developed in the existing studies, we proposed an ACO approach. ACO was proposed by Dorigo <ref type="bibr" target="#b32">[33]</ref>, Dorigo and Gambardella <ref type="bibr" target="#b33">[34]</ref> in the early 1990s and by now has been successfully applied to various combinatorial optimization problems <ref type="bibr" target="#b34">[35]</ref>, <ref type="bibr" target="#b35">[36]</ref>, <ref type="bibr" target="#b36">[37]</ref>, <ref type="bibr" target="#b37">[38]</ref>, <ref type="bibr" target="#b38">[39]</ref>. As ACO builds solutions in a step-by-step manner and enables the use of problem-based heuristics to guide the search direction of ants, it is possible to design useful heuristics to direct the ants to schedule the critical tasks as early as possible and to assign the project tasks to suitable employees with required skills. Therefore, ACO promises to converge fast and perform well on the considered problem. In the experiments, the proposed method is compared with four other approaches on three real projects and 80 randomly generated instances. Experimental results show that the proposed approach is promising.</p><p>The rest of this paper is organized as follows: Section 2 formulates the model for software project task scheduling and human resource allocation. Section 3 reviews the related work of scheduling and staffing for software projects. Section 4 introduces the representation scheme and the EBS. In Section 5, the ACO algorithm is proposed. Section 6 analyzes the experimental results. Conclusions are finally drawn in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">MODEL DESCRIPTION</head><p>This paper considers a software project planning model that addresses both the problems of human resource allocation and task scheduling. The model is described in detail as follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Description of Employees</head><p>Software development is a people-intensive activity. To manage employees, an employee database is needed to record the employees' information of wages, skills, and working constraints. The problem of employee allocation is to assign employees to suitable tasks so that the tasks can be done efficiently. Suppose m employees are involved in the project, for the ith employee (i ¼ 1; 2; . . . ; m) the following attributes are considered.</p><p>. bs i -The basic salary for the employee per time period (e.g., month). . hs i -The salary for the employee's per-hour normal work. . ohs i -The salary for the employee's per-hour overtime work. . nh-Legal normal working hours per month. . maxh i -Maximum possible working hours per month of the employee for the project. . ½join i ; leave i -The time window when the employee is available for the project. . fs 1 i ; s 2 i ; . . . ; s È i g-The skill list for the employee, where È is the number of skills and s j i 2 ½0; 5 is the proficiency score of the jth skill. Here the skills can be documenting, C++ programming, GUI design, and any other technical abilities. s j i ¼ 0 means the employee does not have the skill and s j i ¼ 5 means the employee is masterly on that skill. Basic salaries are paid to regular employees every month regardless of the workloads the employees devote to the project. On the other hand, per-hour normal work salaries are paid according to the working hours. Usually, there are two types of employees: regular ones and temporary ones. Regular employees have stable basic salaries, while temporary ones do not have basic salaries but have much higher per-hour working salaries.</p><p>Let us suppose that the ith employee devotes hours t i hours to the project at the tth month (hours t i maxh i ). If hours t i is larger than the legal normal working hours nh, it implies that the employee works overtime for the project. The salary salary t i for the ith employee at the tth month is calculated by</p><formula xml:id="formula_0">salary t i ¼ bs i þ hours t i Á hs i ; hours t i nh; bs i þ nh Á hs i þ ðhours t i À nhÞ Á ohs i ; nh &lt; hours t i maxh i ; 1; hours t i &gt; maxh i : 8 &gt; &gt; &gt; &lt; &gt; &gt; &gt; :<label>ð1Þ</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Description of Tasks</head><p>In a software project, tasks can be any activity involved in software construction, for example, class design, programming, and testing. A commonly used technique for task description is the task precedence graph (TPG) <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b14">[15]</ref>. A TPG is an acyclic directed graph GðT ; AÞ. The set of nodes T ft 1 ; t 2 ; . . . ; t n g corresponds to the set of tasks, where n is the number of tasks in the project. The set of arcs A represents the precedence relations among tasks. An arcði; jÞ 2 A means t i is a direct predecessor task of t j . An example of a TPG is shown in Fig. <ref type="figure" target="#fig_0">1</ref>. Under the precedence constraint defined by the TPG, a task can only start when all of its direct predecessor tasks have finished. The problem of task scheduling is to construct an efficient timetable for the implementation of tasks subject to the precedence constraints. For a task t j ðj ¼ 1; 2; . . . ; nÞ, the following attributes are considered . pm j -The estimated work effort of the task in person months. Several famous methods, for example, the COCOMO models <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b7">[8]</ref>, can be adopted for work effort estimation. . SK j -The set of skills required by the task. . maxhead j -The maximum headcount for the task. In application, as too many employees working on the same task will incur higher communication overhead and result in low efficiency, it is necessary to limit the number of employees for a task. According to <ref type="bibr" target="#b5">[6]</ref>, the maximum headcount can also be estimated based on the COCOMO model. . deadline j and penalty j -The deadline and penalty of the task. In practice, it is common to define deadlines for milestone tasks. If the task is delayed, a penalty will be incurred. Based on the above definitions, suppose wh t ij is the number of working hours of the ith employee for t j at the tth month; according to <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b7">[8]</ref>, the achievement A t j yielded by the employees for t j at time t can be evaluated by the following steps:</p><p>1. The proficiency prof ij of the ith employee for t j can be evaluated by</p><formula xml:id="formula_1">prof ij ¼ Y id2SK j s id i 5 :<label>ð2Þ</label></formula><p>2. The total fitness F t j of the employees for t j on the tth month is given by</p><formula xml:id="formula_2">F t j ¼ P m i¼1 prof ij Á wh t ij P m i¼1 wh t ij :<label>ð3Þ</label></formula><p>3. Convert F t j to a cost driver value V ¼ 8 À roundðF t j Á 7 þ 0:5Þ, where the value of V belongs to 1-7. V ¼ 1 means the employees are the most suitable for the task and vice versa. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.</head><p>The achievement A t j for t j on the tth month is calculated by</p><formula xml:id="formula_3">A t j ¼ P m i¼1 wh t ij V :<label>ð4Þ</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Planning Objective</head><p>As the software project planning problem involves task scheduling and employee allocation, a plan for a project must specify when the tasks of the project are processed and how the workloads of employees are assigned to the tasks. More specifically, the plan has to determine the start time start j and the finish time finish j of each task t j ðj 2 f1; 2; . . . ; ngÞ, and the working hours wh t ij of all employees i 2 f1; 2; . . . ; mg to the task t j during the time window t 2 ½start j ; finish j . The plan must satisfy the following constraints:</p><p>1. The processing order of tasks must obey the precedence constraint defined by the TPG. 2. The working hours of the ith employee per month must not exceed the limit maxh i , i.e.,</p><formula xml:id="formula_4">X n j¼1 wh t ij ¼ hours t i maxh i ; t ¼ 1; 2; . . .<label>ð5Þ</label></formula><p>3. The number of employees assigned to a task t j is limited by the maximum headcount, i.e.,</p><formula xml:id="formula_5">X m i¼1 sign X finish j t¼start j wh t ij ! maxhead j ;</formula><p>where signðxÞ ¼</p><formula xml:id="formula_6">1; if x &gt; 0; 0; if x ¼ 0: &amp;<label>ð6Þ</label></formula><p>4. All tasks have to be complete. In other words, for a task t j , the sum of the achievements for t j during the time window ½start j ; finish j must satisfy</p><formula xml:id="formula_7">X finish j t¼startj A t j ! pm j :<label>ð7Þ</label></formula><p>This paper considers cost minimization as the objective function, which is given by</p><formula xml:id="formula_8">min f ¼ X end t¼1 salary t i þ X n j¼1 penalty j ;<label>ð8Þ</label></formula><p>where the first item is the salary expenditure and the second item is the total penalty.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RELATED WORK REVIEW</head><p>This paper intends to propose a representation scheme with a novel event-based scheduler and an ant colony optimization approach for the aforementioned problem. In order to better illustrate why the representation scheme and the EBS are designed, we first briefly review the existing (software) project planning models in this section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The Resource Constrained Project Scheduling Problem Model</head><p>The RCPSP is a classic model in project management which is NP-hard <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b39">[40]</ref>. It involves scheduling the tasks of a project subject to precedence and resource constraints. To build a schedule, one needs to determine an order of tasks which forms a task list</p><formula xml:id="formula_9">ðt p1 ; t p2 ; . . . ; t pn Þ;<label>ð9Þ</label></formula><p>where ðp 1 ; p 2 ; . . . ; p n Þ is a permutation of ð1; 2; . . . ; nÞ. The task list defines the tasks' priorities to consume resources when resource conflict occurs <ref type="bibr" target="#b9">[10]</ref>.</p><p>Although the RCPSP is important and widely used, it only focuses on the issue of project scheduling and does not take the issue of employee allocation into account. Therefore, the RCPSP is still inadequate for modeling the software project planning problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Employee Allocation Models</head><p>Employee allocation problems have attracted a considerable amount of research effort in recent years and various models like nurse rostering <ref type="bibr" target="#b40">[41]</ref> and personnel planning <ref type="bibr" target="#b41">[42]</ref>, <ref type="bibr" target="#b42">[43]</ref> have been proposed. There are also some studies that focus on the employee allocation problem in software projects <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b29">[30]</ref>, <ref type="bibr" target="#b30">[31]</ref>, <ref type="bibr" target="#b31">[32]</ref>. In these models, the problem of how to assign employees to different workstations (or tasks/time periods) is addressed. The optimization objective is to minimize the number of constraint violations <ref type="bibr" target="#b40">[41]</ref>, <ref type="bibr" target="#b41">[42]</ref>, <ref type="bibr" target="#b42">[43]</ref> or to minimize project duration and cost <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b29">[30]</ref>, <ref type="bibr" target="#b30">[31]</ref>, <ref type="bibr" target="#b31">[32]</ref>. Though the objectives of these models are quite different, they usually describe a plan for the problem by an employee allocation matrix. For example, in <ref type="bibr" target="#b14">[15]</ref>, the employee allocation matrix is described by</p><formula xml:id="formula_10">wh 11 wh 12 Á Á Á wh 1n wh 21 wh 22 Á Á Á wh 2n . . . . . . . . . . . . wh m1 wh m2 Á Á Á wh mn 8 &gt; &gt; &gt; &lt; &gt; &gt; &gt; : 9 &gt; &gt; &gt; = &gt; &gt; &gt; ; ;<label>ð10Þ</label></formula><p>where wh ij means the working hours of the ith employee for t j . These employee allocation models are helpful for managing human resources. However, they lack the consideration of task scheduling. To plan a software project, the project manager has to decide not only the allocation of human resources but also the start and finish time of each task. As the working duration of a task is dependent on the employees assigned to the task, separating task scheduling and employee allocation as two independent activities is considered to be unsuitable <ref type="bibr" target="#b5">[6]</ref>. In addition, an employee allocation matrix like <ref type="bibr" target="#b9">(10)</ref> has no information about how to deal with resource conflict. As a result, the employee allocation models for software project planning <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b29">[30]</ref>, <ref type="bibr" target="#b30">[31]</ref>, <ref type="bibr" target="#b31">[32]</ref> have to implicitly assume that a task can be conducted by an unlimited number of employees and an employee can be assigned to an unlimited number of tasks at one time, which is usually not the case in practice <ref type="bibr" target="#b5">[6]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Multiskill Scheduling Models</head><p>Considering the fact that software development involves a group of employees with different skills, Bellenguez and Ne ´ron <ref type="bibr" target="#b18">[19]</ref>, <ref type="bibr" target="#b19">[20]</ref> extended the traditional RCPSP model to propose a multiskill project scheduling model for software project planning. The model follows the framework of the RCPSP for task scheduling and regards different combinations of employees as different alternative modes for the implementation of a task. Tabu search and branch and bound algorithms were also developed for the problem. In a recent work <ref type="bibr" target="#b17">[18]</ref>, Yannibelli and Amandi further developed a representation scheme for the problem by combining the task list representation <ref type="bibr" target="#b8">(9)</ref> and the employee allocation matrix <ref type="bibr" target="#b9">(10)</ref>. Compared with the models aforementioned, as the multiskill scheduling model is derived from the original RCPSP and couples the modeling of employees with various skills, it provides a more practical way for software project planning as it can deal with both the problems of task scheduling and employee allocation. But, since the model assumes that an employee can only be assigned to a task at one time and no task preemption is allowed, the flexibility of human resource allocation is reduced. Under such restriction, if any one of the employees assigned to a task is busy with other activities, the whole team has to wait until that employee is released. This situation may reduce the resource efficiency of the project.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">The Time-Line-Based Model</head><p>To model the task scheduling and human resource allocation problem in a more flexible way, Chang et al. <ref type="bibr" target="#b5">[6]</ref> considered task scheduling and employee allocation together and developed a time-line-based model. Different from the previous approaches, the time-line-based model introduces the time-line axis to solution representation and thus a feasible plan is described as a 3D employee allocation matrix: </p><p>where wh t ij is the working hours of the ith employee for t j at time t.</p><p>The 3D representation is able to overcome the disadvantages of the RCPSP and the employee allocation models. But it also brings in two new problems. First, as workloads are assigned period-by-period instead of task-by-task, the plans produced by this model may assign two completely different groups of employees to the same task in different periods. As a result, the task may be implemented in a desultory manner, which is inefficient. Second, as the representation size of a schedule is enlarged from a 2D matrix to a 3D one, the search space of the problem significantly increases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">REPRESENTATION AND THE EVENT-BASED SCHEDULER</head><p>To overcome the deficiencies of the above-mentioned models, this paper proposes a representation scheme with a novel event-based scheduler. Similarly to the representation in Yannibelli and Amandi's recent work <ref type="bibr" target="#b17">[18]</ref> for the multiskill scheduling problem, we combine the task list representation <ref type="bibr" target="#b8">(9)</ref> and the employee allocation matrix representation <ref type="bibr" target="#b9">(10)</ref> so that both the problems of task scheduling and human resource allocation are addressed. The representation scheme is given by ( <ref type="formula" target="#formula_13">12</ref>) </p><formula xml:id="formula_12">Task</formula><p>Similarly to <ref type="bibr" target="#b8">(9)</ref>, the task list in ( <ref type="formula" target="#formula_13">12</ref>) also specifies the priorities of tasks in the schedule. However, differently from Yannibelli and Amandi's scheme <ref type="bibr" target="#b17">[18]</ref> that directly uses the employee allocation matrix <ref type="bibr" target="#b9">(10)</ref>, the proposed representation scheme in <ref type="bibr" target="#b11">(12)</ref> uses the planned employee allocation matrix. More specifically, the wh ij in ( <ref type="formula" target="#formula_10">10</ref>) is the actual working hours of the ith employee for t j . But the pwh ij in ( <ref type="formula" target="#formula_13">12</ref>) is only the originally planned working hours of the ith employee for t j . Because the multiskill scheduling model has various restrictions and reduces the flexibility of human resource allocation, to relax such restrictions and enable task preemption we no longer fix the working hours of the ith employee for t j during the processing course of t j as pwh ij . Instead, the actual working hours wh t ij during the time t 2 ½start j ; finish j should be adjusted according to the urgency of tasks and the amount of available resources. To adjust the planned working hours pwh ij to the actual working hours wh t ij , we propose the EBS in this paper.</p><p>The EBS is characterized by making new assignments at events. We regard the time t as an event if t satisfies any one of the following three conditions: 1) t ¼ 1 is the beginning of the project, 2) any employee joins or leaves the project at t, or 3) any task just finished in the previous time period and the corresponding resources become released and available at t. The EBS adjusts a plan in the form of ( <ref type="formula" target="#formula_13">12</ref>) into an actual timetable by two rules. First, if there is resource conflict between two tasks, the task that appears earlier in the task list has a higher priority to use the resource. That is, assuming that the ith employee is originally planned to simultaneously dedicate pwh ij and pwh ik of his working hours to t j and t k , respectively, if pwh ij þ pwh ik &gt; maxh i , the employee will first dedicate his working hours to the task with a higher priority. Second, new workload assignments are only made when events occur. If no employees join or leave the project or no human resource is released by the tasks just finished, the workload assignments remain the same as the previous time period.</p><p>The pseudocode of the EBS is given in Fig. <ref type="figure" target="#fig_2">2</ref>. At the beginning, the start time of the project and the time when employees join or leave the project are set as events. Then the scheduler assigns workloads in chronological order with the growing of time t. If t is an event, the scheduler reassigns the actual workloads according to the priority of a task defined by the task list and the originally planned workloads given in ( <ref type="formula" target="#formula_13">12</ref>) (lines 6-16). Otherwise, if t is not an event, the workloads at t remain the same as those at t À 1 (line 19). After allocating the actual workloads at t, the achievement A t j of t j at t is calculated by ( <ref type="formula" target="#formula_1">2</ref>)-(4) (line 21). If there is any task finished at t, the time t þ 1 is set as an event because the resources assigned to these tasks can all be released at t þ 1. These steps run repeatedly until all tasks of the project have been finished.</p><p>In Fig. <ref type="figure" target="#fig_2">2</ref>, there are local refinement steps in lines 17 and 24. The local refinement steps are designed to further improve performance of the plan. It is based on two ideas.</p><p>First, in practice, regular employees are usually expected to work more for the project so that the costs for hiring extra employees can be saved. Therefore, the refinement step in line 17 is to let regular employees dedicate their normal working hours to the project. More specifically, for all regular employees i, if the assignment in lines 7-16 satisfies hours t i ¼ P n j¼1 wh t ij &gt; 0, hours t i &lt; maxh i , and hours t i &lt; nh, it means that the ith employee is planned to work for the project at time t but not all of his normal working hours are dedicated. In this case, according to the order defined by the task list, we find the first task t j from the task list that satisfies wh t ij &gt; 0 and update wh t ij to</p><formula xml:id="formula_14">wh t ij ¼ wh t ij þ ðmaxh i À hours t i Þ; if maxh i &lt; nh; wh t ij þ ðnh À hours t i Þ; if maxh i ! nh: &amp;<label>ð13Þ</label></formula><p>In this way, the ith employee can dedicate all of his normal working hours nh to the project. Second, if a task t j is finished at time t, it is possible that there are redundant assignments at t. In other words, if some workloads are released, task t j may still be finished at t. To reduce cost, it is necessary to reduce such redundant assignments in line 24 in Fig. <ref type="figure" target="#fig_2">2</ref>. Redundant assignments are released as follows.</p><p>Step a: Arrange the employees that work for t j at time t (i.e., wh t ij &gt; 0) in ascending order of their proficiency scores prof ij in task t j . Proficiency scores are defined in <ref type="bibr" target="#b1">(2)</ref>.</p><p>Step b: Select the first employee from the order given in step a and denote the employee as u.</p><p>Step c: Repeatedly set wh t uj ¼ wh t uj À nh Á unitpercent% and test whether t j can be complete at time t under this assignment until wh t uj ¼ 0 or t j cannot be complete. Here, although the working hours of employees can be continuous variables, setting the working hours to a very precise value like 159.5 hours/month is meaningless. Therefore, we only test the situation when a certain percentage unitpercent of the normal working hours are reduced. According to the discussion of workload discretization in <ref type="bibr" target="#b5">[6]</ref>, we set unitpercent ¼ 25 in this paper.</p><p>Step d: If wh t uj ¼ 0, set the next employee in the order given in step a as the employee u and go to step c. If t j cannot be complete at time t, reset wh t uj ¼ wh t uj þ nh Á unitpercent% to make sure that t j can be finished, and the refinement procedure is ended.</p><p>Compared with the RCPSP and the employee allocation models, as the proposed representation scheme combines the task list and the employee allocation matrix it is able to deal with both the issues of task scheduling and employee allocation. In addition, with the EBS, the problems of task preemption and resource conflict can be addressed. Compared with the time-line-based model <ref type="bibr" target="#b5">[6]</ref> that uses a 3D matrix with size m Â n Â end, the proposed scheme only uses a task list of length n and a matrix of size m Â n for representation. In other words, the proposed scheme reduces the representation size from Oðm Á n Á endÞ to Oðm Á nÞ, and thus reduces the size of search space. As new assignments are only made at events, the project can be executed in a more stable way.</p><p>More fundamentally, an essential difference between the proposed scheme and the existing methods is the granularity of planning. The RCPSP and the employee allocation models make plans with the granularity to task. Thus, they can only make plans with each task having a fixed workload assignment and cannot deal with task preemption. On the other hand, the time-line-based model makes plans with the granularity to each time period. Though the model is flexible, the plan is too fine-grained and thus the problems of a large search space and desultory workload assignments are incurred. In contrast, the proposed scheme makes plans with the granularity to event. In this way, the scheme has sufficient information for modeling task preemption and reduces the search space as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">ANT COLONY OPTIMIZATION APPROACH</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Overview of the ACO Algorithm</head><p>To solve the software project planning problem, this paper proposes an ACO approach. The underlying idea of ACO is to simulate the foraging behavior of ants. When ants search for food, they usually deposit a special chemical on the path they travel through. This kind of chemical, which is called pheromone, serves as a medium for ants to communicate with each other. By sensing the concentration of pheromone, other ants can follow the path to find the food. Inspired by this swarm intelligence phenomenon, ACO was developed by Dorigo et al. <ref type="bibr" target="#b32">[33]</ref>, <ref type="bibr" target="#b33">[34]</ref> and has been successfully applied to various optimization problems. An ACO algorithm works by dispatching a group of artificial ants to build solutions to the problem iteratively. In general, an ACO algorithm can be viewed as the interplay and the repeated execution of the following three main procedures <ref type="bibr" target="#b38">[39]</ref>:</p><p>1. Solution construction-During each iteration of the algorithm, a group of ants set out to build solutions to the problem. Each ant builds a solution in a constructive manner by selecting components step by step to form a complete solution. The selections are made according to pheromone and heuristic information. In ACO, pheromone is a record of the past search experience of ants for guiding the following ants to make decisions. The components belonging to the best solutions found by the previous ants usually accumulate more pheromone, attracting more ants to select in future iterations. Heuristic is some problem-dependent information that helps ants to have higher probabilities to select promising components in the solution construction procedure. 2. Pheromone management-Along with the solution construction procedure, pheromone values are updated according to the performance of the solutions built by ants. Ants tend to deposit more pheromone to the components of better-performed solutions. 3. Daemon actions-Daemon actions mean the centralized operations that cannot be done by single ants.</p><p>In the design of ACO algorithms, daemon actions are optional, but many existing ACO variants use different kinds of daemon actions to improve performance <ref type="bibr" target="#b38">[39]</ref>. One commonly seen daemon action is the local search procedure. By now, various ACO variants have been developed <ref type="bibr" target="#b38">[39]</ref>. Two of the best performing ACO variants include ant colony system (ACS) <ref type="bibr" target="#b33">[34]</ref> and max-min ant system (MMAS) <ref type="bibr" target="#b43">[44]</ref>. In this paper, we follow the ACS variant to develop the ACO approach to the considered software project planning problem. The main characteristics of the ACS are in two aspects. First, in the solution construction procedure, the ACS applies a pseudorandom proportional selection rule which aggressively biases selecting the components with the maximum pheromone and heuristic values. In this way, the ACS strongly exploits the past search experience of ants and has a fast convergence speed. Second, in the pheromone management procedure, ACS has two pheromone updating rules, namely, the global updating and the local updating. The global updating rule makes the components corresponding to the best-so-far solution become more attractive. The local updating rule reduces the pheromone on the components just selected by ants to increase the search diversity of the algorithm.</p><p>With the above procedures and using the ACS variant, the overall flowchart of the proposed ACO approach is shown in Fig. <ref type="figure" target="#fig_3">3</ref>. At the beginning, parameters of the algorithm are initialized. In each iteration, ants set out to build plans for the problem. Since a plan for the considered problem includes the task list and the planned employee allocation matrix, the solution construction procedure in the proposed algorithm has two steps: 1) construction of the task list and 2) construction of the employee allocation matrix. Pheromone values are updated by the global and the local updating rules. Finally, a local mutation procedure is designed as the local search to further improve the performance of the algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Solution Construction</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">Construction of Task List</head><p>A task list is an order of tasks ðt p1 ; t p2 ; . . . ; t pn Þ that satisfies the precedence constraints defined by the TPG. Here we first define the pheromone and the heuristic for task list construction. Then the procedure for an ant to build a task list will be described in detail.</p><p>Pheromone. To build a task list, an ant has to determine an order of the tasks. In existing studies of ACO for scheduling problems like shop scheduling problems and the RCPSP, there are mainly two types of pheromone models for finding an order of tasks. The first type is the absolute position model that defines the pheromone of putting a task t j to the kth position of the task list as t ðj; kÞ <ref type="bibr" target="#b44">[45]</ref>. Since the absolute position model can only indicate the desirability of putting a task to a certain position, it is found that the model can lead to highly suboptimal solutions <ref type="bibr" target="#b38">[39]</ref>. To improve this model, Merkle et al. <ref type="bibr" target="#b34">[35]</ref> developed a summation rule. The summation rule uses the sum of the pheromone values of putting a task t j to the positions 1 to k instead of simply using t ðj; kÞ in the selection. In this way, the deficiency of the absolute position model is overcome and the resulting approach is effective. The second type of pheromone models is the relative position model that defines the pheromone on the link between two tasks and uses the pheromone to indicate the desirability of putting one task directly after the other one <ref type="bibr" target="#b36">[37]</ref>, <ref type="bibr" target="#b45">[46]</ref>. The disadvantage of this model is that the relative positions of two tasks may become meaningless when the two tasks are reconcilable with respect to resource (machine) consumption. To improve this model, Blum and Sampels <ref type="bibr" target="#b46">[47]</ref>, Blum <ref type="bibr" target="#b47">[48]</ref> developed a relation-learning model that only defines pheromone on the links between two related tasks in the same group or processed by the same machine for shop scheduling problems. In this way, the relation-learning model overcomes the deficiency of the conventional relative position model and achieves promising performance.</p><p>For the considered software project planning problem, since one task can be assigned to several employees, one employee can undertake several tasks simultaneously, and skill proficiency is considered, it is more difficult to define related tasks for the relation-learning model. Therefore, we adopt the absolute position model with the summation rule in the proposed approach. In other words, the pheromone t ðj; kÞ in the proposed approach means the desirability of putting the task t j to the kth position. The summation rule will be presented in detail in the construction procedure of the task list.</p><p>Heuristic. The minimum slack (MINSLK) heuristic <ref type="bibr" target="#b39">[40]</ref>, <ref type="bibr" target="#b48">[49]</ref> is adopted for task list construction. A task with a relatively smaller MINSLK implies that this task is more urgent. The MINSLK for a task t j , which is denoted as MINSLK j , can be estimated as follows:</p><p>Step a: Estimate the shortest possible makespan of each task.</p><p>To estimate the shortest possible makespan of t j , we select maxhead j most proficient employees of t j and assume these maxhead j employees dedicate all of their working hours to t j . Here maxhead j is the maximum headcount for t j and the proficiency of employees for t j can be evaluated by <ref type="bibr" target="#b1">(2)</ref>. With this assumption, the shortest possible makespan of t j can be estimated using ( <ref type="formula" target="#formula_2">3</ref>) and ( <ref type="formula" target="#formula_3">4</ref>).</p><p>Step b: Based on the shortest possible makespan of each task, the earliest start time and the latest start time of each task can be evaluated, and the MINSLK is calculated by the difference between the latest start time and the earliest start time of the task <ref type="bibr" target="#b48">[49]</ref>. Then the heuristic for task t j (denoted as t ðjÞ) is given by</p><formula xml:id="formula_15">t ðjÞ ¼ 1=MINSLK j :<label>ð14Þ</label></formula><p>Construction procedure. To build a feasible task list, each ant maintains an eligibleSet of the tasks that satisfy the precedence constraint. The construction includes the following steps:</p><p>Step a: Put the tasks that can be implemented at the beginning of the project (i.e., the tasks that do not have any precedence tasks) into the eligibleSet.</p><p>Step b: For k ¼ 1 to n, process the following substeps b-1 and b-2, repeatedly:</p><p>Step b-1: Select a task from eligibleSet and put the task to the kth position of the task list. In the selection rule, at first a random number q uniformly distributed in ½0; 1 is generated and is compared with a parameter q t . If q &lt; q t , then the task t j from the eligibleSet with the largest value of P k l¼1 t ðj; lÞ Á t ðjÞ is chosen to put to the kth position. Otherwise, the task is selected using the roulette wheel selection scheme. The probability Prðj; kÞ of selecting the task t j to the kth position in the roulette wheel selection scheme is given by </p><formula xml:id="formula_16">8 &lt; :<label>ð15Þ</label></formula><p>This selection rule is designed based on the pseudorandom proportional rule in the ACS <ref type="bibr" target="#b33">[34]</ref> and the summation rule <ref type="bibr" target="#b34">[35]</ref>. The characteristic of the pseudorandom proportional rule is that ants have a probability q t of selecting the task with the maximum pheromone and heuristic values directly so that the algorithm can strongly exploit the past search experience of ants. The characteristic of the summation rule is to use the sum of the pheromone values of putting t j to positions 1 to k instead of simply using the pheromone value t ðj; kÞ in the rule. In this way, the deficiency of the absolute position pheromone model can be overcome.</p><p>Step b-2: Update the eligibleSet by removing the selected task from eligibleSet and adding new feasible tasks that satisfy the precedence constraint into eligibleSet.</p><p>After Steps b-1 and b-2 repeat n times, a feasible task list is built. An example of how an ant builds a task list (based on the TPG given in Fig. <ref type="figure" target="#fig_0">1</ref>) is illustrated in Fig. <ref type="figure" target="#fig_4">4</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">Construction of Employee Allocation Matrix</head><p>The employee allocation matrix in <ref type="bibr" target="#b11">(12)</ref> specifies the originally planned working hours of employees to tasks. In general, for the working hours of the ith employee for the task t j , the domain of pwh ij is ½0; maxh i . However, as setting the workload assignment to a very accurate value is not meaningful in practice, according to Chang et al. <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b14">[15]</ref> it is possible to discretize the search domain of pwh ij . Here we use nh Á unitpercent% as the unit of working hours for discretization. If unitpercent ¼ 25, the search domain of pwh ij becomes f0; 25% nh; 50% nh; . . . ; maxh i g. (Note that if maxh i &gt; nh, the percentage can be larger than 100 percent.) With the maximum headcount constraint, at most maxhead j employees can be selected to devote their working hours to t j . The working hours of other unselected employees is set to 0.</p><p>Pheromone. Here two kinds of pheromone are adopted for employee allocation matrix construction. The pheromone of choosing the ith employee to work for the task t j is denoted as e1 ði; jÞ. The pheromone of assigning k (k ¼ 25% nh; 50% nh; . . . ; maxh i ) of the ith employee's working hours to t j is denoted as e2 ði; j; kÞ.</p><p>Heuristic. The heuristic of choosing the ith employee to work for the task t j is denoted as e ði; jÞ. We define e ði; jÞ as</p><formula xml:id="formula_17">e ði; jÞ ¼ prof ij =hs i :<label>ð16Þ</label></formula><p>The meaning of this heuristic definition is the rate between the proficiency prof ij of the ith employee for the task t j and the hour salary of the employee. An employee with a lower salary and a higher proficiency score for t j is more probable to be chosen to work for t j . Construction procedure. The construction of the employee allocation matrix is based on the following steps:</p><p>Step a: Set all values in the employee allocation matrix to 0.</p><p>Step b: For each task t j ðj ¼ 1; 2; . . . ; nÞ, assign the workloads for t j by the following substeps:</p><p>Step b-1: Evaluate the value of e1 ði; jÞ Á e ði; jÞ for all employees, where is a parameter.</p><p>Step b-2: Select an employee u from the set of employees which have not yet been chosen for t j using the pseudorandom proportional rule in the ACS <ref type="bibr" target="#b33">[34]</ref>. A random number q uniformly distributed in ½0; 1 is first generated and is compared with a parameter q e1 . If q &lt; q e1 , then the employee u from the eligible set Eligible of employees with the largest value of e1 ðu; jÞ Á e ðu; jÞ is selected for t j . Otherwise, the employee is selected using the roulette wheel selection scheme. The probability Prðu; jÞ of selecting the employee u for t j is given by Prðu; jÞ ¼ e1 ðu;jÞÁ e ðu;jÞ P i2Eligible e1ði;jÞÁeði;jÞ ; if u 2 Eligible; 0; otherwise:</p><p>(</p><p>If employee u is selected, then this employee will be removed from the Eligible set.</p><p>Step b-3: Assign the working hours for the employee selected to work for t j using the pseudorandom proportional rule. The selection is only based on the pheromone values e2 . A random number q uniformly distributed in ½0; 1 is first generated and is compared with a parameter q e2 . If q &lt; q e2 , then we set pwh ij ¼ k, where k 2 f25%nh; 50%nh; . . . ; maxh i g and k has the highest pheromone value e2 ði; j; kÞ. Otherwise, the selection is made using the roulette wheel selection scheme. The probability Prði; j; kÞ of setting pwh ij ¼ k is given by Prði; j; kÞ ¼ e2 ði; j; kÞ P v2f25%nh;50%nh;...;maxh i g e2 ði; j; vÞ ; k 2 f25%nh; 50%nh; . . . ; maxh i g:</p><p>Step b-4: If the number of the employees selected to work for t j reaches maxhead j , the workload assignment process for t j is finished. Otherwise, go to Step b-2 to select other employees to work for t j .</p><p>After the workloads for all tasks have been assigned, the procedure for building the employee allocation matrix is complete.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Pheromone Management</head><p>At the beginning, all pheromone values are set to an initial value initial , where</p><formula xml:id="formula_20">initial ¼ 1:0 P m i¼1 ½bs i þ maxsalary i Á ðdeadline þ nÞ :<label>ð19Þ</label></formula><p>Here maxsalary i is the maximum possible salary of the ith employee per time period,which can be calculated by</p><formula xml:id="formula_21">maxsalary i ¼ bs i þ maxh i Á hs i ; 0 maxh i nh; bs i þ nh Á hs i þ ðmaxh i À nhÞ Á ohs i ; maxh i &gt; nh: &amp;<label>ð20Þ</label></formula><p>The denominator in <ref type="bibr" target="#b18">(19)</ref> is actually an upper bound estimation of the objective function value. The upper bound is estimated by assuming all employees contribute all of their working hours to the project during every time period and the project is delayed by n time periods (months) with respect to a predefined deadline. Here, n is a rough worstcase estimation that assumes each task leads to a one-month delay for the project. During the construction of the task list and employee allocation matrix, immediately after a selection is made the local pheromone updating rule is applied to reduce the corresponding pheromone values so that the following ants can have better chances of selecting other possible choices. In this way, the algorithm manages to maintain diversity. Suppose the task t j is selected to the kth position of the task list; the corresponding pheromone is updated by</p><formula xml:id="formula_22">t ðj; kÞ ¼ ð1 À Þ Á t ðj; kÞ þ Á initial ;<label>ð21Þ</label></formula><p>where is a parameter. Similarly, if the ith employee is assigned to the jth task with k working hours, the corresponding pheromone is updated by</p><formula xml:id="formula_23">e1 ði; jÞ ¼ ð1 À Þ Á e1 ði; jÞ þ Á initial ;<label>ð22Þ</label></formula><formula xml:id="formula_24">e2 ði; j; kÞ ¼ ð1 À Þ Á e2 ði; j; kÞ þ Á initial :<label>ð23Þ</label></formula><p>At the end of each iteration, additional pheromone is deposited to the components associated with the best-so-far plans found by the algorithm. All the pheromone values associated with the best-so-far plan are updated by</p><formula xml:id="formula_25">t ðj; kÞ ¼ ð1 À Þ Á t ðj; kÞ þ Á Á;<label>ð24Þ</label></formula><formula xml:id="formula_26">e1 ði; jÞ ¼ ð1 À Þ Á e1 ði; jÞ þ Á Á;<label>ð25Þ</label></formula><formula xml:id="formula_27">e2 ði; j; kÞ ¼ ð1 À Þ Á e2 ði; j; kÞ þ Á Á;<label>ð26Þ</label></formula><p>where Á ¼ 1=f is the reciprocal of the objective function value of the plan. Based on these definitions, as the denominator in ( <ref type="formula" target="#formula_20">19</ref>) is an upper-bound estimation, initial is the lower-bound of all pheromone values. With the evolution of the algorithm, the cost of the best-so-far plan found by the algorithm becomes lower and lower. Thus, the value of Á becomes larger. In other words, more pheromone will be added to the components of the bestso-far plan to make them more attractive for the ants in the following iterations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Local Mutation Procedure</head><p>The considered problem is intractable as both the task list and the employee allocation matrix have to be optimally decided. In particular, although there are effective heuristics for guiding the construction of task list and the selection of employees, it is difficult to find an effective heuristic that can tell us how many working hours an employee works for a specific task is the most suitable. Therefore, to further improve the performance of the ACO approach, it is helpful to couple it with a local search procedure.</p><p>Inspired by the mutation operator used by the GA for the multiskill problem <ref type="bibr" target="#b17">[18]</ref>, a simple local mutation procedure is designed. The procedure is performed by mutating the best-so-far solution found by ACO using either of the following mutation operators.</p><p>Operator 1-Task list mutation: First, a task t j is randomly selected from the task list. Then a destination position is randomly generated. The mutation is performed by moving the selected task t j toward the destination position in the task list as close as possible without violating the precedence constraints.</p><p>Operator 2-Employee allocation matrix mutation: First a task t j is randomly selected. Then an employee i who has been assigned to work for this task is randomly selected and his working hours for this task are reset to pwh ij ¼ 0. Finally, a new employee u who has not been selected to work for the task is randomly selected and his working hours for the task pwh uj are randomly set to a value from f25%nh; 50%nh; . . . ; maxh u g.</p><p>During each iteration, mutatenum of mutated solutions are generated based on either of the above mutation operators. If any mutated solution is better than the current best-so-far solution, then the best-so-far solution will be replaced.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">EXPERIMENTAL STUDIES 6.1 Experimental Settings</head><p>In the experiments, we test the proposed method on three real instances and 80 randomly generated instances. The three real instances are derived from business software construction projects for a department store company. The TPG in Fig. <ref type="figure" target="#fig_0">1</ref> belongs to one of the real projects. In order to guarantee that the randomly generated instances correctly capture the characteristics of real-world projects, we generate the instances using the following strategies:</p><p>1. The project networks of the instances are derived from the PSPLIB <ref type="bibr" target="#b49">[50]</ref>. The benchmark instances in PSPLIB have been widely used in project management studies in various fields (including software project management) <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b50">[51]</ref>. Thus, we consider these benchmark project networks to be useful for capturing the task precedence relations of software projects. 2. Based on our empirical observation, we consider four types of employees in a project team: regular elite staff, regular normal staff, temporary experts, and temporary normal staff. Elite staff are experts on one or more skills and their salaries are high. Normal staff are good at one or two skills and they are in the majority of the team. Temporary staff are hired temporarily for the project and we only need to pay for what they contribute to the project. Under this classification, in our random instance generator, the properties of an employee are generated randomly within a predefined domain according to his staff type. After the properties of all staff are generated, a feasibility check is run to ensure the skills required by the project have been covered by the employees. 3. The workload (in person months) of each task of the project is given randomly and the maximum headcount for the task is evaluated based on the COCOMO model <ref type="bibr" target="#b5">[6]</ref>. Based on these strategies, we generate 80 random instances by using 80 different project networks from the PSPLIB. The basic information of the project networks is given in Table <ref type="table" target="#tab_2">1</ref>. We name the instances after the sources of their project networks from the PSPLIB. In other words, the instance "c159_1" in our experiment means that the project network of this instance comes from the benchmark instance "c159_1" in the PSPLIB.  <ref type="figure">5</ref>. Analysis of the configurations for the parameters q t , q e1 and q e2 on the instance c159_1.</p><p>comprehensive, we also report the results of proposed ACO approach without using the local mutation procedure presented in Section 5.4. We denote the ACO approach without the local mutation procedure as "ACO" in the table, and the one with the local mutation procedure is denoted as "ACO-L."</p><p>According to the results, it can be seen that out of the 83 instances, the ACO-L with the local mutation procedure yields the best results and the best average results in all cases. In some instances, the ACO-L can reduce the costs by 10-20 percent compared with other approaches. Even without the local mutation procedure, the proposed ACO approach still has competitive performance. We implement t-tests to find out if there are significant differences between the results found by the ACO without the local mutation procedure and those found by other algorithms. The results of t-tests are also reported in Table <ref type="table" target="#tab_3">2</ref>. According to these results, the ACO without local still significantly outperforms the 3dGA on 82 instances, the KGA on all 83 instances, the TS on 77 instances, and the KGA-p on 56 instances. Overall, these results show that ACO is able to obtain project plans with lower costs in most instances.</p><p>We further analyze the convergence behavior of the algorithms based on their evolutionary curves. The evolutionary curves which give the best results found by the algorithms (averaged over 30 runs) as a function of the number of evaluations are illustrated in Fig. <ref type="figure" target="#fig_5">6</ref>. The plots show that ACO can usually find good solutions at the very beginning of the search process and maintain its advantage till the end of the search process. This is because the proposed ACO adopts some useful heuristic information to guide the construction process and uses the aggressive pseudorandom proportional selection rule of ACS <ref type="bibr" target="#b33">[34]</ref> in the solution construction procedure. With the help of the local mutation procedure, the ACO-L can further improve the performance of the ACO approach. Finally, it is noteworthy from Table <ref type="table" target="#tab_3">2</ref> and Fig. <ref type="figure" target="#fig_5">6</ref> that the KGA-p outperforms the KGA on most instances. These results demonstrate that the proposed EBS is effective. By coupling with the EBS, the KGA-p is capable of dealing with task preemption. Thus, it provides a more flexible and efficient way for human resource allocation and its performance is improved. On the other hand, while both the proposed ACO and the KGA-p are coupled with the EBS, ACO can still achieve better results than the KGA-p in most cases. These results also demonstrate that the proposed ACO algorithm is effective.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Comparison of the Plan Structures</head><p>To further analyze why the proposed approach can yield good results, we further go deep into the structures of the solutions found by different algorithms. We plot a section of the Gantt charts of the plans found by the ACO, 3dGA, and TS in Fig. <ref type="figure" target="#fig_7">7</ref>.</p><p>The 3dGA proposed in <ref type="bibr" target="#b5">[6]</ref> allows task preemption and schedules the workloads period by period based on the 3D employee allocation matrix. Because the workloads are assigned month by month separately, it is possible that a group of employees is assigned to a task in a month and another different group of employees is assigned to the task in the next month. For example in Fig. <ref type="figure" target="#fig_7">7b</ref>, the task 6 is executed by employees #2 and #6 on May and by employees #1 and #5 on June. Such a plan is actually unstable and impractical for real-world software projects.</p><p>On the other hand, the TS <ref type="bibr" target="#b18">[19]</ref> (and also the KGA <ref type="bibr" target="#b17">[18]</ref>) is designed for the multiskill scheduling problem. The models of these studies do not allow task preemption and usually assume that an employee can only be assigned to a task at one time. This assumption reduces the flexibility of human resource allocation and may sometimes lead to inefficient plans. For example, in the part of a plan built by the TS given in Fig. <ref type="figure" target="#fig_7">7c</ref>, as employee #1 is assigned to work for task 3 from March to May, the execution of task 2 has to be delayed until employee #1 is finally released from task 3 in June.</p><p>Compared with the above approaches, with the EBS, the plans generated by the proposed approach seem to be more flexible and practical. For example, in Fig. <ref type="figure" target="#fig_7">7a</ref> the workload assignments of employees are generally stable because the assigned working hours of employees are all adjusted based on the same planned employee allocation matrix. Moreover, when a task is finished and its related recourses are released, these resources can be assign to other tasks immediately (e.g., employee #1 joins tasks 3 and 6 in May after he finished his work on task 4 in March and April). In this way, the human resources can be utilized in a more efficient manner. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Analysis of the Local Refinement Steps</head><p>Finally, we analyze the functions of the two local refinement steps in the proposed EBS. The first local refinement step in the line 17 of Fig. <ref type="figure" target="#fig_2">2</ref> is to let regular employees dedicate all of their normal working hours to the project, and the second local refinement step in the line 24 is to release redundant assignments when a task is complete. Fig. <ref type="figure" target="#fig_6">8</ref> illustrates the performance of these local refinement steps on the instance j301_1.</p><p>According to the figure, both the schemes of only using local refinement step 1 (scheme "local 1") and only using local refinement step 2 (scheme "local 2") yield better results than the scheme without any local refinement step (scheme "without local"). These results prove that both refinement steps are helpful. Therein, local refinement step 2 is more significant to the performance of the algorithm as the scheme "local 2" yields better results than the scheme "local 1." Nevertheless, by using both the local refinement steps, the proposed method manages to obtain the best results among the four schemes shown in Fig. <ref type="figure" target="#fig_7">7</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSION</head><p>A new method for solving the software project planning problem has been developed. The main characteristics of the proposed method are in two aspects. First, the method introduces an event-based scheduler. Second, the method takes advantage of ACO to solve the complicated planning problem. Experimental results show that the representation scheme with the EBS is effective, and the proposed algorithm manages to yield better plans with lower costs and more stable workload assignments compared with other existing approaches.</p><p>In future research, it will be interesting to consider employee experience and the training model <ref type="bibr" target="#b5">[6]</ref> to make the considered problem more comprehensive. Including uncertainty treatment in the software project planning model is also a promising research topic. In addition, since the model proposed in this paper provides a flexible and effective way for managing human resources, it is promising to apply the proposed approach to other complex human-centric projects like consulting projects.  </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. An example of the TPG.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Pseudocode of the EBS.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Flowchart of the ACO algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. An example of task list construction based on the TPG given in Fig. 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Comparison of the evolutionary curves of different algorithms.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Analysis of the local refinement steps on the instance j301_1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Comparison between the structures of the solutions built by different algorithms.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE 1</head><label>1</label><figDesc>Information of the Test InstancesFig.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>TABLE 2</head><label>2</label><figDesc>Comparison of the Results on the 83 Instances</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>TABLE 2 (</head><label>2</label><figDesc>Cont.)    </figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>This work was supported in part by the National Science Fund for Distinguished Young Scholars under Grant 61125205, in part by the National natural Science Foundation of China under Grant 61070004, and in part by the NSFC Joint Fund with Guangdong under Key Project U0835002.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The parameters of the proposed ACO are set as follows:</p><p>The number of ants is P OP SIZE ¼ 10, the pheromone updating rate in (21)-( <ref type="formula">26</ref>) is set to 0.1, and the parameter in the employee allocation matrix generation procedure is set to 2. These parameters can significantly influence the performance of ACO. We have tested different configurations for these parameters and found that the original configurations suggested by Dorigo and Gambardella <ref type="bibr" target="#b33">[34]</ref>, Dorigo and Stu ¨tzle <ref type="bibr" target="#b38">[39]</ref> still contribute to good performance for the proposed ACO approach. There is also a local mutation procedure in the proposed ACO algorithm and the number of mutated solutions generated in each iteration mutatenum is a parameter. In the experiment, we find that if mutatenum &lt; 5, the local mutation procedure can hardly cause effects. On the other hand, if mutatenum &gt; 30, the local mutation procedure consumes too much computational effort so that the convergence speed of the algorithm is influenced. Overall, we find that mutatenum 2 ½5; 30 is suitable for the problem and we empirically set mutatenum ¼ 10 in the experiment. In addition, there are also three parameters, q t , q e1 , and q e2 , in the pseudorandom proportional rule developed in the ACS <ref type="bibr" target="#b33">[34]</ref> in the solution construction procedure. These parameters are used to control the degree of aggressiveness in the selection rules of the algorithm. If we set q t , q e1 , and q e2 ¼ 0, the selection rules become the conventional roulette wheel selection scheme. If we set q t , q e1 , and q e2 to larger values, the algorithm strongly exploits the past search experience and exhibits a fast-converging manner. But the search diversity of the algorithm is decreased. To find a good tradeoff between convergence and diversity, we study the configurations for q t , q e1 , and q e2 empirically and the results are shown in Fig. <ref type="figure">5</ref>. For the parameter q t used in the construction of task list and the parameter q e2 used in the assignment of working hours, we find that setting q t , q e2 ¼ 0:5 can generally yield the best performance. For the parameter q e1 used in the selection of employees, we find that the aggressive choice q e1 ¼ 0:9 is helpful for the algorithm to assign each activity to a suitable group of employees quickly, and thus results in good performance. Thereby, we use the configuration q t , q e2 ¼ 0:5 and q e1 ¼ 0:9 in the proposed ACO approach.</p><p>This paper compares the proposed ACO algorithm with the tabu search (TS) algorithm for the multiskill scheduling problem <ref type="bibr" target="#b18">[19]</ref>, the knowledge-based genetic algorithm (KGA) proposed recently for multiskill scheduling <ref type="bibr" target="#b17">[18]</ref>, and the time-line-based GA that uses a 3D representation (we denoted as 3dGA in the following text) <ref type="bibr" target="#b5">[6]</ref>. The reason for selecting these algorithms for comparison is that all these algorithms can deal with both the problems of task scheduling and human resource allocation in software project planning. In these three algorithms, the TS and the KGA do not allow task preemption, and only the 3dGA allows it. But as the KGA uses a similar representation scheme to the proposed ACO algorithm that combines a task list and an employee allocation matrix, we further develop a KGA-p algorithm by coupling the KGA with the event-based scheduler proposed in this paper. With the EBS, KGA-p can also deal with task preemption. We also compared the KGA-p algorithm with the proposed ACO, and the comparison results can tell whether the EBS is effective and whether the ACO performs well.</p><p>The parameters of the algorithms in the comparison are set according to the corresponding references. The TS uses a greedy algorithm to generate a promising initial solution for the search. The parameters of the KGA and KGA-p are set as follows: Population size is 50, mutation probability is 0.05, and crossover probability is 0.8. The parameters of 3dGA are set as follows: Population size is 200, crossover probability is 0.7, and mutation probability is 0.001.</p><p>In the experiment, all algorithms are run 30 independent times for each instance. During each run, the algorithm stops when the number of plans built by the algorithm reaches the predefined maximum number of solutions given in Table <ref type="table">1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Comparison of the Costs</head><p>The objective function considered in this paper is to minimize the cost of the software project. Therefore, we first compare the performance of the proposed method with other approaches in terms of cost. For all test instances, the best and mean results (averaged over 30 runs) found by the algorithms are tabulated in Table <ref type="table">2</ref>. To make the comparison . For more information on this or any other computing topic, please visit our Digital Library at www.computer.org/publications/dlib.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Impact of Budget and Schedule Pressure on Software Development Cycle Time and Effort</title>
		<author>
			<persName><forename type="first">N</forename><surname>Nan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Harter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="624" to="637" />
			<date type="published" when="2009-10">Sept./Oct. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A Task Allocation Optimizer for Software Construction</title>
		<author>
			<persName><forename type="first">J</forename><surname>Duggan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Byrne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Lyons</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Software</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="76" to="82" />
			<date type="published" when="2004-06">May/June 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Five Principles of Project Management in Software Companies</title>
		<author>
			<persName><forename type="first">R.-G</forename><surname>Ding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X.-H</forename><surname>Jing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Project Management Technology (in Chinese)</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Staffing a Software Project: A Constraint Satisfaction and Optimization-Based approach</title>
		<author>
			<persName><forename type="first">A</forename><surname>Barreto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>De O. Barros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M L</forename><surname>Werner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers &amp; Operations Research</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="3073" to="3089" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Software Project Management with GAs</title>
		<author>
			<persName><forename type="first">E</forename><surname>Alba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Chicano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Sciences</title>
		<imprint>
			<biblScope unit="volume">177</biblScope>
			<biblScope unit="page" from="2380" to="2401" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Time-Line Based Model for Software Project Scheduling with Genetic Algorithms</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">K</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Di</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Software Technology</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="page" from="1142" to="1154" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><forename type="first">B</forename><surname>Boehm</surname></persName>
		</author>
		<title level="m">Software Engineering Economics</title>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Software Cost Estimation with COCOMO II</title>
		<author>
			<persName><forename type="first">B</forename><surname>Boehm</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Prentice-Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Shtub</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Bard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Globerson</surname></persName>
		</author>
		<title level="m">Project Management: Processes, Methodologies, and Economics</title>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note>second ed</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Resource-Constrained Project Scheduling: Notation, Classification, Models and Methods</title>
		<author>
			<persName><forename type="first">P</forename><surname>Brucker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Drexl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mohring</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Neumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Pesch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">European J. Operational Research</title>
		<imprint>
			<biblScope unit="volume">112</biblScope>
			<biblScope unit="page" from="3" to="41" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A Net Practice for Software Project Management</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">K</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Christensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Software</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="80" to="88" />
			<date type="published" when="1999-12">Nov./Dec. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">K</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Christensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Chao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">T</forename><surname>Nguyen</surname></persName>
		</author>
		<title level="m">Software Project Management Net: A New Methodology on Software Management,&quot; Proc. 22nd Ann. Int&apos;l Computer Software and Applications Conf</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Use of Petri Nets for Resource Allocation in Projects</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">K</forename></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">S</forename><surname>Ganesh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Eng. Management</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="49" to="56" />
			<date type="published" when="1998-02">Feb. 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A Formal Model for Software Project Management</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Horowitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1280" to="1293" />
			<date type="published" when="1989-10">Oct. 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Genetic Algorithms for Project Management</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">K</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Christensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Software Eng</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="107" to="139" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Robust Preemptive Resource Assignment for Multiple Software Projects Using Parameter Design</title>
		<author>
			<persName><forename type="first">L.-H</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int&apos;l J. Applied Science and Eng</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="159" to="171" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Project Scheduling with Finite or Infinite Number of Activity Processing Modes-A Survey</title>
		<author>
			<persName><forename type="first">J</forename><surname>Wglarz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jo ´zefowska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mika</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Waligo ´ra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">European J. Operational Research</title>
		<imprint>
			<biblScope unit="volume">208</biblScope>
			<biblScope unit="page" from="177" to="205" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A Knowledge-Based Evolutionary Assistant to Software Development Project Scheduling</title>
		<author>
			<persName><forename type="first">V</forename><surname>Yannibelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Amandi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Expert Systems with Applications</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="8403" to="8413" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Methods for the Multi-Skill Project Scheduling Problem</title>
		<author>
			<persName><forename type="first">O</forename><surname>Bellenguez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Ne ´ron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Ninth Int&apos;l Workshop Project Management and Scheduling</title>
		<meeting>Ninth Int&apos;l Workshop Project Management and Scheduling</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="66" to="69" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A Branch-and-Bound Method for Solving Multi-Skill Project Scheduling Problem</title>
		<author>
			<persName><forename type="first">O</forename><surname>Bellenguez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Ne ´ron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">RAIRO-Operations Research</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="155" to="170" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Reformulating Software Engineering as a Search Problem</title>
		<author>
			<persName><forename type="first">J</forename><surname>Clarke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEE Software</title>
		<meeting>IEE Software</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">150</biblScope>
			<biblScope unit="page" from="161" to="175" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Search Based Software Engineering: A Comprehensive Analysis and Review of Trends Techniques and Applications</title>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Mansouri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<idno>TR-09- 03</idno>
		<imprint>
			<date type="published" when="2009-04">Apr. 2009</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">An Evolutionary Approach to Estimating Software Development Projects</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Aguilar-Ruiz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Ramos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Riquelme</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Toro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Software Technology</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="875" to="882" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Software Module Clustering as a Multi-Objective Search Problem</title>
		<author>
			<persName><forename type="first">K</forename><surname>Praditwong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="264" to="282" />
			<date type="published" when="2011-04">Mar./Apr. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Interactive, Evolutionary Search in Upstream Object-Oriented Class Design</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Simons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">C</forename><surname>Parmee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gwynllyw</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="798" to="816" />
			<date type="published" when="2010-12">Nov./Dec. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A Theoretical and Empirical Study of Search-Based Testing: Local, Global, and Hybrid Search</title>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mcminn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="226" to="247" />
			<date type="published" when="2010-04">Mar./Apr. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A Genetic Algorithm-Based Stress Test Requirements Generator Tool and Its Empirical Evaluation</title>
		<author>
			<persName><forename type="first">V</forename><surname>Garousi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="778" to="797" />
			<date type="published" when="2010-12">Nov./Dec. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Optimized Resource Allocation for Software Release Planning</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ngo-The</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ruhe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="109" to="123" />
			<date type="published" when="2009-02">Jan./Feb. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Management of Software Projects with GAs</title>
		<author>
			<persName><forename type="first">E</forename><surname>Alba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Chicano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Sixth Mateheuristics Int&apos;l Conf</title>
		<imprint>
			<biblScope unit="page">1152</biblScope>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Search-Based Techniques Applied to Optimization of Project Planning for a Massive Maintenance Project</title>
		<author>
			<persName><forename type="first">G</forename><surname>Antoniol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Di Penta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 21st IEEE Int&apos;l Conf. Software Maintenance</title>
		<meeting>21st IEEE Int&apos;l Conf. Software Maintenance</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Search-Based Techniques for Optimizing Software Project Resource Allocation</title>
		<author>
			<persName><forename type="first">G</forename><surname>Antoniol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Di Penta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genetic and Evolutionary Computation</title>
		<imprint>
			<biblScope unit="volume">3103</biblScope>
			<biblScope unit="page" from="1425" to="1436" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Software Project Rescheduling with Genetic Algorithms</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Artificial Intelligence and Computational Intelligence</title>
		<meeting>Int&apos;l Conf. Artificial Intelligence and Computational Intelligence</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Ant System: Optimization by a Colony of Cooperating Agents</title>
		<author>
			<persName><forename type="first">M</forename><surname>Dorigo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Maniezzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Colorni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Systems Man, and Cybernetics-Part B: Cybernetics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="29" to="41" />
			<date type="published" when="1996-02">Feb. 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Ant Colony System: A Cooperative Learning Approach to TSP</title>
		<author>
			<persName><forename type="first">M</forename><surname>Dorigo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>Gambardella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Evolutionary Computation</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="53" to="66" />
			<date type="published" when="1997-04">Apr. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Ant Colony Optimization for Resource-Constrained Project Scheduling</title>
		<author>
			<persName><forename type="first">D</forename><surname>Merkle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Middendorf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Schmeck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Evolutionary Computation</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="333" to="346" />
			<date type="published" when="2002-08">Aug. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">An Ant Colony Optimization Approach to a Grid Workflow Scheduling Problem with Various QoS Requirements</title>
		<author>
			<persName><forename type="first">W.-N</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. System, Man, and Cybernetics-Part C</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="29" to="43" />
			<date type="published" when="2009-01">Jan. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Optimizing Discounted Cash Flows in Project Scheduling-An Ant Colony Optimization Approach</title>
		<author>
			<persName><forename type="first">W.-N</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">-H</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R.-Z</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Systems, Man, and Cybernetics-Part C</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="64" to="77" />
			<date type="published" when="2010-01">Jan. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">An Intelligent Testing System Embedded with an Ant Colony Optimization Based Test Composition Method</title>
		<author>
			<persName><forename type="first">X.-M</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">-H</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Xiao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Systems, Man and Cybernetics, Part C: Applications and Rev</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="659" to="669" />
			<date type="published" when="2009-11">Nov. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">M</forename><surname>Dorigo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Stu ¨tzle</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>Ant Colony Optimization. MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">A Genetic Algorithm Approach to a General Category Project Scheduling Problem</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">}</forename><surname>Ozdamar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Systems, Man, and Cybernetics-Part C: Applications and Rev</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="44" to="59" />
			<date type="published" when="1999-02">Feb. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">A Hybrid Evolutionary Approach to the Nurse Rostering Problem</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">K</forename><surname>Burke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kendall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mccollum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Evolutionary Computation</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="580" to="590" />
			<date type="published" when="2010-08">Aug. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Automatic Generation of Optimised Working Time Models in Personnel Planning</title>
		<author>
			<persName><forename type="first">V</forename><surname>Nissen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gu ¨nther</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Seventh Int&apos;l Conf. Swarm Intelligence</title>
		<imprint>
			<biblScope unit="page" from="384" to="391" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Particle Swarm Optimization and an Agent-Based Algorithm for a Problem of Staffing Scheduling</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Nissen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Conf. Applications of Evolutionary Computation</title>
		<meeting>Int&apos;l Conf. Applications of Evolutionary Computation</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="451" to="461" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Max-Min Ant System</title>
		<author>
			<persName><forename type="first">T</forename><surname>Stu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Hoos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Future Generation Computer Systems</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="889" to="914" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Minimizing Total Tardiness on a Single Machine Using Ant Colony Optimization</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Bullnheimer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">F</forename><surname>Hartl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Strauss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Central European J. Operations Research and Economics</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="125" to="141" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Multi-Agent Search for Open Shop Scheduling: Adapting the Ant-Q Formalism</title>
		<author>
			<persName><forename type="first">B</forename><surname>Pfahringer</surname></persName>
		</author>
		<idno>TR-96-09</idno>
	</analytic>
	<monogr>
		<title level="j">Austrian Research Inst. of Artificial Intelligence</title>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">An Ant Colony Optimization Algorithm for Shop Scheduling Problems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sampels</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Math. Modelling and Algorithms</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="285" to="308" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Beam-ACO-Hybridizing Ant Colony Optimization with Beam Search: An Application to Open Shop Scheduling</title>
		<author>
			<persName><forename type="first">C</forename><surname>Blum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers and Operations Research</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="1565" to="1591" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">Heuristic Algorithms for Solving the Resource-Constrained Project Scheduling Problem: Classification and Computational Analysis</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kolisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hartmann</surname></persName>
		</author>
		<editor>J. Weglarz</editor>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Kluwer</publisher>
			<biblScope unit="page" from="197" to="212" />
		</imprint>
	</monogr>
	<note>Handbook on Recent Advances in Project Scheduling</note>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">PSPLIB-A Project Scheduling Problem Library: OR Software-ORSEP Operations Research Software Exchange Program</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kolisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sprecher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">European J. Operational Research</title>
		<imprint>
			<biblScope unit="volume">96</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="205" to="216" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">A Survey on the Resource-Constrained Project Scheduling Problem</title>
		<author>
			<persName><forename type="first">L</forename><surname>Ozdamar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ususoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trans. IIE</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="574" to="586" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
