<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Reformulating software engineering as a search</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">J</forename><surname>Clarke</surname></persName>
						</author>
						<author>
							<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Dolado</surname></persName>
							<affiliation key="aff8">
								<orgName type="institution">Shepperd is with Boumemouth University</orgName>
								<address>
									<postCode>BH12 SBB</postCode>
									<settlement>Talbot Campus, Poole</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
							<affiliation key="aff8">
								<orgName type="institution">Shepperd is with Boumemouth University</orgName>
								<address>
									<postCode>BH12 SBB</postCode>
									<settlement>Talbot Campus, Poole</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">M</forename><surname>Harman</surname></persName>
						</author>
						<author>
							<persName><forename type="first">R</forename><surname>Hierons</surname></persName>
							<affiliation key="aff8">
								<orgName type="institution">Shepperd is with Boumemouth University</orgName>
								<address>
									<postCode>BH12 SBB</postCode>
									<settlement>Talbot Campus, Poole</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">B</forename><surname>J O N E S</surname></persName>
							<affiliation key="aff8">
								<orgName type="institution">Shepperd is with Boumemouth University</orgName>
								<address>
									<postCode>BH12 SBB</postCode>
									<settlement>Talbot Campus, Poole</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">M</forename><surname>Lumkin</surname></persName>
						</author>
						<author>
							<persName><forename type="first">B</forename><surname>Mitchell</surname></persName>
						</author>
						<author>
							<persName><forename type="first">S</forename><surname>Mancoridis</surname></persName>
						</author>
						<author>
							<persName><forename type="first">K</forename><surname>Rees</surname></persName>
							<affiliation key="aff8">
								<orgName type="institution">Shepperd is with Boumemouth University</orgName>
								<address>
									<postCode>BH12 SBB</postCode>
									<settlement>Talbot Campus, Poole</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">M</forename><surname>Roper</surname></persName>
							<affiliation key="aff8">
								<orgName type="institution">Shepperd is with Boumemouth University</orgName>
								<address>
									<postCode>BH12 SBB</postCode>
									<settlement>Talbot Campus, Poole</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">M</forename><surname>Shepperd</surname></persName>
						</author>
						<author>
							<persName><forename type="first">M</forename><surname>Haman</surname></persName>
						</author>
						<author>
							<persName><forename type="first">K</forename><surname>Rces</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">The University of York</orgName>
								<address>
									<postCode>YO10 5DD</postCode>
									<settlement>Heslington</settlement>
									<region>York</region>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Facultad de Infomitica</orgName>
								<orgName type="institution">University of the Basque Country</orgName>
								<address>
									<postCode>20009</postCode>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">are with Brunel University</orgName>
								<address>
									<postCode>UB8 3PH</postCode>
									<settlement>Uxbridge</settlement>
									<region>Middlescn</region>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">University ofGIamorgan</orgName>
								<address>
									<postCode>CF37 IDL</postCode>
									<settlement>Pontypridd</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="department">are with Systems Integration Research. British Telecom</orgName>
								<address>
									<postCode>IP5 3RE</postCode>
									<settlement>Adastral Park, Ipswich</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="institution">Drenel Univmiry. Philadelphia</orgName>
								<address>
									<postCode>19104</postCode>
									<region>PA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff6">
								<orgName type="institution">M. Roper is with Strathclyde University</orgName>
								<address>
									<addrLine>Livingstone Tower. 26 Richmond Street</addrLine>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff7">
								<orgName type="institution">Glasgow G I IXH</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Reformulating software engineering as a search</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">367D1E43CE4147D0694DCF2750F8D178</idno>
					<note type="submission">received 18th November 2002</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Metaheuristic techniques such as genecc algorithms, simulated annealing and tabu search have found wide application in most areas of engineering. These techniques have also been applied in business, financial and economic modelling. Metaheuristics have been applied to three areas of software engineering: test data generation, module clustering and cost/effort prediction, yet there remain many software engineering problems which have yet to be tackled using metaheuristics. It is surprising that metaheuristics have not been more widely applied to software engineering; many problems in software engineering are characterised by precisely the features which make metaheuristics search applicable. In the paper it is argued that the features which make metaheuristics applicable for engineering and business applications outside software engineering also suggest that there is great potential for the exploitation of metaheuristics within software engineering. The paper briefly reviews the principal metahenristic search techniques and surveys existing work on the application of metaheuristics to the three software engineering areas of test data generation, module clustering and cost/effort prediction. It also shows how metaheuristic search techniques can be applied to three additional areas of software engineering: maintenance/evolution system integration and requirements scheduling. The software engineering problem areas considered thus span the range of the software development process, from initial planning, cost estimation and requirements analysis through to integration, maintenance and evolution of legacy systems. The aim is to justify the claim that many problems in software engineering can be reformulated as search problems. to which metaheuristic techniques can be applied. The goal of the paper is to stimulate greater interest in metaheuristic search as a tool of optimisation of software engineering problems and to encourage the investigation and exploitation of these technologies in finding near optimal solutions to the complex constraint-based scenarios which arise so frequently in software engineering.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Many of the problems associated with complexity management of the software development process have proved resistant to conventional analytical solutions. The software development process and its products tend to be characterised by a large number of competing and interrelated constraints. Some of these are clearly specified, while others are notoriously vague and poorly defined. Changes to one parameter can often have a large impact upon several related areas, making the balancing of concerns very difficult.</p><p>If there were only a single solution to a typical set of software engineering constraints, then software engineering would probably not be regarded as 'engineering' at all.</p><p>The authors take as their premise the claim that software engineers face problems which consist, not in finding the solution, but rather, in engineering an acceptable or near optimal solution from a largc number of alternatives. Often it is not clear how to achieve an optimal solution, but it is more clear how to evaluate and compare candidates. For instance, it may be hard to know how to achieve a design with low coupling and high cohesion, yet relatively easy to decide whether one design is more closely coupled than another.</p><p>Metaheuristic search techniques are a set of generic algorithms which are concerned with searching for optimal or near optimal solutions to a problem within a large multimodal search space. These search spaces typically arise when a number of competing constraints have to be balanced against one another to arrive at a solution which is 'good enough'. Typically, for these problems, it is infeasible to apply a precise analytic algorithm which produces the 'hest' solution to the problem, yet it is possible to determine which is the better of two candidate solutions. Metaheuristic algorithms [I-71 have been applied successfully to a number of engineering problems, ranging from load balancing in the process industries (pressing of sugar pulp) through electromagnetic system design to aircraft control and aerodynamics [SI.</p><p>It is surprising that technologies such as metaheuristic search have not penetrated the software engineering research community and are not widely applied when compared with the more traditional engineering discir plines. This paper argues that software engineering problems can often be thought of as search problems and thus metaheuristic search can be applied to a whole range of software engineering problems such as requirements gathering, systems integration and evolution.</p><p>The aim of the paper is to provide a new perspective on software engineering problems, in which they are reformulated as search problems to which metaheuristic algorithms can be applied. This new perspective should be regarded as complementary and supplementary to existing approaches, rather than being a replacement. The paper argues that metaheuristic search techniques simply provide another technology with which many software engineering problems can he attacked. To justify this claim, the paper surveys existing successful results in the application of metaheuristic search techniques to automated software test data generation, module clustering and cost/effort prediction and provides a reformulation of three other software engineering problem areas as metaheuristic search problems. Together, the six areas considered span the software development process from scheduling and requirements, cost and effort estimation, through system integration to source transformation for maintenance and re-engineering.</p><p>The hope is that the paper will stimulate greater interest in metaheuristic search technologies within the software engineering community, leading to further research into the application of these techniques to solving the complex sets of constraints which make software development and evolution such a demanding process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Metaheuristic search techniques</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Opfimisafion</head><p>Optimisation seeks to find the set of parameters for which an objective function has a maximum or minimum value. The objective function may have a number of local extreme points in addition to the global extremum. Metaheuristic algorithms are a set of techniques that have been successfully applied to solving optimisation problems in the presence of many local extrema, with many parameters and in the presence of conflicting constraints. They have been used to find acceptable approximations to the solution of many NP complete problems.</p><p>Examples of metaheuristic algorithms are local searchbased techniques such as hill-climbing simulated annealing and tabu search, and evolutionary techniques such as genetic algorithms. These are described briefly in the following two sections.</p><p>The key ingredients of any search-based optimisation problem are: the choice of the representation of the problem the definition of the fitness function. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.7">Hill-climbing:</head><p>In hill-climbing, the search proceeds from a randomly chosen point by considering the neighbours of the point. Once a fitter neighbour is found this becomes the 'current point' in the search space and the process is repeated. If there is no fitter neighbour, then the search terminates and a maximum has been found (by definition). The approach is called hill-climbing, because when the fitness function is thought of as a landscape, with peaks representing points of higher fitness, the hill-climbing algorithm selects a hill near to the randomly chosen start point and simply moves the current point to the top of this hill (climbing the hill).</p><p>Clearly, the problem with the bill-climbing approach is that the hill located by the algorithm may be a local maximum, and may be far poorer, in terms of fitness, than the global maximum in the search space. However, hillclimbing is a simple technique which is easy to implement and has been shown to be useful and robust in the software engineering applications of modularisation [9, IO] and cost estimation [I I] (see also Sections 3.2 and 3.4).</p><p>There are many variations of the hill-climbing theme. For example, should the algorithm select the first neighbour it finds with better fitness than the current individual (first ascent hill-climbing) or should it consider all of the neighbours and select that with the best fitness improvement (steepest ascent hill-climbing)? Whichever variation is chosen, the important characteristic of hill-climbing is the property that it will select a local peak, which may be a local optimum, and once this local peak is found the algorithm terminates-fast, simple, but prone to suboptimality. Simulated annealing and tabu search are local search techniques which also search a local neighbourhood within the search space, but each has a different approach to overcoming this tendency to become trapped by a local maximum.</p><p>The key ingredient of the hill-climbing algorithm is the definition of a neighbourhood on the configuration space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2">Simulated annealing:</head><p>Simulated annealing [I21 is a method of local searching, in contrast to genetic algorithms which sample the whole domain and improve the solution by recombination in some form. In simulated annealing, a value, .rI , is chosen for the solution, x, and the cost (or objective) function, E, is minimised. Cost functions define the relative undesirability of particular solutions. In general, larger values of the function are associated with larger casts. Similarly, since we wish to satisfy constraints, values of the function's dependent variable !hat blatantly break constraints will attract a greater cost than those that satisfy all constraints, or come close to doing so. When minimising, the objective function is usually referred to as a cost function. When maximising it is usually referred to as a fitness function.</p><p>The simulated annealing algorithm then considers a neighbouring value of xI and evaluates its cost function; what constitutes a neighbouring value of x , may not he immediately obvious and a neighbour, x i , must be defined in an appropriate way. If the cost function for xi is reduced, the search moves to x', and the process is repeated. However, if the cost function increases, the move to x', is not necessarily rejected; there is a small probahility,p, that the search will move to x; and continue. The probability, p , is a function of the change in cost function, AE, and a parameter, T:</p><formula xml:id="formula_0">= ,-(AE)/T</formula><p>This probability is of a similar form to the Maxwell-Boltzmann distribution law for the statistical distribution of molecular energies in a classical gas, where AE and T are related to energy and temperature, respectively. When the change in cost function is negative (i.e. an improvement), the probability is set to one and the move is always accepted. When AE is positive (i.e. unfavourable), the move is accepted with the probability given in the equation above; the probability depends strongly on the values of the AE and i ? At the start of the simulated annealing, Tis high and the probability of accepting a very unfavourable move is correspondingly high. During the search, T is slowly reduced by some function, C, called the 'cooling' function because of its counterpart in the physical world. The effect of 'cooling' on the simulation of annealing is that the probability of following an unfavourable move is reduced. In practice, the temperature is decreased in stages, and at each stage the temperature is kept constant until thermal quasi-equilibrium is reached. The set of parameters that determine the temperature decrement (i.e. initial temperature, stop criterion, temperature decrement between successive stages, number of transitions for each temperature value) is called the cooling schedule. The cooling schedule is critical to the success of the optimisation.</p><p>The algorithm is described in Fig. <ref type="figure">1</ref>.</p><p>The key ingredients of the simulated annealing algorithm are:</p><p>1. the definition of a neighbourhood on the configuration space 2. the specification of the cooling schedule.</p><p>The term 'simulated annealing' arises from the use of the Maxwell-Boltzmann probability function along with a procedure of cooling; metallurgical annealing involves heating a metal or alloy to a high temperature and cooling slowly to room temperature with the aim of removing internal stresses and thereby improving ductility and reducing brittleness. The technique originates from the theory of statistical mechanics and is based upon the analogy between the annealing of solids and solving optimisation problems. It is not helpful to pursue the analogy with the physical world to any greater extent.</p><p>The cffectiveness of the search depends upon the initial temperature (is it high enough to randomise the search sufficiently?) and the subsequent cooling (is it slow</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Initialise x t o xo and Tto</head><formula xml:id="formula_1">To loop-Cooling IOOD Local search Derive a neighbour, x', of x BE = E M -E(x) if A E c O then x : = g else derive random if r c k E J T number r t l O , 11</formula><p>enough to ensure that equilibrium is achieved at each temperature?).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.23">Tabu search:</head><p>Tabu search <ref type="bibr" target="#b1">[2]</ref> is an iterative procedure for solving discrete combinatorial optimisation problems. The space of all possible solutions is searched in a sequence of moves from one possible solution to the best available alternative. To prevent being stuck at a suboptimal solution and to avoid drifting away from the global optimum, some moves are classified as forbidden 'or tabu (taboo). The list of tabu moves is formed using both short-term and long-term memory of previous unpromising moves. A move may also he regarded as 'unpromising' simply because it was recent. On occasions, a tabu move may be allowed. This is an aspiration criterion, whereby the tabu move might lead to the best solution obtained so far.</p><p>The search space, or neighbourhood, comprises a set of moves that lead to another solution when applied to the current solution. Tabu search starts at a possibly random point and determines a sequence of moves during which a tabu set is established; some members of the tabu set may he classified as a member of an aspirant set. The criteria for classifying aspiring moves are specific to the application. Moves may be tabu if they could lead to a solution that has already been considered (recency or short-term condition) or has been repeated many times before (frequency or long-term condition). The next move is the best neighbouring solution which is either not tabu or is an aspirant.</p><p>A generic tabu search algorithm is summarised in Fig. <ref type="figure">2</ref>.</p><p>The key ingredients for setting up a tabu search are to:</p><p>b define the neighbourhood of a solution b define an aspiring move.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Evolutionary search using genetic algorithms</head><p>Genetic algorithms (GAS) [4,  diverse pool of genetic material is preserved for the purpose of breeding yet fitter individuals. This terminology strongly suggests that GAS are based on the principles of Darwinian evolution. This analogy should not be taken too literally since Darwinian evolution is assumed blind and improvements happen by chance rather than by aspiring to a goal; improved individuals are those with a better chance of survival and thus they are able to pass their genes to their offspring.</p><p>Chance plays an important role in GAS, though their success in locating an optimum [Note I] strongly depends on a judicious choice of a fitness function. The fitness function must be designed carefully to reflect the nature of the optimum and to direct the search along promising pathways.</p><p>GAS operate on a population of individuals (often called chromosomes) each of which has an assigned fitness. The population size should he sufficiently great to allow a substantial pool of genetic material, but not be so large that the search degenerates into a random search. Those individuals that either undergo recombination or survive are chosen with a probability which depends on fitness in some way. There are many different selection mechanisms: in the So-Cdkd roulette wheel, the population's cumulative fitness is normalised to give a set of probabilities for each individual; io the N-toumament, N individuals are selected at random from a population and the fittest chosen.</p><p>A generic evolutionary algorithm is presented in Fig. <ref type="figure" target="#fig_2">3</ref>.</p><p>The key ingrcdients of the genetic algorithm are: 0 the specification of probabilities of crossover and mutation the choice of recombination, mutation and selection algorithms.</p><p>An advantage o f GA is that the solution domain is sampled, though if the evaluation of the fitness hnction is computationally expensive, this advantage may rapidly become a disadvantage. In spite of sampling, there is no guarantee that the global optimum will be found and the search may rapidly stagnate at a sub-optimum unless steps are taken to preserve the diversity of genetic material. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Evolutionary search using genetic programming</head><p>In genetic programming [5], the goal is to produce a program which solves a particular problem. The fitness function is defined in terms of how close the program comes to solving the problem. The operators for mutation and mating are defined in terms of the program's abstract syntax tree. Because these operators are applied to trees rather than sequences, their definition is typically less straight fonvard than those applied to GAS.</p><p>Note I : Or sub-optimum; in this section, the tem optimum is taken to subsume sub-optimum.  Genetic programming can be used to find functions which describe (and predict) data. In this way the genetic program is an algorithmic fit to a set of data. The fit need not be perfect, in order to be useful. Indeed, many of the applications of genetic programming described by Kora <ref type="bibr">[5]</ref>, require not a perfect fully 'correct'solution, hut merely one which is 'good enough'. Genetic programming can be used to find fits to software engineering data, such as project estimation data, as will be described in Section 3.4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">The use of metaheuristic algorithms to' solve problems in software engineering</head><p>The strength of metaheuristic algorithms is that they seek iteratively an optimum solution within a landscape that may be extremely complicated and even discontinuous.</p><p>The key to applying metaheuristic algorithms successfully is, first, to formulate the problem in hand as a search/optimisation problem. For instance, as will he seen in Section 3, the automated generation of test data can be formulated as a search within the input domain guided by a fitness function which captures an appropriate test adequacy criterion. Having formulated the problem as a search problem, it is necessary to define the essential ingredients relevant to the chosen metaheuristic.</p><p>All metaheuristic techniques require a suitable representation for the candidate solution (or 'individual') together with a fitness (or cost) function. The fitness function defincs B 'fitness landscape' which gives the search a sense of direction; the search will be hindered by landscapes which have too shallow gradients and by landscapes with a few sharply-defined peaks or craters. The definition of suitable fitness functions for software engineering problems is therefore a major area of work required to underpin the exploitation of metaheuristics in software engineering.</p><p>All search techniques rely upon a concept of a move from one individual to another. This can be either in the form of a 'move' to a 'near neighbour' or a 'mutation' which may produce a jump to a very different individual (i.e. not a 'near' neighbour). The available mutation and/or move operations that can he applied to an individual are typically delimited by the choice of representation.</p><p>The definition of representation, fitness function and mutation/move operations should he considered first, as these are a pre-requisite for the application of any of the metaheuristic search techniques outlined in this paper. Having defined these three key ingredients it becomes possible to apply hill-climbing, simulated annealing and other local search techniques. To apply genetic algorithms it will be necessary to define a crossover operator.</p><p>A near neighbour may be defined as a predecessor or successor fur an ordinal type and to be arbitrarily close for a floating type. Normally, the search space will be multi-dimensional and a decision must he made about how many values to change and in what way.</p><p>A crossover operator takes two individuals (the parents) and produces a new individual (the. offspring) which is related to both parents, by sharing some of the information of each. In the literature, this process is regarded as an analogue of sexual reproduction in living individuals (though, typically, no gender distinction is made.)</p><p>To apply metaheuristics to software engineering problems, the following steps should therefore be considered: I . Ask: Is this a suitable problem? That is, 'Is the search space sufficiently large to make exhaustive search impractical?' 2. Define a representation for the possible solutions. 3. Define the fitness function. The motivation for the final piece of advice in this prescription for the application of metaheuristics is the observation [9-11, 141 that hill-climbing may produce results which are suficiently good to make the application of more sophisticated techniques an unnecessary additional effort. Of course, there are also landscapes in software engineering, such as the test data input landscape [15], where genetic approaches outperform hill-climbing. However, even for these landscapes, hill-climbing represents a good starting point. If the results for the simple hillclimbing approach are not better than those for a random search, then this may indicate a lack of understanding of the problem area or that the representations used are perhaps inadequate. It could also he a reflection of the fact that the problem area simply is not suited to a searchbased approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Problem characteristics</head><p>This section describes some of the characteristics of the problem space which would lead to its being suitable for attack using a search-based solution. The section also contains examples of source engineering activity areas where search-based techniques are unlikely to prove successful, as a way of hounding the problem.</p><p>1. Large solution space. Building any artefact can he thought of as a search problem. The space of possible solutions has to be sufficiently large that enumeration of candidate solutions is impossibly expensive. 2. No known efficient and complete solution. Clearly there is little to he gained from applying a new solution to a problem which is already solved. However, search-based approaches may yield additional insight and may help to 'fill in gaps' where existing solutions are only partial.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.</head><p>The existence of suitable candidate fitness functions. Fields of soRware engineering activity which have a large number of readily accepted metrics are examples of this. 4. Cheap generation of candidate solutions. A large solution space makes search-based solutions inevitable, hut in order to apply them, the candidate solutions will need to he valuable in reasonable time. Typical searchbased algorithms require many executions of the fitness function, so speed of execution of the fitness function is crucial.</p><p>Likely criteria for success include:</p><formula xml:id="formula_2">IEE Proc -.SqIix:, Yo/. I50 No. 3, June 20113</formula><p>Areas of software engineering activity which are unlikely to profit from search-based solutions include:</p><p>. most forms of requirements clicitation e aspects of human interaction situations where it is unclear what is required.</p><p>3 Existing applications of metaheuristics to software engineering</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7">, Testing</head><p>For the problem of generating test data for software, the individuals over whom optimisation occurs are the test cases and these can he represented in ways that allow mutation, crossover and the notion .of a neighbourhood. Crucially, testing normally aims to achieve certain measurable objectives. In fact, many test generation techniques are based around some notion of the coverage of the code or specification. This coverage can he measured and incorporated into an objective function.</p><p>Metaheuristics have been applied to the following types of testing: I . structural testing 2. specification based testing 3. testing to determine the worst case execution time metaheuristics to them, shall now be discussed.</p><p>Each of these types of testing, and the application of</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.7">Structural testing:</head><p>Structural, or white-box, test techniques determine the adequacy of a test set by considering the structure of the code. Normally such techniques consider certain constructs and measure the proportion of these constructs, in the source code, that are executed during testing. This proportion is called the coverage. Given a construct being considered it is normal to insist on full coverage: all such (feasible).constructs are executed during testing.</p><p>A number of forms of coverage, including the following, are based on the control flow graph:</p><p>1. statement coveruge: the proportion of the reachable program statements that are covered during testing 2 . branch coveruge: the proportion of the feasible program branches (edges of the control flow graph that leave a node that has more than one possible next node) that are covered during testing 3. path coverage: the proportion of the feasible paths, through the control flow graph, that are covered during testing.</p><p>When considering a particular notion of coverage, random testing may provide a high level of coverage.</p><p>There will often, however, he constructs that are unlikely to he executed by random testing and thus test generation may be broken down into two phases: use random testing to cover most constructs and then use some other technique to derive tests to cover the remaining constructs. A number of authors have considered the use of metaheuristics in the second phase [16-19].</p><p>Suppose a construct has not been executed during testing. Then the tester may choose some path that contains this construct and try to derive test cases that follow this path. Consider the fragment of code (written in a C style notation), from a program produced to solve the triangle problem, shown in Fig. 4. In order to test the t h e n branch of the final i f statement it is sufficient to follow the else  <ref type="bibr" target="#b3">4</ref> Frugment ofcode for triangle problem branches of the first two i f statements followed by this then branch.</p><p>Naturally a path that has been chosen might be infeasible and thus if a test generation process fails to execute the path for a significant length of time the tester might choose an alternative path. An objective function may be defined by, given a test input, measuring how close it gets to taking this path (up to the end of the construct being considered). This might be how many predicates it has in common with the intended path <ref type="bibr">[18]</ref>. The fitness may he measured by instrumenting the code and the tcst input may be rcpresented by a string of values or a bit string.</p><p>Suppose, again, that the tester wishes to test the final then branch of the code in Fig. <ref type="figure">4</ref>. If a test case takes the first e l s e branch and then the second then branch, under the notion of fitness given above, this test case is given fitness I .</p><p>Given a particular criterion, it may be possible to further refine the objective function. Jones ef al. [16, 171, who consider the use of genetic algorithms for branch testing, give a fitness function for a test that reaches the initial vertex of the branch. The fitness function depends upon the values of the statc when it reaches this vertex. Any test that fails to reach the vertex is given a low fitness. Assuming the test reaches the initial vertex of the branch being considered the calculation of the fitness considers two cases: in the first case the test does not go down the correct branch and in the second it does go down the correct branch.</p><p>If the test fails to go down the correct branch, the fitness depends upon how close the state variables were, at that point, to executing the correct branch. The closer a test is to executing the correct branch, the higher its fitness. Consider the then branch of the second i f statement from Fig. <ref type="figure">4</ref>. If the input reaches the initial node of this (and thus follows thc else branch of thc first i f ) but follows the e l s e branch at this point, the fitness might be inversely proportional to how close a is to b and how close b is to a. The fitness might then be 1</p><formula xml:id="formula_3">(1 + la -bl + Ib -CI)</formula><p>lfthe test goes down the correct branch, the fitness depends upon how close the state is to the boundary of the branch: the closer to the boundary the higher the fitness. Consider the e l s e branch ofthe second i f statement. lfthis branch is taken as the result of executing a test case, then again, the fitness might be inversely proportional to la ~ b/ + / bc / . This second case is motivated by the observation that tests around boundaries are often effective at detecting faults and thus the fitness should drive the values towards the boundary of the branch. Again the fitness may be determined by instrumenting the code.</p><p>The fitness function described by [ 16, 171 could, potentially, be combined with that described in <ref type="bibr">[18]</ref>. Given a branch, some path to this branch might be chosen. If a test does not rcach the initial vertex of the branch, then the fitness depends on how close the test is to executing the path. If the test reaches the initial vertex of the branch, then the total fitness depends upon that described in [16, 171.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>166</head><p>The fitness described in [16, 171 might be called a local fitness, since it only considers the initial node of the branch. Then the total fitness, for a test that reaches the initial node of the branch, might be the local fitness plus the number of predicates on the path to the branch.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7.2">Specification-based testing:</head><p>Tracey et al. <ref type="bibr" target="#b15">[19]</ref> consider the problem of testing from a formal specification that is in the form of a set of (disjoint) pre/post conditions. For such a system, a test case leads to a failure if, for one of these pre/post pairs, it satisfies the precondition but fails the post condition.</p><p>For each pre/post condition pair (e Q), the predicate C(P, Q) = QV-P is formed. Then a fault is detected i f a test exccution makes C(P, Q) false. To try to drive test cases towards detecting faults, a fitness function, that depends on how close the test case is to making C(P, Q) false, is used. C(P, Q) is rewritten to disjunctive normal form and the conjuncts from this are considered in turn. Thus, each conjunct is tested with the intention to try to make it take on the value,fuDe. Naturally, the fitness must depend upon more than just whether the value is true or false. Instead, assuming the conjunct is true for the value being considered each tenn in the conjunct contributes to the final fitness value, which is the sum of these values (the problem is to minimise this fitness). For certain classes of predicate, such as e , &gt; e2 for expressions e , and e2, a fitness function that gives a range of values may be defined. For example, with cI &gt; c2, the fitness is 0 if the predicate is false and otherwise the fitness is e l -e 2 .</p><p>Thc authors use simulated annealing to try to find faults. Interestingly, the authors find that a similar approach, in which assertions are placed in the code with the intention of trying to make them false, can be used to test exception conditions [19].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7.3">Worst case execution time:</head><p>Real-time control systems are often designed to respond to a stimulus within some fixed time interval. A failure to respond sufficiently within this interval may lead to a critical condition. Thus, it is often important to determinc the worst case execution time of a function or method. The problem of determining the worst case execution time is often, however, highly complex as it may depend crucially on properties of the hardware and the compiler.</p><p>Genetic algorithms have been used in an attempt to find the maximum and minimum execution times [20, 211: Given an input, represented by a chromosome, the fitness of this input depends upon the execution time: when trying to find maximal times the fitness is proportional to the execution time and when trying to find minimal times the fitness is inversely proportional to the execution time.</p><p>Simulated annealing has been used in a similar manner [22]. This approach not only consistently outperformed random testing but also found a new minimum execution time for one module [21].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Module clustering</head><p>According to Shaw and Garlan [23], the software architecture of a system consists of a description of the system elements, the interactions between them, the patterns that guide their construction, and constraints on their relationships. For smaller systems the elements and relations may be modelled using source code entities such as procedures, classes, method invocation, inheritance, and so on.</p><p>However, for larger systems, the desired entities may be abstract (high-level), and modelled using architectural artefacts such as subsystem components and relations.</p><p>Subsystems provide developers with structural information about the numerous software components, their interfaces, and their interconnections. Subsystems generally consist of a collection of collaborating source code resources that implement a feature or provide a service to the rest of the system. Typical resources found in subsystems include modules, classes and possibly other subsystems. Subsystems facilitate program understanding by treating sets of related source code resources as highlevel software abstractions. Subsystems can also he organised hierarchically, allowing developers to study the organisation of a system at various levels of detail by navigating through the hierarchy.</p><p>The entities and relations needed to represent software architectures are not found in the source code. Thus, without external documentation, techniques capable of deriving a reasonable approximation of the software architecture from source code are needed. Research into the software clustering problem has proposed several approaches to deal with this challenge by defining techniques that partition the structure of a software system into subsystems (clusters). Most of these techniques determine clusters (subsystems) using either source code component similarity <ref type="bibr" target="#b19">[24]</ref>, sets of heuristic rules <ref type="bibr" target="#b20">[25]</ref>, concept analysis and clustering metrics [26-291, or information available from the system implementation such as module, directory and/or package names [30].</p><p>Although the above-mentioned software clustering techniques have been shown to produce good results on certain types of systems, promising results have been obtained on a variety of different systems by applying heuristic-search techniques to the software clustering problem <ref type="bibr" target="#b13">[14]</ref>. Mitchell and Mancoridis have studied hill-climbing, simulated annealing and genetic algorithm searches, and have implemented their software clustering algorithms as a suite of integrated tools that can be downloaded over the Internet [3 I]. Other researchers have examined how to modularise software systems using genetic algorithms [9, 321.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Software clustering as a search problem</head><p>The starting point for applying search-based techniques to the software clustering problem is to formalise the representation of the structure of the system to be clustered. Based on this representation, a fitness function is required to measure the relative quality of the system modularisation once its structure is decomposed into subsystems (clusters). Finally, an algorithm is required to traverse the space of candidate solutions, using the fitness function to locate a good solution from the enormous set of all possible solutions. Like most metaheuristic search problems, the result produced by the clustering algorithm need not be the optimal solution in a theoretical sense. Rather, it is a solution that is perceived by several people to be 'good enough'.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Representation:</head><p>One of the goals of most software clustering algorithms is to be neutral of programming language syntax. To accomplish this goal, source code analysis tools can be used to transform the structure of the system's code into a language-independent directed graph.</p><p>Graph G is formally defined as G = (M, R), where M is the set of named modules in the software system, and R g M x M is a set of ordered pairs of the form (U, v), which represents the source-level relationships that exist between module u and module v (e.g. module U uses an exported function in module v). Also, G can have weighted edges to establish the 'strength' of the relationship between a pair of modules.</p><p>The primary goal of software clustering algorithms is to propose subsystems (clusters) that expose abstractions of the software structure. Each partition of the software structure graph G is defined as a set of nonoverlapping clusters that cover all of the graph's nodes. The goal is to partition the graph so that the clusters represent meaningful subsystems. Finding a 'good' partition involves navigating through the search space of all possible partitions of G in a systematic way.</p><p>It should also be noted that there are many ways to define G. For example, a Module Dependency Graph places an edge between a pair of modules if one module uses resources provided by the other module. Other graphs can be created by considering dynamic program behaviour (e.g. dynamic loading, object creation, runtime method invocation), inheritance relationships, and so on. Clustering alternative graph representations of the same software systems provides users with additional insight into the overall system architecture, which is helpful for activities such as program understanding and software maintenance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">fitness functions:</head><p>When designing a fitness for software clustering applications, a fundamental decision must be made about what constitutes a good partition of the software structure graph. One of the most popular approaches implemented by researchers is to define a fitness function that maxiniises the cohesion of the individual clusters while at the same time minimising the coupling between all of the clusters.</p><p>As an example, consider the fitness function implemented in the Bunch <ref type="bibr" target="#b27">[33]</ref> clustering tool. The authors refer to their fitness function as madulurisution yuulity (MQ). MQ for a software structure graph G partitioned into k clusters is calculated by summing the clusterfactor (CF) for each cluster of the partitioned graph. The cluster factor CF;, for cluster i (1 5 is k), is defined as a normalised ratio between the total weight of the internal edges (edges within the cluster) and half of the total weight of external edges (edges that exit or enter the cluster). The weight of the external edges is split in half in order to apply an equal penalty to both clusters that are connected by an external edge. Internal edges of a cluster are referred to as intreedges. The number of intra-edges for module i is denoted by p i . The edges between two distinct clusters i and j are the inter-edges. The number of inter-edges between a module i and a module j is denoted as z i j . If edge weights are not provided by G, it is assumed that each edge has a weight of 1. Also, note that = 0 and P,.~ = 0 when i = j .</p><p>The formal definition of the MQ calculation is defined as follows:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I &gt;Pi</head><p>Notice how MQ increases as the cohesiveness of the individual clusters increases and the coupling between all of the clusters decreases. Thus the goal of the search algorithms implemented in Bunch is to maximise MQ.</p><p>An alternative objective function that integrates the concept of cluster granularity into the fitness evaluation has been investigated by Harman et al. <ref type="bibr">191</ref>. Lutz <ref type="bibr" target="#b26">[32]</ref> describes a fitness function for a GA that measures complexity based on coupling and cohesion principles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.3">Software clustering search algorithms:</head><p>One way to find the best partition of the software qtructure graph is to perform an exhaustive search through all of the valid partitions, and select the one with the best fitness value. However, this approach is often impossible because the number of ways the system can be partitioned into subsystems grows exponentially with respect to the number of its nodes (modules) [33; Note 21. Because discovering the optimal grouping of modules into clusters is only feasible for small software systems (e.g. fewer than 15 modules), heuristic search algorithms are required to locate acceptable results quickly.</p><p>Mitchell and Mancoridis have designed and implemented the following software clustering search algorithms into the Bunch tool:</p><p>I. Hill-climbing search algorithm: Bunch's hill-climbing clustering algorithms [33] start by generating a random partition of the software structure graph G. Modules from this partition are then rearranged systematically by examining neighbouring partitions in an attempt to find an 'improved' partition (a partition with a better fitness). If a better partition is found, the process iterates, using the improved partition as the basis for finding even better partitions. The hill-climbing search algorithm eventually converges when no improved partitions of G can he found.</p><p>During each iteration, several options are available for controlling the behaviour of the hill-climbing algorithm:</p><p>(a) The neighbouring process uses the first partition that it discovers with a larger fitness function (MQ) as the basis for the next iteration. (b) The neighbouring process examines all neighbouring partitions during the current iteration and selects the partition with the largest MQ as the hasis for the next iteration. (c) The neighbouring process ensures that it examines a minimum number of neighbouring partitions during each iteration. If multiple partitions with a larger MQ are discovered within this set, then the padition with the largest MQ is used as the basis for the next iteration. If no partitions are discovered that have a larger MQ, then the neighbouring process continues, and uses the next partition that it discovers with a larger MQ as the basis for the next iteration.</p><p>2. Jfill-climbing using simulated annealing: Bunch's hillclimbing algorithm includes the ability to accept, with some probability, a partition with a worse fitness function value as the new solution of the current iteration. The probability of accepting a nonimproving partition is reduced exponentially as the clustering process continues by invoking a user-defined cooling function. Results associated with the use of Bunch's simulated annealing feature have shown an improvement in performance without sacrificing any quality in the clustering results [lo].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Generic algorithm (GA):</head><p>The Bunch GA <ref type="bibr" target="#b28">[34]</ref> uses traditional operators such as selection, crossover and mutation to determine a 'good' partition of the software structure graph. Although GAS have been shown to produce good results in many search problems, the quality of the clustering results produced by Bunch's hill-climbing algorithm are typically better than the Bunch GA. Mitchell and Note 2: It should also be noted that the general problem of gmph partitioning (of which software clustering i s a special casc) is NP-hard.</p><p>Mancoridis think that further work on Bunch's encoding and crossover techniques is necessary.</p><p>Harman et al.</p><p>[9] implemented two GAS and a hillclimber to cluster software systems using a fitness function that is also based nu maximising the cohesiveness of clusters and minimising inter-cluster coupling. The fitness function used by Harman et al. also includes a concept of 'target granularity', the idea being that the tool should aim to produce clusterings with a desired number of modules. The fitness function achieves this by enforcing a quadratic punishment as the clustering produced deviates from the target granularity. The two GAS used explored crossover techniques designed to promote the formation of good building blocks, by preserving at least one module in each child. Although this produced improved results over a GA with no such crossover technique, Harman el a/. found that hill-climbing far outperformed both variations of genetic algorithms, confirming results by the Bunch team <ref type="bibr" target="#b13">[14]</ref>.</p><p>Lutz <ref type="bibr" target="#b26">[32]</ref> has also worked on hierarchical clustering using search-based techniques. His work was concerned with the problem of decomposition of software into hierarchies at different levels of abstraction, like the work of Macoridis et al., but unlike that by Harman er al., which was concerned with only a single level of abstraction (the implementation level). Lutz also focuses upon the clustering and hierarchies in designs rather than code.</p><p>The approach adopted by Lutz differs strongly from the approach adopted in the work of Macoridis er al. and that of Harman et al. with regard to the choice of fitness function. The fitness function used by Lutz is based upon an information-theoretic formulation inspired by Shannon <ref type="bibr" target="#b29">[35]</ref>. The function awards high fitness scores to hierarchies which can he expressed most simply (in information theoretic terms), with the aim of rewarding the more 'understandable' designs.</p><p>Search-based software modularisation is now an estahlished approach to software clustering, with promising results in terms of quality and efficiency. Mitchell's PhD dissertation [ 141 reports promising results, both in terms of quality and performance, when applying search algorithms to the software clustering problem. For example, the Bunch hill-climbing algorithm produces acceptable clustering results for systems such as Sun's swing class library in about 30s, and the linux operating system in approximately 90 s.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Cost estimation</head><p>Initial approaches for applying metaheuristic methods to the problem of cost estimation have considered 'system identification' or 'symbolic regression' approach <ref type="bibr">[36, 371.</ref> This work bas used genetic programming (GP) to learn predictive functions from training sets. The idea is similar to that studied in the works of McKay and Willis, in which GP is used to discover the function that relates the data points of the independent to the dependent variables.</p><p>Dolado <ref type="bibr">[36, 371 has</ref> shown that GP is able to discover nonlinear as well as linear systems. In the cost estimation problem the data relate the size of the application to the effort (usually measured in person-months). Size is usually measured in function points or in lines of code.</p><p>The operands of a solution may be constants or variables. The operators include the following:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>+, -, + . / , p o w e r , sqrt, square, log, exp</head><p>This variety of operators will allow approximation of almost any function likely to be required by this model. The population of equations to be evolved is composed of a set of well-formed equations to which the usual genetic operators mutation and crossover are applied. Crossover is applied to the trees by exchanging subtrees between equations. Mutation consists in changing the value of the nodes of the trees, by replacing a node with another operator or with a new numeric value.</p><p>The fitness function used in the evaluation of the equations is the mean squared error, This is a usual measure for assessing regression models. Other measures, such as the correlation coefficient, could not be considered since it is not clear which one should be recommended. The next generation is formed by selecting the equations according to the 'fitness proportionate selection method'. With this method an individual of the population is selected or rejected according to a probability proportional to its fitness.</p><p>Dolado <ref type="bibr" target="#b30">[36]</ref> reports that the number of individuals in each generation were low, around 50 equations, and the number of generations that provided the best results was surprisingly very low, from 3 to 5 generations in most cases. These parameters have not demanded special computing power, as the convergence to the solution was achieved so quickly. This behaviour can be attributed to the few data points available in each data set, as well as the low number of variables.</p><p>Dolado [36, 371 also reports results regarding the application of GP to cost estimation. First of all, the GP obtains equations that approximate the data at least as well as the classical regression method. In some cases GP is able to obtain better cost functions than classical regression. However, the improvement in the predictions is not dramatic and GP cannot overcome the intrinsic limitations of the data points. GP has helped to conclude that the best curve that approximates several data sets, publicly available, is a linear function between size and effort <ref type="bibr" target="#b31">[37]</ref>. The results of classical regression can be misleading due to the fact that only a small set of the mace of functions can be analysed.</p><p>The main benefit that G P provides is confidence in the results. GP explores the solutions guided only by the fitness of the equations and does not constrain the form of the solution. Therefore the final set of equations that are found by GP have the best predictive values. By running the algorithm many times, an ample set of good approximations is obtained.</p><p>Two methods for size estimation were compared in <ref type="bibr" target="#b30">[36]</ref>, the component-based method and the Mark11 function point method. The results of GP were compared to those obtained by artificial neural networks (ANNs) and classical regression. It was observed that ANNs performed slightly better than GP, from the predictive point of view. However, the drawback of the ANNs in such prediction systems is that they do not provide a symbolic representation of the equation, rendering the method less useful for the sofiware project manager. With the ANN approach it is hard to work out the reason behind the automated system's choice of predicted value, leading to uncertainty as to the confidence that can be placed in such an estimate.</p><p>Linear regression (or curve estimation) presented the worst values. GP essentially offers the best of both approaches since it provides symbolic equations as the result of its evolutionary process and, also, takes advantage of the computational power of techniques. Another advantage of the GP approach is that it is a nonparametric method since it does not make any assumption about the distribution of the data, deriving the equations according only to fitted values.</p><p>A similar approach to software project cost estimation is proposed by Burgess and Lefley <ref type="bibr" target="#b32">[38]</ref>, who use GP to evolve functions which provide good fits to the trends found in software project cost data. Burgess and Lefley present results comparing GP-based effort estimation against approaches based upon stepwise regression and neural nets. They also show how to highlight statistically significant predictions.</p><p>Aguilar-Ruiz et al. <ref type="bibr" target="#b33">[39]</ref> have also worked on the problem of search-based software project cost estimation. In their work, the use of the evolutionary algorithms (EA) is directed towards the extraction of management rules for estimation and decision in software projects. The key elements of their approach are: I . the construction of a dynamic model of the software development process 2. the simulation of the model with different ranges in the parameters for obtaining a database 3 . the application of the evolutionary algorithms to the database generated for obtaining a set of management rules.</p><p>The database contains values obtained by the dynamic simulation of the software process model. The database can be as big as the manager wants, only bearing in mind that the simulation for every combination of ranges of parameters takes time and that the performance of the EA depends on the accuracy of the rules founded.</p><p>The representation (coding) of the search space is a set of individuals, each one taking the form [ I , , U , . . . . &gt;I,, I,, cl where I,, U ? are the values representing an interval for the attribute i and c is the class to which the tuple belongs for the classification. The algorithm is a sequential covering EA, and the fitness function tries to discriminate between correct and incorrect classifications of the examples. This is carried out by maximising the function</p><formula xml:id="formula_4">f ( i ) = 2 ( N ) -CE(i) + G(i) + coverage(i)</formula><p>where N is the number of examples being processed, CE(i) is the number of examples belonging to the rule whose class is different to that of the rule, G(i) is the number of examples correctly classified by the rule and the coverage is the proportion of the search space covered by the rule.</p><p>The application of this EA to a numerical database classifies the data into a series of management rules. The benefit of this approach is that the task of finding the good decision rules within the database generated is left to the EA. Aguilar er a/. <ref type="bibr" target="#b33">[39]</ref> report that the EA performs better than the classical decision tree-based algorithms, like C4.5.</p><p>Kirsopp et al. [ I I ] use case based reasoning to estimate unknown project attributes, based upon partial information about the project. The approach is to locate similar projects (based upon the known data for the new project) and to use the data from these similar previous projects to estimate the unknown attributes of the new project. Kirsopp and Shepperd have many project attributes, some of which are better predictors than others.</p><p>Determining the best set of attributes to use as the basis for a prediction is a feature of the subset selection problem, to which search-based approaches present reasonable This section considers several aspects of software engineering for which metaheuristics have not been applied but which, it will be shown, are promising candidates for the application of these techniques.</p><p>An important precursor to the application of metaheuristic algorithms to software engineering is the ability to characterise software engineering problems as search problems. The notable successes with test data generation are partly due to the fact that this problem has a large, natural search component and an easily definable fitness function. Such characteristics are not so readily identifiable in other areas of software engineering.</p><p>This section considers other problem areas in software engineering, arguing that it is possible to view these problems as search problems, in such a way that metaheuristic search techniques can he applied. To do so, it will he shown that there are natural definitions of the 'key ingredients' of metaheuristic search techniques identified in Section 2.</p><p>The rest of this section considers three areas of software engineering: requirements, systems integration and software maintenance and evolution. It will show how each can be formulated as a search problem, defining appropriate fitness functions, mutation operations and representations for individuals and, where applicable, defining near neighbours and crossover operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Requirements phasing</head><p>The necd to phasc or schedule requirements typically occurs in projects which have a relatively short development time and a high level of user involvement, and often operate in a dynamic environment. However, the process is more widespread than this and occurs whenever there is a need for rapid and iterative product development.</p><p>Essentially the development of a system consists of an iterative cycle of 'negotiate a bit, build a hit'. This negotiation takes the form of selecting from a set of potential requirements, which are then implemented prior to the system being reviewed by the customers. A requirement is typically an aspect of system functionality and so this set is not going to he trivially small. The problem of interest is how to select the set of requirements that is going to constitute the next iteration of the system. This is not too problematic in those cases where there is a single customer. However, when there are a number of customers with differing needs it is important that all views are taken into account when this choice is made. It may well he impossible for all customers to he represented at a meeting and it is important that the system does not only reflect the views of those customers who happen to he the most vocal.</p><p>This was recognised by Boehm and his co-workers some time ago and is the motivation behind the development of the spiral model into the WinWin spiral model <ref type="bibr" target="#b35">[41]</ref>. The I70 original spiral model incorporated a phase which required the project manager to establish the objectives, constraints and alternatives for the next level of development. Determining the origin of these objectives, constraints and alternatives was found to he difficult and so three additional activities were added on to the front of the spiral model to give the WinWin spiral model. These three activities involved: identifying the system's key stakeholders (developers, customers, users etc.), identifying the stakeholders' win conditions (basically a desired outcome), and negotiating win-win (mutually agreeable) reconciliations of these win conditions. The negotiation process is supported by the WinWin groupware tool which visualises links between stakeholders' win conditions, issues, options and negotiatcd agreements, enables negotiations, and records changes, hut does not attempt to resolve any of the issues automatically.</p><p>Karlsson and Ryan <ref type="bibr" target="#b36">[42]</ref> use the Analytic Hierarchy Process to determine cost-benefit tradeoffs for a set of requirements. The relative value of requirements is determined by customers and users, and the relative cost is determined by the developers. These results are then combined and the system stakeholders use the resulting cost-value diagram as a vehicle For determining which requirements will he implemented. The selection of a subset of requirements from a number of alternatives can of course be viewed as a classic. Multi Criteria Decision Making problem, and one approach is to attempt to resolve the problem using the well-established techniques from this discipline (see <ref type="bibr" target="#b37">[43]</ref>, for example).</p><p>To see how metaheuristic approaches can address this problem, consider first of all the relatively straightforward case which ignores the criteria such as cost, functionality, and development time, that different customers might wish to see optimised in different ways (this more complicated case will be dealt with later), and assume that a customer's view is amalgamated into a single opinion. Assume also that all requirements are independent. At each iteration o f the system build there is: a set of requirements, R, which have yet to he implemented: R = IT,, . . . . r!,) a development cost associated with each requirement a resource (a limit on how much the customers wish to spend) 0 a set of customers who might have different opinions of what is required in the next phase of the system.</p><p>A choice has to be made of which set of requirements is going to be incorporated into the next phase of development. Each customer obviously wishes to select the set which is of greatest value to them. The problem is how to select the set of requirements that is going to he acceptable to as many customers as possible.</p><p>A customer's opinion is expressed as a priority or weighting, p x , associated with each requirement. Suppose there are k customers and n potential requirements. A customer-priority matrix, CP can be defined, such that p i t CP represents the priority associated with customer i for requirement j (1 5 i 4 k, 1 5 j 5 n). The values used for each p &lt; will depend upon the nature of the application. If all users are equal, then each could simply rank the requirements, with the most desirable being ranked n, through to the least desirable ranked I . Alternatively, the users could each be allocated a number of 'votes', with multiple votes per requirement permitted. This would allow users to record thc relative magnitude of their desire to see a certain requirement implemented. It would also allow the developer to allocate a grcater numbcr of 'votes' to users considered more important.</p><p>Using eithcr of these strategies it becomes possible to 'score' a choice of requirements according to overall user preferences. The association of an absolute value (using a voting mechanism or sonic method of quantifying this value in terms of business benefit) will be preferable as these can meaningfully be summed to give the total value of a requirement. Using such an 'absolute value' system, the value of the j t h requirement is defined as i ,=I P, = CP; Using a ranking system, the values associated with each requirement merely place the elements on an ordinal scale: making many forms of value combination meaningless according to measurement theory <ref type="bibr" target="#b38">[44]</ref>. For ranked priority values a more complex way of combining individual user priorities will have to be found.</p><p>Having scored the requirements in sonie way, the problem is now to find the optimal set of requirements to build. However, this problem is an instance of the 0-1 knapsack problem <ref type="bibr">[45]</ref>, which is known to be NP-hard [46]. This makcs the implied search problem appropriate for a nietaheuristic-based algorithm. An individual solution to the problem can be represented by a bit vector, where each bit denotes the presence or absence of a requirement. Mutation can be represented by bit twiddling, crossover by simple selection of a crossovcr point, and neighbour proximity can be represented by Hamming distance. This encoding would allow all the forms of metaheuristic search to be applied to the problem of choosing a set of requirements.</p><p>Once a solution is found an additional problem arises-how to explain this to the customer. The interpretation of solutions is nearly always a problem when applying inetaheuristic techniques, but the importance varies according to the problem domain. For cxample, in the area of test data generation discussed earlier, a customer (in this case, a person using the system to generatc test data) is probably going to be content with the fact that data have been automatically generated to cover some percentage of program paths. They are unlikely to want to know wlg~ a particular value was generated just pleased that the system has done some of their work for them. The attitude of the customer is likely to be different in the case of requirenients phasing. They will probably want to know why a certain set was chosen and what happened to the requirements that they ranked highly. This matter is important, particularly while the customer lacks confidence in the system. One approach i s to save more of the solutions and provide the customer with a list of the alternative solution combinations that just missed being selected. Another is to try and explain the thinking behind the fitness function. Whatever approach is taken it .is important that all customers feel they have a chance to question and enhance the system for everyone's mutual benefit.</p><p>Unfortunately, the assumption that requirements are independent and that customer preferences can be expressed as a simple opinion is unrealistic. There will be dependencies between requirements that will impact upon the dccision of which sct of requirements to select. Requirements which depend upon othcrs which are not already in the system are going to incur a greater cost. It is</p><formula xml:id="formula_5">IEE Pm~.-Soflw &amp;I. ISD, No. 3, June 2001</formula><p>also unrealistic to assume that cost and rcquircment functionality are the only important factors. Customers are likely to be concerned about other constraints such as development time, and the developers themselves might have a strong desire to build the system in a way that smoothes not release dates. So associated with each requirement will be not one attribute, but a vector of attributes representing the cost, development time, associated dependencies, etc.</p><p>If the primary focus of each customer is still on the functionality then these additional attributes pose no real problem except as constraints that have to be included within the fitness function (in much the same way as cost is a constraint in the simple case). A difficulty arises when different groups of customers decide priorities according to different criteria. For example, one set of custoniers might prioritise requiremcnts on the basis of functionality, another group might focus on developnient time on the basis that they want some sort of system as soon as possible, whilst a third group might want the cheapest working system imaginable and hence prioritise according to cost. This forms a classic Multi-Criteria Decision Making problem. One approach is to try and adapt the fitness function to accommodate this, but the danger is that in trying to find a solution the main focus of each of the distinct.customer groups becomes lost. Another approach is to tackle it in two phases, firstly by considering each group independently and extracting a .subset of requirements which meets their criteria using fitness functions which reflect the priorities, and then combining these three subsets in a second phase of the algorithm which uses a more balanced fitness function (or one which reflects the relative group sizes).</p><p>These additional constraints also change the nature of the problem: it is no longer a matter of selecting from an ordered list of requirements. The choice of which requirement to incorporate has to take the vector of costs, times, dependencies etc. into account. Constraints on requirements make it possible to gcnerate 'invalid individuals-those for which the set of requirements denotcd is not closed under the dependence relation, for example. When this happens, there are two possible strategies available:</p><p>1. 'Repair' the individual <ref type="bibr" target="#b39">[47]</ref>-that is, include in the requirement set I' the transitively dependent requirements of those in r. This has the advantage that it reduces the size of the search space to only those individuals that represent valid solutions (those containing all relevant dependent requirements). However, it may bias the search towards inclusion of requirement upon which many others depend. 2. 'Punish' the individual with a very low fitness scorethat is, for individuals which do not contain dependent requirements, reduce the fitness score to make these less likely to be selected. This has the disadvantage that the search space is larger than that for a 'repair-based'solution, but does not have the potential bias that repair might introduce.</p><p>Of course, it will also be possible to generate individuals which require a cost greater than that allowed by the customer. Thesc can be allocated a very low fitness score, making it unlikely (though not impossible) for them to be selected. The coefficient used to determine the unfitness level for cost-breaking solutions can be adjusted to take account of the 'softness' of the cost ceiling. This would allow for solutions to be selected which were near the cost boundary and noticeably more attractive in terms of customer requirement. This flexibility of the metaheuristic search approach is one of the benefits of the methods which the authors believe makes it ideally suited to many software engineering problems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Systems integration</head><p>Systems integration consists of taking individual components and combining them, usually in an incremental fashion, to eventually create the entire system. The importance of adopting an incremental approach, and the probability that not all components are going to he available at the same time, means that many stubs and drivers (dummy components plugged in place of the real component to simulate the interaction) have to he written. The testing that takes place at this stage is important as it is often the first opportunity to determine if two (or more) components interact correctly with each other. Any component which fails at this stage is likely to be sent hack to the developers for re-work. This re-work introduces two problems-firstly a delay in the systems integration process (the more important the component, the greater the delay), and secondly the need to re-test when the corrected component is re-integrated. All this leads, in turn, to the systems integration process becoming very chaotic, when ideally it ought to operate like a well-organised assembly plant.</p><p>Viewing the integration problem as a search problem provides an opportunity to achieve this assembly plant type of process. Each component in a system may make use of, and/or be used by, some other component. If a heavily used component is integrated late in the process (having been stubbed prior to its introduction) and then reveals several faults in the components with which it interacts, these interacting components may have to he re-worked, and then re-integrated, resulting in significant time delays and much repeated testing. On the other hand, if a component which uses many other components is integrated early, then the components it uses will have to be replaced by stubs. This can he wasteful in terms of resources and causes problems as interaction faults are only visible when the real components are introduced.</p><p>This leads to the situation where, ideally, the heavily used components are integrated first and the heavily dependent components are integrated last. Obviously some components are both used and dependent and so a cost is associated with each use or dependency. This cost, along with information about which components have been integrated so far, can then he used to determine the ideal order of integration. This in turn can he fed back to the developers to enable the production of components in the order which is most likely to lead to the cheapest (least overall time due to fewest re-works, minimal stubbing, etc.) system integration.</p><p>An order of integration of the components can he represented by a permutation of the set of components. Since the individual is a permutation, it is not sensible for crossover to proceed by simply taking parts of two individuals and conjoining them: the result of this is unlikely to be a valid individual. Instead, it is necessary to apply a crossover technique such as order crossover or cycle crossover. These are guaranteed to return a valid permutation. Under order crossover, a random cut point is chosen and the left substring of the first individual is kept. The individual is completed by taking the elements left out in the order they occurred in the second parent. In contrast, cycle crossover merges the two permutations (see, for example, <ref type="bibr" target="#b40">[48]</ref> for more details).</p><p>The mutation operators available to this representation of the systems integration problem are essentially the swap and s h u f f l e operators: swap-interchanges two genes shuffle-produces a gene permutation.</p><p>For the application to integration ordering the effect of a swap has a relatively low impact upon the overall fitness. This is because the cost function depends upon whether one activity comes before or after another and swap only changes two such values. For a large sequence of components to be integrated this will have a smaller effect than a similar swap on a transformation sequence. As will he seen in the following section, transformation sequences are more akin to simple programs from a 'linear programming language', where a single change to a 'programming language statement' can have a dramatic effect on the meaning of the overall 'program'.</p><p>For the systems integration question, there is also a clear notion of a neighbourhood. That is, two permutationsp and p' are neighbours if and only if p can be obtained from p' by swapping two adjacent event genes. The problem now is to find an appropriate objective function to drive the optimisation process. Naturally, given an order for the events, this objective function should just provide the estimated cost associated with this order. This may be determined by, for each ordered pair ( c l , c2) of components, determining the costs associated with integrating cI before c2. The total cost, of an order of integration, may then be determined.</p><p>As has been demonstrated, it is possible to define all the key ingredients for metaheuristic algorithms for the application to systems integration problems. It is therefore possible to claim that all three metaheuristic techniques considered in this paper can he applied to this software engineering problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Maintenance and re-engineering using program transformation</head><p>Program transformation has a long history dating hack to the work of Darlington and Burstall on pure functional languages <ref type="bibr" target="#b41">[49]</ref>. Using program transformation, a sequence of simple transformation steps is applied to a program to translate it from one form into another. All approaches to transformation share the common principle that they alter the program's syntax without affecting its semantics.</p><p>Transformation is familiar from its use in compiler technology, where, for some time, it has been used to support optimisation [SO]. However, transformation is also applied at higher levels of abstraction, where the goal is to restructure the program in some way <ref type="bibr">[51]</ref>, to partially evaluate it [52, 531, or to support activities typically associated with the later phases of the software development life cycle, such as maintenance <ref type="bibr" target="#b46">[54]</ref><ref type="bibr" target="#b47">[55]</ref><ref type="bibr" target="#b48">[56]</ref> and re-engineering [57, 581. There are many systems which support transformation for these activities, such as FermaT <ref type="bibr" target="#b51">[59]</ref> and KIDS <ref type="bibr" target="#b52">[60]</ref>.</p><p>For these problems the number of transformation steps may be very large (the maintainers' assistant [S6] for example, supports several hundred transformations). At each step many of these will be applicable to the program under transformation. Effective program transformation strategies are hard to define [61], because the space of solutions is exponentially large in the number of basic transformation steps and the typical transformation sequence length.</p><p>Transformation for these applications can thus he viewed as a search problem in the space of admissible transformation sequences, to which genetic algorithms, simulated annealing and tabu search can be applied. Such techniques have been shown to be effective for the specific transformation-based problem of automatic parallelisation <ref type="bibr" target="#b54">[62]</ref><ref type="bibr">[63]</ref><ref type="bibr" target="#b56">[64]</ref><ref type="bibr" target="#b57">[65]</ref>, so there is reason to hope that they will be applicable to more general software engineering problems.</p><p>Fitness functions on programs are nothing more than code-level software metrics [44, 661. A metaheuristic approach to program transformation therefore provides a mechanism to combine program transformation rules with software metrics. The metric is used to guide the search, while the possible solutions that can be found are bounded by the set of transformations chosen.</p><p>The existing work on transformation using evolutionary techniques has focused upon automated parallelisation. Three approaches have been considered. The rest of this section considers each of these and how it might be built upon to allow evolutionary techniques to be applied to software maintenance and re-engineering through transformation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">Program as individual:</head><p>local search approach: With the program to he transformed as the individual, the search space consists of all semantically equivalent programs which can be reached by a sequence of transformation steps from the original. The representation of the program itself (as an Abstract Syntax Tree or Control Flow Graph) is unimportant, so long as the transformation steps can be applied to the program to yield a new individual.</p><p>In the 'program as individual' representation, the mutation operators are the transformation steps. This approach is adopted by Williams <ref type="bibr" target="#b59">[67]</ref>. He compares the approach to one which uses the transformation sequence as an individual (described in Section 4.3.3) and reports that the 'program as individual' approach yields superior results.</p><p>This approach is essentially a local search using hillclimbing; as the program is mutated (using transformation) and better programs are retained. Williams' success with the approach indicates that the landscape for program transformation (at least in the case of auto-parallelisation) may be smooth enough for hill-climbing to produce reasonable results.</p><p>It is not clear whether these superior results reflected the type of program Williams was considering, nor whether they were achieved because the domain under consideration was auto-parallelisation, rather than more general reengineering transformation. More work will be required to see if these results are replicated when evolutionary transformation is applied to re-engineering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2">Program as individual: traditional genetic programming approach:</head><p>Using 'program as iudividual' it is hard to define crossover, because two programs p , and p z with identical behaviour would have to be combined to produce a program p' with identical behaviour to each of p , and p 2 . Such a combination is far from obvious in most cases. However, there is hope that advances in 'genetic programming [SI may be of assistance here.</p><p>Ryan <ref type="bibr" target="#b54">[62]</ref> describes an approach, called Pargen I, for auto-parallelisation, in which the individual is a program to be transformed, represented as an Abstract Syntax Tree, to which genetic programming mutation and crossover operators are applied. This approach can inherently lead to a program which is not faithful to the semantics of the original. In the language of program transformation, this would result in a nonmeaning preserving transformation.</p><p>In an attempt to overcome this possibility, Ryan uses a set of test cases which he incorporates into the fitness function. The evolutionary algorithm therefore has a multiobjective fitness function. The fitness function rewards solutions for both correctness (according to the test cases) and efficiency. Of course; the problem here is that the algorithm may render programs which are fast but incorrect. Worse, even where the algorithm yields answers which (according to the fitness function) are 'correct' they are only correct with respect to the test cases and so correctness is no longer guaranteed. For re-engineering applications, correctness is vital, and so the Pargen 1 approach is unlikely to form a good basis for further development.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.3">Transformation sequence as individual:</head><p>genetic algorithm approach: Taking a step up from the program as the individual, the sequence of transformations applied to the program could be considered to be the individual. In this approach, the fitness function involves applying the sequence of transformations to the original program to produce a transformed programp' to which the metric to he optimised is applied. This approach is adopted by Ryan for auto-parallelisation using the Pargen I1 system.</p><p>For more general re-engineering transformation, using this approach, a number of mutation operations are possible: replacement, shift leftlright, rotate lef t/right and swap are four obvious choices: replacement: This operator takes a sequence of transformations and replaces one or more transformation steps in the sequence to produce a mutated sequence. shift leftlright: This operator takes a sequence of transformations, removes one transformation step, and shifts the remaining transformation steps to the left or right, adding a new transformation step at the beginning or end of the sequence. rotate leftlright: This operator does not replace any transformation steps, but moves all to the left or right, rotating the lastlfirst transformation step to the firstllast position, respectively. swap: This operator interchanges two transformation steps in a transformation sequence.</p><p>Of these candidates, swap and rotate do not introduce any new transformation steps. In most situations these two mutation operators will therefore be insufficient on their own, as new information will need to be introduced to ensure that there do not exist some areas of the search space which can never he explored. Replacement is likely to be effective in the early stages of a search, where the algorithm will need to be free to consider widely different individuals. The shift and rotate operators will tend to be less disruptive to the effect of the transformation sequence and may be more suited to later stages of the search.</p><p>Using the transformation sequence as the individual makes it possible to define crossover relatively easily. Two sequences of transformations can be combined to change information, using single point, multiple point and uniform crossover. In fit individuals, subsequences of transformations are likely to represent simple transformation tactics, which individually make some progress towards the goal embodied in the fitness function. It would he sensible to choose an approach to crossover which did not unnecessarily disrupt these transformation tacticals and so uniform crossover is unlikely to he successful.</p><p>Changing a single transformation step can radically alter the way in.which a sequence of transformations behaves. This makes it hard to define a suitable concept of near neighbour for this representation. For the 'transformation sequence as individual' approach to the representation problem, it is thus possible to define fitness, mutation and crossover operators hut hard to define the concept of near-neighbour. Such a representation therefore suggests a genetic algorithm as a means of tackling the search problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.4">Transformation program as individual:</head><p>adapted genetic programming approach: An alternative approach, based upon GP, but not upon a test-based fitness function, would be to construct a transformation pmgrum <ref type="bibr" target="#b60">[68]</ref> as the individual and to measure its fitness against a suite of 'training' programs. The fitness would be based upon the improvement an individual transformation program was able to produce across this training suite.</p><p>The standard syntax-tree based operators of genetic programming can be applied to mutate transformation programs and to crossover two transformation programs. The fitness function would reward a transformation program which performed well across the range of programs in the training suite. The primitive operations of the transformation language would be the simple transformation steps, while the constructs of the language would be sequencing, selection and iteration. The transformation language would also have to include predicates over program structures.</p><p>This may allow higher-level program transformation tactics to emerge. It would also he a way of examining both the training suite and the set of transformation primitives available. The behaviours with different training suites would give insights into the similarities the programs in the suite present for transformation. The behaviours with different sets of transformation primitives would yield insight into the effectiveness and applicability of the chosen sets of transformatinns for the particular task in hand.</p><p>The goal here would not be to produce a perfect transformation algorithm for transforming the suite of programs (or programs which resemble members of the suite'). This would he a very quixotic aim. Rather, the aim would he to gain insight into the transformation tactic applicable, the sets of transformations which are useful for a given metric and training suite and the kinds of program which are amenable to a chosen transformation goal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>Metaheuristic algorithms have found wide application in engineering problems. The problems for which these techniques have been most suitable have consisted of situations where complex, competing and inter-related constraints are placed upon the development process and its products. In such a situation, the implicit tradeoffs between criteria form points in a fitness landscape, defined by a cost function which assesses the fitness of a particular configuration of constraints.</p><p>Software engineering provides many examples of situations where competing constraints have to he balanced against one another. It therefore appears to be an attractive and ripe area for the application of metaheuristic search techniques. Such techniques are applicable when good I74 solutions are easy to recognise but hard to generate, because of the competing constraints, the size of the search space and the complexity of the cost function.</p><p>These techniques have already been applied very successfully to the problem of finding test data to achieve test-data adequacy criteria, to module clustering and to cost estimation. This paper has considered several other areas of software engineering for which metaheuristic search will be likely to find successful application. These areas span the range of the software development process, from initial planning and requirements analysis, through to maintenance and the evolution of legacy systems.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>162 2 . 2</head><label>22</label><figDesc>Local search This section overviews three local search metaheuristic techniques: hill-climbing, simulated annealing and tabu search.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>'</head><label></label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3</head><label>3</label><figDesc>Fig. 3 Generic evolutionary algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Fig.<ref type="bibr" target="#b3">4</ref> Frugment ofcode for triangle problem</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>IEE Proc.-Sofi~!. Vol. 150, No. 3, .lune 2003</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>I69solutions [ 40</head><label>40</label><figDesc>]. Interestingly, Kirsopp ef al. [I I ] (like Mancoridis and Mitchell [14, 341 and Harman et al. [9], found that hill-climbing outperformed more elaborate search techniques for this problem. These results, taken together, give rise to optimism that progress can he made in search-based software engineering, using relatively simple search-based techniques. 4 Software engineering as a search problem: pushing the boundaries</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>fune 2003 Generic simulated annealing algorithm</head><label></label><figDesc></figDesc><table><row><cell>generate initial solution</cell></row><row><cell>loop</cell></row><row><cell>Identify neighbourhood set Identify tabu set</cell></row><row><cell>Identify aspirant set Choose the best move</cell></row></table><note><p><p>131 search for optimal solutions by sampling the search space at random and creating a set of candidate solutions called a 'population'. These candidates are combined and mutated to evolve into a new generation of solutions which may or may not be fitter. Recombination is fundamental to the GA and provides a mechanism for mixing genetic material within the population. Mutation is vital in introducing new genetic material, thereby preventing the search from stagnating. The next population of solutions is chosen from the parent and offspring generations in accordance with a survival strategy that normally favours fit individuals but nevertheless does not preclude the survival of the less fit. In this way, a then x : = Y end if end if end loop-Local search exit when the goal is reached or a pre-defined stopping condition is satisfied J:= Cln end loop-Cooling</p>Fig. 1 IEE Pmc.~Sqfw., Yo/. 150. No. 3, exit whengoal issatisfiedorthestoppingcondition is reached end loop Fig. 2 Generic rabu seurch algori~hm Set omeration numhsr. m:=O</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>ind'v dual of ROI. F!P,Oir loop</head><label></label><figDesc>Cnoosn tnn in t a. POPJ at'on of candioate sowt,ons. ROI EvalLate the fitness for eacn</figDesc><table><row><cell>~</cell><cell>~~</cell><cell>_ . ~ ~</cell><cell>.</cell></row><row><cell></cell><cell></cell><cell cols="2">Recombine: R m k R I F l m ) )</cell></row><row><cell></cell><cell></cell><cell cols="2">Mutate: Om):= M(Flm)) Evaluate: F(Ftm)) Select: Rm+ 1) := SWim))</cell></row><row><cell></cell><cell></cell><cell cols="2">m : = m + l exit when goal or stopping condition</cell></row><row><cell>IM</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>is satisfied end loop</head><label></label><figDesc></figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Acknowledgment</head><p>This work is part-funded by EPSRC SEMINAL (Software Engineering using Metaheuristic INovative ALgorithms) network (GR/M78083), http://www.discbrunel.org.uW seminal.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">On using genetic algorithms to scarch program spaces&apos;. Genetic algorithms and their applications</title>
		<author>
			<persName><forename type="first">Jong</forename><surname>De</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2nd hit. Conf. on Genctic algorithms</title>
		<meeting>2nd hit. Conf. on Genctic algorithms<address><addrLine>Cambridge, MA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987-07">July 1987</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="10" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Tahu search: a tutorial</title>
		<author>
			<persName><forename type="first">F</forename><surname>Glover</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">hilerfuces</title>
		<imprint>
			<biblScope unit="page" from="74" to="94" />
			<date type="published" when="1990">1990, 20</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Genetic algorithms in search</title>
		<author>
			<persName><forename type="middle">D E</forename><surname>Goldberf</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>optimization &amp;k</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Adaption in natural and anificial svstems&apos; 1MIT</title>
		<author>
			<persName><forename type="middle">J H</forename><surname>Holland</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Genetic programming: on the programming of computers machinc learning</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Koza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Reading</forename><surname>Addison-Wesley</surname></persName>
		</author>
		<author>
			<persName><surname>Ma</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989">1989. 1992</date>
			<publisher>M m Press</publisher>
			<pubPlace>Caibridge. MA</pubPlace>
		</imprint>
	</monogr>
	<note>Press. Ann Arhur, 1975) by means of natural s&amp;c6on</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m">Modcm hrunstic techniques for combinatod problems&apos; (Blackwell Scientific Prcss</title>
		<editor>
			<persName><forename type="first">C</forename><forename type="middle">R</forename><surname>Reeves</surname></persName>
		</editor>
		<meeting><address><addrLine>Oxford UK</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Simulated annealing: theory and practice</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J M</forename><surname>Van Larrhoven</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aarts</forename></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">H L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Durdrecht. The Nefherlandc</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">71</biblScope>
			<publisher>Kluwer Acadcmic Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Gcnetic algorithms in engineering and computer scicnce</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">.</forename><surname>Winter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pcriaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Galan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Cuesta</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Wiley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A ncw rcpresmtalion and c~ossovcr opemtor for yh:bssed optimization of software modularization</title>
		<author>
			<persName><forename type="middle">M</forename><surname>Iiarman</surname></persName>
		</author>
		<author>
			<persName><forename type="middle">R</forename><surname>Hierons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Proctor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc:font. on enetic and evolutionary computation</title>
		<imprint>
			<biblScope unit="page" from="1351" to="1358" />
			<date type="published" when="2002-07">July 2002</date>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Using heuristic search techniques to extract dcsign abstractions from source code</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">S</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mancoridis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Coni on Genetic and evolutionary computation</title>
		<imprint>
			<biblScope unit="page" from="1375" to="1382" />
			<date type="published" when="2002-07">July 2002</date>
			<publisher>GECCO)</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Scarch heuristics, casebased reasoning and software projcct cffoif prediction</title>
		<author>
			<persName><forename type="first">C</forename><surname>Kirsopp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hart</forename><forename type="middle">M J</forename><surname>Shepperd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Cont on Genetic and cvolutionary computation (GECCO)</title>
		<meeting>Cont on Genetic and cvolutionary computation (GECCO)<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-07">July 2002</date>
			<biblScope unit="page" from="1367" to="1374" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Equation of state calculations by fast co,!nputing machines</title>
		<author>
			<persName><forename type="first">Metropolis</forename><forename type="middle">N</forename><surname>Rosenbluth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">.</forename><surname>Rosenbluth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Teller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Teller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J Chmt. Phvs</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="1087" to="1092" />
			<date type="published" when="1953">1953</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Evolutionary algorithms in theory and practice</title>
		<author>
			<persName><forename type="first">T</forename><surname>Back</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Oxford University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">A heuristic search approach to solving thc software cluatcringproblem</title>
		<author>
			<persName><forename type="first">Mitchell</forename><forename type="middle">B S</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2002-01">Jan 2002</date>
			<pubPlace>Philadelphia, PA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Drenel Univenity</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD Thesis</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">2001, I , , genetic algorithms tu butumstc branch and Faht-bascd tcsting&apos;. C o m p u ~ 18 PARGAS</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">.</forename><surname>Wegener</surname></persName>
		</author>
		<author>
			<persName><forename type="middle">A</forename><surname>Baresel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Sthamer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Harrold</forename><forename type="middle">M J</forename><surname>Peck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">I S@w: l k t . I &amp; -&lt; Relinh</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="263" to="282" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
	<note>In$ S u f i . Tmhnol.</note>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Automated prognm flaw J , 1 9 ~a</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">.</forename><surname>Tracey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mander</forename></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename></persName>
		</author>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="98" to="107" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Systematic testing of real-time systems</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">F</forename><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">th Int. Conf. on Soflume testing analysis and review (EuioSTAR)</title>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Testing real-time systems using genetic algorithms&apos;. SOJ?</title>
		<author>
			<persName><forename type="first">Z I</forename><surname>Wegener</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">.</forename><surname>Sthamer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">B F</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Eykes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Quo/.. (DCIA)</title>
		<imprint>
			<publisher>Yol. I S U . MO. 3</publisher>
			<date>January (998. June 2Ull3</date>
			<biblScope unit="page" from="169" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Software architecture: perspectives an an emerging discipline</title>
		<author>
			<persName><forename type="first">M</forename><surname>Shaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Garlan</forename></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A reverse engineering approach to subsystem stmchm identification</title>
		<author>
			<persName><forename type="first">H</forename><surname>Muller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Okgun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tilley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Uhl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J S q t h Main,. RES. Proct</title>
		<imprint>
			<biblScope unit="page" from="181" to="204" />
			<date type="published" when="1993">1 9 9 3 . 5</date>
		</imprint>
	</monogr>
	<note>~~</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">An intelligent tool for re-engineering software modularity</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">W</forename><surname>Schwanke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Prof. 13th Int. Conf. on Software engineering</title>
		<imprint>
			<date type="published" when="1991-05">May 1991</date>
			<biblScope unit="page" from="83" to="92" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A comparison of graphs o f concept for reverse engineering</title>
		<author>
			<persName><forename type="first">N</forename><surname>Anquetil</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Workshop on Program comprehension</title>
		<meeting>Int. Workshop on Program comprehension</meeting>
		<imprint>
			<date>June lnnn</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">System stmcNre analysis: clustering with databindings</title>
		<author>
			<persName><forename type="first">D</forename><surname>Hutchens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Basil</forename><forename type="middle">]</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Tmns. Sofl~! Eng</title>
		<imprint>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="749" to="757" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Assessing modular s ~N c N ~~ o f legacy code based on mathematical concept analysis</title>
		<author>
			<persName><forename type="first">C</forename><surname>Lindig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Snelting</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Inc. Conf. on Software engineering</title>
		<meeting>Inc. Conf. on Software engineering</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="349" to="359" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Identi$ing objects using cluster and concept analysis</title>
		<author>
			<persName><forename type="first">A</forename><surname>Van Deursen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kuipeks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Tcchnical Report SEN-R</title>
		<imprint>
			<biblScope unit="volume">9814</biblScope>
			<date type="published" when="1998-09">Sept.1998</date>
			<publisher>Centrum voor Wiskunde en Informatica (CWI). Tech</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Kecovcring software architecture from the names of source files</title>
		<author>
			<persName><forename type="first">N</forename><surname>Anquetil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lethbkidge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Working Conf. on Revens engineering</title>
		<meeting>Working Conf. on Revens engineering</meeting>
		<imprint>
			<date>Oct. I999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Evolving good hierarchial decompositions of complex systcms</title>
		<author>
			<persName><forename type="first">K</forename><surname>Lutz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J Syr. Archil</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="page" from="613" to="634" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Using automatic clustcring to producc high-level systcm organizations of source code</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mancoridis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="middle">C</forename><surname>Rokres</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gansner</forename></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 6th Int</title>
		<meeting>6th Int</meeting>
		<imprint>
			<date type="published" when="1998-06">June 1998</date>
			<biblScope unit="page">comprehension</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Autumatic clustering of software systems using a genetic algorithms</title>
		<author>
			<persName><forename type="middle">D</forename><surname>Doval</surname></persName>
		</author>
		<author>
			<persName><forename type="middle">S</forename><surname>Mancokidis</surname></persName>
		</author>
		<author>
			<persName><surname>Mitchell. 6</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Conf. on Software took and engineering practice (STEP)</title>
		<meeting><address><addrLine>Pittsburgh, PA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999-02">30 August-2 Srptcmber 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A mathcmatical theory ofcommunication</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Shannon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BellSjsr. Tech. 1</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="379" to="423" />
			<date type="published" when="1948-07">1948. July, October, 6 2 3 4 5 6</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">A validation of the component-based method for software size estimation</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Dolado</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. So/h. Eng</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">On the problem of the software cost function</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Dolado</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001, 43</date>
			<biblScope unit="page" from="61" to="72" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Can genetic programming improve soitwarc effort estimation&apos;! A comparative evaluation</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Burgess</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lefley</forename></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf SoJiw Tech</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">14</biblScope>
			<biblScope unit="page" from="863" to="873" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">An cvolutionary approach to estimating software development projects</title>
		<author>
			<persName><forename type="first">J</forename><surname>Aguilar-Ruiz</surname></persName>
		</author>
		<author>
			<persName><forename type="middle">I</forename><surname>Ramos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Kiquelme</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Toro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">hf Sofiw Technol</title>
		<imprint>
			<biblScope unit="issue">14</biblScope>
			<biblScope unit="page" from="875" to="882" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Messy genetic algorithms for subset feaNre selection</title>
		<author>
			<persName><forename type="first">D</forename><surname>Whitley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Beveridge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Guekra-Salcedo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Graves</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th Int. Conf. on Genetic algorithms</title>
		<meeting>7th Int. Conf. on Genetic algorithms<address><addrLine>San Francisco</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-07-23">19-23 July 1997</date>
			<biblScope unit="page" from="568" to="575" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Using the winwin spiral model: a case study</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">.</forename><surname>Boehm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Egyed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kwan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Port</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Madachy</forename><forename type="middle">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Compufer</title>
		<imprint>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="3" to="3" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">A cost-value approach for prioritizing requirements</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kaklsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ryan</forename></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE SsJw</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="67" to="74" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Multiple c&quot;te&quot;a decision analysis: an integrated approach</title>
		<author>
			<persName><forename type="first">V</forename><surname>Belton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stewart</forename><forename type="middle">T J</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>Kluwzr Academic Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">Foundations of software measurement</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Shepperd</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="100" to="1021" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">An introduction to genetic algorithms</title>
		<author>
			<persName><forename type="first">M</forename><surname>Mitchell</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">Iterative computer algorithms with applications in engineering: solving combinatorial optimization problems</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Sait</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Youssef</forename></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>IEEE Computer Society</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">A emsformation system for developing recursive programs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Darlington</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Burstall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J ACM</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="44" to="67" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sethi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<title level="m">Compilers principles, techniques and tools</title>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">The translation ofgot pmgrams into whil programs</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Ashcroft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manna</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pmc. of IFlP Congress</title>
		<editor>
			<persName><forename type="first">C</forename><forename type="middle">Y</forename><surname>Freiman</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Griffith</forename></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Kosenfeld</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">L</forename></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">71</biblScope>
			<biblScope unit="page" from="25S" to="255" />
			<date type="published" when="1972">1972</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title level="m" type="main">Partial evahiation and mined computation</title>
		<author>
			<persName><forename type="first">D</forename><surname>Bjbrnek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Ekshov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">D</forename><surname>Jones</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
			<pubPlace>North-Holland</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Partial evaluaion for soflware engineering</title>
		<author>
			<persName><forename type="first">C</forename><surname>Consel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Hornop</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Marlet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Muller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Thibault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E.-N</forename><surname>Volanschi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Cumpur. Sum</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Automated support for software maintenance</title>
		<author>
			<persName><forename type="first">K</forename><surname>Bennett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J In/.&apos; Sof?. Techno!</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="74" to="85" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">A post-placement side-effect removal algorithm</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hakman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Hierons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Munro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Dolado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Oteko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wegenek</forename></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Int. Conf. on Software maintenance (ICSM)</title>
		<imprint>
			<publisher>Monneal, Canada</publisher>
			<date type="published" when="2002-10">Oct 2002</date>
			<biblScope unit="page" from="2" to="3" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">The maintainer&apos;s assistant</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ward</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">W</forename><surname>Calliss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Munko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. lnt. Conf. on Software maintenance 1989</title>
		<meeting>lnt. Conf. on Software maintenance 1989<address><addrLine>Los Alamitos, Califomia, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page">307</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Bylands: reverse engmernng safety-cntical systems</title>
		<author>
			<persName><forename type="first">K</forename><surname>Bennett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">.</forename><surname>Bull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Younger</surname></persName>
		</author>
		<author>
			<persName><surname>Luo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Int. Conf an Software maintenance</title>
		<meeting><address><addrLine>Los Alamitos, Califomia, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="358" to="366" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">R e ~t m c ~r i n g p r o p &quot; by tucking statements into functions</title>
		<author>
			<persName><forename type="first">A</forename><surname>Lakhotia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-C</forename><surname>Deprez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In/ SoJh. Techno!</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="677" to="689" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Assembler to C migration using the FermaT transformation system</title>
		<author>
			<persName><forename type="middle">M</forename><surname>Ward</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Int. Conf. on Sothvare maintenance (ICSM&apos;99)</title>
		<meeting><address><addrLine>Oxford, UK</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999-08">Aug 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">KIDS: a semiautomatic program development system</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Sofh. Eng</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1024" to="1043" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Do program transformations help reverse engineerign?</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">H</forename><surname>Bennett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Pmc. IEEE Int. Conf. on Soitware maintenance (lCSM&apos;98)</title>
		<meeting><address><addrLine>Bethesda. Maryland, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998-11">Nov. 1998</date>
			<biblScope unit="page" from="247" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<title level="m" type="main">Automatic m-engineering of software using genetic programming</title>
		<author>
			<persName><forename type="first">C</forename><surname>Ryan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Kluwer Academic Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">The evolution of provable parallel programs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Ryan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Walsh</forename></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2nd Ann. Cunf. on Genetic programming</title>
		<meeting>2nd Ann. Cunf. on Genetic programming<address><addrLine>Stanford University, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-07">July 1997</date>
			<biblScope unit="page" from="295" to="302" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<monogr>
		<title level="m" type="main">Genetic compilers: a new technique for automatic parallclisation&apos; 2nd European School of Parallel programming envimnmcnts (ESPPE96), UAlpe d&apos;Huez</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">P</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Williams</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="27" to="30" />
			<pubPlace>France</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<monogr>
		<title level="m" type="main">Experience o f developing codes for distributed for parallel architectures&apos;. PPECC Workshop: &apos;Dishibuted Y parallel: convergence or divergence?</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Fagg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995-03">Mar 1995</date>
			<biblScope unit="page" from="115" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<monogr>
		<title level="m" type="main">Software metrics: a rieorous aooroach</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">N E . .</forename><surname>Fenton</surname></persName>
		</author>
		<author>
			<persName><surname>Hall</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<monogr>
		<title level="m" type="main">Evolutionary algorithms for automatic parallelization</title>
		<author>
			<persName><forename type="first">K</forename><surname>Williams</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998-09">September 1998</date>
			<pubPlace>UK</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, Universily of Reading</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD Thesis</note>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Program developments: formal explanations of implementations</title>
		<author>
			<persName><forename type="first">D</forename><surname>Wile</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="page" from="902" to="991" />
			<date type="published" when="1983">1983, 26</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
