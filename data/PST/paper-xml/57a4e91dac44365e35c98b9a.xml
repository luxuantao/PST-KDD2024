<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Measuring Neural Net Robustness with Constraints</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2017-06-16">16 Jun 2017</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Osbert</forename><surname>Bastani</surname></persName>
							<email>obastani@cs.stanford.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Yani</forename><surname>Ioannou</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">University of Cambridge</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Leonidas</forename><surname>Lampropoulos</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Dimitrios</forename><surname>Vytiniotis</surname></persName>
							<email>dimitris@microsoft.com</email>
							<affiliation key="aff3">
								<orgName type="institution">Microsoft Research</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Aditya</forename><forename type="middle">V</forename><surname>Nori</surname></persName>
							<email>adityan@microsoft.com</email>
							<affiliation key="aff4">
								<orgName type="institution">Microsoft Research</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Antonio</forename><surname>Criminisi</surname></persName>
							<affiliation key="aff5">
								<orgName type="institution">Microsoft Research</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Measuring Neural Net Robustness with Constraints</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2017-06-16">16 Jun 2017</date>
						</imprint>
					</monogr>
					<idno type="arXiv">arXiv:1605.07262v2[cs.LG]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T12:37+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Despite having high accuracy, neural nets have been shown to be susceptible to adversarial examples, where a small perturbation to an input can cause it to become mislabeled. We propose metrics for measuring the robustness of a neural net and devise a novel algorithm for approximating these metrics based on an encoding of robustness as a linear program. We show how our metrics can be used to evaluate the robustness of deep neural nets with experiments on the MNIST and CIFAR-10 datasets. Our algorithm generates more informative estimates of robustness metrics compared to estimates based on existing algorithms. Furthermore, we show how existing approaches to improving robustness "overfit" to adversarial examples generated using a specific algorithm. Finally, we show that our techniques can be used to additionally improve neural net robustness both according to the metrics that we propose, but also according to previously proposed metrics.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Recent work <ref type="bibr" target="#b20">[21]</ref> shows that it is often possible to construct an input mislabeled by a neural net by perturbing a correctly labeled input by a tiny amount in a carefully chosen direction. Lack of robustness can be problematic in a variety of settings, such as changing camera lens or lighting conditions, successive frames in a video, or adversarial attacks in security-critical applications <ref type="bibr" target="#b17">[18]</ref>.</p><p>A number of approaches have since been proposed to improve robustness <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b19">20]</ref>. However, work in this direction has been handicapped by the lack of objective measures of robustness. A typical approach to improving the robustness of a neural net f is to use an algorithm A to find adversarial examples, augment the training set with these examples, and train a new neural net f <ref type="bibr" target="#b4">[5]</ref>. Robustness is then evaluated by using the same algorithm A to find adversarial examples for f -if A discovers fewer adversarial examples for f than for f , then f is concluded to be more robust than f . However, f may have overfit to adversarial examples generated by A-in particular, a different algorithm A may find as many adversarial examples for f as for f . Having an objective robustness measure is vital not only to reliably compare different algorithms, but also to understand robustness of production neural nets-e.g., when deploying a login system based on face recognition, a security team may need to evaluate the risk of an attack using adversarial examples.</p><p>In this paper, we study the problem of measuring robustness. We propose to use two statistics of the robustness ρ(f, x * ) of f at point x * (i.e., the L ∞ distance from x * to the nearest adversarial example) <ref type="bibr" target="#b20">[21]</ref>. The first one measures the frequency with which adversarial examples occur; the other measures the severity of such adversarial examples. Both statistics depend on a parameter , which intuitively specifies the threshold below which adversarial examples should not exist (i.e., points x with L ∞ distance to x * less than should be assigned the same label as x * ).</p><p>The key challenge is efficiently computing ρ(f, x * ). We give an exact formulation of this problem as an intractable optimization problem. To recover tractability, we approximate this optimization problem by constraining the search to a convex region Z(x * ) around x * . Furthermore, we devise an iterative approach to solving the resulting linear program that produces an order of magnitude speed-up. Common neural nets (specifically, those using rectified linear units as activation functions) are in fact piecewise linear functions <ref type="bibr" target="#b14">[15]</ref>; we choose Z(x * ) to be the region around x * on which f is linear. Since the linear nature of neural nets is often the cause of adversarial examples <ref type="bibr" target="#b4">[5]</ref>, our choice of Z(x * ) focuses the search where adversarial examples are most likely to exist.</p><p>We evaluate our approach on a deep convolutional neural network f for MNIST. We estimate ρ(f, x * ) using both our algorithm A LP and (as a baseline) the algorithm A L-BFGS introduced by <ref type="bibr" target="#b20">[21]</ref>. We show that A LP produces a substantially more accurate estimate of ρ(f, x * ) than A L-BFGS . We then use data augmentation with each algorithm to improve the robustness of f , resulting in fine-tuned neural nets f LP and f L-BFGS . According to A L-BFGS , f L-BFGS is more robust than f , but not according to A LP . In other words, f L-BFGS overfits to adversarial examples computed using A L-BFGS . In contrast, f LP is more robust according to both A L-BFGS and A LP . Furthermore, to demonstrate scalability, we apply our approach to evaluate the robustness of the 23-layer network-in-network (NiN) neural net <ref type="bibr" target="#b12">[13]</ref> for CIFAR-10, and reveal a surprising lack of robustness. We fine-tune NiN and show that robustness improves, albeit only by a small amount. In summary, our contributions are:</p><p>• We formalize the notion of pointwise robustness studied in previous work <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b5">6]</ref> and propose two statistics for measuring robustness based on this notion ( §2). • We show how computing pointwise robustness can be encoded as a constraint system ( §3). We approximate this constraint system with a tractable linear program and devise an optimization for solving this linear program an order of magnitude faster ( §4). • We demonstrate experimentally that our algorithm produces substantially more accurate measures of robustness compared to algorithms based on previous work, and show evidence that neural nets fine-tuned to improve robustness ( §5) can overfit to adversarial examples identified by a specific algorithm ( §6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Related work</head><p>The susceptibility of neural nets to adversarial examples was discovered by <ref type="bibr" target="#b20">[21]</ref>. Given a test point x * with predicted label * , an adversarial example is an input x * + r with predicted label = * where the adversarial perturbation r is small (in L ∞ norm). Then, <ref type="bibr" target="#b20">[21]</ref> devises an approximate algorithm for finding the smallest possible adversarial perturbation r. Their approach is to minimize the combined objective loss(f (x * + r), ) + c r ∞ , which is an instance of box-constrained convex optimization that can be solved using L-BFGS-B. The constant c is optimized using line search.</p><p>Our formalization of the robustness ρ(f, x * ) of f at x * corresponds to the notion in <ref type="bibr" target="#b20">[21]</ref> of finding the minimal r ∞ . We propose an exact algorithm for computing ρ(f, x * ) as well as a tractable approximation. The algorithm in <ref type="bibr" target="#b20">[21]</ref> can also be used to approximate ρ(f, x * ); we show experimentally that our algorithm is substantially more accurate than <ref type="bibr" target="#b20">[21]</ref>.</p><p>There has been a range of subsequent work studying robustness; <ref type="bibr" target="#b16">[17]</ref> devises an algorithm for finding purely synthetic adversarial examples (i.e., no initial image x * ), <ref type="bibr" target="#b21">[22]</ref> searches for adversarial examples using random perturbations, showing that adversarial examples in fact exist in large regions of the pixel space, <ref type="bibr" target="#b18">[19]</ref> shows that even intermediate layers of neural nets are not robust to adversarial noise, and <ref type="bibr" target="#b2">[3]</ref> seeks to explain why neural nets may generalize well despite poor robustness properties.</p><p>Starting with <ref type="bibr" target="#b4">[5]</ref>, a major focus has been on devising faster algorithms for finding adversarial examples. Their idea is that adversarial examples can then be computed on-the-fly and used as training examples, analogous to data augmentation approaches typically used to train neural nets <ref type="bibr" target="#b9">[10]</ref>.</p><p>To find adversarial examples quickly, <ref type="bibr" target="#b4">[5]</ref> chooses the adversarial perturbation r to be in the direction of the signed gradient of loss(f (x * + r), ) with fixed magnitude. Intuitively, given only the gradient of the loss function, this choice of r is most likely to produce an adversarial example with r ∞ ≤ . In this direction, <ref type="bibr" target="#b15">[16]</ref> improves upon <ref type="bibr" target="#b4">[5]</ref> by taking multiple gradient steps, <ref type="bibr" target="#b6">[7]</ref> extends this idea to norms beyond the L ∞ norm, <ref type="bibr" target="#b5">[6]</ref> takes the approach of <ref type="bibr" target="#b20">[21]</ref> but fixes c, and <ref type="bibr" target="#b19">[20]</ref> formalizes <ref type="bibr" target="#b4">[5]</ref> as robust optimization.</p><p>A key shortcoming of these lines of work is that robustness is typically measured using the same algorithm used to find adversarial examples, in which case the resulting neural net may have overfit</p><p>to adversarial examples generating using that algorithm. For example, <ref type="bibr" target="#b4">[5]</ref> shows improved accuracy to adversarial examples generated using their own signed gradient method, but do not consider whether robustness increases for adversarial examples generated using more precise approaches such as <ref type="bibr" target="#b20">[21]</ref>. Similarly, <ref type="bibr" target="#b6">[7]</ref> compares accuracy to adversarial examples generated using both itself and <ref type="bibr" target="#b4">[5]</ref> (but not <ref type="bibr" target="#b20">[21]</ref>), and <ref type="bibr" target="#b19">[20]</ref> only considers accuracy on adversarial examples generated using their own approach on the baseline network. The aim of our paper is to provide metrics for evaluating robustness, and to demonstrate the importance of using such impartial measures to compare robustness.</p><p>Additionally, there has been work on designing neural network architectures <ref type="bibr" target="#b5">[6]</ref> and learning procedures <ref type="bibr" target="#b0">[1]</ref> that improve robustness to adversarial perturbations, though they do not obtain state-of-theart accuracy on the unperturbed test sets. There has also been work using smoothness regularization related to <ref type="bibr" target="#b4">[5]</ref> to train neural nets, focusing on improving accuracy rather than robustness <ref type="bibr" target="#b13">[14]</ref>.</p><p>Robustness has also been studied in more general contexts; <ref type="bibr" target="#b22">[23]</ref> studies the connection between robustness and generalization, <ref type="bibr" target="#b1">[2]</ref> establishes theoretical lower bounds on the robustness of linear and quadratic classifiers, and <ref type="bibr" target="#b3">[4]</ref> seeks to improve robustness by promoting resiliance to deleting features during training. More broadly, robustness has been identified as a desirable property of classifiers beyond prediction accuracy. Traditional metrics such as (out-of-sample) accuracy, precision, and recall help users assess prediction accuracy of trained models; our work aims to develop analogous metrics for assessing robustness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Robustness Metrics</head><p>Consider a classifier f : X → L, where X ⊆ R n is the input space and L = {1, ..., L} are the labels. We assume that training and test points x ∈ X have distribution D. We first formalize the notion of robustness at a point, and then describe two statistics to measure robustness. Our two statistics depend on a parameter , which captures the idea that we only care about robustness below a certain threshold-we disregard adversarial examples x whose L ∞ distance to x * is greater than . We use = 20 in our experiments on MNIST and CIFAR-10 (on the pixel scale 0-255).</p><p>Pointwise robustness. Intuitively, f is robust at x * ∈ X if a "small" perturbation to x * does not affect the assigned label. We are interested in perturbations sufficiently small that they do not affect human classification; an established condition is x − x * ∞ ≤ for some parameter . Formally, we say f is (x * , )-robust if for every</p><formula xml:id="formula_0">x such that x − x * ∞ ≤ , f (x) = f (x * ).</formula><p>Finally, the pointwise robustness ρ(f, x * ) of f at x * is the minimum for which f fails to be (x * , )-robust:</p><formula xml:id="formula_1">ρ(f, x * ) def = inf{ ≥ 0 | f is not (x * , )-robust}.<label>(1)</label></formula><p>This definition formalizes the notion of robustness in <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b20">21]</ref>.</p><p>Adversarial frequency. Given a parameter , the adversarial frequency</p><formula xml:id="formula_2">φ(f, ) def = Pr x * ∼D [ρ(f, x * ) ≤ ]</formula><p>measures how often f fails to be (x * , )-robust. In other words, if f has high adversarial frequency, then it fails to be (x * , )-robust for many inputs x * .</p><p>Adversarial severity. Given a parameter , the adversarial severity</p><formula xml:id="formula_3">µ(f, ) def = E x * ∼D [ρ(f, x * ) | ρ(f, x * ) ≤ ]</formula><p>measures the severity with which f fails to be robust at x * conditioned on f not being (x * , )-robust.</p><p>We condition on pointwise robustness since once f is (x * , )-robust at x * , then the degree to which f is robust at x * does not matter.  accuracy on adversarial examples used to measure robustness in <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b19">20]</ref>. Severity can be used to differentiate between neural nets with similar adversarial frequency.</p><p>Given a set of samples X ⊆ X drawn i.i.d. from D, we can estimate φ(f, ) and µ(f, ) using the following standard estimators, assuming we can compute ρ:</p><formula xml:id="formula_4">φ(f, , X) def = |{x * ∈ X | ρ(f, x * ) ≤ }| |X| μ(f, , X) def = x * ∈X ρ(f, x * )I[ρ(f, x * ) ≤ ] |{x * ∈ X | ρ(f, x * ) ≤ }| .</formula><p>An approximation ρ(f, x * ) ≈ ρ(f, x * ) of ρ, such as the one we describe in Section 4, can be used in place of ρ. In practice, X is taken to be the test set X test .</p><p>3 Computing Pointwise Robustness</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Overview</head><p>Consider the training points in Figure <ref type="figure">1</ref> (a) colored based on the ground truth label. To classify this data, we train a two-layer neural net f (x) = arg max {(W 2 g(W 1 x)) }, where the ReLU function g is applied pointwise. Figure <ref type="figure">1</ref> (a) includes contours of the per-point loss function of this neural net.</p><p>Exhaustively searching the input space to determine the distance ρ(f, x * ) to the nearest adversarial example for input x * (labeled * ) is intractable. Recall that neural nets with rectified-linear (ReLU) units as activations are piecewise linear <ref type="bibr" target="#b14">[15]</ref>. Since adversarial examples exist because of this linearity in the neural net <ref type="bibr" target="#b4">[5]</ref>, we restrict our search to the region Z(x * ) around x * on which the neural net is linear. This region around x * is defined by the activation of the ReLU function:</p><formula xml:id="formula_5">for each i, if (W 1 x * ) i ≥ 0 (resp., (W 1 x * ) ≤ 0), we constrain to the half-space {x | (W 1 x) i ≥ 0} (resp., {x | (W 1 x) i ≤ 0}).</formula><p>The intersection of these half-spaces is convex, so it admits efficient search. Figure <ref type="figure">1</ref> (b) shows one such convex region<ref type="foot" target="#foot_0">1</ref> .</p><p>Additionally, x is labeled exactly when f (x) ≥ f (x) for each = . These constraints are linear since f is linear on Z(x * ). Therefore, we can find the distance to the nearest input with label = * by minimizing x − x * ∞ on Z(x * ). Finally, we can perform this search for each label = * , though for efficiency we take to be the label assigned the second-highest score by f . Figure <ref type="figure">1 (b)</ref> shows the adversarial example found by our algorithm in our running example. In Figure <ref type="figure">1</ref> note that the direction of the nearest adversarial example is not necessary aligned with the signed gradient of the loss function, as observed by others <ref type="bibr" target="#b6">[7]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Formulation as Optimization</head><p>We compute ρ(f, ) by expressing (1) as constraints C, which consist of The feasible set F(C) of C is the set of x ∈ R m that satisfy C; C is satisfiable if F(C) is nonempty.</p><formula xml:id="formula_6">•</formula><p>In the next section, we show that the condition f (x) = can be expressed as constraints C f (x, ); i.e., f (x) = if and only if C f (x, ) is satisfiable. Then, ρ(f, ) can be computed as follows:</p><formula xml:id="formula_7">ρ(f, x * ) = min = * ρ(f, x * , )<label>(2)</label></formula><formula xml:id="formula_8">ρ(f, x * , ) def = inf{ ≥ 0 | C f (x, ) ∧ x − x * ∞ ≤ satisfiable}.<label>(3)</label></formula><p>The optimization problem is typically intractable; we describe a tractable approximation in §4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Encoding a Neural Network</head><p>We show how to encode the constraint f (x) = as constraints C f (x, ) when f is a neural net. We assume f has form f</p><formula xml:id="formula_9">(x) = arg max ∈L f (k) (f (k−1) (...(f (1) (x))...))</formula><p>, where the i th layer of the network is a function f (i) : R ni−1 → R ni , with n 0 = n and n k = |L|. We describe the encoding of fully-connected and ReLU layers; convolutional layers are encoded similarly to fully-connected layers and max-pooling layers are encoded similarly to ReLU layers. We introduce the variables x (0) , . . . , x (k) into our constraints, with the interpretation that x (i) represents the output vector of layer i of the network; i.e., x (i) = f (i) (x (i−1) ). The constraint C in (x) ≡ (x (0) = x) encodes the input layer. For each layer f (i) , we encode the computation of x (i) given x (i−1) as a constraint C i .</p><p>Fully-connected layer. In this case, x (i) = f (i) (x (i−1) ) = W (i) x (i−1) + b (i) , which we encode using the constraints</p><formula xml:id="formula_10">C i ≡ ni j=1 x (i) j = W (i) j x (i−1) + b (i) j</formula><p>, where W (i) j is the j-th row of W (i) .</p><p>ReLU layer. In this case, x</p><formula xml:id="formula_11">(i) j = max {x (i−1) j</formula><p>, 0} (for each 1 ≤ j ≤ n i ), which we encode using the constraints</p><formula xml:id="formula_12">C i ≡ ni j=1 C ij , where C ij = (x (i−1) j &lt;0 ∧ x (i) j =0) ∨ (x (i−1) j ≥ 0 ∧ x (i) j =x (i−1) j ).</formula><p>Finally, the constraints C out ( )</p><formula xml:id="formula_13">≡ = x (k) ≥ x (k) ensure that the output label is . Together, the constraints C f (x, ) ≡ C in (x) ∧ k i=1 C i ∧ C out ( ) encodes the computation of f :</formula><p>Theorem 1 For any x ∈ X and ∈ L, we have f (x) = if and only if C f (x, ) is satisfiable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Approximate Computation of Pointwise Robustness</head><p>Convex restriction. The challenge to solving (3) is the non-convexity of the feasible set of C f (x, ).</p><p>To recover tractability, we approximate (3) by constraining the feasible set to x ∈ Z(x * ), where Z(x * ) ⊆ X is carefully chosen so that the constraints Ĉf (x, ) ≡ C f (x, ) ∧ (x ∈ Z(x * )) have convex feasible set. We call Ĉf (x, ) the convex restriction of C f (x, ). In some sense, convex restriction is the opposite of convex relaxation. Then, we can approximately compute robustness:</p><formula xml:id="formula_14">ρ(f, x * , ) def = inf{ ≥ 0 | Ĉf (x, ) ∧ x − x * ∞ ≤ satisfiable}. (<label>4</label></formula><formula xml:id="formula_15">)</formula><p>The objective is optimized over x ∈ Z(x * ), which approximates the optimum over x ∈ X .</p><p>Choice of Z(x * ). We construct Z(x * ) as the feasible set of constraints D(x * ); i.e., Z(x * ) = F(D(x * )). We now describe how to construct D(x * ).</p><p>Note that F(w T x + b = 0) and F(w T x + b ≥ 0) are convex sets. Furthermore, if F(C 1 ) and F(C 2 ) are convex, then so is their conjunction F(C 1 ∧ C 2 ). However, their disjunction F(C 1 ∨ C 2 ) may not be convex; for example, F((x ≥ 0) ∨ (y ≥ 0)). The potential non-convexity of disjunctions makes (3) difficult to optimize.</p><p>We can eliminate disjunction operations by choosing one of the two disjuncts to hold. For example, note that for otherwise. In our constraints, disjunctions are always mutually exclusive, so x * never simultaneously satisfies both C 2 and C 3 . We then take D(x * ) to be the conjunction of all our choices. The resulting constraints Ĉf (x, ) contains only conjunctions of linear relations, so its feasible set is convex. In fact, it can be expressed as a linear program (LP) and can be solved using any standard LP solver.</p><formula xml:id="formula_16">C 1 ≡ C 2 ∨ C 3 , we have both F(C 2 ) ⊆ F(C 1 ) and F(C 3 ) ⊆ F(C 1</formula><p>For example, consider a rectified linear layer (as before, max pooling layers are similar). The original constraint added for unit j of rectified linear layer f (i) is</p><formula xml:id="formula_17">x (i−1) j ≤ 0 ∧ x (i) j = 0 ∨ x (i−1) j ≥ 0 ∧ x (i) j = x (i−1) j</formula><p>To restrict this constraint, we evaluate the neural network on the seed input x * and look at the input to f (i) , which equals x</p><formula xml:id="formula_18">(i−1) * = f (i−1) (...(f (1) (x * ))...). Then, for each 1 ≤ j ≤ n i : D(x * ) ← D(x * ) ∧ x (i−1) j ≤ 0 ∧ x (i) j = x (i−1) j if (x (i−1) * ) j ≤ 0 x (i−1) j ≥ 0 ∧ x (i) j = 0 if (x (i−1) * ) j &gt; 0.</formula><p>Iterative constraint solving. We implement an optimization for solving LPs by lazily adding constraints as necessary. Given all constraints C, we start off solving the LP with the subset of equality constraints Ĉ ⊆ C, which yields a (possibly infeasible) solution z. If z is feasible, then z is also an optimal solution to the original LP; otherwise, we add to Ĉ the constraints in C that are not satisfied by z and repeat the process. This process always yields the correct solution, since in the worst case Ĉ becomes equal to C. In practice, this optimization is an order of magnitude faster than directly solving the LP with constraints C.</p><p>Single target label. For simplicity, rather than minimize over ρ(f, x * , ) for each = * , we fix to be the second most probable label f (x * ); i.e.,</p><formula xml:id="formula_19">ρ(f, x * ) def = inf{ ≥ 0 | Ĉf (x, f (x * )) ∧ x − x * ∞ ≤ satisfiable}.<label>(5)</label></formula><p>Approximate robustness statistics. We can use ρ in our statistics φ and μ defined in §2. Because ρ is an overapproximation of ρ (i.e., ρ(f, x * ) ≥ ρ(f, x * )), the estimates φ and μ may not be unbiased (in particular, φ(f, ) ≤ φ(f, )). In §6, we show empirically that our algorithm produces substantially less biased estimates than existing algorithms for finding adversarial examples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Improving Neural Net Robustness</head><p>Finding adversarial examples. We can use our algorithm for estimating ρ(f, x * ) to compute adversarial examples. Given x * , the value of x computed by the optimization procedure used to solve (5) is an adversarial example for x * with x − x * ∞ = ρ(f, x * ).</p><p>Finetuning.  Rounding errors. MNIST images are represented as integers, so we must round the perturbation to obtain an image, which oftentimes results in non-adversarial examples. When fine-tuning, we add a constraint x (k) ≥ x (k) + α for all = , which eliminates this problem by ensuring that the neural net has high confidence on its adversarial examples. In our experiments, we fix α = 3.0.</p><p>Similarly, we modified the L-BFGS-B baseline so that during the line search over c, we only count x * + r as adversarial if x (k) ≥ x (k) + α for all = . We choose α = 0.15, since larger α causes the baseline to find significantly fewer adversarial examples, and small α results in smaller improvement in robustness. With this choice, rounding errors occur on 8.3% of the adversarial examples we find on the MNIST training set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Experiments</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Adversarial Images for CIFAR-10 and MNIST</head><p>We find adversarial examples for the neural net LeNet <ref type="bibr" target="#b11">[12]</ref> (modified to use ReLUs instead of sigmoids) trained to classify MNIST <ref type="bibr" target="#b10">[11]</ref>, and for the network-in-network (NiN) neural net <ref type="bibr" target="#b12">[13]</ref> trained to classify CIFAR-10 <ref type="bibr" target="#b8">[9]</ref>. Both neural nets are trained using Caffe <ref type="bibr" target="#b7">[8]</ref>. For MNIST, Figure <ref type="figure">2</ref> (b) shows an adversarial example (labeled 1) we find for the image in Figure <ref type="figure">2</ref> (a) labeled 3, and Figure <ref type="figure">2</ref> (c) shows the corresponding adversarial perturbation scaled so the difference is visible (it has L ∞ norm 17). For CIFAR-10, Figure <ref type="figure">2</ref> (e) shows an adversarial example labeled "truck" for the image in Figure <ref type="figure">2</ref> (d) labeled "automobile", and Figure <ref type="figure">2</ref> (f) shows the corresponding scaled adversarial perturbation (which has L ∞ norm 3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Comparison to Other Algorithms on MNIST</head><p>We compare our algorithm for estimating ρ to the baseline L-BFGS-B algorithm proposed by <ref type="bibr" target="#b20">[21]</ref>. We use the tool provided by <ref type="bibr" target="#b21">[22]</ref> to compute this baseline. For both algorithms, we use adversarial target label = f (x * ). We use LeNet in our comparisons, since we find that it is substantially more robust than the neural nets considered in most previous work (including <ref type="bibr" target="#b20">[21]</ref>). We also use versions of LeNet fine-tuned using both our algorithm and the baseline with T = 1, 2. To focus on the most severe adversarial examples, we use a stricter threshold for robustness of = 20 pixels.</p><p>We performed a similar comparison to the signed gradient algorithm proposed by <ref type="bibr" target="#b4">[5]</ref> (with the signed gradient multiplied by = 20 pixels). For LeNet, this algorithm found only one adversarial example on the MNIST test set (out of 10,000) and four adversarial examples on the MNIST training set (out of 60,000), so we omit results<ref type="foot" target="#foot_1">2</ref> .</p><p>Results. In Figure <ref type="figure" target="#fig_2">3</ref>, we plot the number of test points x * for which ρ(f, x * ) ≤ , as a function of , where ρ(f, x * ) is estimated using (a) the baseline and (b) our algorithm. These plots compare the robustness of each neural network as a function of . In Table <ref type="table" target="#tab_2">1</ref>, we show results evaluating the robustness of each neural net, including the adversarial frequency and the adversarial severity. The running time of our algorithm and the baseline algorithm are very similar; in both cases, computing ρ(f, x * ) for a single input x * takes about 1.5 seconds. For comparison, without our iterative constraint solving optimization, our algorithm took more than two minutes to run.</p><p>Discussion. For every neural net, our algorithm produces substantially higher estimates of the adversarial frequency. In other words, our algorithm estimates ρ(f, x * ) with substantially better accuracy compared to the baseline.</p><p>According to the baseline metrics shown in Figure <ref type="figure" target="#fig_2">3</ref> (a), the baseline neural net (red) is similarly robust to our neural net (blue), and both are more robust than the original LeNet (black). Our neural net is actually more robust than the baseline neural net for smaller values of , whereas the baseline neural net eventually becomes slightly more robust (i.e., where the red line dips below the blue line). This behavior is captured by our robustness statistics-the baseline neural net has lower adversarial frequency (so it has fewer adversarial examples with ρ(f, x * ) ≤ ) but also has worse adversarial severity (since its adversarial examples are on average closer to the original points x * ).</p><p>However, according to our metrics shown in Figure <ref type="figure" target="#fig_2">3</ref> (b), our neural net is substantially more robust than the baseline neural net. Again, this is reflected by our statistics-our neural net has substantially lower adversarial frequency compared to the baseline neural net, while maintaining similar adversarial severity. Taken together, our results suggest that the baseline neural net is overfitting to the adversarial examples found by the baseline algorithm. In particular, the baseline neural net does not learn the adversarial examples found by our algorithm. On the other hand, our neural net learns both the adversarial examples found by our algorithm and those found by the baseline algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Scaling to CIFAR-10</head><p>We also implemented our approach for the for the CIFAR-10 network-in-network (NiN) neural net <ref type="bibr" target="#b12">[13]</ref>, which obtains 91.31% test set accuracy. Computing ρ(f, x * ) for a single input on NiN takes about 10-15 seconds on an 8-core CPU. Unlike LeNet, NiN suffers severely from adversarial examples-we measure a 61.5% adversarial frequency and an adversarial severity of 2.82 pixels. Our neural net (NiN fine-tuned using our algorithm and T = 1) has test set accuracy 90.35%, which is similar to the test set accuracy of the original NiN. As can be seen in Figure <ref type="figure" target="#fig_2">3</ref> (c), our neural net improves slightly in terms of robustness, especially for smaller . As before, these improvements are reflected in our metrics-the adversarial frequency of our neural net drops slightly to 59.6%, and the adversarial severity improves to 3.88. Nevertheless, unlike LeNet, our fine-tuned version of NiN remains very prone to adversarial examples. In this case, we believe that new techniques are required to significantly improve robustness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>We have shown how to formulate, efficiently estimate, and improve the robustness of neural nets using an encoding of the robustness property as a constraint system. Future work includes devising better approaches to improving robustness on large neural nets such as NiN and studying properties beyond robustness.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :Figure 2 :</head><label>12</label><figDesc>Figure 1: Neural net with a single hidden layer and ReLU activations trained on dataset with binary labels. (a) The training data and loss surface. (b) The linear region corresponding to the red training point.</figDesc><graphic url="image-1.png" coords="4,120.49,85.08,98.01,98.01" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Linear relations; specifically, inequalities C ≡ (w T x + b ≥ 0) and equalities C ≡ (w T x + b = 0), where x ∈ R m (for some m) are variables andw ∈ R m , b ∈ R are constants. • Conjunctions C ≡ C 1 ∧ C 2 ,where C 1 and C 2 are themselves constraints. Both constraints must be satisfied for the conjunction to be satisfied. • Disjunctions C ≡ C 1 ∨C 2 , where C 1 and C 2 are themselves constraints. One of the constraints must be satisfied for the disjunction to be satisfied.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: The cumulative number of test points x * such that ρ(f, x * ) ≤ as a function of . In (a) and (b), the neural nets are the original LeNet (black), LeNet fine-tuned with the baseline and T = 2(red), and LeNet fine-tuned with our algorithm and T = 2 (blue); in (a), ρ is measured using the baseline, and in (b), ρ is measured using our algorithm. In (c), the neural nets are the original NiN (black) and NiN finetuned with our algorithm, and ρ is estimated using our algorithm.</figDesc><graphic url="image-10.png" coords="7,246.60,207.85,118.79,72.08" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Smaller µ(f, ) corresponds to worse adversarial severity, since f is more susceptible to adversarial examples if the distances to the nearest adversarial example are small.</figDesc><table /><note>The frequency and severity capture different robustness behaviors. A neural net may have high adversarial frequency but low adversarial severity, indicating that most adversarial examples are about distance away from the original point x * . Conversely, a neural net may have low adversarial frequency but high adversarial severity, indicating that it is typically robust, but occasionally severely fails to be robust. Frequency is typically the more important metric, since a neural net with low adversarial frequency is robust most of the time. Indeed, adversarial frequency corresponds to the</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>). In other words, if we replace C 1 with either C 2 or C 3 , the feasible set of the resulting constraints can only become smaller. Taking D(x * ) ≡ C 2 (resp., D(x * ) ≡ C 3 ) effectively replaces C 1 with C 2 (resp., C 3 ).To restrict (3), for every disjunction C 1 ≡ C 2 ∨ C 3 , we systematically choose either C 2 or C 3 to replace the constraint C 1 . In particular, we choose C 2 if x * satisfies C 2 (i.e., x * ∈ F(C 2 )) and choose C 3</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 :</head><label>1</label><figDesc>Evaluation of fine-tuned networks. Our method discovers more adversarial examples than the baseline<ref type="bibr" target="#b20">[21]</ref> for each neural net, hence producing better estimates. LeNet fine-tuned for T = 1, 2 rounds (bottom four rows) exhibit a notable increase in robustness compared to the original LeNet.</figDesc><table><row><cell>Neural Net</cell><cell>Accuracy (%)</cell><cell cols="4">Adversarial Frequency (%) Adversarial Severity (pixels) Baseline Our Algo. Baseline Our Algo.</cell></row><row><cell>LeNet (Original)</cell><cell>99.08</cell><cell>1.32</cell><cell>7.15</cell><cell>11.9</cell><cell>12.4</cell></row><row><cell>Baseline (T = 1)</cell><cell>99.14</cell><cell>1.02</cell><cell>6.89</cell><cell>11.0</cell><cell>12.3</cell></row><row><cell>Baseline (T = 2)</cell><cell>99.15</cell><cell>0.99</cell><cell>6.97</cell><cell>10.9</cell><cell>12.4</cell></row><row><cell>Our Algo. (T = 1)</cell><cell>99.17</cell><cell>1.18</cell><cell>5.40</cell><cell>12.8</cell><cell>12.2</cell></row><row><cell>Our Algo. (T = 2)</cell><cell>99.23</cell><cell>1.12</cell><cell>5.03</cell><cell>12.2</cell><cell>11.7</cell></row></table><note>We use fine-tuning to reduce a neural net's susceptability to adversarial examples. First, we use an algorithm A to compute adversarial examples for each x * ∈ X train and add them to the training set. Then, we continue training the network on a the augmented training set at a reduced training rate. We can repeat this process multiple rounds (denoted T ); at each round, we only consider x * in the original training set (rather than the augmented training set).</note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0">Our neural net has 8 hidden units, but for this x * , 6 of the half-spaces entirely contain the convex region.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1">Futhermore, the signed gradient algorithm cannot be used to estimate adversarial severity since all the adversarial examples it finds have L∞ norm .</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Visual causal feature learning</title>
		<author>
			<persName><forename type="first">K</forename><surname>Chalupka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Perona</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Eberhardt</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Analysis of classifers&apos; robustness to adversarial perturbations</title>
		<author>
			<persName><forename type="first">A</forename><surname>Fawzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Fawzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Frossard</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
	<note>ArXiv e-prints</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Ensemble robustness of deep learning algorithms</title>
		<author>
			<persName><forename type="first">Jiashi</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tom</forename><surname>Zahavy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bingyi</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Huan</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shie</forename><surname>Mannor</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1602.02389</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Nightmare at test time: robust learning by feature deletion</title>
		<author>
			<persName><forename type="first">Amir</forename><surname>Globerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sam</forename><surname>Roweis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd international conference on Machine learning</title>
				<meeting>the 23rd international conference on Machine learning</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="353" to="360" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Explaining and harnessing adversarial examples</title>
		<author>
			<persName><forename type="first">Ian</forename><forename type="middle">J</forename><surname>Goodfellow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathon</forename><surname>Shlens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christian</forename><surname>Szegedy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Towards deep neural network architectures robust to adversarial examples</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Rigazio</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Learning with a strong adversary</title>
		<author>
			<persName><forename type="first">Ruitong</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bing</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dale</forename><surname>Schuurmans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Csaba</forename><surname>Szepesvári</surname></persName>
		</author>
		<idno>CoRR, abs/1511.03034</idno>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName><forename type="first">Yangqing</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Evan</forename><surname>Shelhamer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeff</forename><surname>Donahue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sergey</forename><surname>Karayev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ross</forename><surname>Girshick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sergio</forename><surname>Guadarrama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Trevor</forename><surname>Darrell</surname></persName>
		</author>
		<author>
			<persName><surname>Caffe</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1408.5093</idno>
		<title level="m">Convolutional architecture for fast feature embedding</title>
				<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Learning multiple layers of features from tiny images</title>
		<author>
			<persName><forename type="first">Alex</forename><surname>Krizhevsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Geoffrey</forename><surname>Hinton</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Imagenet classification with deep convolutional neural networks</title>
		<author>
			<persName><forename type="first">Alex</forename><surname>Krizhevsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ilya</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Geoffrey</forename><forename type="middle">E</forename><surname>Hinton</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Gradient-based learning applied to document recognition</title>
		<author>
			<persName><forename type="first">Yann</forename><surname>Lecun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Léon</forename><surname>Bottou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yoshua</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrick</forename><surname>Haffner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of the IEEE</title>
		<imprint>
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="2278" to="2324" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Gradient-based learning applied to document recognition</title>
		<author>
			<persName><forename type="first">Yann</forename><surname>Lecun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Léon</forename><surname>Bottou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yoshua</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrick</forename><surname>Haffner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Intelligent Signal Processing</title>
				<editor>
			<persName><forename type="first">S</forename><surname>Haykin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Kosko</surname></persName>
		</editor>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="306" to="351" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">Min</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Qiang</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shuicheng</forename><surname>Yan</surname></persName>
		</author>
		<idno>CoRR, abs/1312.4400</idno>
	</analytic>
	<monogr>
		<title level="j">Network In Network</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Distributional smoothing with virtual adversarial training</title>
		<author>
			<persName><forename type="first">Takeru</forename><surname>Miyato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shin-Ichi</forename><surname>Maeda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Masanori</forename><surname>Koyama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ken</forename><surname>Nakae</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shin</forename><surname>Ishii</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">stat</title>
		<imprint>
			<biblScope unit="volume">1050</biblScope>
			<biblScope unit="page">25</biblScope>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">On the number of linear regions of deep neural networks</title>
		<author>
			<persName><forename type="first">Guido</forename><forename type="middle">F</forename><surname>Montúfar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Razvan</forename><surname>Pascanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kyunghyun</forename><surname>Cho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yoshua</forename><surname>Bengio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems 27: Annual Conference on Neural Information Processing Systems</title>
				<meeting><address><addrLine>Montreal, Quebec, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-12-08">2014. December 8-13 2014. 2014</date>
			<biblScope unit="page" from="2924" to="2932" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Deepfool: a simple and accurate method to fool deep neural networks</title>
		<author>
			<persName><forename type="first">Seyed</forename><surname>Mohsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moosavi</forename><surname>Dezfooli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alhussein</forename><surname>Fawzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pascal</forename><surname>Frossard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 2016 IEEE Conference on Computer Vision and Pattern Recognition (CVPR), number EPFL-CONF-218057</title>
				<meeting>2016 IEEE Conference on Computer Vision and Pattern Recognition (CVPR), number EPFL-CONF-218057</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Deep neural networks are easily fooled: High confidence predictions for unrecognizable images</title>
		<author>
			<persName><forename type="first">Anh</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jason</forename><surname>Yosinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeff</forename><surname>Clune</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Vision and Pattern Recognition (CVPR), 2015 IEEE Conference on</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="427" to="436" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Practical black-box attacks against deep learning systems using adversarial examples</title>
		<author>
			<persName><forename type="first">Nicolas</forename><surname>Papernot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrick</forename><surname>Mcdaniel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ian</forename><surname>Goodfellow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Somesh</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ananthram</forename><surname>Berkay Celik</surname></persName>
		</author>
		<author>
			<persName><surname>Swami</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1602.02697</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">Sara</forename><surname>Sabour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yanshuai</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fartash</forename><surname>Faghri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">J</forename><surname>Fleet</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1511.05122</idno>
		<title level="m">Adversarial manipulation of deep representations</title>
				<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Understanding adversarial training: Increasing local stability of neural nets through robust optimization</title>
		<author>
			<persName><forename type="first">Uri</forename><surname>Shaham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yutaro</forename><surname>Yamada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sahand</forename><surname>Negahban</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1511.05432</idno>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Intriguing properties of neural networks</title>
		<author>
			<persName><forename type="first">Christian</forename><surname>Szegedy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wojciech</forename><surname>Zaremba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ilya</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joan</forename><surname>Bruna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dumitru</forename><surname>Erhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ian</forename><surname>Goodfellow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rob</forename><surname>Fergus</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Exploring the space of adversarial images</title>
		<author>
			<persName><forename type="first">Pedro</forename><surname>Tabacof</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eduardo</forename><surname>Valle</surname></persName>
		</author>
		<idno>CoRR, abs/1510.05328</idno>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Robustness and generalization</title>
		<author>
			<persName><forename type="first">Huan</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shie</forename><surname>Mannor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Machine learning</title>
		<imprint>
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="391" to="423" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
