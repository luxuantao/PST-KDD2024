<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Higher-Order Ghost State</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ralf</forename><surname>Jung</surname></persName>
							<email>jung@mpi-sws.org</email>
							<affiliation key="aff0">
								<orgName type="institution">MPI-SWS</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Robbert</forename><surname>Krebbers</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Aarhus University</orgName>
								<address>
									<country key="DK">Denmark</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Lars</forename><surname>Birkedal</surname></persName>
							<email>birkedal@cs.au.dk</email>
							<affiliation key="aff2">
								<orgName type="institution">Aarhus University</orgName>
								<address>
									<country key="DK">Denmark</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Derek</forename><surname>Dreyer</surname></persName>
							<email>dreyer@mpi-sws.org</email>
							<affiliation key="aff3">
								<orgName type="institution">MPI-SWS</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Higher-Order Ghost State</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">9C8BB87A7C83CC89D7F5F4E24D831CBB</idno>
					<idno type="DOI">10.1145/2951913.2951943</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T05:14+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.3.1 [Programming Languages]: Formal Definitions and Theory; F.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Programs Keywords Separation logic</term>
					<term>fine-grained concurrency</term>
					<term>higherorder logic</term>
					<term>compositional verification</term>
					<term>interactive theorem proving</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The development of concurrent separation logic (CSL) has sparked a long line of work on modular verification of sophisticated concurrent programs. Two of the most important features supported by several existing extensions to CSL are higher-order quantification and custom ghost state. However, none of the logics that support both of these features reap the full potential of their combination. In particular, none of them provide general support for a feature we dub "higher-order ghost state": the ability to store arbitrary higherorder separation-logic predicates in ghost variables.</p><p>In this paper, we propose higher-order ghost state as a interesting and useful extension to CSL, which we formalize in the framework of Jung et al.'s recently developed Iris logic. To justify its soundness, we develop a novel algebraic structure called CMRAs ("cameras"), which can be thought of as "step-indexed partial commutative monoids". Finally, we show that Iris proofs utilizing higher-order ghost state can be effectively formalized in Coq, and discuss the challenges we faced in formalizing them.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Over a decade ago, O'Hearn made a critical observation: separation logic-developed to simplify the verification of sequential, heapmanipulating programs-can help simplify the verification of concurrent programs as well. In concurrent separation logic (CSL) <ref type="bibr" target="#b27">[28]</ref>, assertions denote not only facts about the state of the program, but also ownership of a piece of that state. Concretely, this means that if a thread t can assert ℓ → v, then t knows not only that location ℓ currently points to v, but also that it "owns" ℓ, so no other thread can read or write ℓ concurrently. Given this ownership assertion, t can perform local (and essentially sequential) reasoning on accesses to ℓ, completely ignoring concurrently operating threads.</p><p>Of course at some point threads have to communicate through some kind of shared state (such as a mutable heap or messagepassing channels). To reason modularly about such communication, the original CSL used a simple form of resource invariants, which were tied to a "conditional critical region" construct for synchronization. Since O'Hearn's pioneering (and Gödel-award-winning) paper, there has been an avalanche of follow-on work extending CSL with more sophisticated mechanisms for modular reasoning, which allow shared state to be accessed at a finer granularity (e.g., atomic compare-and-swap instructions) and which support the verification of more "daring" (less clearly synchronized) concurrent programs <ref type="bibr" target="#b39">[40,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b37">38,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b23">24]</ref>.</p><p>In this paper, we focus on two of the most important extensions to CSL-higher-order quantification and custom ghost state-and observe that, although several logics support both of these extensions, none of them reap the full potential of their combination. In particular, none of them provide general support for a feature we dub "higher-order ghost state".</p><p>Higher-order quantification is the ability to quantify logical assertions (universally and existentially) over other assertions and, in general, over arbitrary higher-order predicates. Several recent extensions to CSL have incorporated higher-order quantification <ref type="bibr" target="#b35">[36,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b26">27]</ref>, in part because it leads to more generic and reusable specifications of concurrent data structures (see §4), and in part because it is seemingly necessary for verifying some higher-order concurrency paradigms <ref type="bibr" target="#b34">[35,</ref><ref type="bibr" target="#b37">38,</ref><ref type="bibr" target="#b30">31]</ref>.</p><p>Ghost state is "logical state", i.e., state that is essential to maintain in the proof of a program but is not part of the physical state manipulated by the program itself. It is a fixture of Hoare logics since the work of Owicki and Gries <ref type="bibr" target="#b28">[29]</ref> in the 1970s, and is useful for a variety of purposes: for encoding various kinds of "permissions", for recording information about the trace of the computation, for describing "protocols" on how threads may interact with shared state, and more. Traditionally, ghost state was manipulated by instrumenting a program with updates to "ghost" (or "auxiliary") variables. Although this approach is convenient for integration into automatic verification tools <ref type="bibr" target="#b9">[10]</ref>, it is unnecessarily low-level: there is no reason logical state needs to be manipulated in exactly the same way as physical state, and doing so makes it harder to reason about updates to shared logical state in a modular fashion.</p><p>Recently, a number of researchers have argued that a more highlevel, general, and flexible way to represent ghost state is via partial commutative monoids (PCMs). Intuitively, PCMs are a natural fit for ghost state because they impose only the bare minimum requirements on something that should be "ownable" in a separation logic, while leaving lots of room for proof-specific customization. Several newer extensions to CSL <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b11">12]</ref> thus give users the freedom to define ghost state on a per-proof basis in terms of an arbitrary PCM of their choosing. Furthermore, the Iris logic <ref type="bibr" target="#b23">[24]</ref> has established that PCMs (together with simple invariants) are flexible enough to derive several advanced reasoning mechanisms that were built in as primitive in prior logics.</p><p>Unfortunately, a limitation arises when one uses PCMs to support custom ghost state in the context of a logic with higher-order quantification. Specifically, PCMs yield a model of ghost state that is first-order. By this we mean that there is an inherent stratification:</p><formula xml:id="formula_0">M C1 W1 C2 W2 P1 * P2 P1 P2 P1 P2 Figure 1.</formula><p>Structure of illustrative example separation-logic assertions may talk about ownership of ghost state, but the PCM structure of ghost state may not depend (recursively) on the language of logical assertions. At first glance, this may not seem like a big deal. Why would you want higher-order ghost state-i.e., ghost state that is mutually recursive with the language of assertions-anyway? What would that even mean? To give some intuition for what higher-order ghost state is and what it can be good for, let us turn to a simple yet interesting illustrative example of some intuitively sensible reasoning that, as far as we know, no existing logic can support.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Illustrative Example: Splitting and Joining Existentials</head><p>Imagine we have three threads-a main thread M and two worker threads W1 and W2-running concurrently, and that we have two communication channels C1 and C2 connecting each worker to the main thread (see Figure <ref type="figure">1</ref>). The idea of the example is that M is going to initialize some state, split up ownership of the state, send the pieces to W1 and W2 via their respective channels, and after some computation, they are going to send their pieces back so that M can join them together and reassert ownership of the whole state.</p><p>Formally: Let i range over {1, 2}. Let us suppose that M will initialize its state so that it satisfies the assertion P , after which M would like to split up ownership into two "disjoint" pieces P1 and P2 such that P = P1 * P2 and Pi is the assertion to be transferred back and forth with the corresponding Wi over Ci. (The * operator here is the "separating conjunction" connective of separation logic, which enforces the disjointness of P1 and P2.) To make this work, it is essential that M and Wi agree ahead of time on the fact that Ci will be used to transfer ownership of Pi.</p><p>So far, so good. But now what happens if the assertion P depends on some information (say, on some x of type T ) that is only determined dynamically, right before M wants to transfer ownership of P to the other, already running, threads. (For instance, x might be some information that depends on the result of I/O or some other source of nondeterminism.) In this case, we cannot associate the channels Ci ahead of time with the assertions Pi since, at the point the channels are created, the identity of x is not known. Instead, all we can really do is to existentially quantify over x-that is, set up our channels so that instead of transferring Pi to Wi, M will transfer ∃x:T. Pi, which is well-defined at the point the channels are created.</p><p>In the forward direction (sending from M to Wi), this works because P = P1 * P2 implies ∃x:T. P ⇒ ∃x:T. P1 * ∃x:T. P2. But when the Wi try to return the state to M , we run into a problem: although P1 * P2 ⇒ P , it is not true that ∃x:T. P1 * ∃x:T. P2 ⇒ ∃x:T. P because there is no way to deduce that the existential witnesses for x in ∃x:T. P1 and ∃x:T. P2 are the same. This is all very frustrating since we know that, at least when M split up its original state, the witnesses were indeed the same.</p><p>Fortunately, there is another way: custom ghost state! Using custom ghost state, we can allocate a oneshot ghost variable γ up front: initially, γ will be undefined, and once M determines what term e should be the witness for x, it will set γ to e. <ref type="foot" target="#foot_0">1</ref> We will write γ ֒→ e to denote the knowledge that e has been stored in γ. Unlike normal heap ownership assertions, γ ֒→ e can be freely duplicated (i.e., γ ֒→ e ⇔ γ ֒→ e * γ ֒→ e) since γ can only be assigned once. Furthermore, if we know γ ֒→ e1 and γ ֒→ e2, then we also know that e1 = e2 because, once set, γ maps to a unique e.</p><p>We can now amend the assertions ∃x:T. Pi that are sent between the threads to ∃x:T. (γ ֒→ x * Pi), thus recording the fact that the witness x is precisely the term stored in γ. And the virtue of this encoding is that now the existential can be split and rejoined: ∃x:T. (γ ֒→ x * P ) ⇔ ∃x:T. (γ ֒→ x * P1) * ∃x:T. (γ ֒→ x * P2). The ⇒ direction relies on the fact that γ ֒→ x is duplicable, and the ⇐ direction relies on the fact that γ stores a unique witness.</p><p>There is just one catch: in all the existing logics that support custom ghost state, the witness x stored in γ is restricted to be first-order (i.e., an "object-level" term), hence restricting all the existentials in the example to be first-order as well. If x instead is (or contains) an assertion or higher-order predicate of the logic-as may very well be the case if we are working in a higher-order concurrent separation logic <ref type="bibr" target="#b35">[36,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b26">27]</ref>-then the whole approach falls over. Moreover, this problem is not limited to logics with custom ghost state: to our knowledge, no existing logic is capable of proving this example in the general case.</p><p>The good news is that restricting custom ghost state to first-order is unnecessary. To overcome it, we will need the ability to store terms of arbitrary higher type T (including assertions and higherorder predicates) in ghost variables like γ. In other words, we will need higher-order ghost state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Contributions</head><p>In this paper, we make the following contributions:</p><p>• We propose and formalize higher-order ghost state as an interesting and useful extension of concurrent separation logic.</p><p>• We give a semantics to justify this extension in terms of a novel algebraic structure we call a CMRA ("camera"), which can be thought of as a kind of "step-indexed" PCM.</p><p>• We demonstrate that separation-logic proofs utilizing higherorder ghost state can be effectively formalized in Coq.</p><p>To be concrete, we will develop our notion of higher-order ghost state as an extension to the Iris logic of Jung et al. <ref type="bibr" target="#b23">[24]</ref>. Iris is a higher-order variant of CSL that supports custom ghost state through the choice of an arbitrary user-supplied PCM. Over the course of the paper, we will gradually extend Iris from its original version, numbered 1.0, to the latest version, numbered 2.0, which can handle higher-order ghost state in a generic manner.</p><p>In §2, we give an overview of the key features of Iris and showcase their use on a simple representative example. Along the way, we introduce Iris 1.1, which makes some improvements to the original Iris 1.0, in particular generalizing its model of resources from PCMs to resource algebras (RAs), which are more flexible.</p><p>In §3, we extend Iris with higher-order ghost state and put the extension on a sound formal footing. This involves revisiting the category-theoretic model of Iris 1.x and further generalizing its model of resources to the aforementioned step-indexed CMRAs. Furthermore, we discuss how the new semantic structure of our higher-order ghost state not only generalizes the original model of Iris-in certain ways, it also simplifies it.</p><p>In §4, we return to our example from §1.1, flesh it out more carefully, and show how to verify it in Iris 2.0. Our implementation of the example makes use of a "barrier" synchronization primitive (drawn from Dodds et al. <ref type="bibr" target="#b14">[15]</ref>), whose own proof of correctness independently involves an interesting use of higher-order ghost state.</p><p>In §5, we describe our Coq formalization of Iris 2.0, which improves significantly on the original Coq formalization of Iris 1.0 in several respects. All proofs backing this paper have been formalized in Coq <ref type="bibr" target="#b0">[1]</ref>.</p><p>Finally, in §6 and §7, we conclude with related and future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Iris Primer</head><p>Iris is a generic higher-order concurrent separation logic. Generic here refers to the fact that the logic is parameterized by the language of program expressions that one wishes to reason about, so the same logic can be used for a large variety of languages. For the purpose of this paper, we instantiate Iris with an ML-like language with higher-order store, fork, and compare-and-swap (CAS): The logic includes the usual connectives and rules of higherorder separation assertion logic, some of which are shown in the grammar below. 2 In this section, we will give a brief tour of Iris, and demonstrate the purpose of these most important logical connectives.</p><formula xml:id="formula_1">e ::= x | rec f(x) = e | e1(</formula><formula xml:id="formula_2">P, Q, R ::= True | False | P ∧ Q | P ∨ Q | P ⇒ Q | ∀x. P | ∃x. P | P * Q | ℓ → v | ⊲P | t = u | P ι | a γ | V(a) | {P } e {v. Q} | P ⇛ Q | . . .</formula><p>What makes Iris a higher-order separation logic is that universal and existential quantifiers can range over any type, including that of assertions and (higher-order) predicates. Furthermore, notice that Hoare triples {P } e {v. Q} are part of the assertion logic instead of being a separate entity. As a consequence, triples can be used in the same way as any logical assertion, and in particular, they can be nested to account for specifications of higher-order functions.</p><p>We will demonstrate this, and some other core features of Iris, by verifying the safety of the simple higher-order-program given in Figure <ref type="figure">2</ref>. This is of course a rather contrived example, but it serves to showcase the core features of Iris.</p><p>The function mk_oneshot allocates a oneshot location at x and returns a record with two functions. (Formally, records are syntactic sugar for pairs.) The function tryset(n) tries to set the location to n, which will fail if the location has already been set. We use CAS to ensure correctness of the check even if two threads concurrently try to set the location. The function check() records the current state of the location and then returns a closure which, if the location has already been initialized, checks that it does not change.</p><p>The specification looks a little funny with most pre-and postconditions being True. The reason for this is that all we are aiming to show here is that the code is safe, i.e., that the assertions 3 succeed: the branch with assert(false) will never get executed, and in the final branch, n will always equal m. In Iris, Hoare triples imply safety, so we do not need to impose any further conditions.</p><p>As is common for Hoare triples about functional programs, the postconditions have a binder to refer to the return value. We will omit the binder if the result is always unit.</p><p>We use nested Hoare triples to express that mk_oneshot returns closures: Since Hoare triples are just assertions, we can put them into the postcondition of mk_oneshot to describe what the client can assume about c. Furthermore, since Iris is a concurrent program 2 Actually, many of the connectives given in this grammar are defined as derived forms in Iris, and this flexibility is an important aspect of the logic. For more details on this, see <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b0">1]</ref>. 3 Our semantics here is that assert(e) gets stuck if e evaluates to false.</p><formula xml:id="formula_3">mk_oneshot λ . let x = ref(inl(0)) in { tryset = λn. CAS(x, inl(0), inr(n)), check = λ . let y = !x in λ . match y, !x with inl( ) , ⇒ () | inr(n), inl( ) ⇒ assert(false) | inr(n), inr(m) ⇒ assert(n = m) end } {True} mk_oneshot() { c. ∀v. {True} c.tryset(v) {w. w ∈ {true, false}} * {True} c.check() {f. {True} f () {True}} } Figure 2.</formula><p>Example code and specification logic, the specification for mk_oneshot actually permits the client to call tryset and check, as well as the f returned by check, concurrently from multiple threads and in any combination.</p><p>High-level proof structure. To perform this proof, we need to somehow encode the fact that we are only performing a oneshot update to x. To this end, we will allocate a ghost location γ which mirrors the current state of x. This may at first sound rather pointless; why should we record a value in the ghost state that is exactly the same as the value in a particular physical location?</p><p>The reason we do this is so that we can control what kind of sharing is possible on the location. For a physical location ℓ, the assertion ℓ → v expresses full ownership of ℓ (and hence the absence of any sharing of it). In contrast, Iris permits us to choose whatever kind of structure and ownership we want for our ghost location γ; in particular, we can define it in such a way that, although the contents of γ mirror the contents of x, we can freely share ownership of γ once it has been initialized (by a call to tryset). This in turn will allow the closure returned by check to own a piece of γ witnessing its value after initialization. We will then have an invariant tying the value of γ to the value of x, so we know which value that closure is going to see when it reads from x, and we know that that value is going to match y.</p><p>With this high-level proof structure in mind, we now explain how exactly ownership and sharing of ghost state can be controlled.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Ghost State in Iris: Resource Algebras</head><p>The key properties of ownership of ghost state in concurrent separation logics are:</p><p>• Ownership of different threads can be composed.</p><p>• Composition of ownership is associative and commutative, mirroring the associative and commutative semantics of parallel composition.</p><p>• Combinations of ownership that do not make sense are ruled out, e.g., multiple threads claiming to have exclusive ownership of the same piece of ghost state.</p><p>For these reasons, partial commutative monoids (PCMs) have become a canonical structure for representing ghost state in separation logics. Iris 1.0 was parameterized by an arbitrary PCM, so that the structure of the ghost state was entirely up to the user.</p><p>In Iris 1.1, we are deviating slightly from this, using our own notion of a resource algebra (RA), whose definition is in Figure <ref type="figure">3</ref>. As we will see in our example, the additional flexibility afforded by RAs results in additional logical expressiveness.</p><formula xml:id="formula_4">A resource algebra (RA) is a tuple (M, V ⊆ M, |-| : M → M ? , (•) : M × M → M ) satisfying: ∀a, b, c. (a • b) • c = a • (b • c) (RA-ASSOC) ∀a, b. a • b = b • a (RA-COMM) ∀a. |a| ∈ M ⇒ |a| • a = a (RA-CORE-ID) ∀a. |a| ∈ M ⇒ ||a|| = |a| (RA-CORE-IDEM) ∀a, b. |a| ∈ M ∧ a b ⇒ |b| ∈ M ∧ |a| |b| (RA-CORE-MONO) ∀a, b. (a • b) ∈ V ⇒ a ∈ V (RA-VALID-OP)</formula><p>where</p><formula xml:id="formula_5">M ? M ⊎ {ε} a ? • ε ε • a ? a ? a b ∃c ∈ M. b = a • c (RA-INCL)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 3. Resource algebras</head><p>There are two key differences between RAs and PCMs:</p><p>1. The composition operation on RAs is total (as opposed to the partial composition operation of a PCM), but there is a specific subset V of valid elements that is compatible with the composition operation (RA-VALID-OP). We will see in §3.2 that this take on partiality is necessary when defining the structure of higher-order ghost state.</p><p>2. Instead of a single unit that is an identity to every element, we allow for an arbitrary number of units, via a function |-| assigning to an element a its (duplicable) core |a|, as demanded by RA-CORE-ID. We further demand that |-| is idempotent (RA-CORE-IDEM) and monotone (RA-CORE-MONO) with respect to the extension order, defined similarly to that for PCMs (RA-INCL).</p><p>Notice that the domain of the core is M ? , a set that adds a dummy element ε to M . Thus, the core can be partial: not all elements need to have a unit. We use the metavariable a ? to indicate elements of M ? . We also lift the composition (•) to M ? . As we will see in §2.5, partial cores help us to build interesting composite RAs from smaller primitives. Notice also that the core of an RA is a strict generalization of the unit that any PCM must provide, since |-| can always be picked as a constant function.</p><p>A resource algebra for our example. We will now define the RA that can be used to verify our example, which we call the oneshot RA. This RA appropriately mirrors the state of the physical location x.</p><p>The carrier is defined using a datatype-like notation as follows:</p><formula xml:id="formula_6">M pending | shot(n : Z) | ⊥ V {pending} ∪ {shot(n) | n ∈ Z}</formula><p>The two important states of the ghost location are: pending, to represent the fact that the single update has not yet happened, and shot(n), saying that the location has been set to n. We need an additional element ⊥ to account for partiality.</p><p>The most interesting piece of data of an RA is of course its composition: What happens when ownership of two threads is combined? For our example, we are most interested in the behavior of pending and shot:</p><formula xml:id="formula_7">pending • pending ⊥ pending • shot(n) shot(n) • pending ⊥ shot(n) • shot(m)    shot(n) if n = m ⊥ otherwise GHOST-OP a • b γ ⇔ a γ * b γ GHOST-VALID a γ ⇒ a γ * V(a) GHOST-ALLOC V(a) True ⇛ ∃γ. a γ GHOST-UPDATE a b a γ ⇛ b γ PERSISTENT-GHOST |a| = a persistent( a γ )</formula><p>where</p><formula xml:id="formula_8">a b ∀a ? f ∈ M ? . a • a ? f ∈ V ⇒ b • a ? f ∈ V INV-ALLOC I ⇛ I ι INV</formula><p>(side conditions on ι and I omitted) {I * P } e {v. I * Q} atomic(e)  As a result of this definition, if we own pending, we know that no other thread can own anything about this location, since the composition with that other piece of ownership would be invalid (i.e., ⊥). Furthermore, if we own shot(n), we know that the only ownership any other thread can have is also shot(n), since everything else is incompatible with our own ownership. However, since shot(n)•shot(n) = shot(n), we can also duplicate ownership of the location as much as we want, once it has been set to some n. This gives rise to the sharing that we need.</p><formula xml:id="formula_9">I ι ⊢ {P } e {v. Q} CSQ P ⇛ P ′ {P ′ } e {v. Q ′ } ∀v. Q ′ ⇛ Q {P } e {v. Q}</formula><p>In defining the duplicable core, we make sure that we keep as much ownership as possible while satisfying RA-CORE-ID:</p><formula xml:id="formula_10">|pending| ε |shot(n)| shot(n) |⊥| ⊥</formula><p>Note that, since ownership of pending is exclusive, it has no suitable unit element, so we assign it the "dummy core" ε. It is now straightforward to verify that the RA for our example satisfies the RA axioms.</p><p>Proof rules for ghost state. Resource algebras are embedded into the logic using the assertion a γ , which asserts ownership of a piece a of the ghost location γ. <ref type="foot" target="#foot_1">4</ref> The proof rule GHOST-ALLOC in Figure <ref type="figure" target="#fig_2">4</ref> can be used to allocate a new ghost location, with an arbitrary but valid initial state a. The assertion V(a) reflects validity of a into the logic, i.e., it corresponds to a ∈ V on the meta-level. The ⇛ in GHOST-ALLOC is a view shift, also known as a ghost move: P ⇛ Q says that, starting in a (ghost and physical) state satisfying P , we can do updates to the ghost state only and arrive in a state satisfying Q. The rule of consequence (CSQ) says that we can apply view shifts in the pre-and postconditions of Hoare triples. The rule GHOST-OP says that ghost state can be separated (in the sense of separation logic) following the composition operation (•) defined for the RA. And GHOST-VALID encodes the fact that only valid RA elements can ever be owned.</p><p>Finally, we need a way to update ghost locations. Updates to ghost locations are called frame-preserving updates and can be performed using the rule GHOST-UPDATE. We can perform a framepreserving update a b on a ghost location γ, if the update ensures that no matter what assumptions the rest of the program is making about the state of γ, if these assumptions were compatible with a, they should also be compatible with b. Or in other words, we have to make sure that the assumptions the rest of the program is making about γ will not be invalidated by the update.</p><p>We only need one frame-preserving update for our example:</p><formula xml:id="formula_11">pending shot(n) (ONESHOT-SHOOT)</formula><p>This property follows from the fact that no frames are compatible with pending. That is, by the definition of (•), we know that pending • a ? f ∈ V can only hold for the dummy frame a ? f = ε.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Invariants</head><p>Now that we have set up the structure of our ghost location γ, we have to connect the state of γ to x. This is done using an invariant.</p><p>In Iris, invariants are provided in the form of the assertion P ι , which asserts that P is maintained as an invariant on the global (ghost and physical) state. In order to identify invariants, every invariant has a name ι. We need to do some bookkeeping with these names to avoid reentrancy, which in the case of invariants means avoiding "opening" the same invariant twice in a nested fashion. However, we omit the bookkeeping for this paper, as it is orthogonal to our focus; see the original Iris paper for details <ref type="bibr" target="#b23">[24]</ref>. Notice that P ι is just another kind of assertion, and can be used anywhere that normal assertions can be used-including the preand postconditions of Hoare triples, and invariants themselves. The latter property is sometimes referred to as impredicativity.</p><p>Invariants are created using the INV-ALLOC rule (Figure <ref type="figure" target="#fig_2">4</ref>): Whenever an assertion P has been established, it can be turned into an invariant. Allocating an invariant is another example of a view shift, since only ghost state is changed to record that this invariant will henceforth be maintained.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Persistent Assertions</head><p>Before we come to the actual proof of Figure <ref type="figure">2</ref>, we have to talk about the notion of a persistent assertion. These are assertions that, once established, will remain valid for the rest of the verification. Examples of persistent assertions are invariants P ι , validity V(a), equality t = u, Hoare triples {P } e {v. Q} and view shifts P ⇛ Q. Persistent assertions can be freely duplicated (PERSISTENT-DUP) and can be moved in and out of the precondition of Hoare triples (PERSISTENT-HOARE). This differentiates them from ephemeral assertions like ℓ → v and a γ , which could be invalidated in the future by actions of the program or the proof, and for which the above properties thus do not hold. Another example of a persistent assertion is ghost ownership of a core: |a| γ is persistent (PERSISTENT-GHOST). This possibility of having persistent ghost ownership is a novel concept of Iris 1.1 that cannot be expressed in a PCM-based logic. In the proof of check, we will see this concept in action.</p><p>A closely related concept is the notion of duplicable assertions, i.e., assertions P for which one has P ⇔ P * P . This is a strictly weaker notion, however: not all duplicable assertions are persistent. For example, ∃q. ℓ q -→ v is duplicable (which follows from halving the fractional permission q), but is not persistent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Proof of the Example</head><p>Proof of mk_oneshot. In order to verify mk_oneshot, we will first allocate a new ghost location γ with the structure of the oneshot RA defined above, picking the initial state pending. Then, we will establish and allocate the following invariant:</p><formula xml:id="formula_12">I (x → inl(0) * pending γ ) ∨ (∃n. x → inr(n) * shot(n) γ )</formula><p>Since x is initialized with inl(0), the invariant I initially holds.</p><p>Proof of tryset. How exactly can invariants be used? This is described by INV, which allows us to open the invariant for the verification of e. That is, we can assume that the invariant holds in the precondition, and then we have to reestablish that it holds in the postcondition. Crucially, we require that e is physically atomic, meaning that it is guaranteed to evaluate to a value in a single step of computation. This side condition is essential for soundness: within the verification of e the invariant I might be temporarily broken, but by restricting e's execution to a single instruction we ensure that no other thread can observe that I has been broken. In our language, reading from memory (!e), assigning to memory (e1 ← e2), and CAS are all physically atomic operations.</p><p>In the case of tryset, we have to open the invariant to justify safety of the CAS. The invariant always provides x → , so safety of the memory operation is justified. In case the CAS fails, no change is made to x, so reestablishing the invariant is immediate.</p><p>The case in which the CAS succeeds is more subtle. Here, we know that x originally had value inl(0), so we obtain the invariant in its left disjunct. Thus, after the CAS, we have the following:</p><p>x → inr(n) * pending γ How can we reestablish the invariant I after this CAS? Clearly, we must pick the right disjunct, since x → inr(n). Hence we have to update the ghost state to match the physical state. To this end, we apply GHOST-UPDATE with the frame-preserving update ONESHOT-SHOOT, which allows us to update the ghost location to shot(n) if we own pending. We then have I again and can finish the proof.</p><p>Notice that we could not complete the proof if tryset would ever change x again, since ONESHOT-SHOOT can only ever be used once on a particular ghost location. We have to be in the pending state if we want to pick the n in shot(n). This is exactly what we would expect, since check indeed relies on x not being modified once it has been set to inr(n).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of check. What remains is to prove correctness of check.</head><p>We open our invariant I to justify safety of !x, which is immediate since I always provides x → , but we will not immediately close I again. Instead, we will have to acquire some piece of ghost state that shows that if we read an inr(n), then x will not change its value. At this point in the proof, we have the following assertion:</p><formula xml:id="formula_13">x → y * ((y = inl(0) * pending γ ) ∨ (∃n. y = inr(n) * shot(n) γ ))</formula><p>We use the identity shot(n) = shot(n) • shot(n) with GHOST-OP to show that this logically implies:</p><formula xml:id="formula_14">x → y * ((y = inl(0) * pending γ ) ∨ (∃n. y = inr(n) * shot(n) γ * shot(n) γ ))</formula><p>which in turn implies:</p><formula xml:id="formula_15">I * (y = inl(0) ∨ (∃n. y = inr(n) * shot(n) γ ) P )</formula><p>We can then reestablish the invariant, but we keep P , the information we gathered about y. The plan is to use this in the proof of the closure that we return to justify that the assertion will hold.</p><p>To do so, we have to show that P is persistent. Technically, this is mandated by PERSISTENT-HOARE; intuitively, it is needed because the client could call the closure returned by check in an arbitrary future state of the program, and we have to make sure that it is always safe to do so. The reason P is persistent is that, thanks to shot(n) = |shot(n)| and PERSISTENT-GHOST, shot(n) γ is persistent. This matches the intuition that, once we observe that x has been set, we can then forever assume it will not change again.</p><p>To finish this proof, let us look at the closure returned by check in more detail: Again, we will open our invariant to justify safety of !x. Our assertion then is I * P , which unfolds to:</p><formula xml:id="formula_16">((x → inl(0) * pending γ ) ∨ (∃m. x → inr(m) * shot(m) γ )) * (y = inl(0) ∨ (∃n. y = inr(n) * shot(n) γ ))</formula><p>In order to proceed, we do 4-way case distinction over the values of x and y. Our goal is to prove that the assertions do not fail, so we have to show the following:</p><p>1. Goal: It cannot be the case that y = inr(n) and x → inl( ).</p><p>In this case, we would have pending • shot(n) γ and hence ⊥ γ , which according to GHOST-VALID is a contradiction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Goal:</head><p>In the case that y = inr(n) and x → inr(m), we have shot(n) • shot(m) γ . The following lemma shows that the assertion cannot fail:</p><formula xml:id="formula_17">shot(n) • shot(m) γ ⇒ n = m (ONESHOT-AGREE)</formula><p>The lemma holds by GHOST-VALID, which yields V(shot(n) • shot(m)), implying shot(n) • shot(m) = ⊥, and thus n = m.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">RA Constructions</head><p>One of the key features of Iris is that it leaves the structure of ghost state entirely up to the user of the logic, so if there is the need for some special-purpose RA, the user has the freedom to directly use it. However, it turns out that many frequently needed RAs can be constructed by composing smaller, reusable pieces-so while we have the entire space of RAs available when needed, we do not have to construct custom RAs for every new proof. For example, looking at the oneshot RA from §2.1, it really does three things:</p><p>1. It separates the allocation of an element of the RA from the decision about what value to store there (ONESHOT-SHOOT).</p><p>2. While the oneshot location is uninitialized, ownership is exclusive, i.e., at most one thread can own the location.</p><p>3. Once the value has been decided on, it makes sure everybody agrees on that value (ONESHOT-AGREE).</p><p>We can thus decompose the oneshot RA into the sum, exclusive and agreement RAs as described below. (In the definitions of all the RAs, the omitted cases of the composition and core are all ⊥.) Sum. The sum RA M1 + ⊥ M2 for any RAs M1 and M2 is:</p><formula xml:id="formula_18">M1 + ⊥ M2 inl(a1 : M1) | inr(a2 : M2) | ⊥ V inl(a1) a1 ∈ V ′ ∪ inr(a2) a2 ∈ V ′′ inl(a1) • inl(b1) inl(a1 • b1) |inl(a1)|    ε if |a1| = ε inl(|a1|) otherwise</formula><p>The composition and core for inr are defined symmetrically. Above, V ′ refers to the validity of M1, and V ′′ to the validity of M2.</p><p>Exclusive. Given a set X, the task of the exclusive RA EX(X) is to make sure that one party exclusively owns a value x ∈ X. We define EX by essentially dropping shot from the oneshot RA, and generalizing the carrier:</p><formula xml:id="formula_19">EX(X) ex(x : X) | ⊥ V {ex(x) | x ∈ X} |ex(x)| ε</formula><p>Composition is always ⊥ to ensure that ownership is exclusive.</p><formula xml:id="formula_20">a • b ⇔ a * b a ⇒ V(a) a b a ⇛ b Figure 5.</formula><p>Primitive rules for ghost state Agreement. Given a set X, the task of the agreement RA AG(X) is to make sure multiple parties can agree upon which value x ∈ X has been picked. We define AG by essentially dropping pending from the oneshot RA and generalizing the carrier:</p><formula xml:id="formula_21">AG(X) ag(x : X) | ⊥ V {ag(x) | x ∈ X} ag(x) • ag(y)    ag(x) if x = y ⊥ otherwise |ag(x)| ag(x)</formula><p>Oneshot. We can now define the general idea of the oneshot RA as ONESHOT(M ) EX(1) + ⊥ M , and recover the RA for the example as ONESHOT(AG(Z)). Notice that the decomposition of ONESHOT into a sum relies crucially on the fact that one summand, namely EX(1), has a partial core. The following generalization of ONESHOT-SHOOT can be shown in general for ONESHOT:</p><formula xml:id="formula_22">inl(ex()) inr(a)</formula><p>This update relies on the fact that ex() has no frame. If there was a unit |ex()| for ex(), then inl(|ex()|) would be a frame compatible with inl(ex()), and the frame-preserving update would not hold.</p><p>Obtaining usable frame-preserving updates for sums is one of our key motivations for making the core a partial function.</p><p>Joining existentials. The general construction ONESHOT(-) comes in handy, because it is exactly the RA that we need for the challenge of splitting and joining existentials as described in §1.1. Remember that there, too, we want to allocate ghost state before it is known what will be stored there. Now, it may seem that we are already equipped to solve the challenge posed in §1.1, but that is not the case. To prove that example, we need the ghost state to be M ONESHOT(AG(T )), where T may depend on iProp (the type of Iris assertions). However, the structure of the ghost state is a parameter of Iris, so iProp is actually defined in terms of M -which means we cannot define M in terms of iProp. We have to do some interesting work in the model of Iris to resolve this cycle, as we will describe in §3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Derived Forms and the Global Ghost State</head><p>In Iris, there is a strong emphasis on only providing a minimal core logic, and deriving as much as possible within the logic rather than baking it in as a primitive <ref type="bibr" target="#b23">[24]</ref>. For example, both Hoare triples and assertions of the form l → v are actually derived forms. This has the advantage that the model can be kept simpler, since it only has to justify soundness of a minimal core logic.</p><p>In this section we discuss the encoding of the assertion a γ for ghost ownership, which is not a baked-in notion. Instead, the idea of having a heap of ghost variables, which can be individually allocated and updated, is derived within the logic. Although this construction did not fundamentally change since Iris 1.0 <ref type="bibr" target="#b23">[24]</ref>, it is important for understanding the model construction in §3. As a primitive, Iris provides the construct a , which asserts ownership of a piece a of the entire global ghost state, rather than ownership of a piece of an individual ghost variable. The structure of the global ghost state is a single RA picked by the user, and the rules governing global ghost state are given in Figure <ref type="figure">5</ref>. In practice, however, the end-user typically wants to use multiple ghost variables of multiple RAs, in particular when combining different proofs. We apply a general construction facilitating this: We assume a family of RAs (Mi)i∈I for some index set I, and then define the RA M of the global ghost state to be the indexed (dependent) product over "heaps of Mi" as follows:</p><formula xml:id="formula_23">M i∈I N fin -⇀ Mi</formula><p>In this construction, we use the natural point-wise lifting of the RA operations from each Mi through the finite maps and products all the way to M , so that M is an RA itself.</p><p>This allows us (a) to use all the Mi in our proofs, and (b) to treat ghost state as a heap, where we can allocate new instances of any of the Mi at any time. We define local ghost ownership of a single location as:</p><formula xml:id="formula_24">a : Mi γ λj.    [γ → a] if i = j ∅ otherwise</formula><p>In other words, a : Mi γ asserts ownership of the singleton heap [γ → a] at position i in the product. We typically leave the concrete Mi implicit and write just a γ . The rules given in Figure <ref type="figure" target="#fig_2">4</ref> can then be derived from those shown in Figure <ref type="figure">5</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">A Model for Higher-Order Ghost State</head><p>In this section, we explain how to solve the problem outlined at the end of §2.5 by changing the semantic model of Iris assertions to account for higher-order ghost state. We start by giving a model for Iris 1.1. This is essentially a review of how the model of Iris 1.0 was built; the differences are minuscule. Next we show why the agreement construction AG as defined in §2.5 does not scale to higher-order ghost state, and give a refined version that does scale. Finally, we show how to evolve the model to Iris 2.0 in order to solve the challenge posed in §1.1 in a generic and foundational way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The Iris Model</head><p>Proving soundness of Iris involves giving a model to all its primitive assertions in an appropriate semantic domain, and then verifying correctness of every primitive rule with respect to that model. The main difficulty here is to come up with a semantic domain that is sufficient to model Iris's assertions. This domain, which we call iProp, should satisfy (roughly) the following equations:</p><formula xml:id="formula_25">iProp = World mon --→ Res mon --→ Prop (IRIS-1.0) where World N fin -⇀ iProp Res M × EX(PhyState)</formula><p>Let us look at the individual pieces: M is the RA of ghost state as picked by the user. Physical states PhyState are equipped with</p><p>Step-indexed Assertions:</p><formula xml:id="formula_26">SProp {X ∈ ℘(N) | ∀n ≥ m. n ∈ X ⇒ m ∈ X} X n = Y ∀m ≤ n. m ∈ X ⇔ m ∈ Y Discrete: ∆X X x n = y x = y Later: ◮T {next(x) | x ∈ T } next(x) n = next(y) n = 0 ∨ x n-1 = y Figure 7.</formula><p>The COFEs used as part of the Iris model the exclusive RA structure defined in §2.5, so that Res becomes the RA of resources (logical and physical) that can be owned. Prop is the domain of meta-level propositions (e.g., Coq's Prop). Res mon --→ Prop is a predicate over resources, the usual model of assertions in separation logic. Iris is an intuitionistic separation logic, which gives rise to the monotonicity requirement-owning more resources makes more assertions true. <ref type="foot" target="#foot_2">5</ref> We can easily model ghost ownership a in this domain of resource predicates.</p><p>The World keeps track of the invariants that have been created. We index the resource predicate over "possible worlds". The invariant assertion P ι is thus modeled as asserting the existence of an invariant named ι in the current world. Worlds are ordered by the extension order, i.e., allocating new invariants "grows" the world.</p><p>It is crucial to demand monotonicity of assertions with respect to that order, so that assertions cannot be invalidated by new invariants being added. Notice that the above equations are circular: World depends on iProp, which depends contravariantly on World.</p><p>Step-indexing to the rescue. To solve the circularity in the proposed definition of iProp, we use step-indexing <ref type="bibr" target="#b2">[3]</ref> to stratify the recursive domain equation. Following Birkedal et al. <ref type="bibr" target="#b6">[7]</ref>, we do this in an abstract way by working in the category COFE of Complete Ordered Family of Equivalences (COFEs), as defined in Figure <ref type="figure" target="#fig_3">6</ref>.</p><p>The key intuition behind COFEs is that elements x and y are n-equivalent, written x n = y, if they are equivalent for n steps of computation, i.e., if they cannot be distinguished by a program running for no more than n steps. It follows that, as n increases, n = becomes more and more refined (COFE-MONO). In the limit, it agrees with plain equality (COFE-LIMIT). In order to solve the recursive domain equation it is essential that COFEs are complete, i.e., that any chain has a limit. See <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b0">1]</ref> for more details.</p><p>An arrow f : T ne -→ U between two COFEs is a non-expansive function. Such functions preserve the structure defined by ( n =) (COFE-NONEXP). In other words, applying such a function to some data will not suddenly introduce differences between seemingly equal data. Elements that cannot be distinguished by programs within n steps remain indistinguishable after applying f .</p><p>The COFEs that are essential to the Iris model are defined in Figure <ref type="figure">7</ref>. The COFE of step-indexed assertions SProp represents assertions that are true for some number of steps, or forever. (SProp corresponds to the set of ordinals up to ω.) The discrete COFE ∆X turns any set X into a COFE by assigning the degenerate step-indexed equivalence. Finally, the later COFE ◮T moves the step-indexed equivalence of a COFE T up by one, thus making everything "one level more equal" than in T .</p><p>It turns out that, within the category COFE, the following recursive domain equation can be solved up to isomorphism using America and Rutten's theorem <ref type="bibr" target="#b1">[2]</ref>:</p><formula xml:id="formula_27">iProp ≈ World mon --→ ∆Res mon --→ SProp (IRIS-1.1)</formula><p>where World N fin -⇀ ◮iProp</p><formula xml:id="formula_28">Res M × EX(PhyState)</formula><p>An Iris assertion is hence indexed by a world w ∈ World, by a resource r ∈ Res, and by a step-index n ∈ N.</p><p>Compared to IRIS-1.0, the key differences are the use of SProp instead of Prop, and the ◮ in front of the recursive occurrence of iProp. The ◮ serves as a guard that introduces a stratification step. This is needed to ensure that the recursive domain equation reaches a fixed point. It is also the reason that the proof rule INV needs a sidecondition about I: Due to World actually containing ◮iProp rather than iProp, INV only holds for assertions that do not depend on the step-index, such as ghost ownership a γ . We call such assertions timeless. There is a stronger version of INV <ref type="bibr" target="#b0">[1]</ref> that works for any assertion, but it needs more care because we have to deal with the fact that I only holds at the next step-index (which is written as ⊲I).</p><p>Since the equation IRIS-1.1 only holds up to isomorphism, we have to be careful not to perform operations that are not preserved by the isomorphism. Basically, we have to make sure that we stay inside the category COFE, which in particular means that every function must be non-expansive.</p><p>However, the end user of Iris 1.1 does not have to bother much about this: Since we use the discrete COFE ∆ for Res, all functions on Res-and in particular the RA operations for composition and core-are trivially non-expansive.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Higher-Order Agreement</head><p>With the framework of the model-in particular the category COFE-set up, let us now look again at the agreement RA defined in §2.5. Remember that ultimately we would like to obtain AG(T ) for some T that may depend on iProp.</p><p>Ignoring the circularity that came up in §2.5, there is another problem with the definition of AG in that section: when the AG(T ) construction is generalized to range over a non-discrete COFE T , such as iProp, the composition operator (•) is not non-expansive. That is, given P and Q that are equal up to n steps, but not equal for all steps, i.e., P n = Q for some n while P = Q, we have:</p><formula xml:id="formula_29">ag(P ) • ag(Q) = ⊥ n = ag(P ) = ag(P ) • ag(P )</formula><p>For (•) to be non-expansive, we should have ag(P ) • ag(P ) n = ag(P ) • ag(Q), which is clearly not the case. This is not entirely surprising: agreement composition was defined in terms of equality rather than step-indexed equality.</p><p>In order to make sense of the idea of agreement over COFEs, we have to drop absolute terms like the elements being (exactly) equal and composition being (completely) defined, and instead use step-indexed versions of those terms. This is achieved by keeping track of how valid an RA element is, which we can then relate to how equal the operands of the composition were. So, we re-define AG(T ) for any COFE T : Elements a ∈ AG(T ) now consist of an a.x ∈ T (the actual data represented by a) and a set a.V defining how valid a is. The set contains those n such that a is valid for n steps of computation. Finally, the quotient by ∼ ensures that elements of AG(T ) are only equated for the number of steps for which they are valid.</p><formula xml:id="formula_30">AG(T ) {(x, V ) ∈ T × SProp} / ∼ where a ∼ b a.V = b.V ∧ ∀n ∈ a.V . a.x n = b.x a n = b (∀m ≤ n. m ∈ a.V ⇔ m ∈ b.V ) ∧ (∀m ≤ n. m ∈ a.V ⇒ a.x m = b.x) Vn {a ∈ AG(T ) | n ∈ a.V } a • b a.x, n n ∈ a.V ∧ n ∈ b.V ∧ a n = b A CMRA is a tuple (M : COFE, (Vn ⊆ M ) n∈N , |-| : M ne -→ M ? , (•) : M × M ne -→ M ) satisfying: ∀n, a, b. a n = b ∧ a ∈ Vn ⇒ b ∈ Vn (CMRA-VALID-NE) ∀n, m. n ≥ m ⇒ Vn ⊆ Vm (CMRA-VALID-MONO) ∀a, b, c. (a • b) • c = a • (b • c) (CMRA-ASSOC) ∀a, b. a • b = b • a (CMRA-COMM) ∀a. |a| ∈ M ⇒ |a| • a = a (CMRA-CORE-ID) ∀a. |a| ∈ M ⇒ ||a|| = |a| (CMRA-CORE-IDEM) ∀a, b. |a| ∈ M ∧ a b ⇒ |b| ∈ M ∧ |a| |b| (CMRA-CORE-MONO) ∀n, a, b. (a • b) ∈ Vn ⇒ a ∈ Vn (CMRA-VALID-OP) ∀n, a, b1, b2. a ∈ Vn ∧ a n = b1 • b2 ⇒ ∃c1, c2. a = c1 • c2 ∧ c1 n = b1 ∧ c2 n = b2 (CMRA-EXTEND)</formula><p>In this construction, validity of a is generalized from a "plain" assertion a ∈ V to a step-indexed assertion a ∈ Vn. Recall that validity in RAs corresponds to partiality in PCMs-we obtain a notion of two elements being composable or not. With step-indexed validity, we have a notion of elements being n-composable. You can think of this as "step-indexed partiality".</p><p>The step-indexed equality on AG(T ) propagates the one on T . This makes composition a non-expansive operation: For a1 In order to explain how we use AG, we first define an injection ag : T → AG(T ) as follows:</p><formula xml:id="formula_31">ag(x) (x, N)</formula><p>Now imagine we start with two elements x, y ∈ T . You can see that ag(x) • ag(y) is n-valid if and only if x n = y-in other words, the composition of two elements is as valid as the elements are equal. This gives rise to the following property:</p><formula xml:id="formula_32">V(ag(x) • ag(y)) ⇒ x = y (AG-VALID)</formula><p>Note that this is a statement in Iris, not in the meta-logic. Both validity and equality are actually step-indexed assertions, namely, Vn and ( n =). This implication has to be shown once and for all when defining AG; it can then be used in Iris proofs.</p><p>There is one last technical step that we have to take: AG(T ) as defined in this section does not satisfy the completeness axiom of COFEs (see Figure <ref type="figure" target="#fig_3">6</ref>). To turn AG(T ) into an actual COFE, we perform a Cauchy completeness construction (by considering chains of elements). This technical step is detailed in the appendix <ref type="bibr" target="#b0">[1]</ref> and fully formalized in Coq, as are all the constructions in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">CMRAs</head><p>The AG(T ) construction as defined in the previous section is no longer just an RA-we had to define Vn, and we had to prove nonexpansiveness of the operations. In this section we introduce the algebraic structure of CMRAs ("cameras") to abstractly characterize such "step-indexed RAs". You can find its definition in Figure <ref type="figure" target="#fig_4">8</ref>. The differences from RAs are as follows:</p><p>• The carrier needs to be a COFE, and the core and composition operations have to be non-expansive.</p><p>• The set of valid elements Vn is step-indexed. The rule CMRA-VALID-OP expresses that we need decomposition to preserve validity at every step-index. The rule CMRA-VALID-NE demands that Vn must not make a distinction between n-equal elements (this is a form of non-expansiveness), and CMRA-VALID-MONO declares that at smaller step-indices, more elements are valid.</p><p>As discussed in the previous section, Vn encodes "step-indexed partiality", which is more general than using a partial function for composition. For consistency, we decided that partiality should be handled the same for RAs and CMRAs, which is why RAs use a validity predicate as well.</p><p>• The extension axiom CMRA-EXTEND roughly states that decomposition must commute with step-indexed equivalence. This is discussed in more depth in our technical appendix <ref type="bibr" target="#b0">[1]</ref>.</p><p>Notice that every RA can be trivially turned into a CMRA by equipping it with the discrete COFE ∆ and making Vn just ignore the step-index, so that validity is the same at every n.</p><p>We can easily generalize existing RA constructions to CMRA constructions by lifting the step-indexed validity. For example, for + ⊥ from §2.5, this is done as follows: Notice that this is very similar to IRIS-1.1. The only difference is that Res is no longer discrete, but rather defined in terms of F . Similar to the case of the ◮ in World, every recursive occurrence of iProp in F needs to be guarded by a ◮ to ensure the existence of a fixed point of the recursive domain equation. (Formally that means F should be locally contractive <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b6">7]</ref>.)</p><formula xml:id="formula_33">Vn inl(a1) a1 ∈ V ′ n ∪ inr(a2) a2 ∈ V ′′</formula><p>In order to solve the challenge outlined in §1.1, recall that we wish to obtain an instantiation of Iris where the ghost state is a heap of oneshots of type T , where T may depend on iProp. Let us rewrite it as T = G(iProp) to factor out the dependency on iProp. We can then choose the following function for the ghost state:</p><formula xml:id="formula_34">F (X) N fin -⇀ ONESHOT(AG(◮G(X)))</formula><p>We will see in §4.2 that this suffices to prove the correctness of the client from §1.1.</p><p>Since F is a function between types in a category, we require it to be a bifunctor from COFE to CMRA. <ref type="foot" target="#foot_3">6</ref> This is typically easy to show. Using bifunctors, we can handle both co-and contravariant occurrences of F 's argument, e.g., if the type T is iProp → iProp, in which case G(X) X ne -→ X. Of course, if all you need is first-order ghost state, you can easily pick the constant functor F (_) = M for any CMRA or RA M . In this case, there are no further proof obligations; F trivially satisfies all the functor laws.</p><p>So, to sum this up: Iris 2.0 is parameterized over a user-selected locally contractive bifunctor F . Within the logic, the user then has F (iProp) available for the ghost state, which gives rise to arbitrary higher-order ghost state in a canonical and principled way.</p><p>Unifying worlds and resources. There is one final change in the model of Iris 2.0, compared to IRIS-1.1. Looking at IRIS-PRE-2.0, we see that World and Res are recursively referring to iProp. By equipping worlds with an appropriate CMRA structure, we can merge worlds into the resources, which means we can make resources comprise physical state, ghost state, and worlds.</p><p>What we need for this is a CMRA structure on World-but it turns out that we have already defined the right CMRA, namely, AG. One important property of invariants is that everybody involved agrees on what the invariant with a particular name is; the agreement CMRA ensures that this is the case.</p><p>This leads us to the following equation for defining the semantic model of Iris:</p><formula xml:id="formula_35">iProp ≈ Res mon --→ SProp (IRIS-2.0)</formula><p>where Res World × F (iProp) × ∆EX(PhyState)</p><formula xml:id="formula_36">World N fin -⇀ AG(◮iProp)</formula><p>Ignoring the AG, this is just the uncurried form of IRIS-PRE-2.0. However, as a consequence of this, iProp is now just a predicate over a CMRA. Practically speaking, this means that most Iris connectives can be modeled independently of worlds. Almost all connectives can be interpreted in M mon --→ SProp, completely generic in the choice of the CMRA M . This kind of abstraction and unification simplifies proving soundness of the logical rules.</p><p>Note that IRIS-2.0 brings us very close to the canonical model of traditional separation logic-using a predicate over PCMs-the core difference being step-indexing. This goes to show that even the most complicated of concurrent impredicative higher-order separation logics can be semantically reduced to the same fundamental idea. In that sense, equipping Iris with generic higher-order ghost state actually simplifies its model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Case Study: Barrier</head><p>In this section, we will show how to implement and verify the example from §1.1 using a synchronization primitive called a barrier (which one can also think of as a "oneshot channel"). We follow the implementation and specification of this primitive as presented in Dodds et al. <ref type="bibr" target="#b14">[15]</ref>. As we will see, higher-order ghost state is crucially useful both in our use of the barrier and in verifying the correctness of the barrier itself.</p><p>A barrier is a synchronization primitive offering two actions:</p><p>• Clients can wait on the barrier, which will block these processes until the barrier is triggered.</p><p>• A client can signal the barrier, which will cause all waiting clients to resume execution.</p><p>You can find the code implementing a barrier in Figure <ref type="figure" target="#fig_7">9</ref>. This implementation is fairly straightforward: A waiting client is in a busy loop until it sees the location x updated to 1. So, all that signal has to do is set the location to 1, and all current and future waiting clients will leave their busy loop.</p><p>The example client in Figure <ref type="figure" target="#fig_8">11</ref> shows how a barrier can be used to implement the pattern described in §1.1. Notice that we are actually using the same barrier to communicate with both worker threads, which is possible because a barrier can trigger multiple threads when signaled. In fact, the client given here is even more general than the one sketched in §1.1, since the worker threads </p><formula xml:id="formula_37">newbarrier λ . ref(0) signal λx. x ← 1 wait rec wait(x) = if !x = 1 then () else wait(x)</formula><formula xml:id="formula_38">P ⊢ Q recv(ℓ, P ) ⊢ recv(ℓ, Q) RECV-SPLIT recv(ℓ, P1 * P2) ⇛ recv(ℓ, P1) * recv(ℓ, P2)</formula><p>Figure <ref type="figure">10</ref>. Barrier specification are transforming their Pi into Qi, and the main thread later joins these two together to obtain Q. Before we go into details about the verification of the client, let us have a closer look at specifying the interface provided by the barrier library.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Barrier Specification</head><p>The behavior of the barrier is specified in Figure <ref type="figure">10</ref>. When initializing a barrier using newbarrier(), the resources recv(ℓ, P ) and send(ℓ, P ) are created, which can then be used by the waiting thread and signaling thread, respectively. The assertion P describes the resources the barrier has to transfer, so when calling signal(ℓ), the resource P has to be given up and is transferred to the waiting client. Conversely, when wait(ℓ) returns, the waiting client receives P .</p><p>Notice that newbarrier works for any assertion P , without the caller having to establish P or give up any resources on initialization of the barrier. In the example shown in Figure <ref type="figure" target="#fig_8">11</ref>, the assertion P is in fact only established by the "expensive computation", long after the barrier has been created.</p><p>The predicates recv(ℓ, P ) and send(ℓ, P ) are impredicative higher-order abstract predicates. This means that they are predicates describing any assertion P (higher-order), which can include occurrences of recv and send itself (impredicative), as well as e.g., Hoare triples. It is thus for example possible to send the permission for code pointers through the barrier. Finally, these predicates are defined by the implementation of the barrier, but their details are not exposed to the client (abstract).</p><p>The rule RECV-SPLIT plays an important role in proving the correctness of the client in Figure <ref type="figure" target="#fig_8">11</ref>. The client has two threads that both call wait, and thus both need a recv resource, whereas after initialization of the barrier we have just one such resource. If we can split P into two pieces P1 and P2, then we can use RECV-SPLIT to split recv(ℓ, P ) into recv(ℓ, P1) and recv(ℓ, P2). Splitting makes it possible to move the resources recv(ℓ, P1) and recv(ℓ, P2) to different threads, which then can both call wait to obtain their piece of the resource transmitted through the barrier.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Splitting and Joining the Existentials</head><p>For the verification of the example client in Figure <ref type="figure" target="#fig_8">11</ref>, we assume that we have the following Hoare triples for the main thread M and the workers Wi for i ∈ {1, 2}:</p><p>{P ′ } e {∃x:T. P } ∀x:T. {Pi} ei {Qi}</p><p>Here and below, the assertions P , Pi, Qi and Q range over a variable x of type T = G(iProp) for some bifunctor G (cf. §3.4). We furthermore assume that resources can be split and merged.</p><formula xml:id="formula_39">∀x:T. P ⇒ P1 * P2 ∀x:T. Q1 * Q2 ⇒ Q Oneshot ghost variables.</formula><p>The functor that we need to implement oneshot ghost variables is F (X) ONESHOT(AG(◮G(X))), so the ghost state is of type F (iProp) = ONESHOT(AG(◮T )). We encode oneshot ghost locations as follows:</p><p>γ ֒→ pending inl()</p><formula xml:id="formula_40">γ γ ֒→ x inr(ag(next(x)))</formula><p>γ for x : T Notice that γ ֒→ x is a persistent assertion stating that the oneshot location has been initialized. The state of location γ is obtained by injecting x into ONESHOT(AG(◮T )).</p><p>From generic properties of the oneshot and agreement CMRA we obtain the following proof rules to initialize a previously uninitialized location, and to encode that a location, once initialized, will not change its value:</p><formula xml:id="formula_41">γ ֒→ pending ⇛ γ ֒→ x (ONESHOT-INIT) γ ֒→ x * γ ֒→ y ⇒ ⊲(x = y) (ONESHOT-AGREE-LATER)</formula><p>We will now prove the latter rule (ONESHOT-AGREE-LATER) to show that it is indeed a derived rule. First of all, observe that owning γ ֒→ x * γ ֒→ y is logically equivalent to (using GHOST-OP):</p><p>inr(ag(next(x)) • ag(next(y)))</p><p>γ</p><p>By GHOST-VALID we know that we can only own valid ghost CMRA elements. In combination with AG-VALID, we thus obtain</p><formula xml:id="formula_42">next(x) = next(y)</formula><p>Finally, we use the following general property of the later construction ◮T to complete the proof of ONESHOT-AGREE-LATER:</p><formula xml:id="formula_43">next(x) = next(y) ⇔ ⊲(x = y)</formula><p>Remember that ⊲(x = y) means that x and y are equal at the next step-index. This is not a problem, since we can get rid of the ⊲ when the program performs a physical step of execution.</p><p>Verification of the worker threads. We decorated Figure <ref type="figure" target="#fig_8">11</ref> with verification conditions to document resources available at any particular point in the code. To obtain the resources needed for the worker threads, we want to split the recv using RECV-SPLIT, which first requires us to weaken the barrier assertion with RECV-MONO:</p><p>(∃x:T. γ ֒→ x * P ) ⇒ (∃x:T. γ ֒→ x * P1) * (∃x:T. γ ֒→ x * P2)</p><p>It is straightforward to verify correctness of the worker threads.</p><p>Joining the existentials. What is left to justify is the last line of Figure <ref type="figure" target="#fig_8">11</ref>: How can the two existentials be joined together? The core lemma for this step of the proof is ONESHOT-AGREE-LATER. From there, we easily obtain:</p><p>(∃x:T.γ ֒→ x * Q1) * (∃x:T.γ ֒→ x * Q1) ⇒ ⊲(∃x:T.γ ֒→ x * Q)</p><p>The ⊲ on the right hand side is then consumed by the parallel composition, when it performs a physical step of computation to join the threads back together.</p><p>This completes the verification: We demonstrated that, using the higher-order ghost state as defined in §3, we can solve the challenge posed in §1.1 for existential quantification over arbitrary types.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Verifying the Barrier Specification: Saved Propositions</head><p>As has been discussed in <ref type="bibr" target="#b14">[15]</ref>, it is very difficult to prove a specification for a barrier that includes the splitting axiom. Intuitively, the reason for this is as follows: When a thread calls send to give up But how should signal know how the resources should be split among the waiting clients? The splitting may have happened after the call to newbarrier, and yet it must be somehow communicated to signal.</p><p>To our knowledge, the only way to do this is to record the desired splitting in the global ghost state, which is accessible to both the thread that performs the splitting and to signal. This immediately means that we need to be able to have ghost state that depends on propositions-that is, arbitrary propositions of the logic (iProp), not just meta-level propositions (Prop).</p><p>One convenient way of actually going about this proof is to apply saved propositions <ref type="bibr" target="#b14">[15]</ref>. In Iris, the interface of saved propositions is as follows:</p><formula xml:id="formula_44">∀P. True ⇛ ∃γ. γ ⇒ P (SPROP-ALLOC) ∀γ, P, Q. (γ ⇒ P * γ ⇒ Q) ⇒ ⊲(P ⇔ Q) (SPROP-AGREE)</formula><p>The first rule says that we can allocate a new saved proposition P at a fresh ghost location γ. Notice that to establish a saved proposition, we do not actually have to establish that assertion. The allocated assertion γ ⇒ P is persistent. The second rule then allows us to derive, given two assertions about the same location, that they must be about the same proposition.</p><p>It is not coincidental that these rules look very similar to GHOST-ALLOC and ONESHOT-AGREE: the oneshot locations described in §4.2 are strictly more general than saved propositions. However, it is easy enough to directly encode saved propositions by defining F (X) AG(◮X) to obtain ghost state of the form AG(◮iProp).</p><p>The full proof of the barrier specification in Iris is carried out in our technical appendix <ref type="bibr" target="#b0">[1]</ref> and is formalized in Coq.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Coq Formalization</head><p>Adequacy and soundness for Iris 2.0, many derived constructions, and all specifications and proofs in this paper have been fully formalized using Coq. We discuss important aspects of the formalization, features of Coq that were essential, and the key differences between the formalization of Iris 1.0 and Iris 2.0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Algebraic Structures</head><p>The main challenge of formalizing the Iris logic is that it lives in the category of COFEs instead of the conventional category of Coq Types. So, instead of using plain Coq Types, we use types equipped with an ordered family of equivalences, and instead of plain Coq functions, we use non-expansive functions. This poses some interesting challenges:</p><p>• In Iris we use large nested COFE constructions composed from smaller COFEs (see for example the construction IRIS-2.0).</p><p>Coq should be able infer the COFE structure on these nested constructions automatically without considerable overhead.</p><p>• Defining non-expansive functions should be lightweight. Most importantly, just to write down a ∀x:T. P x or ∃x:T. P x quantification in the logic (where P : T ne -→ iProp), there should be no proof obligations.</p><p>• Rewriting with the equivalence relations n = of COFEs should work fast and reliably. Note that rewriting with n = is only possible in the context of non-expansive functions, and thus requires Coq to derive facts about non-expansiveness. In Coq, rewriting with user-defined equivalence relations is called setoid rewriting.</p><p>The Coq formalization of Iris 1.0, which used the ModuRes library <ref type="bibr" target="#b31">[32]</ref>, did not meet any of these challenges. Dealing with large COFE constructions made Coq very slow, setoid rewriting worked unreliably, and proofs of non-expansiveness cluttered definitions. The Coq formalization of Iris 2.0 has been implemented from scratch, and we have improved on all of these points.</p><p>In order to emphasize the difficulties involved, let us describe the two most commonly used patterns of representing algebraic structure (like COFEs and CMRAs in our case) in Coq.</p><p>• The bundled approach consists of representing algebraic structures as dependently typed records containing the carrier, the operations, and proofs. COFEs would thus be formalized as: In order to automatically infer algebraic structures given the Type of the carrier, Coq supports two similar mechanisms: canonical structures and type classes. Canonical structure search is guided by the fields of a record, and is thus commonly used in combination with the bundled approach <ref type="bibr" target="#b18">[19]</ref>. Type class search, on the other hand, is guided by the parameters of a record, and is thus commonly used in combination with the unbundled approach <ref type="bibr" target="#b33">[34]</ref>.</p><p>Iris 1.0 used the unbundled approach to represent COFEs, which is known to suffer from an exponential blow-up in term size when nesting instances of algebraic structures. In order to remedy this shortcoming, Iris 2.0 uses a bundled approach using canonical structures inspired by Ssreflect's <ref type="bibr" target="#b18">[19]</ref>.</p><p>Iris 1.0 demanded proofs of non-expansiveness of functions a priori pretty much everywhere. We changed this in Iris 2.0 such that for example the predicates in universal and existential quantification, and the post-condition of Hoare triples, do not a priori have to be non-expansive. This allows us to reuse Coq's functions and notation when writing down formulas in the Iris logic. Proofs of nonexpansiveness are only needed for setoid-rewriting and constructing recursive definitions, but not for validity of the proof rules, and can thus be established a posteriori. This approach matches well with Coq's setoid machinery, which uses type classes to register compatibility with equivalence relations a posteriori <ref type="bibr" target="#b32">[33]</ref>.</p><p>Although Iris 2.0 made considerable progress on the formalization challenges we posed, we do not consider these challenges to be solved. Since we need the combination of bundled algebraic structures and setoid rewriting, we are using a mixture of canonical structures and type classes, whose interaction is somewhat fragile. Most notably, many Coq tactics, including the rewrite tactic and the type class machinery, are very sensitive to terms that are only equal up to conversion (e.g., unfolding of canonical structure projections), and they often fail to infer type class arguments. In order to work around these problems, we are using the Ssreflect rewrite tactic, which deals better with these issues.</p><p>We thus welcome some machinery that unifies type classes and canonical structures in a streamlined way. Unification hints may be a step in this direction <ref type="bibr" target="#b4">[5]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Programming Language</head><p>Similar to Iris 1.0, the Coq formalization of Iris 2.0 is parameterized by the programming language that one wishes to reason about. For the purpose of this paper, we have instantiated Iris with a deeply embedded untyped ML-like language with higher-order store and the concurrency primitives fork and CAS (compare-and-swap). This improves on the Iris 1.0 formalization, which has not been instantiated with an actual programming language.</p><p>The main goal of the Iris 2.0 Coq formalization is verification of actual code, and as such, readability of programs written in the deeply embedded language becomes important. In particular:</p><p>1. We want to be able to write programs in a syntax that resembles ML, and we want programs to be pretty printed similarly to how they appear when being interactively verified.</p><p>2. Variable binding should be human-readable, hence a "machine oriented" approach like De Bruijn indexes does not suffice.</p><p>3. All programs should be closed, i.e., they should not contain free variables. The language formalization should ensure closedness of programs automatically.</p><p>We make use of Coq's expressive notation mechanism to obtain an ML-like notation for our language, we make use of named variables to make binding human-readable, and we make use of dependent types to ensure closedness of programs. Our representation of programming language expressions is roughly as follows:</p><p>Class VarBound (x : string) (X : list string) := var_bound : if decide (x∈X) then True else False. Inductive expr (X : list string) : Type := | Var x : VarBound x X → expr X | App : expr X → expr X → expr X | Lam x : expr (x :: X) → expr X. Coercion App : expr &gt;-&gt; Funclass. Notation "' x" := (Var x _). Notation "λ: x .. y , e" := (Lam x .. (Lam y e) ..).</p><p>The type expr X represents expressions whose free variables are a subset of X, and as such, expressions of type expr [ ] are guaranteed to be closed. An important part of this definition is that the condition x ∈ X for variables is decidable, and can thus be inferred by computation while type checking concrete programs. This is achieved by instrumenting the type class mechanism with a hint to solve VarBound constraints by computation:</p><p>Hint Extern 0 (VarBound _ _) =&gt; vm_compute; exact I : typeclass_instances.</p><p>Notice that we can use a named approach to variable binding without having to worry about variable capture because our language has weak reduction-i.e., we do not reduce under λs.</p><p>Example. The Coq version of the code of the barrier implementation is as follows: <ref type="foot" target="#foot_5">7</ref>Definition newbarrier : val := λ: &lt;&gt;, ref #0. Definition signal : val := λ: "x", '"x" &lt;-#1. Definition wait : val := rec: "wait" "x" := if: !'"x" = #1 then #() else '"wait" '"x".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Notable Formalization Aspects</head><p>Weakest precondition. The Hoare triples of Iris are defined in terms of a more primitive weakest precondition judgment. Since the weakest preconditions are better suited for interactive proving, we use them in our Coq proofs. Hoare-triple-based specifications-such as those in §2 and §4.1-are only established at the end.</p><p>Non-expansive functions. We have implemented a tactic to prove that functions are non-expansive by repeatedly applying congruence properties. Contrary to Coq's solve_proper, our tactic is more efficient and handles match constructs.</p><p>Combining functors. A core feature of Iris is that the structure of the ghost state can be chosen by the user. This is achieved by parameterizing the logic by a functor F ( §3.4). However, when verifying programs that consist of multiple program modules, it is likely that different program modules are in need of different functors Gi. We have used Coq's type class machinery to implement infrastructure that automatically combines these Gi to form the global functor F , so the modules can be combined in one proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Overview</head><p>The Coq development, which is entirely constructive and axiomfree, consists of the parts described in Figure <ref type="figure">12</ref>. Line counts exclude whitespace and comments. We used a support library by Krebbers <ref type="bibr" target="#b24">[25]</ref> that contains many definitions and theorems about data structures such as lists, finite sets, and finite maps. The compilation times of Iris 2.0 have improved by an order of magnitude: Compilation of the components 'Algebra' and 'Program logic' takes less than 2 minutes for Iris 2.0 vs. 23 minutes for Iris 1.0 (using an Intel Core i5-2450M, 4 threads, 2 cores). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Component</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Related Work</head><p>User-defined higher-order ghost state. Several prior logics support custom (user-defined) ghost state, via Concurroids <ref type="bibr" target="#b26">[27]</ref> or PCMs <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b38">39]</ref>. However, these logics are all restricted to first-order ghost state, since the structure of the ghost state is defined and fixed before the logic is instantiated. Some logics do have a model that can be considered to involve second-order ghost state, e.g., to justify their use of dynamically allocated locks <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b7">8]</ref>, regions <ref type="bibr" target="#b34">[35]</ref>, or invariants <ref type="bibr" target="#b23">[24]</ref>. However, this ghost state has a fixed structure, rather than being an instance of a generic algebraic structure like CMRAs.</p><p>In some of these prior logics, even though the structure of ghost state is fixed, it can sometimes be adapted cleverly to support a range of proof patterns. For example, Dodds et al. <ref type="bibr" target="#b14">[15]</ref> showed that the built-in "protocol" mechanism of the iCAP logic <ref type="bibr" target="#b34">[35]</ref> can be repurposed to encode saved propositions ( §4.3), a functionality for which it was not originally intended. However, the encoding is somewhat artificial, must be verified by direct appeal to the model of iCAP, and does not scale to support general higher-order ghost state (such as we relied on in proving the example from §1.1).</p><p>The Verified Software Toolchain (VST) of Appel et al.</p><p>[4] provides a general framework for defining higher-order logics via "indirection theory" <ref type="bibr" target="#b21">[22]</ref>. Although VST has been demonstrated to support particular forms of second-order ghost state, it is not yet clear how precisely indirection theory compares with the categorical COFE-based approach. We believe that VST can potentially be generalized to support more general higher-order ghost state in the manner of Iris 2.0. Notably, VST has a notion of PCM-like structures that are compatible with aging (step-indexing) and seem to loosely correspond to CMRAs. However, logics built using the VST typically fix a particular ghost state for their purpose and provide primitive rules for this particular ghost state, whereas Iris is designed for such proof rules to be derived inside a single logic from a few fundamental proof rules. As a result, Iris proofs using different CMRAs can be safely composed ( §2.6), whereas proofs carried out in different VST logics do not necessarily interoperate. Furthermore, VST has so far only been applied to sequential and coarse-grained concurrent code, not to fine-grained concurrent algorithms.</p><p>PCMs with a (duplicable) core. There have been several presentations of variants of PCMs that have "multiple units" or include a notion of a "duplicable core". Dockins et al. introduced multi-unit separation algebras <ref type="bibr" target="#b13">[14]</ref>, which, unlike PCMs, only demand the existence of a possibly different unit ua with ua • a = a for any element a. A crucial difference between multi-unit separation algebras and RAs is that we present the monoidal operation and core as a function, whereas they represent these as relations.</p><p>The terminology of a (duplicable) core has been adapted from Pottier, who introduced it in the context of monotonic separation algebras <ref type="bibr" target="#b29">[30]</ref>. However, the axioms of Pottier's cores, as well as those of related notions in other work <ref type="bibr" target="#b38">[39,</ref><ref type="bibr" target="#b3">4]</ref>, are somewhat different from the axioms of our RAs. Some common properties appear consistently (either as axioms, or as admissible rules): The core must produce a unit (RA-CORE-ID), be idempotent (RA-CORE-IDEM), and be a homomorphism, i.e., be compatible with composition: |a • b| = |a| • |b|. The last property is stronger than our monotonicity axiom (RA-CORE-MONO), and as such, the axioms of RAs are weaker than those demanded by prior work. In fact, RAs are strictly weaker. One of our most important RA constructions, the state-transition system (STS), <ref type="foot" target="#foot_6">8</ref> has a core that is not a homomorphism. This shows that demanding the core to be a homomorphism, as prior work has done, rules out useful instances.</p><p>Another difference is the fact that our core may be partial, whereas in prior work it was always a total function. As discussed in §2.5, partial cores make it easier to compose RAs out of simpler constructions like sums.</p><p>Coq formalizations. Over the past decade, there has been tremendous progress on formalization of program logics in proof assistants, with focus on supporting strong proof automation, as well as the ability to deal with realistic programming languages (see, e.g., <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b38">39,</ref><ref type="bibr" target="#b36">37]</ref>).</p><p>However, with the exception of the aforementioned VST, these formalized program logics do not support impredicative invariants ( §2.2), let alone higher-order ghost state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusion</head><p>We have introduced higher-order ghost state and have shown that it is a useful extension of higher-order concurrent separation logic. Moreover, we have presented Iris 2.0, an extension of the original Iris program logic with support for higher-order ghost state.</p><p>Soundness of Iris 2.0 is proven using a new model construction, which, in addition to supporting higher-order ghost state, also unifies two of the core model concepts, worlds and resources, that were distinct before. This simplifies the meta-theory, which is important not only conceptually, but also when formalizing the meta-theory of Iris in a proof assistant. We have formalized Iris 2.0 in Coq, and the formalization itself is a strong improvement over the earlier formalization of Iris 1.0.</p><p>In ongoing work, we are using the new Iris 2.0 formalization to conduct larger experiments with Iris. To support such experiments, we are in the process of developing tactic support for reasoning about concurrent higher-order programs.</p><p>In order to facilitate interactive reasoning in Iris using Coq, we have extended Coq with support for the linear context of separation logic. This extension provides named assumptions and tactical support for introduction and case analysis of these linear assumptions. Initial experiments are promising and show a significant improvement in ergonomics compared to using the rules of Iris manually.</p><p>In addition, we plan to develop tactics to reason fully automatically about client code. This will probably be done using Malecha and Bengtson's recent reflective tactics <ref type="bibr" target="#b25">[26]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>e2) | assert(e) | fork {e} | | ref(e) | !e | e ← e | CAS(e, e1, e2) | . . . (We omit the usual operations on pairs and sums.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>PERSISTENT-DUP persistent(P ) P ⇔ P * P PERSISTENT-HOARE Q ⊢ {P } e {v. R} {P * Q} e {v. R} persistent(Q)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Some Iris 1.1 proof rules</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Objects and arrows of the category COFE of COFEs</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. CMRA operations and axioms</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>n=</head><label></label><figDesc>a2, it is easy to see that a1 • b n = a2 • b (and likewise if b changes).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>n 3 . 4</head><label>34</label><figDesc>The Model of Iris 2.0 We now have everything set up to generalize Iris to higher-order ghost state. Instead of the user picking a fixed RA R, they can pick an arbitrary CMRA M that can depend on iProp. Formally, this dependency is expressed by a function F : COFE → CMRA: iProp ≈ World mon --→ Res mon --→ SProp (IRIS-PRE-2.0) where World N fin -⇀ ◮iProp Res F (iProp) × ∆EX(PhyState)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. Implementation of a barrier</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 11 .</head><label>11</label><figDesc>Figure 11. Example client of a barrier</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>Record cofeT := { cofe_car :&gt; Type; cofe_dist : nat → relation cofe_car; cofe_dist_equivalence : ∀ n, Equivalence (cofe_dist n); (* ... *) }.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>This is just one particular form of proof-specific ghost state that can be encoded as a PCM-we will see in §2.1 how to encode it.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>The notation γ ֒→ e used in §1.1 is defined in terms of the more general a γ (see §4.2).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_2"><p>In other words, the function has to be monotone with respect to the extension order (defined in Figure3) and implication on Prop.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_3"><p>The arrows of CMRA are monotone, non-expansive functions-for further details, see our technical appendix<ref type="bibr" target="#b0">[1]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_4"><p>• The unbundled approach consists of representing algebraic structures as predicates over the carrier, the operations, and proofs. COFEs would thus be formalized as: Record cofeT {A} (d : nat → relation A) := { cofe_dist_equivalence : ∀ n, Equivalence (cofe_dist n); (* ... *) }.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_5"><p>In this code, &lt;&gt; denotes an anonymous binder.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_6"><p>The RA of STSs, as well as the example demonstrating that the core is not a homomorphism, is described in our technical appendix<ref type="bibr" target="#b0">[1]</ref>.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We wish to thank Jacques-Henri Jourdan for suggesting the notion of a partial core, and Kasper Svendsen for his help with clarifying details concerning COFEs and saved propositions in iCAP.</p><p>This research was supported in part by a European Research Council (ERC) Consolidator Grant for the project "RustBelt", funded under the European Union's Horizon 2020 Framework Programme (grant agreement no. 683289); and by the ModuRes Sapere Aude Advanced Grant from The Danish Council for Independent Research for the Natural Sciences (FNU).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Higher-Order Ghost State: Appendix and Coq development</title>
		<ptr target="http://plv.mpi-sws.org/iris/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Solving reflexive domain equations in a category of complete metric spaces</title>
		<author>
			<persName><forename type="first">P</forename><surname>America</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rutten</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JCSS</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="343" to="375" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">An indexed model of recursive types for foundational proof-carrying code</title>
		<author>
			<persName><forename type="first">A</forename><surname>Appel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mcallester</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TOPLAS</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="657" to="683" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Program Logics for Certified Compilers</title>
		<editor>A. W. Appel</editor>
		<imprint>
			<date type="published" when="2014">2014</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Hints in unification</title>
		<author>
			<persName><forename type="first">A</forename><surname>Asperti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Ricciotti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Coen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Tassi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TPHOLs</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5674</biblScope>
			<biblScope unit="page" from="84" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Charge! -A Framework for Higher-Order Separation Logic in Coq</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bengtson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Birkedal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">7406</biblScope>
			<biblScope unit="page" from="315" to="331" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note>ITP</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The category-theoretic solution of recursive metric-space equations</title>
		<author>
			<persName><forename type="first">L</forename><surname>Birkedal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Støvring</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Thamsborg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TCS</title>
		<imprint>
			<biblScope unit="volume">411</biblScope>
			<biblScope unit="issue">47</biblScope>
			<biblScope unit="page" from="4102" to="4122" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Step-indexed Kripke model of separation logic for storable locks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Buisse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Birkedal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Støvring</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ENTCS</title>
		<imprint>
			<biblScope unit="volume">276</biblScope>
			<biblScope unit="page" from="121" to="143" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The Bedrock structured programming system: combining generative metaprogramming and Hoare logic in an extensible program verifier</title>
		<author>
			<persName><forename type="first">A</forename><surname>Chlipala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICFP</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="391" to="402" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Invariants, modularity, and rights</title>
		<author>
			<persName><forename type="first">E</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Alkassar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Boyarinov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dahlweid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Degenbaev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hillebrand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Langenstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Leinenbach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Moskal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Obua</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Paul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Pentchev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Petrova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Santen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Schirmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Schmaltz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Schulte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shadrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tobies</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tsyban</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tverdyshev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">5947</biblScope>
			<biblScope unit="page" from="43" to="55" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
	<note>PSI</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">TaDA: A logic for time and data abstraction</title>
		<author>
			<persName><forename type="first">P</forename><surname>Da Rocha Pinto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Dinsdale-Young</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Gardner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECOOP</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="207" to="231" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Views: Compositional reasoning for concurrent programs</title>
		<author>
			<persName><forename type="first">T</forename><surname>Dinsdale-Young</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Birkedal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Gardner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Parkinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Concurrent abstract predicates</title>
		<author>
			<persName><forename type="first">T</forename><surname>Dinsdale-Young</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dodds</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Gardner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Parkinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vafeiadis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECOOP</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="504" to="528" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A fresh look at separation algebras and share accounting</title>
		<author>
			<persName><forename type="first">R</forename><surname>Dockins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hobor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Appel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">APLAS</title>
		<imprint>
			<biblScope unit="page" from="161" to="177" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Verifying custom synchronization constructs using higher-order separation logic</title>
		<author>
			<persName><forename type="first">M</forename><surname>Dodds</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jagannathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Parkinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Svendsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Birkedal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TOPLAS</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">4</biblScope>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Local rely-guarantee reasoning</title>
		<author>
			<persName><forename type="first">X</forename><surname>Feng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="315" to="327" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">On the relationship between concurrent separation logic and assume-guarantee reasoning</title>
		<author>
			<persName><forename type="first">X</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ferreira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Shao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESOP</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="173" to="188" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Reasoning about optimistic concurrency using a program logic for history</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CONCUR</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="388" to="402" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Packaging mathematical structures</title>
		<author>
			<persName><forename type="first">F</forename><surname>Garillot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gonthier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mahboubi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Rideau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TPHOLs</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5674</biblScope>
			<biblScope unit="page" from="327" to="342" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Local reasoning for storable locks and threads</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gotsman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Berdine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Rinetzky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sagiv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">APLAS</title>
		<imprint>
			<biblScope unit="page" from="19" to="37" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Oracle semantics for concurrent separation logic</title>
		<author>
			<persName><forename type="first">A</forename><surname>Hobor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Appel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">Zappa</forename><surname>Nardelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESOP</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="353" to="367" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A theory of indirection via approximation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Hobor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Dockins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Appel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">High-level separation logic for low-level code</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Benton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kennedy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="301" to="314" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Iris: Monoids and invariants as an orthogonal basis for concurrent reasoning</title>
		<author>
			<persName><forename type="first">R</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Swasey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Sieczkowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Svendsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Turon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Birkedal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dreyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="637" to="650" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">The C standard formalized in Coq</title>
		<author>
			<persName><forename type="first">R</forename><surname>Krebbers</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
		<respStmt>
			<orgName>Radboud University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Easy and efficient automation through reflective tactics</title>
		<author>
			<persName><forename type="first">G</forename><surname>Malecha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bengtson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESOP</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Communicating state transition systems for fine-grained concurrent resources</title>
		<author>
			<persName><forename type="first">A</forename><surname>Nanevski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ley-Wild</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Sergey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">A</forename><surname>Delbianco</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESOP</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="290" to="310" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Resources, concurrency, and local reasoning</title>
		<author>
			<persName><forename type="first">P</forename><surname>O'hearn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TCS</title>
		<imprint>
			<biblScope unit="volume">375</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="271" to="307" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Verifying properties of parallel programs: An axiomatic approach</title>
		<author>
			<persName><forename type="first">S</forename><surname>Owicki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gries</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CACM</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="279" to="285" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Syntactic soundness proof of a type-and-capability system with hidden state</title>
		<author>
			<persName><forename type="first">F</forename><surname>Pottier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JFP</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="38" to="144" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Mechanized verification of fine-grained concurrent programs</title>
		<author>
			<persName><forename type="first">I</forename><surname>Sergey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Nanevski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Banerjee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="77" to="87" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">ModuRes: A Coq library for modular reasoning about concurrent higher-order imperative programming languages</title>
		<author>
			<persName><forename type="first">F</forename><surname>Sieczkowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bizjak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Birkedal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">9236</biblScope>
			<biblScope unit="page" from="375" to="390" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
	<note>ITP</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">A new look at generalized rewriting in type theory</title>
		<author>
			<persName><forename type="first">M</forename><surname>Sozeau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JFR</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="41" to="62" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Type classes for mathematics in type theory</title>
		<author>
			<persName><forename type="first">B</forename><surname>Spitters</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Van Der Weegen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">MSCS</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="795" to="825" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Impredicative concurrent abstract predicates</title>
		<author>
			<persName><forename type="first">K</forename><surname>Svendsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Birkedal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESOP</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="149" to="168" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Modular reasoning about separation of concurrent data structures</title>
		<author>
			<persName><forename type="first">K</forename><surname>Svendsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Birkedal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Parkinson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESOP</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="169" to="188" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Types, bytes, and separation logic</title>
		<author>
			<persName><forename type="first">H</forename><surname>Tuch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Norrish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="97" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Unifying refinement and Hoarestyle reasoning in a logic for higher-order concurrency</title>
		<author>
			<persName><forename type="first">A</forename><surname>Turon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dreyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Birkedal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICFP</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="377" to="390" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">GPS: navigating weak memory with ghosts, protocols, and separation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Turon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vafeiadis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dreyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="691" to="707" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">A marriage of rely/guarantee and separation logic</title>
		<author>
			<persName><forename type="first">V</forename><surname>Vafeiadis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Parkinson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CONCUR</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="256" to="271" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
