<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Sampling from Large Graphs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jure</forename><surname>Leskovec</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computer Science</orgName>
								<orgName type="institution">Carnegie Mellon University Pittsburgh</orgName>
								<address>
									<region>PA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Christos</forename><surname>Faloutsos</surname></persName>
							<email>christos@cs.cmu.edu</email>
							<affiliation key="aff1">
								<orgName type="department">School of Computer Science</orgName>
								<orgName type="institution">Carnegie Mellon University Pittsburgh</orgName>
								<address>
									<region>PA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Sampling from Large Graphs</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">E6AE979A77F93C98458300BEBB3D79F5</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T10:36+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>H2.84 [Database Management]: Database Applications -Data Mining Measurement</term>
					<term>Experimentation graph sampling</term>
					<term>graph mining</term>
					<term>scaling laws</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Given a huge real graph, how can we derive a representative sample? There are many known algorithms to compute interesting measures (shortest paths, centrality, betweenness, etc.), but several of them become impractical for large graphs. Thus graph sampling is essential.</p><p>The natural questions to ask are (a) which sampling method to use, (b) how small can the sample size be, and (c) how to scale up the measurements of the sample (e.g., the diameter), to get estimates for the large graph. The deeper, underlying question is subtle: how do we measure success?</p><p>We answer the above questions, and test our answers by thorough experiments on several, diverse datasets, spanning thousands nodes and edges. We consider several sampling methods, propose novel methods to check the goodness of sampling, and develop a set of scaling laws that describe relations between the properties of the original and the sample.</p><p>In addition to the theoretical contributions, the practical conclusions from our work are: Sampling strategies based on edge selection do not perform well; simple uniform random node selection performs surprisingly well. Overall, best performing methods are the ones based on random-walks and "forest fire"; they match very accurately both static as well as evolutionary graph patterns, with sample sizes down to about 15% of the original graph.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Given a large massive graph with millions or billions of nodes, how can we create a small, but "good" sample out of it? In many applications we need to run expensive algorithms, like simulations of internet routing protocols, peerto-peer gossip-like protocols, virus propagation and immunization policies, or analysis of "viral marketing" scenarios.</p><p>For example, in studies of Internet routing protocols computer communication researchers would like to do detailed simulations of BGP (Border Gateway Protocol), or flow level simulations, but the simulations on networks with more than a few thousand nodes may be prohibitively expensive <ref type="bibr" target="#b4">[4]</ref>.</p><p>The questions we ask here are:</p><p>• What is a good sampling method? Should we pick random nodes? Random edges? Use some other strategy?</p><p>• What is a good sample size?</p><p>• How do we measure the goodness of a single sample, as well as the goodness of a whole sampling method?</p><p>For the last question, we need to address two aspects: What do we compare against? Do we want the sample graph S to have similar (or scaled-down) properties as compared to the original graph G? Or, do we want the sample S to be similar to what the graph G looked like back in the time when it had the size of S? We refer to the former goal as Scale-down goal, and to the latter as Back-in-time goal.</p><p>Next issue is to define a list of graph properties that we should aim for. The properties would be, say, the shape of the degree distribution should be heavy tailed; small diameter, etc. Our goal here is not to find a sampling procedure and the corresponding (unbiased) estimator (scaling rule) for a single property of the graph (e.g. number of edges, diameter). We are more interested in finding a general sampling method that would match a full set of graph properties so that sampled graphs can be used to for simulations and more complicated/expensive experiments.</p><p>The main results of this work are the following:</p><p>• We propose two different goals on sampling: the Backin-time goal and the Scale-down goal.</p><p>• For each of the above goals, we provide the most thorough analysis and comparison in the published literature, testing multiple sampling algorithms <ref type="bibr" target="#b10">(10)</ref>, on several real datasets <ref type="bibr" target="#b5">(5)</ref>, with 14 graph properties and patterns, using 2 different evaluation methods.</p><p>• We perform a systematic evaluation of sampling algorithms, introducing non-trivial statistical evaluation methods (the Kolmogorov-Smirnov D-statistic and random walk inspired ideas), that go beyond simple eye-balling.</p><p>Best performing sampling methods are the following: for the Scale-down sampling goal, methods based on random walks perform best, since they are are biased towards high degree nodes and give sampled graphs that are connected. For the Back-in-time sampling goal, we find out that "Forest Fire" type sampling and sampling based on PageRank score of a node perform best. These methods are not as biased and thus nicely mimic the temporal evolution of the graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RELATED WORK</head><p>Sampling on graphs has been used in many different flavors but very little has been done on matching a large set of graph properties. Previous work focused on using sampling to condense the graph to allow for better visualization <ref type="bibr" target="#b7">[7,</ref><ref type="bibr" target="#b12">12]</ref>. Works on graph compression focused on transforming the graph to speed up algorithms <ref type="bibr">[6]</ref>. Techniques for efficiently storing and retrieving the web-graph were also studied <ref type="bibr" target="#b1">[1]</ref>. Internet modeling community <ref type="bibr" target="#b8">[8]</ref> studied sampling from undirected graphs and concluded that some graph properties can be preserved by random-node selection with sample sizes down to 30%. A recent work <ref type="bibr" target="#b2">[2]</ref> studies separability and stability of various graph properties for a number of different graph generation algorithms.</p><p>A seemingly related, but vastly different problem comes from the area of web-crawling or P2P networks, where the question is, how to select a random node from a graph, if we only see a neighborhood <ref type="bibr" target="#b15">[15]</ref>. This problem is not related to ours, because we do have the full graph, and we can easily pick nodes at random -the challenge for us is to select a set of nodes so that the induced graph obeys general characteristics, and so the sampled graphs can be used for simulations and further analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">PROPOSED METHOD</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Problem definition</head><p>In graph sampling we are given a large directed target graph and the task is to create a small sample graph, that will be similar (have similar properties). There are two ways to look at the graph sampling: under the Scale-down goal we want to match the static target graph, while under the Back-in-time goal we want to match its temporal evolution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Scale-down sampling goal</head><p>In Scale-down sampling we are given a large static directed graph G on n nodes. We are also given the size of the sample n . The goal is to create a sample graph S on n nodes, n n, that will be most similar to G, i.e. we want S to have similar graph properties as G. For example, similar degree distribution and/or diameter. We precisely define "similar" in section 3.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Back-in-time sampling goal</head><p>The Back-in-time sampling goal corresponds to traveling back in time and trying to mimic the past versions of G, of which we only get to observe the final, static snap-shot. Note that we also do not know the ages of nodes and edges. Let G n denote graph G at some point in time, when it had exactly n nodes. Now, we want to find a sample S on n nodes that is most similar to graph G n , i.e. when graph G was of the same size as S.</p><p>The hard part here is that we want to match patterns describing the temporal evolution together with the patterns defined on a single snapshot of a graph, which also change over time. If one would have node ages, then the best possible approach would be to simply roll-back the evolution (addition/deletion of nodes and edges over time). Note that our sampling algorithms do not know the age of individual nodes and edges. So the question here is whether we can roll-back the time without having any temporal information (age of nodes/edges).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Evaluation techniques</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Criteria for a static snapshot of a graph</head><p>First, we present a set of static graph patterns, which are measured on a single snapshot of a graph. Given a graph, we measure the following nine graph properties. Essentially we treat all as distributions to allow for proper scaling:</p><p>• S1: In-degree distribution: for every degree d, we count the number of nodes with in-degree d. Typically it follows a power-law and some other heavy tailed distribution <ref type="bibr" target="#b5">[5]</ref>.</p><p>• S2: Out-degree distribution.</p><p>• S3: The distribution of sizes of weakly connected components ("wcc"): a set of nodes is weakly connected if for any pair of nodes u and v there exists an undirected path from u to v.</p><p>• S4: The distribution of sizes of strongly connected components ("scc"): a set of nodes is strongly connected, if for any pair of nodes u and v, there exists a directed path from u to v and from v to u.</p><p>• S5: Hop-plot: the number P (h) of reachable pairs of nodes at distance h or less; h is the number of hops <ref type="bibr" target="#b11">[11]</ref>.</p><p>• S6: Hop-plot on the largest WCC.</p><p>• S7: The distribution of the first left singular vector of the graph adjacency matrix versus the rank.</p><p>• S8: The distribution of singular values of the graph adjacency matrix versus the rank. Spectral properties of graphs often follow a heavy-tailed distribution <ref type="bibr" target="#b3">[3]</ref>.</p><p>• S9: The distribution of the clustering coefficient C d [16] defined as follows. Let node v have k neighbors; then at most k(k -1)/2 edges can exist between them. Let Cv denote the fraction of these allowable edges that actually exist. Then C d is defined as the average Cv over all nodes v of degree d.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Criteria for temporal graph evolution</head><p>We also study the five temporal graph patterns, that are measured on a sequence of graphs over time. Essentially, we measure a single number (e.g., diameter) of a graph and see how it evolves with the graph size. Thus, we treat all these criteria as distributions: each is a set of numbers, with one number for each time-tick (a desirable sample size n ).</p><p>• T1: Densification Power Law (DPL) <ref type="bibr" target="#b9">[9]</ref>: number of edges versus the number of nodes over time. DPL states that e(t) ∝ n(t) a . The densification exponent a is typically greater than 1, implying that the average degree of a node in the graph is increasing over time.</p><p>• T2: The effective diameter of the graph over time, which is defined as the minimum number of hops in which 90% of all connected pairs of nodes can reach each other. It has been observed that the effective diameter generally shrinks or stabilizes as the graph grows with time <ref type="bibr" target="#b9">[9]</ref>.</p><p>• T3: The normalized size of the largest connected component (CC) over time.</p><p>• T4: The largest singular value of graph adjacency matrix over time.</p><p>• T5: Average clustering coefficient C over time <ref type="bibr" target="#b16">[16]</ref>: C at time t is the average Cv of all nodes v in graph at time t.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.3">Statistical tests for graph patterns</head><p>To compare the two graph patterns (static or temporal) we use the Kolmogorov-Smirnov D-statistic. Usually Dstatistics is applied as a part of Komogorov-Smirnov test to reject the null hypothesis. Here we simply use it to measure the agreement between the two distributions. It is defined as D = maxx{|F (x) -F (x)|}, where x is over the range of the random variable, and F and F are the two empirical cumulative distribution functions of the data. Note that the D-statistic does not address the issue of the scaling but rather compares the shape of the (normalized) distribution.</p><p>Evaluation procedure: we use the D-statistic for both the Scale-down and Back-in-time sampling goals to measure the agreement between the true and the sample graph property:</p><p>For the Scale-down sampling goal, we are given a sample graph S on n nodes and a target G on n nodes, n n. We measure the 9 distributions for static graphs, on both G and S, and compare them using the D-statistic. We logarithmically bin the x-axis for all the distributions S1-S9.</p><p>In case of Back-in-time sampling goal, we are given a sequence Gt of snap-shots of a temporally evolving graph G. We are also given a sequence of sample graphs St, where for every t, St and Gt have the same number of nodes. For each t, we measure 9 distributions for static graphs on Gt and St and compare them. We also measure 5 temporal graph patterns on both sequences of graphs and compare them using the D-statistic. Given that we have data on graphs over time, we can perform the exact evaluation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.4">Visiting probability</head><p>The intuition we use here is that in a good sample the probability that a random walk, which starts at node v, visits node w should be similar in sample S and target G. For every node v in G (S) we calculate the the stationary probability of a random walk starting at node v. We then use Frobenius norm to measure the difference in visiting probability. Due to space limitations we refer the reader to extended version of the paper for details on these experiments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Sampling algorithms</head><p>Conceptually we can split the sampling algorithms into three groups: methods based on randomly selecting nodes, randomly selecting edges and the exploration techniques that simulate random walks or virus propagation to find a representative sample of the nodes.</p><p>As it will turn out in section 4, for Scale-down sampling goal random walks perform best, while in Back-in-time sampling "Forest Fire" performs best.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Sampling by random node selection</head><p>First, we introduce three sampling algorithms based on random node selection. The most obvious way to create a sample graph is to uniformly at random select a set of nodes N and a sample is then a graph induced by the set of nodes N . We call this algorithm the Random Node (RN) sampling. Authors in <ref type="bibr" target="#b14">[14]</ref> showed that RN does not retain power-law degree distribution. Note that here we are not interested in limiting behavior or discussions whether a distribution is a power-law or not. We simply want to find best sampling method that gives the most similar degree distribution. So, our conclusions are valid even if the original graph deviates from exact power-law (which is often the case in practice).</p><p>In contrast to uniform we also explore non-uniform sampling strategies. One way is to set the probability of a node being selected into the sample to be proportional to its PageRank weight. We refer to this as Random PageRank Node (RPN) sampling. Random Degree Node (RDN) sampling has even more bias towards high degree nodes. Here the probability of a node being selected is proportional to its degree. Intuitively this method will have problems matching degree distribution, since there are too many high degree nodes in the sample. We also expect it to give samples that are very dense.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">Sampling by random edge selection</head><p>Similarly to selecting nodes at random, one can also select edges uniformly at random. We refer to this algorithm as Random Edge (RE) sampling. There are several problems with this idea: sampled graphs will be very sparsely connected and will thus have large diameter and will not respect community structure. A slight variation of random nodes is Random Node-Edge (RNE) sampling, where we first uniformly at random pick a node and then uniformly at random pick an edge incident to the node. Intuitively, RE sampling is slightly biased to high degree nodes, since they have more edges incident to them. RNE does not have this bias.</p><p>Based on recommendation from <ref type="bibr" target="#b8">[8]</ref> we also implemented the Hybrid (HYB) approach, where with probability p we perform a step of RNE sampling and with probability 1 -p we perform a step of RE sampling. We set p = 0.8, which was found to perform best <ref type="bibr" target="#b8">[8]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.3">Sampling by exploration</head><p>The common idea in this family of sampling techniques is that we first select a node uniformly at random and then explore the nodes in its the vicinity.</p><p>In Random Node Neighbor (RNN) sampling we select a node uniformly at random together with all of its out-going neighbors. This is suitable for very large disk resilient graphs since it imitates reading an edge file. As we will see it matches well the out-degree distribution, but fails in matching in-degrees and the community structure.</p><p>Next, we present two ideas based on random walks. First, in Random Walk (RW) sampling, we uniformly at random pick a starting node and then simulate a random walk on the graph. At every step with probability c = 0.15 (the value commonly used in literature) we fly back to the starting node and re-start the random walk. There is problem of getting stuck, for example, if the starting node is a sink, and/or it belongs to a small, isolated component. The solution is: If, after a very long number of steps, we do not visit enough nodes to meet the required sample size, we select another starting node and repeat the procedure. In our experiments we run the random walk for 100 * n steps.</p><p>A very similar idea to Random Walk sampling is the Random Jump (RJ) sampling. The only difference here is that with probability c = 0.15 we randomly jump to any node in the graph. Note that this algorithm does not have problems of getting stuck or not being able to visit enough nodes.</p><p>The Forest Fire (FF) sampling is inspired by the work on temporal graph evolution. We randomly pick a seed node and begin "burning" outgoing links and the corresponding nodes. If a link gets burned, the node at the other endpoint gets a chance to burn its own links, and so on recursively. Model has two parameters: forward (p f ) and backward (p b ) burning probability. The exact definition is given in <ref type="bibr" target="#b9">[9]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.4">Other sampling strategies</head><p>One could easily think of other simple sampling strategies. In particular, authors in <ref type="bibr" target="#b8">[8]</ref> also explore contraction based methods, and depth and breath first search graph traversal, but none of them performed well overall.  One could also use ideas from graph clustering and graph partitioning. These algorithms are usually computationally intensive and do not scale well to very large graphs. Graph sampling becomes important with massive graphs, where real-world algorithms become too expensive and one has to reside to sampling. Thus simplicity of sampling is essential.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">EXPERIMENTAL EVALUATION</head><p>In the following section we present the results of experiments on several real graphs. We show results for both Scale-down and Back-in-time sampling goals. We also explore how the quality of the sample degrades with the sample size and conclude with a set of scaling rules that help is scale the properties of the sample to the target graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Dataset description</head><p>We consider five different datasets: a static graph and four graph with temporal information, which allows us to also evaluate them for the Back-in-time sampling goal.</p><p>Citation networks: The HEP-TH and HEP-PH citation graphs from the e-print arXiv and covers all the citations within a dataset of n=29,555 papers with e= 352,807 citations, and n=30,567, e=348,721 respectively. The data in both graphs covers papers from Jan 1992 to Apr 2003 (10 years) and represents essentially the complete history of the section. For each year Y (1992 ≤ Y ≤ 2003) we create a citation graph using all papers published before year Y .</p><p>Autonomous systems: A graph of routers comprising the Internet can be organized into sub-graphs called Autonomous Systems (AS) <ref type="bibr" target="#b10">[10]</ref> . The dataset contains 735 daily instances spanning 785 days from November 8 1997 to January 2 2000. Graphs range in size from n=3,011 and e=10,687 to n=6,474 and e=26,467. To mimic the temporal evolution we took 20 graphs uniformly spanning the number of nodes between the largest and the smallest AS graph.</p><p>Bipartite affiliation network: Using the arXiv data, we also constructed a bipartite affiliation graph. There is a node for each paper and for each author, and an edge connecting people to the papers they authored. The network is derived from the astro physics category in the arXiv. We place a time-stamp on each node: the submission date of each paper, and for each person, the date of their first submission to the arXiv. The data for affiliation graph covers the period from April 1992 to March 2002. It has n=57,381 nodes (19,393 authors, 37,988 papers) and e=133,170 edges.</p><p>Network of trust is a static snapshot of a who-trustswhom network from epinions.com <ref type="bibr" target="#b13">[13]</ref>. We only had access to a single snapshot of the network, which contains n=75,879 nodes and e=508,960 edges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Scale-down sampling goal</head><p>We begin by introducing the experimental results on Scaledown sampling, where the goal is to create a sample graph S, that will match the properties of the target graph G.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Matching the graph patterns</head><p>First we present illustrative examples of behavior of sampling algorithms from section 3.3. We run each algorithm ten times on each of five datasets and plot the patterns.</p><p>Figure <ref type="figure" target="#fig_1">1</ref>(a) shows the in-degree distribution of target and the sampled graphs for a sample size of 10%. For presentational purposes we do not plot the results of all 10 sampling algorithms. We notice three qualitatively different behaviors: RDN, RJ and RW sampling algorithms observe very similar behavior -we only show RW. These algorithms are biased towards high degree nodes and densely connected parts of the graph. Observe how the tail of degree distribution is over estimated at the cost of under represented nodes with small degrees. The second class consists of FF, RPN and RN (we only plot FF), which are not biased towards high degree nodes. Observe that degree distribution is well matched and has about the same shape (slope) as the true degree distribution. The last cluster are RE, RNE and HYB, which are all based on random edge selection. When the size of the sample is small, the resulting samples are very sparsely connected, the high degree nodes are underrepresented and the slope of degree distribution is too steep. We notice roughly the same three classes of behavior with the same members for most of our experiments.</p><p>Figure <ref type="figure" target="#fig_1">1</ref>(b) plots the logarithmically binned distribution of clustering coefficient. The plot shows the average fraction of triangles present around the nodes of degree d. Intuitively, it gives us clues about the community structure in the graph. We make the following observations:</p><p>The sample size is small, so the RN and RNN are far off. Edge selection techniques (RE, RNE and HYB) give too sparse samples which contain no triangles. FF works fine.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Evaluation using the D-statistic</head><p>Next, we evaluate the sampling algorithms against all 14 graph static and temporal patterns. We present the results in table <ref type="table" target="#tab_0">1</ref>. Each entry in the table is obtained by averaging the D-statistic over 10 runs, 5 datasets, and 20 sample sizes per dataset. For Scale-down sampling criteria the temporal patterns are essentially flat, since regardless of a sample size we want to match the property of the final graph.</p><p>For each column we bolded the best scoring algorithm. Notice that FF, RW and RPN fit well the degree distribution. Distribution of weakly connected components is best matched by edge selection techniques. The distribution of the number of reachable pairs of nodes at particular distance (column denoted as hops) is best matched by FF and RPN. Singular values and first left singular vector of graph adjacency matrix are best approximated using RW and FF. Exploration methods match the clustering coefficient.</p><p>For temporal graph patterns in table <ref type="table" target="#tab_0">1</ref> we see that RW performs best. This means that properties of sample graphs obtained by RW algorithm, have very stable and flat temporal patterns, e.g. as we see on figure <ref type="figure" target="#fig_3">2</ref> the diameter remains almost constant and the graph is highly connected.</p><p>We omit the results for difference in random walk node visiting probability between the sample and the target graph. We note the results were very similar to those on table  We set the RW random walk returning probability to high value of 0.8, which means we were basically performing breath first search from the starting node. For FF we set p f = 0.7 and p b = 0, so the fire burned 2.3 nodes on average.</p><p>All in all the results suggest that there is no single perfect answer to graph sampling. Depending on particular application and properties of interest one would choose appropriate method, with exploration methods performing best overall.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Back-in-time sampling goal</head><p>A second approach to sampling is the Back-in-time sampling goal. Here we do not to match the properties of the final target graph G, but rather match G as it grew and evolved. This means that we compare the patterns from a sample graph S on n nodes with the target graph G, when it was of the same size as S. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">Matching the graph properties</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2">Evaluation using the D-statistic</head><p>We use the same evaluation strategy as in previous section. We refer to extended version of the paper for the exact results. Overall, FF performed best (average D-statistic 0.13), closely followed RPN(0.14). Second group was then formed by RN, RW with D-stat of 0.16. Again, edge selection performed worst. We obtained best results when setting FF p f = 0.2, which means it burned 0.25 nodes on average.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.3">Sensitivity analysis of parameter values</head><p>For RW and RJ the probability of random jump was set to 0.15. For Forest Fire (FF) and Back-in-time goal, we obtain good results for 0 ≤ p f ≤ 0.4, where D-statistic is below 0.16, obtaining the best D-statistic of 0.13 at p f = 0.20. For Scale-down goal best performance was obtained with high values of p f (p f ≥ 0.6) where every fire eventually floods the connected component.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">How small sample to take?</head><p>Last, we explore how the quality of the sample degrades with the sample size. Figure <ref type="figure" target="#fig_2">3</ref> shows performance of sampling algorithms for both Scale-down and Back-in-time sampling goals. We plot the D-statistic as a function of sample size. Notice that edge selection techniques perform bad on both Scale-down and Back-in-time sampling goals. For Scale-down sampling, up to 50% sample size exploration and node selection techniques perform about the same. As the sample size gets smaller, RW, RJ and RDN start to outperform FF, RN and RPN. For Back-in-time sampling goal the situation is reversed. Performance of RW, RJ and RDN sampling algorithms slowly degrades as the sample size decreases. On the contrary, FF, RN and RPN perform much better. Also notice that quality of the sample decreases much slower. For Back-in-time sampling goal we are able to obtain good samples of size only around 15 percent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Scaling rules</head><p>Assuming we use Random Walk (RW) sampling for Scaledown and Forest Fire (FF) sampling for Back-in-time goal, with moderate sampling sizes (≈ 25%), we find the scaling rules shown in table 2. Most of them are very simple, since the sampling does a good job of matching the patterns.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">CONCLUSION</head><p>Generating smaller, "realistic" samples of larger graphs is an important tool for large graph analysis, and what-if scenarios. Besides the task of coming up with a good sampling algorithm our work addresses a subtle questions: What do  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX A. APPENDIX</head><p>Here we present additional material on graph sampling that is not presented in the conference version of the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1 Forest Fire sampling algorithm</head><p>First, we give the exact definition and the algorithm for the Forest Fire sampling.</p><p>We first choose node v uniformly at random. We then generate a random number x that is geometrically distributed with mean p f /(1 -p f ). Node v selects x out-links incident to nodes that were not yet visited. Let w1, w2, . . . , wx denote the other ends of these selected links. We then apply this step recursively to each of w1, w2, . . . , wx until enough nodes have been burned. As the process continues, nodes cannot be visited a second time, preventing the construction from cycling. If the fire dies, then we restart it, i.e. select new node v uniformly at random. We call the parameter p f the forward burning probability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 Back-in-time sampling goal</head><p>Table <ref type="table" target="#tab_1">3</ref> shows the Kolmogorov-Smirnov D-statistic for Back-in-time sampling. For each of the four temporally evolving graphs we run each of ten sampling algorithms ten times and report average D-statistic over all runs and sample sizes. This means each cell in table <ref type="table" target="#tab_1">3</ref> is the average over more than 500 different runs of sampling.</p><p>Notice how Forest Fire (FF) sampling algorithm performs best for the most of the graph patterns. Also, notice that even for static patterns it performs better than node selection and exploration methods in Scale-down sampling goal (table <ref type="table" target="#tab_0">1</ref>). This means that static patterns also exhibit evolution, e.g. degree distribution changes as the graph grows, and Forest Fire is able to capture this evolutionary pattern.</p><p>For Back-in-time sampling we obtained best results when setting FF p f = 0.2. The Forest Fire burned 0.25 nodes on the average, which means it explored very little of the node's vicinity and was pretty much similar to random node sampling.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.3 Parameter sensitivity</head><p>Figure <ref type="figure">4</ref> shows the average Kolmogorov-Smirnov D-statistic for Scale-down and Back-in-time sampling goals. We vary the parameter value: for Forest Fire this is the forward burning probability (p f ), for Page Rank Random Node, Random Walk and Random Jump sampling this is the probability of a random surfer jumping to a random node or back to starting node in case of Random Walk sampling.</p><p>Notice that for Forest Fire and the Scale-down goal (figure 4(a)) best performance was obtained with high values the burning probability: p f ≥ 0.6. Random Jump performs poorly all the time. Random Walk works best for low parameter values.</p><p>In case of Back-in-time sampling goal (figure <ref type="figure">4</ref>(a)) we observe the following: For Forest Fire (FF) and Back-in-time goal, we obtain good results for 0 ≤ p f ≤ 0.4, where Dstatistic is below 0.16, obtaining the best D-statistic of 0.13 at p f = 0.20. Notice that for both the Page Rank Random Node sampling and the Forest Fire the quality of sampling gets worse as one increases the parameter value (burning / teleportation probability). For Random Jump and Random Walk sampling we obtain best results with high jumping probability, which means the sampling algorithm behaves very much like sampling nodes uniformly at random. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Static graph patterns</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>S1: In-degree (b) S9: Clustering coef.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Scale-down sampling goal</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Scale-down sampling goal</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 (</head><label>2</label><figDesc>Figure 2(a) plots the Densification Power Law. Again notice 3 types of behavior. RW and RDN give too dense graphs, edge selection techniques (RE, RNE and HYB) result in too sparse graphs that start to rapidly fill-in the missing edges when the sample size gets large. FF, RN and RPN match the temporal densification of the true graph. Plot for the effective diameter on figure 2(b) shows that edge selection techniques give samples with too high diameter. On contrary, RW, RJ and RDN have constant diameter, which is good for Scale-down sampling. And, FF, RN and RPN match the shrinking diameter of the true graph over time quite well. Similar observations can be done for the size of connected component and average clustering coefficient over time (figures 2(c), (d)). RW, RJ and RDN give connected graph with constant clustering coefficient. Edge selection techniques produce disconnected graphs and thus underestimate the clustering. FF, RN and RPN match the size of connected component and clustering over time.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>T2: Diameter vs. time (c) T3: Size of CC vs. time (d) T5: Clustering vs. time</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 2 :Figure 4 :</head><label>24</label><figDesc>Figure 2: Back-in-time sampling goal for HEP-PH citation graph. FF and RPN match well the true patterns.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>1. Scale-down sampling criteria. On average RW and FF perform best.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">Static graph patterns</cell><cell></cell><cell></cell><cell cols="4">Temporal graph patterns</cell></row><row><cell></cell><cell cols="2">in-deg out-deg</cell><cell>wcc</cell><cell>scc</cell><cell>hops</cell><cell cols="3">sng-val sng-vec clust</cell><cell>diam</cell><cell cols="2">cc-sz sng-val</cell><cell>clust</cell><cell>AVG</cell></row><row><cell>RN</cell><cell>0.084</cell><cell>0.145</cell><cell cols="3">0.814 0.193 0.231</cell><cell>0.079</cell><cell>0.112</cell><cell>0.327</cell><cell>0.074</cell><cell>0.570</cell><cell>0.263</cell><cell>0.371</cell><cell>0.272</cell></row><row><cell>RPN</cell><cell>0.062</cell><cell>0.097</cell><cell cols="3">0.792 0.194 0.200</cell><cell>0.048</cell><cell>0.081</cell><cell>0.243</cell><cell>0.051</cell><cell>0.475</cell><cell>0.162</cell><cell>0.249</cell><cell>0.221</cell></row><row><cell>RDN</cell><cell>0.110</cell><cell>0.128</cell><cell cols="3">0.818 0.193 0.238</cell><cell>0.041</cell><cell>0.048</cell><cell>0.256</cell><cell>0.052</cell><cell>0.440</cell><cell>0.097</cell><cell>0.242</cell><cell>0.222</cell></row><row><cell>RE</cell><cell>0.216</cell><cell>0.305</cell><cell cols="3">0.367 0.206 0.509</cell><cell>0.169</cell><cell>0.192</cell><cell>0.525</cell><cell>0.164</cell><cell>0.659</cell><cell>0.355</cell><cell>0.729</cell><cell>0.366</cell></row><row><cell>RNE</cell><cell>0.277</cell><cell>0.404</cell><cell cols="3">0.390 0.224 0.702</cell><cell>0.255</cell><cell>0.273</cell><cell>0.709</cell><cell>0.370</cell><cell>0.771</cell><cell>0.215</cell><cell>0.733</cell><cell>0.444</cell></row><row><cell>HYB</cell><cell>0.273</cell><cell>0.394</cell><cell cols="3">0.386 0.224 0.683</cell><cell>0.240</cell><cell>0.251</cell><cell>0.670</cell><cell>0.331</cell><cell>0.748</cell><cell>0.256</cell><cell>0.765</cell><cell>0.435</cell></row><row><cell>RNN</cell><cell>0.179</cell><cell>0.014</cell><cell cols="3">0.581 0.206 0.252</cell><cell>0.060</cell><cell>0.255</cell><cell>0.398</cell><cell>0.058</cell><cell>0.463</cell><cell>0.200</cell><cell>0.433</cell><cell>0.258</cell></row><row><cell>RJ</cell><cell>0.132</cell><cell>0.151</cell><cell cols="3">0.771 0.215 0.264</cell><cell>0.076</cell><cell>0.143</cell><cell>0.235</cell><cell>0.122</cell><cell>0.492</cell><cell>0.161</cell><cell>0.214</cell><cell>0.248</cell></row><row><cell>RW</cell><cell>0.082</cell><cell>0.131</cell><cell cols="3">0.685 0.194 0.243</cell><cell>0.049</cell><cell cols="5">0.033 0.243 0.036 0.423 0.086</cell><cell>0.224</cell><cell>0.202</cell></row><row><cell>FF</cell><cell>0.082</cell><cell>0.105</cell><cell cols="4">0.664 0.194 0.203 0.038</cell><cell>0.092</cell><cell>0.244</cell><cell>0.053</cell><cell>0.434</cell><cell>0.140</cell><cell>0.211 0.205</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 3 :</head><label>3</label><figDesc>Back-in-time sampling criteria. D-statistic for 10 sampling algorithms (section 3.3) average over 4 temporally evolving graphs. Bolded the best performing sampling algorithms based on D-statistic. Column AVG shows the average over all patterns. FF and RPN perform best followed by RNand RW. Edge selection performs poorly.</figDesc><table><row><cell>Temporal graph patterns</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>We thank Michalis Faloutsos of UCR for useful discussions. Work supported by the NSF grants IIS-0209107, SENSOR-0329549, EF-0331657, IIS-0326322, IIS-0534205. by the Pennsylvania Infrastructure Technology Alliance, and a gift from Hewlett Packard. Jure Leskovec was partially supported by a Microsoft Research Graduate Fellowship.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>we mean by "realistic"? How do we measure the deviation from realism? There seems to be no perfect single answer to graph sampling. Depending on particular application and properties one cares about a suitable algorithm is chosen. The contributions of this work are the following:</p><p>• We propose the Back-in-time goal for sampling which is better defined than the Scale-down sampling goal.</p><p>• We study a large variety of graph sampling algorithms. Methods that do a combination of random node selection, and a little of vicinity exploration give best samples. "Forest Fire" is best performing sampling algorithm. Best results are obtained with burning probability ≈0.7 for Scale-down, and ≈0.2 for Back-in-time. This means that for Scale-down larger fires exploring more of the node's vicinity help, while for Back-in-time smaller fires which explore less vicinity give better results.</p><p>• We show that a 15% sample is usually enough, to match the properties (S1-S9 and T1-T5) of the real graph.</p><p>• We recognize that no list of properties will ever be perfect. We give a long list of "realism criteria", inspired from our experience with social networks, citation networks and communication networks. Our list is a significantly larger superset of the lists of earlier work on graph sampling.</p><p>• We provide rules to scale-up the measurements from the sample, to reach the measurements of the original graph.</p><p>Future work could focus on sampling from graphs with weighted edges, as opposed to the current, zero-one weights, as well as sampling on graphs with labeled edges. A different direction would be to focus on sampling algorithms to estimate a single property of the graph (e.g., diameter, number of triads) and define precise estimators (scaling relations) and evaluate their variance and bias.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Towards compressing web graphs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Adler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mitzenmacher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Data Compression Conference</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Sampling algorithms for pure network topologies</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Airoldi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">M</forename><surname>Carley</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<publisher>SIGKDD Explor</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">R-mat: A recursive model for graph mining</title>
		<author>
			<persName><forename type="first">D</forename><surname>Chakrabarti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SDM</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Creating realistic BGP models</title>
		<author>
			<persName><forename type="first">X</forename><forename type="middle">A</forename><surname>Dimitropoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">F</forename><surname>Riley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM MASCOTS</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">On power-law relationships of the internet topology</title>
		<author>
			<persName><forename type="first">M</forename><surname>Faloutsos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Faloutsos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="251" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Clique partitions, graph compression and speeding-up algorithms</title>
		<author>
			<persName><forename type="first">T</forename><surname>Feder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Motwani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer And System Sciences</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Compressing network graphs</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Gilbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Levchenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LinkKDD</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Reducing large internet topologies for faster simulations</title>
		<author>
			<persName><forename type="first">V</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Faloutsos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Chrobak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-H</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Percus</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Graphs over time: Densification laws, shrinking diamaters and possible explanations</title>
		<author>
			<persName><forename type="first">J</forename><surname>Leskovec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kleinberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGKDD</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">U</forename><surname>Oregon</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Route views project</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Anf: A fast and scalable tool for data mining in massive graphs</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">R</forename><surname>Palmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">B</forename><surname>Gibbons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGKDD</title>
		<meeting><address><addrLine>Edmonton, AB, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Effectively visualizing large networks through sampling</title>
		<author>
			<persName><forename type="first">D</forename><surname>Rafiei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Trust management for the semantic web</title>
		<author>
			<persName><forename type="first">M</forename><surname>Richardson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Domingos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Second International Semantic Web Conference</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Subnets of scale-free networks are not scale-free: Sampling properties of networks</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P H</forename><surname>Stumpf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wiuf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>May</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PNAS</title>
		<imprint>
			<biblScope unit="volume">102</biblScope>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Sampling techniques for large, dynamics graphs</title>
		<author>
			<persName><forename type="first">D</forename><surname>Stutzbach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rejaie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Duffield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Willinger</surname></persName>
		</author>
		<idno>CIS-TR-06-01</idno>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
		<respStmt>
			<orgName>University of Oregon</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Collective dynamics of &apos;small-world&apos; networks</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Watts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">H</forename><surname>Strogatz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">393</biblScope>
			<biblScope unit="page" from="440" to="442" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
