<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Event-driven Programming with Logical Execution Times</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Arkadeb</forename><surname>Ghosal</surname></persName>
							<email>arkadeb@eecs.berkeley.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Thomas</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Christoph</forename><forename type="middle">M</forename><surname>Kirsch</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Marco</forename><forename type="middle">A A</forename><surname>Sanvido</surname></persName>
							<email>msanvido¢@eecs.berkeley.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Event-driven Programming with Logical Execution Times</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">B4C93B4D42095AE6B76F09618DB9391E</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T03:59+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present a new high-level programming language, called XGIOTTO, for programming applications with hard real-time constraints. Like its predecessor, XGIOTTO is based on the LET (logical execution time) assumption: the programmer specifies when the outputs of a task become available, and the compiler checks if the specification can be implemented on a given platform. However, while the predecessor language GIOTTO was purely time-triggered, XGIOTTO accommodates also asynchronous events. Indeed, through a mechanism called event scoping, events are the main structuring principle of the new language. The XGIOTTO compiler and run-time system implement event scoping through a treebased event filter. The compiler also checks programs for determinism (absence of race conditions).</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>One of the key issues in real-time software is the development of high-level programming languages. On one hand, a real-time programming language should be sufficiently abstract as to support the automatic verification of programs against mathematical models such as hybrid automata or Simulink, which are commonly used in practice. On the other hand, the language should be sufficiently concrete as to support the automatic compilation of a program into efficient code. While some tools generate code directly from mathematical models (Real-Time Workshop, dSpace), the resulting code is useful for rapid prototyping but, especially on distributed platforms, it is neither sufficiently efficient nor sufficiently reliable to be used in safety-critical products. By contrast, we envision a future where hard real-time properties are guaranteed by a compiler that produces code of sufficient quality such that, as with current optimizing compilers for conventional (non-real-time) programming languages, manual code tweaking is rarely (if ever) necessary or desirable.</p><p>Previous attempts to define real-time languages fall mostly into two categories. The first approach uses priorities to specify (indirectly) the relative deadlines of software tasks <ref type="bibr" target="#b0">[1]</ref>. This approach supports efficient code generation based on scheduling theory <ref type="bibr" target="#b1">[2]</ref>. The resulting run-time behavior of a program, however, is highly nondeterministic; for example, varying execution times of tasks cause race conditions. This makes program verification difficult. The second approach is based on the synchrony assumption <ref type="bibr" target="#b2">[3]</ref>, which postulates that the execution platform is sufficiently fast as to complete all computation before the next environment event arrives. This approach leads to deterministic behavior and supports formal verification. It is, however, nontrivial to compile synchronous programs if either non-negligible execution times or distributed execution platforms are involved <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5]</ref>. We submit that the priority-based approach, which sacrifices determinacy in order to accommodate varying physical task execution times, is insufficiently abstract; and that the strictly synchronous approach, which sacrifices nonnegligible task execution times in order to recover determinacy, is insufficiently realistic about the physical platform.</p><p>We propose an intermediate approach, which is based on the LET (logical execution time) assumption. Using LET, the programmer specifies with every task invocation the logical execution time of the task, that is, the time (or event) at which the task provides its outputs. The compiler makes sure that, on a specified platform, the outputs are computed in time. If the outputs are ready early, then they are made visible only when the specified logical execution time expires. This buffering of outputs achieves determinacy in both timing (no jitter) and functionality (no race conditions). LET programming, therefore, trades code efficiency in favor of code predictability when compared with traditional task scheduling, which makes all outputs visible as soon as they become available. We have demonstrated, however, that the loss in efficiency is insignificant even in high-performance control applications, such as helicopter flight control <ref type="bibr" target="#b5">[6]</ref>. When compared with the synchrony assumption, LET programming trades mathematical expressiveness in favor of computational realities: it accommodates tasks with varying execution times, but in order to avoid fixpoint issues, all logical execution times are assumed to be strictly positive.</p><p>Previously, we have proposed and implemented a LET-based language for timetriggered programming, called GIOTTO <ref type="bibr" target="#b6">[7]</ref>. In this paper we generalize GIOTTO to accommodate also asynchronous events. Indeed, through a mechanism called event scoping, events are the main structuring principle of the new language, which is called XGIOTTO. Event scoping admits a variety of ways for handling events within a hierarchical block structure: an out-of-scope event may either be ignored, or it may be postponed until the event comes back into scope, or it may cause the current scope to terminate as soon as all currently active tasks are terminated. The XGIOTTO compiler and run-time system implement event scoping through a tree-based event filter. The XGIOTTO compiler also checks programs for determinism (absence of race conditions caused by multiple tasks terminating at the same time). Finally, we show how the compiler could check for time safety (schedulability within logical execution times). This has not yet been implemented in the current compiler prototype. state information of the task. In XGIOTTO, the same task may be instantiated on different memory at the same time. This task model is more general than GIOTTO tasks <ref type="bibr" target="#b6">[7]</ref>, which consist of both code and memory (i.e., fixed input and output ports).</p><p>Figure <ref type="figure" target="#fig_0">1</ref> shows that the logical execution of a LET task begins with the release of the task and ends with the termination of the task. The release as well as the termination of a LET task are triggered by events such as clock ticks or sensor interrupts. This is a generalization of GIOTTO tasks, which can be released and terminated only at clock ticks. From the release event to the termination event, the task is called active. A LET task is time-safe on some given hardware if the task completes execution on that hardware before the termination event occurs. The output of a time-safe LET task is made accessible to other tasks and to actuators only when the termination event occurs, even if the task completes its physical execution earlier. Similarly, the input of a LET task is written into its assigned memory when the release event occurs, not when the task actually starts executing. As a consequence, a LET task always exhibits the same behavior in the value and time domain on different hardware as long as the task is time-safe. Note that proving time safety is usually impossible if unconstrained events are used as release or termination events for LET tasks. For example, an unconstrained event may occur immediately after a LET task is released. This problem could be solved by an explicit environment assumption on the minimal inter-arrival time between events. With XGIOTTO, however, we propose a new approach based on the notion of event scoping, which allows us to encode an implicit environment assumption in XGIOTTO programs. Event scoping temporarily disables event monitoring for a subset of the observed events. In this way, the environment assumption is reflected by the control structure of the program itself.</p><p>XGIOTTO has three important programming constructs. The statement react b¡ until [e] is a reaction block, with a body b of XGIOTTO statements and an until event e, which determines when the reaction block, and the tasks that are released within the block, are terminated. The statements in b are executed logically in zero time but possibly at different time instants, if the reaction block contains nested reaction blocks. Even if all statements in b have been executed, the reaction block waits for the until event e to occur. During the wait, released tasks may be executed by the system scheduler. The second type of statement, release t(in)(out) first allocates memory for a new instance of the task t, then loads data stored in the list in of input ports into the allocated memory, and finally releases t to the system scheduler for execution. When the enclosing reaction terminates, the task is assumed to be complete and its output is made available in the list out of output ports, which can be used as input for other tasks. Third, the statement when [e] r enables the reaction r, which is a parallel composition of reaction blocks, to be invoked when the when event e occurs. If two sequential when statements share the same event e, then the corresponding reactions are invoked by two different occurrences of e. If, however, the two when [e] statements are nested, then the corresponding reactions are invoked by the same occurrence of e.</p><p>A reaction block in XGIOTTO defines the event scope for the statements in its body. An event scope consists of the until event of the reaction block and the when events of the when statements in the body of the reaction block. Upon invoking the reaction of one of the when statements, the current event scope is pushed onto a stack (i.e., it becomes passive) and a new event scope is created and becomes the active scope. In general, a reaction is a parallel composition of reaction blocks. If two or more reaction blocks are invoked in parallel, then the scope of the parent block is pushed onto the stack and the scopes of all parallel blocks become active. Therefore we have a tree of scopes with the root of the tree being the initial scope, and the leaves of the tree being the active scopes. There are two ways for parallel reaction blocks to terminate. If the parallel reaction blocks are invoked with wait-parallelism, then the until event of one of the blocks will close the corresponding leaf of the tree. Consequently, the entire reaction consisting of wait-parallel reaction blocks terminates once all until events have occurred, and then the parent scope is resumed. In contrast, if the parallel reaction blocks are invoked with asap-parallelism, then the until event of any one of the reaction blocks disables the sibling blocks. Disabling a reaction block does not cause its immediate termination, but it implies that no new activity (e.g., task releases) will happen until the until event of the reaction block occurs: all when events are erased from the disabled event scope, leaving only its until events active.</p><p>An event of an active scope either, in the case of a when event, invokes a reaction, or in the case of an until event, terminates the corresponding scope. If an event e of an active scope can both invoke a reaction as well as terminate the scope, then the termination action has precedence. An event of a passive scope can be handled in the following three ways: it may be ignored (keyword forget); or it may be postponed until its scope becomes active again, once all descendent blocks have terminated (keyword remember); or it may disable all descendent blocks, thus speeding up their termination (keyword asap). Note that only active until events can terminate active tasks; in particular, active tasks cannot be prematurely terminated, neither by the termination of asap-parallel reaction blocks nor by passive asap events.</p><p>Since XGIOTTO is a generalization of the GIOTTO language <ref type="bibr" target="#b6">[7]</ref>, consider first the two GIOTTO program fragments on the left of Figure <ref type="figure">2</ref>. A GIOTTO mode specifies a set of periodic tasks. The mode m shown here contains a task t1 with a period of 20 ms and a task t2 with a period of 10 ms. The LET of a GIOTTO task is equal to its period. At 0 ms, both tasks load input (code not shown here) into their memory and are then released to execute concurrently. At 10 ms, the result of task t2 is made accessible to actuators and to other tasks. However, task t1 may load new input only at 20 ms, even if t1 has not had the chance to start before 10 ms. On the other hand, t2 now loads  <ref type="figure">2</ref> implements exactly the behavior of one round of mode m. For simplicity, we have omitted the input and output ports of tasks. The code is a sequence of two reaction blocks. Initially the code releases task t1 and executes the first inner block, which releases task t2. We write 10 (resp. 20) for the event that recurs every 10 ms (resp. 20 ms). The termination of a task is defined by the until event of the surrounding reaction block, and therefore t1 and t2 terminate at 20 ms and 10 ms, respectively. At 10 ms, the second inner block is entered. Now, task t2 is released a second time and terminated at 20 ms. The right column of Figure <ref type="figure">2</ref> implements, in XGIOTTO, one round of the GIOTTO mode n with two nonharmonic tasks: task t1 has again a period of 20 ms but task t2 has now a period of 30 ms. For this, the XGIOTTO program uses a reaction that consists of two parallel reaction blocks. The first reaction block releases the task t1 every 20 ms: the whenever <ref type="bibr" target="#b19">[20]</ref> statement invokes its reaction every 20 ms, i.e., at 0 ms, 20 ms, and 40 ms, respectively. The second reaction block releases the t2 task every 30 ms. Both parallel blocks terminate at 60 ms, implementing one round of the nonharmonic GIOTTO mode n.</p><p>In the middle code fragment of Figure <ref type="figure">2</ref>, we add an asynchronous event async, which instantiates a task ta with a LET of 1 ms. This cannot be done in GIOTTO. We use the hierarchical structure of XGIOTTO to constrain the times at which the asynchronous event may cause the release of a new task instance. First consider the left column of Figure <ref type="figure">3</ref>. Since the event async is remembered, if it occurs between 0 ms and 10 ms, during the first inner reaction block, then task ta is released at 10 ms and terminated at 11 ms. Since the event 10 is also remembered (by default), the second inner reaction block is invoked at 11 ms, releasing task t2 a second time, and terminated at 20 ms. If async occurs, instead, between 10 ms and 20 ms, then task ta is never released, because until events -i.e., block termination (at 20 ms)-have precedence over when events. If the event async would have been specified as forget instead of remember, then task ta would never be released, because we assume that no two unrelated events can happen at exactly the same time (e.g., async cannot happen at exactly 10 ms). Now consider the middle column of Figure <ref type="figure">3</ref> ¡ until <ref type="bibr" target="#b9">[10]</ref>; end ¡ until <ref type="bibr" target="#b19">[20]</ref>; Fig. <ref type="figure">3</ref>. XGIOTTO code fragments with asynchronous event handling may be serviced twice, once between 10 ms and 20 ms, and a second time between 10 ms and 20 ms. While our default specification of an event is remember, note that in this case, it does not matter if async is specified as forget or remember. The third column of Figure <ref type="figure">3</ref> shows the use of an asap event. In this example an occurrence of the async event between 0 ms and 10 ms disables the reaction to the asyncb event and releases task ta at 10 ms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Syntax</head><p>We refer to the language manual <ref type="bibr" target="#b7">[8]</ref> for a full definition of the language. Here we introduce only the syntax necessary for understanding the most important XGIOTTO concepts:</p><formula xml:id="formula_0">Program = "program" Ident ' ' [ConstDecl] [TypeDecl] [PortDecl] [EventDecl]</formula><p>ReactionDecl | TaskDecl Constant, type, port, and event declarations. Constant declarations allow to associate a name with a value. Type declarations associate a name with a structured data type. Each port has a fixed type and can be initialized, if an initial value different from a type-dependent default value is desired. Similarly, each event has as a fixed type, the value being assigned by the interrupt generating the event. The events time and now are predefined. The integer event time is bound to the system clock. The event now is a placeholder for the current event and can be used in when statements only (not in whenever and until statements). Events are structured hierarchically in a tree, e.g., the event 20 occurs at every other occurrence of the event 10. Logically, no two unrelated events (i.e., neither one is a descendent of the other in the event tree) can happen simultaneously, as they are sequenced by the interrupt handler.</p><p>Task declarations. A task header specifies a task name, formal input parameters, formal output parameters, and local variables. The task body is a standard sequential program without reference to events (we omit the exact syntax). The input parameters are passed by value, i.e., they are local ports to which the actual parameters are assigned as initial values upon release of a task instance. The output parameters are passed by valuereference, i.e., they are local ports with the actual parameters as initial values, but their values are instantaneously copied back to the actual parameters at termination of the task instance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Reaction block declarations.</head><p>A header specifies the name of the reaction block and a formal until-event parameter. The body of the reaction block contains three parts:</p><p>(1) conditional when and whenever statements called trigger statements, (2) conditional release statements, and (3) sequential reaction statements. The trigger statements whose condition is true specify the active events of the reaction block (in addition to the until event, which is also active) and the corresponding reactions. The occurrence of an active event is processed in the order in which the trigger statements are declared. The events can be specified as forget, remember, or asap. A whenever statement corresponds to a when statement that reenables itself immediately after its event occurs, until the surrounding reaction block is terminated. The reenabled active event will be processed after all the other previously enabled events are processed. The release statements whose condition is true hand task instances to the system scheduler. The sequential reaction statements can be declared either as a one-time sequence or as a loop of reaction statements. Each reaction statement is an asap-parallel (defined by &amp;&amp;) or a wait-parallel (defined by ||) composition of reaction blocks. Each reaction invocation renders the active events passive. When the until event of the reaction block is active and arrives, the scope and all tasks released in its scope are terminated, and control is returned to the invoking reaction block, reenabling its active events. The trigger and release statements are executed instantaneously (in logical zero time), but time passes between events; in particular, time passes during the execution of a react statement, between the trigger and release statements of the reaction block, and the until event of the block.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Core-XGIOTTO.</head><p>The syntax of XGIOTTO given by the above grammar is used in all program examples in this paper. However, the corresponding formal semantics is provided only for a fully expressive fragment called core-XGIOTTO. Each XGIOTTO program can be transformed into a core-XGIOTTO by replacing each call to a named reaction block with the code of the reaction block, and by removing from each reaction block all sequential reaction statements as follows: each one-time sequence of reaction statements is replaced by a set of when trigger statements; each loop, by a set of whenever trigger statements. XGIOTTO programs with recursive (cyclic) calls of reaction blocks are considered illegal, because they represent infinite core-XGIOTTO programs. Note that in core-XGIOTTO, a reaction block consists of a sequence of trigger statements, a set of release statements, and an until event.</p><p>Example of a control program. Figure <ref type="figure">4</ref> shows a program for controlling a onedimensional system with an actuator u, a position sensor p, and a velocity sensor v. The controller is a cascaded controller combining a proportional velocity controller in the inner loop, and a proportional position controller in the outer loop. The proportional controllers are used for simplicity; more advanced controller algorithms can easily replace the task code of Pos and Vel. The velocity controller updates the actuator every 2 time units, whereas the position controller updates the target velocity every 3 time units. The target of the position controller is a position point stored in the position array p. When the position is reached, the next target position is chosen from p. If the last position in p is reached, the system stabilizes at the actual position. The system will follow the trajectory stored in p until the last point of the trajectory is reached. In addition to the two periodic tasks, we introduce an asynchronous task, which computes an array of target position points for a given set of way-points. The asynchronous task is triggered by an external event, such as an operator input. We limit the number of asynchronous way-point updates to one every 6 time units.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Semantics</head><p>The execution of an XGIOTTO program yields a possibly infinite sequence of configurations. Each configuration consists of the values of all program variables (ports) and a tree of scopes. Each scope corresponds to a reaction block of the program; it contains a termination event, a trigger queue, and a ready set. The active scopes are the leaves. The trigger queue contains the enabled reactions, each associated with an invocation event: if the invocation event for an enabled reaction of an active scope arrives, then the first such reaction is invoked, and for each of its parallel reaction blocks, a new scope is added as a child to the present scope, rendering that scope passive. The ready set of a scope contains the tasks that have been released in the scope; their termination event is the termination event of the scope. Each when and whenever statement of a reaction block adds an event-reaction pair to the trigger queue; each release statement adds a task to the ready set. The termination event of an active scope removes that scope.</p><p>In the following, we make this formal by defining a state-transition graph whose states are the program configurations, and whose transitions correspond to the occurrence of a new event, the termination of a scope, and the invocation of a core-XGIOTTO reaction. When a new event arrives, first an event transition records the event occurrence in all scopes, then a sequence of termination transitions removes (possibly nested) scopes that have terminated, and finally a sequence of reaction transitions adds (possibly nested) new scopes by invoking enabled reaction blocks. If no more reaction blocks , and reaction addresses £ . A configuration is a pair ¤ ¦¥ ¨ § © , where ¥ is a function from the port set to values, and © is a labeled tree -each node is labeled by a scope. A scope is a tuple ¤ § § § ! , where specifies the termination event instance, is a queue of triggers, is a set of task instances, and #" %$ '&amp; ($ () ' § 10 '$ 32 %4 ¡ specifies the parallelism for (the siblings of) the scope. An event instance is a tuple ¤ 65 7 § 98 @ § BA C , where 5 D" E¡ , 8 F" EG , and A H" PI Q § 9R Q § BS ¡ , denoting asap, remember, and forget, respectively; the tuple implies that the required action (terminating a scope, or invoking a reaction) happens when the event 5 occurs 8 number of times. A trigger is a tuple ¤ 6T 3 § 9U V § 9W X , where T specifies the invoking event instance, U Y" `G ba Xc ¡ records if the trigger is registered by a when (U ed fc ) or whenever (U g" hG ) statement, and W i" p£ is the invoked reaction. A task instance is a tuple ¤ 6q r § 6s ut 1 § v wt 9 § xs y , where q " ¢ and s 3t 1 § xs y , and v %t is a function from s t to values. At task termination the output ports s y are updated to the values computed by the task q , given that the input ports s t had the values v wt when the task was released.</p><p>In the initial configuration, all ports have their initial values, and the scope tree has a single node labeled by the scope of the main reaction block. A scope is terminating if it is a leaf scope and its terminating event instance has the form ¤ x5 7 § ¡ § BA C . A scope is reacting if it is a leaf scope and its trigger queue contains a trigger with an invoking event instance of the form ¤ x5 § ¡ § BA C ; this is called an invoked trigger. A configuration is waiting if all its scopes are neither terminating nor reacting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Event transitions.</head><p>For each waiting configuration ¤ ¥ ¨ § © and event 5 £¢ " ¡ , an event successor is obtained by replacing each event instance ¤ x5 7 § 98 @ § 9A ! in © with ¤ 65 7 § 98 ¥¤ §¦ ( § 9A ! if 8 ©¨¡ and 5 d 5 ¢ and either (1) A V" PI Q § BR ¡ or (2) A d FS and the event instance occurs in a leaf scope. Moreover, if the terminating event instance of a scope is replaced by ¤ 65 ¢ 6 § ¡ § BI , then the trigger queues of all descendent scopes are emptied.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Termination transitions.</head><p>For each configuration ¤ ¥ ¨ § © which has a terminating scope, a termination successor is obtained by removing the leaf with the terminating scope. Second, for each task instance ¤ q r § xs t § v t § 6s y of the removed scope, the port values of s y in ¥ are updated by applying task q to the port values v Xt of s t . Third, if the removed scope is asap-parallel, then the trigger queues of all sibling scopes and their descendents are emptied. If the program is free of race conditions (see next section), then each sequence of termination transitions leads, independent of their order, to a unique configuration without terminating scopes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Reaction transitions.</head><p>For each configuration ¤ ¥ ¨ § © which has no terminating scope but a reacting scope, if the first invoked trigger in the queue is d ¤ B¤ 65 7 § ¡ § 9A C § 9U V § 9W X , then a reaction successor is obtained by adding to the node with the reacting scope a set of children -one for each reaction block of W . Moreover, the trigger is removed from the queue, and if U d c , then the new trigger ¤ 9¤ 65 7 § BU § BA C r § BU § BW is appended at the end of the queue. The scope of each new node is computed by executing the corresponding reaction block: the termination event instance of the new scope is determined by the until event of the reaction block; the trigger queue of the new scope contains one trigger for each when and whenever statement whose condition is true in ¥ , in the order of the statements; the ready set of the new scope contains one task instance for each release statement whose condition is true in ¥ , where the values of the task input ports are taken from ¥ ; and the parallelism of the new scope is determined by whether the reaction block is composed with asap-or wait-parallelism. It is not difficult to see that each sequence of reaction transitions leads, independent of their order, to a unique waiting configuration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Program Analysis</head><p>The XGIOTTO compiler performs several program analyses. First, it does a conservative check and rejects programs whose execution may encounter a race condition. A race occurs when two tasks that are terminated by the same event write to the same port; in this case, the port value is not predictable. By contrast, for a given event sequence, programs without race conditions are executed deterministically. Second, since the memory of embedded systems is often constrained, the XGIOTTO compiler computes a conservative estimate for the memory requirements of a program. Third, we show how the compiler could check for time safety (schedulability) of a program on a given platform. The platform is specified through WCETs (worst-case execution times) for all ¡¡¡¡¡¡¡ hscc04-final.tex tasks. ======= tasks. ¿¿¿¿¿¿¿ 1.67 Race detection. A program trace is a sequence of transitions starting from the initial configuration. A trace contains a race if it has two termination transitions that update the same port without an interspersed event transition. The absence of races can be checked precisely by a traversal of the exponential configuration graph. The compiler performs a less precise, but conservative polynomial-time check on the program text. It associates with every reaction block a set ¢ ¤ ¡ of potential termination events: the set ¢ ¤ ¡ contains the until event of , and if the until event of has type remember or asap, then ¢ ¤ ¡ contains also all potential termination events of the immediate subblocks of . If for any two distinct release statements v and v ¢ that have an output port in common, the potential termination events of the reaction blocks containing v and v ¢ are disjoint, then all program traces are race-free. A less conservative analysis might consider the configuration graph, but with all port values abstracted.</p><p>Resource requirements. In order to allocate sufficient memory, the compiler computes from conservative bounds on the size of the scope tree, trigger queues, and ready sets of an XGIOTTO program (the computation of exact bounds would again require a traversal of the configuration graph). As the reaction block structure of a program is nonrecursive, the size of the scope tree is bounded. An upper bound on the tree size for a reaction block is 1 plus the maximum of the tree sizes for the contained reactions, and for each reaction, it is the sum of the tree sizes for the contained reaction blocks. The length of the trigger queue of a reaction block is bounded by the number of when and whenever statements of the block, and the size of the ready set of a reaction block is bounded by the number of release statements. Time-safety (schedulability) analysis. The execution of an XGIOTTO program is timesafe if each active task instance completes before its termination event. Time safety, of course, depends not only on the program but also on the execution platform. In particular, for time-safety analysis, the XGIOTTO compiler needs WCET information. For example, if there is a single task instance, then the program is time-safe if the WCET is less than the LET. In general, there may be concurrent active task instances and time-safety checking requires a schedulability analysis. The XGIOTTO compiler uses discrete time. The WCET for each task is assumed to be a positive integer, and scheduling decisions (i.e., task preemptions) are taken only at integer times. For this purpose, we assume there is a periodic event called tick. In every waiting configuration, the scheduler assigns to the CPU one of the tasks that have been released but not completed. Scheduling decisions take effect only if the subsequent event is a tick event.</p><p>Then, an integer counter that keeps the task execution time is decremented. At task release the counter is initialized to the WCET, and if the termination event arrives before the counter is 0, then a time-safety violation occurs.</p><p>Formally, the schedulability of an XGIOTTO program (on a single CPU) is defined as a two-player safety game. The game graph is an extended configuration graph, where Fig. <ref type="figure">5</ref>. The system architecture each configuration is extended with execution-time counters for all active tasks, and in addition to event, termination, and reaction transitions, there are scheduling transitions. An extended configuration is a triple ¤ ¡ X § £¢ § , where d ¤ ¦¥ ¨ § © is a configuration, ¢ is a function that assigns a positive integer to each task instance in the ready set for each node of © , and is a bit. The function ¢ indicates for each task instance the remaining (worst-case) execution time. The bit indicates which player moves next in the scheduling game: if d ¡ , then the environment chooses an event or the system performs a termination or reaction transition; if d ¦ , then the scheduler chooses a task to be executed. The transitions between extended configurations are: if ¤ ¤ § ¥ ¢ is a transition other than an event transition on tick, then ¤ B¤ ¡ § ¦¢ § ¡ r § w¤ ¡ ¢ ¦ § £¢ § ¡ 9 is the corresponding extended transition; if ¤ ¡ § £ ¢ is an event transition on tick, then ¤ B¤ ¡ § ¦¢ § ¡ r § w¤ ¡ ¢ x § £¢ § ¦ w B is the corresponding extended transition; and ¤ 9¤ ¤ § £¢ § ¦ % r § P¤ ¤ § £¢ ¢ 6 § ¡ B is a scheduling transition if either (1) the scheduler does not schedule any task and ¢ ¢ id §¢ , or (2) the scheduler schedules a task instance 2 of and ¢ ¢ ¦¤ 92 X d ¨¢ u¤ 92 X ¤ ¦ , and ¢ ¢ ¦¤ 12 ¢ d ©¢ u¤ 92 ¢ for all task instances 2 ¢ different from 2 .</p><p>Player 1 is the system and its environment; they choose event, termination, and reaction transitions. Player 2 is the scheduler; it chooses scheduling transitions, i.e., it determines the task whose execution-time counter is to be decremented (while the execution-time counters of all other tasks stay unchanged). The program is time-safe with respect to a given WCET mapping (which maps each task to a WCET) if in this game player 2 -the scheduler-has a strategy to avoid time-safety violations forever. Safety games can be solved in linear time in the size of the game graph. Since the extended configuration graph is exponential (even if port values are abstracted), in theory the schedulability problem for XGIOTTO is complete for EXPTIME. It is an interesting question to look for restrictions on the program structure which make the problem tractable in practice, at least if ports values are abstracted. For example, in GIOTTO (which is a special case of XGIOTTO) the schedulability check can be done by a simple utilization test <ref type="bibr" target="#b9">[10]</ref>.</p><p>The prototype implementation of the XGIOTTO system consists of a compiler and a runtime environment. The run-time environment is shown in the upper part of Figure <ref type="figure">5</ref> and executes the code generated by the XGIOTTO compiler. The generated code is divided into two parts, reaction code and task code. Reaction code is essentially E code (the instruction set of the E Machine <ref type="bibr" target="#b8">[9]</ref>), whereas task code is similar to Java byte-code. This can be any platform-native code, but we chose to interpret the task code in our prototype and generate ¡¡¡¡¡¡¡ hscc04-final.tex native code in a later stage of the project. The compiler checks for race conditions and determines upper bounds on the resource ======= native code in a later stage of the project. The compiler checks race conditions and determines upper bounds on the resource ¿¿¿¿¿¿¿ 1.67 requirements of the program. We are currently implementing a ¡¡¡¡¡¡¡ hscc04-final.tex time-safety check with respect to given task WCETs. The run-time system also performs checks that raise exceptions when a time-safety violation is detected at run-time. This may happen if WCET data is wrong. The user can specify, again ======= time-safety check with respect to given task WCETs. The run-time system also performs checks that raise exceptions when a time-safety violation is detected at run time. Even if a static time-safety check is performed a time-safety violation may happen at run time if the WCET data is wrong. The user can specify, again ¿¿¿¿¿¿¿ 1.67 in XGIOTTO, how exceptions are handled.</p><p>The XGIOTTO run-time environment consists of three interacting components: the event filter, the E Machine, and the scheduler. The original E Machine is insufficient to implement event scoping; therefore we have augmented the architecture presented in <ref type="bibr" target="#b10">[11]</ref> with an event filter. The event filter implements the event-scoping mechanism and presents the filtered events to the E Machine. The implementation of the event filter is tree-based, where each node of the tree is the event scope of a reaction block. The leaves of the tree are the active event scopes. An event scope is composed of the trigger events (from the when and whenever statements), the until event of the reaction block, and the set of released tasks. At run-time, the occurrence of an event is processed by the event filter. The event filter computes the event transition and the termination transitions on the tree of event scopes and gives to the E Machine a set of E code addresses, which correspond to the invoked reaction blocks. The E Machine interprets the E code, thus performing the reaction transitions. The E code instructions may release new tasks to the scheduler and enable new triggers. When all invoked reactions are processed by the E Machine, the system scheduler chooses a task to execute from the ready set of the active event scopes, and whenever such a task completes, the E Machine is notified. In addition, the E Machine monitors the running tasks by detecting task overruns (time-safety violations). If a task overrun is detected (i.e., if a task termination event arrives before the task completes), a run-time exception is generated.</p><p>The lower part of Figure <ref type="figure">5</ref> shows the execution environment. The platform interacts with the environment through actuators and sensors. The actuators are driven by the task outputs and the sensors generate raw events (interrupts), which are handled by the event filter. The prototype system is implemented in Java and is able to run any XGIOTTO program on any Java virtual machine (JVM). The E Machine is available on several platforms, including JVM, POSIX, HelyOS, and KURT-Linux, and we are in the process of porting the XGIOTTO system to these platforms.</p><p>XGIOTTO has been inspired by the GIOTTO <ref type="bibr" target="#b6">[7]</ref> language. The GIOTTO programmer's model is restricted to time-triggered task release and termination, and therefore wellsuited for control applications with a periodic task structure. The interest in investigating a LET-based programmer's model that can handle also asynchronous events and aperiodic tasks has been the main driver for the XGIOTTO language project. Timed multitasking (TM) <ref type="bibr" target="#b11">[12]</ref> is based on a computational model similar to the LET assumption. However, in TM the execution time of each parallel task is logically fixed only by time, and not by general, dynamically scoped events as in XGIOTTO.</p><p>The zero-time execution of XGIOTTO statements is inspired by synchronous reactive languages, such as Esterel <ref type="bibr" target="#b12">[13]</ref> and Lustre <ref type="bibr" target="#b13">[14]</ref>. In synchronous reactive languages all computations are assumed to take zero logical time, as opposed to XGIOTTO, where all task computations have a strictly positive logical execution time. XGIOTTO, therefore, on one hand restricts the theoretical expressiveness of synchronous reactive languages, and on the other hand integrates them with scheduling theory. Esterel allows the parallel execution of tasks in a way similar to XGIOTTO. A parallel task can be started by the exec statement, and at its completion a signal is raised. While Esterel can stop the task execution, it cannot specify its termination point; it has no notion of LET. Moreover, event scoping would have to be explicitly coded into an Esterel program. Recent work in the synchronous language community has been aimed at relating logical (synchronous) time and physical (real) time. For example, Taxys <ref type="bibr" target="#b14">[15]</ref> relaxes the zero-delay assumption with real-time constraints by merging the Esterel language and the Kronos real-time constraint verifier, and an extension to Lustre with a relaxed zero-delay assumption has been proposed as well <ref type="bibr" target="#b15">[16]</ref>.</p><p>nesC <ref type="bibr" target="#b16">[17]</ref> is a programming language especially targeted to small, networked sensor devices. The goal of nesC is very similar to XGIOTTO. Both compilers check for race conditions. Interestingly, XGIOTTO task instantiation can be specified in nesC by using the post command, which releases a computation, but without explicitly giving a termination requirement. The main difference between nesC and XGIOTTO is the absence of the concept of time, and therefore no hard-real time constraints can be guaranteed by the nesC compiler. Also, the nesC programmer's model is platform-independent but not value-deterministic. In particular, the same program running on different platforms with the same input events may produce different results. Erlang <ref type="bibr" target="#b17">[18]</ref> is a functional language for real-time embedded systems, specifically for the telecommunication domain. Erlang, like XGIOTTO, generates code for a virtual machine, and is therefore easily portable to different platforms. Erlang features the execution of parallel tasks but, like nesC, does not explicitly address real-time requirements apart from timeouts and the handling of run-time exceptions.</p><p>Real-Time Euclid <ref type="bibr" target="#b18">[19]</ref> is a language designed specifically to address reliability and schedulability issues in time-constrained environments. The language definition forces every construct in the language to be time-and space-bounded. These restrictions make it easier to estimate the execution time of the program, and they facilitate scheduling to meet all deadlines. Therefore, RT-Euclid programs can always be analyzed for schedulability. However, RT-Euclid does not have any notion of event reaction and is therefore lacking an important aspect of embedded-systems programming. The programming lan-guage Flex <ref type="bibr" target="#b19">[20]</ref> extends C++ by introducing explicit real-time constraints. In Flex, timing constraints can be specified for each section of code. The run-time mechanism of Flex ensures that the timing constraints are satisfied, or else the block is aborted and an exception handler is invoked. In Flex timing constrains are guaranteed at run-time and no schedulability analysis is performed at compile-time. However, like XGIOTTO, both Flex and Real-Time Euclid define a platform-independent logical execution model for real-time programs, which makes them predictable.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Logical and physical execution of a task</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>const" Ident "=" Number ";" ¡ . TypeDecl = "type" TypeId (("array" Number "of" TypeId) | ("record" ' ' TypeId Ident ';' ¡ ' ¡ '))';' ¡ . PortDecl = "port" TypeId Ident [InitPort] ';' ¡ . EventDecl = "event" TypeId Ident ["at" Ident] ';' ¡ . TaskDecl = "task" Ident Pars "output" Pars ["var" Pars] Body. Body = ' ' StatSeq ' ¡ '. StatSeq = Statement ";" Statement ¡ . Pars = '(' [TypeId Ident ',' TypeId Ident ¡ ] ')'. ReactionDecl = "react" Ident ReactionBody "until" '[' TypeId Ident ']'. ReactionBody = ' ' Triggers Releases [("begin" | "loop") RStatSeq "end" ";"] ' ¡ '. Triggers = [Condition] ("when" | "whenever") Event Reaction ";" ' | '&amp;&amp;' ) ReactionBlock ¡ . ReactionBlock = "react" ((Ident) | ReactionBody) "until" Event. ParsRef = '(' [Ident ',' Ident ¡ ] ')'. Event = ["asap" | "remember" | "forget"] '[' [Number] Ident ']'. Condition = '(' BoolExpression ')'.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>. Here, the event async</figDesc><table><row><cell>react</cell><cell>react</cell><cell>react</cell></row><row><cell>when remember [async]</cell><cell>release t1()();</cell><cell>when asap [async]</cell></row><row><cell>react</cell><cell>begin</cell><cell>react</cell></row><row><cell>release ta()();</cell><cell>react</cell><cell>release ta()();</cell></row><row><cell>¡</cell><cell></cell><cell>¡</cell></row><row><cell>until [1];</cell><cell>when [async] react</cell><cell>until [1];</cell></row><row><cell>release t1()();</cell><cell>release ta()();</cell><cell>release t1()();</cell></row><row><cell></cell><cell>¡</cell><cell></cell></row><row><cell>begin</cell><cell>until [1];</cell><cell>begin</cell></row><row><cell>react</cell><cell>release t2()();</cell><cell>react</cell></row><row><cell></cell><cell>¡</cell><cell></cell></row><row><cell>release t2()();</cell><cell>until [10];</cell><cell>when [asyncb] react</cell></row><row><cell>¡</cell><cell></cell><cell></cell></row><row><cell>until [10];</cell><cell>react</cell><cell>release tb()();</cell></row><row><cell></cell><cell></cell><cell>¡</cell></row><row><cell>react</cell><cell>when [async] react</cell><cell>until [1];</cell></row><row><cell>release t2()();</cell><cell>release ta()();</cell><cell>release t2()();</cell></row><row><cell>¡</cell><cell>¡</cell><cell></cell></row><row><cell>until [10];</cell><cell>until [1];</cell><cell></cell></row><row><cell>end</cell><cell>release t2()();</cell><cell></cell></row><row><cell>¡</cell><cell>¡</cell><cell></cell></row><row><cell>until [20];</cell><cell>until [10]</cell><cell></cell></row><row><cell></cell><cell>end</cell><cell></cell></row><row><cell></cell><cell>¡</cell><cell></cell></row><row><cell></cell><cell>until [20];</cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>The xGiotto LanguageXGIOTTO is an event-driven real-time programming language that is built around the notion of software tasks with logical execution times. A LET task is sequential code operating on memory that is assigned to the task upon its release and which is not accessible to any other tasks. The memory holds the input and output as well as possible</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This research is supported by the AFOSR MURI grant F49620-00-1-0327, the DARPA SEC grant F33615-C-98-3614, the MARCO GSRC grant 98-DT-660, and the NSF grants CCR-0208875 and CCR-0225610.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Real-Time Systems and Programming Languages</title>
		<author>
			<persName><forename type="first">A</forename><surname>Burns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wellings</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Hard Real-Time Computing Systems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Buttazzo</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Kluwer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Synchronous Programming of Reactive Systems</title>
		<author>
			<persName><forename type="first">N</forename><surname>Halbwachs</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>Kluwer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Automatic production of globally asynchronous, locally synchronous systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Girault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ménier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Embedded Software. LNCS 2491</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="266" to="281" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Clock-driven automatic distribution of Lustre programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Girault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Nicollin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Embedded Software</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2855</biblScope>
			<biblScope unit="page" from="206" to="222" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">From control models to real-time code using GIOTTO</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Kirsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A A</forename><surname>Sanvido</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Pree</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Control Systems Magazine</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="50" to="64" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">GIOTTO: a time-triggered language for embedded programming</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Horowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Kirsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. IEEE</title>
		<imprint>
			<biblScope unit="volume">91</biblScope>
			<biblScope unit="page" from="84" to="99" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A A</forename><surname>Sanvido</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ghosal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<idno>UCB//CSD-03-1261</idno>
		<title level="m">XGIOTTO language report</title>
		<imprint>
			<publisher>UC Berkeley</publisher>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The Embedded Machine: predictable, portable real-time code</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Kirsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Programming Language Design and Implementation</title>
		<meeting>Programming Language Design and Implementation</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="315" to="326" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Time-safety checking for embedded programs</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Kirsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Majumdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Matic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Embedded Software. LNCS 2491</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="76" to="92" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">A programmable microkernel for real-time systems</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Kirsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A A</forename><surname>Sanvido</surname></persName>
		</author>
		<idno>UCB/CSD-03-1250</idno>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>UC Berkeley</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Timed multitasking for real-time embedded software</title>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Control Systems Magazine</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="65" to="75" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><surname>Boussinot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>De Simone</surname></persName>
		</author>
		<title level="m">The Esterel language. Proc. IEEE</title>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">79</biblScope>
			<biblScope unit="page" from="1293" to="1304" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The synchronous data-flow programming language Lustre</title>
		<author>
			<persName><forename type="first">N</forename><surname>Halbwachs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Caspi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Raymond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pilaud</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE</title>
		<meeting>IEEE</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">79</biblScope>
			<biblScope unit="page" from="1305" to="1320" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Taxys = Esterel + Kronos. A tool for verifying real-time properties of embedded systems</title>
		<author>
			<persName><forename type="first">V</forename><surname>Bertin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Closse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Poize</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pulou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sifakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Venier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Weil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yovine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Decision and Control</title>
		<meeting>Decision and Control</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="2875" to="2880" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">From Simulink to Scade/Lustre to TTA: a layered approach for distributed embedded applications</title>
		<author>
			<persName><forename type="first">P</forename><surname>Caspi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Curic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Maignan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sofronis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tripakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Niebert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Languages, Compilers, and Tools for Embedded Systems</title>
		<meeting>Languages, Compilers, and Tools for Embedded Systems</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="153" to="162" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The nesC language: a holistic approach to networked embedded systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Gay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Levis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Von Behren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Welsh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Brewer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Culler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Programming Languages Design and Implementation</title>
		<imprint>
			<biblScope unit="page" from="1" to="11" />
			<date type="published" when="2003">2003</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Armstrong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Virding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wikström</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Williams</surname></persName>
		</author>
		<title level="m">Concurrent Programming in Erlang</title>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Real-time Euclid: a language for reliable real-time systems</title>
		<author>
			<persName><forename type="first">E</forename><surname>Kligerman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Stoyenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Engineering</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="941" to="949" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Building flexible real-time systems using the Flex language</title>
		<author>
			<persName><forename type="first">K</forename><surname>Kenny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">J</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="70" to="78" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
