<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Under review as a conference paper at ICLR 2021 ACCURATE LEARNING OF GRAPH REPRESENTATIONS WITH GRAPH MULTISET POOLING</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<title level="a" type="main">Under review as a conference paper at ICLR 2021 ACCURATE LEARNING OF GRAPH REPRESENTATIONS WITH GRAPH MULTISET POOLING</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T13:09+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Message-passing graph neural networks have been widely used on modeling graph data, achieving impressive results on a number of graph classification and link prediction tasks. Yet, obtaining an accurate representation for a graph further requires a well-defined pooling function that maps the set of node representations into a compact form, without information loss of the individual node features and the global graph structure. A simple sum or average over all node representations considers all node features equally without consideration of their task relevance, and any structural dependencies among them. Recently proposed hierarchical graph pooling methods, on the other hand, may yield the same representation for two different graphs that are distinguished by the Weisfeiler-Lehman test, as they suboptimally preserve information from the node features. To tackle these limitations of existing graph pooling methods, we first formulate the graph pooling problem as a multiset encoding problem with auxiliary information about the graph structure, and propose a Graph Multiset Transformer (GMT) which is a multi-head attention based global pooling layer that captures the interaction between nodes according to their structural dependencies. We show that GMT satisfies both injectiveness and permutation invariance, such that it is at most as powerful as the Weisfeiler-Lehman graph isomorphism test. Moreover, our methods can be easily extended to the previous node clustering approaches for hierarchical graph pooling. Our experimental results show that GMT significantly outperforms state-of-the-art graph pooling methods on graph classification benchmarks with high memory efficiency, and obtains even larger performance gain on graph reconstruction and generation tasks, which more directly measure the expressiveness of graph pooling methods.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Graph neural networks (GNNs) <ref type="bibr" target="#b53">(Zhou et al., 2018;</ref><ref type="bibr" target="#b44">Wu et al., 2019)</ref>, which work with graph structured data, have recently attracted considerable attention, as they can learn expressive representations for various graph-related tasks such as node classification, link prediction, and graph classification. While the majority of the existing works on GNNs focus on the message passing strategies for neighborhood aggregation <ref type="bibr" target="#b21">(Kipf &amp; Welling, 2017;</ref><ref type="bibr" target="#b16">Hamilton et al., 2017)</ref>, which aims to encode the nodes in a graph accurately, graph pooling <ref type="bibr" target="#b52">(Zhang et al., 2018;</ref><ref type="bibr" target="#b48">Ying et al., 2018)</ref> that maps the set of nodes into a compact representation is crucial in capturing a meaningful structure of an entire graph.</p><p>As a simplest approach for graph pooling, we can average or sum all node features in the given graph <ref type="bibr" target="#b1">(Atwood &amp; Towsley, 2016;</ref><ref type="bibr" target="#b46">Xu et al., 2019)</ref> (Figure <ref type="figure" target="#fig_0">1 (B)</ref>). However, since such simple aggregation schemes treat all nodes equally without considering their relative importance on the given tasks, they can not generate a meaningful graph representation in a task-specific manner. Their flat architecture designs also restrict their capability toward the hierarchical pooling or graph compression into few nodes. To tackle these limitations, several differentiable pooling operations have been proposed to condense the graph with neural network architectures in an end-to-end manner. There are two dominant approaches to pooling a graph. Node drop methods <ref type="bibr" target="#b52">(Zhang et al., 2018;</ref><ref type="bibr" target="#b23">Lee et al., 2019b)</ref> (Figure <ref type="figure" target="#fig_0">1 (C</ref>)) obtain a score of each node using information from the graph convolutional layers, and then drop unnecessary nodes with lower scores at each pooling step by sorting them. Node clustering methods <ref type="bibr" target="#b48">(Ying et al., 2018;</ref><ref type="bibr" target="#b4">Bianchi et al., 2019)</ref> (Figure <ref type="figure" target="#fig_0">1</ref> (D)), on the other hand, cluster similar nodes into a single node by exploiting their hierarchical similarity structure. Both graph pooling approaches have obvious drawbacks. First, node drop methods unnecessarily drop some nodes at every pooling step, leading to information loss on those discarded nodes. On the other hand, node clustering methods compute the dense soft cluster assignment matrix with an adjacency matrix. This prevents them from exploiting sparsity in the graph topology, leading to excessively high computational complexity <ref type="bibr" target="#b23">(Lee et al., 2019b)</ref>. Furthermore, since they need a single graph representation at the end, they generally use Readout <ref type="bibr" target="#b5">(Cangea et al., 2018)</ref> or 1D convolution <ref type="bibr" target="#b52">(Zhang et al., 2018)</ref> for this purpose. However, it is suboptimal since those operations do not explicitly consider the inter-node relationships. Finally, to accurately represent the graph, the GNNs should obtain a representation that is as powerful as the Weisfeiler-Lehman (WL) graph isomorphism test <ref type="bibr" target="#b43">(Weisfeiler &amp; Leman, 1968</ref>), such that it can map two different graphs onto two distinct embeddings. While recent message-passing operations satisfy this constraint <ref type="bibr" target="#b27">(Morris et al., 2019;</ref><ref type="bibr" target="#b46">Xu et al., 2019)</ref>, most deep graph pooling works <ref type="bibr" target="#b48">(Ying et al., 2018;</ref><ref type="bibr" target="#b23">Lee et al., 2019b;</ref><ref type="bibr" target="#b15">Gao &amp; Ji, 2019;</ref><ref type="bibr" target="#b4">Bianchi et al., 2019)</ref> overlook graph isomorphism except for a few <ref type="bibr" target="#b52">(Zhang et al., 2018)</ref>.</p><p>To obtain accurate representations of graphs, we need a graph pooling function that is as powerful as the WL test in distinguishing two different graphs. To this end, we first focus on that the graph representation learning can be regarded as a multiset encoding problem, which allows for possibly repeating elements, since a graph may have redundant node representations (See Figure <ref type="figure" target="#fig_0">1</ref>, right). However, since a graph is more than a multiset due to its structural constraint, we further define the problem as a graph multiset encoding, whose goal is to encode two different graphs given as multisets of node features with auxiliary structural dependencies among them (See Figure <ref type="figure" target="#fig_0">1</ref>, right) into two unique embeddings. We tackle this problem by utilizing a graph-structured attention unit. By leveraging this unit as a fundamental building block, we propose the Graph Multiset Transformer (GMT), a pooling mechanism that condenses the given graph into the set of representative nodes, and then further encodes relationships between them to enhance the representation power of a graph.</p><p>We theoretically analyze the connection between our pooling operations and WL test, and further show that our graph multiset pooling function can be easily extended to node clustering methods.</p><p>We then experimentally validate the graph classification performance of GMT on 10 benchmark datasets from biochemical and social domains, on which it significantly outperforms existing methods on most of them. However, since graph classification tasks only require discriminative information, to better quantify the amount of information about the graph in condensed nodes after pooling, we further validate it on graph reconstruction of synthetic and molecule graphs, and also on two graph generation tasks, namely molecular generation and retrosynthesis. Notably, GMT outperforms baselines with even larger performance gap on graph reconstruction, which demonstrates that it learns meaningful information without forgetting original graph structure. Finally, it improves the graph generation performance on two tasks, which shows that GMT can be well coupled with other GNNs for graph representation learning. In sum, our main contributions are summarized as follows:</p><p>• We treat a graph pooling problem as a multiset encoding problem, under which we consider relationships among nodes in a set with several attention units, to make a compact representation of an entire graph only with one global function, without additional message-passing operations. • We show that existing GNN with our parametric pooling operation can be as powerful as the WL test, and also be easily extended to the node clustering approaches with learnable clusters. • We extensively validate GST for graph classification, reconstruction, and generation tasks on synthetic and real-world graphs, on which it largely outperforms most graph pooling baselines.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>Graph Neural Network Existing graph neural network (GNN) models generally encode the nodes by aggregating the features from the neighbors <ref type="bibr" target="#b21">(Kipf &amp; Welling, 2017;</ref><ref type="bibr" target="#b16">Hamilton et al., 2017)</ref>, and have achieved a large success on node classification and link prediction tasks <ref type="bibr" target="#b39">(Velickovic et al., 2018;</ref><ref type="bibr" target="#b49">You et al., 2019)</ref>. Recently, there also exist transformer-based GNNs <ref type="bibr" target="#b29">(Nguyen et al., 2019;</ref><ref type="bibr" target="#b35">Rong et al., 2020)</ref> that further consider the relatedness between nodes in learning the node embeddings. However, accurately representing the given graph as a whole remains challenging. While using mean or max over the node embeddings allow to represent the entire graph for graph classification <ref type="bibr" target="#b11">(Duvenaud et al., 2015;</ref><ref type="bibr" target="#b8">Dai et al., 2016)</ref>, they are mostly suboptimal, and may output the same representation for two different graphs. To resolve this problem, recent GNN models <ref type="bibr" target="#b46">(Xu et al., 2019;</ref><ref type="bibr" target="#b27">Morris et al., 2019)</ref> aim to make the GNNs to be as powerful as the Weisfeiler-Lehman test <ref type="bibr" target="#b43">(Weisfeiler &amp; Leman, 1968</ref>) in distinguishing graph structures. Yet, they also rely on simple operations, and we need a more sophisticated method to represent the entire graph.</p><p>Graph Pooling In the graph representation learning tasks, graph pooling methods play an essential role of representing the entire graph. While averaging all node features is directly used as simplest pooling methods <ref type="bibr" target="#b1">(Atwood &amp; Towsley, 2016;</ref><ref type="bibr" target="#b36">Simonovsky &amp; Komodakis, 2017)</ref>, they result in a loss of information since they consider all node information equally without considering key features for graphs. To overcome this limitation, there have been recent studies on graph pooling to compress the given graph in a task specific manner. Node drop methods use learnable scoring functions to drop nodes with lower scores <ref type="bibr" target="#b52">(Zhang et al., 2018;</ref><ref type="bibr" target="#b15">Gao &amp; Ji, 2019;</ref><ref type="bibr" target="#b23">Lee et al., 2019b)</ref>. Moreover, node clustering methods cast the graph pooling problem into the node clustering problem to map the nodes into a set of clusters <ref type="bibr" target="#b48">(Ying et al., 2018;</ref><ref type="bibr" target="#b4">Bianchi et al., 2019;</ref><ref type="bibr" target="#b50">Yuan &amp; Ji, 2020)</ref>. Among these, Bianchi et al. ( <ref type="formula">2019</ref>) uses the spectral clustering for the graph coarsening, similarly to existing spectral-based graph pooling methods <ref type="bibr" target="#b25">(Ma et al., 2019;</ref><ref type="bibr">Wang et al., 2019)</ref> to coarsen a given graph. Some methods combine the two approaches by first locally clustering the neighboring nodes and then dropping unimportant clusters <ref type="bibr" target="#b34">(Ranjan et al., 2020)</ref>. Meanwhile, edge clustering gradually merges nodes by contracting high-scoring edges between them <ref type="bibr" target="#b10">(Diehl, 2019)</ref>. In addition, Ahmadi et al. ( <ref type="formula">2020</ref>) model the memory layer to aggregate nodes without utilizing message-passing after pooling. Also, there exists a semi-supervised pooling method <ref type="bibr" target="#b47">(Li et al., 2019)</ref> that scores nodes with an attention scheme <ref type="bibr" target="#b3">(Bahdanau et al., 2015)</ref>, to weight more on the important nodes on pooling.</p><p>(Multi-)Set Representation Learning Note that a set of nodes in a graph forms a multiset <ref type="bibr" target="#b46">(Xu et al., 2019)</ref>; a set that allows possibly repeating elements. Therefore, contrary to the previous setencoding methods which mainly consider non-graph problems <ref type="bibr" target="#b31">(Qi et al., 2017a;</ref><ref type="bibr" target="#b47">Yi et al., 2019;</ref><ref type="bibr" target="#b37">Snell et al., 2017)</ref>, we regard the graph representation learning as a multi-set encoding problem. Mathematically, <ref type="bibr" target="#b51">Zaheer et al. (2017);</ref><ref type="bibr" target="#b32">Qi et al. (2017b)</ref> provide the theoretical grounds on permutation invariant functions for the set encoding. Further, <ref type="bibr" target="#b22">Lee et al. (2019a)</ref> propose Set Transformer, which uses attention mechanism on the set encoding. Building on top of these theoretical grounds on set, we propose the multiset encoding function that explicitly considers the graph structures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">GRAPH MULTISET POOLING</head><p>We posit the graph representation learning problem as a multiset encoding problem, and then utilize the graph-structured attention to consider the global graph structure when encoding the given graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">PRELIMINARIES</head><p>We begin with the general descriptions of graph neural network, and graph pooling.</p><p>Graph Neural Network A graph G can be represented by its adjacency matrix A ∈ {0, 1} n×n and node set V with |V| = n nodes, along with the c dimensional node features X ∈ R n×c . Graph Neural Networks (GNNs) learn feature representation for different nodes using neighborhood aggregation schemes, which are formalized as the following Message-Passing function:</p><formula xml:id="formula_0">H (l+1) u = UPDATE (l) H (l) u , AGGREGATE (l) H (l) v , ∀v ∈ N (u) ,<label>(1)</label></formula><p>where H (l+1) ∈ R n×d is the node features computed after l-steps of the GNN simplified as follows: l) , A (l) ), UPDATE and AGGREGATE are arbitrary differentiable functions, N (u) denotes a set of neighboring nodes of u, and H</p><formula xml:id="formula_1">H (l+1) = GNN (l) (H (</formula><p>(1)</p><p>u is initialized as the input node features X u .</p><p>Graph Pooling While message-passing functions can produce a set of node representations, we need additional READOUT function to obtain the entire graph representation h G ∈ R d as follows:</p><formula xml:id="formula_2">h G = READOUT ({H v | v ∈ V}) .<label>(2)</label></formula><p>As a READOUT function, we can simply use the average or sum over all node features H v , ∀v ∈ V from the given graph <ref type="bibr" target="#b1">(Atwood &amp; Towsley, 2016;</ref><ref type="bibr" target="#b46">Xu et al., 2019)</ref>. However, since such aggregation schemes take all node information equally without considering the graph structures, they lose structural information that is necessary for accurately representing a graph. To tackle this limitation, Node Drop methods <ref type="bibr" target="#b15">(Gao &amp; Ji, 2019;</ref><ref type="bibr" target="#b23">Lee et al., 2019b</ref>) select the high scored nodes i (l+1) ∈ R n l+1 with learnable score function s at layer l, to drop the unnecessary nodes, denoted as follows:</p><formula xml:id="formula_3">y (l) = s(H (l) , A (l) ); i (l+1) = top k (y (l) ),<label>(3)</label></formula><p>where function s depends on specific implementation, and top k function samples the top k nodes by dropping nodes with low scores y (l) ∈ R n l . Whereas Node Clustering methods <ref type="bibr" target="#b48">(Ying et al., 2018;</ref><ref type="bibr" target="#b4">Bianchi et al., 2019)</ref> learn cluster assignment matrix C (l) ∈ R n l ×n l+1 with the node features H (l) ∈ R n l ×d , to coarsen the nodes and the adjacency matrix A (l) ∈ R n l ×n l at layer l as follows:</p><formula xml:id="formula_4">H (l+1) = C (l) T H (l) ; A (l+1) = C (l) T A (l) C (l) ,<label>(4)</label></formula><p>where generating an assignment matrix C (l) depends on specific implementation. While these two approaches obtain decent performance on graph classification tasks, they are suboptimal since node drop methods unnecessarily drop arbitrary nodes, and node clustering methods have limited scalability to large graphs <ref type="bibr" target="#b5">(Cangea et al., 2018;</ref><ref type="bibr" target="#b23">Lee et al., 2019b)</ref>. Therefore, we need a sophisticated graph pooling layer that coarsens the graph with sparse implementation without discarding nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">GRAPH MULTISET TRANSFORMER</head><p>We now describe the Graph Multiset Transformer (GMT) architecture, which can accurately represent the entire graph, given a multiset of node features. We first introduce a multiset encoding scheme that allows to embed two different graphs into distinct embeddings. Then we further describe the graph multi-head attention that reflects the graph topology in the attention-based multiset encoding, to compress the elements of a multiset while considering their structural dependencies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Multiset Encoding</head><p>The input of the graph pooling function READOUT consists of nodes in a graph, and they form a multiset (i.e. a set which allows for repeating elements) since different nodes can have identical feature vectors. To design a graph pooling function that is as powerful as the WL test, it needs to satisfy the permutation invariance and injectiveness over the multiset, since two non-isomorphic graphs should be embedded differently through the injective function. While the simple sum pooling satisfies the injectiveness over a multiset <ref type="bibr" target="#b46">(Xu et al., 2019)</ref>, it may treat all node embeddings equally without consideration of their relevance to the task. To resolve this issue, we consider attention mechanism on the multiset pooling function to capture structural dependencies among nodes within a graph, in which we can provably enjoy the expressive power of the WL test.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Graph Multi-head Attention</head><p>To overcome the inability of simple pooling methods (e.g. sum) on distinguishing important nodes, we use the attention mechanism as the main component in our pooling scheme. Assume that we have n node vectors, then the input of the attention function (Att) consists of query Q ∈ R nq×d k , key K ∈ R n×d k and value V ∈ R n×dv , where n q is the number of query vectors, n is the number of input nodes, d k is the dimensionlity of the key vector, and d v is the dimensionality of the value vector. Then we compute the dot product of the query with all keys, to put more weights on the relevant values, namely nodes, as follows: Att(Q, K, V ) = w(QK T )V , where w is an activation function. Instead of computing a single attention, we can further use a multi-head attention <ref type="bibr" target="#b38">(Vaswani et al., 2017)</ref>, by linearly projecting the query Q, key K, and value V h times respectively to yield h different representation subspaces. The output of the multi-head attention function (MH) then can be denoted as follows:</p><formula xml:id="formula_5">MH(Q, K, V ) = (O 1 , ..., O h )W O ; O i = Att(QW Q i , KW K i , V W V i ),<label>(5)</label></formula><p>where the operations for h parallel projections are parameter matrices</p><formula xml:id="formula_6">W Q i ∈ R d k ×d k , W K i ∈ R d k ×d k and W V i ∈ R dv×dv . Also, the output projection matrix is W O ∈ R hdv×d model</formula><p>, where d model is the output dimensionality for the multi-head attention (MH) function. Note that, QW Q i consists of a specific query Q, which we describe in equation 7 or 8, and a learnable matrix W Q i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Input Graph Message Passing</head><p>Triangle Graph, 3-Path Graph</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Node Space that reflects graph structures</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Seed Vectors 𝑺</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>GMPool</head><p>SelfAtt GMPool While multi-head attention is superior to trivial pooling methods such as sum or mean as it considers global dependencies among nodes, the MH function suboptimally generates the key and value for Att, since it linearly projects the obtained node embeddings H from equation 1 to further obtain the key and value pairs. To tackle this limitation, we newly define a novel graph multi-head attention block (GMH) to consider the graph structure into account, by generating key and value matrices with two separate GNNs. Formally, given node features H ∈ R n×d with their adjacency information A, we construct the key and value using GNNs, to explicitly leverage the graph structure as follows:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>𝑺′ Graph Representation</head><formula xml:id="formula_7">GMH(Q, H, A) = (O 1 , ..., O h )W O ; O i = Att(QW Q i , GNN K i (H, A), GNN V i (H, A)). (6)</formula><p>Graph Multiset Pooling with Graph Multi-head Attention Using the ingredients above, we now propose a graph pooling function that satisfies the injectiveness and permutation invariance, such that overall architecture can be at most as powerful as the WL test, while taking the graph structure into account. Note that constructing the multiset encoding function with all nodes is problematic in terms of memory efficiency since a graph can have a large number of nodes. Therefore, given node features H ∈ R n×d from GNNs, we define a Graph Multiset Pooling (GMPool), which is inspired by the Transformer <ref type="bibr" target="#b38">(Vaswani et al., 2017;</ref><ref type="bibr" target="#b22">Lee et al., 2019a)</ref>, to compress the n nodes into the k typical nodes with a parameterized seed matrix S ∈ R k×d for the GMPool operation that is directly optimized in an end-to-end fashion as follows (Figure <ref type="figure" target="#fig_1">2</ref>-GMPool): GMPool k (H, A) = LN(Z + rFF(Z)); Z = LN(S + GMH(S, H, A)), (7) where rFF is any row-wise feedforward layer that processes each individual row independently and identically, and LN is a layer normalization <ref type="bibr" target="#b2">(Ba et al., 2016)</ref>. Note that the output of the GMPool is a set of k vectors, such that we can condense the all nodes into the set of k nodes. Also, since we should obtain the one feature vector to represent each graph, we set k = 1 in the final layer of our overall pooling architectures. Intuitively, feature aggregation using attention is beneficial in the extreme case k = 1 because the influence of each instance on the target task is not necessarily equal.</p><p>Self-Attention for Inter-node Relationship While previously described GMPool condenses the set of entire nodes into k representative nodes, a major drawback of this scheme is that it does not consider the relationships between nodes in the given set, which limits its ability to accurately represent the graph structure. To tackle this limitation, one should further consider the interactions among n or condensed k different nodes. To this end, we propose a Self-Attention function (SelfAtt), inspired by the Transformer <ref type="bibr" target="#b38">(Vaswani et al., 2017;</ref><ref type="bibr" target="#b22">Lee et al., 2019a)</ref>, as follows (Figure <ref type="figure" target="#fig_1">2</ref></p><formula xml:id="formula_8">-SelfAtt): SelfAtt(H) = LN(Z + rFF(Z)); Z = LN(H + MH(H, H, H)). (<label>8</label></formula><formula xml:id="formula_9">)</formula><p>Overall Architecture We now describe the full structure of Graph Multiset Transformer (GMT) consisting of GNN and pooling layers using ingredients above (See Figure <ref type="figure" target="#fig_1">2</ref>). For a graph G with node features X and an adjacency matrix A, the Encoder :</p><formula xml:id="formula_10">G → H ∈ R n×d is denoted as follows: Encoder(X, A) = GNN 2 (GNN 1 (X, A), A),<label>(9)</label></formula><p>where we can stack several GNNs to construct the deep structures. After obtaining a set of node features H from an encoder, the pooling layer aggregates the features into a single vector form; Pooling : H, A → h G ∈ R d . To deal with a large number of nodes, we first condense the entire graph into k representative nodes with Graph Multiset Pooling (GMPool) which is also adaptable to the varying size of nodes, and then utilize the interaction among them with Self-Attention Block (SelfAtt). Finally, we get the entire graph representation by using GMPool with k = 1 as follows:</p><p>Pooling(H, A) = GMPool 1 (SelfAtt(GMPool k (H, A)), A ), (10) where A ∈ R k×k is the identity or coarsened adjacency matrix since adjacency information should be adjusted after compressing the nodes from n to k with GMPool k (See Appendix B for detail).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">CONNECTION WITH WEISFEILER-LEHMAN GRAPH ISOMORPHISM TEST</head><p>Weisfeiler-Lehman (WL) test <ref type="bibr" target="#b43">(Weisfeiler &amp; Leman, 1968</ref>) is known for its ability to efficiently distinguish two different graphs. Recent studies <ref type="bibr" target="#b27">(Morris et al., 2019;</ref><ref type="bibr" target="#b46">Xu et al., 2019)</ref> show that GNNs can be made to be as powerful as the WL test, by using an injective function over a multiset to map two different graphs into distinct spaces. Building on previous powerful GNNs, if our graph pooling function is injective, then our overall architecture can be at most as powerful as the WL test.</p><p>To do so, we first recount the theorem from <ref type="bibr" target="#b46">Xu et al. (2019)</ref>, as formalized in Theorem 1.</p><p>Theorem 1 (Non-isomorphic Graphs to Different Embeddings). Let A : G → R d be a GNN, and Weisfeiler-Lehman test decides two graphs G 1 ∈ G and G 2 ∈ G as non-isomorphic. Then, A maps two different graphs G 1 and G 2 to distinct vectors if node aggregation and update function are injective, and graph-level readout, which operates on a multiset of node features {H i }, is injective.</p><p>Since we focus on the representation of graphs through pooling, we deal with the injectiveness of the READOUT function. Our next Lemma 2 states that GMPool can represent the injective function.</p><p>Lemma 2 (Uniqueness on Graph Multiset Pooling). Assume the input feature space H is a countable set. Then the output of the GMPool i k (H, A) with GMH(S i , H, A) for a seed vector S i can be unique for each multiset H ⊂ H of bounded size. Further, the output of the full GMPool k (H, A) constructs a multiset with k elements, which are also unique on the input multiset H.</p><p>All proofs regarding the WL test are provided in Appendix A.1. Moreover, our next Proposition 3 states that the sequence of GMPool and SelfAtt with proper GNN is as powerful as the WL test.</p><p>Proposition 3 (Injectiveness on Pooling Function). The overall Graph Multiset Transformer with multiple GMPool and SelfAtt can map two different graphs G 1 and G 2 to distinct embedding spaces, such that the resulting GNN with proposed pooling functions can be as powerful as the WL test.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">CONNECTION WITH NODE CLUSTERING APPROACHES</head><p>Node clustering is widely used for coarsening a given graph in a hierarchical manner, as described in the equation 4. However, since they require to store and even multiply the adjacency matrix A with the soft assignment matrix C: A (l+1) = C (l) T A (l) C (l) , they need a quadratic space O(n 2 ) for n nodes, which may be problematic for large graphs <ref type="bibr" target="#b5">(Cangea et al., 2018;</ref><ref type="bibr" target="#b23">Lee et al., 2019b)</ref>. On the other hand, our Graph Multiset Pooling (GMPool) does not compute a coarsened adjacency matrix A (l+1) , such that graph representation learning is possible only with sparse implementation, as formalized in Theorem 4. All proofs regarding node clustering are provided in Appendix A.2.</p><p>Theorem 4 (Space Complexity of Graph Multiset Pooling). Graph Multiset Pooling condsense a graph with n nodes to k nodes in O(nk) space complexity, which can be further optimized to O(n).</p><p>In spite of this huge strength on space complexity, our GMPool can be further approximated to the node clustering methods by manipulating an adjacency matrix, as formalized in Proposition 5.</p><p>Proposition 5 (Approximation to Node Clustering). Graph Multiset Pooling GMPool k can perform hierarchical node clustering with learnable k cluster centroids by Seed Vector S in equation 7.</p><p>Note that, contrary to previous node clusterings <ref type="bibr" target="#b48">(Ying et al., 2018;</ref><ref type="bibr" target="#b4">Bianchi et al., 2019)</ref>, GMPool learns data dependent k cluster centroids that might be more meaningful to capture graph structures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">EXPERIMENT</head><p>To demonstrate the proposed Graph Multiset Transformer (GMT) for accurate graph representation learning, we evaluate it on multiple tasks, including graph classification on 10 benchmark datasets, graph reconstruction of synthetic and molecular graphs, and graph generation of molecular graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">GRAPH CLASSIFICATION</head><p>Objective Graph classification task is used to measure the representation power of GNNs, where the goal is to predict the label y i ∈ Y of a given graph G i ∈ G, with a mapping function f : G → Y. To this end, we use a set of node representations {H v | v ∈ V} to obtain an entire graph representation h G that is finally used to classify a graph label f (G) = ŷ. We then learn it with crossentropy loss, to minimize the negative log likelihood denoted as follows: min i=1 −y i log ŷi .</p><p>Table <ref type="table">1</ref>: Graph classification results on test sets. The reported results are mean and standard deviations over 10 different runs. Best performance and its comparable results (p &gt; 0.05) from the t-test are marked in bold. Hyphen (-) denotes out-of-resources that take more than 10 days (See Figure <ref type="figure">4</ref> for the time efficiency analysis).  Datasets Among TU datasets <ref type="bibr" target="#b28">(Morris et al., 2020)</ref>, we select 6 datasets including 3 datasets (D&amp;D, PROTEINS, and MUTAG) on Biochemical domain, and 3 datasets (IMDB-B, IMDB-M, and COL-LAB) on Social domain with accuracy for evaluation metric. Also, we use 4 molecule datasets (HIV, Tox21, ToxCast, BBBP) from the OGB datasets <ref type="bibr" target="#b18">(Hu et al., 2020)</ref> with ROC-AUC for evaluation metric. Statistics are reported in the Table <ref type="table">1</ref>, and more details are described in the Appendix C.2.</p><p>Models 1) GCN. 2) GIN. Naive GNN baselines with mean or sum pooling <ref type="bibr" target="#b21">(Kipf &amp; Welling, 2017;</ref><ref type="bibr" target="#b46">Xu et al., 2019)</ref>. 3) Set2Set. Set pooling baseline <ref type="bibr" target="#b40">(Vinyals et al., 2016)</ref>. 4) SortPool. 5) SAGPool. 6) TopKPool. 7) ASAP. The methods <ref type="bibr" target="#b52">(Zhang et al., 2018;</ref><ref type="bibr" target="#b23">Lee et al., 2019b;</ref><ref type="bibr" target="#b15">Gao &amp; Ji, 2019;</ref><ref type="bibr" target="#b34">Ranjan et al., 2020)</ref> that use the node drop scheme, by dropping nodes (or clusters) with lower scores using learnable scoring functions. 8) DiffPool. 9) MinCutPool. 10) StructPool.</p><p>The methods <ref type="bibr" target="#b48">(Ying et al., 2018;</ref><ref type="bibr" target="#b4">Bianchi et al., 2019;</ref><ref type="bibr" target="#b50">Yuan &amp; Ji, 2020</ref>) that use the node clustering scheme, by generating a cluster assignment matrix to map a set of nodes into a set of clusters. 11) EdgePool. The method <ref type="bibr" target="#b10">(Diehl, 2019)</ref> that gradually merges two adjacent nodes that have a high score edge. 12) HaarPool. The method (Wang et al., 2019) that uses Haar basis system in a spectral domain for graph clustering. 13) GMT. Our proposed Graph Multiset Transformer (See Appendix C.1 for detailed descriptions of baselines and our model).</p><p>Implementation Details For a fair comparison of baselines <ref type="bibr" target="#b23">(Lee et al., 2019b)</ref>, we fix the GCN <ref type="bibr" target="#b21">(Kipf &amp; Welling, 2017)</ref> as a message passing layer and only change the pooling architecture throughout all models. We evaluate the model performance on TU datasets for a conventional 10fold cross validation setting <ref type="bibr" target="#b52">(Zhang et al., 2018;</ref><ref type="bibr" target="#b46">Xu et al., 2019)</ref> with LIBSVM <ref type="bibr" target="#b7">(Chang &amp; Lin, 2011)</ref>. Also, we use the initial node features following the recently proposed fair comparison setup <ref type="bibr" target="#b14">(Errica et al., 2020)</ref>. Also, we evaluate the performance on OGB datasets with their original feature extraction and data split settings <ref type="bibr" target="#b18">(Hu et al., 2020)</ref>. We set the pooling ratio as 25% in each pooling layer for all models. Detailed experimental settings are described in the Appendix C.2.</p><p>Results Table <ref type="table">1</ref> shows that our GMT outperforms most baselines, or achieves comparable performance to the best baseline results. These results demonstrate that our method is simple yet powerful as it only performs a single global operation at the final layer, unlike several baselines that use multiple pooling with a sequence of message passing (See Figure <ref type="figure" target="#fig_8">9</ref> for the detailed model architectures). Note that, since graph classification tasks mostly require the discriminative information to predict the labels of a graph, GNN baselines without parametric pooling, such as GCN and GIN, sometimes outperform pooling baselines on some datasets. In addition, recently proposed work <ref type="bibr" target="#b26">(Mesquita et al., 2020)</ref>, which reveals that message-passing layers are dominant in the graph classification, supports  this phenomenon. Therefore, we conduct experiments on graph reconstruction to directly quantify the amount of retained information after pooling, which we describe in the next subsection.</p><p>Ablation Study To see where the performance improvement comes from, we conduct an ablation study on GMT by removing graph attention, self attention, and message-passing operations. Table <ref type="table" target="#tab_0">2</ref> shows that using graph attention with self-attention helps significantly improve the performances from the mean pooling. Further, the performance of the GMT without GNN layers indicates that our pooling layer well captures the graph multiset structure only with pooling without GNNs.</p><p>Efficiency While node clustering methods, such as DiffPool and MinCutPool, achieve decent performances in Table <ref type="table">1</ref>, they are known to suffer from large memory usage since they cannot work with sparse graph implementations. To compare the GPU Memory Efficiency of GMT with baseline models, we test it on the Erdos-Renyi graphs <ref type="bibr" target="#b13">(Erdős &amp; Rényi, 1960</ref>) (See Appendix C.2 for detail setup). Figure <ref type="figure">3</ref> shows that our GMT is highly efficient in terms of memory thanks to its compatibility with sparse graphs, making it more practical over memory-heavy pooling baselines. In addition to this, we measure the Time Efficiency to further validate the practicality of GMT compared to baselines in terms of time complexity. We validate it with the same Erdos-Renyi graphs <ref type="bibr" target="#b13">(Erdős &amp; Rényi, 1960</ref>) (See Appendix C.2 for detail setup). Figure <ref type="figure">4</ref> shows that GMT takes less than (or nearly about) a second even for large graphs, compared to the slowly working models such as HaarPool and EdgePool. This result further confirms that GMT is practically efficient.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">GRAPH RECONSTRUCTION</head><p>Graph classification, often used as benchmarks for GNNs, does not directly measure the expressiveness of the GNNs since identifying discriminative features may be more important than accurately representing the graph for classification. On the other hand, graph reconstruction more directly quantifies the amount of information about the graph retained by condensed nodes after pooling.</p><p>Objective For graph reconstruction, we train an autoencoder to reconstruct the input node features X ∈ R n×c from their pooled representations X pool ∈ R k×c . The learning objective to minimize the discrepancy between the original graph X and the reconstructed graph X rec with a cluster assignment matrix C ∈ R n×k is defined as follows: min X − X rec , where X rec = CX pool .</p><p>Experimental Setup We first experiment with Synthetic Graph that can be represented in a 2-D Euclidean space, such as ring and grid <ref type="bibr" target="#b4">(Bianchi et al., 2019)</ref>, where the goal is to restore the location of each node from pooled features, with an adjacency matrix. We further experiment with real-world Molecule Graph for quantitative evaluation on ZINC datasets <ref type="bibr">(Irwin et al., 2012)</ref>, which consists of 12K molecular graphs. See Appendix C.3 for the experimental detail including model descriptions.     </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Results on Synthetic Graph</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Molecule Generation Results</head><p>The power of the discriminator distinguishing whether a molecule is real or fake is highly important to create a valid molecule in MolGAN. Figure <ref type="figure">8</ref> shows the validity curve on the early stage of MolGAN training for Molecule Generation, and the representation power of the GMT significantly leads to the stabilized generation of valid molecules than baselines.</p><p>Retrosynthesis Results Further, Table <ref type="table" target="#tab_2">3</ref> shows the retrosynthesis results, where we use the GLN as a backbone architecture. Similar to the molecule generation, retrosynthesis with GMT further improves the baseline performances, which suggests that GMT can replace existing pooling methods for improved performance on diverse graph tasks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">CONCLUSION</head><p>In this work, we pointed out that existing graph pooling approaches either do not consider the task relevance of each node (sum or mean) or may not satisfy the injectiveness (node drop and clustering methods). To overcome such limitations, we proposed a novel graph pooling method, Graph Multiset Transformer (GMT), which not only encodes the given set of node embeddings as a multiset to uniquely embed two different graphs into two distinct embeddings, but also considers both the global structure of the graph and their task relevance in compressing the node features. We theoretically justified that the proposed pooling function is as powerful as the WL test, and can be extended to the node clustering schemes. We validated the proposed GMT on 10 graph classification datasets, and our method outperformed state-of-the-art graph pooling models on most of them. We further showed that our method is superior to the existing graph pooling approaches on graph reconstruction and generation tasks, which require more accurate representations of the graph than classification tasks. We strongly believe that the proposed pooling method will bring substantial practical impact, as it is generally applicable to many graph-learning tasks that are becoming increasingly important.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A PROOFS A.1 PROOFS REGARDING WEISFEILER-LEHMAN TEST</head><p>We first recount the theorem of <ref type="bibr" target="#b46">(Xu et al., 2019)</ref> to define a GNN that is injective over a multiset (Theorem 1). We then prove that the proposed Graph Multiset Pooling (GMPool) can map two different graphs to distinct spaces (Lemma 2). Finally, we show that our overall architecture Graph Multiset Transformer (GMT) with a sequence of proposed Graph Multiset Pooling (GMPool) and Self-Attention (SelfAtt) can represent the injective function over the input multiset (Proposition 3).</p><p>Theorem 1 (Non-isomorphic Graphs to Different Embeddings). Let A : G → R d be a GNN, and Weisfeiler-Lehman test decides two graphs G 1 ∈ G and G 2 ∈ G as non-isomorphic. Then, A maps two different graphs G 1 and G 2 to distinct vectors if node aggregation and update function are injective, and graph-level readout, which operates on a multiset of node features {H i }, is injective. Proof. To map the two non-isomorphic graphs to distinct embedding spaces with GNNs, we recount the theorem on Graph Isomorphism Network. See Appendix B of <ref type="bibr" target="#b46">Xu et al. (2019)</ref> for detail.</p><p>Lemma 2 (Uniqueness on Graph Multiset Pooling). Assume the input feature space H is a countable set. Then the output of the GMPool i k (H, A) with GMH(S i , H, A) for a seed vector S i can be unique for each multiset H ⊂ H of bounded size. Further, the output of the full GMPool k (H, A) constructs a multiset with k elements, which are also unique on the input multiset H.</p><p>Proof. We first state that the GNNs of the Graph Multi-head Attention (GMH) in a GMPool can represent the injective function over the multiset H with an adjacency information A, by selecting proper message-passing functions that satisfy the WL test <ref type="bibr" target="#b46">(Xu et al., 2019;</ref><ref type="bibr" target="#b27">Morris et al., 2019)</ref>, denoted as follows: H = GNN(H, A), where H ⊂ H. Then, given enough elements, a GMPool i k (H, A) can express the sum pooling over the multiset H defined as follows: ρ( h∈H f (h)), where f and ρ are mapping functions (see the proof of PMA in <ref type="bibr" target="#b22">Lee et al. (2019a)</ref>).</p><p>Since H is a countable set, there is a mapping from the elements to prime numbers denoted by p(h) : H → P. If we let f (h) = − log p(h), then h∈H f (h) = log h∈H 1 p(h) which constitutes an unique mapping for every multiset H ⊂ H (see <ref type="bibr" target="#b41">Wagstaff et al. (2019)</ref>). In other words, h∈H f (h) is injective. Also, we can easily construct a function ρ, such that GMPool</p><formula xml:id="formula_11">i k (H, A) = ρ( h∈H f (h)) = ρ(log h∈H 1 p(h)</formula><p>) is injective function for every multiset H ⊂ H, where H is derived from the GNN component in the GMPool; H = GNN(H, A).</p><p>Furthermore, since a GMPool considers multiset elements without any order, it satisfies the permutation invariance condition for the multiset function.</p><p>Finally, each GMPool block has k components such that the output of it consists of k elements as follows: GMPool = GMPool i k (H, A) k i=1 , which allows multiple instances for its elements. Then, since each GMPool i k (H, A) is unique on the input multiset H, the output of the GMPool that consists of k outputs is also unique on the input multiset H.</p><p>Thanks to the universal approximation theorem <ref type="bibr" target="#b17">(Hornik et al., 1989)</ref>, we can construct such functions p and ρ using multi-layer perceptrons (MLPs).</p><p>Proposition 3 (Injectiveness on Pooling Function). The overall Graph Multiset Transformer with multiple GMPool and SelfAtt can map two different graphs G 1 and G 2 to distinct embedding spaces, such that the resulting GNN with proposed pooling functions can be as powerful as the WL test.</p><p>Proof. By Lemma 2, we know that a Graph Multiset Pooling (GMPool) can represent the injective function over the multiset. If we can also show that a Self-Attention (SelfAtt) can represent the injective function over the multiset, then the sequence of the GMPool and SelfAtt blocks can satisfy the injectiveness.</p><p>Let W O be a zero matrix in SelfAtt function. SelfAtt(H) then can be approximated to the any instance-wise feed-forward network denoted as follows: SelfAtt(H) = rFF(H). Therefore, this Under review as a conference paper at ICLR 2021 rFF is a suitable transformation φ : R d → R d that can be easily constructed over the multiset elements h ∈ H, to satisfy the injectiveness.</p><p>To maximize the discriminative power of the Graph Multiset Transformer (GMT) by satisfying the WL test, we assume that SelfAtt does not consider the interactions among multiset elements, namely nodes. While proper GNN with proposed pooling function can be as powerful as the WL test with this assumption, our experimental results with the ablation study show that the interaction among nodes is significantly important to distinguish the broad class of graphs (See Table <ref type="table" target="#tab_0">2</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 PROOFS REGRADING NODE CLUSTERING</head><p>We first prove that the space complexity of the Graph Multiset Pooling (GMPool) without GNNs can be approximated to the O(n) with n nodes (Theorem 4), and then show that GMPool can be easily extended to the Node Clustering approaches with learnable cluster centroids (Proposition 5).</p><p>Theorem 4 (Space Complexity of Graph Multiset Pooling). Graph Multiset Pooling condsense a graph with n nodes to k nodes in O(nk) space complexity, which can be further optimized to O(n).</p><p>Proof. Assume that we have key K ∈ R n×d k and value V ∈ R n×dv matrices of the Att function in Graph Multi-head Attention (GMH) for the simplicity, which is described in the equation 6. To obtain the weights on the values V , we multiply the query Q with key K: QK T , where Q is defined as a seed vector S ∈ R k×d in GMPool function. This matrix multiplication then maps a set of n nodes into a set of k nodes, such that it requires the O(nk) space complexity. Also, we can further drop the constant term k: O(n), by properly setting the small k values; k n.</p><p>The multiplication of the attention weights QK T with value V also takes the same complexity, such that the overall space complexity of MGPool is O(nk), which can be further optimized to O(n).</p><p>The space complexity of GNNs with sparse implementation tasks the O(n + m) space complexity, where n is the number of nodes, and m is the number of edges in a graph. Therefore, multiple GNNs followed by our GMPool require the total space complexity of O(n + m) due to the space complexity of the GNN operations. However, GNNs with our GMPool are more efficient than node clustering methods since node clustering approaches need O(n 2 ) space complexity.</p><p>Proposition 5 (Approximation to Node Clustering). Graph Multiset Pooling GMPool k can perform hierarchical node clustering with learnable k cluster centroids by Seed Vector S in equation 7.</p><p>Proof. Node clustering approaches are widely used to coarsen a given large graph in a hierarchical manner with several message-passing functions. The core part of the node clustering schemes is to generate a cluster assignment matrix C, to coarsen nodes and adjacency matrix as in an equation 4. Therefore, if our Graph Multiset Pooling (GMPool) can generate a cluster assignment matrix C, then the proposed GMPool can be approximated to the node clustering approaches.</p><p>In the proposed GMPool, query Q is generated from a learnable set of k seed vectors S, and key K and value V are generated from node features H with GNNs in the Graph Multi-head Attention (GMH) block, as in an equation 6. In this function, if we decompose the attention function Att(Q, K, V ) = w(QK T )V into the dot products of the query with all keys, and the corresponding weighted sum of values, then the first dot product term inherently generates a soft assignment matrix as follows: C = w(QK T ). Therefore, the proposed GMPool can be easily extended to the node clustering schemes, with the inherently generated cluster assignment matrix; C = w(QK T ), where one of the proper choices for the activation function w is the softmax function as follows:</p><formula xml:id="formula_12">w(QK T ) i,j = exp(Q i K T j ) k n=1 exp(Q n K T j )<label>(11)</label></formula><p>Furthermore, through the learnable seed vectors S, we can learn data dependent k different cluster centroids in an end-to-end fashion.</p><p>Note that, as shown in the section 4.2 of the main paper, the proposed GMPool significantly outperforms the previous node clustering approaches <ref type="bibr" target="#b48">(Ying et al., 2018;</ref><ref type="bibr" target="#b4">Bianchi et al., 2019)</ref>. This is because, contrary to them, the proposed GMPool can explicitly learn data dependent k cluster centroids by learnable seed vectors S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B DETAILS FOR GRAPH MULTISET TRANSFORMER COMPONENTS</head><p>In this section, we describe the Graph Multiset Pooling (GMPool) and Self-Attention (SelfAtt), which are the components of the proposed architecture Graph Multiset Transformer, in detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Graph Multiset Pooling</head><p>The core components of the Graph Multiset Pooling (GMPool) is the Graph Multi-head Attention (GMH) that considers the graph structure into account, by constructing the key and value using GNNs, as described in the equation 6. As shown in the Table <ref type="table" target="#tab_0">2</ref> of the main paper, this graph multi-head attention (GMH; equation 6) significantly outperforms the naive multihead attention (MH; equation 5). However, after compressing the n nodes into the k nodes with GMPool k , we can not directly perform further GNNs since the original adjacency information is useless after pooling. To tackle this limitation, we can generate the new adjacency matrix A for the compressed nodes, by performing node clustering as described in Proposition 5 of the main paper as follows:</p><formula xml:id="formula_13">GMPool 1 (GMPool k (H, A), A ); A = C T AC, (<label>12</label></formula><formula xml:id="formula_14">)</formula><p>where C is the generated cluster assignment matrix, and A is the coarsened adjacency matrix as described in the equation 4. However, this approach is well known for their scalability issues <ref type="bibr" target="#b23">(Lee et al., 2019b;</ref><ref type="bibr" target="#b5">Cangea et al., 2018)</ref>, since they require quadratic space O(n 2 ) to store and even multiply the adjacency matrix A with the soft assignment matrix C. Therefore, we leave doing this as future work, and use the following tricks. By replacing the adjacency matrix A with the identity matrix I in the GMPool except for the first block, we can easily perform multiple GMPools without any constraints, which is approximated to the GMPool with MH (equation 5) rather than GMH (equation 6) as follows:</p><formula xml:id="formula_15">GMPool 1 (GMPool k (H, A), A ); A = I. (<label>13</label></formula><formula xml:id="formula_16">)</formula><p>Self-Attention The Self-Attention (SelfAtt) function can consider the inter-relationships between nodes in a set, which helps the network to take the global graph structure into account. Because of this advantage, the self-attention function significantly improves the proposed model performance on the graph classification tasks, as shown in the Table <ref type="table" target="#tab_0">2</ref> of the main paper. From a different perspective, we can treat the Self-Attention function as a graph neural network (GNN) with a complete graph. Specifically, given k nodes from the previous layer, the Multi-head Attention (MH) of the Self-Attention function first constructs the adjacency matrix among all nodes with their similarity, through the matrix multiplication of the query with key: QK T , then computes the outputs with the sum of the obtained weights on the value. In other words, the self-attention function can be considered as one message passing function with a soft adjacency matrix, which might be further connected to the Graph Attention Network <ref type="bibr" target="#b39">(Velickovic et al., 2018)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C EXPERIMENTAL SETUP</head><p>In this section, we first introduce the baselines and our model, and then describe the experimental details about graph classification, reconstruction, and generation tasks respectively.</p><p>C.1 BASELINES AND OUR MODEL 1) GCN. This method <ref type="bibr" target="#b21">(Kipf &amp; Welling, 2017)</ref> is the mean pooling baseline with Graph Convolutional Network (GCN) as a message passing layer.</p><p>2) GIN. This method <ref type="bibr" target="#b46">(Xu et al., 2019)</ref> is the sum pooling baseline with Graph Isomorphism Network (GIN) as a message passing layer.</p><p>3) Set2Set. This method <ref type="bibr" target="#b40">(Vinyals et al., 2016)</ref> is the set pooling baseline that uses recurrent neural network to encode the set of all nodes, with content-based attention over them.</p><p>4) SortPool. This method <ref type="bibr" target="#b52">(Zhang et al., 2018)</ref> is the node drop baseline that drops unimportant nodes by sorting their representation, which is directly generated from the previous GNN layers. 5) DiffPool. This method <ref type="bibr" target="#b48">(Ying et al., 2018)</ref> is the node clustering baseline that produces the hierarchical representation of the graphs in an end-to-end fashion, by clustering similar nodes into the few nodes through graph convolutional layers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MP MP MP</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Global</head><p>6) SAGPool. This method <ref type="bibr" target="#b23">(Lee et al., 2019b)</ref> is the node drop baseline that selects the important nodes, by dropping unimportant nodes with lower scores that is generated by the another graph convolutional layer. Particularly, this method has two variants. 6.1) SAGPool(G) is the global node drop method that drops unimportant nodes one time at the end of their architecture. 6.2) SAGPool(H) is the hierarchical node drop method that drops unimportant nodes sequentially with multiple graph convolutional layers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7)</head><p>TopkPool. This method <ref type="bibr" target="#b15">(Gao &amp; Ji, 2019)</ref> is the node drop baseline that selects the top-ranked nodes using a learnable scoring function.</p><p>8) ASAP. This method <ref type="bibr" target="#b34">(Ranjan et al., 2020)</ref> is the node drop baseline that first locally generates the clusters with neighboring nodes, and then drops the lower score clusters using a scoring function. 9) MinCutPool. This method <ref type="bibr" target="#b4">(Bianchi et al., 2019)</ref> is the node clustering baseline that applies the spectral clustering with GNNs, to coarsen the nodes and the adjacency matrix of a graph. 10) StructPool. This method <ref type="bibr" target="#b50">(Yuan &amp; Ji, 2020)</ref> is the node clustering baseline that integrates the concept of the conditional random field into the graph pooling. While this method can be used with a hierarchical scheme, we use it with a global scheme following their original implementation, which is similar to the SortPool <ref type="bibr" target="#b52">(Zhang et al., 2018)</ref>.</p><p>11) EdgePool. This method <ref type="bibr" target="#b10">(Diehl, 2019)</ref> is the edge clustering baseline that gradually merges the nodes by contracting the high score edge between two adjacent nodes.</p><p>12) HaarPool. This method (Wang et al., 2019) is the spectral-based pooling baseline that compresses the node features with a nonlinear transformation in a Haar wavelet domain. Since it directly uses the spectral clustering to generate a coarsened matrix, the time complexity cost is relatively high than other pooling methods.</p><p>13) GMT. Our proposed Graph Multiset Transformer that first condenses all nodes into the important nodes by GMPool, and then considers interaction between nodes in a set. Since in operates on the global READOUT layer, it can be coupled with any pooling methods by replacing their last layer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.2 GRAPH CLASSIFICATION</head><p>Dataset Among TU datasets <ref type="bibr" target="#b28">(Morris et al., 2020)</ref>, we select the 6 datasets including 3 datasets (D&amp;D, PROTEINS, and MUTAG) on Biochemical domain, and 3 datasets (IMDB-B, IMDB-M, and COLLAB) on Social domain. We use the classification accuracy as an evaluation metric. As suggested by <ref type="bibr" target="#b14">Errica et al. (2020)</ref> for a fair comparison, we use the one-hot encoding of their atom types as initial node features in the bio-chemical datasets, and the one-hot encoding of node degrees as initial node features in the social datasets. Moreover, we use the recently suggested 4 molecule graphs (HIV, Tox21, ToxCast, BBBP) from the OGB datasets <ref type="bibr" target="#b18">(Hu et al., 2020)</ref>. We use the ROC-AUC for an evaluation metric, and use the additional atom and bond features, as suggested by <ref type="bibr" target="#b18">(Hu et al., 2020)</ref>. Dataset statistics are reported in the Table <ref type="table">1</ref> of the main paper.</p><p>Implementation Details on Classification Experiments For all experiments on TU datasets, we evaluate the model performance with a 10-fold cross validation setting, where the dataset split is based on the conventionally used training/validation/test splits <ref type="bibr" target="#b30">(Niepert et al., 2016;</ref><ref type="bibr" target="#b52">Zhang et al., 2018;</ref><ref type="bibr" target="#b46">Xu et al., 2019)</ref>, with LIBSVM <ref type="bibr" target="#b7">(Chang &amp; Lin, 2011)</ref>. In addition, we use the 10 percent of the training data as a validation data following the fair comparison setup <ref type="bibr" target="#b14">(Errica et al., 2020)</ref>.</p><p>For all experiments on OGB datasets, we evaluate the model performance following the original training/validation/test dataset splits <ref type="bibr" target="#b18">(Hu et al., 2020)</ref>. We use the early stopping criterion, where we stop the training if there is no further improvement on the validation loss during 50 epochs. Further, the maximum number of epochs is set to 500. We then report the average performances on the validation and test sets, by performing overall experiments 10 times with 10 different seeds.</p><p>For all experiments on TU datasets except the D&amp;D, the learning rate is set to 5 × 10 −4 , hidden size is set to 128, batch size is set to 128, weight decay is set to 1 × 10 −4 , and dropout rate is set to 0.5. Since the D&amp;D dataset has a large number of nodes (See Table <ref type="table">1</ref> in the main paper), node clustering methods can not perform clustering operations on large graphs with large batch size, such that the hidden size is set to 32, and batch size is set to 10 on D&amp;D dataset. For all experiments on OGB datasets except the HIV, the learning rate is set to 1 × 10 −3 , hidden size is set to 128, batch size is set to 128, weight decay is set to 1 × 10 −4 , and dropout rate is set to 0.5. Since the HIV dataset contains a large number of graphs compared to others (See Table <ref type="table">1</ref> in the main paper), the batch size is set to 512 for fast training. Then we optimize the network with Adam optimizer <ref type="bibr" target="#b20">(Kingma &amp; Ba, 2014)</ref>. For a fair comparison of baselines <ref type="bibr" target="#b23">(Lee et al., 2019b)</ref>, we use the three GCN layers <ref type="bibr" target="#b21">(Kipf &amp; Welling, 2017)</ref> as a message passing function for all models with jumping knowledge strategies <ref type="bibr" target="#b45">(Xu et al., 2018)</ref>, and only change the pooling architecture throughout all models, as illustrated in Figure <ref type="figure" target="#fig_8">9</ref>. Also, we set the pooling ratio as 25% in each pooling layer for both baselines and our models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Implementation Details on Efficiency Experiments</head><p>To compare the GPU memory efficiency of GMT against baseline models including node drop and node clustering methods, we first generate the Erdos-Renyi graphs <ref type="bibr" target="#b13">(Erdős &amp; Rényi, 1960)</ref> by varying the number of nodes n, where edge sizes m are twice the number of nodes: m = 2n. For all models, we compress the given n nodes into the k = 4 nodes at the first pooling function.</p><p>To compare the time efficiency of GMT against baseline models, we first generate the Erdos-Renyi graphs <ref type="bibr" target="#b13">(Erdős &amp; Rényi, 1960)</ref> by varying the number of nodes n with m = n 2 /10 edges, following the setting of <ref type="bibr">HaarPool (Wang et al., 2019)</ref>. For all models, we set the pooling ratio as 25% except for HaarPool, since it compresses the nodes according to the coarse-grained chain of a graph. We measure the forward time, including CPU and GPU, for all models with 50 graphs over one batch.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.3 GRAPH RECONSTRUCTION</head><p>Dataset We first experiment with synthetic graphs represented in a 2-D Euclidean space, such as ring and grid structures. The node features of a graph consist of their location in a 2-D coordinate space, and the adjacency matrix indicates the connectivity information of nodes. The goal here is to restore all node locations from compressed features after pooling, with the intact adjacency matrix.</p><p>While synthetic graphs are appropriate choices for the qualitative analysis, we further do the quantitative evaluation of models with real-world molecular graphs. Specifically, we use the subset <ref type="bibr" target="#b12">(Dwivedi et al., 2020)</ref> of the ZINC dataset <ref type="bibr">(Irwin et al., 2012)</ref> that consists of 12K real-world molecular graphs, to further conduct a graph reconstruction on the large number of various graphs. The goal of the molecule reconstruction task is to restore the exact atom types of all nodes in the given graph, from the compressed representations after pooling.</p><p>Common Implementation Details Following <ref type="bibr" target="#b4">(Bianchi et al., 2019)</ref>, we use the two message passing layers right before the pooling operation and right after the unpooling operation. Also, both  pooling and unpooling operations are performed once and sequentially connected, as illustrated in the Figure <ref type="figure" target="#fig_8">9</ref>. We compare our methods against both the node drop (TopKPool <ref type="bibr" target="#b15">(Gao &amp; Ji, 2019)</ref>) and node clustering (DiffPool <ref type="bibr" target="#b48">(Ying et al., 2018) and</ref><ref type="bibr">MinCutPool (Bianchi et al., 2019)</ref>) methods. For the node drop method, we use the unpooling operation proposed in the graph U-net <ref type="bibr" target="#b15">(Gao &amp; Ji, 2019)</ref>. For the node clustering methods, we use the graph coarsening schemes described in the equation 4 with their specific implementation on generating an assignment matrix. For our proposed methods, we only use the one Graph Multiset Pooling (GMPool) without SelfAtt, where we follow the node clustering approaches as described in the subsection 3.4 by generating a single soft assignment matrix with one head h = 1 in the multi-head attention function. For experiments of both synthetic and molecule reconstructions, the learning rate is set to 5 × 10 −3 , hidden size is set to 32. We then optimize the network with Adam optimizer <ref type="bibr" target="#b20">(Kingma &amp; Ba, 2014)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Implementation Details on Synthetic Graph</head><p>We set the compression ratio (pooling ratio) of all models as 25% on synthetic graph reconstruction. For the design of the loss function, we use the Mean Squared Error (MSE) to train the models. We use the early stopping criterion, where we stop the training if there is no further improvement on the training loss during 1,000 epochs. Further, the maximum number of epochs is set to 10,000. Note that, there is no other available graphs for validation of the synthetic graph, such that we train and test the models only with the given graph in the Figure <ref type="figure" target="#fig_10">10</ref>. The baseline results are adopted from <ref type="bibr" target="#b4">Bianchi et al. (2019)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Implementation Details on Molecule Graph</head><p>We set the compression ratio (pooling ratio) of all models as 5%, 10%, 15%, and 25% on molecule graph reconstruction, and plot all results in the Figure <ref type="figure">6</ref> of the main paper. Note that, in the case of molecule graph reconstruction, softmax layer is appended at the last layer of the model architecture to classify the original atom types of all nodes. For the design of the loss function, we use the cross entropy loss to train the models. We use the early stopping criterion, where we stop the training if there is no further improvement on the validation loss during 50 epochs. Further, the maximum number of epochs is set to 500 and batch size is set to 128. Note that, in the case of molecule graph reconstruction on ZINC dataset, we strictly separate the training, validation and test sets, as suggested by <ref type="bibr" target="#b12">Dwivedi et al. (2020)</ref>. We perform all experiments 5 times with 5 different random seeds, and then report the averaged results with the standard deviation. Note that, in addition to the baselines mentioned above in the common implementation details paragraph, we compare two more baselines: GCN with random assignment matrix for pooling, which is adopted from <ref type="bibr" target="#b26">Mesquita et al. (2020)</ref>, and StructPool <ref type="bibr" target="#b50">(Yuan &amp; Ji, 2020)</ref>, for real-world molecule graph reconstruction.</p><p>Evaluation Metrics for Molecule Reconstruction For quantitative evaluations of the molecule reconstruction, we use the three metrics as follows: 1) validity indicates the number of reconstructed molecules that are chemically valid, 2) exact match indicates the number of reconstructed molecules that are exactly same as the original molecules, and 3) accuracy indicates the classification accuracy of atom types for every nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.4 GRAPH GENERATION</head><p>Common Implementation Details In the graph generation experiments, we replace the graph embedding function f (G) from existing graph generation models to the proposed Graph Multiset Table <ref type="table">4</ref>: Graph classification results on validation sets with standard deviations. All results are averaged over 10 different runs. Best performance and its comparable results (p &gt; 0.05) from the t-test are marked in blod. Hyphen (-) denotes out-of-resources that take more than 10 days (See Figure <ref type="figure">4</ref> for the time efficiency analysis). For MinCutPool, since it cannot directly compress the all n nodes into the 1 cluster to represent the entire graph, we use the following tricks to replace the simple pooling operation (e.g. sum or mean) with it. We first condense the graph into the k clusters (k = 4) using one MinCutPool layer, and then average the condensed nodes to get a single representation of the given graph. However, our proposed Graph Multiset Transformer (GMT) can directly compress the all n nodes into the 1 node with one learnable seed vector, by using the single GMPool 1 block. In other words, we use the one GMPool 1 to represent the entire graph by replacing their simple pooling (e.g. sum or mean), in which we use the following softmax activation function:</p><formula xml:id="formula_17">w(QK T ) i,j = exp(Q i K T j ) n k=1 exp(Q i K T k )<label>(14)</label></formula><p>Implementation Details on Molecule Generation For the molecule generation experiment with the MolGAN, we replace the average pooling in the discriminator with GMPool 1 . We use the QM9 dataset <ref type="bibr" target="#b33">(Ramakrishnan et al., 2014)</ref>  Implementation Details on Retrosynthesis For the retrosynthesis experiment with the Graph Logic Network (GLN), we replace the average pooling in the template and subgraph encoding functions with GMPool 1 . We use the USPTO-50k dataset. For an evaluation metric, we use the Top-k accuracy for both reaction class is not given and given cases, following the original paper <ref type="bibr" target="#b29">(Dai et al., 2019)</ref>. We reproduce all results in Table <ref type="table" target="#tab_2">3</ref> with published codes from the original paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D ADDITIONAL EXPERIMENTAL RESULTS</head><p>Validation Results on Graph Classification We additionally provide the validation results on the graph classification task. As shown in Table <ref type="table">4</ref>, proposed GMT outperforms most baselines, or Leaderboard Results on Graph Classification For a fair comparison, we experiment with all baselines and our models in the same setting, as described in implementation details of Appendix C.2. Specifically, we average the results over 10 different runs with the same hidden dimension (128, and leaderboard uses 300), and the same number of message-passing layers (3, and leaderboard uses 5) with 10 different seeds for all models. Therefore, the results can be slightly different from the leaderboard results, as shown in Table <ref type="table" target="#tab_5">5</ref>, since the leaderboard uses different hyper-parameters with different random seeds (See <ref type="bibr" target="#b18">Hu et al. (2020)</ref> for more detail). However, our reproduction results are almost the same as leaderboard results with the standard deviation, and sometimes outperform the leaderboard results (See the GCN results for the HIV dataset in Table <ref type="table" target="#tab_5">5</ref>). Therefore, while we conduct all experiments under the same setting for a fair comparison and specific hyperparameter choices are slightly different from the leaderboard setting, these results indicate that there is no significant difference between reproduced and leaderboard results.</p><p>Adjacency Reconstruction for Graph Reconstruction While we conduct experiments for reconstructing nodes in a graph to quantify the retained information on condensed nodes after pooling (See Section 4.2 for experiments on the graph reconstruction task), we further reconstruct the adjacency matrix to see if the pooling layer can also condense the adjacency structure without loss of information. The learning objective to minimize the discrepancy between the original adjacency matrix A and the reconstructed adjacency matrix A rec with a cluster assignment matrix C ∈ R n×k is defined as follows: min A − A rec , where A rec = CA pool C T .</p><p>Then we design the following two experiments. First, pooling layers are trained to minimize the objective in Section 4.2: min X−X rec , and then we measure the discrepancy between the original and the reconstructed node features: X − X rec , and the discrepancy between the original and the reconstructed adjacency matrix: A − A rec . Second, pooling layers are trained to minimize the objective described in the previous paragraph: min A−A rec , and then we measure the mentioned two discrepancies.</p><p>We experiment with synthetic grid and ring graphs, illustrated in Figure <ref type="figure" target="#fig_10">10</ref>. Table <ref type="table" target="#tab_4">6</ref> shows that the error is large when the objective and the error metrics are different, which indicates that there is a high discrepancy between the required information for condensing node and the required information for condensing adjacency matrix. In other words, the compression for node and the compression for adjacency matrix might be differently performed to reconstruct the whole graph information.</p><p>Also, Table <ref type="table" target="#tab_4">6</ref> shows that there are some cases where there is no significant difference in the calculated adjacency error ( A − A rec ), when minimizing nodes discrepancies and minimizing adjacency discrepancies (See 0.0331 and 0.0324 for GMT on Ring Graph). Also, calculated errors for the adjacency matrix on minimizing adjacency are larger than the calculated errors for node features on minimizing nodes. These results indicate that the adjacency matrix is difficult to reconstruct after pooling. This might be because the reconstructed adjacency matrix should be further transformed from continuous values to discrete values (0 or 1 for the undirected simple graph), while the re-constructed node feature can be represented as continuous values. We leave further reconstructing adjacency matrices and visualizing them as future work. As visualized in Figure <ref type="figure" target="#fig_13">11</ref>, we can see that the same atom or the similarly connected atoms obtain the same cluster. For example, the atom type O mostly obtains the yellow cluster, and the atom type F obtains the green cluster. Furthermore, ring-shaped substructures that do not contain O or N mostly receive the blue cluster, whereas ring-shaped substructures that contain O and N receive the green and yellow cluster respectively. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Additional Examples for Molecule Reconstruction</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Concepts (Left): Conceptual comparison of graph pooling methods. Grey box indicates the readout layer, which is compatible with our method. Also, green check icon indicates the model that can be as powerful as the WL test. (Right): An illustration of set, multiset, and graph multiset encoding for graph representation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Graph Multiset Transformer. Given a graph passed through several message passing layers, we use an attention-based pooling block (GMPool) and a self-attention block (SelfAtt) to compress the nodes into few important nodes and consider the interaction among them respectively, within a multiset framework.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :Figure 4 :</head><label>34</label><figDesc>Figure 3: Memory efficiency of GMT compared with baselines. X indicates out-of-memory error.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :Figure 6 :</head><label>56</label><figDesc>Figure 5: Reconstruction results of the ring and grid synthetic graphs, compared to the node drop and node clustering methods.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Figure5shows the original and the reconstructed graphs for synthetic ring and grid structures. The noisy results of baselines indicate that the condensed node features do not fully capture the original graph structure. Whereas our GMPool yields almost perfect reconstruction, which demonstrates that our pooling operation learns meaningful representation without discarding the original graph information.Results on Molecule GraphWe further validate the reconstruction performance of the proposed GMPool on the real-world molecule graph, namely ZINC, by varying the compression ratio. Figure6shows reconstruction results on the molecule graph, on which GMPool largely outperforms all compared baselines in terms of validity, exact match, and accuracy (High score indicates the better, and see Appendix C.3 for the detailed description of evaluation metrics). With given results, we demonstrate that our GMPool can be easily extended to the node clustering schemes, while it is powerful enough to encode meaningful information to reconstruct the graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :Figure 8 :</head><label>78</label><figDesc>Figure 7: Reconstruction example with assigned clusters as colors on left and reconstructed molecules on right. Qualitative Analysis We visualize the reconstruction examples from ZINC in Figure 7, where colors in the left figure indicate the assigned clusters of each model on the original molecule and red dashed circles in the right indicate the incorrectly predicted atoms on the reconstructed molecule. As shown in Figure 7, GMPool yields more calibrated clustering over MinCutPool, capturing the detailed substructure of molecules, which results in the successful reconstruction (See Figure 11 in Appendix D for more reconstruction examples).4.3 GRAPH GENERATIONObjective The graph generation task is used to generate a valid graph that satisfies the desired properties, in which graph encoding methods are directly used to improve the graph generation performances. Formally, given a graph G with graph encoding function f , the goal here is to generate a valid graph Ḡ ∈ G of desired property y with graph decoding function g as follows: min d(y, Ḡ), where Ḡ = g(f (G)). d is a distance metric between the generated graph and desired properties, (e.g. validity for molecule optimization), to guarantee that the graph has them.Experimental Setup To evaluate the applicability of our model, we experiment on Molecule Generation to stably generate the valid molecules withMolGAN (Cao &amp; Kipf, 2018)  and Retrosynthesis to empower the synthesis performances with Graph Logic Network (GLN)<ref type="bibr" target="#b29">(Dai et al., 2019)</ref>, by replacing their graph embedding function f (G) to ours. In both experiments, we replace the average pooling to either the MinCutPool or GMT. See Appendix C.4 for more experimental details.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Illustration of High-level Model Architectures (Top): Global Graph Classification; GCN, GIN, Set2Set, SortPool, SAGPool(G), StructPool, GMT. (Middle:) Hierarchical Graph Classification; DiffPool, SAGPool(H), TopKPool, MinCutPool, ASAP, EdgePool, HaarPool. (Bottom:) Graph Reconstruction; Diff-Pool, TopKPool, MinCutPool, GMT. MP denotes the message passing layer.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: High resolution image for synthetic graph reconstruction results in Figure 5.</figDesc><graphic url="image-18.png" coords="19,269.35,153.57,143.76,69.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>following the original MolGAN paper<ref type="bibr" target="#b6">(Cao &amp; Kipf, 2018)</ref>. To evaluate the models, we report the validity of 13,319 generated molecules at the early stage of the MolGAN training, over 4 different runs. As depicted in Figure8of the main paper, each solid curve indicates the average validity of each model with 4 different random seeds, and the shaded area indicates the half of the standard deviation for 4 different runs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>We visualize the examples for molecule reconstruction on the ZINC dataset in Figure 11. Molecules on the left side indicate the original molecule, where the transparent color denotes the assigned cluster for each node, which is obtained by the cluster assignment matrix C with node (atom) representations in a graph (molecule) (See Proposition 5 for more detail on generating the cluster assignment matrix). Also, molecules on the right side indicate the reconstructed molecules with failure cases denoted as a red dotted circle.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Molecule Reconstruction Examples (Left): Original Molecules with the assigned cluster for each node, which is generated from Graph Multiset Pooling (GMPool), and represented as color. (Right): Reconstructed Molecules. Red dotted circle indicates the incorrect atom prediction.</figDesc><graphic url="image-26.png" coords="22,307.61,587.77,176.59,59.50" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 2 :</head><label>2</label><figDesc>MinCutPool 78.22 ± 0.54 74.72 ± 0.48 79.17 ± 1.64 75.37 ± 2.05 75.11 ± 0.69 62.48 ± 1.33 65.97 ± 1.13 72.65 ± 0.75 51.04 ± 0.70 80.87 ± 0.34 4 / 10 StructPool 78.45 ± 0.40 75.16 ± 0.86 79.50 ± 1.75 75.85 ± 1.81 75.43 ± 0.79 62.17 ± 1.61 67.01 ± 2.65 72.06 ± 0.64 50.23 ± 0.53 77.27 ± 0.51 Ours) 78.72 ± 0.59 75.09 ± 0.59 83.44 ± 1.33 77.56 ± 1.25 77.30 ± 0.59 65.44 ± 0.58 68.31 ± 1.62 73.48 ± 0.76 50.66 ± 0.82 80.74 ± 0.54 Ablation</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Biochemical Domain</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Social Domain</cell><cell></cell><cell>Significance</cell></row><row><cell></cell><cell>D&amp;D</cell><cell cols="3">PROTEINS MUTAG</cell><cell>HIV</cell><cell>Tox21</cell><cell>ToxCast</cell><cell>BBBP</cell><cell>IMDB-B</cell><cell>IMDB-M</cell><cell>COLLAB</cell></row><row><cell># graphs</cell><cell>1,178</cell><cell cols="2">1,113</cell><cell>188</cell><cell>41,127</cell><cell>7,831</cell><cell>8,576</cell><cell>2,039</cell><cell>1,000</cell><cell>1,500</cell><cell>5,000</cell><cell>-</cell></row><row><cell># classes</cell><cell>2</cell><cell>2</cell><cell></cell><cell>2</cell><cell>2</cell><cell>12</cell><cell>617</cell><cell>2</cell><cell>2</cell><cell>3</cell><cell>3</cell><cell>-</cell></row><row><cell>Avg # nodes</cell><cell>284.32</cell><cell cols="2">39.06</cell><cell>17.93</cell><cell>25.51</cell><cell>18.57</cell><cell>18.78</cell><cell>24.06</cell><cell>19.77</cell><cell>13.00</cell><cell>74.49</cell><cell>-</cell></row><row><cell>GCN</cell><cell cols="11">72.05 ± 0.55 73.24 ± 0.73 69.50 ± 1.78 76.81 ± 1.01 75.04 ± 0.80 60.63 ± 0.51 65.47 ± 1.73 73.26 ± 0.46 50.39 ± 0.41 80.59 ± 0.27</cell><cell>3 / 10</cell></row><row><cell>GIN</cell><cell cols="11">70.79 ± 1.17 71.46 ± 1.66 81.39 ± 1.53 75.95 ± 1.35 73.27 ± 0.84 60.83 ± 0.46 67.65 ± 3.00 72.78 ± 0.86 48.13 ± 1.36 78.19 ± 0.63</cell><cell>2 / 10</cell></row><row><cell>Set2Set</cell><cell cols="11">71.94 ± 0.56 73.27 ± 0.85 69.89 ± 1.94 74.70 ± 1.65 74.10 ± 1.13 59.70 ± 1.04 66.79 ± 1.05 72.90 ± 0.75 50.19 ± 0.39 79.55 ± 0.39</cell><cell>1 / 10</cell></row><row><cell>SortPool</cell><cell cols="11">75.58 ± 0.72 73.17 ± 0.88 71.94 ± 3.55 71.82 ± 1.63 69.54 ± 0.75 58.69 ± 1.71 65.98 ± 1.70 72.12 ± 1.12 48.18 ± 0.83 77.87 ± 0.47</cell><cell>0 / 10</cell></row><row><cell>DiffPool</cell><cell cols="11">77.56 ± 0.41 73.03 ± 1.00 79.22 ± 1.02 75.64 ± 1.86 74.88 ± 0.81 62.28 ± 0.56 68.25 ± 0.96 73.14 ± 0.70 51.31 ± 0.72 78.68 ± 0.43</cell><cell>3 / 10</cell></row><row><cell cols="12">SAGPool(G) 71.54 ± 0.91 72.02 ± 1.08 76.78 ± 2.12 74.56 ± 1.69 71.10 ± 1.06 59.88 ± 0.79 65.16 ± 1.93 72.16 ± 0.88 49.47 ± 0.56 78.85 ± 0.56</cell><cell>0 / 10</cell></row><row><cell cols="12">SAGPool(H) 74.72 ± 0.82 71.56 ± 1.49 73.67 ± 4.28 71.44 ± 1.67 69.81 ± 1.75 58.91 ± 0.80 63.94 ± 2.59 72.55 ± 1.28 50.23 ± 0.44 78.03 ± 0.31</cell><cell>1 / 10</cell></row><row><cell>TopKPool</cell><cell cols="11">73.63 ± 0.55 70.48 ± 1.01 67.61 ± 3.36 72.27 ± 0.91 69.39 ± 2.02 58.42 ± 0.91 65.19 ± 2.30 71.58 ± 0.95 48.59 ± 0.72 77.58 ± 0.85</cell><cell>0 / 10</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>3 / 10</cell></row><row><cell>ASAP</cell><cell cols="11">76.58 ± 1.04 73.92 ± 0.63 77.83± 1.49 72.86 ± 1.40 72.24 ± 1.66 58.09 ± 1.62 63.50 ± 2.47 72.81 ± 0.50 50.78 ± 0.75 78.64 ± 0.50</cell><cell>1 / 10</cell></row><row><cell>EdgePool</cell><cell cols="10">75.85 ± 0.58 75.12 ± 0.76 74.17± 1.82 72.66 ± 1.70 73.77 ± 0.68 60.70 ± 0.92 67.18 ± 1.97 72.46 ± 0.74 50.79 ± 0.59</cell><cell>-</cell><cell>3 / 9</cell></row><row><cell>HaarPool</cell><cell>-</cell><cell>-</cell><cell cols="2">66.11± 1.50</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell cols="3">66.11 ± 0.82 73.29 ± 0.34 49.98 ± 0.57</cell><cell>-</cell><cell>1 / 5</cell></row><row><cell cols="13">GMT (10 / 10</cell></row><row><cell>Model</cell><cell></cell><cell cols="3">D&amp;D PROTEINS BBBP</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>GMT</cell><cell></cell><cell>78.72</cell><cell>75.09</cell><cell>68.31</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="3">w/o message passing 78.06</cell><cell>75.07</cell><cell>65.26</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="3">w/o graph attention 78.08</cell><cell>74.50</cell><cell>66.21</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">w/o self-attention</cell><cell>75.13</cell><cell>74.22</cell><cell>64.53</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">mean pooling</cell><cell>72.05</cell><cell>73.24</cell><cell>65.47</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note>Study of GMTon the D&amp;D, PROTEINS, and BBBP datasets for graph classification.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 :</head><label>3</label><figDesc>Top-k accuracy for Retrosynthesis experiment on USPTO-50k data, for cases where the reaction class is given as prior information (Bottom) and not given (Top).</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>) 76.73 ± 0.80 77.01 ± 0.58 88.11 ± 1.21 80.55 ± 1.89 77.03 ± 0.76 65.51 ± 0.91 95.59 ± 1.22 78.09 ± 0.58 53.73 ± 0.42 81.91 ± 0.45 SAGPool(H) 79.56 ± 0.67 77.24 ± 0.56 86.06 ± 2.07 79.21 ± 1.50 75.36 ± 2.63 64.05 ± 0.83 93.05 ± 3.00 77.11 ± 0.46 53.49 ± 0.65 80.55 ± 0.56 TopKPool 78.54 ± 0.73 75.47 ± 0.90 75.06 ± 2.12 79.24 ± 1.84 75.06 ± 2.30 64.56 ± 0.56 93.31 ± 2.32 76.12 ± 0.79 52.75 ± 0.58 79.94 ± 0.86 MinCutPool 81.96 ± 0.39 79.23 ± 0.66 87.22 ± 1.72 83.12 ± 1.27 81.10 ± 0.42 69.09 ± 1.12 95.99 ± 0.47 77.76 ± 0.36 54.94 ± 0.19 83.37 ± 0.18 StructPool 82.56 ± 0.37 80.00 ± 0.27 91.5 ± 0.95 81.09 ± 1.26 79.61 ± 0.70 66.49 ± 1.59 95.18 ± 0.59 77.14 ± 0.31 54.13 ± 0.39 79.90 ± 0.18 ASAP 81.58 ± 0.38 78.71 ± 0.45 91.33± 0.65 79.80 ± 1.88 77.33 ± 1.34 63.82 ± 0.75 92.96 ± 1.09 77.89 ± 0.51 55.17 ± 0.33 82.11 ± 0.33 Ours) 82.19 ± 0.40 80.01 ± 0.21 91.00 ± 0.82 83.54 ± 0.78 80.91 ± 0.41 69.77 ± 0.67 95.14 ± 0.48 78.43 ± 0.22 55.14 ± 0.25 83.37 ± 0.11 Transformer (GMT), to evaluate the applicability of our model on generation tasks, as described in the subsection 4.3 of the main paper. As baselines, we first use the original models with their implementations. Specifically, we use the MolGAN 1 (Cao &amp; Kipf, 2018) for molecule generation, and Graph Logic Network (GLN) 2 (Dai et al., 2019) for retrosynthesis. For both experiments, we directly follow the experimental details of original papers (Cao &amp; Kipf, 2018; Dai et al., 2019) for a fair comparison. Furthermore, to compare our models with another strong pooling method, we use the MinCutPool (Bianchi et al., 2019) as an additional baseline for generation tasks, since it shows the best performance among baselines in the previous two classification and reconstruction tasks.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell cols="2">Biochemical Domain</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Social Domain</cell><cell></cell></row><row><cell></cell><cell>D&amp;D</cell><cell cols="2">PROTEINS MUTAG</cell><cell>HIV</cell><cell>Tox21</cell><cell>ToxCast</cell><cell>BBBP</cell><cell>IMDB-B</cell><cell>IMDB-M</cell><cell>COLLAB</cell></row><row><cell># graphs</cell><cell>1,178</cell><cell>1,113</cell><cell>188</cell><cell>41,127</cell><cell>7,831</cell><cell>8,576</cell><cell>2,039</cell><cell>1,000</cell><cell>1,500</cell><cell>5,000</cell></row><row><cell># classes</cell><cell>2</cell><cell>2</cell><cell>2</cell><cell>2</cell><cell>12</cell><cell>617</cell><cell>2</cell><cell>2</cell><cell>3</cell><cell>3</cell></row><row><cell>Avg # nodes</cell><cell>284.32</cell><cell>39.06</cell><cell>17.93</cell><cell>25.51</cell><cell>18.57</cell><cell>18.78</cell><cell>24.06</cell><cell>19.77</cell><cell>13.00</cell><cell>74.49</cell></row><row><cell>GCN</cell><cell cols="10">76.17 ± 0.65 77.13 ± 0.44 76.56 ± 1.75 81.27 ± 0.92 78.80 ± 0.40 65.66 ± 0.40 93.35 ± 1.08 77.93 ± 0.28 54.29 ± 0.23 83.08 ± 0.13</cell></row><row><cell>GIN</cell><cell cols="10">76.85 ± 0.61 78.43 ± 0.45 94.44 ± 0.52 82.10 ± 1.01 78.20 ± 0.45 66.29 ± 0.42 94.64 ± 0.36 78.38 ± 0.26 54.04 ± 0.29 82.19 ± 0.25</cell></row><row><cell>Set2Set</cell><cell cols="10">76.32 ± 0.40 77.64 ± 0.41 79.72 ± 2.40 80.07 ± 0.93 79.13 ± 0.75 66.39 ± 0.49 91.89 ± 1.48 78.13 ± 0.30 54.39 ± 0.19 82.34 ± 0.23</cell></row><row><cell>SortPool</cell><cell cols="10">80.68 ± 0.59 77.92 ± 0.42 81.33 ± 3.00 81.17 ± 2.30 75.97 ± 0.76 64.26 ± 1.17 94.21 ± 1.04 77.46 ± 0.60 52.95 ± 0.62 80.58 ± 0.25</cell></row><row><cell>DiffPool</cell><cell cols="10">81.33 ± 0.33 79.09 ± 0.36 87.94 ± 1.93 83.16 ± 0.44 80.02 ± 0.38 69.73 ± 0.79 96.32 ± 0.36 77.86 ± 0.39 54.77 ± 0.19 81.69 ± 0.31</cell></row><row><cell>SAGPool(GEdgePool</cell><cell cols="9">80.32 ± 0.44 79.61 ± 0.25 87.28± 1.18 81.84 ± 1.32 78.92 ± 0.29 66.21 ± 0.64 94.98 ± 0.62 77.50 ± 0.25 54.69 ± 0.40</cell><cell>-</cell></row><row><cell>HaarPool</cell><cell>-</cell><cell>-</cell><cell>68.22± 0.86</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell cols="3">89.98 ± 0.58 76.72 ± 0.60 53.03 ± 0.14</cell><cell>-</cell></row><row><cell>GMT (</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 6 :</head><label>6</label><figDesc>Quantitative results of graph reconstruction on reconstructing the node feature and the adjacency matrix for synthetic graphs, with two different minimization objective and error calculation metrics: X −X rec and A − A rec . * indicates the model without adjacency normalization. comparable performance to the best baseline results even in the validation sets. While validation results can not directly measure the generalization performance of the model for unseen data, these results further confirm that our method is powerful enough, compared to baselines. Regarding the results of the test set on the graph classification task, please see Table1in the main paper.</figDesc><table><row><cell>Data:</cell><cell></cell><cell cols="2">Grid Graph</cell><cell></cell><cell></cell><cell cols="2">Ring Graph</cell><cell></cell></row><row><cell>Objective:</cell><cell cols="2">min X − X rec</cell><cell cols="2">min A − A rec</cell><cell cols="2">min X − X rec</cell><cell cols="2">min A − A rec</cell></row><row><cell>Error Calculation:</cell><cell>X − X rec</cell><cell>A − A rec</cell><cell>X − X rec</cell><cell>A − A rec</cell><cell>X − X rec</cell><cell>A − A rec</cell><cell>X − X rec</cell><cell>A − A rec</cell></row><row><cell>DiffPool</cell><cell>0.0833</cell><cell>12110194</cell><cell>0.3908</cell><cell>0.0856</cell><cell>0.0032</cell><cell>617.7706</cell><cell>0.6208</cell><cell>0.0948</cell></row><row><cell>MinCutPool</cell><cell>0.0001</cell><cell>0.0092</cell><cell>1.2883</cell><cell>0.0051</cell><cell>0.0005</cell><cell>0.0424</cell><cell>0.5026</cell><cell>0.0128</cell></row><row><cell>MinCutPool*</cell><cell>0.0002</cell><cell>201.7619</cell><cell>2.0261</cell><cell>0.0616</cell><cell>0.0003</cell><cell>68.23</cell><cell>0.5211</cell><cell>0.0725</cell></row><row><cell>GMT (Ours)</cell><cell>0.0001</cell><cell>0.0102</cell><cell>0.2353</cell><cell>0.0084</cell><cell>0.0000</cell><cell>0.0331</cell><cell>0.5475</cell><cell>0.0324</cell></row></table><note>achieves</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 5 :</head><label>5</label><figDesc>Graph classification results for OGB test datasets with standard deviations. Leaderboard GCN 76.06 ± 0.97 75.29 ± 0.69 GIN 75.58 ± 1.40 74.91 ± 0.51 Reproduced GCN 76.81 ± 1.01 75.04 ± 0.80 GIN 75.95 ± 1.35 73.27 ± 0.84 Ours GMT 77.56 ± 1.25 77.30 ± 0.59</figDesc><table><row><cell>Model</cell><cell>HIV</cell><cell>Tox21</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0">https://github.com/yongqyu/MolGAN-pytorch</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1">https://github.com/Hanjun-Dai/GLN</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Memorybased graph networks</title>
		<author>
			<persName><forename type="first">Amir</forename><surname>Hosein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Khas</forename><surname>Ahmadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kaveh</forename><surname>Hassani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Parsa</forename><surname>Moradi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leo</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Quaid</forename><surname>Morris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">8th International Conference on Learning Representations</title>
				<meeting><address><addrLine>Addis Ababa, Ethiopia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2020">April 26-30, 2020, 2020</date>
			<biblScope unit="volume">2020</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Diffusion-convolutional neural networks</title>
		<author>
			<persName><forename type="first">James</forename><surname>Atwood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Don</forename><surname>Towsley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems 29: Annual Conference on Neural Information Processing Systems</title>
				<meeting><address><addrLine>Barcelona, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-12-05">2016. December 5-10, 2016. 2016</date>
			<biblScope unit="page" from="1993" to="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Jimmy</forename><surname>Lei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jamie</forename><surname>Ba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Geoffrey</forename><forename type="middle">E</forename><surname>Ryan Kiros</surname></persName>
		</author>
		<author>
			<persName><surname>Hinton</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1607.06450</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note type="report_type">Layer normalization. arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Neural machine translation by jointly learning to align and translate</title>
		<author>
			<persName><forename type="first">Dzmitry</forename><surname>Bahdanau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kyunghyun</forename><surname>Cho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yoshua</forename><surname>Bengio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">3rd International Conference on Learning Representations, ICLR 2015</title>
				<meeting><address><addrLine>San Diego, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">May 7-9, 2015. 2015</date>
		</imprint>
	</monogr>
	<note>Conference Track Proceedings</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Spectral clustering with graph neural networks for graph pooling</title>
		<author>
			<persName><forename type="first">Maria</forename><surname>Filippo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniele</forename><surname>Bianchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cesare</forename><surname>Grattarola</surname></persName>
		</author>
		<author>
			<persName><surname>Alippi</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1907.00481</idno>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Towards sparse hierarchical graph classifiers</title>
		<author>
			<persName><forename type="first">Catalina</forename><surname>Cangea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Petar</forename><surname>Velickovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nikola</forename><surname>Jovanovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Kipf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pietro</forename><surname>Liò</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1811.01287</idno>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Molgan: An implicit generative model for small molecular graphs</title>
		<author>
			<persName><forename type="first">Nicola</forename><surname>De</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cao</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Kipf</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1805.11973</idno>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">LIBSVM: A library for support vector machines</title>
		<author>
			<persName><forename type="first">Chih-Chung</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chih-Jen</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Intell. Syst. Technol</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">27</biblScope>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Discriminative embeddings of latent variable models for structured data</title>
		<author>
			<persName><forename type="first">Hanjun</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bo</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Le</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33nd International Conference on Machine Learning, ICML 2016</title>
				<meeting>the 33nd International Conference on Machine Learning, ICML 2016<address><addrLine>New York City, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016">June 19-24, 2016. 2016</date>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="2702" to="2711" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Retrosynthesis prediction with conditional graph logic network</title>
		<author>
			<persName><forename type="first">Hanjun</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chengtao</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Connor</forename><forename type="middle">W</forename><surname>Coley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bo</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Le</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems 32: Annual Conference on Neural Information Processing Systems</title>
				<meeting><address><addrLine>NeurIPS; Vancouver, BC, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-12-14">2019. 2019, 8-14 December 2019. 2019</date>
			<biblScope unit="page" from="8870" to="8880" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Edge contraction pooling for graph neural networks</title>
		<author>
			<persName><forename type="first">Frederik</forename><surname>Diehl</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1905.10990</idno>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Convolutional networks on graphs for learning molecular fingerprints</title>
		<author>
			<persName><forename type="first">David</forename><surname>Duvenaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dougal</forename><surname>Maclaurin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jorge</forename><surname>Aguilera-Iparraguirre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rafael</forename><surname>Gómez-Bombarelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Timothy</forename><surname>Hirzel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alán</forename><surname>Aspuru-Guzik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ryan</forename><forename type="middle">P</forename><surname>Adams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems 28: Annual Conference on Neural Information Processing Systems</title>
				<meeting><address><addrLine>Montreal, Quebec, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-12-07">2015. December 7-12, 2015. 2015</date>
			<biblScope unit="page" from="2224" to="2232" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Benchmarking graph neural networks</title>
		<author>
			<persName><forename type="first">Vijay</forename><surname>Prakash Dwivedi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chaitanya</forename><forename type="middle">K</forename><surname>Joshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Laurent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yoshua</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xavier</forename><surname>Bresson</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2003.00982</idno>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">On the evolution of random graphs</title>
		<author>
			<persName><forename type="first">P</forename><surname>Erdős</surname></persName>
		</author>
		<author>
			<persName><surname>Rényi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PUBLICATION OF THE MATHE-MATICAL INSTITUTE OF THE HUNGARIAN ACADEMY OF SCIENCES</title>
				<imprint>
			<date type="published" when="1960">1960</date>
			<biblScope unit="page" from="17" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A fair comparison of graph neural networks for graph classification</title>
		<author>
			<persName><forename type="first">Federico</forename><surname>Errica</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marco</forename><surname>Podda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Davide</forename><surname>Bacciu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alessio</forename><surname>Micheli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">8th International Conference on Learning Representations</title>
				<meeting><address><addrLine>Addis Ababa, Ethiopia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2020">April 26-30, 2020, 2020</date>
			<biblScope unit="volume">2020</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Graph u-nets</title>
		<author>
			<persName><forename type="first">Hongyang</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shuiwang</forename><surname>Ji</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th International Conference on Machine Learning, ICML 2019</title>
				<meeting>the 36th International Conference on Machine Learning, ICML 2019<address><addrLine>Long Beach, California, USA</addrLine></address></meeting>
		<imprint>
			<publisher>PMLR</publisher>
			<date type="published" when="2019-06-15">9-15 June 2019. 2019</date>
			<biblScope unit="volume">97</biblScope>
			<biblScope unit="page" from="2083" to="2092" />
		</imprint>
	</monogr>
	<note>of Proceedings of Machine Learning Research</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Inductive representation learning on large graphs</title>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">L</forename><surname>Hamilton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhitao</forename><surname>Ying</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jure</forename><surname>Leskovec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems 30: Annual Conference on Neural Information Processing Systems</title>
				<meeting><address><addrLine>Long Beach, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-12-09">2017, 4-9 December 2017. 2017</date>
			<biblScope unit="page" from="1024" to="1034" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Multilayer feedforward networks are universal approximators</title>
		<author>
			<persName><forename type="first">Kurt</forename><surname>Hornik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maxwell</forename><forename type="middle">B</forename><surname>Stinchcombe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Halbert</forename><surname>White</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neural Networks</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="359" to="366" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Open graph benchmark: Datasets for machine learning on graphs</title>
		<author>
			<persName><forename type="first">Weihua</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Fey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marinka</forename><surname>Zitnik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuxiao</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hongyu</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bowen</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michele</forename><surname>Catasta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jure</forename><surname>Leskovec</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2005.00687</idno>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">ZINC: A free tool to discover chemistry for biology</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Teague</forename><surname>John</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">M</forename><surname>Sterling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Erin</forename><forename type="middle">S</forename><surname>Mysinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ryan</forename><forename type="middle">G</forename><surname>Bolstad</surname></persName>
		</author>
		<author>
			<persName><surname>Coleman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Chem. Inf. Model</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="1757" to="1768" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Adam: A method for stochastic optimization</title>
		<author>
			<persName><forename type="first">P</forename><surname>Diederik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jimmy</forename><surname>Kingma</surname></persName>
		</author>
		<author>
			<persName><surname>Ba</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1412.6980</idno>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Semi-supervised classification with graph convolutional networks</title>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">N</forename><surname>Kipf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Max</forename><surname>Welling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">5th International Conference on Learning Representations, ICLR 2017</title>
		<title level="s">Conference Track Proceedings</title>
		<meeting><address><addrLine>Toulon, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">April 24-26, 2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Set transformer: A framework for attention-based permutation-invariant neural networks</title>
		<author>
			<persName><forename type="first">Juho</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yoonho</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jungtaek</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adam</forename><forename type="middle">R</forename><surname>Kosiorek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Seungjin</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yee</forename><forename type="middle">Whye</forename><surname>Teh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th International Conference on Machine Learning, ICML 2019</title>
				<meeting>the 36th International Conference on Machine Learning, ICML 2019<address><addrLine>Long Beach, California, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-06-15">9-15 June 2019. 2019a</date>
			<biblScope unit="page" from="3744" to="3753" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Self-attention graph pooling</title>
		<author>
			<persName><forename type="first">Junhyun</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Inyeop</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jaewoo</forename><surname>Kang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th International Conference on Machine Learning, ICML 2019</title>
				<meeting>the 36th International Conference on Machine Learning, ICML 2019<address><addrLine>Long Beach, California, USA</addrLine></address></meeting>
		<imprint>
			<publisher>PMLR</publisher>
			<date type="published" when="2019-06-15">9-15 June 2019. 2019b</date>
			<biblScope unit="volume">97</biblScope>
			<biblScope unit="page" from="3734" to="3743" />
		</imprint>
	</monogr>
	<note>of Proceedings of Machine Learning Research</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Semi-supervised graph classification: A hierarchical graph perspective</title>
		<author>
			<persName><forename type="first">Jia</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yu</forename><surname>Rong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hong</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Helen</forename><surname>Meng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wen-Bing</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Junzhou</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The World Wide Web Conference</title>
				<meeting><address><addrLine>San Francisco, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2019-05-13">2019. May 13-17, 2019. 2019</date>
			<biblScope unit="page" from="972" to="982" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Graph convolutional networks with eigenpooling</title>
		<author>
			<persName><forename type="first">Yao</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Suhang</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charu</forename><forename type="middle">C</forename><surname>Aggarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiliang</forename><surname>Tang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th ACM SIGKDD International Conference on Knowledge Discovery &amp; Data Mining, KDD 2019</title>
				<meeting>the 25th ACM SIGKDD International Conference on Knowledge Discovery &amp; Data Mining, KDD 2019<address><addrLine>Anchorage, AK, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2019">August 4-8, 2019. 2019</date>
			<biblScope unit="page" from="723" to="731" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Rethinking pooling in graph neural networks</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">P</forename><surname>Diego</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amauri</forename><forename type="middle">H</forename><surname>Mesquita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Samuel</forename><surname>Souza</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><surname>Kaski</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2010.11418</idno>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Weisfeiler and leman go neural: Higher-order graph neural networks</title>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Ritzert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Fey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">L</forename><surname>Hamilton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Eric Lenssen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gaurav</forename><surname>Rattan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Grohe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Thirty-Third AAAI Conference on Artificial Intelligence, AAAI 2019, The Thirty-First Innovative Applications of Artificial Intelligence Conference, IAAI 2019, The Ninth AAAI Symposium on Educational Advances in Artificial Intelligence</title>
				<meeting><address><addrLine>Honolulu, Hawaii, USA</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2019-02-01">January 27 -February 1, 2019. 2019</date>
			<biblScope unit="volume">2019</biblScope>
			<biblScope unit="page" from="4602" to="4609" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Tudataset: A collection of benchmark datasets for learning with graphs</title>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nils</forename><forename type="middle">M</forename><surname>Kriege</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Franka</forename><surname>Bause</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kristian</forename><surname>Kersting</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Petra</forename><surname>Mutzel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marion</forename><surname>Neumann</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2007.08663</idno>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Unsupervised universal self-attention network for graph classification</title>
		<author>
			<persName><forename type="first">Tu</forename><surname>Dai Quoc Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dinh</forename><surname>Dinh Nguyen</surname></persName>
		</author>
		<author>
			<persName><surname>Phung</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1909.11855</idno>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Learning convolutional neural networks for graphs</title>
		<author>
			<persName><forename type="first">Mathias</forename><surname>Niepert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohamed</forename><surname>Ahmed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Konstantin</forename><surname>Kutzkov</surname></persName>
		</author>
		<ptr target="JMLR.org" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33nd International Conference on Machine Learning, ICML 2016</title>
				<meeting>the 33nd International Conference on Machine Learning, ICML 2016<address><addrLine>New York City, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016">June 19-24, 2016. 2016</date>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="2014" to="2023" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Pointnet: Deep learning on point sets for 3d classification and segmentation</title>
		<author>
			<persName><forename type="first">Charles</forename><surname>Ruizhongtai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Qi</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Hao</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kaichun</forename><surname>Mo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonidas</forename><forename type="middle">J</forename><surname>Guibas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2017 IEEE Conference on Computer Vision and Pattern Recognition</title>
				<meeting><address><addrLine>Honolulu, HI, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2017-07-21">2017. July 21-26, 2017. 2017a</date>
			<biblScope unit="page" from="77" to="85" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Pointnet: Deep learning on point sets for 3d classification and segmentation</title>
		<author>
			<persName><forename type="first">Charles</forename><surname>Ruizhongtai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Qi</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Hao</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kaichun</forename><surname>Mo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonidas</forename><forename type="middle">J</forename><surname>Guibas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2017 IEEE Conference on Computer Vision and Pattern Recognition</title>
				<meeting><address><addrLine>Honolulu, HI, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2017-07-21">2017. July 21-26, 2017. 2017b</date>
			<biblScope unit="page" from="77" to="85" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Quantum chemistry structures and properties of 134 kilo molecules</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ramakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Pavlo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Dral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">A</forename><surname>Rupp</surname></persName>
		</author>
		<author>
			<persName><surname>Lilienfeld</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Scientific Data</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">ASAP: adaptive structure aware pooling for learning hierarchical graph representations</title>
		<author>
			<persName><forename type="first">Ekagra</forename><surname>Ranjan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Soumya</forename><surname>Sanyal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Partha</forename><forename type="middle">P</forename><surname>Talukdar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Tenth AAAI Symposium on Educational Advances in Artificial Intelligence</title>
				<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2020">February 7-12, 2020. 2020</date>
			<biblScope unit="volume">2020</biblScope>
			<biblScope unit="page" from="5470" to="5477" />
		</imprint>
	</monogr>
	<note>The Thirty-Fourth AAAI Conference on Artificial Intelligence</note>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">GROVER: self-supervised message passing transformer on large-scale molecular data</title>
		<author>
			<persName><forename type="first">Yu</forename><surname>Rong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yatao</forename><surname>Bian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tingyang</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Weiyang</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ying</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wenbing</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Junzhou</forename><surname>Huang</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2007.02835</idno>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Dynamic edge-conditioned filters in convolutional neural networks on graphs</title>
		<author>
			<persName><forename type="first">Martin</forename><surname>Simonovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nikos</forename><surname>Komodakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2017 IEEE Conference on Computer Vision and Pattern Recognition</title>
				<meeting><address><addrLine>Honolulu, HI, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2017-07-21">2017. July 21-26, 2017. 2017</date>
			<biblScope unit="page" from="29" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Prototypical networks for few-shot learning</title>
		<author>
			<persName><forename type="first">Jake</forename><surname>Snell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Swersky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><forename type="middle">S</forename><surname>Zemel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems 30: Annual Conference on Neural Information Processing Systems</title>
				<meeting><address><addrLine>Long Beach, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-12-09">2017, 4-9 December 2017. 2017</date>
			<biblScope unit="page" from="4077" to="4087" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Attention is all you need</title>
		<author>
			<persName><forename type="first">Ashish</forename><surname>Vaswani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Noam</forename><surname>Shazeer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Niki</forename><surname>Parmar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jakob</forename><surname>Uszkoreit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Llion</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aidan</forename><forename type="middle">N</forename><surname>Gomez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lukasz</forename><surname>Kaiser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Illia</forename><surname>Polosukhin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems 30: Annual Conference on Neural Information Processing Systems</title>
				<meeting><address><addrLine>Long Beach, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-12-09">2017, 4-9 December 2017. 2017</date>
			<biblScope unit="page" from="5998" to="6008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Graph attention networks</title>
		<author>
			<persName><forename type="first">Petar</forename><surname>Velickovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guillem</forename><surname>Cucurull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arantxa</forename><surname>Casanova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adriana</forename><surname>Romero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pietro</forename><surname>Liò</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yoshua</forename><surname>Bengio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">6th International Conference on Learning Representations, ICLR 2018</title>
		<title level="s">Conference Track Proceedings</title>
		<meeting><address><addrLine>Vancouver, BC, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-05-03">April 30 -May 3, 2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Order matters: Sequence to sequence for sets</title>
		<author>
			<persName><forename type="first">Oriol</forename><surname>Vinyals</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Samy</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manjunath</forename><surname>Kudlur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">4th International Conference on Learning Representations, ICLR 2016</title>
		<title level="s">Conference Track Proceedings</title>
		<meeting><address><addrLine>San Juan, Puerto Rico</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016">May 2-4, 2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">On the limitations of representing functions on sets</title>
		<author>
			<persName><forename type="first">Edward</forename><surname>Wagstaff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabian</forename><surname>Fuchs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Engelcke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ingmar</forename><surname>Posner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">A</forename><surname>Osborne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th International Conference on Machine Learning, ICML 2019</title>
				<editor>
			<persName><forename type="first">Kamalika</forename><surname>Chaudhuri</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ruslan</forename><surname>Salakhutdinov</surname></persName>
		</editor>
		<meeting>the 36th International Conference on Machine Learning, ICML 2019<address><addrLine>Long Beach, California, USA</addrLine></address></meeting>
		<imprint>
			<publisher>PMLR</publisher>
			<date type="published" when="2019-06-15">9-15 June 2019. 2019</date>
			<biblScope unit="volume">97</biblScope>
			<biblScope unit="page" from="6487" to="6494" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">Haarpooling: Graph pooling with compressive haar basis</title>
		<author>
			<persName><forename type="first">Yu</forename><surname>Guang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wang</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Ming</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zheng</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guido</forename><surname>Montúfar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaosheng</forename><surname>Zhuang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yanan</forename><surname>Fan</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1909.11580</idno>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">Reduction of a graph to a canonical form and an algebra arising during this reduction</title>
		<author>
			<persName><forename type="first">B</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Weisfeiler</surname></persName>
		</author>
		<author>
			<persName><surname>Leman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1968">1968</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<author>
			<persName><forename type="first">Zonghan</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shirui</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fengwen</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guodong</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chengqi</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philip</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1901.00596</idno>
		<title level="m">A comprehensive survey on graph neural networks</title>
				<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Representation learning on graphs with jumping knowledge networks</title>
		<author>
			<persName><forename type="first">Keyulu</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chengtao</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yonglong</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tomohiro</forename><surname>Sonobe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ken-Ichi</forename><surname>Kawarabayashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefanie</forename><surname>Jegelka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 35th International Conference on Machine Learning, ICML 2018</title>
				<meeting>the 35th International Conference on Machine Learning, ICML 2018<address><addrLine>Stockholmsmässan, Stockholm, Sweden</addrLine></address></meeting>
		<imprint>
			<publisher>PMLR</publisher>
			<date type="published" when="2018">July 10-15, 2018. 2018</date>
			<biblScope unit="volume">80</biblScope>
			<biblScope unit="page" from="5449" to="5458" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">How powerful are graph neural networks?</title>
		<author>
			<persName><forename type="first">Keyulu</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Weihua</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jure</forename><surname>Leskovec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefanie</forename><surname>Jegelka</surname></persName>
		</author>
		<idno>ICLR 2019</idno>
	</analytic>
	<monogr>
		<title level="m">7th International Conference on Learning Representations</title>
				<meeting><address><addrLine>New Orleans, LA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019">May 6-9, 2019. OpenReview.net, 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">GSPN: generative shape proposal network for 3d instance segmentation in point cloud</title>
		<author>
			<persName><forename type="first">Li</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wang</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">He</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Minhyuk</forename><surname>Sung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonidas</forename><forename type="middle">J</forename><surname>Guibas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Conference on Computer Vision and Pattern Recognition, CVPR 2019</title>
				<meeting><address><addrLine>Long Beach, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Computer Vision Foundation / IEEE</publisher>
			<date type="published" when="2019">June 16-20, 2019. 2019</date>
			<biblScope unit="page" from="3947" to="3956" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Hierarchical graph representation learning with differentiable pooling</title>
		<author>
			<persName><forename type="first">Zhitao</forename><surname>Ying</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiaxuan</forename><surname>You</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiang</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">L</forename><surname>Hamilton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jure</forename><surname>Leskovec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems 31: Annual Conference on Neural Information Processing Systems</title>
				<meeting><address><addrLine>NeurIPS; Montréal, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-12-08">2018. 2018, 3-8 December 2018. 2018</date>
			<biblScope unit="page" from="4805" to="4815" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Position-aware graph neural networks</title>
		<author>
			<persName><forename type="first">Jiaxuan</forename><surname>You</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rex</forename><surname>Ying</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jure</forename><surname>Leskovec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th International Conference on Machine Learning, ICML 2019</title>
				<meeting>the 36th International Conference on Machine Learning, ICML 2019<address><addrLine>Long Beach, California, USA</addrLine></address></meeting>
		<imprint>
			<publisher>PMLR</publisher>
			<date type="published" when="2019-06-15">9-15 June 2019. 2019</date>
			<biblScope unit="volume">97</biblScope>
			<biblScope unit="page" from="7134" to="7143" />
		</imprint>
	</monogr>
	<note>of Proceedings of Machine Learning Research</note>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Structpool: Structured graph pooling via conditional random fields</title>
		<author>
			<persName><forename type="first">Hao</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shuiwang</forename><surname>Ji</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">8th International Conference on Learning Representations</title>
				<meeting><address><addrLine>Addis Ababa, Ethiopia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2020">April 26-30, 2020, 2020</date>
			<biblScope unit="volume">2020</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Deep sets</title>
		<author>
			<persName><forename type="first">Manzil</forename><surname>Zaheer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Satwik</forename><surname>Kottur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Siamak</forename><surname>Ravanbakhsh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Barnabás</forename><surname>Póczos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ruslan</forename><surname>Salakhutdinov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexander</forename><forename type="middle">J</forename><surname>Smola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems 30: Annual Conference on Neural Information Processing Systems</title>
				<meeting><address><addrLine>Long Beach, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-12-09">2017, 4-9 December 2017. 2017</date>
			<biblScope unit="page" from="3391" to="3401" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">An end-to-end deep learning architecture for graph classification</title>
		<author>
			<persName><forename type="first">Muhan</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhicheng</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marion</forename><surname>Neumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yixin</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Thirty-Second AAAI Conference on Artificial Intelligence, (AAAI-18), the 30th innovative Applications of Artificial Intelligence (IAAI-18), and the 8th AAAI Symposium on Educational Advances in Artificial Intelligence (EAAI-18)</title>
				<meeting>the Thirty-Second AAAI Conference on Artificial Intelligence, (AAAI-18), the 30th innovative Applications of Artificial Intelligence (IAAI-18), and the 8th AAAI Symposium on Educational Advances in Artificial Intelligence (EAAI-18)<address><addrLine>New Orleans, Louisiana, USA</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2018">February 2-7, 2018. 2018</date>
			<biblScope unit="page" from="4438" to="4445" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<author>
			<persName><forename type="first">Jie</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ganqu</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhengyan</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cheng</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhiyuan</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maosong</forename><surname>Sun</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1812.08434</idno>
		<title level="m">Graph neural networks: A review of methods and applications</title>
				<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
