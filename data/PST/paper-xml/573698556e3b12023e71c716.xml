<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">NetPaxos: Consensus at Network Speed</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Tu</forename><surname>Huynh</surname></persName>
						</author>
						<author>
							<persName><surname>Dang</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Università della Svizzera italiana</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Daniele</forename><surname>Sciascia</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Università della Svizzera italiana</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Marco</forename><surname>Canini</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Université catholique de Louvain</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Fernando</forename><surname>Pedone</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Università della Svizzera italiana</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Robert</forename><surname>Soulé</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Università della Svizzera italiana</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="laboratory">SOSR2015</orgName>
								<address>
									<addrLine>June 17 -18</addrLine>
									<postCode>2015</postCode>
									<settlement>Santa Clara</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">NetPaxos: Consensus at Network Speed</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">C372233FFF38AD23F76F6D79C3D57867</idno>
					<idno type="DOI">10.1145/2774993.2774999</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:13+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C.2.4 [Distributed Systems]: Network operating systems</term>
					<term>C.4 [Performance of Systems]: Reliability, availability, and serviceability</term>
					<term>D.4.5 [Reliability]: Fault-tolerance Software-defined networking, Paxos, NetPaxos</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper explores the possibility of implementing the widely deployed Paxos consensus protocol in network devices. We present two different approaches: (i) a detailed design description for implementing the full Paxos logic in SDN switches, which identifies a sufficient set of required OpenFlow extensions; and (ii) an alternative, optimistic protocol which can be implemented without changes to the OpenFlow API, but relies on assumptions about how the network orders messages. Although neither of these protocols can be fully implemented without changes to the underlying switch firmware, we argue that such changes are feasible in existing hardware. Moreover, we present an evaluation that suggests that moving Paxos logic into the network would yield significant performance benefits for distributed applications.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Software-defined networking (SDN) is transforming the way networks are configured and run. In contrast to traditional networks, in which forwarding devices have proprietary control interfaces, SDNs generalize network devices using a set of protocols defined by open standards, including most prominently the OpenFlow <ref type="bibr" target="#b24">[24]</ref> protocol. This move towards standardization has led to increased "network pro-grammability", allowing ordinary programs to manage the network through direct access to network devices.</p><p>Several recent projects have used SDN platforms to demonstrate that applications can benefit from improved network support. While these projects are important first steps, they have largely focused on one class of applications (i.e., Hadoop data processing <ref type="bibr" target="#b12">[12,</ref><ref type="bibr" target="#b15">15,</ref><ref type="bibr" target="#b21">21,</ref><ref type="bibr" target="#b36">36]</ref>), and on improving performance via data-plane configuration (e.g., route selection <ref type="bibr" target="#b15">[15,</ref><ref type="bibr" target="#b36">36]</ref>, traffic prioritization <ref type="bibr" target="#b12">[12,</ref><ref type="bibr" target="#b36">36]</ref>, or traffic aggregation <ref type="bibr" target="#b21">[21]</ref>). None of this work has fundamentally considered whether application logic could be moved into the network. In other words: how can distributed applications and protocols utilize network programmability to improve performance?</p><p>This paper focuses specifically on the Paxos consensus protocol <ref type="bibr" target="#b19">[19]</ref>. Paxos is an attractive use-case for several reasons. First, it is one of the most widely deployed protocols in highly-available, distributed systems, and is a fundamental building block to a number of distributed applications <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b9">9]</ref>. Second, there exists extensive prior research on optimizing Paxos <ref type="bibr" target="#b20">[20,</ref><ref type="bibr" target="#b22">22,</ref><ref type="bibr" target="#b31">31,</ref><ref type="bibr" target="#b32">32]</ref>, which suggests that the protocol could benefit from increased network support. Third, moving consensus logic into network devices would require extending the OpenFlow API with functionality that is amenable to an efficient hardware implementation <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b5">5]</ref>.</p><p>Implementing Paxos in the network provides a different point in the design space, and identifies a different set of network requirements for protocol implementors. This paper presents two different approaches: (i) a detailed description of a sufficient set of OpenFlow extensions needed to implement the full Paxos logic in SDN switches; and (ii) an alternative, optimistic protocol which can be implemented without changes to the OpenFlow API, but relies on assumptions about how the network orders messages.</p><p>Although neither of these protocols can be fully implemented without changes to the underlying switch firmware, we present evidence to show that such changes are feasible. Moreover, we present an evaluation that suggests that moving consensus logic into the network would reduce application complexity, reduce application message latency, and increase transaction throughput.</p><p>In summary, this paper makes the following contributions:</p><p>• It identifies a sufficient set of features that protocol implementors would need to provide to implement consensus logic in network devices.</p><p>• It describes an alternative protocol, inspired by Fast Paxos <ref type="bibr" target="#b20">[20]</ref>, which can be implemented without changes to the OpenFlow API, but relies on assumptions about how the network orders messages.</p><p>• It presents experiments that suggest the potential performance improvements that would be gained by moving consensus logic into the network.</p><p>The rest of this paper is organized as follows. We first provide a short summary of the Paxos protocol ( §2), followed by a description of the two approaches to providing network support for Paxos ( §3). Then, we present the results from our experimental evaluation ( §4), discuss related work ( §5), and conclude ( §6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PAXOS BACKGROUND</head><p>State-machine replication <ref type="bibr" target="#b18">[18,</ref><ref type="bibr" target="#b34">34]</ref> is a fundamental approach to designing fault-tolerant systems used by many distributed applications and services (e.g., Google's Chubby <ref type="bibr" target="#b6">[6]</ref>, Scatter <ref type="bibr" target="#b14">[14]</ref>, Spanner <ref type="bibr" target="#b9">[9]</ref>). The key idea is to replicate services, so that a failure at any one replica does not prevent the remaining operational replicas from servicing client requests. State-machine replication is implemented using a consensus protocol, which dictates how the participants propagate and execute commands.</p><p>Paxos <ref type="bibr" target="#b19">[19]</ref> is perhaps the most widely used consensus protocol. Paxos participants, which communicate by exchanging messages, may play any of three roles: proposers issue requests to the distributed system (i.e., propose a value); acceptors choose a single value; and learners provide replication by learning what value has been chosen. Note that a process may play one or more roles simultaneously. For example, a client in a distributed system may be both a proposer and a learner.</p><p>A Paxos instance is one execution of consensus. An instance begins when a proposer issues a request, and ends when learners know what value has been chosen by the acceptor. The protocol proceeds in a sequence of rounds. Each round has two phases. For each round, one process, typically a proposer or acceptor, acts as the coordinator of the round. Phase 1. The coordinator selects a unique round number c-rnd and asks the acceptors to promise that in the given instance they will reject any requests (Phase 1 or 2) with round number less than c-rnd. Phase 1 is completed when a majority-quorum Q a of acceptors confirms the promise to the coordinator. Notice that since Phase 1 is independent of the value proposed it can be pre-executed by the coordinator <ref type="bibr" target="#b19">[19]</ref>. If any acceptor already accepted a value for the current instance, it will return this value to the coordinator, together with the round number received when the value was accepted (v-rnd).</p><p>Phase 2. The coordinator selects a value according to the following rule: if no acceptor in Q a accepted a value, the coordinator can select any value. If however any of the acceptors returned a value in Phase 1, the coordinator is forced to execute Phase 2 with the value that has the highest round number v-rnd associated to it. In Phase 2, the coordinator sends a message containing a round number (the same used in Phase 1). Upon receiving such a request, the acceptors acknowledge it, unless they have already acknowledged another message (Phase 1 or 2) with a higher round number. Acceptors update their c-rnd and v-rnd variables with the round number in the message. When a quorum of acceptors accepts the same round number (Phase 2 acknowledgment), consensus terminates: the value is permanently bound to the instance, and nothing will change this decision. Thus, learners can deliver the value. Learners learn this decision either by monitoring the acceptors or by receiving a decision message from the coordinator.</p><p>As long as a nonfaulty coordinator is eventually selected and there is a majority quorum of nonfaulty acceptors and at least one nonfaulty proposer, every consensus instance will eventually decide on a value. A failed coordinator is detected by the other nodes, which select a new coordinator. If the coordinator does not receive a response to its Phase 1 message it can re-send it, possibly with a bigger round number. The same is true for Phase 2, although if the coordinator wants to execute Phase 2 with a higher round number, it has to complete Phase 1 with that round number.</p><p>The above describes one instance of Paxos. Throughout this paper, references to Paxos implicitly refer to multiple instances chained together (i.e., Multi-Paxos <ref type="bibr">[7]</ref>).</p><p>Fast Paxos <ref type="bibr" target="#b20">[20]</ref> is a well known optimization of Paxos. It extends the classic rounds, as described above, with fast rounds. In a fast round proposers contact acceptors directly, bypassing the coordinator. Fast rounds save one communication step but are only effective in the absence of collisions, a situation in which acceptors accept different values in the round, and as a result no value is chosen. Fast Paxos can recover from collisions using classic rounds. In order to ensure that no two values are decided, fast rounds require larger quorums than classic rounds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">CONSENSUS IN THE NETWORK</head><p>In this section, we identify two approaches to improving the performance of Paxos by using software-defined networking. Section 3.1 identifies a sufficient set of features that a switch would need to support to implement Paxos logic (i.e., extensions to OpenFlow). Section 3.2 discusses the possibility of implementing consensus using unmodified OpenFlow switches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Paxos in SDN Switches</head><p>We argue that performance benefits could be gained by moving Paxos consensus logic into the network devices them-selves. Specifically, network switches could play the role of coordinators and acceptors. The advantages would be twofold. First, messages would travel fewer hops in the network, therefore reducing the latency for the replicated system to reach consensus. Second, coordinators and acceptors typically act as bottlenecks in Paxos implementations, because they must aggregate or multiplex multiple messages. The consensus protocol we describe in Section 3.2 obviates the need for coordinator logic.</p><p>A switch-based implementation of Paxos need only implement Phase 2 of the protocol described in Section 2. Since Phase 1 does not depend on any particular value, it could be run ahead of time for a large bounded number of values. The pre-computation would need to be re-run under two scenarios: either (i) the Paxos instance approaches the bounded number of values, or (ii) the device acting as coordinator changes (possibly due to failure).</p><p>Unfortunately, even implementing Phase 2 of the Paxos logic in SDN switches goes far beyond what is expressible in the current OpenFlow API, which is limited to basic matchaction rules, simple statistics gathering, and modest packet re-writes (e.g., incrementing the time-to-live). Below, we identify a sufficient set of operations that the switch could perform to implement Paxos. Note, we are not claiming that this set of operations is necessary. As we will see in Section 3.2, the protocol can be modified to avoid some of these requirements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Generate round and sequence number. Each switch coor-</head><p>dinator must be able to generate a unique round number (i.e., the c-rnd variable), and a monotonically increasing, gap-free sequence number.</p><p>Persistent storage. Each switch acceptor must store the latest ballot it has seen (c-rnd), the latest accepted ballot (v-rnd), and the latest value accepted.</p><p>Stateful comparisons. Each switch acceptor must be able to compare a c-round value in a packet header with a c-rnd value that has been stored. If the new value is higher, then the switch must update the local state with the new c-round and value, and then broadcast the message to all learners. Otherwise, the packet could be ignored (i.e., dropped).</p><p>Storage cleanup. Stored state must be trimmed periodically.</p><p>Recent work on extending OpenFlow suggests that the functionality described above could be efficiently implemented in switch hardware <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b5">5,</ref><ref type="bibr" target="#b4">4]</ref>. Moreover, several existing switches already have support of some combinations of these features. For example, the NoviSwitch 1132 has 16 GB of SSD storage <ref type="bibr" target="#b27">[27]</ref>, while the Arista 7124FX <ref type="bibr" target="#b1">[1]</ref> has 50 GB of SSD storage directly usable by embedded applications. Note that current SSDs typically achieve throughputs of several 100s MB/s <ref type="bibr" target="#b29">[29]</ref>, which is within the requirements of a high-performance, network-based Paxos implementation.</p><p>The upcoming Netronome network processor NFP-6xxx <ref type="bibr" target="#b26">[26]</ref>, which is used to realize advanced switches and programmable NICs, has sequence number generators and can flexibly perform stateful comparisons.</p><p>Also, rather than modifying network switches, a recent hardware trend towards programmable NICs <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b25">25]</ref> could allow the proposer and acceptor logic to run at the network edge, on programmable NICs that provide high-speed processing at minimal latencies (tens of µs). Via the PICe bus, the programmable NIC could communicate to the host OS and obtain access to permanent storage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Fast Network Consensus</head><p>Section 3.1 describes a sufficient set of functionality that protocol designers would need to provide to completely implement Paxos logic in forwarding devices. In this section, we describe NetPaxos, an alternative algorithm inspired by Fast Paxos. The key idea behind NetPaxos is to distinguish between two execution modes, a "fast mode" (analogous to Fast Paxos's fast rounds), which can be implemented in network forwarding devices with no changes to existing Open-Flow APIs, and a "recovery mode", which is executed by commodity servers.</p><p>Both Fast Paxos's fast rounds and NetPaxos's fast mode avoid the use of a Paxos coordinator, but for different motivations. Fast Paxos is designed to reduce the total number of message hops by optimistically assuming a spontaneous message ordering. NetPaxos is designed to avoid implementing coordinator logic inside a switch. In contrast to Fast Paxos, the role of acceptors in NetPaxos is simplified. In fact, acceptors do not perform any standard acceptor logic in NetPaxos. Instead, they simply forward all messages they receive, without doing any comparisons. Because they always accept, we refer to them as minions in NetPaxos.</p><p>Figure <ref type="figure" target="#fig_0">1</ref> illustrates the design of NetPaxos. In the figure, all switches are shaded in gray. Proposers send messages to the single switch called a serializer. The serializer is used to establish an ordering of messages from the proposers. The serializer then broadcasts the messages to the minions. Each minion forwards the messages to the learners and to a server that acts as the minion's external storage mechanism, used to record the history of "accepted" messages. Note that if switches could maintain persistent state, there would be no need for the minion storage servers. Each learner has multiple network interfaces, one for each minion.</p><p>The protocol, as described, does not require any additional functionality beyond what is currently available in the Open-Flow protocol. However, it does make two important assumptions:</p><p>1. Packets broadcast from the serializer to the minions arrive in the same order. This assumption is important for performance, not correctness. In other words, if packets are received out-of-order, the learners would recognize the problem, fail to reach consensus, and revert to the "recovery mode" (i.e., classic Paxos). 2. Packets broadcast from a minion arrive all in the same order at its storage and the learners. This assumption is important for correctness. If this assumption is violated, then learners may decide different values in an instance of consensus and not be able to recover a consistent state from examining the logs at the minion storage.</p><p>Recent work on Speculative Paxos <ref type="bibr" target="#b33">[33]</ref> shows that packet reordering happens infrequently in data centers, and can be eliminated by using IP multicast, fixed length network topologies, and a single top-of-rack switch acting as a serializer.</p><p>Our own initial experiments ( § 4) also suggest that these assumptions hold with unmodified network switches when traffic is non-bursty, and below about 675 Mbps on a 1 Gbps link.</p><p>Fast Paxos optimistically assumes a spontaneous message ordering with no conflicting proposals, allowing proposers to send messages directly to acceptors. Rather than relying on spontaneous ordering, NetPaxos uses the serializer to establish an ordering of messages from the proposers. It is important to note that the serializer does not need to establish a FIFO ordering of messages. It simply maximizes the chances that acceptors see the same ordering.</p><p>Learners maintain a queue of messages for each interface. Because there are no sequence or round numbers, learners can only reason about messages by using their ordering in the queue, or by message value. At each iteration of the protocol (i.e., consensus instance), learners compare the values of the messages at the top of their queues. If the head of a quorum with three queues contain the same message, then consensus has been established through the fast mode, and the protocol moves to the next iteration. The absence of a quorum with the same message (e.g., because one of the minions dropped a packet), leads to a conflict.</p><p>Like Fast Paxos <ref type="bibr" target="#b20">[20]</ref>, NetPaxos requires a two-thirds majority to establish consensus, instead of a simple majority. A two-thirds majority allows the protocol to recover from cases in which messages cannot be decided in the fast mode. If a learner detects conflicting proposals in a consensus instance, then the learner reverts to recovery mode and runs a classic round of Paxos to reach consensus on the value to be learned. In this case, the learner must access the storage of the minions to determine the message to be decided. The protocol ensures progress as long as at most one minion fails. Since the non-conflicting scenario is the usual case, NetPaxos typically is able to reduce both latency and the overall number of messages sent to the network.</p><p>Switches and servers may fail individually, and their failures are not correlated. Thus, there are several possible failure cases that we need to consider to ensure availability:</p><p>• Serializer failure. Since the order imposed by the serializer is not needed for correctness, the serializer could easily be made redundant, in which case the protocol would continue to operate despite the failure of one serializer. Figure <ref type="figure" target="#fig_0">1</ref> shows two backup switches for the serializer.</p><p>• Minion failure. If any minion fails, the system could continue to process messages and remain consistent. The configuration in Figure <ref type="figure" target="#fig_0">1</ref>, with four minions, could tolerate the failure of one minion, and still guarantee progress.</p><p>• Learner failure. If the learner fails, it can consult the minion state to see what values have been accepted, and therefore return to a consistent state.</p><p>A natural question would be to ask: if minions always accept messages, why do we need them at all? For example, the serializer could simply forward messages to the learners directly. The algorithm needs minions to provide fault tolerance. Because each minion forwards messages to their external storage mechanism, the system has a log of all accepted messages, which it can use for recovery in the event of device failure, message re-ordering, or message loss. If, alternatively, the serializer were responsible for maintaining the log, then it would become a single point of failure.</p><p>A final consideration is whether network hardware could be modified to ensure the NetPaxos ordering assumptions. We discussed this matter with several industrial contacts at different SDN vendors, and found that there are various platforms that could enforce the desired packet ordering. For example, the Netronome NFP-6xxx <ref type="bibr" target="#b26">[26]</ref> has a packet reorder block on the egress path that allows packets to be reordered based on program-controlled packet sequence numbers. A NetPaxos implementation would assign the sequence numbers based on when the packets arrive at ingress. The NetF-PGA platform <ref type="bibr" target="#b13">[13]</ref> implements a single pipeline where all packet processing happens sequentially. As such, the Net-Paxos ordering assumption is trivially satisfied. Furthermore, discussions with Corsa Technology <ref type="bibr" target="#b10">[10]</ref> and recent work on Blueswitch <ref type="bibr" target="#b16">[16]</ref> indicate that FPGA-based hardware would also be capable of preserving the ordering assumption.</p><p>In the next section, we present experiments that show the expected performance benefits of NetPaxos when these assumptions hold.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">EVALUATION</head><p>Our evaluation focuses on two questions: (i) how frequently are our assumptions violated in practice, and (ii) what are the expected performance benefits that would result from moving Paxos consensus logic into forwarding devices. Experimental setup. All experiments were run on a cluster with two types of servers. Proposers were Dell PowerEdge SC1435 2-CPU servers with 4 x 2 GHz AMD cores, 4 GB RAM, and a 1 Gbps NIC. Learners were Dell PowerEdge R815 8-CPU servers with 64 x 2 GHz AMD hyperthreaded cores, 128 GB RAM, and 4 x 1 Gbps NICs. The machines were connected in the topology shown in Figure <ref type="figure" target="#fig_0">1</ref>. We used three Pica8 Pronto 3290 switches. One switch played the role of the serializer. The other two were divided into two virtual switches, for a total of four virtual switches acting as minions.</p><p>Ordering assumptions. The design of NetPaxos depends on the assumption that switches will forward packets in a deterministic order. Section 3.2 argues that such an ordering could be enforced by changes to the switch firmware. However, in order to quantify the expected performance benefits of moving consensus logic into forwarding devices, we measured how often the assumptions are violated in practice with unmodified devices.</p><p>There are two possible cases to consider if the ordering assumptions do not hold. First, learners could deliver different values. Second, one learner might deliver, when the other does not. It is important to distinguish these two cases because delivering two different values for the same instance violates correctness, while the other case impacts performance (i.e., the protocol would be forced to execute in recovery mode, rather than fast mode).</p><p>The experiment measures the percentage of values that result in a learner disagreement or a learner indecision for increasing message throughput sent by the proposers. For each iteration of the experiment, the proposers repeatedly sleep for 1 ms, and then send n messages, until 500,000 messages have been sent. To increase the target rate, the value of n is increased. The small sleep time interval ensures that traffic is non-bursty. Each message is 1,470 bytes long, and contains a sequence number, a proposer id, a timestamp, and some payload data.</p><p>Two learners receive messages on four NICs, which they processes in FIFO order. The learners dump the contents of each packet to a separate log file for each NIC. We then compare the contents of the log files, by examining the messages in the order that they were received. If the learner sees the same sequence number on at least 3 of its NICs, then the learner can deliver the value. Otherwise, the learner cannot deliver. We also compare the values delivered on both learners, to see if they disagree.</p><p>Figure <ref type="figure" target="#fig_3">2a</ref> shows the results, which are encouraging. We saw no disagreement or indecision for throughputs below 57,457 messages/second. When we increased the throughput to 65,328 messages/second, we measured no learner dis-   agreement, and only 0.3% of messages resulted in learner indecision. Note that given a message size of 1,470 bytes, 65,328 messages/second corresponds to about 768 Mbps, or 75% of the link capacity on our test configuration. Although the results are not shown, we also experimented with sending bursty traffic. We modified the experiment by increasing the sleep time to 1 second. Consequently, most packets were sent at the beginning of the 1 second time window, while the average throughput over the 1 second reached the target rate. Under these conditions, we measured larger amounts of indecision, 2.01%, and larger disagreement, 1.12%.</p><p>Overall, these results suggest that the NetPaxos ordering assumptions are likely to hold for non-bursty traffic for throughput less than 57,457 messages/second. As we will show, this throughput is orders of magnitude greater than a basic Paxos implementation. NetPaxos expected performance. Without enforcing the assumptions about packet ordering, it is impossible to implement a complete, working version of the NetPaxos protocol. However, given that the prior experiment shows that the ordering assumption is rarely violated, it is still possible to compare the expected performance with a basic Paxos implementation. This experiment quantifies the performance improvements we could expect to get from a network-based Paxos implementation for a best case scenario.</p><p>We measured message throughput and latency for Net-Paxos and an open source implementation of basic Paxos<ref type="foot" target="#foot_0">1</ref> that has been used previously in replication literature <ref type="bibr" target="#b35">[35,</ref><ref type="bibr" target="#b23">23]</ref>. As with the prior experiment, two proposers send messages at increasing throughput rates by varying the number of messages sent for 1 ms time windows. Message latency is measured one way, using the time stamp value in the packet, so the accuracy depends on how well the server clocks are synchronized. To synchronize the clocks, we re-ran NTP before each iteration of the experiment.</p><p>The results, shown in Figure <ref type="figure" target="#fig_3">2b</ref>, suggest that moving consensus logic into network devices can have a dramatic impact on application performance. NetPaxos is able to achieve a maximum throughput of 57,457 messages/second. In contrast, with basic Paxos the coordinator becomes CPU bound, and is only able to send 6,369 messages/second.</p><p>Latency is also improved for NetPaxos. The lowest latency that basic Paxos is able to provide is 1.39 ms, when sending at a throughput of only 1,531 messages/second. As throughput increases, latency also increases sharply. At 6,369 messages/second, the latency is 3.67 ms. In contrast, the latency of NetPaxos is both lower, and relatively unaffected by increasing throughput. For low throughputs, the latency is 0.15 ms, and at 57,457 messages/second, the latency is 0.37 ms. In other words, NetPaxos reduces latency by 90%.</p><p>We should stress that these numbers indicate a best case scenario for NetPaxos. One would expect that modifying the switch behavior to enforce the desired ordering constraints might add overhead. However, the initial experiments are extremely promising, and suggest that moving consensus logic into network devices could dramatically improve the performance of replicated systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">RELATED WORK</head><p>Network support for applications. Several recent projects have demonstrated that large-scale, data processing applications, such as Hadoop, can benefit from improved network support. For example, PANE <ref type="bibr" target="#b12">[12]</ref>, EyeQ <ref type="bibr" target="#b17">[17]</ref>, and Merlin <ref type="bibr" target="#b36">[36]</ref> all use resource scheduling to improve the job performance, while NetAgg <ref type="bibr" target="#b21">[21]</ref> leverages user-defined combiner functions to reduce network congestion. These projects have largely focused on improving application performance through traffic management. In contrast, this paper argues for moving application logic into network devices.</p><p>Speculative Paxos <ref type="bibr" target="#b33">[33]</ref> uses a combination of techniques to eliminate packet reordering in a data center, including IP multicast, fixed length network topologies, and a single of-rack switch acting as a serializer. NetPaxos uses similar techniques to ensure message ordering. However, Net-Paxos moves Paxos logic into the switches, while Speculative Paxos uses servers to provide the role of acceptors. OpenFlow extensions. To better support the needs of networked applications, there has been an increasing interest in extending OpenFlow with a more generalized API. From academia, there have been several recent proposals <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b3">3,</ref><ref type="bibr" target="#b17">17]</ref>. In industry, there has been a longstanding discussion about how to support stateful operations in the new versions of the OpenFlow protocol. The presiding standards body, the Open Networking Foundation (ONF), includes two working groups on the topic: one to standardize extensions to the protocol (EXT-WG), and one focused on forwarding abstractions (FAWG). Replication protocols. Research on replication protocols for high availability is quite mature. Existing approaches for replication-transparent protocols, notably protocols that im-plement some form of strong consistency (e.g., linearizability, serializability) can be roughly divided into three classes <ref type="bibr" target="#b8">[8]</ref>: (a) state-machine replication <ref type="bibr" target="#b18">[18,</ref><ref type="bibr" target="#b34">34]</ref>, (b) primary-backup replication <ref type="bibr" target="#b28">[28]</ref>, and (c) deferred update replication <ref type="bibr" target="#b8">[8]</ref>.</p><p>At the core of all classes of replication protocol discussed above, there lies a message ordering mechanism. This is obvious in state-machine replication, where commands must be delivered in the same order by all replicas, and in deferred update replication, where state updates must be delivered in order by the replicas. In primary-backup replication, commands forwarded by the primary must be received in order by the backups; besides, upon electing a new primary to replace a failed one, backups must ensure that updates "intransit" submitted by the failed primary are not intertwined with updates submitted by the new primary (e.g., <ref type="bibr" target="#b30">[30]</ref>).</p><p>Although many mechanisms have been proposed in the literature to order messages consistently in a distributed system <ref type="bibr" target="#b11">[11]</ref>, very few protocols have taken advantage of network specifics. Protocols that exploit spontaneous message ordering to improve performance are in this category (e.g., <ref type="bibr" target="#b20">[20,</ref><ref type="bibr" target="#b31">31,</ref><ref type="bibr" target="#b32">32]</ref>). The idea is to check whether messages reach their destination in order, instead of assuming that order must be always constructed by the protocol and incurring additional message steps to achieve it. As we claim in the proposal, ordering protocols have much to gain (e.g., in performance, in simplicity) by tightly integrating with the underlying network layer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSION</head><p>Software-defined networking offers improved network programmability, which can not only simplify network management, but can also enable a tighter integration with distributed applications. This integration means that networks can be tailored specifically to the needs of the deployed applications, and improve application performance.</p><p>This paper proposes two protocol designs which would move Paxos consensus logic into network forwarding devices. Although neither of these protocols can be fully implemented without changes to the underlying switch firmware, all of these changes are feasible in existing hardware. Moreover, our initial experiments show that moving Paxos into switches would significantly increase throughput and reduce latency.</p><p>Paxos is a fundamental protocol used by fault-tolerant systems, and is widely used by data center applications. Consequently, performance improvements in the protocol implementation would have a great impact not only on the services built with Paxos, but also on the applications that use those services.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Network Paxos architecture. Switch hardware is shaded grey. Other devices are commodity servers. The learners each have four network interface cards.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Evaluation of ordering assumptions and performance. 2a shows the percentage of messages in which learners either disagree, or cannot make a decision. 2b shows the throughput vs. latency for basic Paxos and NetPaxos.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>https://bitbucket.org/sciascid/libpaxos</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments: We thank Gianni Antichi, Marc LeClerc, Rolf Neugebauer, Luc Mayrand, Arun Paneri, and Stacey Sheldon for their feedback, and the reviewers for their suggestions. This research is (in part) supported by European Union's Horizon 2020 research and innovation programme under the ENDEAVOUR project (grant agreement 644960).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Arista 7124FX Application Switch datasheet</title>
		<author>
			<persName><surname>Arista</surname></persName>
		</author>
		<ptr target="http://www.arista.com/assets/data/pdf/7124FX/7124FX_Data_Sheet.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Enabling End Host Network Functions</title>
		<author>
			<persName><forename type="first">H</forename><surname>Ballani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Costa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gkantsidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Grosvenor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Karagiannis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Koromilas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>O'shea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM Conference on Applications, Technologies, Architectures, and Protocols for Computer Communication (SIGCOMM)</title>
		<imprint>
			<date type="published" when="2015-08">Aug. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">OpenState: Programming Platform-Independent Stateful Openflow Applications Inside the Switch</title>
		<author>
			<persName><forename type="first">G</forename><surname>Bianchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bonola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Capone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Cascone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM Computer Communication Review (CCR)</title>
		<imprint>
			<date type="published" when="2014-04">Apr. 2014</date>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page" from="44" to="51" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Programming Protocol-Independent Processors</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bosshart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Daly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gibb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Izzard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Schlesinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Talayco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vahdat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Varghese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGCOMM Computer Communication Review (CCR)</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="87" to="95" />
			<date type="published" when="2014-07">July 2014</date>
		</imprint>
	</monogr>
	<note>P</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Forwarding Metamorphosis: Fast Programmable Match-Action Processing in Hardware for SDN</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bosshart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gibb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-S</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Varghese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Izzard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Mujica</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Horowitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM Conference on Applications, Technologies, Architectures, and Protocols for Computer Communication (SIGCOMM)</title>
		<imprint>
			<date type="published" when="2013-08">Aug. 2013</date>
			<biblScope unit="page" from="99" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The Chubby Lock Service for Loosely-Coupled Distributed Systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Burrows</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Symposium on Operating Systems Design and Implementation (OSDI)</title>
		<imprint>
			<date type="published" when="2006-11">Nov. 2006</date>
			<biblScope unit="page" from="335" to="350" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Paxos Made Live: An Engineering Perspective</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">D</forename><surname>Chandra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Griesemer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Redstone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Principles of Distributed Computing (PODC)</title>
		<imprint>
			<date type="published" when="2007-08">Aug. 2007</date>
			<biblScope unit="page" from="398" to="407" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<author>
			<persName><forename type="first">B</forename><surname>Charron-Bost</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pedone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schiper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Replication: Theory and Practice</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">5959</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Spanner: Google&apos;s Globally-Distributed Database</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Corbett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Epstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fikes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Frost</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Furman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ghemawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gubarev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Heiser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hochschild</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Hsieh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kanthak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kogan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lloyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Melnik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mwaura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Nagle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Quinlan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Rolig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Saito</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Szymaniak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Woodford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Symposium on Operating Systems Design and Implementation (OSDI)</title>
		<imprint>
			<date type="published" when="2012-10">Oct. 2012</date>
			<biblScope unit="page" from="251" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<ptr target="http://www.corsa.com/" />
		<title level="m">Corsa Technology</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Total Order Broadcast and Multicast Algorithms: Taxonomy and Survey</title>
		<author>
			<persName><forename type="first">X</forename><surname>Defago</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schiper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Urban</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys (CSUR)</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="372" to="421" />
			<date type="published" when="2004-12">Dec. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Participatory Networking: An API for Application Control of SDNs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ferguson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Guha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fonseca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Krishnamurthi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM Conference on Applications, Technologies, Architectures, and Protocols for Computer Communication (SIGCOMM)</title>
		<imprint>
			<date type="published" when="2013-08">Aug. 2013</date>
			<biblScope unit="page" from="327" to="338" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">NetFPGA -An Open Platform for Teaching How to Build Gigabit-Rate Network Switches and Routers</title>
		<author>
			<persName><forename type="first">G</forename><surname>Gibb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Lockwood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Naous</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hartke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Education</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="160" to="161" />
			<date type="published" when="2008-08">Aug. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Scalable Consistency in Scatter</title>
		<author>
			<persName><forename type="first">L</forename><surname>Glendenning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Beschastnikh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Operating Systems Principles (SOSP)</title>
		<imprint>
			<date type="published" when="2011-10">Oct. 2011</date>
			<biblScope unit="page" from="15" to="28" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Improving Availability in Distributed Systems with Failure Informers</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Leners</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Aguilera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Walfish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Symposium on Networked Systems Design and Implementation (NSDI)</title>
		<imprint>
			<date type="published" when="2013-04">Apr. 2013</date>
			<biblScope unit="page" from="427" to="441" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Blueswitch: Enabling Provably Consistent Configuration of Network Switches</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hun Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mundkur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rotsos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Antichi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Dave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Neumann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">11th ACM/IEEE Symposium on Architectures for Networking and Communications Systems</title>
		<imprint>
			<date type="published" when="2015-04">Apr. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">EyeQ: Practical Network Performance Isolation at the Edge</title>
		<author>
			<persName><forename type="first">V</forename><surname>Jeyakumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Alizadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mazières</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Prabhakar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Greenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Symposium on Networked Systems Design and Implementation (NSDI)</title>
		<imprint>
			<date type="published" when="2013-04">Apr. 2013</date>
			<biblScope unit="page" from="297" to="312" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Time, Clocks, and the Ordering of Events in a Distributed System</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM (CACM)</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="558" to="565" />
			<date type="published" when="1978-07">July 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The Part-Time Parliament</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems (TOCS)</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="133" to="169" />
			<date type="published" when="1998-05">May 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
		<title level="m">Fast Paxos. Distributed Computing</title>
		<imprint>
			<date type="published" when="2006-10">Oct. 2006</date>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="79" to="103" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">NetAgg: Using Middleboxes for Application-Specific On-Path Aggregation in Data Centres</title>
		<author>
			<persName><forename type="first">L</forename><surname>Mai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Rupprecht</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Alim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Costa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Migliavacca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pietzuch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Wolf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM International Conference on Emerging Networking Experiments and Technologies (CoNEXT)</title>
		<imprint>
			<date type="published" when="2014-12">Dec. 2014</date>
			<biblScope unit="page" from="249" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Ring Paxos: A High-Throughput Atomic Broadcast Protocol</title>
		<author>
			<persName><forename type="first">P</forename><surname>Marandi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Primi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Schiper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pedone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Dependable Systems and Networks (DSN)</title>
		<imprint>
			<date type="published" when="2010-06">June 2010</date>
			<biblScope unit="page" from="527" to="536" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">The Performance of Paxos in the Cloud</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Marandi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Benz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pedone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">P</forename><surname>Birman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Symposium on Reliable Distributed Systems (SRDS)</title>
		<imprint>
			<date type="published" when="2014-10">Oct. 2014</date>
			<biblScope unit="page" from="41" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">OpenFlow: Enabling Innovation in Campus Networks</title>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Parulkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Peterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM Computer Communication Review (CCR)</title>
		<imprint>
			<date type="published" when="2008-03">Mar. 2008</date>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="69" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<ptr target="http://netronome.com/product/flownics" />
	</analytic>
	<monogr>
		<title level="m">Programmable Interface Cards</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">NFP-6xxx -A 22nm High-Performance Network Flow Processor for 200Gb/s Software Defined Networking</title>
		<author>
			<persName><surname>Netronome</surname></persName>
		</author>
		<ptr target="http://www.hotchips.org/wp-content/uploads/hc_archives/hc25/HC25.60-Networking-epub/HC25.27.620-22nm-Flow-Proc-Stark-Netronome.pdf" />
	</analytic>
	<monogr>
		<title level="m">Talk at HotChips by Gavin Stark</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">NoviSwitch 1132 High Performance OpenFlow Switch datasheet</title>
		<author>
			<persName><surname>Noviflow</surname></persName>
		</author>
		<ptr target="http://noviflow.com/wp-content/uploads/2014/12/NoviSwitch-1132-Datasheet.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Viewstamped Replication: A General Primary-Copy Method to Support Highly-Available Distributed Systems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Oki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Principles of Distributed Computing (PODC)</title>
		<imprint>
			<date type="published" when="1988-08">Aug. 1988</date>
			<biblScope unit="page" from="8" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">SDF: Software-Defined Flash for Web-Scale Internet Storage Systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ouyang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Hou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<imprint>
			<date type="published" when="2014-02">Feb. 2014</date>
			<biblScope unit="page" from="471" to="484" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Pronto: A Fast Failover Protocol for Off-the-Shelf Commercial Databases</title>
		<author>
			<persName><forename type="first">F</forename><surname>Pedone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Frolund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Symposium on Reliable Distributed Systems (SRDS)</title>
		<imprint>
			<date type="published" when="2000-10">Oct. 2000</date>
			<biblScope unit="page" from="176" to="185" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Optimistic Atomic Broadcast: A Pragmatic Viewpoint</title>
		<author>
			<persName><forename type="first">F</forename><surname>Pedone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schiper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">291</biblScope>
			<biblScope unit="page" from="79" to="101" />
			<date type="published" when="2003-01">Jan. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Solving Agreement Problems with Weak Ordering Oracles</title>
		<author>
			<persName><forename type="first">F</forename><surname>Pedone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schiper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Urban</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Cavin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Dependable Computing Conference (EDCC)</title>
		<imprint>
			<date type="published" when="2002-10">Oct. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Designing Distributed Systems Using Approximate Synchrony in Data Center Networks</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R K</forename><surname>Ports</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">K</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Krishnamurthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Symposium on Networked Systems Design and Implementation (NSDI)</title>
		<imprint>
			<date type="published" when="2015-03">Mar. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Implementing Fault-Tolerant Services Using the State Machine Approach: A Tutorial</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">B</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys (CSUR)</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="299" to="319" />
			<date type="published" when="1990-12">Dec. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Geo-Replicated Storage with Scalable Deferred Update Replication</title>
		<author>
			<persName><forename type="first">D</forename><surname>Sciascia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pedone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Dependable Systems and Networks (DSN)</title>
		<imprint>
			<date type="published" when="2013-06">June 2013</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Merlin: A Language for Provisioning Network Resources</title>
		<author>
			<persName><forename type="first">R</forename><surname>Soulé</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Basu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Marandi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pedone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kleinberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">G</forename><surname>Sirer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Foster</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM International Conference on Emerging Networking Experiments and Technologies (CoNEXT)</title>
		<imprint>
			<date type="published" when="2014-12">Dec. 2014</date>
			<biblScope unit="page" from="213" to="226" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
