<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">SAT-based model-checking for security protocols analysis</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2007-09-21">21 September 2007</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Alessandro</forename><surname>Armando</surname></persName>
							<email>armando@dist.unige.it</email>
						</author>
						<author>
							<persName><forename type="first">Luca</forename><surname>Compagna</surname></persName>
							<email>luca.compagna@sap.com</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">DIST</orgName>
								<orgName type="institution" key="instit1">AI-Lab</orgName>
								<orgName type="institution" key="instit2">Universit√† di Genova</orgName>
								<address>
									<addrLine>Viale Causa 13</addrLine>
									<postCode>16145</postCode>
									<settlement>Genova</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">SAP Research</orgName>
								<address>
									<addrLine>805 Av. du Dr M. Donat</addrLine>
									<postCode>06250</postCode>
									<settlement>Mougins</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">SAT-based model-checking for security protocols analysis</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2007-09-21">21 September 2007</date>
						</imprint>
					</monogr>
					<idno type="MD5">D76CB0DEB055F15CDDA235CF0B1A4399</idno>
					<idno type="DOI">10.1007/s10207-007-0041-y</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:05+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present a model checking technique for security protocols based on a reduction to propositional logic. At the core of our approach is a procedure that, given a description of the protocol in a multi-set rewriting formalism and a positive integer k, builds a propositional formula whose models (if any) correspond to attacks on the protocol. Thus, finding attacks on protocols boils down to checking a propositional formula for satisfiability, problem that is usually solved very efficiently by modern SAT solvers. Experimental results indicate that the approach scales up to industrial strength security protocols with performance comparable with (and in some cases superior to) that of other state-of-the-art protocol analysers.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In a world strongly dependent on distributed data communication, the design of secure IT infrastructures is a crucial task. At the core of computer security-sensitive applications are security protocols i.e., communication protocols aiming at providing security guarantees (such as authentication of principals or secrecy of some piece of information) through the application of cryptographic primitives. The problem is that-in spite of their apparent simplicity-the design of security protocols is notoriously error-prone. Many published protocols have been implemented and deployed in real applications only to be found flawed years later. (See, e.g., <ref type="bibr" target="#b26">[27]</ref> for a survey.) Quite interestingly, many attacks can be carried out without breaking cryptography. These attacks exploit weaknesses in the protocol that are due to the complex and unexpected interleavings of different protocol sessions as well as to the possible interference of malicious agents. Since these weaknesses are very difficult to spot by simple inspection of the protocol specification, security protocols are considered a new, promising application domain for formal methods.</p><p>In the last decade we have witnessed a dramatic speed-up of SAT solvers: problems with several thousands variables are now solved routinely in milliseconds by state-of-the-art SAT solvers. This has led to breakthroughs in important areas such as planning and model-checking of hardware. An interesting question is whether SAT solvers can lead to similar results also in security protocol analysis. In this paper we try to answer this question and we do this by presenting and evaluating (both theoretically and experimentally) a model checking technique for security protocols based on a reduction to propositional logic.</p><p>We model the problem of determining whether a security protocol fails to meet the security properties it is expected to enjoy as a reachability problem (called protocol insecurity problem) of a transition system specifying all the possible actions of the participating agents. Among the participating agents we include an active intruder that, besides overhearing and intercepting messages exchanged by honest participants, can also forge and send new messages. As in <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b23">24]</ref> we specify protocol insecurity problems using a rule-based specification framework based on (order-sorted) multi-set rewriting. The state of the transition system is represented by a set of ground (i.e., variable-free) first-order atomic formulae called facts, while the allowed transitions are specified by rewrite rules modelling the abilities of the agents. Each rewrite rule is a declarative specification of the applicability conditions of the associated action (in terms of the facts that must hold in a state for the action to be applicable in it) and of its effects (namely, the facts that must be replaced from and added to the current state in order to obtain the next state).</p><p>It is well-known that solving protocol insecurity problems is undecidable in the general case <ref type="bibr" target="#b35">[36]</ref>. However, as shown in <ref type="bibr" target="#b60">[61]</ref>, solving protocol insecurity problems with a bounded number of acyclic sessions (BNAS problems, for short) is NP-complete and hence decidable. In this paper we focus on the bounded protocol insecurity problem, i.e., the problem of determining whether any given security protocol is vulnerable to attacks of length k, for any given bound k &gt; 0. This problem is obviously decidable. Building decision procedures for the bounded protocol insecurity problem is important. In fact, any decision procedure for this problem can be used to build a semi-decision procedure for (unrestricted) protocol insecurity problems by simply doing iterative deepening on the value of k. Moreover it can be shown (by using the polynomial bounds on normal attacks discussed in <ref type="bibr" target="#b60">[61]</ref>) that any given BNAS problem can be safely reduced to a bounded version of the problem with a value of k quadratic in the size of the protocol specification. Thus any decision procedure for the bounded protocol insecurity problem can be used as a decision procedure for BNAS problems.</p><p>Given a protocol insecurity problem and a positive integer k, i.e., given a bounded protocol insecurity problem, we show how to build a propositional formula whose models (if any) correspond to sequences R 1 , . . . , R k of sets of rules representing partial order attacks (of length k) on the protocol. (The idea is that rules in the same set R i , for i = 1, . . . , k, can be executed in any order, but all the rules in R i must be executed after the rules in R h , for all h &lt; i, and before the rules in R j , for all j &gt; i. Thus a partial order attack is a concise representation of all the attacks obtained by imposing a total ordering on the rules in R i for i = 1, . . . , k.) Thus, by using the approach described in this paper, finding attacks of bounded length boils down to generating and checking for satisfiability a propositional formula. Since for the solving phase we can rely on the efficiency of modern SAT solvers, in this paper we will focus on the issue of generating a propositional formula corresponding (in the sense specified above) to the bounded protocol insecurity problem given as input. This activity requires some ingenuity, as a naive approach to the problem leads to propositional formulae of unmanageable size even for relatively simple problems. The following techniques make our approach not only viable but also effective of many problems of practical interest:</p><p>Optimisations. We apply a number of optimising transformations on the input problem. The effect of these transformations is to reduce considerably the number of messages and the number of actions performed by the participating agents that need to be considered during the analysis. Quantifier-elimination. Existential quantifiers are used in our multi-set specification formalism to model the generation of fresh data. We provide two methods, that by eliminating the quantifiers from the protocol specification, remove the non-determinism associated with the generation of fresh data. Propositional encoding. We generate a propositional formula that encodes all possible partial order attacks of bounded length on the resulting protocol insecurity problem. We have adapted two encoding techniques originally developed for planning to the domain of security protocol analysis.</p><p>We have built a SAT-based model-checker (SATMC) for security protocols based on the above ideas. An abstract account of the internal functioning of SATMC is given by the procedure of Fig. <ref type="figure" target="#fig_2">1</ref>. Given as input a protocol insecurity problem Œû specified in our multi-set rewriting specification formalism and a bound k &gt; 0 (which can be set also to ‚àû), the procedure starts by optimising and removing the existential quantifiers from Œû (lines 3 and 4 respectively) and then enters a loop (with increasing values of a counter i, initially set to 0) in which it builds a propositional formula [[Œû ]] i representing all possible partial order attacks on Œû of length ‚â§ i and stops as soon as (i) an attack is found (line 8) or (ii) the bound is reached (lines 5 and 10). If k is set to a positive number, then the procedure is a decision procedure for the corresponding bounded protocol insecurity problem. If k is set to ‚àû, then the procedure may not terminate and is a semidecision procedure for the corresponding protocol insecurity problem.</p><p>The approach neatly separates the encoding phase from the search activity that (if we neglect the external loop implementing the iterative deepening) is completely delegated to Fig. <ref type="figure" target="#fig_2">1</ref> SAT-based model checking of security protocols the SAT solver. This is a very attractive feature as state-ofthe-art SAT solvers are very powerful search engines that combine the sheer speed ensured by finely tuned data structures and algorithms with the high sophistication of advanced search strategies which often lead to a dramatic pruning of the search space. Moreover, virtually all state-of-the-art SAT solvers accept propositional formulae in the same common format. This makes their integration immediate and their replacement (as soon as new, faster SAT solvers become available) almost effortless.</p><p>The encoding techniques we present in this paper are based on the idea to add a time-index to the facts and rules to indicate the time step in which the facts hold and the rules apply respectively. (Rules are ground first-order atomic formulae used to unambiguously refer to the ground instances of the rewrite rules.) Facts are thus indexed by 0 through k and rules by 0 through k -1. The propositional formula [[Œû ]] i is obtained by conjoining (i) a set of 0-indexed facts specifying the initial state, (ii) a propositional combination of (k + 1)-indexed facts representing the set of states whose reachability implies the violation of the security property that the protocol is expected to guarantee, (iii) a set of formulae specifying the applicability conditions of the actions at time step i as well as their effects on the state at time step i + 1, for i = 0, . . . , k -1, (iv) a set of frame axioms stating that actions are the only cause of change, and (v) some further formulae whose form and meaning depend on the specific encoding technique employed.</p><p>As we will see, the size of the resulting propositional formula grows linearly in the number of facts and quadratically in the number of rules in the worst case. Unfortunately both the number of facts and rules (and hence also the size of the propositional formula) are in the worst case exponential in the size of the input security protocol specification. This result seems to limit the applicability of the approach to small protocols. However computer experiments, obtained by running SATMC on complex, industrial strength security protocols, show that our approach generates formulae of manageable size in most cases and exhibits performance comparable with (and in some cases better than) that of other state-of-the-art protocol analysers. We believe that this result is due to (i) the proper use of sort declarations in the protocol specifications, (ii) the effectiveness of the optimising transformations and of the encoding techniques, and (iii) the ability of the SAT solver to quickly solve complex combinatorial problems. The combined effect of (i) and (ii) makes the approach generate remarkably compact encodings, while (iii) allows SATMC to scale up smoothly as the number of sessions in the problem considered increases.</p><p>The technical contribution of the paper is fourfold:</p><p>-We provide an operational semantics for multi-set rewriting systems that takes into account the non-determinism associated with the generation of fresh data and show that this form of non-determinism can be safely eliminated. In most accounts (e.g., <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b23">24]</ref>) this is either taken for granted or abstracted away. -In previous work <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b9">10]</ref> we showed how encoding techniques originally developed for planning can be adapted and successfully applied to security protocol analysis. In this paper we provide a detailed account of these techniques and prove their soundness and completeness. -We provide a detailed and comprehensive account of our SAT-based model checking procedure for security protocols. We show that our procedure can be turned into a decision procedure for BNAS problems. -We provide a thorough experimental assessment of our approach obtained by running SATMC and two other state-of-the-art tools against a large set of protocol insecurity problems drawn from two publicly available libraries of security protocols. The experiments indicate that SATMC is more sensitive to the size of messages exchanged by the protocols than the other two tools considered but also that it scales better as the number of sessions increases. This is an interesting result that indicates that our approach is complementary to other state-of-theart techniques.</p><p>Structure of the paper. In Sect. 2 we give a brief presentation of the Needham-Schroeder Public-Key Protocol (NSPK) that will be used as a running example throughout the rest of the paper. (This section can be skipped by readers who are familiar with this protocol.) In Sect. 3 we show how the notion of protocol insecurity problem can be expressed as a reachability problem in a multi-set rewriting formalism. In Sect. 4, we focus on the problem of encoding bounded protocol insecurity problems into propositional logic. In Sect. 5 we discuss how the previously presented techniques can be put together to obtain a decision procedure for BNAS problems and, more in general, a semi-decision procedure for protocol insecurity problems. In Sect. 6 we present and analyse the experimental results. The related work is discussed in Sect. 7. We conclude in Sect. 8 with some final remarks. Proofs of the main results are given in the Appendix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">An example: the NSPK protocol</head><p>We will use the well-known NSPK protocol <ref type="bibr" target="#b56">[57]</ref> as a running example throughout the paper. The NSPK protocol is intended to ensure the mutual authentication of the participating agents Alice and Bob through a challenge-response mechanism which is succinctly represented by following three protocol steps:</p><p>(1) Unfortunately the above argumentation (and hence the protocol) is flawed. While it is correct for Bob to conclude at the end of the protocol that N a has been generated by Alice, it might be the case that N a has been generated by Alice with a different purpose than authenticating with Bob. In the scenario of Fig. <ref type="figure" target="#fig_0">2</ref> (corresponding to Lowe's attack on the NSPK protocol <ref type="bibr" target="#b48">[49]</ref>) nonce na is generated by Alice with the purpose of authenticating with Ives, but Ives mischievously reuses na by forging and sending the message {a, na} kb . In this way Ives tricks Bob into believing that Alice wishes to initiate the protocol with him. As a consequence of this, at the end Bob concludes he has successfully authenticated Alice and that they both agree with values of N a and N b, but this is obviously not the case. We model protocol insecurity problems as reachability problems associated with an order-sorted multi-set rewriting system specifying the behaviour of the honest agents as well as that of the intruder.</p><formula xml:id="formula_0">A ‚Üí B : {A, N a} K b 123 (2) B ‚Üí A : {N a, N b} K a (3) A ‚Üí B : {N b} K b</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Order-sorted language</head><p>An order-sorted signature is a triple S, ‚â§, such that S, ‚â§ is a partially ordered set of sorts and is a set of function symbols, each equipped with a set of arities, i.e., a set of sequences of sorts s 1 , . . . , s n , s for some n ‚â• 0. (We call individual constants the function symbols with n = 0.) We write f : s 1 , . . . , s n ‚Üí s to indicate that s 1 , . . . , s n , s is an arity of f . Let V = V s s‚ààS be an S-indexed family of variables and let s ‚àà S. We assume the usual inductive definition of -terms of sort s over V (see, e.g., <ref type="bibr" target="#b62">[63]</ref>). By T s ( , V ) we indicate the set of all -terms of sort s over V . A term without variables is said to be ground and we abbreviate T s ( , ‚àÖ) with T s ( ). Let X be a set, by |X | we denote the cardinality of X . If s is a sort, then we write |s| in place of |T s ( , V )| and we say that the cardinality of s is |T s ( , V )|.</p><p>We assume that S has sorts for messages (Msg), agent names (Agent), (a subset of the) natural numbers (Num), asymmetric cryptographic keys (Key), protocol steps (StepId), data identifiers (Id), and session identifiers (SessId). Furthermore, Agent ‚â§ Msg, Num ‚â§ Msg, Key ‚â§ Msg, StepId ‚â§ Num, and SessId ‚â§ Num. (Numbers are used to represent nonces, protocol steps, and protocol sessions.) Moreover we assume that has -individual constants for agents (e.g., a, b, i), for cryptographic keys (e.g., ka, kb, ki), for numbers, protocol step identifiers and session identifiers (e.g., 0, 1, 2, ‚Ä¶); -function symbols for pairing ( _, _ : Msg, Msg ‚Üí Msg), for symmetric encryption ({_} s _ : Msg, Msg ‚Üí Msg), for asymmetric encryption ({_} _ : Msg, Key ‚Üí Msg), and for denoting the inverse key (_ -1 : Key ‚Üí Key). (Symbols for other cryptographic operators, e.g., hash functions, can be also included if needed.) Notice that any message can be used as a symmetric key: this allows us to model protocols of real-world complexity (e.g., TLS) in which symmetric keys are built out of several pieces of information.</p><p>We also assume that S contains two sort symbols Fact and Rule. We call fact terms and rule terms the terms in T Fact ( , V ) and T Rule ( , V ) respectively. (We call facts and rules the terms in T Fact ( ) and T Rule ( ) respectively.) Finally we call rule names the function symbols f such that f : s 1 , . . . , s n ‚Üí Rule for some s 1 , . . . , s n ‚àà S and n ‚â• 0. We assume that fact terms are of the forms shown in the left column of  The informal meaning of these facts is explained in the right column. (Notice that, the last four rows describe fact terms used to express security properties and they will thus be discussed again only at the end of Sect. 3.4.) Finally we assume that S has sorts for freshly generated entities. For instance, fresh(Num) is the sort for nonces and fresh(Key) is the sort for session keys. In general if s is a basic sort, then fresh(s) is the corresponding sort of fresh elements and fresh(s) ‚â§ s. We assume that is extended with an enumerable set of individual constants (called fresh constants) for each sort of type fresh(s). We require that if c is a constant of sort fresh(s) for some s ‚àà S, then fresh(s) is the only sort of c. If v ‚àà V fresh(s) for some s ‚àà S, then we say that v is a fresh variable. By -and V -we denote the result of dropping from and V the fresh constants and the fresh variables respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Multi-set rewriting systems</head><p>Let O be a set of terms. By vars(O) we denote the set of variables occurring in O. Moreover we write x to denote a sequence of expressions x 1 , . . . , x n . With abuse of notation in the sequel we use x also to denote the set of the expressions in x. Context will disambiguate what is meant.</p><p>A multi-set rewriting system of signature S, ‚â§, over V is a pair Œì = I, R where I ‚äÜ T Fact ( -) is a multiset of facts representing the initial state of the system and R is a function mapping rule names into triples of the form L , x, ‚àÉy.R called rewrite rules, where x is a sequence of the variables occurring in L, y is a sequence of fresh variables occurring in R, and L and R are multi-sets of terms in T Fact ( -, V -) and T Fact ( -, V ) respectively with (vars(R)\y) ‚äÜ vars(L). In this paper we will restrict our attention to the simpler class of multi-set rewriting systems in which all the multi-sets are just sets. We will write (L</p><formula xml:id="formula_1">r (x) --‚Üí ‚àÉy.R) ‚àà R (or even (L r (x)</formula><p>--‚Üí ‚àÉy.R), when R can be inferred from the context) in place of R(r ) = L , x, ‚àÉy.R . If y is the empty sequence of variables, then we will abbreviate ‚àÉy.R with R. Moreover if f and f s are a fact term and a set of fact terms respectively, then we write f f s in place of { f } ‚à™ f s and f in place of { f }.</p><p>A possible initial state S 0 for the intruder i and two honest agents a and b involved in two concurrent sessions of the NSPK is:</p><formula xml:id="formula_2">state(0, a, a, [a, i, ka, ka -1 , ki], 1)<label>(1)</label></formula><p>state(0, a, a, [a, b, ka, ka</p><formula xml:id="formula_3">-1 , kb], 2) state(1, a, b, [b, a, kb, kb -1 , ka], 2)<label>(2)</label></formula><formula xml:id="formula_4">ik(i) ik(a) ik(b) ik(ki) ik(ki -1 ) ik(ka) ik(kb)<label>(3)</label></formula><p>Fact (1) represents the initial state of the honest agent a playing the role of initiator in session 1 and knowing her own identity, the identity of the intruder (the agent she would like to talk with), her own public and private keys, and the public key of the intruder. Facts (2) represent the initial state of the honest agents a and b involved as initiator and responder (respectively) in session 2. Facts (3) represent the terms initially known by the intruder. Rewrite rules modelling the behaviour of the honest agents in the NSPK protocol are given in Fig. <ref type="figure">3</ref>. Rewrite rule (4) is applicable to the state comprising facts (1) and (2) when in the substitution the variables A, B, Ka, Kb, and S are instan-Fig. <ref type="figure">3</ref> Rewrite rules for the honest agents in the NSPK protocol Fig. <ref type="figure">4</ref> Rewrite rules for the intruder tiated with a, i, ka, ki, and 1 respectively, possibly leading to the state:</p><formula xml:id="formula_5">state(2, i, a, [na, a, i, ka, ka -1 , ki], 1) msg(1, a, i, { a, na } ki ) state(0, a, a, [a, b, ka, ka -1 , kb], 2) state(1, a, b, [b, a, kb, kb -1 , ka], 2)</formula><p>where na is an individual constant of sort fresh(Num). As effect of the application of the rule, agent a (i) has sent message { a, na } ki to the intruder i, (ii) has extended her knowledge with the nonce na, and (iii) is ready to execute step 2 of the protocol as witnessed by the fact state(2, i, a, [na, a, i, ka, ka -1 , ki], 1) occurring in the state. Notice that all the other facts occurring in the initial state are automatically inherited by the new state. The second step of the NSPK protocol in which the responder receives the challenge generated by the initiator and replies with his own nonce, is modelled by <ref type="bibr" target="#b4">(5)</ref>. The state of the responder is updated by incrementing the protocol step and by extending the knowledge with the acquired information, namely the nonce sent by the initiator and the nonce freshly generated by the responder itself. Moreover, the message { Na, Nb } Ka is sent to A. The remaining steps of the protocol are modelled by ( <ref type="formula">6</ref>) and <ref type="bibr" target="#b6">(7)</ref>.</p><p>We consider the Dolev-Yao model of the intruder <ref type="bibr" target="#b30">[31]</ref>. The Dolev-Yao intruder has complete control of the network: he can overhear and divert messages, and by using the knowledge gleaned from the observed traffic he forges and sends fraudulent messages to the honest participants. These abilities are modelled by the rules of Fig. <ref type="figure">4</ref>. Rewrite rule (8) models the ability of the intruder of diverting the information exchanged by the honest participants. It states that, if a message has been sent on the communication channel, then the intruder can read its content and remove it from the channel. The rules (9), <ref type="bibr" target="#b9">(10)</ref>, and (11) model the ability of composing messages by encrypting with a known key and by pairing known messages. The deduction of new knowledge by decryption (via known keys) and pair decomposition is modelled by the rules (12), <ref type="bibr" target="#b12">(13)</ref>, and <ref type="bibr" target="#b13">(14)</ref>. Finally, the ability to send arbitrary messages (possibly faking somebody else's identity in doing so) is modelled by the rewrite rules of the form <ref type="bibr" target="#b14">(15)</ref>, for all terms j of sort StepId:</p><p>Notice that the decryption key must be known in order to extract the plaintext from the cyphertext. This is commonly known as the perfect cryptography assumption. This assumption is important as it allows us to abstract from the cryptosystem and focus on the logic of the protocol.</p><p>We also make the so called strong typing assumption that rules out type-flaw attacks, i.e., attacks where a field that was originally intended to have one type is subsequently interpreted as having another type. A tagging mechanism that allows for the implementation of protocols enjoying the strong typing assumption is proposed in <ref type="bibr" target="#b42">[43]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Operational semantics</head><p>A multi-set rewriting system defines a state transition systems whose states are represented by sets of facts. If S is a set of facts, then we interpret the facts in S as the propositions holding in the state represented by S, all other facts being false in that state (closed-world assumption). A (ground) substitution is a total function mapping the variables in V in (ground, resp.) terms of the same sort. Let (L œÅ -‚Üí ‚àÉy.R) ‚àà R, œÉ be a ground substitution, and S be a set of facts. If LœÉ ‚äÜ S, then we say that rule instance œÅ, œÉ is applicable in S and that S = app œÅ,œÉ (S) = (S\LœÉ ) ‚à™ RœÉ is the state resulting from the execution of œÅ, œÉ in S. Under the same hypotheses we say that rule œÅœÉ is applicable in S and that S is a state resulting from an execution of œÅœÉ in S.</p><p>Thus a rule models an action that may non-deterministically lead to many (possibly infinite) successor states. For example, all the rule instances corresponding to the rewrite rule (4) are of the form œÅ, œÉ with œÉ = {a/A, b/B, ka/Ka, kb/Kb, 1/S, n/Na} for any constant n of sort fresh(Num) and all of them correspond to the rule step 1 (a, b, ka, kb, 1). Thus starting from a given state, the execution of a rule may nondeterministically lead the system into different (possibly infinitely many) successor states. At a first sight this seems a serious problem for automatic analysis as each rule application seems to lead to an infinite branching. However, as we will see below, this is a form of "don't care non-determinism". This means that no branching at all is needed when considering the application of a rule during the analysis as any (arbitrarily chosen) rule instance will serve as representative of all the others.</p><p>A path is an alternating sequence of states and rule instances S 0 œÅ 1 , œÉ 1 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S n-1 œÅ n , œÉ n S n such that, for i = 1, . . . , n, 1. S i = app œÅ i ,œÉ i (S i-1 ), i.e., S i is a state resulting from the execution of œÅ i œÉ i in S i-1 ; 2. if y and y are existentially quantified variables of œÅ i and œÅ j (resp.) and œÉ i (y) = œÉ j (y ), then i = j and y = y for all i, j = 1, . . . , n, i.e., the substitutions œÉ 1 , . . . , œÉ n not only associate different existentially quantified variables with different terms but also associate occurrences at different execution steps of the same existentially quantified variable with different fresh constants.</p><p>If, additionally, S 0 ‚äÜ I, then we say that the path is initialised. Condition (2) ensures that existentially quantified variables are replaced by fresh terms representing newly generated data (e.g., nonces and session keys). Notice also that the above definition-by excluding the simultaneous execution of two (or more) rules-enforces an interleaving semantics. This is a common assumption in security protocol analysis as it rules out execution paths (and hence attacks) that are difficult to reproduce in practice. Let œá = œÅ 1 , œÉ 1 , . . . , œÅ n , œÉ n and œá = œÅ 1 , œÉ 1 , . . . , œÅ n , œÉ n be two sequence of rule instances of Œì . We say that œá and œá are rule equivalent if and only if œÅ i œÉ i = œÅ i œÉ i for i = 1, . . . , n. A sequence of rule instances œá = œÅ 1 , œÉ 1 , . . . , œÅ n , œÉ n is a run of Œì if and only if there exist a sequence of states S 0 , S 1 , . . . , S n such that S 0 œÅ 1 , œÉ 1 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S n-1 œÅ n , œÉ n S n is an initialised path of Œì . When this is the case, we write S n = app œá (S 0 ) and we say that S n is reachable in n steps from S 0 by applying in sequence the rules œÅ 1 œÉ 1 , . . . , œÅ n œÉ n . We say that two states S and S are equivalent, in symbols S ‚àº S , if and only if they are equal modulo renaming of the fresh constants.</p><p>Lemma 1 Let œá be a run of Œì = I, R and œá be a sequence of rule instances of Œì . If œá is rule equivalent to œá then also œá is a run of Œì and app œá (I) ‚àº app œá (I).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Protocol insecurity problems</head><p>Given a multi-set rewriting system of signature S, ‚â§, over V , we are interested in the reachability problem over it. The bad states (i.e., the states of the system whose reachability implies a violation of a security property that the protocol is expected to enjoy) are represented by goals, i.e., pairs of the forms B = G, C where G is a quantifier-free formula built out of fact terms T Fact ( -, V -) using the standard propositional connectives, and C is a set of equality and inequality constraints of the form t </p><formula xml:id="formula_6">Œû = Œì, B is a run œá of Œì such that app œá (I) | B.</formula><p>Theorem 1 Let œá be a solution to Œû = Œì, B and œá be a sequence of rule instances of Œì . If œá is rule equivalent to œá then also œá is a solution to Œû .</p><p>A protocol insecurity problem is a reachability problem Œû = Œì, B where Œì is a multi-set rewriting system specifying the behaviour of the honest agents and of the intruder and B is a goal specifying the set of states whose reachability implies the violation of one of the security properties that the protocol is expected to enjoy. Any solution to Œû is an attack on the protocol specified by Œû .</p><p>We now see how common security properties like secrecy and authentication can be specified in our formalism. It is easy to see that weak authentication does not guarantee protection against replay attacks. To rectify this problem we must ensure that there exists a one-one relationship between the sessions of p 1 and the sessions of p 2 . We can specify a stronger form of authentication, called strong authentication in this paper and injective agreement in <ref type="bibr" target="#b49">[50]</ref>, by augmenting the request fact with a fifth parameter identifying the session and by setting</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Secrecy</head><formula xml:id="formula_7">G = (request( p 1 , p 2 , d, v, s) ‚àß ¬¨ witness( p 2 , p 1 , d, v))‚à®(request( p 1 , p 2 , d, v, s 1 )‚àßrequest( p 1 , p 2 , d, v, s 2 )) and C = {p 2 i, s 1 s 2 }.</formula><p>Basically, besides the satisfaction of weak authentication, strong authentication requires that no principal should accept the same value twice from the same communication partner in two different sessions.</p><p>The definition of protocol insecurity problem is very general and allows for the specification of a wide variety of application scenarios, including those in which an unbounded number of sessions are allowed (e.g., see Example 1), infinitely-many fresh terms are generated, the number of steps that an honest agent can perform in each session is not fixed in advance, and/or infinitely many messages are exchanged by honest agents.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 1</head><p>The protocol insecurity problem associated with the NSPK protocol that we presented in Sect. 3.2 consists of two sessions only: one between agent a and the intruder with session identifier 1 (cf. fact (1) in the initial state) and one between agents a and b with session identifier 2 (cf. fact <ref type="bibr" target="#b1">(2)</ref> in the initial state). It is possible to add the ability to generate an unbounded number of sessions, each involving two new agents, by extending the protocol insecurity problem with the following rewrite rule:</p><formula xml:id="formula_8">new_session(X,Y,KX,KY,NS) ------------------‚Üí ‚àÉX.Y.KX.KY.NS. state(0, X, X, [X, Y, KX, KX -1 , KY], NS) state(1, X, Y, [Y, X, KY, KY -1 , KX], NS)</formula><p>Notice that this rewrite rule has an empty left-handside and therefore it can be applied in any state. For each execution of the rewrite rule two new agents (X and Y), their public (KX, KY) and private keys (KX -1 , KY -1 ), and a session identifier (NS) are freshly generated. These values define a new session of the NSPK protocol played by agents X and Y.</p><p>Not surprisingly, because of this expressiveness solving a protocol insecurity problem is undecidable in the general case. (As shown in <ref type="bibr" target="#b28">[29]</ref> the Post Correspondence Problem can be recast as a protocol insecurity problem.) However, as shown in <ref type="bibr" target="#b50">[51]</ref>, in some cases it is possible to reduce the general protocol insecurity problem to a protocol insecurity problem for the same protocol but comprising a small number of acyclic sessions (i.e., it can be reduced to a BNAS problem). Moreover violations of the security properties often exploit only a small number of sessions. (This claim is substantiated by the empirical observation that all flawed protocols in the Clark-Jacob's library <ref type="bibr" target="#b26">[27]</ref> suffers from attacks that exploit at most two sessions.)</p><p>Since BNAS problems are an important, decidable class of protocol insecurity problems we now provide a syntactic characterisation of this class of problems inspired by the definition of bounded role theory given in <ref type="bibr" target="#b33">[34]</ref>. Let Œû be a protocol insecurity problem. We say that Œû is a protocol insecurity problem with a bounded number of acyclic sessions (BNAS problem, for short) if, and only if, there exists an anti-reflexive and transitive relation ‚â∫ over a finite set {S 0 , S 1 , . . . , S t } of state facts such that (i) if S i ‚â∫ S j , then S i œÉ ‚â∫ S j œÉ for each substitution œÉ and (ii) for each rewrite rule (L</p><formula xml:id="formula_9">r (x)</formula><p>--‚Üí ‚àÉy.R) of an honest agent there is exactly one occurrence of a state fact in L and R, say S i and S j resp., and it must be the case that S i ‚â∫ S j . The definition basically states that in each execution path the number of applications of the rules of the honest agents is finite and that each rule instance can be applied at most once. This justifies the name BNAS since it guarantees that the number of sessions associated to a BNAS problem is finite and that the sessions are acyclic. Notice that the number of sessions (in general defined as the number of different session identifiers occurring in the state facts of the reachable states) can be easily computed for BNAS problems by a static inspection of the input specification. (This usually amounts to counting the number of different session identifiers occurring in the state facts of the initial state.)</p><p>It is immediate to see that the protocol insecurity problem previously specified for the NSPK protocol is a BNAS problem with two sessions. To show this it suffices to collect the state facts occurring in the rules of Fig. <ref type="figure">3</ref> and define state(i, _, A, _, S) ‚â∫ state( j, _, A, _, S) if, and only if, i &lt; j. Moreover, since the application of every rule of Fig. <ref type="figure">3</ref> just advances the state of an agent by leaving him in the same session he was involved in, then the number of sessions is given by the number of different session identifiers (namely 1 and 2) occurring in the state facts of the initial state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Optimising transformations on protocol insecurity problems</head><p>The notion of protocol insecurity problem we have outlined so far is accurate but not adequate to carry out automatic analysis in an efficient way. The main problem rests with the specification of the intruder that allows to forge messages that cannot be possibly used to mount an attack on the protocol. This can be avoided by providing a refined model of the intruder that forges a message only if it can be accepted by a honest participant. Moreover it is possible to drastically reduce the number of transitions (while retaining all the possible attacks on the protocol) by merging some intruder rules with protocol steps carried out by the honest participants. We now discuss in more details these optimisations.</p><p>Step compression. An effective optimisation, called step compression has been proposed in <ref type="bibr" target="#b11">[12]</ref>. The key idea is to replace the rewrite rules of the honest agents and those modelling the ability of the intruder to fake and divert messages with a new set of rewrite rules obtained by merging these rewrite rules. This amounts to changing the model of the problem by regarding the intruder and the network as a single entity and by assuming that (i) every message sent by a honest agent is received by the intruder and that (ii) every message received by a honest agents has been generated by the intruder. The step compression optimisation removes the intruder rules ( <ref type="formula">8</ref>) and ( <ref type="formula">15</ref>) and replaces every rule of the honest agents, i.e., msg( j, s, r, m) state( j, s, r, ms, c)</p><formula xml:id="formula_10">r (x) --‚Üí ‚àÉy. msg( j , r, r , m ) state( j , s , r, ms , c)<label>(16)</label></formula><p>with ik(m) state( j, s, r, ms, c)</p><formula xml:id="formula_11">sc_r (x) ----‚Üí ‚àÉy. ik(m) ik(m ) state( j , s , r, ms , c)<label>(17)</label></formula><p>Notice that the above transformation has to be slightly adapted for those rules that do not have a message fact in either the left hand side or the right hand side (cf. rules ( <ref type="formula">4</ref>) and ( <ref type="formula">7</ref>) of Fig. <ref type="figure">3</ref>). More specifically: when msg( j, s, r, m) does not occur in the left-hand side of ( <ref type="formula" target="#formula_10">16</ref>), then ik(m) will not occur in <ref type="bibr" target="#b16">(17)</ref>; when msg( j , r, r , m ) does not occur in the right-hand side of ( <ref type="formula" target="#formula_10">16</ref>), then ik(m ) will not occur in the right-hand side of <ref type="bibr" target="#b16">(17)</ref>. We say that m is the reception pattern of the rule. For instance, the step compressed rewrite rule corresponding to ( <ref type="formula">6</ref>) is:</p><formula xml:id="formula_12">ik({ Na, Nb } Ka ) state(2, B, A, [Na, A, B, Ka, Ka -1 , Kb], S) sc_step 3 (A,B,Ka,Kb,Na,Nb,S) -------------------‚Üí ik({ Na, Nb } Ka ) ik({Nb} Kb ) state(4, B, A, [Nb, Na, A, B, Ka, Ka -1 , Kb], S)<label>(18)</label></formula><p>Specialisation of the composition rules. Let us assume that the step compression optimisation has been applied to the input protocol insecurity problem. The intuition behind our second optimisation is to build in the left-hand side of the rewrite rules of the honest agents the ability to compose all the possible messages matching their reception patterns. This gives us a new version of these rules and allows us to remove the composition rules of the intruder, namely ( <ref type="formula">9</ref>), <ref type="bibr" target="#b9">(10)</ref>, and <ref type="bibr" target="#b10">(11)</ref>. The rationale for this optimising transformation rests on the following fact borrowed from <ref type="bibr" target="#b51">[52]</ref>: we can safely restrict our attention to those intruder knowledge derivations in which all the decomposition rules are applied before all the composition rules.</p><p>Let m ‚àà T Msg ( , V ), M be a set of subsets of</p><formula xml:id="formula_13">T Msg ( , V ), and c * -‚Üí ( d *</formula><p>-‚Üí) be the reflexive and transitive closure of the rewrite relation defined by the rewrite rules ( <ref type="formula">9</ref>), <ref type="bibr" target="#b9">(10)</ref>, and ( <ref type="formula">11</ref>) (( <ref type="formula">12</ref>), <ref type="bibr" target="#b12">(13)</ref>, and ( <ref type="formula">14</ref>), resp.). If M = {m 1 , . . . , m n } ‚äÜ T Msg ( , V ), then ik(M) abbreviates ik(m 1 ) . . . ik(m n ). We say that M is a generator of m if and only if for each grounding substitution œÉ and for all</p><formula xml:id="formula_14">M 0 ‚äÜ T Msg ( ) such that ik(M 0 ) c * -‚Üí ik(mœÉ ) there exists M ‚äÜ T Msg ( , V ) such that ik(M) ‚àà M and ik(M 0 ) d * -‚Üí ik(MœÉ ) c * -‚Üí ik(mœÉ ). For instance, both M 1 = {ik({ Na, Nb } Ka ), ik(Na) ik(Nb) ik(Ka)} and M 2 = {ik({ Na, Nb } Ka ), ik(Na) ik(Nb) ik(Ka), ik( Na, Nb ) ik(Ka)} are generators of { Na, Nb } Ka , while M 3 = {ik(Na) ik(Nb) ik(Ka)} is not, as ik({ na, nb } ka ) c * -‚Üí ik({ na, nb } ka ), but ik({ na, nb } ka ) d * --‚Üíik(na) ik(nb) ik(ka).</formula><p>The optimisation amounts to removing all the composition rules of the intruder and then to replacing each step compressed rewrite rule of the form <ref type="bibr" target="#b16">(17)</ref> by a new set, say RC(sc_r ), of rewrite rules ik(M) state( j, s, r, ms, c)</p><formula xml:id="formula_15">sc_r l (x) -----‚Üí ‚àÉy. ik(M) ik(m ) state( j , s , r, ms , c)</formula><p>for each ik(M) ‚àà M, where M is a generator of the reception pattern m. Notice that each path of the resulting protocol insecurity problem contains at most one application of the rules in RC(sc_r ). In fact, all the rules in RC(sc_r ) have the same state fact in the left hand side, namely state( j, s, r, ms, c), and this very same fact is deleted from the state by applying any such rule.</p><p>A simple way to compute a generator of a given reception pattern m is M = {ik(M) | M ‚äÜ T Msg ( , V ) and ik(m) ‚Üí * ik(M)}, where ‚Üí * is the reflexive and transitive closure of the rewrite relation defined by the rewrite rules of Fig. <ref type="figure" target="#fig_1">5</ref>. (Notice that these rewrite rules model the backward representation of the composition rules of the intruder.) It must be noted that in the worst case, i.e., when the tree representation of m is a complete binary tree with n nodes all labelled by the pairing operator, the cardinality of M is exponential in n. (This follows from (i) the observation that there exists a bijection between the elements of M and the set of strongly binary trees of depth d = log 2 n and (ii) the fact that the number of strongly binary trees of depth d is equal to c 2 d , where c 1.5 <ref type="bibr" target="#b1">[2]</ref>.) However a dramatic reduction of the cardinality of M may be obtained by dropping from M all the Let us now consider the application of the optimisation to the rewrite rule <ref type="bibr" target="#b17">(18)</ref>. The reception pattern is is m = { Na, Nb } Ka }. By applying the above method, we obtain M 1 = {ik({ Na, Nb } Ka ), ik(Na) ik(Nb) ik(Ka)} as generator of m and thus we can generate the following two specialised rewrite rules:</p><formula xml:id="formula_16">ik({ Na, Nb } Ka ) state(2, B, A, [Na, A, B, Ka, Ka -1 , Kb], S) sc_step 1 3 (A,B,Ka,Kb,Na,Nb,S) -------------------‚Üí ik({ Na, Nb } Ka ) ik({Nb} Kb ) state(4, B, A, [Nb, Na, A, B, Ka, Ka -1 , Kb], S) ik(Na) ik(Nb) ik(Ka) state(2, B, A, [Na, A, B, Ka, Ka -1 , Kb], S) sc_step 2 3 (A,B,Ka,Kb,Na,Nb,S) -------------------‚Üí ik(Na) ik(Nb) ik(Ka) ik({Nb} Kb ) state(4, B, A, [Nb, Na, A, B, Ka, Ka -1 , Kb], S)</formula><p>Since each rewrite rule is replaced by |M| new rewrite rules, for the effectiveness of the optimisation it is necessary that the generators have finite cardinality. For this reason we apply this optimisation only to those problems in which the size of all the ground instances of the reception patterns is bounded. Although this requirement is apparently quite restrictive, many complex protocols (e.g., Kerberos, AAA Mobile IP, and Fair ZG) meet this condition provided that their implementation adds enough redundancy to the messages to allow the agents to check the well-formedness of the received messages. (A tagging mechanism that achieves this is described in <ref type="bibr" target="#b42">[43]</ref>.) The following example illustrates the point.</p><p>Example 2 Let us consider the following protocol fragment where a server S generates and then secretly distributes a nonce N to agents A and B. Secrecy is ensured by encrypting the messages with the public keys of the intended recipients.</p><p>(1)</p><formula xml:id="formula_17">S ‚Üí A : {S, A, B, N } K a , {S, A, B, N } K b (2) A ‚Üí B : {S, A, B, N } K b</formula><p>Notice that since A does not know B's private key, she cannot decrypt {S, A, B, N } K b and then she cannot check its structure and content. She will thus accept any message comprising two components and will forward the second component provided that the first component has the expected content. This behaviour can be modelled by the two (step compressed) rewrite rules of the following form:</p><p>. . .</p><formula xml:id="formula_18">step 1 (S,A,B,...) ---------‚Üí ‚àÉN. ik( {S, A, B, N} Ka , {S, A, B, N} Kb ) . . . ik( {S, A, B, N} Ka , X ) state(1, S, A, [. . .], _) step 2 (A,B,S,Ka,N,X,...) --------------‚Üí ik(X) . . . (<label>19</label></formula><formula xml:id="formula_19">)</formula><p>where X is a variable of sort Msg. Since the size of the terms of sort Msg is unbounded, this protocol falls outside the scope of our optimisation. However, if we assume that A can check the well-formedness of the messages she receives, then we can replace rule <ref type="bibr" target="#b18">(19)</ref> with the following, less liberal, rule:</p><formula xml:id="formula_20">ik( {S, A, B, N} Ka , {S , A , B , N } Kb ) state(1, S, A, [. . .], _) step 2 (A,B,S,Ka,N,S ,A ,B ,N ,Kb ,...) ----------------------‚Üí ik({S , A , B , N } Kb ) . . .</formula><p>where the size of all the ground instances of the reception pattern is bounded and thus our optimisation becomes applicable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Reducing bounded protocol insecurity problems to SAT</head><p>We now focus on the problem of reducing a bounded protocol insecurity problem to SAT. Given a protocol insecurity problem Œû and an integer k ‚â• 0 we build a propositional formula [[Œû ]] k whose models correspond (in a sense that will be defined shortly) to the partial order attacks of Œû of length k.</p><p>Preliminarily to this we show how a protocol insecurity problem Œû can be turned into an quantifier-free, attackequivalent protocol insecurity problem Œû . (We say that Œû is attack-equivalent to Œû if, and only if, there exists a oneto-one mapping between the solutions of Œû and those of Œû .) How this can be done will be discussed in Sect. 4.1. In Sect. 4.2 we introduce the notion of partial order solution of protocol security problems that will play a fundamental role in stating and proving the fundamental properties of the encoding techniques that we present in Sect. 4.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Quantifier elimination</head><p>A multi-set rewriting system Œì = I, R is quantifier-free if, and only if, for all (L r (x)</p><p>--‚Üí ‚àÉy.R) ‚àà R we have that y = ‚àÖ. A first, general approach to quantifier elimination amounts to extending the state of the system with a counter whose value is used and incremented every time a fresh term is built. More in detail, a fact of the form c(0) is added to the initial state of the system and then every rule (L r (x) --‚Üí ‚àÉy.R) where y = y 1 , . . . , y n is replaced with</p><formula xml:id="formula_21">c(z) L r (x,z) ---‚Üí c(s(z)) R</formula><p>where z is a variable of sort Num that does not occur in R and R is obtained from R by substituting every occurrence of y i with f i (z) where f i is a new function symbol (of the appropriate arity) for i = 1, . . . , n. Intuitively the term f i (z) denotes the fresh value generated by the execution of the rule and associated with the existentially quantified variable y i . For example, the rewrite rule ( <ref type="formula">4</ref>) is transformed into:</p><formula xml:id="formula_22">c(C) state(0, A, A, [A, B, Ka, Ka -1 , Kb], S) step 1 (A,B,C,Ka,Kb,S) -------------‚Üí c(s(C)) state(2, B, A, [f 1 (C), A, B, Ka, Ka -1 , Kb], S) msg(1, A, B, { A, f 1 (C) } Kb )</formula><p>It is easy to see that this simple transformation guarantees the uniqueness of fresh terms and hence that the resulting protocol insecurity problems is attack-equivalent to the original one.</p><p>An alternative approach to quantifier elimination, which can be applied effectively to BNAS protocol insecurity problems, amounts to determining in advance a set of ground terms U representing all fresh values that can possibly be generated during execution and transforming the protocol insecurity problem in the following way. (Notice that for BNAS protocol insecurity problems the set U has necessarily finite size.) The initial state is extended with a fact of the form fresh(t) (stating that the value denoted by t has not been used before) for each t ‚àà U . Every rule of the form (L state( j, s, r, w, c) œÅ -‚Üí ‚àÉy.R), where y = y 1 , . . . , y n and w is a term representing the messages known by agent r , is then replaced with L state( j, s, r, w, c) fresh(t 1 ) . . . fresh(t n ) œÅ -‚Üí R where t i = f i (r, j, c) (with f i a new function symbol of the appropriate arity) and R is obtained from R by substituting y i with t i for i = 1, . . . , n. For instance, the rewrite rule (4) becomes:</p><formula xml:id="formula_23">state(0, A, A, [A, B, Ka, Ka -1 , Kb], S) fresh(f 1 (A, 0, S)) step 1 (A,B,Ka,Kb,S) --------------‚Üí state(2, B, A, [f 1 (A, 0, S), A, B, Ka, Ka -1 , Kb], S) msg(1, A, B, { A, f 1 (A, 0, S) } Kb )</formula><p>Notice that, as a result of the application of an instance of the above rule, the facts occurring in the left hand side will be removed from the state and therefore the same rule instance will not be applicable in the subsequent steps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Partial order solutions</head><p>Even though we are assuming an interleaving semantics for protocol insecurity problems, considering the parallel execution of rewrite rules may have significant advantages. In fact the parallel execution of two (or more) rules often leads to a state which would be anyway reachable by applying the same rules sequentially in some order. To illustrate, consider the situation in which you want to execute the rewrite rules in {off i act i ---‚Üí on i : i = 1, . . . , n} so to activate n alarm devices through n different switches. It is immediate to see that the parallel execution of act 1 , . . . , act n leads (in a single step) to the same state obtained by applying the rules in sequence and in any order. Thus by enabling parallelism we may obtain shorter solutions and, as it will be clear in the next section, smaller encodings. However, in some cases the parallel execution of two (or more) rules leads to a state which is not reachable by applying the same rules sequentially in any order. For instance, the parallel execution of the rewrite rules a We are thus interested in enabling a restricted form of parallelism which ensures that all the parallel executions of the rules lead to a state which is reachable by applying the same individual rules sequentially in some order.</p><p>For the sake of simplicity from here on we focus on ground reachability problems, i.e., reachability problems of a given signature S, over the empty set of variables. This is without loss of generality as any given quantifier-free protocol insecurity problem Œû = Œì, G, C can be thought as a concise representation of the protocol insecurity problem obtained from Œû by replacing (i) the rewrite rules of Œì with the corresponding ground instances, (ii) G with the disjunction of all its instances satisfying the constraints in C, and (iii) C with the empty set. Moreover, if (L œÅ -‚Üí R) ‚àà R, then we define pre(œÅ) = L, add(œÅ) = R, and del(œÅ) = (L\R) to be the preconditions, the positive effects, and the negative effects of œÅ respectively. Definition 1 (parallel composition) Let œÅ i ‚àà dom(R) for i = 1, . . . , n. We say that œÅ 1 , . . . , œÅ n are composable if and only if add(œÅ i ) ‚à© del(œÅ j ) = ‚àÖ for all i, j = 1, . . . , n such that i = j, i.e., the effects of the rules in œÅ 1 , . . . , œÅ n do not contradict each other. If œÅ 1 , . . . , œÅ n are composable rules, then the (parallel) composition of œÅ 1 , . . . , œÅ n , in symbols</p><formula xml:id="formula_24">œÅ 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ œÅ n , is the rule label œÅ associated with the rewrite rule n i=1 L i œÅ -‚Üí n i=1 R i .</formula><p>If the parallel execution of a set of composable rules leads to a state which is reachable by applying the same rules sequentially in some order, then we say that this set of rule is linearisable.</p><formula xml:id="formula_25">Definition 2 (linearisation) Let œÅ 1 , . . . , œÅ n be composable rules. A linearisation of œÅ 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ œÅ n is a permutation œÅ = œÅ k 1 , . . . , œÅ k n of œÅ 1 , .</formula><p>. . , œÅ n such that for all S 0 ‚äá n i=1 pre(œÅ i ) there exists an initialised path œÄ œÅ 1 ,...,œÅ n (S 0 ). We say that</p><formula xml:id="formula_26">œÅ 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ œÅ n is linearisable if and only if there exists a lin- earisation of œÅ 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ œÅ n . Lemma 2 Let œÅ 1 , . . . , œÅ n be composable rules, let œÅ k 1 , . . . , œÅ k n be a linearisation of œÅ 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ œÅ n , and let S 0 ‚äá n i=1 pre(œÅ i ), then app œÅ k 1 ;‚Ä¢‚Ä¢‚Ä¢ ;œÅ kn (S 0 ) = app œÅ 1 ‚Ä¢‚Ä¢‚Ä¢ œÅ n (S 0 ). Let œÄ = S 0 œÅ 1 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S m-1 œÅ m S m and œÄ = S 0 œÅ 1 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S n-1</formula><p>œÅ n S n be initialised paths such that S 0 = S m . (From here on we write</p><formula xml:id="formula_27">S 0 œÅ 1 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S m-1 œÅ m S m in place of S 0 œÅ 1 , ‚àÖ S 1 . . . S n-1 œÅ n , ‚àÖ S n .) The concatenation of œÄ and œÄ , in symbols œÄœÄ , is the initialised path S 0 œÅ 1 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S m-1 œÅ m S m œÅ 1 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S n-1 œÅ n S n .</formula><p>The following result easily follows from Lemma 2.</p><formula xml:id="formula_28">Lemma 3 Let Œì = I, R and Œì = I, R , where R is obtained from R by adding all linearisable compound rules. If S 0 œÅ 1 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S m-1 œÅ m S m is an initialised path of Œì , then œÄ œÅ 1 (S 0 ) œÄ œÅ 2 (S 1 ) ‚Ä¢ ‚Ä¢ ‚Ä¢ œÄ œÅ m (S m</formula><p>) is an initialised path of Œì where œÅ 1 , . . . , œÅ m are linearisations of œÅ 1 , . . . , œÅ m respectively, and we say that the initialised path S 0 œÅ</p><formula xml:id="formula_29">1 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S m-1 œÅ m S m is linearisable.</formula><p>It is thus important to identify conditions that guarantee the linearisability of parallel paths. A simple approach is based on the idea of requiring that all component rules must be executed in any order and must lead to the same result. Definition 3 (interference) We say that œÅ 1 interferes with œÅ 2 , in symbols œÅ 1 ‚äï œÅ 2 , if and only if (i) œÅ 1 = œÅ 2 and (ii) del(œÅ 1 )‚à©pre(œÅ 2 ) = ‚àÖ or del(œÅ 2 )‚à©pre(œÅ 1 ) = ‚àÖ, i.e., œÅ 1 is different from œÅ 2 and the execution of œÅ 1 prevents the execution of œÅ 2 or vice versa.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 4</head><p>Let œÅ 1 , . . . , œÅ n be composable rules. If œÅ i does not interfere with œÅ j for i, j = 1, . . . , n, then all permutations of œÅ 1 , . . . , œÅ n are linearisations of</p><formula xml:id="formula_30">œÅ 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ œÅ n .</formula><p>The following result readily follows from Lemmas 2 and 4.</p><p>Theorem 2 Let Œì = I, R and let Œì = I, R where R is obtained from R by adding all the compound rules</p><formula xml:id="formula_31">œÅ 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ œÅ n for all pairwise non-interfering set of rules {œÅ 1 , . . . , œÅ n } ‚äÜ R. If S 0 œÅ 1 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S m-1 œÅ m S m is an initialised path of Œì , then œÄ œÅ 1 (S 0 ) œÄ œÅ 2 (S 1 ) ‚Ä¢ ‚Ä¢ ‚Ä¢ œÄ œÅ m (S m</formula><p>) is an initialised path of Œì where œÅ 1 , . . . , œÅ m are linearisations of œÅ 1 , . . . , œÅ m respectively, and we say that S 0 œÅ 1 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S m-1 œÅ m S m is a partial-order path of Œì .</p><p>An immediate consequence of Theorem 2 is that any solution to Œû = Œì , B compactly represents a finite set of solutions to Œû = Œì, B and it is thus referred to as a partial-order solution of Œû . Moreover, since by definition the paths of Œì are a superset of those of Œì , then for each solution to Œû there exists a corresponding (possibly shorter) solution to Œû and vice versa. </p><formula xml:id="formula_32">} ‚äÜ R. Similarly, if Œû = Œì, B , then Œû = Œì , B . The formula [[Œû ]] k is defined by [[Œû ]] k = [[Œì ]] k ‚àß [[B]] k (<label>20</label></formula><formula xml:id="formula_33">)</formula><p>where</p><formula xml:id="formula_34">[[Œì ]</formula><p>] k is a propositional formula encoding the behaviour of the (multi)-set rewriting system Œì and [[B]] k is a propositional formula encoding the set of bad states represented by B and reachable in k steps. The propositional formula</p><formula xml:id="formula_35">[[Œì ]</formula><p>] k is of the form:</p><formula xml:id="formula_36">[[Œì ]] k = I (f 0 ) ‚àß k-1 i=0 T i f i , œÅ i , f i+1<label>(21)</label></formula><p>where f and œÅ are tuples of elements of F and L respectively and -1 i=0 T i (f i , œÅ i , f i+1 ) stands for the propositional constant true. The formula I (f 0 ) encodes the initial state whereas the formula T i (f i , œÅ i , f i+1 ) encodes all the possible evolutions of the system from step i to step i + 1. These formulae can be defined in a variety of ways but here we provide a high level characterisation of the encoding techniques in terms of a set of abstract requirements on I (f 0 ) and T i (f i , œÅ i , f i+1 ).</p><formula xml:id="formula_37">(R1) I (f 0 ) is such that if M is a model of I (f 0 ) then { f ‚àà F : f 0 ‚àà M} ‚àà I and, conversely, if S ‚àà I then { f 0 : f ‚àà S} is a model of I (f 0 ). (R2) T i (f i , œÅ i , f i+1 ) is such that for any i = 0, . . . , k -1 (a) if M is a model of T i (f i , œÅ i , f i+1</formula><p>) then the rules in Œõ = {œÅ ‚àà L : œÅ i ‚àà M} are composable and their parallel composition, say Œõ, is linearisable and such that app</p><formula xml:id="formula_38">Œõ (S) = S for S = { f ‚àà F : f i ‚àà M} and S = { f ‚àà F : f i+1 ‚àà M}; (b) if S ‚äÜ F is reachable in i steps in Œì , the set of rules in Œõ ‚äÜ L is linearisable and Œõ is appli- cable in S, and S = app Œõ (S), then M = { f i : f ‚àà S} ‚à™ { f i+1 : f ‚àà S } ‚à™ {œÅ i : œÅ ‚àà Œõ} is a model of T i (f i , œÅ i , f i+1 ).</formula><p>The following two theorems state that any encoding satisfying the above requirements is both sound and complete (respectively).</p><formula xml:id="formula_39">Theorem 3 (soundness) If M is a model of [[Œì ]] k for k ‚â• 0, S i = { f ‚àà F : f i ‚àà M} for i = 0, . . .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>, k, and</head><formula xml:id="formula_40">œÅ i = {œÅ ‚àà L : œÅ i ‚àà M}, for i = 0, . . . , k -1 then S 0 œÅ 0 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S k-1 œÅ k-1 S k is an initialised path of Œì .</formula><p>Let M be a model of</p><formula xml:id="formula_41">[[Œì ]] k . We define œÄ(M) = S 0 œÅ 0 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S k-1 œÅ k-1 S k , where S i = { f : f i ‚àà M} for i = 0, . . . , k and œÅ i is the parallel composition of the rules in {œÅ : œÅ i ‚àà M} for i = 0, . . . , k -1. Theorem 4 (completeness) If œÄ k = S 0 œÅ 0 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S k-1 œÅ k-1 S k is an initialised path of Œì , then there exists a model M of [[Œì ]] k such that œÄ(M) = œÄ k .</formula><p>We now present two approaches to building the formulae <ref type="figure"></ref>and<ref type="figure">[[B]</ref>] k adapted from two encoding techniques originally introduced for AI planning, namely the linear encoding and the graphplan-based encoding <ref type="bibr" target="#b44">[45,</ref><ref type="bibr" target="#b34">35]</ref>.</p><formula xml:id="formula_42">I (f 0 ), T i (f i , œÅ i , f i+1 ),</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">The linear encoding</head><p>We assume that F and L have finite size. This is the case for BNAS problems for which it is possible to pre-compute these sets by looking at the signature of the language and at the rewrite rules of the protocol insecurity problem. Notice that although the cardinality of F and L is in the worst case exponential in the size of the original specification, the proper use of sort declarations and of the optimising transformations of Sect. 3.5 allows us to keep the size of F and L reasonably small for many protocols of interests.</p><p>The initial state is encoded by the formula:</p><formula xml:id="formula_43">I (f 0 ) = { f 0 : f ‚àà I} ‚àß {¬¨ f 0 : f ‚àà (F\I)} (<label>22</label></formula><formula xml:id="formula_44">)</formula><p>and the formula T i (f i , œÅ i , f i+1 ), encoding the i-th step of the transition relation, is given by the conjunction of the following formulae:</p><p>Universal Axioms: for each œÅ ‚àà L</p><formula xml:id="formula_45">œÅ i ‚äÉ { f i | f ‚àà pre(œÅ)} (<label>23</label></formula><formula xml:id="formula_46">)</formula><formula xml:id="formula_47">œÅ i ‚äÉ { f i+1 | f ‚àà add(œÅ)} (<label>24</label></formula><formula xml:id="formula_48">)</formula><formula xml:id="formula_49">œÅ i ‚äÉ {¬¨ f i+1 | f ‚àà del(œÅ)}<label>(25)</label></formula><p>Explanatory Frame Axioms: for all f ‚àà F</p><formula xml:id="formula_50">( f i ‚àß ¬¨ f i+1 ) ‚äÉ œÅ i | œÅ ‚àà L, f ‚àà del(œÅ) (<label>26</label></formula><formula xml:id="formula_51">)</formula><formula xml:id="formula_52">(¬¨ f i ‚àß f i+1 ) ‚äÉ œÅ i | œÅ ‚àà L, f ‚àà add(œÅ)<label>(27)</label></formula><p>Conflict Exclusion Axioms (CEA): for all pairs of rules</p><formula xml:id="formula_53">œÅ 1 , œÅ 2 ‚àà L such that œÅ 1 ‚äï œÅ 2 ¬¨(œÅ i 1 ‚àß œÅ i 2 ) (<label>28</label></formula><formula xml:id="formula_54">)</formula><p>Intuitively, the universal axioms state that for a rule œÅ to be applicable at the time-step i its preconditions must hold at the same time-index-cf. formula ( <ref type="formula" target="#formula_45">23</ref>)-and its effects must hold at the next time-index-cf. formulae ( <ref type="formula" target="#formula_47">24</ref>) and ( <ref type="formula" target="#formula_49">25</ref>) for positive and negative effects respectively. The explanatory frame axioms express that if a fact changes value from true to false (from false to true) between the time-indexes i and i + 1, then one of the rules that deletes (adds, resp.) the fact must have been applied at time-index i-cf. formula (26) (formula <ref type="bibr" target="#b26">(27)</ref>, resp.). In other words, the explanatory frame axioms state that the rules are the only cause of change. The CEA, by imposing that two interfering rules cannot be executed at the same time, ensure that the interleaving semantics is respected. In the following example we describe a fragment of the encoding associated with our NSPK protocol insecurity problem.</p><p>Example 3 Let us consider the quantifier-free protocol insecurity problem resulting from the application of the second variant of the quantifier elimination method described in Sect. 4.1 and of the optimising transformations of Sect. 3.5.</p><p>Besides others, the problem contains the following two rewrite rules:</p><formula xml:id="formula_55">ik({ A, Na } Kb ) state(1, A, B, [B, A, Kb, Kb -1 , Ka], S) fresh(f 2 (B, 1, S)) sc_step 2a (A,B,Ka,Kb,Na,S) -----------------‚Üí state(3, A, B, [Na, f 2 (B, 1, S), B, A, Kb, Kb -1 , Ka], S) ik({ Na, f 2 (B, 1, S) } Ka ) witness(B, A, nb, f 2 (B, 1, S)) ik({ A, Na } Kb ) ik(A) ik(B) ik(Kb) state(1, A, B, [B, A, Kb, Kb -1 , Ka], S) fresh(f 2 (B, 1, S)) sc_step 2b (A,B,Ka,Kb,Na,S) -----------------‚Üí state(3, A, B, [Na, f 2 (B, 1, S), B, A, Kb, Kb -1 , Ka], S) ik({ Na, f 2 (B, 1, S) } Ka ) witness(B, A, nb, f 2 (B, 1, S)) ik({ A, Na } Kb )</formula><p>The universal axioms associated with the rule sc_step 2a (a, b, ka, kb, f 1 (a, 0, 2), 2) are as follow:</p><formula xml:id="formula_56">sc_step 2a (a, b, ka, kb, f 1 (a, 0, 2), 2) i ‚äÉ ik({ a, f 1 (a, 0, 2) } kb ) i ‚àß fresh(f 2 (b, 1, 2)) i ‚àß state(1, a, b, [b, a, kb, kb -1 , ka], 2) i (29) sc_step 2a (a, b, ka, kb, f 1 (a, 0, 2), 2) i ‚äÉ ik({ f 1 (a, 0, 2), f 2 (b, 1, 2) } ka ) i+1 ‚àß witness(b, a, nb, f 2 (b, 1, 2)) i+1 ‚àß state(3, a, b, [f 1 (a, 0, 2), f 2 (b, 1, 2), b, a, kb, kb -1 , ka], 2) i+1 (30) sc_step 2a (a, b, ka, kb, f 1 (a, 0, 2), 2) i ‚äÉ ¬¨fresh(f 2 (b, 1, 2)) i+1 ‚àß ¬¨state(1, a, b, [b, a, kb, kb -1 , ka], 2) i+1<label>(31)</label></formula><p>where ( <ref type="formula">29</ref>), <ref type="bibr" target="#b29">(30)</ref>, and ( <ref type="formula">30</ref>) are instances of ( <ref type="formula" target="#formula_45">23</ref>), <ref type="bibr" target="#b23">(24)</ref>, and ( <ref type="formula" target="#formula_49">25</ref>) respectively.</p><p>The explanatory frame axioms associated with the fact fresh(f 2 (b, 1, 2)) are:</p><formula xml:id="formula_57">fresh(f 2 (b, 1, 2)) i ‚àß ¬¨fresh(f 2 (b, 1, 2)) i+1 ‚äÉ sc_step 2a (a, b, ka, kb, f 1 (a, 0, 2), 2) ‚à® sc_step 2b (a, b, ka, kb, f 1 (a, 0, 2), 2) (32) ¬¨fresh(f 2 (b, 1, 2)) i ‚àßfresh(f 2 (b, 1, 2)) i+1 ‚äÉ f alse<label>(33)</label></formula><p>where ( <ref type="formula">32</ref>) and ( <ref type="formula" target="#formula_57">33</ref>) are instances of ( <ref type="formula" target="#formula_50">26</ref>) and ( <ref type="formula" target="#formula_52">27</ref>) respectively. Formula (32) states that there is no other way to change the value of fresh(f 2 (b, 1, 2)) from true to false other than executing either sc_step 2a (a, b, ka, kb, f 1 (a, 0, 2), 2) or sc_step 2b (a, b, ka, kb, f 1 (a, 0, 2), 2), while <ref type="bibr" target="#b32">(33)</ref> states that the freshness of f 2 (b, 1, 2) cannot be restored once it has been used. The rules sc_step 2a (a, b, ka, kb, f 1 (a, 0, 2), 2) and sc_step 2b (a, b, ka, kb, f 1 (a, 0, 2), 2) are obviously interfering since the execution of one prevents the execution of the other. The following CEA is thus generated:</p><formula xml:id="formula_58">¬¨ sc_step 2a (a, b, ka, kb, f 1 (a, 0, 2), 2) i ‚àß sc_step 2b (a, b, ka, kb, f 1 (a, 0, 2), 2) i (34)</formula><p>where ( <ref type="formula">34</ref>) is an instance of (28).</p><p>Theorem 5 states the soundness and completeness of the linear encoding. The proof, given in Appendix, amounts to showing that I (f 0 ) enjoys requirement R1 and T i (f i , œÅ i , f i+1 ) enjoys part (a) and part (b) of requirement R2. From this and from Theorem 3 it readily follows that the formulae ( <ref type="formula" target="#formula_43">22</ref>)-( <ref type="formula" target="#formula_53">28</ref>) faithfully encode the behaviours of Œì of length k and hence the main result. Since the structure of the formula T i (f i , œÅ i , f i+1 ) is independent from i, in the rest of this section we write</p><formula xml:id="formula_59">T (f i , œÅ i , f i+1 ) in place of T i (f i , œÅ i , f i+1 ).</formula><p>Since Œû is ground, we assume that B = G, ‚àÖ (with G ground) and we define [[B]] k = G k where G k is obtained from G by replacing every fact p with p k . Theorem 5 (soundness and completeness of the linear encoding</p><formula xml:id="formula_60">) If M is a model of [[Œû ]] k for k ‚â• 0, then S 0 œÅ 0 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S k-1 œÅ k-1 S k is a (partial-order) solution of Œû , where S i = { f ‚àà F : f i ‚àà M} for i = 0, . .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>. , k and œÅ i is the parallel composition of the rules in {œÅ ‚àà</head><formula xml:id="formula_61">L : œÅ i ‚àà M} for i = 0, . . . , k -1. Conversely, if œÄ k = S 0 œÅ 0 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S k-1 œÅ k-1 S k is a (partial-order) solution of Œû , then there exists a model M of [[Œû ]] k such that œÄ(M) = œÄ k .</formula><p>It is immediate to see that the number of atoms in Finally, the number of (binary) clauses in T (f i , œÅ i , f i+1 ) associated with the CEA is in O(|L| 2 ), as in the worst case all rules are pairwise interfering. Thus, the overall number of clauses is in</p><formula xml:id="formula_62">T (f i , œÅ i , f i+1 ) is in O(|F| + |L|), i.</formula><formula xml:id="formula_63">T (f i , œÅ i , f i+1 ) is in O(|F| + |L| 2 ).</formula><p>The quadratic growth of the number of the CEA can produce encodings of unmanageable size when the considered security protocol involves the exchange of complex messages.</p><p>It is possible to dispense with the CEA by using a bitwise representation of the rules as proposed in <ref type="bibr" target="#b34">[35]</ref>. This amounts to replacing the CEA with the Bitwise Rule Representation Axioms shown below. Let Q be a set of log 2 |L| new propositional variables and let Œ≤ be any injective function mapping every œÅ ‚àà L into a set of literals such that q ‚àà Œ≤(œÅ) if and only if (¬¨q) ‚àà Œ≤(œÅ) for all q ‚àà Q and all œÅ ‚àà L. Intuitively Œ≤(œÅ) provides a binary representation of œÅ in terms of the propositional variables in Q. Bitwise Rule Representation Axioms: for each œÅ ‚àà L:</p><formula xml:id="formula_64">œÅ i ‚â° Œ≤(œÅ) i (<label>35</label></formula><formula xml:id="formula_65">)</formula><p>By using this encoding the number of propositional atoms in . This is a considerable saving, but it must be noted that the bitwise rule representation axioms rule out all parallelism from the solutions as they impose that at most one rule is executed at a time. As a consequence, attacks are usually found at greater values of k than if the CEA are employed.</p><formula xml:id="formula_66">T (f i , œÅ i , f i+1 ) is still in O(|F| + |L|)</formula><p>A further alternative is to use the iterative abstraction/ refinement strategy we proposed in <ref type="bibr" target="#b7">[8]</ref>. The basic idea is to avoid generating the CEA a priori. By doing this we may get spurious attacks, i.e., attacks that are not executable. So, whenever a solution is found by the solver we check whether it is spurious or not. If it is not spurious, then the procedure halts reporting the attack. If the attack is spurious, then a set of pairs of interfering rules are extracted from the attack, a set of clauses excluding the simultaneous execution of interfering rules is added to the formula, and the whole procedure is iterated. In the worst case the procedure detects a single pair of interfering rules at each iteration and stops when all the possible pairs are generated. Hence in the worst case the overall number of clauses generated by the procedure is still in O(|F| + |L| 2 ), but in many cases of interest, a small number of iterations is sufficient to discover an attack or to conclude that no attack exists.</p><p>We have thoroughly experimented with the variants of the linear encoding we have just presented: on all the problems considered the abstraction/refinement strategy outperforms both the approach based on the standard linear encoding and that based on the bitwise representation of the actions. Details of the experimental analysis can be found in <ref type="bibr" target="#b28">[29]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2">The graphplan-based encoding</head><p>We recall that by using the linear encoding the formula representing the transition relation, namely T (f i , œÅ i , f i+1 ), is independent from the time step i. From this it follows that important simplifications are possible on this formula. For instance, not all the rules are applicable at time step 0, yet the formula</p><formula xml:id="formula_67">T (f 0 , œÅ 0 , f 1 ) (36)</formula><p>encodes the effects of all possible rules, also those that are not applicable in the initial state. By looking at the initial state it is possible to build a simpler version of (36), say T 0 (f 0 , œÅ 0 , f 1 ), specifying the effect of only those rules that are applicable in the initial state. The same line of reasoning can be applied at the subsequent steps: by computing an over-approximation of the reachable states at time step i we can then determine a simplified encoding of the transition relation at time step i, say T i (f i , œÅ i , f i+1 ), for i = 0, . . . , k -1. Formally, the simplified encoding of such an over-approximation will be such that for every j = 0, . . . , k the formulae encoding the (multi)-set rewriting system by means of the linear encoding, i.e., I (f 0 )‚àß j-1 i=0 T (f i , œÅ i , f i+1 ), and by means of the graphplan-based encoding, i.e.,</p><formula xml:id="formula_68">I (f 0 ) ‚àß j-1 i=0 T i (f i , œÅ i , f i+1 ), are logically equivalent.</formula><p>The graphplan-based encoding is defined on the basis of the above ideas. Preliminary to the generation of the encoding is the construction of a data structure, called planning graph, used to determine for each time step an over-approximation of the reachable states. More in general, the planning graph concisely represents an over-approximation of the forward search tree and the encoding of the transition relation can be drastically simplified by exploiting this information.</p><p>In the rest of this section we will first describe how to construct a planning graph representing the over-approximation of the reachable states for the time step k, and then we will present how to exploit such an over-approximation while building the propositional formula I (f 0 ) ‚àß k-1 i=0 T i (f i , œÅ i , f i+1 ) that encodes the unfolding of the transition relation up to k steps.</p><p>The k-planning graph for Œì is a directed acyclic graph</p><formula xml:id="formula_69">([Œì ]) k = N f , N œÅ , --‚Üí pre , --‚Üí add , -‚Üí del , ‚äï f , ‚äï œÅ</formula><p>where N f is a time-indexed family of sets of fact nodes, i.e., N i f ‚äÜ F is the set of fact nodes of layer i, for i = 0, . . . , k; similarly N œÅ ‚äÜ L is a time-indexed family of sets of rule nodes, i.e., N i œÅ is the set of rule nodes of layer i for i = 0, . . . , k -1; --‚Üí pre , --‚Üí add , and -‚Üí del are time-indexed binary relations between rule nodes and fact nodes, i.e., --‚Üí</p><formula xml:id="formula_70">pre i ‚äÜ N i œÅ √ó N i f , --‚Üí add i ‚äÜ N i œÅ √ó N i+1 f , and -‚Üí del i ‚äÜ N i œÅ √ó N i+1</formula><p>f , whose instances are called preconditions, add, and delete edges respectively, for i = 0, . . . , k -1; finally ‚äï f and ‚äï œÅ are time-indexed (irreflexive and commutative) relations of mutual exclusion (mutex for short) between facts (i.e., ‚äï i f ‚äÜ N i f √ó N i f ) and rules (i.e., ‚äï j œÅ ‚äÜ N j œÅ √ó N j œÅ ) respectively, for i = 0, . . . , k and j = 0, . . . , k -1.</p><p>As a preliminary step to the construction of the k-planning graph for Œì the sets L and R are extended with the nooperation rule labels and rules of the form nop( f ) and</p><formula xml:id="formula_71">( f nop( f )</formula><p>----‚Üí f ) respectively, for all f ‚àà F. The k-planning graph for Œì is then inductively defined as follows: </p><formula xml:id="formula_72">(PG1) N 0 f = I; moreover, f ‚àà N i f if and only if there exists œÅ ‚àà N i-1 œÅ such that either œÅ --‚Üí add i-1 f or œÅ -‚Üí del i-1 f , for i = 1, . . . , k; (PG2) œÅ ‚àà N i œÅ if and only if pre(œÅ) ‚äÜ N i f and for all facts f, f ‚àà pre(œÅ) not f ‚äï i f f , for i = 0, . . . , k -1; (PG3) for each œÅ ‚àà N i œÅ and for i = 0, . . . , k -1: œÅ --‚Üí pre i f if and only if f ‚àà pre(œÅ),</formula><formula xml:id="formula_73">f, f ‚àà F s.t. œÅ --‚Üí pre i f , œÅ --‚Üí pre i f , and f ‚äï i f f , for i = 0, . . . , k -1; (PG5) f ‚äï i f f if and only if f = f and for all œÅ, œÅ ‚àà N i-1 œÅ such that œÅ = œÅ , œÅ --‚Üí add i-1 f and œÅ --‚Üí add i-1 f we have œÅ ‚äï i-1 œÅ œÅ , for i = 1, . . . , k.</formula><p>It can be shown that the time needed to build the k-planning graph for Œì is polynomial in the size of Œì . Notice that unlike in the linear encoding it is not necessary to assume that L and R have finite size: finite over-approximations of the facts reachable in k steps and of the rules executable in one of the k steps (resp.) are automatically built during the construction of the planning graph. These over-approximations are still in the worst case exponential in the size of the original specification, but are usually dramatically smaller than those computed for the linear encoding.</p><p>Example 4 Let us consider the quantifier-free (multi)-set rewriting system Œì such that F = {v, x, y, w, z}, L = {a, b, c, d}, I = x y, and R = {(x</p><formula xml:id="formula_74">a -‚Üí x y z), (x z b -‚Üí w z), (w c -‚Üí w z), (v d -‚Üí v x)}.</formula><p>The forward search tree of depth 3 associated with Œì is depicted in Fig. <ref type="figure" target="#fig_4">6</ref>. By applying rule a the system moves from the initial state x y to the state x y z (i.e., the fact z is added by a); by executing any of the applicable no-operation rules-denoted by nop(_)-the system remains in the current state x y and the same branch of the forward search tree can be repeated; no other rules can be applied from the initial state.</p><p>A graphical representation of ([Œì ]) 3 is given in Fig. <ref type="figure">7</ref>. The set of fact nodes are built starting with layer 0 (N 0 f = {x, y}) and the mutex relation on the same layer is initialised to the empty set (‚äï 0 f = ‚àÖ). The rest of the planning graph is built by repeating the following steps for i = 0, 1, 2: (i) the set of rule nodes at layer i is computed, e.g., N 0 œÅ = {a, nop(x), nop(y)}; (ii) the mutex relation on the rules at layer i is calculated, e.g., a ‚äï 1 œÅ b and b ‚äï 1 œÅ nop(x) at layer 1; (iii) the set of fact nodes at layer i + 1 is computed, e.g., </p><formula xml:id="formula_75">N 0 N f N œÅ N f N œÅ N f œÅ 1 1 2 2 3</formula><p>x y w Fig. <ref type="figure">7</ref> Planning graph N 1 f = {x, y, z}; and (iv) the mutex relation on the facts at layer i + 1 is calculated, e.g., x ‚äï 2 f w at layer 2.</p><p>The over-approximation of the set of states reachable at step i ‚â§ k associated with ([Œì ]) k is given by: MBR</p><formula xml:id="formula_76">(([Œì ]) k , i) = {S ‚äÜ N i f : not f 1 ‚äï i f f 2 for all f 1 , f 2 ‚àà S} Thus if S is reachable in i steps, then S ‚àà MBR(([Œì ]) k , i),</formula><p>for i = 0, . . . , k, while the converse does not necessarily hold as illustrated by the following example. This ensures that all the states in 2 F \ MBR(([Œì ]) 3 , 1), i.e., all the states containing the fact w, are unreachable at depth 1. However we cannot guarantee that the states in MBR (([Œì ]) 3 , 1) are indeed reachable. To show this it suffices to consider the state x. This state is in MBR(([Œì ]) 3 , 1), but it is not reachable at depth 1 as shown by the forward search tree of Fig. <ref type="figure" target="#fig_4">6</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Given a quantifier-free reachability problem</head><formula xml:id="formula_77">Œû = Œì, B , if MBR(([Œì ]) k , k) ‚à© {B : B | B} = ‚àÖ,</formula><formula xml:id="formula_78">(i.e., if S ‚àà MBR(([Œì ]) k , k)) is indeed reachable at time step k can be reduced to checking if M = { f k : f ‚àà S} is a model of [[Œì ]] k = I (f 0 ) ‚àß k-1 i=0 T i (f i , œÅ i , f i+1 )</formula><p>where the initial state is encoded by</p><formula xml:id="formula_79">I (f 0 ) = { f 0 : f ‚àà N 0 f }<label>(37)</label></formula><p>and T i (f i , œÅ i , f i+1 ) for i = 0, . . . , k -1 is the conjunction of the following formulae.</p><p>Universal Axioms: for each œÅ ‚àà N i</p><formula xml:id="formula_80">œÅ œÅ i ‚äÉ { f i | œÅ --‚Üí pre i f } (38) œÅ i ‚äÉ { f i+1 | œÅ --‚Üí add i f } (<label>39</label></formula><formula xml:id="formula_81">)</formula><formula xml:id="formula_82">œÅ i ‚äÉ {¬¨ f i+1 | œÅ -‚Üí del i f )} (<label>40</label></formula><formula xml:id="formula_83">)</formula><p>Explanatory Frame Axioms (EFA): for all f ‚àà N i f</p><formula xml:id="formula_84">( f i ‚àß ¬¨ f i+1 ) ‚äÉ œÅ i | œÅ -‚Üí del i f (<label>41</label></formula><formula xml:id="formula_85">)</formula><formula xml:id="formula_86">(¬¨ f i ‚àß f i+1 ) ‚äÉ œÅ i | œÅ --‚Üí add i f (42)</formula><p>Additionally, for all f ‚àà (N i+1 f \N i f )</p><formula xml:id="formula_87">f i+1 ‚äÉ œÅ i | œÅ --‚Üí add i f (43) Mutex Axioms: for all p 1 , p 2 ‚àà (N i œÅ ‚à™ N i f ) such that p 1 ‚äï i p 2 : ¬¨( p i 1 ‚àß p i 2 ) (<label>44</label></formula><formula xml:id="formula_88">)</formula><p>The additional explanatory frame axioms <ref type="bibr" target="#b43">(44)</ref> simply state that if a fact holds at time step i + 1 and it occurs in the (i + 1)-th layer N i+1 f but it does not occur in the preceding one (i.e., N i f ), then at least one of the rules occurring in the i-th rule layer and adding f must hold at the time step i. Basically the extra explanatory frame axiom for the fact f is just a simplification of the explanatory frame axiom for f where f is imposed to be false at time step i. Notice that this follows from the observation that if f is introduced only at the (i + 1)-th fact layer of the planning graph, then there is no state reachable in i steps in which f holds.</p><p>We now state the soundness and completeness of the graphplan-based encoding. As for the case of the linear encoding, Œû is ground and therefore B = G, ‚àÖ (with G ground). We then define [[B]] k = Gk where Gk is obtained from G by first replacing every fact f ‚àà N k f by f alse and every other fact p with p k .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 6 (soundness and completeness of the graphplanbased Encoding</head><formula xml:id="formula_89">) If M is a model of [[Œû ]] k for k ‚â• 0, then S 0 œÅ 0 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S k-1 œÅ k-1 S k is a (partial-order) solution of Œû , where S i = { f ‚àà F : f i ‚àà M} for i = 0, . .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>. , k and œÅ i is the parallel composition of the rules in {œÅ ‚àà</head><formula xml:id="formula_90">L : œÅ i ‚àà M} for i = 0, . . . , k-1. Conversely, if œÄ k = S 0 œÅ 0 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S k-1 œÅ k-1 S k is a (partial-order) solution of Œû , then there exists a model M of [[Œû ]] k such that œÄ(M) = œÄ k .</formula><p>In the worst case the number of atoms and clauses generated by the graphplan-based encoding are equal to those generated with the linear encoding. However, in most cases</p><formula xml:id="formula_91">|N i f | |F| (for i = 0, . . . , k) and |N i œÅ |</formula><p>|L| (for i = 0, . . . , k -1) and therefore the formulae generated by the graphplan-based encoding are usually considerably smaller than those built with linear encoding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">SAT-based model checking for security protocol analysis</head><p>The techniques presented in the previous sections are the fundamental building blocks of the SAT-based model checking procedure outlined in Fig. <ref type="figure" target="#fig_2">1</ref>. In particular -the optimising transformations on the input protocol insecurity problem described in Sect. 3.5 are applied at line 3 of the procedure, -the techniques for the elimination of quantifiers presented in Sect. 4.1 are applied at line 4, and -the encoding techniques described in Sect. 4.3 are applied at line 6. Notice that [[Œû ]] i needs not be computed from scratch at each iteration. When building [[Œû ]] i it is in fact possible to reuse (selected parts of) the formula generated at the previous step thereby speeding up significantly the whole procedure.</p><p>We recall that (by setting k to ‚àû) the procedure in Fig. <ref type="figure" target="#fig_2">1</ref> can be used as a semi-decision procedure for the input protocol insecurity problem Œû , i.e., the procedure halts with a solution when it exists, but it may not terminate otherwise. In the rest of this section we discuss the termination and the complexity of the procedure when applied to a BNAS protocol insecurity problem Œû . Let n be the DAG size of Œû .</p><p>Termination. We know from <ref type="bibr" target="#b60">[61]</ref> that for every attack on Œû there exists an attack on Œû such that between the consecutive application of two rules of the honest agents there are at most 3n 2 applications of the intruder rules. Since sessions are acyclic, the maximal number of rules of the honest agents occurring in an attack is r * s, where r and s are the number of rules of the honest agents and the number of sessions in Œû . Therefore we can restrict our attention to attacks of length ‚â§ k max , where k max = 3n 2 (r * s + 1). Thus the procedure of Fig. <ref type="figure" target="#fig_2">1</ref> is a decision procedure for BNAS problems provided that we add the following line between lines 8 and 9:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">. If [[Œû ]]</head><p>i is unsatisfiable and i ‚â• k max , then print "No attack exists for the BNAS input problem" and then halt.</p><p>A smaller value for k max can be computed whenever the specialisation of the composition rules of the intruder described in Sect. 3.5 is applicable. Let Œû be the result of applying this optimisation to Œû . Since the composition rules of the intruder are built into the rules of the honest agents, the only possible activity that the intruder can do in between two applications of rules of the honest agents is to apply a sequence of decomposition rules. It is easy to see that this sequence can comprise at most d -1 applications of decomposition rules, where d is the maximal depth of the messages occurring in the right hand side of the rewrite rules of Œû . Thus k max = (d -1)(r * s + 1) suffices. In fact the application of the optimising transformation to Œû does not change the number of sessions and, although the number of rules in Œû is usually greater than that of Œû , each path will contain at most r application of the (specialised) rules of the honest agents. (We recall from Sect. 3.5 that each path of Œû contains at most one application of the rules in RC(sc_r ) for each step compressed rule sc_r of Œû .) For the two-sessions variant of the NSPK protocol with the Lowe's fix <ref type="bibr" target="#b48">[49]</ref>, well-known to be not flawed when type-flaw attacks are neglected, we can thus safely bound our analysis to k max = (3 -1)(4 * 2 + 1) = 18 steps.</p><p>Under the same hypotheses, there is another, usually very effective approach to determine whether [[Œû ]] i covers all possible attacks of Œû , and thus to enforce an early (but still safe) termination of the procedure when the graphplan-based encoding is applied. Following <ref type="bibr" target="#b19">[20]</ref> we say that a planning graph ([Œì ]) i has levelled-off when two adjacent fact levels are identical. The following result, which applies to BNAS problems obtained by specialising the composition rules of the intruder as described in Sect. 3.5, ensures that when the planning graph has levelled off, if the current formula [[Œû ]] i is unsatisfiable then there is no attack on Œû . (Notice that for BNAS problems obtained by specialising the composition rules of the intruder, the planning graph is always guaranteed to reach the levelled-off.) Theorem 7 Let Œû = Œì, B be a BNAS problem obtained by specialising the composition rules of the intruder as described in Sect. <ref type="bibr" target="#b2">3</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>.5. When ([Œì ]) i has levelled-off, if [[Œû ]]</head><p>i is unsatisfiable, then there is no attack on Œû . By using the above result we can thus further improve the procedure of Fig. <ref type="figure" target="#fig_2">1</ref> by adding the following line just after line 8:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">. If the planning graph has levelled off and [[Œû ]</head><p>] i is unsatisfiable, then print "No attack exists for the BNAS input problem" and then halt.</p><p>Notice that in this way the procedure can conclude that the protocol is secure without reaching k max . For the two-sessions variant of the NSPK protocol with the Lowe's fix the procedure halts at i = 7, thereby saving 11 iterations.</p><p>Complexity. We now discuss the complexity of our model checking procedure when used as a decision procedures for BNAS problems. We start by first looking at the complexity of the individual steps of the procedure and then we discuss the complexity of the overall procedure. We consider both variants of the procedure we have just outlined.</p><p>-Optimising transformations (line 3 As we previously said, the iterations of the while loop of the procedure is bound by k max , where k max is polynomial in n.</p><p>To summarise, in the worst case, our decision procedure generates and solves polynomially many propositional formulae whose size is at most exponential in the size of the input specification. Though this complexity result seems to limit the applicability of the approach to small size protocols, in the next section we will see that our approach generates formulae of manageable size which are quickly solved by the SAT solver in many cases of interest.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Experimental results</head><p>We have implemented the above ideas in SATMC <ref type="bibr" target="#b8">[9]</ref>, a SAT-based Model Checker for the automatic analysis of security protocols. SATMC is available at http://www.ai.dist. unige.it/satmc. SATMC is also integrated in the AVISPA Tool <ref type="bibr" target="#b4">[5]</ref>, a push-button tool for the automated validation of Internet security-sensitive protocols and applications, and can be used on-line via the AVISPA graphical user interface available at http://www.avispa-project.org.</p><p>We thoroughly assessed our approach by running SATMC on a large set of protocols drawn from so-called Clark-Jacob library and the AVISPA Library. The Clark-Jacob library <ref type="bibr" target="#b26">[27]</ref> is a collection of small and medium-sized authentication protocols. The AVISPA Library (available at http:// www.avispa-project.org) is a selection of practically relevant, industrial protocols that have recently been standardised or are currently undergoing standardisation, especially at the Internet Engineering Task Force (IETF). For each protocol we consider a BNAS problem modelling a scenario consisting of a bounded number of sessions in which the involved principals exchange messages over a channel controlled by a Dolev-Yao intruder. These BNAS problems are automatically generated by the AVISPA Tool starting from a protocol specification in a higher level specification language called HLPSL <ref type="bibr" target="#b24">[25]</ref>. All the experimental results presented in this section have been obtained by setting a resource limit of 1 h CPU time and 1 GB memory, on a Pentium IV 2.4 GHz under Linux. SATMC is invoked with k set to ‚àû on all the problem considered and the tool always terminates by either reporting an attack, by positively concluding that no attack is possible on the given problem, or by exhausting the available resources.</p><p>In order to fine tune our techniques and quantitatively assess the relative merits of the encoding techniques discussed in Sect. 4 we run the encoding techniques (including some variants thereof) implemented in SATMC against a selection of (flawed) security protocols drawn from the Clark-Jacob library. We found that the linear encoding performs best when used in conjunction with the abstraction/ refinement strategy discussed in Sect. 4.3.1. We also found that the graphplan-based encoding performs best if we weaken the definition of ‚äï by enforcing only static mutexes (i.e., by neglecting PG5 and by considering only case (a) of clause PG4 in the definition of the planning graph given in Sect. 4.3.2). By using this weaker version of the mutex relation we obtain a coarser over-approximation of the set of the reachable states. Our experimental results indicate that this loss of precision in the construction of the planning graph is largely compensated by a drastic reduction in the time spent to build the planning graph.</p><p>The best results obtained with each encoding are given in Table <ref type="table" target="#tab_10">2</ref>. For each protocol we give the smallest value of k at which the attack is found (K) and for each encoding technique we give the number of propositional variables (A) and clauses (CL) in the SAT formula, the time spent to generate the SAT formulae (EncT) and the total time spent by the SAT solver to solve the SAT formulae (SolT). The comparison shows that, by using the graphplan-based encoding technique, we obtain (i) SAT instances whose size is up to 3 orders of magnitude smaller and (ii) significantly better encoding and solving times. Moreover by using the graphplan-based encoding SATMC succeeds in analysing protocols (e.g., the KLS rep. protocol) that otherwise are not solved with the given resources.</p><p>We have then compared SATMC against two other stateof-the-art protocol analysers integrated in the AVISPA Tool, namely CL-AtSe <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b63">64]</ref> and OFMC <ref type="bibr" target="#b11">[12]</ref>, by running them against the security protocols in the AVISPA Library. The results are given in Table <ref type="table" target="#tab_11">3</ref>. These results are obtained by assuming that all the messages exchanged are well-typed and that they are freely generated. <ref type="foot" target="#foot_0">1</ref> For each protocol we give the number of security problems analysed ("#Pb") and the number of problems for which attacks are detected ("#Att"), and for each back-end, the average time spent by the back-end to analyse (i.e., either to find the attacks or to report that no attack exists in the scenario considered) a single problem of the protocol. For SATMC we report only the time spent by the back-end to generate the SAT formula, since in this case the time spent by the SAT-solver-we used the Chaff solver <ref type="bibr" target="#b55">[56]</ref> for these experiments-to solve the formula is negligible.</p><p>The boxed number associated with ISO-PK-3 (corresponding to the ISO Public Key Two-Pass Mutual Authentication protocol <ref type="bibr" target="#b43">[44]</ref>) indicates that the back-ends have found a new (i.e., previously unknown) attack on the protocol. It was already known that ISO-PK3 is vulnerable to replay attacks and hence it does not provide strong authentication <ref type="bibr" target="#b31">[32]</ref> as nothing in the messages ensures the freshness of the messages for the responder. Our analysis, however, shows that the ISO-PK3 protocol does not even guarantee weak authentication, i.e., after successfully executing the protocol, neither the initiator nor the responder can be sure about the authenticity of the exchanged messages.</p><p>In general the experiments indicate that the time spent by SATMC and by the other tools is small for all the problems. More in particular, OFMC and CL-AtSe are very fast and performs better than SATMC in many cases whereas SAT-MC performs slightly better on some instances (namely Fair-ZG and PBK-fix-weak-auth) and on a few protocols (namely By inspecting the problems used for the experiments of Table <ref type="table" target="#tab_11">3</ref> it possible to conclude that OFMC and CL-AtSe are less sensitive than SATMC to the size of messages exchanged by the protocols. This is not surprising since we know that the complexity of our approach depends on the size of the messages exchanged. We also noticed that SATMC is less sensitive than OFMC and CL-AtSe to the number of con- current sessions considered. To verify this we then run all the three tools against problems modelling both the flawed and the fixed variants of the NSPK-KS protocol (i.e., the Needham-Schroeder Public Key protocol including the keyserver <ref type="bibr" target="#b56">[57]</ref>) for increasing numbers of concurrent sessions. The experimental results, summarised in Table <ref type="table" target="#tab_12">4</ref>, indicate that OFMC and CL-AtSe fail to analyse the problem within the given resources when more than three sessions are considered, whereas SATMC successfully analyse all the problems considered and scales very smoothly as the number of sessions increases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related work</head><p>We broadly classify the related approaches in SAT-based automated reasoning techniques and in techniques for the automatic analysis of security protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">SAT-based automated reasoning techniques</head><p>Planning as satisfiability. We have greatly benefited from the experience matured in the area of "Planning as Satisfiability" initiated by the seminal paper by Kautz and Selman <ref type="bibr" target="#b45">[46]</ref>. While the encoding techniques we use are adapted from those proposed for planning <ref type="bibr" target="#b44">[45,</ref><ref type="bibr" target="#b34">35]</ref>, their application to the automatic analysis of security protocols is new as new are the proofs of soundness and correctness of the encodings of Sect. 4. Proofs of similar results have been recently and independently developed for planning by Rintanen et al. <ref type="bibr" target="#b59">[60]</ref>.</p><p>However their results apply to linear encodings only, whereas our approach is more general as it applies to graphplan-based encodings as well. In the same paper the authors propose encodings that may lead to shorter solutions than that allowed by the encodings used in our paper. This is an interesting feature, but its application may lead a number of additional clauses in the formula that grows cubically in the size of the input problem. While this may be acceptable for small problems, it does not seem very promising for our application domain.</p><p>We have also written a translator from protocol insecurity problems to planning problems and we have generated a set of planning problems corresponding to protocol insecurity problems taken from the Clark-Jacob library. We have then fed these problem to blackbox v.4.1, a state-of-the-art planner based on the planning as satisfiability paradigm. The experimental results reported in <ref type="bibr" target="#b28">[29]</ref> indicate that SATMC performs uniformly and significantly better than blackbox on these problems. One of the problem with blackbox is the limited expressiveness of the PDDL input specification language <ref type="bibr" target="#b38">[39]</ref>. For instance only individual constants are allowed by PDDL and this can circumvented only by generating very large PDDL specifications.</p><p>Answer set programming. It is well-known that logic programming with answer sets semantics is closely related to propositional logic <ref type="bibr" target="#b57">[58,</ref><ref type="bibr" target="#b47">48]</ref> and AI planning <ref type="bibr" target="#b46">[47]</ref>. In <ref type="bibr" target="#b2">[3]</ref>, the authors present an executable specification language for security protocols based on logic programming and use an efficient model generators for logic programs to find attacks on protocols. Experimental results reported in the same paper show the feasibility of the approach on protocols in the Clark-Jacob library. SATMC performs significantly better on the same problems and-as we showed in Sect. 6-it also successfully analyses protocols of industrial complexity. A further attempt to use logic programming with answer sets semantics to analyse security protocols is described in <ref type="bibr" target="#b10">[11]</ref>.</p><p>Bounded model checking. The approach described in this paper belongs to the wider area of bounded model checking <ref type="bibr" target="#b14">[15]</ref> and as such it can benefit from results obtained in this context. We are currently extending SATMC in order to support the analysis of protocols with respect to goals expressed as generic LTL formulae. This will allow for the specification of (i) different, more sophisticated intruder models (e.g., resilient and location-limited communication channels) by means of fairness constraints and (ii) more complex security properties.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Other techniques for security protocols analysis</head><p>Process calculi. Casper/FDR has been applied to analyse security protocols of the Clark-Jacob library in <ref type="bibr" target="#b31">[32]</ref>. Protocol specifications, written in the high level Casper specification language, are translated into CSP specifications which are then fed to FDR. This approach has been very successful to discover new flaws in protocols. However, some prelimi-nary experiments indicate that SATMC performs better than Casper/FDR. Besides this, Casper/FDR is not able to handle non-atomic keys and this prevents the application of the approach to the analysis of many real-world protocols. Our approach does not suffer from this limitation.</p><p>A technique for the automatic analysis of security protocols based on Non-Interference is proposed in <ref type="bibr" target="#b37">[38]</ref>. The approach, which is based on a slight extension of CCS, has been proved effective a large subset of protocols from the Clark-Jacob library <ref type="bibr" target="#b32">[33]</ref>. The Non-Interference check provides a sufficient condition for the absence of attacks, but, whenever the Non-Interference check fails, the set of interferences returned must be (manually) inspected by the user in order to determine those corresponding to attacks. Another variant of CCS is at the core of the partial model checking technique for security protocols proposed in <ref type="bibr" target="#b52">[53]</ref>. Here the protocol is modelled as an open system and therefore the analysis does not rely on a specific intruder model. The approach is currently limited to the analysis of security protocols with a bounded number of acyclic sessions and bounded message size. A decidability result has been proved when the analysis is restricted to secrecy properties. The techniques has been successfully applied against several protocol instances including NSPK and SSL, but since a systematic experimental analysis is not publicly available it is difficult to assess its scalability.</p><p>A novel static analysis technique for security protocols is proposed in <ref type="bibr" target="#b21">[22]</ref>. The technique, which is based on LySa (a process algebra inspired by the Spi-calculus), is fully automatic and always terminating in polynomial time. The tool builds an over-approximation of the behaviour of the protocol (including also the actions performed by a Dolev-Yao intruder). If no traces representing attacks on the protocol are in the over-approximation, then the protocol is guaranteed to satisfy the expected security property. Otherwise the over-approximation is explored in order to detect an attack on the protocol. If the search is successful then the found attack is reported to the user, otherwise the result is inconclusive. However this does not happen so frequently and the approach has been shown to be efficient on several security protocols of interest <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b41">42]</ref>. (A related static analysis technique for authentication protocols is presented in <ref type="bibr" target="#b22">[23]</ref>.) Our work is complementary to this as it is capable to detect all the attacks on the protocol for the given scenario but may fail to establish their absence in the general case.</p><p>The idea of type-checking secrecy properties of cryptographic protocols has been put forward in <ref type="bibr" target="#b0">[1]</ref>. The approach has been later extended to support the verification of authentication properties by using both types and effects and by annotating protocol specifications (in the Spi-calculus) with correspondence assertions <ref type="bibr" target="#b39">[40,</ref><ref type="bibr" target="#b40">41]</ref>. As in the previous case, these techniques always terminate and can check the absence of attacks, but can report spurious attacks.</p><p>Blanchet's logic programming approach. Bruno Blanchet has developed a technique and a tool (called ProVerif) in which protocols and security properties are expressed as sets of Horn clauses which are then saturated by means of different strategies <ref type="bibr" target="#b16">[17]</ref><ref type="bibr" target="#b17">[18]</ref><ref type="bibr" target="#b18">[19]</ref>. ProVerif allows one to prove security properties for an unbounded number of protocol sessions, in particular strong secrecy (which means that an intruder cannot see any difference when the value of the secret changes). The tool may raise some false attacks since nonces are abstracted by constants or function symbols, so that attacks have to be constructed by the user itself. (Recently, however, ProVerif has been enhanced to reconstruct automatically the attacks in some cases <ref type="bibr" target="#b3">[4]</ref>.) Termination of the technique (which is not guaranteed in the general case) has been proved for the restricted class of protocols in which encryption primitives are distinguished by means of a tagging mechanism <ref type="bibr" target="#b15">[16]</ref>.</p><p>Explicit state model checking. The general purpose state enumeration based model-checker Murphi has been applied to analyse some small cryptographic protocols such as the NSPK protocol <ref type="bibr" target="#b54">[55]</ref>. Experimental results indicate that Murphi suffers from state-space explosion. To cope with this problem the user must restrict the model in several ways. For instance, the size of the network channel as well as the size of the intruder knowledge are fixed a priori. Moreover the intruder model is not provided by the tool, but the burden is on the user to come out with an appropriate finite state machine describing the intruder behaviour. As a result, an attack on the protocol can be missed because either the bound imposed for some parameter is too small (e.g., the attack may require an intruder with more memory than that specified) or an ability of the intruder that has not been specified.</p><p>brutus combines depth-first search with a message derivation mechanism modelling the capabilities of the intruder in the spirit of the Paulson's synthesise and analyse operators <ref type="bibr" target="#b58">[59]</ref>. A powerful specification logic is also provided to describe a variety of security properties including secrecy, authentication, non-repudiation, and a weak form of anonymity. Similarly to other explicit state model checkers, brutus suffers from the state explosion problem, partially mitigated by some partial-order reduction techniques <ref type="bibr" target="#b27">[28]</ref>. However the approach has been experimented only on a few protocols. Furthermore brutus supports atomic keys only.</p><p>Lazy evaluation-based approaches for protocol insecurity problems. Both OFMC <ref type="bibr" target="#b13">[14]</ref> and CL-AtSe <ref type="bibr" target="#b25">[26]</ref> combine forward search exploration with constraint solving using a symbolic representation of the search space. OFMC also features a novel partial order reduction technique, called constraint differentiation <ref type="bibr" target="#b12">[13]</ref>, that leads to considerable pruning in the search space. Both tools are also capable to exploit some algebraic properties of the cryptographic operators.</p><p>Thus both OFMC and CL-AtSe use symbolic techniques to explore the search space in a demand-driven way. SATMC is dual in this respect as it eagerly expands all the terms while building the propositional formula and delegates the search to the SAT solver. It is thus not surprising that OFMC and CL-AtSe are less sensitive than SATMC to the size of messages exchanged in the protocol. On the other hand SATMC is less sensitive than OFMC and CL-AtSe to the combinatorial explosion associated with the interleaved execution of multiple sessions of the protocol.</p><p>Strand spaces approaches. Strand spaces <ref type="bibr" target="#b36">[37]</ref> provide an alternative approach to state-based analysis of protocol by emphasising causal interactions among protocol participants. The approach has been implemented in the Athena protocol analyser <ref type="bibr" target="#b61">[62]</ref> which combines model checking and theorem proving techniques with the (parametric) strand space model to reduce the search space and automatically prove the correctness of or find an attack on security protocols (if it terminates). Besides the strands for honest roles, Athena uses quite prolific strands for modelling the behaviour of the Dolev-Yao intruder. Moreover, Athena supports atomic keys only. In <ref type="bibr" target="#b53">[54]</ref> and, later, in <ref type="bibr" target="#b29">[30]</ref> these limitations have been uplifted.</p><p>These strands-based tools has been successfully experimented against the protocols in the Clark-Jacob library <ref type="bibr" target="#b26">[27]</ref>. Since their input language is different from that of SATMC, a direct comparison is not possible, but according to the published material <ref type="bibr" target="#b61">[62,</ref><ref type="bibr" target="#b53">54,</ref><ref type="bibr" target="#b29">30]</ref> the results obtained with these tools are very good and promising. However, no results are available on protocols of industrial complexity like those in the AVISPA library.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusions</head><p>We have presented a model checking procedure for security protocols based on a reduction to propositional logic. We have described a number of specialised techniques that are essential to make the approach not only viable but also effective on many problems of practical interest. In particular we have adapted and applied encoding techniques originally developed for planning to security protocol analysis, proving their soundness and completeness. Moreover, we have showed that our procedure can be turned into a decision procedure for BNAS problems. To demonstrate the feasibility and effectiveness of our approach we have run our tool against a large set of complex, industrial strength security protocols and compared it with two state-of-the-art protocol analysers. The experiments indicate that our tool is more sensitive to the size of the messages exchanged by the protocol but it scales better than other state-of-the-art tools as the number of sessions increases.</p><p>In the future we would like to extend our techniques so to provide support for the specification of security properties by means of generic LTL formulae. This will provide the user considerably more flexibility in the specification of the security properties that the protocol is expected to enjoy as well as of the properties of the environment (e.g., the communication channels) in which the protocol is executed.</p><p>Acknowledgments This work was partially funded by FET Open EC Project "AVISPA: Automated Validation of Internet Security Protocols and Applications" (IST-2001-39252) and by the FIRB Project no. RBAU01P5SS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Appendix: Proofs of the main results</head><p>A.1 Proofs of the results of Sect. 3.3 Lemma 1 Let œá be a run of Œì = I, R and œá be a sequence of rule instances of Œì . If œá is rule equivalent to œá then also œá is a run of Œì and app œá (I) ‚àº app œá (I).</p><p>Proof The proof is by induction on the length of œá . The key steps of the proof amount to showing for any rule instance œÅ, œÉ with L œÅ -‚Üí ‚àÉy.R that (i) if œÅ, œÉ is applicable to S then it is also applicable to all the states that are equivalent to S (this follows from the observation that LœÉ does not contain any fresh constant); (ii) app œÅ,œÉ (S) ‚àº app œÅ,œÉ (S) for all states S and ground substitutions œÉ .</p><p>Theorem 1 Let œá be a solution to Œû = Œì, B and œá be a sequence of rule instances of Œì . If œá is rule equivalent to œá then also œá is a solution to Œû . Proof The proof is based on Lemma 1 and the observation that the set of bad states is closed under renaming of fresh constants.</p><p>A.2 Proofs of the results of Sect. 4.2</p><formula xml:id="formula_92">Lemma 2 Let œÅ 1 , . . . , œÅ n be composable rules, let œÅ k 1 , . . . , œÅ k n be a linearisation of œÅ 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ œÅ n , and let S 0 ‚äá n i=1 pre(œÅ i ), then app œÅ k 1 ;‚Ä¢‚Ä¢‚Ä¢ ;œÅ kn (S 0 ) = app œÅ 1 ‚Ä¢‚Ä¢‚Ä¢ œÅ n (S 0 ).</formula><p>Proof The proof is by induction on n. Since the base case is trivial, here we focus on the step case that is proved as shown in Fig. <ref type="figure">8</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 4</head><p>Let œÅ 1 , . . . , œÅ n be composable rules. If œÅ i does not interfere with œÅ j for i, j = 1, . . . , n, then all permutations of œÅ 1 , . . . , œÅ n are linearisations of œÅ 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ œÅ n .</p><p>Proof Let œÅ k 1 , . . . œÅ k n be a generic permutation of œÅ 1 , . . . , œÅ n . We must show that œÅ k i+1 is applicable in S i for i = 0, . . . , n -1, where S 0 ‚äá n i=1 pre(œÅ i ) and S i+1 = app œÅ k i+1 (S i ) for i = 0, . . . , n -1. To this end we prove a more general fact, namely that œÅ k j is applicable in S i for all j = i + 1, . . . , n and all i = 0, . . . , n -1, from which the above fact can be readily inferred by considering the cases in which j = i + 1. The proof is by induction on i. The base case (i.e., i = 0) boils down to showing that œÅ k j is applicable in S 0 for all j = 1, . . . , n. This trivially holds since S 0 ‚äá n i=1 pre(œÅ i ) = n j=1 pre(œÅ k j ). For the step case we must show that œÅ k j is applicable in S i+1 for all j = i + 2, . . . , n. Let j be such that i + 1 &lt; j ‚â§ n. By induction hypothesis it readily follows that œÅ k j is applicable in S i or, in other words, that pre(œÅ k j ) ‚äÜ S i . Since, by hypothesis, œÅ k j and œÅ k i+1 do not interfere, we know that pre(œÅ k j ) ‚à© del(œÅ k i+1 ) = ‚àÖ. From this we can conclude that pre(œÅ k j ) ‚äÜ S i \ del(œÅ k i+1 ) and therefore also that pre(œÅ</p><formula xml:id="formula_93">k j ) ‚äÜ (S i \ del(œÅ k i+1 )) ‚à™ add(œÅ k i+1 ) = S i+1 .</formula><p>Thus œÅ k j is applicable in S i and this concludes the proof.</p><p>A.3 Proofs of the results of Sect. 4.3 <ref type="figure">k,</ref> and<ref type="figure">œÅ</ref> </p><formula xml:id="formula_94">Theorem 3 (soundness) If M is a model of [[Œì ]] k for k ‚â• 0, S i = { f ‚àà F : f i ‚àà M} for i = 0, . . . ,</formula><formula xml:id="formula_95">i = {œÅ ‚àà L : œÅ i ‚àà M}, for i = 0, . . . , k -1 then S 0 œÅ 0 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S k-1 œÅ k-1 S k is an initialised path of Œì .</formula><p>Proof The proof is by induction on k. The base case is easy as [[Œì ]] 0 is logically equivalent to I (f 0 ) and by requirement R1 we know that { f ‚àà F : f 0 ‚àà M} = S 0 ‚àà I. Therefore S 0 is a initialised path of Œì . Let us now consider the step case. Let M be a model of <ref type="figure">8</ref> Proof of the step case of Lemma 2 i = 0, . . . , k -1 and œÅ i is the parallel composition of the rules in {œÅ ‚àà L : œÅ i ‚àà M} for i = 0, . . . , k -2. By part (a) of requirement R2 we know that the parallel composition œÅ k-1 of the rules in {œÅ ‚àà L : œÅ k-1 ‚àà M} is linearisable and that app</p><formula xml:id="formula_96">[[Œì ]] k for k &gt; 0. Since [[Œì ]] k = [[Œì ]] k-1 ‚àß T k-1 (f k-1 , œÅ k-1 , f k ), then M is also a model of [[Œì ]] k-1 and of T k-1 (f k-1 , œÅ k-1 , f k ). By induction hypothesis we know that S 0 œÅ 0 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S k-2 œÅ k-2 S k-1 is an ini- tialised path of Œì , where S i = { f ‚àà F : f i ‚àà M} for Fig.</formula><formula xml:id="formula_97">œÅ k-1 (S k-1 ) = { f ‚àà F : f k ‚àà M} = S k . We can therefore conclude that S 0 œÅ 0 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S k-1 œÅ k-1 S k is an initia- lised path of Œì . Theorem 4 (completeness) If œÄ k = S 0 œÅ 0 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S k-1 œÅ k-1 S k is an initialised path of Œì , then there exists a model M of [[Œì ]] k such that œÄ(M) = œÄ k .</formula><p>Proof The proof is by induction on k. The base case is easy as œÄ 0 = S 0 ‚àà I and from R1 we know that</p><formula xml:id="formula_98">M = { f 0 : f ‚àà S 0 } is a model of I (f 0 ). But [[Œì ]] 0 is logically equivalent to I (f 0 ) and therefore M is a model of [[Œì ]] k for k = 0. Moreover œÄ(M) = { f : f 0 ‚àà M} = S 0 = œÄ 0 is an initialised path of Œì . Let us now consider the step case. Let œÄ k = S 0 œÅ 0 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S k-1 œÅ k-1 S k be an initialised path of Œì where œÅ i ‚àà L is the parallel composition of the lin- earisable rules in Œõ i ‚äÜ L for i = 0, . . . , k -1. Clearly also œÄ k-1 = S 0 œÅ 0 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S k-2 œÅ k-2 S k-1 is an initialised path of Œì . By induction hypothesis there exists a model M of [[Œì ]] k-1 such that œÄ(M ) = S 0 œÅ 0 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S k-2 œÅ k-2 S k-1 is an initialised path of Œì . Since S k-1 is reachable in k -1 steps in Œì , pre(œÅ k-1 ) ‚äÜ S k-1 , and app œÅ k-1 (S k-1 ) = S k , by part (b) of requirement R2 we know that M = { f k-1 : f ‚àà S k-1 } ‚à™ {œÅ k-1 : œÅ ‚àà Œõ k-1 } ‚à™ { f k : f ‚àà S k } is a model of T k-1 (f k-1 , œÅ k-1 , f k ). From this fact we can con- clude that M = M ‚à™ M is a model of [[Œì ]] k = [[Œì ]] k-1 ‚àß T (f k-1 , œÅ k-1 , f k ) and is such that œÄ(M) = S 0 œÅ 0 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S k-2 œÅ k-2 S k-1 œÅ k-1 S k is an initialised path of Œì .</formula><p>A.4 Proofs of the results of Sect. 4.3.1</p><p>We now show that I (f 0 ) enjoys requirement R1 (Lemma 5) and T i (f i , œÅ i , f i+1 ) enjoys part (a) and part (b) of requirement R2 (Lemmas 6 and 7 respectively). From this it readily follows by Theorem 3 that the formulae ( <ref type="formula" target="#formula_43">22</ref>)-( <ref type="formula" target="#formula_53">28</ref>) encode faithfully the behaviours of Œì of length k and hence also the soundness and completeness of the linear encoding (Theorem 5). We recall that we write </p><formula xml:id="formula_99">T (f i , œÅ i , f i+1 ) in place of T i (f i , œÅ i , f i+1 ). Moreover,</formula><formula xml:id="formula_100">(f 0 )) I (f 0 ) is such that if M is a model of I (f 0 ) then { f ‚àà F : f 0 ‚àà M} ‚àà I and, conversely, if S ‚àà I then { f 0 : f ‚àà S} is a model of I (f 0 ).</formula><p>Proof This proof readily follows from the definition of I (f 0 ) given in <ref type="bibr" target="#b21">(22)</ref>.</p><formula xml:id="formula_101">Lemma 6 (soundness of T (f i , œÅ i , f i+1 )) If M is a model of T (f i , œÅ i , f i+1</formula><p>) then the rules in Œõ = {œÅ ‚àà L : œÅ i ‚àà M} are composable and their parallel composition Œõ is linearisable and such that app Œõ (S) = S for S = { f ‚àà F :</p><formula xml:id="formula_102">f i ‚àà M} and S = { f ‚àà F : f i+1 ‚àà M} for i = 0, . . . , k -1. Proof If M is a model of T (f i , œÅ i , f i+1</formula><p>), then M is a model of ( <ref type="formula" target="#formula_45">23</ref>)- <ref type="bibr" target="#b27">(28)</ref>. The truth of ( <ref type="formula" target="#formula_47">24</ref>) and ( <ref type="formula" target="#formula_49">25</ref>) in M implies that the effects of the rules in Œõ = {œÅ ‚àà L :</p><formula xml:id="formula_103">œÅ i ‚àà M} are such that { f i+1 : f ‚àà add(œÅ)} ‚äÇ M, { f i+1 : f ‚àà del(œÅ)} ‚à© M = ‚àÖ</formula><p>, and therefore they do not contradict each other, i.e., œÅ‚ààŒõ add(œÅ) ‚à© œÅ‚ààŒõ del(œÅ) = ‚àÖ. Hence the rules in Œõ are composable and because of (28) they are pairwise noninterfering and thus linearisable. Moreover for any œÅ ‚àà Œõ, the formulae <ref type="bibr" target="#b22">(23)</ref> state that { f i : f ‚àà pre(œÅ)} ‚äÇ M. As a consequence, the union of the preconditions of the rules in Œõ are contained in S = { f ‚àà F : f i ‚àà M} and therefore Œõ is applicable in S.</p><p>To conclude the proof we must thus show that S = { f ‚àà F : f i+1 ‚àà M} is equal to (S\ œÅ‚ààŒõ del(œÅ)) ‚à™ œÅ‚ààŒõ add(œÅ). This boils down to proving that p ‚àà (S\ œÅ‚ààŒõ del(œÅ)) ‚à™ œÅ‚ààŒõ add(œÅ) if, and only if, p i+1 ‚àà M. The proof is articulated in the following two cases: Case 1 (if): Let p ‚àà (S\ œÅ‚ààŒõ del(œÅ))‚à™ œÅ‚ààŒõ add(œÅ), i.e., either p ‚àà S\ œÅ‚ààŒõ del(œÅ) or p ‚àà œÅ‚ààŒõ add(œÅ), we must prove that p i+1 ‚àà M. Case 1.1: Let p ‚àà S\ œÅ‚ààŒõ del(œÅ), i.e., p ‚àà S and p ‚àà del(œÅ) for all œÅ ‚àà Œõ (and thus œÅ i ‚àà M). Therefore every rule œÅ that deletes p is not in Œõ, i.e., œÅi ‚àà M. As a consequence the conclusion of the first explanatory frame axiom <ref type="bibr" target="#b25">(26)</ref> for fact p is false in M. Moreover, since p ‚àà S from the definition of S it follows that p i ‚àà M. From this we conclude that the truth value of (26) in M requires p i+1 ‚àà M. Case 1.2: Let p ‚àà œÅ‚ààŒõ add(œÅ), i.e., there exists a rule œÅ ‚àà Œõ (and thus œÅ i ‚àà M) such that p ‚àà add(œÅ). Because of this, the truth of (œÅ i ‚äÉ p i+1 ), i.e., one of the formulae <ref type="bibr" target="#b23">(24)</ref>, in M implies that p i+1 ‚àà M. Case 2 (only if): Let p i+1 ‚àà M, we must prove that p ‚àà (S\ œÅ‚ààŒõ del(œÅ)) ‚à™ œÅ‚ààŒõ add(œÅ) i.e., either (i) p ‚àà S and p ‚àà œÅ‚ààŒõ del(œÅ), or (ii) p ‚àà œÅ‚ààŒõ add(œÅ). Since p i+1 ‚àà M, then for all œÅ such that p ‚àà del( œÅ) the truth of ( œÅi ‚äÉ ¬¨p i+1 ), i.e., one of the formulae <ref type="bibr" target="#b24">(25)</ref>, in M implies that œÅi ‚àà M. Because of this and from the definition of Œõ, we derive that œÅ ‚àà Œõ and therefore that p ‚àà œÅ‚ààŒõ del(œÅ). To conclude the proof we must show that either p ‚àà S or p ‚àà œÅ‚ààŒõ add(œÅ). This is equivalent to proving that either p i ‚àà M or there exists a rule œÅ such that œÅ i ‚àà M and p ‚àà add(œÅ). To demonstrate this it suffices to observe that, for M to satisfy (¬¨ p i ‚äÉ {œÅ i | œÅ ‚àà L, p ‚àà add(œÅ)})-i.e., the formula constructed through schema ( <ref type="formula" target="#formula_52">27</ref>) and simplified by using the assumption p i+1 ‚àà M-it must hold that either p i ‚àà M or there exists a rule œÅ such that œÅ i ‚àà M and p ‚àà add(œÅ). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 7 (completeness of T (f</head><formula xml:id="formula_104">i , œÅ i , f i+1 )) If S ‚äÜ F is reachable in i steps in Œì ,</formula><formula xml:id="formula_105">(S), then M = { f i : f ‚àà S} ‚à™ { f i+1 : f ‚àà S } ‚à™ {œÅ i 1 , . . . , œÅ i n } is a model of T (f i , œÅ i , f i+1 ) for i = 0, . . . , k -1.</formula><p>Proof Let œÅ and f be a rule and a fact respectively. By definition of M and Œõ, it is immediate to see that (i) œÅ ‚àà Œõ if and only if œÅi ‚àà M, (ii) f ‚àà S if and only if f i ‚àà M, and (iii) f ‚àà S if and only if f i+1 ‚àà M.</p><p>To show that M is model of T (f i , œÅ i , f i+1 ), we must prove that M satisfies ( <ref type="formula" target="#formula_45">23</ref>)- <ref type="bibr" target="#b27">(28)</ref>.</p><p>The formulae ( <ref type="formula" target="#formula_45">23</ref>), <ref type="bibr" target="#b23">(24)</ref>, and ( <ref type="formula" target="#formula_49">25</ref>) are true in M if and only if for every rule œÅ ‚àà L if œÅi ‚àà M (i.e., œÅ ‚àà Œõ), then (a) any fact f ‚àà pre( œÅ) is such that f i ‚àà M (i.e., f ‚àà S), (b) any fact f ‚àà add( œÅ) is such that f i+1 ‚àà M (i.e., f ‚àà S ), and (c) any fact f ‚àà del( œÅ) is such that f i+1 / ‚àà M (i.e., f / ‚àà S ). This is trivially satisfied in by any rule œÅ that is not in Œõ. Let us consider the case in which œÅ ‚àà Œõ. By hypothesis the parallel composition Œõ is applicable in S (i.e., pre( Œõ) = œÅ‚ààŒõ pre(œÅ) ‚äÜ S), and the application of Œõ leads to S = (S\ œÅ‚ààŒõ del(œÅ)) ‚à™ œÅ‚ààŒõ add(œÅ). Since œÅ ‚àà Œõ, we have that pre( œÅ) ‚äÜ pre( Œõ) ‚äÜ S and thus (a) is proved. Similarly add( œÅ) ‚äÜ S and therefore also (b) is demonstrated. Finally, to prove (c) it suffices to show that del( œÅ) ‚à© S = ‚àÖ, i.e., both del( œÅ) ‚à© (S\ œÅ‚ààŒõ del(œÅ)) = ‚àÖ and del( œÅ) ‚à© œÅ‚ààŒõ add(œÅ) = ‚àÖ. The former simply derives from the fact that œÅ ‚àà Œõ and thus del( œÅ) ‚äÜ œÅ‚ààŒõ del(œÅ). By definition of parallel composition œÅ‚ààŒõ del(œÅ) ‚à© œÅ‚ààŒõ add(œÅ) = ‚àÖ and since del( œÅ) ‚äÜ œÅ‚ààŒõ del(œÅ) it follows immediately also the latter.</p><p>Formula ( <ref type="formula" target="#formula_50">26</ref>) is true in M if and only if for every fact f ‚àà F if f i ‚àà M (i.e., f ‚àà S) and f i+1 / ‚àà M (i.e., f / ‚àà S ), then at least one of the rules, say œÅ, that deletes f must be such that œÅi ‚àà M (i.e., œÅ ‚àà Œõ). It follows immediately that M | (26) holds for every fact f such that either f / ‚àà S or f ‚àà S . Let us consider the case f ‚àà S and f / ‚àà S . By hypothesis S = (S\ œÅ‚ààŒõ del(œÅ)) ‚à™ œÅ‚ààŒõ add(œÅ) and then, by applying the steps of Fig. <ref type="figure" target="#fig_10">9</ref>, we conclude that for every fluent f such that f ‚àà S and f / ‚àà S , we have that f ‚àà œÅ‚ààŒõ del(œÅ), i.e., there exists at least one rule œÅ ‚àà Œõ such that f ‚àà del( œÅ), and thus <ref type="bibr" target="#b25">(26)</ref> is true in M.</p><p>The proof of M | (27) proceeds in a dual way.</p><p>To conclude the overall proof we must demonstrate that M | (28). This means to show that for all pair of rules œÅ 1 , œÅ 2 ‚àà L such that œÅ 1 ‚äï œÅ 2 either œÅ i 1 / ‚àà M (i.e., œÅ 1 / ‚àà Œõ) or œÅ i 2 / ‚àà M (i.e., œÅ 2 / ‚àà Œõ). This is a simple consequence of the fact that the rules in Œõ are linearisable, i.e., they are pairwise non-interfering. Proof This proof readily follows from the definition of I (f 0 ) given in <ref type="bibr" target="#b36">(37)</ref>.</p><p>Lemma 9 (soundness of T i (f i , œÅ i , f i+1 )) If M is a model of T i (f i , œÅ i , f i+1 ) then the rules in Œõ = {œÅ ‚àà L : œÅ i ‚àà M} are composable and their parallel composition Œõ is linearisable and such that app Œõ (S) = S for S = { f ‚àà F : f i ‚àà M} and S = { f ‚àà F : f i+1 ‚àà M} for i = 0, . . . , k -1.</p><p>Proof It must be noted that the formula T i (f i , œÅ i , f i+1 ) is defined over a subset of the atoms in T L (f i , œÅ i , f i+1 ) and namely over those propositions occurring in { p i : p ‚àà N i f }‚à™ { p i : p ‚àà N i œÅ } ‚à™ { p i+1 : p ‚àà N i+1 f }. As a consequence Œõ, S, and S , that by hypothesis are defined in terms of the model M, are such that Œõ ‚äÜ N i œÅ , S ‚äÜ N i f , and S ‚äÜ N i+1 f . Therefore for any rule œÅ ‚àà Œõ we have that pre(œÅ), add(œÅ), and del(œÅ) can be used interchangeably with { f : œÅ --‚Üí   the proof goes along the lines of Lemma 6 in which ( <ref type="formula" target="#formula_45">23</ref>)-( <ref type="formula" target="#formula_49">25</ref>), <ref type="bibr" target="#b25">(26)</ref>, and (28) are replaced by ( <ref type="formula">38</ref>)-( <ref type="formula" target="#formula_82">40</ref>), <ref type="bibr" target="#b40">(41)</ref>, and ( <ref type="formula" target="#formula_87">44</ref>) respectively. The only significant difference concerns "case 2" of Lemma 6 that we describe entirely here.</p><p>Case 2 (only if): Let p i+1 ‚àà M, we must prove that p ‚àà (S\ œÅ‚ààŒõ del(œÅ)) ‚à™ œÅ‚ààŒõ add(œÅ) i.e., either both p ‚àà S and p ‚àà œÅ‚ààŒõ del(œÅ), or p ‚àà œÅ‚ààŒõ add(œÅ). Since p i+1 ‚àà M, then for all œÅ such that p ‚àà del( œÅ) the truth of ( œÅi ‚äÉ ¬¨p i+1 ), i.e., the formula constructed through axiom <ref type="bibr" target="#b39">(40)</ref>, in M requires œÅi ‚àà M. Because of this and from the definition of Œõ, we derive that œÅ ‚àà Œõ and therefore that p ‚àà œÅ‚ààŒõ del(œÅ). To conclude the proof we must show that either p ‚àà S or p ‚àà œÅ‚ààŒõ add(œÅ), that is equivalent to prove that either p i ‚àà M or there exists a rule œÅ such that œÅ i ‚àà M and p ‚àà add(œÅ). To prove this we must notice that p i+1 ‚àà M if and only if p ‚àà S = { f ‚àà F : f i+1 ‚àà M} ‚äÜ N i+1 f . Moreover by definition of planning graph we know that N i f ‚äÜ N i+1 f and therefore N i+1 f = N i f ‚à™ N i+1 f \N i f . We thus consider the following two cases. Case 2.1: Let p ‚àà N i f , the truth of the formula constructed through axiom <ref type="bibr" target="#b41">(42)</ref> and simplified by using the assumption p i+1 ‚àà M implies that either p i ‚àà M or there exists a rule œÅ such that œÅ i ‚àà M and p ‚àà add(œÅ). Case 2.2: Let p ‚àà N i+1 f \N i f . This implies trivially that p / ‚àà S (since by definition S ‚äÜ N i f ) and thus we must prove that there exists an rule œÅ such that œÅ i ‚àà M and p ‚àà add(œÅ). This is simply derived from the truth value of the formula constructed through axiom <ref type="bibr" target="#b42">(43)</ref> and simplified by using the assumption p i+1 ‚àà M.</p><p>Lemma 10 (completeness of T i (f i , œÅ i , f i+1 )) If S ‚äÜ F is reachable in i steps in Œì , the rules in Œõ = {œÅ 1 , . . . , œÅ n } ‚äÜ L are linearisable and their parallel composition Œõ is applicable in S, and S = app Œõ (S), then M = { f i : f ‚àà S} ‚à™ { f i+1 : f ‚àà S } ‚à™ {œÅ i 1 , . . . , œÅ i n } is a model of T i (f i , œÅ i , f i+1 ) for i = 0, . . . , k -1.</p><p>Proof The proof goes along the lines of Lemma 7. The differences are minor but many and therefore we prefer to present the overall proof here.</p><p>Let œÅ and f be a rule and a fact respectively. First of all notice that by definition of planning graph the reachability of S in i steps implies that S ‚äÜ N i f . Similarly the reachability of S in one step from S by applying the rules in Œõ implies that S ‚äÜ N i+1 f , Œõ ‚äÜ N i œÅ , and that for each œÅ ‚àà N i œÅ pre(œÅ), add(œÅ), and del(œÅ) can be used interchangeably with { f : œÅ --‚Üí To show that M is model of T (f i , œÅ i , f i+1 ), we must prove that M satisfies ( <ref type="formula">38</ref>)- <ref type="bibr" target="#b43">(44)</ref>.</p><p>The formulae <ref type="bibr" target="#b37">(38)</ref>, <ref type="bibr" target="#b38">(39)</ref>, and <ref type="bibr" target="#b39">(40)</ref> are true in M if and only if for every rule œÅ ‚àà N i œÅ if œÅi ‚àà M (i.e., œÅ ‚àà Œõ), then (a) any fact f ‚àà pre( œÅ) is such that f i ‚àà M (i.e., f ‚àà S), (b) any fact f ‚àà add( œÅ) is such that f i+1 ‚àà M (i.e., f ‚àà S ), and (c) any fact f ‚àà del( œÅ) is such that f i+1 / ‚àà M (i.e., f / ‚àà S ). This is trivially satisfied in M by any rule œÅ that is in N i œÅ but not in Œõ. Let us now consider the case in which œÅ ‚àà Œõ. By hypothesis the parallel composition Œõ is applicable in S (i.e., pre( Œõ) = œÅ‚ààŒõ pre(œÅ) ‚äÜ S), and the application of Œõ leads to S = (S\ œÅ‚ààŒõ del(œÅ)) ‚à™ œÅ‚ààŒõ add(œÅ). Since œÅ ‚àà Œõ, we have that pre( œÅ) ‚äÜ pre( Œõ) ‚äÜ S and thus (a) is proved. Similarly add( œÅ) ‚äÜ S and therefore also (b) is demonstrated. Finally, to prove (c) it suffices to show that del( œÅ) ‚à© S = ‚àÖ, i.e., both del( œÅ) ‚à© (S\ œÅ‚ààŒõ del(œÅ)) = ‚àÖ and del( œÅ) ‚à© œÅ‚ààŒõ add(œÅ) = ‚àÖ. The former simply derives from the fact that œÅ ‚àà Œõ and thus del( œÅ) ‚äÜ œÅ‚ààŒõ del(œÅ). By definition of parallel composition œÅ‚ààŒõ del(œÅ) ‚à© œÅ‚ààŒõ add(œÅ) = ‚àÖ and since del( œÅ) ‚äÜ œÅ‚ààŒõ del(œÅ) it follows immediately also the latter.</p><p>The formula <ref type="bibr" target="#b40">(41)</ref> is true in M if and only if for every fact f ‚àà N i f if f i ‚àà M (i.e., f ‚àà S) and f i+1 / ‚àà M (i.e., f / ‚àà S ), then at least one of the rules, say œÅ, that deletes f must be such that œÅi ‚àà M (i.e., œÅ ‚àà Œõ). It follows immediately that M | (41) holds for every fact f ‚àà N i f such that either f / ‚àà S or f ‚àà S . Let us consider the case f ‚àà N i f such that both f ‚àà S and f / ‚àà S . By hypothesis S = (S\ œÅ‚ààŒõ del(œÅ))‚à™ œÅ‚ààŒõ add(œÅ) and then , by applying the steps of Fig. <ref type="figure" target="#fig_11">10</ref>, we conclude that for every fluent f ‚àà N i f such that f ‚àà S and f / ‚àà S , we have that f ‚àà œÅ‚ààŒõ del(œÅ), i.e., there exists at least one rule œÅ ‚àà Œõ such that f ‚àà del( œÅ), and thus <ref type="bibr" target="#b40">(41)</ref> is true in M.</p><p>To prove M | (27) it suffices to proceed as above but dually.</p><p>The formula <ref type="bibr" target="#b42">(43)</ref> is true in M if and only if for every fact f ‚àà N i+1 f \N i f if f i+1 ‚àà M (i.e., f ‚àà S ), then at least one of the rules, say œÅ, that adds f must be such that œÅi ‚àà M (i.e., œÅ ‚àà Œõ). By definition of S and since S ‚äÜ N i f it follows that for all fact f ‚àà N i+1 f \N i f , f ‚àà S if and only if f ‚àà œÅ‚ààŒõ add(œÅ). Hence M | (43) holds for all f ‚àà N i+1 f \N i f such that f ‚àà S . In the other case, i.e., f ‚àà N i+1 f \N i f such that f / ‚àà S , again M | (43) trivially holds since the antecedent of the implication is false.</p><p>To conclude the overall proof we are left with proving that M | <ref type="bibr" target="#b43">(44)</ref>. Mutexes are divided into two disjoint classes, static mutexes over rules (denoted with ‚äï and constructed by considering only part (a) of PG4) and dynamic mutexes. As pointed out in <ref type="bibr" target="#b28">[29]</ref> dynamic mutexes are implied by static mutexes in the overall encoding and therefore if we prove that for all pair of rules œÅ 1 , œÅ 2 ‚àà N i œÅ such that œÅ 1 ‚äï i œÅ 2 M | ¬¨(œÅ i 1 ‚àßœÅ i 2 ) holds, then also M | (44) is proved. This amount showing that for all pair of rules œÅ 1 , œÅ 2 ‚àà N i œÅ such that œÅ 1 ‚äï i œÅ 2 either œÅ i 1 / ‚àà M (i.e., œÅ 1 / ‚àà Œõ) or œÅ i 2 / ‚àà M (i.e., œÅ 2 / ‚àà Œõ). This is a simple consequence of the facts that static mutexes are constructed by considering only part (a) of PG4 and that the rules in Œõ are applicable and linearisable, i.e., their effects do not contradict each other and they are pairwise non-interfering. Proof We recall that the planning graph built at step i represents an over-approximation, in terms of reachable states and applicable rules, of the forward search tree of depth i. Notice that in the general case the unsatisfiability of [[Œû ]] i does not allows to conclude that there is no attack on Œû . In fact, a solution can require multiple executions of the same rule at different steps as well as the sequential execution of rules that are in mutual exclusion. Thus, it could be that i steps are not enough to execute the attack. However, if Œû is a BNAS problem in which the intruder has no rules for composing messages and ([Œì ]) i has levelled-off, then the unsatisfiability of [[Œû ]] i guarantees that there is no attack on Œû . To prove this it suffices to show that if ([Œì ]) i has levelled-off then there cannot be multiple executions of the same rule nor sequential execution of rules that are in mutex.</p><p>-Let us first consider the multiple executions of the same rule. For the rules of the honest agents this is prevented by the ordering on the state facts. For the decomposition rules it is immediate to see that once one of them has been applied it is useless to repeat that rule since it would just cause stuttering. -Let us now consider the sequential execution of rules that are in mutual exclusion. For rules of the honest agents to be conflicting they must have the same state fact in the left-hand side. (Notice that the rewrite rules of the intruder cannot possibly generate conflicts.) But then there cannot be a path in which the two conflicting rules can be both executed. In fact once one of the two rules has been applied the state fact is deleted and it will never occur again in the state.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2</head><label>2</label><figDesc>Fig. 2 Message sequence chart of Lowe's Attack on the NSPK protocol</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 5</head><label>5</label><figDesc>Fig. 5 Rewrite rules for specialised composition</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>r 1 -</head><label>1</label><figDesc>‚Üí b c and b r 2 -‚Üí a c corresponds to the rule a b r 1 r 2 ---‚Üí a b c whose behaviour cannot be reproduced by the sequential application of r 1 and r 2 in any order.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>e., a propositional variable for each fact and rule to denote their truth-value at step i. Moreover the Universal Axioms lead to (| pre(œÅ)| + | add(œÅ)| + | del(œÅ)|) binary clauses for each rule œÅ ‚àà L. As a consequence, the number of clauses in T (f i , œÅ i , f i+1 ) associated with the Universal Axioms is in O(P 0 |L|) where P 0 = max œÅ‚ààL ({| pre(œÅ)|, | add(œÅ)|}) is the maximal number of facts mentioned in one side of a rule, usually a small number, e.g., P 0 = 4 for our NSPK protocol insecurity problem. (Notice that since del(œÅ) = pre(œÅ)\ add(œÅ) we have that | del(œÅ)| ‚â§ | pre(œÅ)| for all œÅ ‚àà L.) The number of clauses in T (f i , œÅ i , f i+1 ) associated with the Explanatory Frame Axioms is in O(|F|) as two clauses are generated for each fact.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 6</head><label>6</label><figDesc>Fig. 6 Forward search tree</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Example 5</head><label>5</label><figDesc>With reference to the multi-set rewriting system Œì presented in Example 4 and the associated planning graph of Fig.7, it is immediate to see that MBR(([Œì ]) 3 , 1) = {x, y, z, x y, x z, y z, x y z}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Lemma 5 (</head><label>5</label><figDesc>since Œû is ground we assume that B = G, ‚àÖ (with G ground) and define [[B]] k = G k where G k is obtained from G by replacing every fact p with p k . soundness and completeness of I</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Theorem 5 ( 2 Lemma 8 (</head><label>528</label><figDesc>soundness and completeness of the linear encoding) If M is a model of [[Œû ]] k for k ‚â• 0, then S 0 œÅ 0 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S k-1 œÅ k-1 S k is a (partial-order) solution of Œû , where S i = { f ‚àà F : f i ‚àà M} for i = 0, . . . , k and œÅ i is the parallel composition of the rules in {œÅ ‚àà L : œÅ i ‚àà M} for i = 0, . . . , k -1. Conversely, if œÄ k = S 0 œÅ 0 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S k-1 œÅ k-1 S k is a (partial-order) solution of Œû , then there exists a model M of [[Œû ]] k such that œÄ(M) = œÄ k .Proof Soundness readily follows from Lemmas 5, 6, and Theorem 3. Similarly, completeness follows from Lemmas 5, 7, and Theorem 4.A.5 Proofs of the results of Sect. 4.3.soundness and completeness ofI (f 0 )) I (f 0 ) is such that if M is a model of I (f 0 ) then { f ‚àà F : f 0 ‚àà M} ‚àà I and, conversely, if S ‚àà I then { f 0 : f ‚àà S} is a model of I (f 0 ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>œÅ --‚Üí add i f }, and { f : œÅ -‚Üí del i f } respectively. Given this</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 9</head><label>9</label><figDesc>Fig. 9 Proof related to Lemma 7</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 10</head><label>10</label><figDesc>Fig. 10 Proof related to Lemma 10</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>pre i f }, { f : œÅ --‚Üí add i f },and { f : œÅ -‚Üí del i f } respectively. Because of this and by definition of M and Œõ, it is immediate to see that (i) œÅ ‚àà Œõ if and only if œÅi ‚àà M, (ii) f ‚àà S if and only if f i ‚àà M, and (iii) f ‚àà S if and only if f i+1 ‚àà M.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Theorem 6 ( 5 Theorem 7</head><label>657</label><figDesc>soundness and completeness of the graphplanbased encoding) If M is a model of [[Œû ]] k for k ‚â• 0, then S 0 œÅ 0 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S k-1 œÅ k-1 S k is a (partial-order) solution of Œû , where S i = { f ‚àà F : f i ‚àà M} for i = 0, . .. , k and œÅ i is the parallel composition of the rules in {œÅ ‚ààL : œÅ i ‚àà M} for i = 0, . . . , k-1. Conversely, if œÄ k = S 0 œÅ 0 S 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ S k-1 œÅ k-1 S k is a (partial-order) solution of Œû , then there exists a model M of [[Œû ]] k such that œÄ(M) = œÄ k .Proof Soundness readily follows from Lemmas 8, 9 and Theorem 3. Similarly, completeness follows from Lemmas 8, 10, and Theorem 4.A.6 Proofs of the results of Sect. Let Œû = Œì, B be a BNAS problem obtained by specialising the composition rules of the intruder as described in Sect.<ref type="bibr" target="#b2">3</ref>.5. When ([Œì ]) i has levelled-off, if [[Œû ]] i is unsatisfiable, then there is no attack on Œû .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Alice starts the protocol by sending Bob her own identity and a nonce N a encrypted with Bob's public key. (A nonce is a number used only once, i.e., a number chosen in an unpredictable way from a large set of candidates. This assumption ensures that it is extremely difficult for an intruder to guess the nonces generated by honest agents during a run of the protocol.) In this way Alice is guaranteed that only Bob can access the content of the sent message and to N b in particular. Bob replies by sending a new nonce N b and the nonce N a received by Alice encrypted by Alice's public key. Again, this ensures that only Alice can access the content of this message. Upon receipt of this message Alice can conclude that this message has been generated and sent by Bob (since nobody else can possibly have generated a message contain-</figDesc><table /><note><p>ing N a) and that Bob agrees with her on the values of N a and N b. Alice then concludes her participation in the protocol by sending the nonce N b encrypted by Bob's public key. Upon receipt of this message Bob concludes that this message has been generated and sent by Alice (since nobody else can possibly have generated a message containing N b) and that Alice agrees with him on the values of N a and N b.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1</head><label>1</label><figDesc>Facts and their informal meaning Agent r accepts the value m of the data item o as originated from s for the purpose of authentication with him in session c</figDesc><table><row><cell>Fact</cell><cell>Meaning</cell></row><row><cell>ik(m)</cell><cell>The intruder knows message m</cell></row></table><note><p>msg( j, s, r, m) Principal s has supposedly sent message m to principal r at protocol step j state( j, s, r, [m 1 , . . . , m h ], c) Principal r is ready to execute step j of session c of the protocol, knows the messages m 1 , . . . , m h , and-if j = 0-a message from s to r is awaited for the step to be executed secret(m, [s 1 , . . . , s h ]) Message m is a secret shared among the group of agents s 1 , . . . , s h witness(s, r, o, m) Value m of the data item o has been generated by agent s for the purpose of authentication with agent r wrequest(r, s, o, m) Agent r accepts the value m of the data item o as originated from s for the purpose of authentication with him request(r, s, o, m, c)</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table</head><label></label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>is bad, in symbols S | B, if and only if there exists a substitution œÉ such that S | GœÉ and</head><label></label><figDesc>1 t 2 and t 1 t 2 respectively where t 1 , t 2 ‚àà T s ( -, V ) for some sort s. A solution of C is a ground substitution œÉ , in symbols œÉ | c C, if and only if t 1 œÉ = t 2 œÉ for all t 1 t 2 ‚àà C and t 1 œÉ = t 2 œÉ for all t 1 t 2 ‚àà C. œÉ | c C, where | is the entailment relation in propositional logic. A solution to</figDesc><table><row><cell cols="2">A reachability problem of signature S, ‚â§,</cell><cell>over V is</cell></row><row><cell cols="3">a pair Œû = Œì, B where Œì is a multi-set rewriting system</cell></row><row><cell>of signature S, ‚â§,</cell><cell>over V and B is a goal.</cell></row><row><cell>A state S</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>. If the protocol is intended to ensure the secrecy of a message m among a set of principals P = {p 1 , . . . , p k }, then we extend either the initial state (if m is present from the outset) or the right hand side of the rewrite rule whose application introduces m with the fact secret(m, [ p 1 , . . . , p k ]) and we set G = secret(m, [ p 1 , . . . , p k ]) ‚àß</figDesc><table><row><cell>ik(m) and C = {p i : p ‚àà P}. Intuitively, the fact</cell></row><row><cell>secret(m, [ p 1 , . . . , p k ]) expresses that m is to be kept</cell></row><row><cell>confidential among the principals in P and thus any state</cell></row><row><cell>in which the intruder knows m is a bad state. In our</cell></row><row><cell>NSPK example to indicate that the nonces must be kept</cell></row><row><cell>secret between initiator and responder, we can add the fact</cell></row><row><cell>terms secret(Na, [A, B]) and secret(Nb, [A, B]) to</cell></row><row><cell>the right hand sides of the rewrite rules (4) and (5) respec-</cell></row><row><cell>tively.</cell></row><row><cell>Authentication. A form of authentication, that we call weak</cell></row><row><cell>authentication, is defined in [50] (under the name of non-</cell></row><row><cell>injective agreement) as follows: an initiator p 1 weakly</cell></row><row><cell>authenticates a responder p 2 on a data item d if, whenever</cell></row><row><cell>p 1 (acting as initiator) completes a run of the protocol,</cell></row><row><cell>apparently with p 2 (acting as responder), then (i) p 2 has</cell></row><row><cell>previously been running the protocol apparently with p 1</cell></row><row><cell>and (ii) the two agents agreed on the values v of d.</cell></row><row><cell>In order to check for this property we need to carry</cell></row><row><cell>out a few, minor modifications to the rewrite rules for</cell></row><row><cell>the honest agents (cf. Fig. 3). As a first step we add</cell></row><row><cell>a fact term of the form witness( p 2 , p 1 , d, v) to the</cell></row><row><cell>right hand side of the rewrite rules that generate data</cell></row><row><cell>values for the purpose of the authentication. Intuitively</cell></row><row><cell>a fact of the form witness( p 2 , p 1 , d, v) means that</cell></row><row><cell>value v of the data item d has been generated by agent</cell></row><row><cell>p 2 for the purpose of authentication with agent p 1 . In</cell></row><row><cell>our example this extension amounts to adding fact terms</cell></row><row><cell>witness(A, B, na, Na) and witness(B, A, nb, Nb)</cell></row><row><cell>to the right hand sides of the rewrite rules (4) and (5)</cell></row><row><cell>respectively. As a second step we add a fact term of the</cell></row><row><cell>form wrequest( p 1 , p 2 , d, v) to the right hand side of</cell></row><row><cell>the rewrite rules modelling the step of the protocol in</cell></row><row><cell>which p 1 accepts the value v of the data item d as orig-</cell></row><row><cell>inated from p 2 for the purpose of authentication with</cell></row><row><cell>p 1 . In our example this extension amounts to adding</cell></row><row><cell>fact terms wrequest(A, B, nb, Nb) and wrequest</cell></row><row><cell>(B, A, na, Na) to the right hand sides of the rewrite rules</cell></row><row><cell>(6) and (7) respectively. Thus, any state in which</cell></row><row><cell>wrequest( p 1 , p 2 , d, v) holds and the corresponding</cell></row><row><cell>witness fact (i.e., witness( p 2 , p 1 , d, v)) does not hold</cell></row><row><cell>represents a violation of the authentication property and</cell></row><row><cell>we concisely represent this set of bad states with the</cell></row></table><note><p><p><p>formula G = wrequest( p 1 , p 2 , d, v) ‚àß ¬¨ witness ( p 2 , p 1 ,</p>d, v</p>) and by the set constraints C = {p 2 i}.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>4.3 Reducing bounded quantifier-free protocol insecurity problems to SAT Given a ground protocol insecurity problem Œû = Œì, B of signature , S and an integer k &gt; 0, we now consider the problem of building a propositional formula [[Œû ]] k such that every model of [[Œû ]] k corresponds to a (linearisable) partialorder solution of Œû of length k and vice versa. The starting point is to add a time-index to the rules and facts to indicate the state at which the rules apply or the facts hold. Facts are thus indexed by 0 through k and rules by 0 through k -1. If p is a fact or a rule and i is an index, then p i is the corresponding time-indexed propositional variable. If p = p 1 , . . . , p n is a tuple of facts or rules and i is an index, then p</figDesc><table /><note><p>i = p i 1 , . . . , p i n is the corresponding time-indexed tuple of propositional variables. To simplify notation from here on we will abbreviate T Fact ( ) and T Rule ( ) with F and L respectively. Moreover, if Œì = I, R , then Œì = I, R where R is obtained from R by adding all the compound rules œÅ 1 ‚Ä¢ ‚Ä¢ ‚Ä¢ œÅ n for all pairwise non-interfering set of rules {œÅ 1 , . . . , œÅ n</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>as log 2 |L| is dominated by |L|, while the number of clauses is in O(|F| + |L| log 2 |L| ) as each axiom of the form (35) leads to log 2 |L| + 1 clauses</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>then no bad state represented by B can be reached in k steps. However if there exists a goal state S ‚àà MBR(([Œì ]) k , k) ‚à© {B : B | B}, we cannot conclude that S is truly reachable. The problem of establishing if a state S included in the over-approximation of the forward search tree at time step k</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head></head><label></label><figDesc>). The optimising transformations turn Œû into a new problem Œû with a number of rewrite rules that in the worst case is exponential in n, i.e., Œû is in O(2 n ). -Quantifier elimination (line 4). It is easy to see that quantifier elimination does not have any impact on the overall complexity of the procedure. -Generation of the encodings (line 6). We recall from Sect. 4.3 that the number of atoms and the number of clauses in [[Œû ]]</figDesc><table /><note><p><p><p><p>i are in O(|F| + |L|) and O(|F| + |L| 2 )</p>respectively. We know from</p><ref type="bibr" target="#b60">[61]</ref> </p>that we can safely restrict the instantiation of variables with ground terms of size ‚â§ n. We observe that the number of terms of size ‚â§ n is in O(n n+1 ). (In fact each term can be regarded as a tree with n nodes together with a mapping from the nodes to the function symbols of . Since the number of function symbols is ‚â§ n, it is easy to conclude that the number of terms of size n is in O(n n+1 ). By summing the number of terms of size ‚â§ n we obtain O(n n+1 ).) Since the number of variables occurring in a term is in O(n), the size of F and L are thus in O(n n+2 ) and O(2 n * n n+2 ) respectively. As a consequence the number of atoms and clauses of [[Œû ]] i are in O(i * n n+2 ) and O(i * 2 2n * n 2(n+2) ) and thus in O(i * 2 (n+2) log 2 n ) and O(i * 2 2n+2(n+2) log 2 n ) respectively.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head>Table 2</head><label>2</label><figDesc>Experimental data on protocols from the Clark/Jacob library</figDesc><table><row><cell>mo means that a memory out has</cell></row><row><cell>been reached</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>Table 3</head><label>3</label><figDesc>Experiments on the AVISPA library</figDesc><table><row><cell>Protocol</cell><cell cols="2">#Pb #Att</cell><cell>CL</cell><cell>OF</cell><cell>SATMC</cell></row><row><cell>UMTS-AKA</cell><cell>4</cell><cell>0</cell><cell>0.01</cell><cell>0.03</cell><cell>0.01</cell></row><row><cell>ISO1</cell><cell>1</cell><cell>1</cell><cell>0.02</cell><cell>0.02</cell><cell>0.04</cell></row><row><cell>ISO2</cell><cell>1</cell><cell>0</cell><cell>0.02</cell><cell>0.07</cell><cell>0.63</cell></row><row><cell>ISO3</cell><cell>2</cell><cell>2</cell><cell>0.03</cell><cell>0.03</cell><cell>0.39</cell></row><row><cell>ISO4</cell><cell>2</cell><cell>0</cell><cell>0.03</cell><cell>0.38</cell><cell>208.31</cell></row><row><cell>ChapV2</cell><cell>4</cell><cell>0</cell><cell>0.02</cell><cell>0.18</cell><cell>0.10</cell></row><row><cell>EKE</cell><cell>4</cell><cell>2</cell><cell>0.03</cell><cell>0.10</cell><cell>0.09</cell></row><row><cell>TLS</cell><cell>4</cell><cell>0</cell><cell>0.05</cell><cell cols="2">0.29 1018.28</cell></row><row><cell>LPD-MSR</cell><cell>2</cell><cell>2</cell><cell>0.02</cell><cell>0.02</cell><cell>0.06</cell></row><row><cell>LPD-IMSR</cell><cell>2</cell><cell>0</cell><cell>0.04</cell><cell>0.04</cell><cell>0.10</cell></row><row><cell>Kerb-basic</cell><cell>10</cell><cell>0</cell><cell>0.07</cell><cell>0.61</cell><cell>6.24</cell></row><row><cell>Kerb-Cross-Realm</cell><cell>18</cell><cell>0</cell><cell>0.52</cell><cell>2.22</cell><cell>5.70</cell></row><row><cell>Kerb-Ticket-Cache</cell><cell>11</cell><cell>0</cell><cell>0.08</cell><cell>0.60</cell><cell>28.90</cell></row><row><cell>Kerb-PKINIT</cell><cell>12</cell><cell>0</cell><cell>0.06</cell><cell>0.47</cell><cell>27.21</cell></row><row><cell>Kerb-Forwardable</cell><cell>12</cell><cell>0</cell><cell>0.16</cell><cell>7.12</cell><cell>to</cell></row><row><cell>Kerb-PreAuth</cell><cell>12</cell><cell>0</cell><cell>0.12</cell><cell>0.39</cell><cell>20.54</cell></row><row><cell>CRAM-MD5</cell><cell>2</cell><cell>0</cell><cell>0.04</cell><cell>0.23</cell><cell>0.17</cell></row><row><cell>PBK</cell><cell>1</cell><cell>1</cell><cell>0.01</cell><cell>0.34</cell><cell>0.25</cell></row><row><cell>PBK-fix</cell><cell>1</cell><cell>1</cell><cell>0.03</cell><cell>0.14</cell><cell>0.09</cell></row><row><cell>PBK-fix-weak-auth</cell><cell>1</cell><cell>0</cell><cell>0.49</cell><cell>3.47</cell><cell>0.33</cell></row><row><cell>DHCP-delayed-auth</cell><cell>2</cell><cell>0</cell><cell>0.02</cell><cell>0.06</cell><cell>0.12</cell></row><row><cell>TSIG</cell><cell>2</cell><cell>0</cell><cell>0.05</cell><cell>0.19</cell><cell>0.38</cell></row><row><cell>ASW</cell><cell>3</cell><cell>0</cell><cell>0.10</cell><cell>0.35</cell><cell>to</cell></row><row><cell>ASW-abort</cell><cell>4</cell><cell>1</cell><cell>0.20</cell><cell>1.98</cell><cell>65.75</cell></row><row><cell>FairZG</cell><cell>5</cell><cell>0</cell><cell>0.37</cell><cell>8.76</cell><cell>0.28</cell></row><row><cell>SET-purchase</cell><cell>4</cell><cell>2</cell><cell>23.66</cell><cell>1.24</cell><cell>to</cell></row><row><cell cols="2">SET-p.-hon.-payment-gw 4</cell><cell>0</cell><cell>0.61</cell><cell>0.83</cell><cell>to</cell></row><row><cell>AAAMobileIP</cell><cell>9</cell><cell>0</cell><cell>0.03</cell><cell>0.14</cell><cell>0.11</cell></row><row><cell>Simple</cell><cell>3</cell><cell>0</cell><cell>100.17</cell><cell>78.50</cell><cell>0.50</cell></row><row><cell>CTP-non_predictive-fix</cell><cell>3</cell><cell>0</cell><cell>0.06</cell><cell>0.23</cell><cell>to</cell></row><row><cell>geopriv</cell><cell>5</cell><cell>0</cell><cell>0.04</cell><cell>0.25</cell><cell>0.08</cell></row><row><cell>pervasive</cell><cell>2</cell><cell>0</cell><cell>47.67</cell><cell>30.52</cell><cell>4.00</cell></row><row><cell>two_pseudonyms</cell><cell>5</cell><cell>0</cell><cell>0.06</cell><cell>0.30</cell><cell>0.07</cell></row><row><cell>QoS-NSLP</cell><cell>2</cell><cell>0</cell><cell>32.16</cell><cell>16.01</cell><cell>0.21</cell></row><row><cell>sip</cell><cell>1</cell><cell>0</cell><cell>0.05</cell><cell>1.86</cell><cell>810.01</cell></row><row><cell cols="4">n : n new attacks has been found, to: time-out</cell><cell></cell><cell></cell></row><row><cell cols="6">Simple, Pervasive, and QoS-NSLP) SATMC significantly</cell></row><row><cell cols="2">outperforms the other tools.</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head>Table 4</head><label>4</label><figDesc>Experiments on the NSPK-KS with increasing number of sessions of sessions, yes: an attack has been found, no: the protocol is safe under the analysed scenario, mo: memory-out, to: time-out</figDesc><table><row><cell>Protocol</cell><cell cols="3">#S Attack CL</cell><cell>OF</cell><cell>SATMC</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>(EncT/SolT)</cell></row><row><cell>NSPK-KS</cell><cell>2</cell><cell>yes</cell><cell>0.06</cell><cell>3.56</cell><cell>2.05/0.03</cell></row><row><cell></cell><cell>3</cell><cell>yes</cell><cell>185.90</cell><cell cols="2">1,038.40 3.89/0.04</cell></row><row><cell></cell><cell>4</cell><cell>yes</cell><cell>to</cell><cell>to</cell><cell>6.54/0.03</cell></row><row><cell></cell><cell>5</cell><cell>yes</cell><cell>to</cell><cell>to</cell><cell>8.55/0.04</cell></row><row><cell></cell><cell>6</cell><cell>yes</cell><cell>mo</cell><cell>to</cell><cell>12.95/0.05</cell></row><row><cell cols="2">NSPK-KS-fix 2</cell><cell>no</cell><cell cols="2">2,616.40 10.74</cell><cell>2.07/0.02</cell></row><row><cell></cell><cell>3</cell><cell>no</cell><cell>to</cell><cell cols="2">1,035.29 4.66/0.03</cell></row><row><cell></cell><cell>4</cell><cell>no</cell><cell>to</cell><cell>to</cell><cell>7.19/0.06</cell></row><row><cell></cell><cell>5</cell><cell>no</cell><cell>to</cell><cell>to</cell><cell>10.72/0.07</cell></row><row><cell></cell><cell>6</cell><cell>no</cell><cell>mo</cell><cell>to</cell><cell>14.69/0.06</cell></row><row><cell>#S: number</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13"><head></head><label></label><figDesc>the rules in Œõ = {œÅ 1 , . . . , œÅ n } ‚äÜ L are linearisable and their parallel composition Œõ is applicable in S, and S = app Œõ</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>It is worth pointings out that OFMC and CL-AtSe can also deal with some properties of cryptographic operators such as, e.g., exponentiation.</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Authors Biography</head><note type="other">Alessandro</note></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Secrecy by typing in security protocols</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="749" to="786" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Some doubly exponential sequences. Fibonacci Q</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">J A</forename><surname>Sloane</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1973">1973</date>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="429" to="437" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Verifying security protocols as planning in logic programming</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Aiello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Massacci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Logic</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="542" to="580" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Reconstruction of attacks against cryptographic protocols</title>
		<author>
			<persName><forename type="first">X</forename><surname>Allamigeon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Blanchet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">18th IEEE Computer Security Foundations Workshop (CSFW-18 2005)</title>
		<meeting><address><addrLine>Aixen-Provence, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-06">June 2005. 2005</date>
			<biblScope unit="page" from="140" to="154" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The AVI-SPA tool for the automated validation of internet security protocols and applications</title>
		<author>
			<persName><forename type="first">A</forename><surname>Armando</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Basin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Boichut</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chevalier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Compagna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cuellar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">H</forename><surname>Drielsma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Heam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Kouchnarenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mantovani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Moedersheim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Von Oheimb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rusinowitch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Santiago</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Turuani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Vigan√≤</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Vigneron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th International Conference on Computer-Aided Verification (CAV&apos;05</title>
		<meeting>the 17th International Conference on Computer-Aided Verification (CAV&apos;05</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The AVISS security protocol analysis tool</title>
		<author>
			<persName><forename type="first">A</forename><surname>Armando</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Basin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bouallagui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chevalier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Compagna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>M√∂dersheim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rusinowitch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Turuani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Vigan√≤</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Vigneron</surname></persName>
		</author>
		<ptr target="www.avispa-project.org" />
	</analytic>
	<monogr>
		<title level="m">URL of the AVISS and AVISPA projects</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2404</biblScope>
			<biblScope unit="page" from="349" to="354" />
		</imprint>
	</monogr>
	<note>Proceedings of CAV&apos;02</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Automatic SAT-compilation of protocol insecurity problems via reduction to planning</title>
		<author>
			<persName><forename type="first">A</forename><surname>Armando</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Compagna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of FORTE 2002</title>
		<meeting>FORTE 2002</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2529</biblScope>
			<biblScope unit="page" from="210" to="225" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Abstraction-driven SAT-based analysis of security protocols</title>
		<author>
			<persName><forename type="first">A</forename><surname>Armando</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Compagna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theory and Applications of Satisfiability Testing</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Giunchiglia</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Tacchella</surname></persName>
		</editor>
		<meeting><address><addrLine>org</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">2919</biblScope>
			<biblScope unit="page" from="257" to="271" />
		</imprint>
	</monogr>
	<note>Selected Revised Papers. Presented to SAT 2003, S. Margherita Ligure, Italy. Available at www.avispa-project</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">SATMC: a SAT-based model checker for security protocols</title>
		<author>
			<persName><forename type="first">A</forename><surname>Armando</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Compagna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th European Conference on Logics in Artificial Intelligence (JELIA 2004)</title>
		<meeting>the 9th European Conference on Logics in Artificial Intelligence (JELIA 2004)<address><addrLine>Lisbon</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3229</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">SAT-based modelchecking of security protocols using planning graph analysis</title>
		<author>
			<persName><forename type="first">A</forename><surname>Armando</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Compagna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ganty</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of FME&apos;2003</title>
		<meeting>FME&apos;2003</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2805</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Automatic compilation of protocol insecurity problems into logic programming</title>
		<author>
			<persName><forename type="first">A</forename><surname>Armando</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Compagna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lierler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th European Conference on Logics in Artificial Intelligence (JELIA 2004)</title>
		<meeting>the 9th European Conference on Logics in Artificial Intelligence (JELIA 2004)<address><addrLine>Lisbon</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3229</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">An on-the-fly modelchecker for security protocol analysis</title>
		<author>
			<persName><forename type="first">D</forename><surname>Basin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>M√∂dersheim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Vigan√≤</surname></persName>
		</author>
		<ptr target="http://www.avispa-project.org" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of ESORICS&apos;03</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Snekkenes</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Gollmann</surname></persName>
		</editor>
		<meeting>ESORICS&apos;03</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2808</biblScope>
			<biblScope unit="page" from="253" to="270" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Constraint differentiation: a new reduction technique for constraint-based analysis of security protocols</title>
		<author>
			<persName><forename type="first">D</forename><surname>Basin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>M√∂dersheim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Vigan√≤</surname></persName>
		</author>
		<ptr target="http://www.avispa-project.org" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of CCS&apos;03</title>
		<editor>
			<persName><forename type="first">V</forename><surname>Atluri</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Liu</surname></persName>
		</editor>
		<meeting>CCS&apos;03</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="335" to="344" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">OFMC: a symbolic modelchecker for security protocols</title>
		<author>
			<persName><forename type="first">D</forename><surname>Basin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>M√∂dersheim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Vigan√≤</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Information Security</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
	<note>in press</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Symbolic model checking without BDDs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Biere</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cimatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of TACAS&apos;99</title>
		<editor>
			<persName><forename type="first">W</forename><forename type="middle">R</forename><surname>Cleaveland</surname></persName>
		</editor>
		<meeting>TACAS&apos;99</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1579</biblScope>
			<biblScope unit="page" from="193" to="207" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Verification of cryptographic protocols: Tagging enforces termination</title>
		<author>
			<persName><forename type="first">P</forename><surname>Blanchet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">333</biblScope>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note>in press</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">An efficient cryptographic protocol verifier based on prolog rules</title>
		<author>
			<persName><forename type="first">B</forename><surname>Blanchet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CSFW&apos;01</title>
		<meeting>CSFW&apos;01</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="82" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Automatic verification of cryptographic protocols: a logic programming approach</title>
		<author>
			<persName><forename type="first">B</forename><surname>Blanchet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of PPDP&apos;03</title>
		<meeting>PPDP&apos;03</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="1" to="3" />
		</imprint>
	</monogr>
	<note>invited talk</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Automatic proof of strong secrecy for security protocols</title>
		<author>
			<persName><forename type="first">B</forename><surname>Blanchet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Symposium on Security and Privacy</title>
		<meeting>IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="86" to="100" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Fast planning through planning graph analysis</title>
		<author>
			<persName><forename type="first">A</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Furst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th International Joint Conference on Artificial Intelligence (IJCAI 95)</title>
		<meeting>the 14th International Joint Conference on Artificial Intelligence (IJCAI 95)</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page">95</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Control flow analysis can find new flaws too</title>
		<author>
			<persName><forename type="first">C</forename><surname>Bodei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Buchholtz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Degano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Nielson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">R</forename><surname>Nielson</surname></persName>
		</author>
		<ptr target="http://www2.imm.dtu.dk/pubdb/p.php?3058" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of Workshop on Issues in the Theory of Security</title>
		<meeting>Workshop on Issues in the Theory of Security</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
	<note>WITS 04</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Automatic validation of protocol narration</title>
		<author>
			<persName><forename type="first">C</forename><surname>Bodei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Buchholtz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Degano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Nielson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Riis Nielson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CSFW&apos;03</title>
		<meeting>CSFW&apos;03</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="126" to="140" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Compositional analysis of authentication protocols</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bugliesi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Focardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Maffei</surname></persName>
		</author>
		<ptr target="http://springerlink.metapress.com/openurl.asp?genre=article\&amp;amp" />
	</analytic>
	<monogr>
		<title level="m">ESOP</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Schmidt</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">2986</biblScope>
			<biblScope unit="page" from="302" to="9743" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">A meta-notation for protocol analysis</title>
		<author>
			<persName><forename type="first">I</forename><surname>Cervesato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">A</forename><surname>Durgin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lincoln</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Scedrov</surname></persName>
		</author>
		<ptr target="citeseer.nj.nec.com/cervesato99metanotation.html" />
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>CSFW</publisher>
			<biblScope unit="page" from="55" to="69" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A high level protocol specification language for industrial security-sensitive protocols</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Chevalier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Compagna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cuellar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hankes Drieslma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mantovani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>M√∂dersheim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Vigneron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SAPS&apos;2004</title>
		<meeting>SAPS&apos;2004</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Automated unbounded verification of security protocols</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Chevalier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Vigneron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CAV&apos;02</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Brinksma</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
		</editor>
		<meeting>CAV&apos;02</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2404</biblScope>
			<biblScope unit="page" from="324" to="337" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">A survey of authentication protocol literature: Version 1.0, 17</title>
		<author>
			<persName><forename type="first">J</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jacob</surname></persName>
		</author>
		<ptr target="www.cs.york.ac.uk/~jac/papers/drareview.ps.gz" />
		<imprint>
			<date type="published" when="1997-11">Nov. 1997. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Partial order reductions for security protocol verification</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">R</forename><surname>Marrero</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TACAS</title>
		<imprint>
			<biblScope unit="page" from="503" to="518" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">SAT-based model-checking of security protocols</title>
		<author>
			<persName><forename type="first">L</forename><surname>Compagna</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
		<respStmt>
			<orgName>Universit√† degli Studi di Genova and the University of Edinburgh</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. thesis</note>
	<note>joint programme</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">An improved constraint-based system for the verification of security protocols</title>
		<author>
			<persName><forename type="first">R</forename><surname>Corin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Etalle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SAS 2002</title>
		<meeting>SAS 2002</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2477</biblScope>
			<biblScope unit="page" from="326" to="341" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">On the security of public-key protocols</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dolev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inf. Theory</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">29</biblScope>
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
	<note>in press</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Analyzing a library of security protocols using Casper and FDR</title>
		<author>
			<persName><forename type="first">B</forename><surname>Donovan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Norris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lowe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Formal Methods and Security Protocols</title>
		<meeting>the Workshop on Formal Methods and Security Protocols</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Gorrieri: CVS at work: a report on new failures upon some cryptographic protocols</title>
		<author>
			<persName><forename type="first">F</forename><surname>Durante</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MMMACNS: International Workshop on Methods, Models and Architectures for Network Security</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<author>
			<persName><forename type="first">N</forename><surname>Durgin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lincoln</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Scedrov</surname></persName>
		</author>
		<title level="m">Multiset rewriting and the complexity of bounded security protocols</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Automatic SATcompilation of planning problems</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Ernst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">D</forename><surname>Millstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Weld</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th International Joint Conference on Artificial Intelligence (IJCAI-97)</title>
		<meeting>the 15th International Joint Conference on Artificial Intelligence (IJCAI-97)</meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="1169" to="1177" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">On the security of multi-party ping pong protocols</title>
		<author>
			<persName><forename type="first">S</forename><surname>Even</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 24th IEEE Symposium on Foundations of Computer Science</title>
		<meeting>24th IEEE Symposium on Foundations of Computer Science</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Strand spaces: why a security protocol is correct?</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">J T</forename><surname>F√°brega</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Herzog</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Guttman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1998 IEEE Symposium on Security and Privacy</title>
		<meeting>the 1998 IEEE Symposium on Security and Privacy<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="160" to="171" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Secrecy in security protocols as non interference</title>
		<author>
			<persName><forename type="first">R</forename><surname>Focardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gorrieri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Martinelli</surname></persName>
		</author>
		<ptr target="http://www.elsevier.com/gej-ng/31/29/23/57/23/show/Products/notes/index.htt#007" />
	</analytic>
	<monogr>
		<title level="j">Electr. Notes Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">The PDDL planning domain definition language</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ghallab</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Howe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Knoblock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mcdermott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Veloso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Weld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wilkins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The AIPS-98 Planning Competition Commitee</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Typing correspondence assertions for communication protocols</title>
		<author>
			<persName><forename type="first">J</forename><surname>Gordon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">300</biblScope>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
	<note>in press</note>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Authenticity by typing for security protocols</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jeffrey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Security</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="451" to="520" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Using static analysis to validate the SAML single sign-on protocol</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Skriver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">R</forename><surname>Nielson</surname></persName>
		</author>
		<ptr target="http://www2.imm.dtu.dk/pubdb/p.php?3657" />
	</analytic>
	<monogr>
		<title level="j">WITS</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">How to prevent type flaw attacks on security protocols</title>
		<author>
			<persName><forename type="first">J</forename><surname>Heather</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lowe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th computer Security Foundations Workshop (CSFW&apos;00)</title>
		<meeting>the 13th computer Security Foundations Workshop (CSFW&apos;00)</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<author>
			<persName><surname>Iso/Iec</surname></persName>
		</author>
		<title level="m">ISO/IEC 9798-3: Information technology-Security techniques-Entity authentication-Part 3: Mechanisms using digital signature techniques</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Encoding plans in propositional logic</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kautz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Mcallester</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Selman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KR&apos;96: Principles of Knowledge Representation and Reasoning</title>
		<editor>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Aiello</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Doyle</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Shapiro</surname></persName>
		</editor>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="374" to="384" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">Planning as satisfiability</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">A</forename><surname>Kautz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Selman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="359" to="363" />
		</imprint>
		<respStmt>
			<orgName>ECAI</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Answer set programming and plan generation</title>
		<author>
			<persName><forename type="first">V</forename><surname>Lifschitz</surname></persName>
		</author>
		<idno type="DOI">10.1016/S0004-3702(02)00186-8</idno>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">138</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="39" to="54" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">ASSAT: computing answer sets of a logic program by SAT solvers</title>
		<author>
			<persName><forename type="first">F</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">157</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="115" to="137" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Breaking and fixing the Needham-Shroeder Public-Key protocol using FDR</title>
		<author>
			<persName><forename type="first">G</forename><surname>Lowe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of TACAS&apos;96</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Margaria</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Steffen</surname></persName>
		</editor>
		<meeting>TACAS&apos;96</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1055</biblScope>
			<biblScope unit="page" from="147" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">A hierarchy of authentication specifications</title>
		<author>
			<persName><forename type="first">G</forename><surname>Lowe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th IEEE Computer Security Foundations Workshop (CSFW&apos;97)</title>
		<meeting>the 10th IEEE Computer Security Foundations Workshop (CSFW&apos;97)</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="31" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Towards a completeness result for model checking of security protocols</title>
		<author>
			<persName><forename type="first">G</forename><surname>Lowe</surname></persName>
		</author>
		<ptr target="citeseer.nj.nec.com/article/lowe98towards.html" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of CSFW&apos;98</title>
		<meeting>CSFW&apos;98</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Model checking for security protocols</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">R</forename><surname>Marrero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DIMACS Workshop on Design and Formal Verication of Security Protocols</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Analysis of security protocols as open systems</title>
		<author>
			<persName><forename type="first">F</forename><surname>Martinelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput Sci</title>
		<imprint>
			<biblScope unit="volume">290</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1057" to="1106" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Constraint solving for bounded-process cryptographic protocol analysis</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">K</forename><surname>Millen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Shmatikov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Conference on Computer and Communications Security CCS&apos;01</title>
		<meeting>the ACM Conference on Computer and Communications Security CCS&apos;01</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="166" to="175" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Automated analysis of cryptographic protocols using murphi</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Stern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Symposium on Security and Privacy</title>
		<meeting>IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="141" to="153" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Chaff: engineering an efficient SAT solver</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W</forename><surname>Moskewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">F</forename><surname>Madigan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Malik</surname></persName>
		</author>
		<ptr target="http://www.ee.princeton.edu/~chaff/DAC2001v56.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 38th Design Automation Conference (DAC&apos;01</title>
		<meeting>the 38th Design Automation Conference (DAC&apos;01</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<monogr>
		<title level="m" type="main">Using encryption for authentication in large networks of computers</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Needham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Schroeder</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1978-06">1978. June 1982</date>
			<publisher>Xerox Palo Alto Research Center</publisher>
			<pubPlace>Palo Alto</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep. CSL-78-4</note>
	<note>Reprinted</note>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Logic programs with stable model semantics as a constraint programming paradigm</title>
		<author>
			<persName><forename type="first">I</forename><surname>Niemel√§</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ann. Math. Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">3-4</biblScope>
			<biblScope unit="page" from="241" to="273" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">The inductive approach to verifying cryptographic protocols</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Paulson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Security</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="85" to="128" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Planning as satisfiability: parallel plans and algorithms for plan search</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rintanen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Heljanko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Niemel√§</surname></persName>
		</author>
		<ptr target="http://www.informatik.uni-freiburg.de/~rintanen" />
	</analytic>
	<monogr>
		<title level="m">Eearlier version: Technical report</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">216</biblScope>
		</imprint>
		<respStmt>
			<orgName>Albert-Ludwigs-Universit√§t Freiburg</orgName>
		</respStmt>
	</monogr>
	<note>Institut fnr Informatik, 2005</note>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Protocol insecurity with finite number of sessions is NP-complete</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rusinowitch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Turuani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th IEEE Computer Security Foundations Workshop</title>
		<meeting>the 14th IEEE Computer Security Foundations Workshop</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Athena: a novel approach to efficient automatic security protocol analysis</title>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Berezin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Security</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="47" to="74" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<monogr>
		<title level="m" type="main">Logic: A Foundation for Computer Science</title>
		<author>
			<persName><forename type="first">V</forename><surname>Sperschneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Antoniou</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Turuani</surname></persName>
		</author>
		<title level="m">S√©curit√© des Protocoles Cryptographiques: D√©cidabilit√© et Complexit√©</title>
		<meeting><address><addrLine>Nancy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
		<respStmt>
			<orgName>Universit√© Henri Poincar√©</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. thesis</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
