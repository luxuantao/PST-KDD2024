<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">a foundation model for components and their composition</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2004-11-05">5 November 2004</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Farhad</forename><surname>Arbab</surname></persName>
							<email>farhad@cwi.nl.</email>
							<affiliation key="aff0">
								<orgName type="department">Centre for Mathematics and Computer Science (CWI)</orgName>
								<address>
									<addrLine>Kruislaan 413</addrLine>
									<postCode>1098 SJ</postCode>
									<settlement>Amsterdam</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">a foundation model for components and their composition</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2004-11-05">5 November 2004</date>
						</imprint>
					</monogr>
					<idno type="MD5">C85445D8CEE1ECAC70ADB82760FCC26E</idno>
					<idno type="DOI">10.1016/j.scico.2004.05.010</idno>
					<note type="submission">Received 31 August 2003; received in revised form 15 April 2004; accepted 30 May 2004</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T10:21+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>68Q85</term>
					<term>68Q70</term>
					<term>81P05</term>
					<term>68N99</term>
					<term>68Q65</term>
					<term>18C50</term>
					<term>68Q10</term>
					<term>68Q65 Coordination</term>
					<term>Components</term>
					<term>Composition</term>
					<term>Abstract Behavior Types</term>
					<term>Reo</term>
					<term>Coalgebraic semantics</term>
					<term>Streams</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The notion of Abstract Data Type (ADT) has served as a foundation model for structured and object oriented programming for some thirty years. The current trend in software engineering toward component based systems requires a foundation model as well. The most basic inherent property of an ADT, i.e., that it provides a set of operations, subverts some highly desirable properties in emerging formal models for components that are based on the object oriented paradigm.</p><p>We introduce the notion of Abstract Behavior Type (ABT) as a higher-level alternative to ADT and propose it as a proper foundation model for both components and their composition. An ABT defines an abstract behavior as a relation among a set of timed-data-streams, without specifying any detail about the operations that may be used to implement such behavior or the data types it may manipulate for its realization. The ABT model supports a much looser coupling than is possible with the ADT's operational interface, and is inherently amenable to exogenous coordination. We propose that both of these are highly desirable, if not essential, properties for models of components and their composition.</p><p>To demonstrate the utility of the ABT model, we describe Reo: an exogenous coordination language for compositional construction of component connectors based on a calculus of channels. We show the expressive power of Reo, and the applicability of ABT, through a number of examples.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>An Abstract Data Type (ADT) defines an algebra of operations with mathematically well-defined semantics, without specifying any detail about the implementation of those operations or the data structures they operate on to realize them. As such, ADT is a powerful abstraction and encapsulation mechanism that groups data together with their related operations into logically coherent and loosely-dependent entities, such as objects, yielding better structured programs. ADT has served as a foundation model for structured and object oriented programming for some thirty years.</p><p>The immense success of object oriented techniques has distracted proper attention away from critical evaluation of some of its underpinning concepts from the perspective of their utility for components. We propose that the most basic inherent property of an ADT, i.e., that it provides a set of operations in its interface, subverts some highly desirable properties in emerging models for component based systems. This is already evident in the current attempts at extending the object oriented models into the realm of components (see, e.g., <ref type="bibr">Sections 3 and 5)</ref>.</p><p>We introduce the notion of Abstract Behavior Type (ABT) as a higher-level alternative to ADT and propose it as a proper foundation model for both components and their composition. The ABT model is not meant as a substitute for ADT. Instead, it is meant as a foundation for programming with components as opposed to programming of components which is what the ADT model and object oriented programming have proved to be suitable and effective for. An ABT defines an abstract behavior as a relation among a set of timeddata-streams, without specifying any detail about the operations that may be used to implement such behavior or the data types it may manipulate for its realization. In contrast with the algebraic underpinnings of the ADT model, the (generally) infinite streams that are the elements of behavior in the ABT model naturally lend themselves to the coalgebraic techniques and the coinduction reasoning principle that have recently been developed as a general theory to describe the behavior of dynamic systems. The ABT model supports a much looser coupling than is possible with ADT and is inherently amenable to exogenous coordination. We propose that both of these are highly desirable, if not essential, properties for components and their composition.</p><p>In our view, a component based system consists of component instances and their connectors (i.e., the "glue code"), both of which are uniformly modeled as ABTs. Indeed, the only distinction between a component and a connector is just that a component is an atomic ABT whose internal structure is unknown, whereas a connector is known to be an ABT that is itself composed out of other ABTs. As a concrete instance of the application of the ABT model, we describe Reo: an exogenous coordination model wherein complex coordinators, called "connectors" are compositionally built out of simpler ones <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4]</ref>. Reo can be used as a glue language for compositional construction of connectors that orchestrate component instances in a component based system. We demonstrate the surprisingly expressive power of ABT composition in Reo through a number of examples.</p><p>The rest of this paper is organized as follows. In Section 2 we motivate our view of components and their composition as a conceptual model at a higher level of abstraction than objects and their composition. Section 3 contains a brief overview of some related work. We review the formal notion of abstract data types in Section 4, and elaborate on its links with and implications on object oriented programming in Section 5. We argue that some of these implications impede the ability of component models based on the object oriented paradigm to support flexible composition and exogenous coordination, both of which, we propose, are highly desirable properties in component based systems. Section 6 is an informal description of our component model, and in Section 7 we describe its accompanying model of behavior. Section 8 is an introduction to Abstract Behavior Types and their composition. In Section 9 we show how channels, connectors, and their composition in Reo are easily expressed as ABTs and their composition. Finally, we close with our concluding remarks in Section 10.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">A component manifesto</head><p>The abundance of the various (primarily informal) definitions of what a component is makes it difficult to assess the effectiveness of different models for componentbased software development. Some differences are often purely technological. Others are more fundamental and sometimes render a side-by-side comparison of model features uninformative, if not meaningless. In this section we present a pre-formal analysis of the concepts and ideas behind the cornucopia of contemporary component models to identify the commonalities of motivations that can in turn be seen as essential requirements of a component model.</p><p>The bulk of the work on component based systems is primarily focused on what components are and how they are to be constructed. Relatively little attention has been paid to alternative models and languages for composing components into (sub)systems, which is typically considered to be the purpose of the so-called glue code, assumed to be written in some scripting language. Clearly, components and their composition are not independent of one another: explicitly emphasizing one defines or at least constrains the other as well, if only implicitly.</p><p>A conspicuous driving force behind the upsurge of interest and activity in component based software is the recognition that the object oriented paradigm is not the silver-bullet that some of its over-zealous advocates purported it to be. Nevertheless, presently, the dominant view of what components are or should be reflects a prominent object oriented legacy: components are fortified collections of classes and/or objects, with very similar interfaces. It follows that the interactions among and the composition of components must use mechanisms very similar to those for interactions among and composition of classes and objects. Thus, the method invocation semantics of message passing in object oriented programming becomes the crux of the component composition mechanisms in scripting languages.</p><p>This approach to components "solves" some of the problems that are rooted in the inadequacies of the object oriented paradigm simply by shifting them elsewhere. For instance, the relatively tight coupling that must be established between a caller and a callee pair of objects indeed disappears as a concern at the intra-component level when the two objects reside in different component instances, but becomes an issue to be addressed in the glue code and its underlying middleware used to compose those components. As long as components and their interfaces are essentially the same as objects and their interfaces, the (scripting) programs that constitute the glue code end up to be inherently no different than other object oriented software. In complex systems, the body of such specialized glue code can itself grow in size, complexity, intricacy, fragility, and rigidity, rendering the system hard to evolve and maintain, in spite of the fact that this inflexible code wraps and connects otherwise reusable, upgradeable, and replaceable components.</p><p>An alternative view of components emerges if we momentarily ignore how they are made or even what they are made of, emphasizing instead what we want to do with them. Beyond fashionable jargon, hype, and merely technical idiosyncrasies, if there is to be any conceptual substance behind the term "component" deserving its minting, it must be that components are less interdependent and are easier and more flexible to compose than objects and classes. The definition of a class or an object specifies the methods it offers to other entities, and the method calls within the code of its methods determine the services and entities it requires to work. This results in a rather tight semantic interdependence among objects/classes and grants each individual a significant degree of control over precisely how it is composed with other classes or objects.</p><p>In contrast to objects and classes, it is highly desirable for components to be semantically independent of one another and internally impose no restrictions on the other components they compose with. This yields a level of composition flexibility that is not possible with objects and classes 1 and which is a prerequisite for another highly desirable property in component based systems: we would like for the whole (system) to be more than the mere sum of its (component) parts. This implies that it should be not only generally possible to produce different systems by composing the same set of components in different ways, but also that the difference between two systems composed out of the same set of components (i.e., the difference between the "more" than the "sum of the parts" in each system) must arise out of the actual rules that comprise their two different compositions, i.e., their glue code. The significance of the latter point is that it requires the glue code to contribute to the semantics of the whole system well beyond the mere so-called "wiring-standard-level" support provided by the current popular middleware and component based technologies. On the other hand, we intuitively expect glue code to be void of any application-domain specific functionality: its job is merely to connect components, facilitating their communication and coordinating their interactions, not to perform any application-domain specific computation.</p><p>This leads to a subtlety regarding the interaction between glue code and components which fundamentally impacts both. If the contribution of the glue code to the behavior 1 Observe that generally speaking, it is the code for the methods of an object that determines the other objects it "composes with" to function properly. Thus, objects/classes "decide for themselves" how they compose with each other and their composition generally cannot be determined or influenced from outside. of a composed system is no more than connecting its components, facilitating their communication and coordinating their interactions, then the difference between the behavior of two systems composed out of the same set of components can arise not out of any application-domain specific computation (and certainly not out of the components), but only out of how the glue code connects and coordinates these components to interact with one another. Since glue code is external to the components it connects, this implies that (1) the components must be amenable to external coordination control and (2) the glue code must contain constructs to provide such external coordination. The first implication constrains the mechanisms through which components can interact with their environment. The second implication means that the glue code language must incorporate an exogenous coordination model <ref type="bibr" target="#b1">[2]</ref>.</p><p>Finally, if glue code is to have its own non-trivial semantics in a composed system, it is highly desirable both for the glue code itself to be piece-wise explicitly identifiable, and for the semantics of each of its pieces to be independent of the semantics of the specific components that it composes. This promotes the recognition of the glue code as an identifiable, valuable software commodity, emphasizes the importance of its reusability, and advocates glue code construction through composition of reusable glue code pieces.</p><p>The notion of compositional construction of glue code out of smaller, reusable pieces of glue code all but eliminates the conceptual distinctions between components and glue code. This behooves us to find conceptual models and formal methods for component based systems wherein the same rules for compositional construction indiscriminately apply to both components as well as their glue code connectors. In such a model, the (perhaps somewhat subjective) distinction between components and their (pieces of glue code) connectors still makes practical sense: although they are indistinguishable when used as primitives to compose more complex constructs, components and connectors are still different in that components are black-box primitives whose internal structures are invisible, whereas the internal structure of a connector shows that it, in turn, is constructed out of other (connector and/or component) primitives according to the same rules of composition.</p><p>Although connectors contain coordination constructs that do not exist in purely computational components, the ability to use a composition of connectors and components exactly as a (black-box) component in other compositions is crucial. The fact that such (non-purely-computational) components may include connectors whose coordinating effects can be discernible in the externally observable behavior of the components, blurs an absolute distinction between components and connectors and makes it somewhat subjective. It takes an encapsulation mechanism with the power of full abstraction to allow components and connectors to be used indistinguishably. Examples presented in Section 9.7.2 and throughout Section 9.8 demonstrate the practical usefulness of the interchangeability of components and connectors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Background and related work</head><p>In popular models of components (e.g., Enterprise Java Beans <ref type="bibr" target="#b46">[47,</ref><ref type="bibr" target="#b23">24]</ref>, CORBA <ref type="bibr" target="#b69">[70,</ref><ref type="bibr" target="#b19">20]</ref>, and DCOM <ref type="bibr" target="#b26">[27]</ref>) component instances are fortified (collections of) objects. Consequently, they typically use variants of message passing with the semantics of method invocation for inter-component communication. The tight coupling inherent in the method call semantics is more appropriate for intra-component communication. In contrast, intercomponent communication invariably requires a minimum level of "control from the outside" of the participating components. In order to break the tight coupling induced by the method call semantics and reduce the interdependence of components on each other, the underlying middleware that supports these component models provides mechanisms or entities (such as the ORB in CORBA) to intercept inter-component messages. Messages may be intercepted to, for instance, provide services (e.g., binding and name servers), enforce imposed constraints (e.g., suppress certain messages in certain states), ensure protocols, and/or enact assigned roles. One way or the other, the middleware's intervention loosens the otherwise tight coupling that would be imposed by targeted active messages (i.e., messages with method-invocation semantics) and furthermore, enforces a certain restricted form of coordination from outside the components.</p><p>Intercepting and manipulating messages before they perform the methods that their sender objects intend to invoke is also at the core of one of the most effective contemporary approaches to Aspect Oriented Programming. The so-called Composition Filters superimpose declarative rules for intercepting, filtering, re-routing, and changing the message traffic among objects to support certain inter-and intra-class cross-cutting concerns <ref type="bibr" target="#b12">[13]</ref>. Composition Filters are most effective for imposing cross-cutting concerns that can be related to individual message contents. Protocol-related concerns that involve coordination of flows of groups of messages, e.g., synchronization at transaction boundaries, are more difficult, if not impossible, to enforce through Composition Filters. Nevertheless, this and similar approaches to Aspect Oriented Programming underline the wider recognition of the inadequacy of the rigid semantic tie between messages and method invocation even in the world of object oriented programming. They clearly show the advantage of a paradigm based on a more abstract notion of messages as passive data over the active messages of object oriented programming whose immediate consequences are strictly to invoke the designated methods of their target objects.</p><p>Coordination languages <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b57">58]</ref> offer an alternative for inter-component communication, as exemplified by JavaSpaces in the Jini architecture <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b55">56,</ref><ref type="bibr" target="#b44">45]</ref>. They impose a stricter sense of temporal and spatial decoupling that supports a looser inter-component semantic dependency, compared with the method invocation semantics of message passing in object oriented paradigms.</p><p>Most common component models define components as reusable binary units of software with interfaces that have no more than a syntactic content. This view of components enforces information hiding in only a rather primitive way: the good practice discipline of using questionably suggestive symbolic names in component interfaces nonwithstanding, such an interface does not reveal any of the externally relevant semantics of the contents of its component. Such component models cannot support (semi-)formal specification/verification of their external behavior.</p><p>A broader definition of components is offered by the Eiffel language <ref type="bibr" target="#b48">[49,</ref><ref type="bibr" target="#b49">50,</ref><ref type="bibr" target="#b25">26]</ref>: components are client-oriented software with the desirable property that a component, x, can be used by other programs that do not need to be known to x. This property is supported in Eiffel through formal specification techniques which include pre-and post-conditions and invariants. In general, this notion of components requires enhanced specification and verification techniques, as also observed by Hennicker and Wirsing <ref type="bibr" target="#b72">[73,</ref><ref type="bibr" target="#b29">30]</ref>.</p><p>Our notion of components <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b21">22]</ref> uses channels as the basic inter-component communication mechanism. A channel is a point-to-point medium of communication with its own unique identity and two distinct ends. A channel supports transfer of passive data only; no transfer of control (e.g., procedure calls, exchange of pointers to internal objects/entities) can take place through a channel. Using channels as the only means of inter-component communication allows a clean, flexible, and expressive model for construction of the glue code for component composition which also supports exogenous coordination.</p><p>Synchronous channels are the basic primitives in π-calculus <ref type="bibr" target="#b50">[51,</ref><ref type="bibr" target="#b51">52]</ref>. Some of the variants of π-calculus and its asynchronous versions <ref type="bibr" target="#b68">[69]</ref> have been used in models proposed for component interaction and composition. Notably, Piccola <ref type="bibr" target="#b54">[55]</ref> is an experimental component composition language based on a higher-order version of the asynchronous π-calculus, extended with explicit name-spaces called forms. Forms in Piccola provide a unified mechanism to address such aspects of component composition as styles, scripts, and glue code. The agents and channels provided by Piccola's underlying calculus support the coordination aspect of component composition.</p><p>In contrast to such calculi, our notion of channel is very general and we specifically allow a variety of different channel types (even user-defined ones) to be used simultaneously and composed together. This differentiates our model from the way channels are used in virtually all other channel-based models, which typically allow only one or at most a small number of simple predefined channel types. Specifically, our liberal notion of channels, the potency that our model derives from mixing and composing channels of different types, and their consequent harmonious combination of synchrony and asynchrony are unique. For instance, these features of our model are in sharp contrast with the use of channels in the Ptolemy project <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b39">40,</ref><ref type="bibr" target="#b40">41]</ref> which ascribes a single interpretation for its connecting channels in each context.</p><p>Asynchronous channels form the basis of the dataflow architecture for networks of components as proposed and formally investigated by Broy and his group <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b30">31]</ref>. In this architectural model, large systems can be realized, allowing programmers to easily understand the input/output behavior of a system as the composition of the behavior of its individual components. They also use data streams containing temporal markers for component composition. Our model of component composition is fundamentally different than (even dynamic) dataflow models because it (1) supports a much wider and more general notion of channels and different channel types; and (2) introduces the notion of channel composition as the construct through which channels of arbitrary types are connected to other channels, forming higher level and more sophisticated connectors for component composition. Unlike Broy's streams, the twin pairs of timed-data streams (see Section 8.1) that we use to model and compose component behavior cleanly separate the flows of time and data, yielding simple, succinct expressions for combining both synchronous and asynchronous behavior, which together with our relational (in contrast to Broy's functional) composition, empower exogenous coordination.</p><p>Inspired by both ADTs and imperative programming, a common approach to model externally observable behavior, particularly in object oriented settings, amounts to  characterizing behavior in terms of message sequences, where a message represents an (ADT) operation or a method call, as exemplified, e.g., by the notion of behavior used for composition with contracts <ref type="bibr" target="#b28">[29]</ref> and behavioral subtyping <ref type="bibr" target="#b45">[46]</ref>. In contrast, our notion of behavior is more abstract and dataflow-like, where the externally observable behavior of an entity is characterized in terms of its input/output sequences of passive data. The fact that passive data can be interpreted as messages that invoke methods or operations means that our notion of behavior is at least as expressive as those based on operation sequences. Our model is more abstract because our sequences contain only atomic, uninterpreted, untargeted data that can interchangeably be sent to and received from any source or target. Method invocation sequences, on the other hand, contain typed messages and the structure and type of a message determine the operation it invokes. Each receiver must specify (at least) the set of message types it accepts in its signature. Regardless of how much of the semantics of the operations is reflected in this signature and to what extent it is used in composition, as we argue in Section 5, the operational view of behavior stifles exogenous coordination and composition.</p><formula xml:id="formula_0">O: top(s) → d O : first(q) → d pop(s) → s d e q (q) → q push(s, d) → s e n q (q, d) → q empty(s) → b e m p t y (q) → b A: empty(λ) = true A: empty(λ) = true empty(push(s, d)) = false empty(enq(q, d)) = false top(push(s, d) = d fi r s t (enq(λ, d)) = d pop(push(s, d) = s fi r s t (enq(enq(q, d 1 ), d 2 )) = first(enq(q, d 1 )) pop(λ) = 1 deq(enq(λ, d)) = λ pop( 1 ) = 1 deq(enq(enq(q, d 1 ), d 2 )) = enq(deq(enq(q, d 1 ), d 2 ) top(λ) = 2 deq(λ) = 1 top( 1 ) = 3 deq( 1 ) = 1 empty( 1 ) = 4 first(λ) = 2 first( 1 ) = 3 empty( 1 ) = 4</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Abstract Data Types</head><p>Formally, an ADT is a triplet S, O, A , where S is a set of sorts denoting the required types, O is a set of operators over S, and A is a set of axioms written as algebraic equations defining the results of various combinations of operations in O on data items of various types in S.</p><p>For example, Fig. <ref type="figure" target="#fig_0">1</ref> shows the formal ADT definitions for the two common data types stack and queue, in separate columns. The set S contains stack, data, and boolean types for stack, and queue, data, and boolean types for queue. We use s, q, d, and b to represent items of types stack, queue, data, and boolean, respectively. Furthermore, in the stack column in this figure λ is an item of type stack representing the empty stack, and likewise in the queue column λ is an item of type queue representing the empty queue. Similarly, in each column 1 and 2 are special error values of their respective types.</p><p>The set O in each column defines the signature of four operations. For the case of the stack, top(s) is expected to produce the data item at the top of the stack s; pop(s) is expected to produce the stack obtained by removing the data item at the top of the stack s; push(s, d) is expected to produce a stack obtained by pushing the data item d on top of the stack s; and empty(s) is expected to produce a boolean indicating whether or not the stack s is empty. For the case of the queue, first(q) is expected to produce the first data item at the head of the queue q; deq(q) is expected to produce the queue obtained by removing the first data item at the head of the queue q (dequeue); enq(q, d) is expected to produce a queue obtained by adding the data item d to the tail end of the queue q (enqueue); and empty(q) is expected to produce a boolean indicating whether or not the queue q is empty. Of course, the set O contains only the signatures of these operations and as such it is void of any formal hint of what they (are expected to) do.</p><p>It is the set of axioms, A, that formally defines the semantics of the operations in O in terms of their mutual effects on each other. In the case of the stack, the two axioms for the empty operation state that (1) empty(λ) = true, and (2) empty applied to a stack obtained from a push operation on any stack yields false. The top axioms state that (1) top applied to the empty stack yields an error ( 2 ), and (2) top applied to a stack obtained from pushing the data item d onto some other stack, yields d. The pop axioms state that (1) popping a stack obtained from pushing a data item onto some other stack, s, yields s;</p><p>(2) popping an empty stack yields an error ( 1 ); and (3) popping this error value yields the same error value. Any stack is canonically represented as a sequence of push operations that add data items on the result of their preceding push, starting with the empty stack, e.g., push(push(push(push(λ, d 1 ), d 2 ), d 3 ), d 4 ). An expression that cannot be transformed into such a canonical form, e.g., push(push(pop(pop(push(λ, d 1 ))), d 2 ), d 3 ), is not a legal stack.</p><p>Many of the queue axioms are analogous to their respective stack axioms. The axioms for first and deq are a bit more interesting. Any queue is canonically represented as a sequence of enq operations that add data items on the result of their preceding enq, starting with the empty queue; e.g., enq(enq(enq(enq(λ, d 1 ), d 2 ), d 3 ), d 4 ). The first axioms state that to find the first element in a queue, we must "peel" it away until we reach the empty queue, at which point we obtain the first data item at the head of the queue. Thus:</p><formula xml:id="formula_1">first(enq(enq(enq(enq(λ, d 1 ), d 2 ), d 3 ), d 4 )) = first(enq(enq(enq(λ, d 1 ), d 2 ), d 3 )) = first(enq(enq(λ, d 1 ), d 2 )) = first(enq(λ, d 1 )) = d 1 .</formula><p>Analogously, deq peels away the canonical representation of a queue, but it also reconstructs it as it moves inside. These examples show that an ADT defines a data type in terms of the operations on that data type and how they mutually affect each other by altering the structure of some canonical representation. It abstracts away from the implementation of those operations and the data structures they manipulate. The semantics of an ADT is given as algebraic equations. The strong conceptual link between abstract data types and object oriented programming stems from the common manner in which they associate data and the operations that manipulate them together. The ADT for a type, T, defines all operations applicable to entities of type T. It encapsulates the representation of T and the implementation of its operations. This prevents manipulation of the entities of type T in any way other than through its own defined operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">ADT and object oriented programming</head><p>Their common aspiration to (1) encapsulate data structures behind operations that manipulate them, and (2) hide the details of those operations as well, has made ADT a suitable foundation model for object oriented programming. An ADT can be seen as a formal description of the interface of an object/class. This encapsulation significantly loosens the coupling between the implementation of an ADT (or object/class) and other code that can use it only through its prescribed operations. The operational interface of an ADT (or object/class) also readily supports extensibility in the form of polymorphism. Extensibility in object oriented programming typically goes beyond mere polymorphism, through some form of inheritance that gives rise to object/class hierarchies.</p><p>In contrast to the declarative, state-less nature of ADT definitions, popular object oriented programming languages are imperative and carry the semantics of operations of objects/classes in their states. Exposing their states exposes the object/class semantics they carry, but it breaks their encapsulation. Hiding their states enforces encapsulation, but it also obscures the semantics of operations by making their effects invisible. Exposing the semantics of their operations without exposing object/class states becomes a nontrivial issue in imperative object oriented languages. Although a formal semantics of its operations is an integral part of the definition of an ADT, object/class interfaces in popular object oriented languages are purely syntactic and contain no semantics. Moreover, the explicit definition of the set of all sorts (both provided and required) by an ADT has no correspondence in the object/class interface definitions in main-stream object oriented languages: they do not mention what their respective objects/classes require, but specify only the operations that they provide.</p><p>The differences between the ADT model and imperative object oriented programming give rise to a number of problems that have already been discussed extensively in the literature. Some counter-measures for problems such as the conflict between inheritance and encapsulation <ref type="bibr" target="#b70">[71]</ref>, the purely syntactic nature of interfaces, and their asymmetric specification of offered/required services, have been integrated in the design of certain more advanced models for object oriented languages, systems, and components <ref type="bibr" target="#b48">[49,</ref><ref type="bibr" target="#b49">50,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b38">39,</ref><ref type="bibr" target="#b42">43,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b71">72]</ref>. They introduce annotations and features that incorporate some semantics in the definitions of classes and objects and respect them in their inter-relationships and use. A notion of behavior as sequences of operations underlies these features, e.g., behavioral subtyping <ref type="bibr" target="#b45">[46]</ref> and contracts for object composition <ref type="bibr" target="#b28">[29]</ref>. In their extreme, welcome methods that expose and enforce (more of) the semantics of classes and objects in their interfaces may demystify the semantics of these imperative pieces of software into declarative formulas as succinct and directly susceptible to formal reasoning as ADTs. What has not been explored so explicitly and extensively in the literature is how message passing in the object oriented paradigm, i.e., the operational interface of the ADT model, affects software composition and what alternative mechanisms can be used in its place for components. We argue here that the elegance of the ADT model and the usefulness of the object oriented languages non-withstanding, software construction using components, their composition, and their coordination involve issues that are not only ill-served, but also actually subverted by the operational nature of ADTs and its manifestation as the method invocation semantics of message passing in the object oriented paradigm.</p><p>The method invocation semantics of object oriented message passing implies a rather tight semantic coupling between the caller and callee pairs of objects. By this semantics, if an object c sends a message m(p) to another object e, then c is invoking the method m of e with the actual parameters p. For this to happen:</p><p>• c must know (how to find) e; • c must know the syntax and the semantics of the method m of e;</p><p>• e must (pretend to) perform the activated method m on parameters p, and return its result to c upon its completion (the "pretense" refers to when e delegates the actual execution of m to a third object); and • c typically suspends between its sending of m and the receiving of its (perhaps null) result.</p><p>Not only is this "rendezvous semantics" far from trivial, it is still susceptible to significantly different and mutually incompatible variations (e.g., with synchronous vs. asynchronous message passing, active vs. passive objects, etc.). Underneath the precise semantics of this rendezvous and its various incarnations in different object oriented models, is a strong conceptual link with ADT. By its virtue of providing a set of operations, all that one can do with an ADT is to perform one of its operations. Similarly, the fact that an object provides a set of methods in its interface means that one can do nothing with an object but to invoke those methods. This operational interface (of objects or ADTs) induces an asymmetric, unidirectional semantic dependency of users (of operations) on providers (of those operations). On the one hand, the operations provided by an ADT (or object) can be used by any other entity (that has access to it). On the other hand, an ADT internally decides what operation of what other ADT to perform. This puts users and providers in asymmetric roles. Users internally make the decisions on what operations are to be performed, and generally rely on some specific semantics that they expect of these operations, while it is left to be the responsibility of the providers to carry out the decisions made by the users to satisfy their expectations.</p><p>Far from a universal pitfall, it can even be argued that the presumed level of intimacy required among a set of objects composed together through message passing, is an advantage in building individual components. However, at the inter-component level, such intimacy subverts independence of components, contributes to breaking of their encapsulation, and leads to a level of inter-dependence among components that is no looser than that among objects within a component. This is not so much a shortcoming or deficiency of the ADT model. Rather, it highlights the inappropriateness of using the ADT model for purposes it was not meant to serve in the first place. To achieve the level of independence that is desirable for inter-component communication, we need a different model based on non-operational interfaces to avoid targeted active messages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">A bland notion of components</head><p>In a programming paradigm where (instances of) components are its primitive building blocks, all decisions about what components are to be used and how they are to be composed together to build an application must necessarily be made from outside of the application's constituent components themselves. This implies that generally, a component cannot be allowed to internally decide on the components that it composes and communicates with. This simple observation renders ADT unsuitable as a model for components. If a component, like an ADT, provides a set of operations, then the only way to communicate with a component is by invoking its operations, and inter-component communication becomes the same as inter-object communication. A formal model for components must provide an inter-component communication mechanism that affords a higher level of mutual independence to components than the ADT model does. In this section, we consider an alternative (to the ADT-style method invocation) communication mechanism as the crux of our definition of a component. The notion of component introduced in this section is then further refined and formalized in Section 8 as Abstract Behavior Types.</p><p>Instead of relying on targeted active messages for inter-component communication, our component model allows a component instance to exchange only untargeted, passive messages with its environment. Passive messages contain only data and carry no control information (e.g., imply no method invocation). Not implying the exchange of any control information makes passive messages more abstract and more flexible than active messages. For instance, because no form of "call" is implied, the receiver of a message need not interpret the message as an operation that it must perform. The receiver of a message is not even obligated to reply. Consequently, the sender does not necessarily suspend waiting for a result either. Passive messages allow interception, filtering, redirection, and manipulation of messages to be done, when necessary, all as legitimate operations on data as opposed to active messages which require ad hoc transparent entities outside of or superimposed on a programming model to perform such actions.</p><p>Untargeted messages break the asymmetry between senders and receivers that is inherent in models based on targeted messages. With targeted messages, the knowledge of who the receiver of a message is, or at least how it can be identified, must be contained in its sender. The receiver of a message, on the other hand, is not required to know anything about its sender beforehand: it is prepared to receive messages "from its environment" not from any specific sender. This asymmetry makes the sender of a message semantically dependent on (the properties and the scheme used to identify) its receiver. This inherent semantic dependency creates an obligation for the environment to fulfill on behalf of this intended receiver that stifles exogenous coordination by severely restricting the ability of a third party to, e.g., set up the interaction of such a sender with a receiver of its own choosing instead of the one prescribed by the sender. With untargeted messages, both senders and receivers symmetrically exchange messages only with their environment, not with any prespecified entity.</p><p>In contrast to the more sophisticated mechanisms necessary for exchanging targeted passive messages, or even more sophisticated ones to support (remote) method invocation for active messages, the mechanism necessary for exchanging untargeted passive messages essentially supports only the mundane I/O primitives: an untargeted message itself is merely some passive data that an entity exchanges with its environment; "sending" such a message is just a write operation; and "receiving" it is just a "read" operation. The I/O operations read and write are performed by a component instance on "contact points" that are recognized by its environment for the purpose of information exchange. We refer to these contact points as the ports of a component instance. Without loss of generality, we assume ports are unidirectional, i.e., the information flows through a port in one direction only: either from the environment into its component instance (through read) or from its component instance to the environment (through write). Each I/O operation inherently synchronizes the entity that performs it with its environment: a write operation suspends until the environment accepts the data it has to offer through its respective port; likewise, a read operation suspends until the environment offers the suitable data it expects through its respective port.</p><p>This view of component communication leads to a generic component model. In this model, a component instance is a black box that contains one or more active entities. An active entity is one that has its own independent thread of control. Examples of active entities are processes, threads, active objects, agents, etc. No assumption is made in this model about how the active entities inside a component instance communicate with each other. However, simple I/O operations on passive data exchanged through its ports are the only means of communication for the active entities inside a component instance with any entity not in the same component instance. By this definition, a Unix process, for instance, qualifies as a component instance: it contains one or more threads of control which may even run in parallel on different physical processors, and its file descriptors qualify as ports. A component instance may itself consist of a collection of other component instances, perhaps running in a distributed environment. Thus, by identifying their relevant ports through which they exchange data with their environment, entire systems can be viewed and used as component instances, abstracting away their internal details of operation, structure, geography, and implementation.</p><p>Such a simple model of components may at first appear rather banal. Nevertheless, it leads to a simple yet useful notion of behavior and behavioral interface. One of the strengths of this model is that it innately espouses anonymous communication: entities that communicate with each other need not know each other. It makes the model inherently amenable to exogenous coordination and supports highly flexible composition possibilities, yielding a very powerful paradigm for component/behavior composition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Elements of a behavioral interface</head><p>There are different ways in which one can represent behavior. Given our model of components, the most direct and obvious way to represent the observable behavior of a component instance is to model it as a relation on its observable input and output. Because this input/output takes place through the ports of the component instance, sequences of data items that pass through a port emerge as the key building blocks for describing behavior.</p><p>Relating sequences of data items that pass through different ports of a component instance requires a sense of relative temporal order to inter-relate otherwise independent events. We need to state, for instance, that a certain data item passes through this port before or after some other data item passes through that port. The assumption of a global clock is stifling in distributed systems and is an overkill for our purpose. Indeed, what we need is a very diluted notion of time that is much less restrictive than the notion of global time. We need to accommodate for:</p><p>• ordering of events: stating that the occurrence of a certain event precedes or succeeds that of another; • atomicity of a set of events: stating that a given set of events occur only atomically;</p><p>• temporal progression: stating that only a finite set of events can occur within any bounded temporal interval.</p><p>Observe that we do not speak of simultaneity in our list of requirements here. Simultaneity is a rather ambiguous notion in distributed systems. Instead, we speak of atomicity. The atomicity of a set of events means that either none of them occurs, or else they all occur before any other event (not in that set) occurs, i.e., the occurrence of an atomic set of events cannot be interleaved with the occurrence of any other event. Stating that a set of events must occur atomically allows but does not require (any subset of) those events to occur simultaneously. It also allows for those events to occur in any nondeterministic order, so long as either they all occur or none occurs at all. Atomicity can be seen as a relaxing generalization of simultaneity. It is as if an atomic set of events all happen "simultaneously", except that we elongate the moment of their occurrence into a temporal interval. The provision that no other event may interleave with the occurrence of those in the set ensures that our "elongation of the time moment into an interval" is not detectable by other entities in the system.</p><p>Requiring that only a finite set of events can occur within any bounded temporal interval precludes anomalies such as Zeno's paradox.</p><p>A partial order over a dense set satisfies the requirements of our diluted notion of time, characterized above. As such, in the terminology of <ref type="bibr" target="#b41">[42]</ref>, we are primarily interested in an untimed model of computation. Imposing the stricter requirement of total order yields a timed version of our model, which is not our concern in this paper. Nevertheless, we use positive real numbers to represent our time streams, because of their familiarity and simplicity, with the proviso that it is not the actual numeric values of the time moments, nor the total order on the real numbers, but only their relative ordering that is significant. The numerical less-than relation represents the ordering of events. The numeric equal-to relation represents atomicity, not simultaneity. Temporal progression can be enforced by requiring that in every temporal sequence a, for any number N ≥ 0 there exists an i ≥ 0 such that the ith element in a exceeds N.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Abstract Behavior Types</head><p>An ABT defines an abstract behavior as a relation among the observable input/output that occurs through a set of "contact points" (e.g., ports of a component instance) without specifying any detail about: (1) the operations that may be used to implement such behavior; or (2) the data types those operations may manipulate for the realization of that behavior. <ref type="foot" target="#foot_0">2</ref> This definition parallels that of an ADT, which abstracts away from the instructions and the data structures that may be used to implement the operational interface it defines for a data type. In contrast, an ABT defines what a behavior is in terms of a relation (i.e., constraint) on the observable input/output of an entity, without saying anything about how it can be realized.</p><p>There are several different ways to formalize the concept of ABT. For instance, process calculi, Petri nets, logic expressions, automata, or labeled transition systems can be used to describe transformations of input to output sequences of observables. Process calculi tend to emphasize processes rather than explicit expression of their input/output behavior. Petri nets are too low level to directly represent the rich set of behavioral relations involving nondeterminism, combination of synchrony and asynchrony, and compositionality that we are interested in. Automata can characterize the relation among the observable input/output sequences of an ABT in an operational style. Indeed, constraint automata <ref type="bibr" target="#b9">[10]</ref> constitute an appropriate formalization of the ABT model, precisely because they were devised to represent the operational semantics of Reo connector circuits for model checking. Constraint automata can be considered generalizations of probabilistic automata, where data constraints, instead of probabilities, label state transitions and influence their firing. Timed-data-streams, which constitute the foundation of the coalgebraic semantics of Reo <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b67">68]</ref>, are also the referents in the language of constraint automata. Constraint automata seem to be more useful than labeled transition systems for modeling of systems composed of both synchronous and asynchronous components, because in practice, their composition tends to yield smaller models <ref type="bibr" target="#b47">[48]</ref>.</p><p>In this paper, we do not further elaborate on labeled transition systems or constraint automata. Instead, we formally define an ABT to be a (maximal) relation among a set of timed-data-streams. We prefer this particular formalization here because it emphasizes the relational aspect of the ABT model explicitly, and abstracts away any hint of an underlying operational semantics of its implementation. This helps to focus on behavior specifications and their composition, rather than on operations that may be used to implement entities that exhibit such behavior and their interactions.</p><p>The notion of timed-data-streams as well as most of the technical content in this section comes from the work of J. Rutten on coalgebras <ref type="bibr" target="#b60">[61,</ref><ref type="bibr" target="#b34">35]</ref>, stream calculus <ref type="bibr" target="#b65">[66]</ref>, and a coalgebraic semantics for Reo <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b67">68]</ref>. Coalgebraic methods have been used for signal flow graphs, dynamical systems, automata and formal languages, modal logic, transition systems, hybrid systems, infinite data types, the control of discrete event systems, formal power series, etc. (see for instance <ref type="bibr" target="#b56">[57,</ref><ref type="bibr" target="#b66">67,</ref><ref type="bibr" target="#b64">65,</ref><ref type="bibr" target="#b52">53,</ref><ref type="bibr" target="#b53">54,</ref><ref type="bibr" target="#b61">[62]</ref><ref type="bibr" target="#b62">[63]</ref><ref type="bibr" target="#b63">[64]</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b31">32]</ref>). Coalgebras have also been used as models for various programming paradigms, notably for objects and classes (see, e.g., <ref type="bibr" target="#b59">[60,</ref><ref type="bibr" target="#b33">34]</ref>, and <ref type="bibr" target="#b32">[33]</ref>). One of the first applications of coalgebras to components appears in <ref type="bibr" target="#b10">[11]</ref>. Analogous to the way in which algebraic methods constitute suitable models for the syntactic structure of systems, from its inception, the coalgebraic approach was implicitly recognized as a promising mathematical foundation for modeling the dynamic behavior of (concurrent) systems. The coalgebraic formulation of the ABT model presented here shows this contrast between structure and behavior in comparison with the algebraic formulation of the ADT model in Section 4.</p><p>Defining observable behavior in terms of input/output implants a dataflow essence within ABTs akin to such dataflow-like networks and calculi as <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b37">38]</ref>, and especially <ref type="bibr" target="#b16">[17]</ref>. The coalgebraic model of ABT presented here differs from all of the above-mentioned work in a number of respects. Most importantly, the ABT model is compositional. Its explicit modeling of ordering/timing of events in terms of separate time streams provides a simple foundation for defining complex synchronization and coordination protocols using a surprisingly expressive small set of primitives. The use of coinduction as the main definition and proof principle to reason about both data and time streams allows simple compositional construction of ABTs representing many different generic coordination schemes involving combinations of various synchronous and asynchronous primitives that are not present (and not even expressible) in any of the aforementioned models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1.">Streams and coinduction</head><p>A stream (over A) is an infinite sequence of elements of some set A. The set of all streams over A is denoted as A ω . Streams in DS = D ω over a set of (uninterpreted) data items D are called data streams and are typically denoted as α, β, γ , etc. Zero-based indices are used to denote the individual elements of a stream, e.g., α(0), α(1), α(2), . . . denote the first, second, third, etc., elements of the stream α. We use the infix "dot" as the stream constructor: x.α denotes a stream whose first element is x and whose second, third, etc. elements are, respectively, the first and its successive elements of the stream α.</p><p>Following the conventions of stream calculus <ref type="bibr" target="#b65">[66]</ref>, the well-known operations of head and tail on streams are called initial value and derivative: the initial value of a stream α (i.e., its head) is α(0), and its (first) derivative (i.e., its tail) is denoted as α . The kth derivative of α is denoted as α (k) and is the stream that results from taking the first derivative of α and repeating this operation on the resulting stream for a total of k times. Relational operators on streams apply pairwise to their respective elements, e.g.,</p><formula xml:id="formula_2">α ≥ β means α(0) ≥ β(0), α(1) ≥ β(1), α(2) ≥ β(2), . . ..</formula><p>Constrained streams in TS = R ω + over positive real numbers representing moments in time are called time streams and are typically denoted as a, b, c, etc. To qualify as a time stream, a stream of real numbers a must be (1) strictly increasing, i.e., the constraint a &lt; a must hold; and (2) progressive, i.e., for every N ≥ 0 there must exist an index n ≥ 0 such that a(n) &gt; N.</p><p>We use positive real numbers instead of natural numbers to represent time because, as observed in the world of temporal logic <ref type="bibr" target="#b11">[12]</ref>, real numbers induce the more abstract sense of dense time instead of the notion of discrete time imposed by natural numbers. Specifically, we sometimes need finitely many steps within any bounded time interval for certain ABT equivalence proofs (see, e.g., <ref type="bibr" target="#b5">[6]</ref>). This is clearly not possible with a discrete model of time. Recall that the actual values of "time moments" are irrelevant in our ABT model; only their relative order is significant and must be preserved. Using dense time allows us to locally break strict numerical equality (i.e., simultaneity) arbitrarily while preserving the atomicity of events.</p><p>A Timed Data Stream is a twin pair of streams α, a in TDS = DS × TS consisting of a data stream α ∈ DS and a time stream a ∈ TS, with the interpretation that for all i ≥ 0, the input/output of data item α(i) occurs at "time moment" a(i). Two timed data streams α, a and β, b are equal if their respective elements are equal, i.e.,</p><formula xml:id="formula_3">α, a = β, b ≡ α = β ∧ a = b.</formula><p>An Abstract Behavior Type (ABT) is a (maximal) relation over timed data streams. Every timed data stream involved in an ABT is tagged either as its input or its output. The input/output tags of the timed data streams involved in an ABT are meaningless in the relation that defines the ABT. However, these tags are crucial in ABT composition described in Section 8.3.</p><p>Generally, we use the prefix notation R(I 1 , I 2 , . . . , I m ; O 1 , O 2 , . . . , O n ) and the separator ";" to designate the ABT defined by the (m+n)-ary relation R over the m ≥ 0 sets of input timed data streams I i , 0 &lt; i ≤ m and the n ≥ 0 sets of output timed data streams O j , 0 &lt; j ≤ n. As usual, m + n is called the arity of R and we refer to m and n individually as the input arity and the output arity of R. In the special case where m = n = 1 it is sometimes convenient to use the infix notation I R O instead of the standard R(I; O). To distinguish the set of timed data streams that appears in a position in the relation that defines an ABT (i.e., a column in the relation) from a specific timed data stream in that set (i.e., which may appear in a row of the relation in that position) we refer to I i and O j as, respectively, the ith input and the jth output portals of the ABT.</p><p>Formally, a component, as defined in Section 6, with m ≥ 0 input and n ≥ 0 output ports is an ABT with m input and n output portals. The set of all possible streams of data items that can pass through each port of the component, together with their respective timing, comprise the set of timed data streams of the ABT's portal that corresponds to that port.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2.">ABT examples</head><p>In this section we show the utility of the ABT model through a number of examples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2.1.">Basic channels</head><p>Following is a list of some useful simple binary abstract behavior types. Each has a single input and a single output portal.</p><p>(1) The behavior of a synchronous channel is captured by the Sync ABT, defined as</p><formula xml:id="formula_4">α, a Sync β, b ≡ α, a = β, b . Because α, a = β, b ≡ α = β ∧ a = b</formula><p>, the Sync ABT represents the behavior of any entity that (1) produces an output data stream identical to its input data stream (α = β), and (2) produces every element in its output at the same time as its respective input element is consumed (a = b). Recall that "at the same time" means only that the two events of consumption and production of each data item by a Sync channel occur atomically.</p><p>(2) The behavior of an asynchronous unbounded FIFO channel is captured by the FIFO ABT, defined as</p><formula xml:id="formula_5">α, a FIFO β, b ≡ α = β ∧ a &lt; b.</formula><p>The FIFO ABT represents the behavior of any entity that (1) produces an output data stream identical to its input data stream (α = β), and (2) produces every element in its output some time after its respective input element is observed (a &lt; b).</p><p>(3) The behavior of an asynchronous channel with the bounded capacity of 1 is captured by the FIFO 1 ABT, defined as</p><formula xml:id="formula_6">α, a FIFO 1 β, b ≡ α = β ∧ a &lt; b &lt; a .</formula><p>The FIFO 1 ABT represents the behavior of any entity that (1) produces an output data stream identical to its input data stream (α = β), and (2) produces every element in its output some time after its respective input element is observed (a &lt; b) but before its next input element is observed (b &lt; a which means b(i) &lt; a(i + 1) for all i ≥ 0). (4) The behavior of an asynchronous channel with the bounded capacity of 1 filled to contain the data item D as its initial value is captured by the FIFO 1 (D) ABT, defined as</p><formula xml:id="formula_7">α, a FIFO 1 (D) β, b ≡ β = D.α ∧ b &lt; a &lt; b .</formula><p>The FIFO 1 (D) ABT represents the behavior of any entity that (1) produces an output data stream β = D.α consisting of the initial data item D followed by the input data stream α of the ABT, and (2) for i ≥ 0 performs its ith input operation some time between its ith and i + 1st output operations (b &lt; a &lt; b ). ( <ref type="formula" target="#formula_32">5</ref>) The behavior of an asynchronous channel with the bounded capacity of k &gt; 0 is captured by the FIFO k ABT, defined as</p><formula xml:id="formula_8">α, a FIFO k β, b ≡ α = β ∧ a &lt; b &lt; a (k) .</formula><p>Recall the a (k) is the kth-derivative (i.e., the kth-tail) of the stream a. The FIFO k ABT represents the behavior of any entity that (1) produces an output data stream identical to its input data stream (α = β), and (2) produces every element in its output some time after its respective input element is observed (a &lt; b) but before its kth-next input element is observed (b &lt; a (k) which means b(i) &lt; a(i + k) for all i ≥ 0). Observe that FIFO 1 is indeed a special case of FIFO k with k = 1.</p><p>It is illuminating to compare the FIFO ABT defined above with the definition of the queue ADT in Fig. <ref type="figure" target="#fig_0">1</ref>. They are both mathematically well-defined constructs that describe the same thing: an unbounded FIFO queue. The ADT defines a queue in terms of a set of operations and a set of axioms that constrain the observable mutual effect of those operations on each other. It abstracts away the actual instructions for the implementation of those operations and the data structures that they manipulate. The ABT defines a queue in terms of what data items it exchanges with its environment, when it consumes and produces them, and a set of axioms that constrain their interrelationships. It abstracts away the operations for the realization (or enforcement) of those relationships and the data types that they may utilize to do so.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2.2.">Merge and replicate</head><p>We now define two other ABTs that, as we see in Section 9, form a foundation for an interesting and expressive calculus: merger and replicator. The merger ABT is defined as:</p><formula xml:id="formula_9">Mrg( α, a , β, b ; γ , c ) ≡            α(0) = γ (0) ∧ a(0) = c(0) ∧ Mrg( α , a , β, b ; γ , c ) if a(0) &lt; b(0) ∃t:a(0) &lt; t &lt; min(a(1), b(1)) ∧ ∃r, s ∈ {a(0), t} ∧ r = s ∧ if a(0) = b(0) Mrg( α, r .a , β, s.b ; γ , c ) β(0) = γ (0) ∧ b(0) = c(0) ∧ Mrg( α, a , β , b ; γ , c ) if a(0) &gt; b(0).</formula><p>Intuitively, the Mrg ABT produces an output that is a merge of its two input streams. If α(0) arrives before β(0), i.e., a(0) &lt; b(0), then the ABT produces γ (0) = α(0) as its output at c(0) = a(0) and proceeds with the tails of the streams in its first input timed data stream. If α(0) arrives after β(0), i.e., a(0) &gt; b(0), then the ABT produces γ (0) = β(0) as its output at c(0) = b(0) and proceeds with the tails of the streams in its second input timed data stream. If the α(0) and β(0) arrive "at the same time" (i.e., a(0) = b(0)), then in this formulation Mrg picks an arbitrary number t in the open time interval (a(0), min(a(1), b(1))) and uses it to non-deterministically break the tie. The assumption of dense time guarantees the existence of an appropriate t. Recall that the construct r .a is a stream whose derivative (tail) is a and whose initial value (head) is r. Thus, for a(0) = b(0) Mrg non-deterministically changes the head of one of the two time streams, a or b, thereby "delaying" the arrival of its corresponding data item to break the tie. The finite delay introduced by Mrg in this case is justified because although it breaks simultaneity, its value is constrained to preserve atomicity. Observe that</p><formula xml:id="formula_10">Mrg( α, a , β, b ; γ , c ) = Mrg( β, b , α, a ; γ , c ).</formula><p>The replicator ABT is defined as:</p><formula xml:id="formula_11">Rpl( α, a ; β, b , γ , c ) ≡ β = α ∧ γ = α ∧ b = a ∧ c = a.</formula><p>It is easy to see that this ABT captures the behavior of any entity that synchronously replicates its input stream into its two identical output streams. Observe that Rpl( α, a ; β, b , γ , c ) = Rpl( α, a ; γ , c , β, b ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2.3.">Sum</head><p>As an example of an ABT that performs some computation, consider a simple dataflow adder. The behavior of such a component is captured by the Sum ABT defined as</p><formula xml:id="formula_12">Sum( α, a , β, b ; γ , c ) ≡ γ (0) = α(0) + β(0)∧ ∃t:max(a(0), b(0)) &lt; t &lt; min(a(1), b(1)) ∧ c(0) = t∧ Sum( α , a , β , b ; γ , c ).</formula><p>Sum defines the behavior of a component that repeatedly reads a pair of input values from its two input ports, adds them up, and writes the result out on its output port. As such, its output data stream is the pairwise sum of its two input data streams. This component behaves asynchronously in the sense that it can produce each of its output data items with some arbitrary delay after it has read both of its corresponding input data items (c(0) = t ∧ t &gt; max(a(0), b(0))). However, it is obligated to produce each of its output data items before it reads in its next input data item (t &lt; min(a(1), b(1))).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2.4.">Philosophers and chopsticks</head><p>The classical dining philosophers problem can be described in terms of n &gt; 1 pairs of instances of two components: philosopher instances of Phil and chopstick instances of Chop. We define the externally observable behavior of each of these components as an ABT. We show in Section 9 how instances of these components can be composed into different component based systems both to exhibit and to solve the famous deadlock problem.</p><p>We assume that a chopstick component has two input ports, t (for take) and f (for free), through which it reads in the timed data streams α t , a t and α f , a f , respectively. The data items in α t and α f are tokens whose actual values are not of interest to us. In practice, it is a good idea for these tokens to contain the identifier of the entity (e.g., philosopher) who uses the chopstick, but as long as such informative requirements do not affect behavior, they are irrelevant for our ABT definition.</p><p>When a chopstick is free (its initial state) it is ready to accept a take request and thus reads from its t port the next take request token out of α t , a t . Once taken, a chopstick is ready to accept a free request and thus reads from its f port the free request token out of α f , a f . For the user of the chopstick, the success of its I/O operation on port t or f means the chopstick has accepted its (take or free) request. This simple behavior is captured by the Chop ABT defined as</p><formula xml:id="formula_13">Chop( α t , a t , α f , a f ;) ≡ a t &lt; a f &lt; a t .</formula><p>Because we are not interested in the actual value of the take/free tokens, the Chop ABT has nothing to say about the data streams α t and α f ; it is only the timing that is relevant here. The timing equation simply states that initially, there must be a take, followed by a free, and this sequence repeats.</p><p>We assume that a philosopher component has four output ports, lt (for left-take), lf (for left-free), rt (for right-take), and rf (for right-free), through which it writes the timed data streams α lt , a lt , α lf , a lf , α rt , a rt , and α rf , a rf , respectively. The two ports lt and lf are "on the left" and the two ports rt and rf are "on the right" of the philosopher component, so to speak. The philosopher's requests to take and free the chopsticks on its left and right are issued through their respective ports.</p><p>The externally observable behavior of a philosopher component is as follows. After some period of "thinking" it decides to eat, at which point it attempts to obtain its two chopsticks by issuing take requests on its lt and rt ports. We assume it always issues a request for its left chopstick before requesting the one on its right. The philosopher component interprets the success of its write operation as the acceptance of its request (e.g., for exclusive access to the chopstick). Once, and if, both of its take requests are granted, it proceeds to "eat" for some time, at the end of which it then issues requests to free its left and right chopsticks by writing tokens to its lf and rf ports. The philosopher component then repeats the cycle by entering its thinking period again. This behavior is captured by the Phil ABT defined as</p><formula xml:id="formula_14">Phil(; α lt , a lt , α lf , a lf , α rt , a rt , α rf , a rf ) ≡ a lt &lt; a rt &lt; a lf &lt; a rf &lt; a lt .</formula><p>Again, because we are not interested in the actual values of the take/free tokens that this component produces, the Phil ABT says nothing about the data streams. All we are interested in is the timing constraints: an arbitrary "thinking" delay; followed by a request to take the left chopstick; once granted, followed by a request to take the right chopstick; once granted, followed by an arbitrary "eating" delay; followed by the requests to free the left and the right chopsticks; and the cycle repeats.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3.">ABT composition</head><p>Abstract behavior types can be composed to yield other abstract behavior types through a composition similar to the relational join operation in relational databases. Two ABTs can be composed over a common timed data stream if one is the producer and the other the consumer of that timed data stream. The same two ABTs can be composed over zero or more common timed data streams, each ABT playing the role of the producer or the consumer of one of the timed data streams, independent of its role regarding the others. Observe that the producer and the consumer of a timed data stream, α, a , necessarily synchronize their I/O operations on their respective portals for the mutual exchange of the data items in its data stream α, according to the schedule in its twin time stream a. This is accomplished simply by "fusing" their respective portals together such that the timed data stream observed on one is identical to the one observed on the other.</p><p>Consider two ABTs B 1 with arity p = p i + p o and B 2 with arity q = q i + q o , where p i and p o are, respectively, the input arity and the output arity of B 1 , and q i and q o , those for B 2 . B 1 and B 2 can be composed with 0 ≤ k ≤ min( p i , q o ) + min( p o , q i ) pairs of mutually fused portals, where the data items produced through an output portal, O, of one ABT are fed for consumption by the other ABT through its input portal that is fused with O.</p><p>We define the k-dyad composition of the two ABTs B 1 (I1 1 , I1 2 , . . . , I1 p i ;O1 1 , O1 2 , . . . , O1 p o ) and B 2 (I2 1 , I2 2 , . . . , I2 q i ;O2 1 , O2 2 , . . . , O2 q o ) as a special form of the join of the two relations B 1 and B 2 where k distinct portals (i.e., relational columns) of B 1 are paired each with a distinct portal of B 2 into k dyads such that (1) the two portals in each dyad have opposite input/output tags, and (2) the two timed data streams of the portals in each dyad are equal. The k-dyad composition of B 1 and B 2 yields a new ABT, B(I 1 , I 2 , . . . , I m ;O 1 , O 2 , . . . , O n ), with arity m + n = p + q -2 × k, defined as a relation over those portals of B 1 and B 2 that are not involved in a dyad (i.e., the fused portals disappear from the resulting relation). The list I 1 , I 2 , . . . , I m is obtained from the list I1 1 , I1 2 , . . . , I1 p i , I2 1 , I2 2 , . . . , I2 q i by eliminating every one of its elements involved in a dyad. Similarly, the list O 1 , O 2 , . . . , O n is obtained from the list O1 1 , O1 2 , . . . , O1 p o , O2 1 , O2 2 , . . . , O2 q o by eliminating every one of its elements involved in a dyad.</p><p>We use the dyad indices 1 ≤ l ≤ k as superscripts to mark the corresponding portals of B 1 and B 2 in their k-dyad composition. For example,</p><formula xml:id="formula_15">B = B 1 ( α, a , β, b 1 ; γ , c ) • B 2 ( δ, d ; µ, m 1 )</formula><p>denotes the 1-dyad composition of the two abstract behavior types B 1 and B 2 where the output (portal) of B 2 is identical to the second input (portal) of B 1 . The resulting ABT is defined through the relation</p><formula xml:id="formula_16">B ≡ { α, a , δ, d ; γ , c | α, a , β, b ; γ , c ∈ B 1 ∧ δ, d ; µ, m ∈ B 2 ∧ β, b = µ, m }. Another example is the ABT B = B 1 ( α, a , β, b 1 ; γ , c 2 ) • B 2 ( δ, d 2 ; µ, m 1 , ν, n ),</formula><p>which denotes the 2-dyad composition of the two abstract behavior types B 1 and B 2 where the first output of B 2 is identical to the second input of B 1 and the output of B 1 is identical to the input of B 2 . The resulting ABT is defined as the relation</p><formula xml:id="formula_17">B ≡ { α, a ; ν, n | α, a , β, b ; γ , c ∈ B 1 ∧ δ, d ; µ, m , ν, n ∈ B 2 ∧ β, b = µ, m ∧ γ , c = δ, d }.</formula><p>The common case of the 1-dyad composition of B 1 and B 2 where the single output of B 1 is identical to the single input of B 2 is abbreviated as</p><formula xml:id="formula_18">B 1 (. . . ; α, a ) • B 2 ( β, b ; . . .) instead of B 1 (. . . ; α, a 1 ) • B 2 ( β, b 1 ; . . .).</formula><p>This abbreviation is particularly convenient together with the infix notation for binary abstract behavior types. For instance, B = α, a B 1 β, b • γ , c B 2 δ, d denotes the 1-dyad composition of the two abstract behavior types B 1 and B 2 where the output of B 1 is identical to the input of B 2 . Of course, the resulting ABT is defined as the relation α, a B δ,</p><formula xml:id="formula_19">d ≡ { α, a ; δ, d | α, a ; β, b ∈ B 1 ∧ γ , c ; δ, d ∈ B 2 ∧ β, b = γ , c }.</formula><p>For example, consider the binary ABTs defining the basic channels presented in Section 8.2. It is not difficult to see that the (1-dyad) composition of these ABTs produces results that correspond to our intuition. For instance, the composition of two Sync ABTs produces a Sync ABT. Indeed, composition of a Sync ABT with any other ABT (on its left or right) yields the same ABT. More interestingly, the composition of two FIFO ABTs produces a FIFO ABT. Composing two FIFO 1 ABTs produces a FIFO 2 ABT. The formal proof of this latter equivalence relies on our notion of dense time (as opposed to discrete time) and is given in <ref type="bibr" target="#b5">[6]</ref>, together with the formal treatment of many other interesting examples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Reo</head><p>The ABT model provides a simple formal foundation for definition and composition of components. The k-dyad composition of ABTs supports a very flexible mechanism for software composition in component based systems. This furnishes the desired level of composition flexibility we expect in a component model. However, composing components directly with one another in this way reduces the glue code to essentially nothing more than repeated applications of the k-dyad composition operator. More importantly, it all but extinguishes the possibility of wielding exogenous coordination through the glue code. The ABT model is too low-level to directly provide any form of non-trivial coordination (beyond the simple synchronization implied by its timed data streams); for that, we need an effective exogenous coordination model.</p><p>Reo is a channel-based exogenous coordination model wherein complex coordinators, called connectors are compositionally built out of simpler ones <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b5">6]</ref>. The simplest connectors in Reo are a set of channels with well-defined behavior supplied by users. Reo can be used as a language for coordination of concurrent processes, or as a "glue language" for compositional construction of connectors that orchestrate component instances in a component based system. The emphasis in Reo is on connectors and their composition only, not on the entities that connect to, communicate, and cooperate through these connectors. Each connector in Reo imposes a specific coordination pattern on the entities (e.g., component instances) that perform I/O operations through that connector, without the knowledge of those entities.</p><p>Channel composition in Reo is a very powerful mechanism for construction of connectors. The expressive power of connector composition in Reo has been demonstrated through many examples in <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b5">6]</ref>. For instance, exogenous coordination patterns that can be expressed as (meta-level) regular expressions over I/O operations performed by component instances can be composed in Reo out of a small set of only five primitive channel types.</p><p>A mobile channel allows (physical or logical) relocation of one of its ends without the knowledge or the involvement of the entity at its other end. Logical mobility changes the topology of the interconnections of communicating entities, while physical mobility can have other implications, e.g., on an entity's (efficiency of) access to various resources. An efficient distributed implementation of channels supporting this notion of mobility is described in <ref type="bibr" target="#b8">[9]</ref>. Both component instances and channels are mobile in Reo. Logical mobility of channel ends in Reo allows dynamic reconfiguration of connectors, even while they are being used by component instances. In this respect, Reo resembles dynamically reconfigurable generalized Kahn networks, as in IWIM <ref type="bibr" target="#b0">[1]</ref> and Manifold <ref type="bibr" target="#b13">[14]</ref>, and its dataflow nature is also related to Broy's timed dataflow model, although Reo is more general and more expressive than these and similar models. Much as Reo supports physical mobility through its move operation to allow more efficient flow of data, it ascribes no semantic significance to it. The move operation does not semantically affect connector topologies, flow of data, or connectivity of components to connectors. In this sense, Reo is orthogonal to the concerns involving the physical mobility of code, e.g., in models such as that of <ref type="bibr" target="#b58">[59]</ref>.</p><p>An important aspect of Reo which is not covered in this paper is that the topology of connectors in Reo is inherently dynamic. This means that the configuration of a component-based system can dynamically change not only due to dynamic construction and connection/disconnection of connectors and component instances, but also -and more interestingly -due to dynamic reconfiguration of instantiated connectors even as they are actively in use. Moreover, Reo supports a very liberal notion of channels. As such, Reo is more general than dataflow models, Kahn-networks, and Petri-nets, all of which can be viewed as specialized channel-based models that incorporate certain specific primitive coordination constructs. Broy's work on timed dataflow channels <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b16">17]</ref> is perhaps closest to Reo. Nevertheless, Reo's more general notion of channels, its inherent dynamic topology, its powerful exogenous coordination that uses a clear separation of flows of data and time, and the fundamental notion of channel/connector composition that allows, among other things, compositions involving an expressive mix of synchrony and asynchrony, distinguish it from this model as well.</p><p>It turns out that the ABT model is quite adequate for defining the channel and connector composition operation which is the crux of exogenous coordination in Reo. In the rest of this section we show how connector construction in Reo can be seen as an application of the ABT model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.1.">Channels and connectors</head><p>Channels are the only primitive medium of communication between two components in Reo. The notion of channel in Reo is far more general than its common interpretation. A channel in Reo has its own unique identity and always has exactly two directed ends, each with its own unique identity. Based on their direction, there are two types of channel ends: source and sink ends. Data enters through a source channel end into its respective channel, and it leaves through a sink channel end from its respective channel. (Channels themselves have no direction in Reo, only their ends do.)</p><p>Beyond a small set of mild obvious requirements, such as enabling I/O operations to read/write data items from/to their ends, Reo places no restrictions on the behavior of channels. This allows an open-ended set of different channel types to be used simultaneously together in Reo, each with its own policy for synchronization, buffering, ordering, computation, data retention/loss, etc. Some typical examples of conventional channels are, e.g., the ones defined in Section 8.2. These channels happen to each have a source end and a sink end. More unconventional channels are also possible in Reo, especially because a channel can also have only two source ends or only two sink ends. A few examples of some such exotic channels appear in Section 9.3; even more examples are presented in <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b3">4]</ref>.</p><p>Strictly speaking, Reo itself neither provides nor assumes the availability of any specific set of channel types; it simply assumes that an appropriate assortment of channel types, each with its properly well-defined semantics, is provided by users for it to operate on. Nevertheless, it is reasonable to expect that in practice certain most primitive channel types, e.g., synchronous channels, will always be made available in all cases.</p><p>Reo defines a connector as a set of channel ends and their connecting channels organized in a graph of nodes and edges such that:</p><p>• Zero or more channel ends coincide on every node.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>• Every channel end coincides on exactly one node.</head><p>• There is an edge between two (not necessarily distinct) nodes if and only if there is a channel one end of which coincides on each of those nodes.</p><p>We use x → N to denote that the channel end x coincides on the node N, and x to denote the unique node on which the channel end x coincides. For a node N, we define the set of all channel ends coincident on N as [N] = {x | x → N}, and disjointly partition it into the sets Src(N) and Snk(N), denoting the sets of source and sink channel ends that coincide on N, respectively.</p><p>Observe that nodes are neither components nor locations. Although some nodes are attached to component instances to allow their exchange of information, nodes and components are different notions and not every node can be associated with or attached to a component instance. A node is a fundamental concept in Reo representing an important topological property: all channel ends x ∈ [N] coincide on the same node N. This property entails specific implications in Reo regarding the flow of data among the channel ends x ∈ [N], irrespective of concern for the location of those channel ends or N, or the possible attachment of N to a component instance.</p><formula xml:id="formula_20">A node N is called a source node if Src(N) = ∅ ∧ Snk(N) = ∅. Analogously, N is called a sink node if Src(N) = ∅ ∧ Snk(N) = ∅. A node N is called a mixed node if Src(N) = ∅ ∧ Snk(N) = ∅.</formula><p>By the above definition, every channel represents a (simple) connector with two nodes. From the point of view of Reo a port of a component instance is just a node that (initially) contains a single channel end. An input port is (initially a singleton) source node, and an output port is (initially a singleton) sink node. From the point of view of a component instance, each of its ports is merely a simple connector corresponding to a synchronous channel (the node of) one end of which is made publicly accessible for I/O by its environment, while (the node of) its other end is hidden for exclusive use by the component instance itself. An output port of a component instance has the sink node of its synchronous channel public while its source node is available only for I/O operations performed by that component instance. Likewise, an input port has the source node of its synchronous channel public while its sink node is hidden for exclusive use by its component instance.</p><p>Reo provides I/O operations on source and sink nodes only; components cannot read from or write to mixed nodes. A component instance can write to a source node or read from a sink node using node I/O operations of Reo only if it is connected to that node. Connection of a node to a component instance gives the latter the exclusive right to perform I/O operations on that node. Reo provides operations to change the connection of nodes to component instances dynamically, but a node can be connected to at most a single component instance at any given time. This is a prerequisite for the formal notion of compositionality presented in <ref type="bibr" target="#b6">[7]</ref>.</p><p>The graph representing a connector is not directed. However, for each channel end x c of a channel c, we use the directionality of x c to assign a local direction in the neighborhood of x c to the edge that represents c. The local direction of the edge representing a channel c in the neighborhood of the node of its source x c is presented as an arrow emanating from x c . Likewise, the local direction of the edge representing a channel c in the neighborhood of the node of its sink x c is presented as an arrow pointing to x c . See Figs. <ref type="figure" target="#fig_2">2</ref> and<ref type="figure" target="#fig_3">3</ref> for examples.</p><p>Complex connectors are constructed in Reo out of simpler ones using its join operation. The join operation in Reo is defined only on nodes. Joining two nodes N 1 and N 2 destroys both nodes and produces a new node N with the property that</p><formula xml:id="formula_21">[N] = [N 1 ] ∪ [N 2 ]</formula><p>. This single operation allows construction of arbitrarily complex connector graphs involving any combination of channels picked from an open-ended set of channel types. The semantics of a connector is defined as a composition of the semantics of its (1) constituent channels, and (2) nodes. Because Reo does not provide any channels, it does not define their semantics either. What Reo defines is the composition of channels into connectors and the semantics of this composition through the semantics of its (three types of) nodes.</p><p>Intuitively, a source node replicates every data item written to it as soon as all of its coincident source channel ends can consume that data item. Reading from a sink node non-deterministically selects one of the data items available through its coincident sink channel ends. A mixed node is a self-contained "pumping station" that combines the behavior of a sink node and a source node in an atomic iteration of an infinite loop: in each atomic iteration it non-deterministically selects an appropriate data item available through its coincident sink channel ends and replicates that data item into all of its coincident source channel ends. A data item is appropriate for selection in an iteration only if it can be consumed by all source channel ends that coincide on that node.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.2.">ABT models of nodes and connectors</head><p>Consider a sink node N with [N] = {x, y}, as in Fig. <ref type="figure" target="#fig_2">2a</ref>. The read operations performed on this node induce an output timed data stream, α N , a N , for this sink node. We use α x , a x and α y , a y to designate the timed data streams corresponding to the channel ends x and y, respectively. The semantics of this sink node is defined by the ABT Mrg( α x , a x , α y , a y ; α N , a N ).</p><p>The semantics of a sink node N where [N] = {x, y, z}, as in Fig. <ref type="figure" target="#fig_1">2b</ref>, is defined as the 1-dyad composition</p><formula xml:id="formula_22">Mrg3( α x , a x , α y , a y , α z , a z ; α N , a N )) ≡ Mrg( α x , a x , α y , a y ; ψ, p 1 ) • Mrg( ξ, q 1 , α z , a z ; α N , a N )</formula><p>where α N , a N is the output timed data stream of the node, as before, and ψ, p and ξ, q are internal timed data streams.</p><p>Because Mrg is associative with respect to its input portals, merging the intermediate result of the merge of x and y with z is the same as merging x with the intermediate result of the merge of y and z; i.e., Mrg3 is associative with respect to its input portals. As such, the simple graphical notation of Reo (e.g., in Fig. <ref type="figure" target="#fig_2">2a</ref> and<ref type="figure">b</ref>) is quite appropriate because it does not suggest any precedence for the Mrg operations. Clearly this scheme can be used to define the semantics of sink nodes with more coincident channel ends in general as the ABT Mrgk with k &gt; 0 input and one output portals. For completeness, we define Mrg1( α x , a x ; α N , a N )) ≡ α x , a x = α N , a N and consider Mrg2 to be a pseudonym for Mrg.</p><p>The write operations performed on a source node N with [N] = {x, y}, as in Fig. <ref type="figure" target="#fig_1">2c</ref>, induce an input timed data stream, α N , a N , for N. The semantics of N in this case is defined by the ABT Rpl( α N , a N ; α x , a x , α y , a y . The semantics of a source node N with [N] = {x, y, z}, as in Fig. <ref type="figure" target="#fig_1">2d</ref>, is defined as the 1-dyad composition</p><formula xml:id="formula_23">Rpl3( α N , a N ; α x , a x , α y , a y , α z , a z ) ≡ Rpl( α N , a N ; α x , a x , ψ, p 1 ) • Rpl( ξ, q 1 ; α y , a y , α z , a z )</formula><p>where α N , a N is the input timed data stream of the node, as before, and ψ, p and ξ, q are internal timed data streams. Because Rpl is associative with respect to its output portals, the precedence of the Rpl operations is irrelevant and Rpl3 is also associative with respect to its output portals. Similarly, the general ABT Rplk with one input and k &gt; 0 output portals defines the semantics of a source node with k coincident channel ends. Again, for completeness, we define Rpl1( α N , a N ; α x , a x )) ≡ α x , a x = α N , a N and consider Rpl2 to be a pseudonym for Rpl.</p><p>A mixed node, as in Fig. <ref type="figure" target="#fig_1">2e</ref>, is a composition of two "half-nodes", a source and a sink. Because no component is allowed to perform an I/O operation on a mixed node, no input/output timed data stream can be defined for a mixed node. A mixed node is a closed entity that does not interact with any component; instead it internally pumps data items from its sink channel ends to its source channel ends. The semantics of a mixed node N with m &gt; 0 sink and n &gt; 0 source channel ends is given by the ABT Node m×n defined as the 1-dyad composition of the two ABTs describing the behavior of each of its half nodes: Mrgm(I 1 , I 2 , . . . , I m ; ψ, p ) and Rpln( ξ, q ;O 1 , O 2 , . . . , O n ). The portals I i and O j designate the timed data streams observed at the m sink and the n source channel ends coincident on N, respectively, and ψ, p and ξ, q are internal timed data streams.</p><formula xml:id="formula_24">Node m×n (I 1 , I 2 , . . . , I m ;O 1 , O 2 , . . . , O n ) ≡ Mrgm(I 1 , I 2 , . . . , I m ; ψ, p ) • Rpln( ξ, q ;O 1 , O 2 , . . . , O n ).</formula><p>For instance, the behavior of the mixed node in Fig. <ref type="figure" target="#fig_1">2e</ref>  where I i and O j designate the timed data streams observed at the m sink and the n source channel ends coincident on the node and α, a represents its output or input timed data stream.</p><p>Every edge of a connector corresponds to a channel whose semantics is defined as an ABT. Since a connector consists of (three types of) nodes and edges, all of whose semantics are now defined as ABTs, the semantics of every connector in Reo can be derived as a composition of the ABTs of its constituent nodes and edges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.3.">A cogent set of primitive channels</head><p>To demonstrate the utility of Reo we must supply it with a set of primitive channels. The fact that Reo accepts and the ABT model allows definition of an open-ended set of arbitrarily complex channels is interesting. What is more interesting, however, is that connector composition in Reo is itself powerful enough to yield surprisingly expressive complex connectors out of a very small set of trivially simple channels.</p><p>A useful set of primitive channels for Reo consists of 7 channel types: Sync, FIFO, FIFO 1 , FIFO 1 (D), Filter(P), LossySync, and SyncDrain. This is not a minimal set, in the sense that some of the channel types in this set can themselves be composed in Reo out of others; however, minimality is not our concern here and these channel types turn out to be both simple and frequently useful enough to deserve their own explicit mention. The first four channel types were defined as ABTs in Section 8.2. We define the ABTs for the rest below.</p><p>The common characteristics of the last three channels, above, are that they are all (1) synchronous, and (2) lossy. Neither channel has a buffer to store data and if necessary, delays the I/O operation on either one of its ends until it is matched with an I/O operation on its other end. A channel is lossy if it does not deliver through its sink end every data item it consumes through its source end. The difference between these three channels is in their loss policy.</p><p>(1) A Filter(P) channel is a synchronous channel with a source and a sink end that takes a pattern P parameter upon its creation. It behaves like a Sync channel, except that only those data items that match the pattern P can actually pass through it; others are always accepted by its source, but are immediately lost. The behavior of such a channel is captured by the Filter(P) ABT defined as The infix operator α(0) P denotes whether or not the data item α(0) matches with the pattern P. If so, α(0) passes through, otherwise it is lost, and the ABT proceeds with the rest of its timed data streams. (2) A LossySync channel is also like a Sync channel except that it is always ready to consume every data item written to its source end. If a matching read operation is pending at its sink, the data item written to its source is actually transferred; otherwise, the written data item is lost. The behavior of this channel is captured by the LossySync ABT defined as</p><formula xml:id="formula_25">α, a LossySync β, b ≡        α, a LossySync β, a(0).b if a(0) &gt; b(0) β(0) = α(0) ∧ α , a LossySync β , b if a(0) = b(0) α , a LossySync β, b otherwise.</formula><p>(3) A SyncDrain is a channel with two source ends. Because it has no sink end, it has no way to ever produce any data items. Consequently, every data item written to its source ends is simply lost. SyncDrain is synchronous because a write operation on one of its ends remains pending until a write is performed on its other end as well; only then </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.4.">Coordinating glue code</head><p>To demonstrate the expressive power of connector composition, in this section we describe a number of examples in Reo. More examples are presented elsewhere <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b3">4]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.4.1.">Write-cue regulator</head><p>Consider the connector in Fig. <ref type="figure" target="#fig_3">3a</ref>, composed out of the three channels ab, cd, and ef. Channels ab and cd are of type Sync and ef is of type SyncDrain. This connector shows one of the most basic forms of exogenous coordination: the number of data items that flow from a to d is the same as the number of write operations that succeeds on f. (Recall that a designates the unique node on which the channel end a coincides.) The analogy between the behavior of this connector and a transistor in the world of electronic circuits is conspicuous.</p><p>A component instance with a port connected to f can count and regulate the flow of data between the two nodes a and d by the timing and the number of write operations it performs on f. The entity that regulates and/or counts the number of data items through f need not know anything about the entities that write to a and/or take from d, nor that its write actions actually regulate this flow. The two entities that communicate through a and d need not know anything about the fact that they are communicating with each other, nor that the volume of their communication is regulated and/or measured by a third entity at f.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.4.2.">Barrier synchronizers</head><p>We can build on our write-cue regulator to construct a barrier synchronization connector, as in Fig. <ref type="figure" target="#fig_3">3b</ref>. The four channels ab, cd, gh, and ij are all of type Sync. The SyncDrain channel ef ensures that a data item passes from a to d only simultaneously with the passing of a data item from g to j (and vice versa). This simple barrier synchronization connector can be trivially extended to any number of pairs, as shown in Fig. <ref type="figure" target="#fig_3">3c</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.4.3.">Ordering</head><p>The connector in Fig. <ref type="figure" target="#fig_3">3d</ref> consists of three channels: ab, ac, and bc. The channels ab and ac are SyncDrain and Sync, respectively. The channel bc is of type FIFO 1 . The behavior of this connector can be seen as imposing an order on the flow of the data items written to a and b, through to c: the data items obtained by successive read operations on c consist of the first data item written to a, followed by the first data item written to b, followed by the second data item written to a, followed by the second data item written to b, etc. See <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4]</ref> for more detail and <ref type="bibr" target="#b5">[6]</ref> for a formal treatment of this connector.</p><p>The coordination pattern imposed by our connector can be summarized as c = (ab) * , meaning the sequence of values that appear through c consist of zero or more repetitions of the pairs of values written to a and b, in that order.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.4.4.">Sequencer</head><p>Consider the connector in Fig. <ref type="figure" target="#fig_3">3e</ref>. The enclosing box represents the fact that the details of this connector are abstracted away and it provides only the four nodes a, b, c, and d for other entities (connectors and/or component instances) to (in this case) read from. Inside this connector, we have four Sync, a FIFO 1 (o), and three FIFO 1 channels connected together. The FIFO 1 (o) channel is the leftmost one and is initialized to have a data item in its buffer, as indicated by the presence of the symbol "o" in the box representing its buffer. The actual value of this data item is irrelevant. The read operations on the nodes a, b, c, and d can succeed only in the strict left to right order. This connector implements a generic sequencing protocol: we can parameterize this connector to have as many nodes as we want, simply by inserting more (or fewer) Sync and FIFO 1 channel pairs, as required.</p><p>Fig. <ref type="figure" target="#fig_3">3f</ref> shows a simple example of the utility of our sequencer. The connector in this figure consists of a two-node sequencer, plus a pair of Sync channels and a SyncDrain channel connecting each of the nodes of the sequencer to the nodes a and c, and b and c, respectively. The connector in Fig. <ref type="figure" target="#fig_3">3f</ref> is another connector for the coordination pattern c = (ab) * , although there is a subtle difference between the behavior of this connector and the one in Fig. <ref type="figure" target="#fig_3">3d</ref>. See <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4]</ref> for more detail.</p><p>It takes little effort to see that the connector in Fig. <ref type="figure" target="#fig_3">3g</ref> corresponds to the meta-regular expression c = (aab) * . Fig. <ref type="figure" target="#fig_3">3f</ref> and<ref type="figure">g</ref> show how easily we can construct connectors that exogenously impose coordination patterns corresponding to the Kleene-closure of any "meta-word" made up of atoms that stand for I/O operations, using a sequencer of the appropriate size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.5.">Constant replacer</head><p>Fig. <ref type="figure" target="#fig_4">4</ref> shows a Reo connector (encapsulated in the outermost thick box, hiding mixed nodes N1 and N2) with one exposed input (i.e., source node A) and one exposed output (i.e., sink node B) nodes. This connector is composed out of four channels: a SyncDrain (A-N1), a Sync (N1-B), a FIFO 1 (N1-N2), and a filled FIFO 1 (T) (N2-N1) that contains an initial value T. Of course, the constructor of this connector can be parameterized to initialize this FIFO 1 channel with any supplied value, instead of T, every time it creates a new instance of this circuit. Using the ABT definitions of these channels and those of its nodes, we can find the relationship between the two timed data streams α, a and β, b that pass through the nodes A and B, respectively. As a side note, it is interesting to observe that this relationship and other insights we gain, below, through a formal treatment of the behavioral equations of this connector, all correspond to and confirm the intuitive impression that we get through an informal reasoning using the schematic of this connector in Fig. <ref type="figure" target="#fig_4">4</ref>. This observation underscores the usefulness and the significance of visual representation of Reo connectors.</p><p>From the definition of the SyncDrain channel in Section 9.3, we have:</p><formula xml:id="formula_26">SyncDrain( α, a , χ, c ;) ≡ a = c.</formula><p>(</p><p>By letting m = 1 and n = 3 in the ABT equation of mixed nodes in Section 9.2, we derive for N1:</p><formula xml:id="formula_28">Node 1×3 ( , e ; χ, c , φ, f , δ, d ) ≡ Mrg1( , e ; ψ, p ) • Rpl3( ξ, q ; χ, c , φ, f , δ, d ) ≡ { , e ; χ, c , φ, f , δ, d | , e ; ψ, p ∈ Mrg1∧ ξ, q ; χ, c , φ, f , δ, d ∈ Rpl3 ∧ ψ, p = ξ, q }.<label>(2)</label></formula><p>From the definition of Mrg1 in Section 9.2, we get , e ; ψ, p ∈ Mrg1 ≡ , e = ψ, p and from the definition of Rpl3 in the same section, we have ξ, q ; χ, c , φ, f , δ, d ∈ Rpl3 ≡ ξ, q = χ, c = φ, f = δ, d . Substituting these back in Eq. ( <ref type="formula" target="#formula_28">2</ref>) and simplifying the result yields:</p><formula xml:id="formula_29">Node 1×3 ( , e ; χ, c , φ, f , δ, d ) ≡ { , e ; χ, c , φ, f , δ, d | , e = χ, c = φ, f = δ, d },<label>(3)</label></formula><p>or</p><formula xml:id="formula_30">Node 1×3 ( , e ; χ, c , φ, f , δ, d ) ≡ { , e ; χ, c , φ, f , δ, d | = χ = φ = δ ∧ e = c = f = d}. (<label>4</label></formula><formula xml:id="formula_31">)</formula><p>Similarly, for the node N2, we derive:</p><formula xml:id="formula_32">Node 1×1 ( γ , g ; η, h ) ≡ { γ , g ; η, h | γ = η ∧ g = h}. (<label>5</label></formula><formula xml:id="formula_33">)</formula><p>From the definition of the FIFO 1 channel in Section 8.2.1, we have:</p><formula xml:id="formula_34">δ, d FIFO 1 γ , g ≡ δ = γ ∧ d &lt; g &lt; d ,<label>(6)</label></formula><p>and the definition of the initialized FIFO 1 channel in the same section yields:</p><formula xml:id="formula_35">η, h FIFO 1 (T) , e ≡ (0) = T ∧ η = ∧ e &lt; h &lt; e . (<label>7</label></formula><formula xml:id="formula_36">)</formula><p>The definition of the Sync channel in Section 8.2.1 gives:</p><formula xml:id="formula_37">φ, f Sync β, b ≡ φ, f = β, b ≡ φ = β ∧ f = b. (<label>8</label></formula><formula xml:id="formula_38">)</formula><p>From Eqs. ( <ref type="formula" target="#formula_27">1</ref>) and ( <ref type="formula" target="#formula_30">4</ref>) we get d = a, which together with Eq. ( <ref type="formula" target="#formula_34">6</ref>) yields:</p><formula xml:id="formula_39">a &lt; g &lt; a .<label>(9)</label></formula><p>From Eq. ( <ref type="formula" target="#formula_37">8</ref>) we have f = b, which together with Eqs. ( <ref type="formula" target="#formula_30">4</ref>) and ( <ref type="formula" target="#formula_27">1</ref>), yields:</p><formula xml:id="formula_40">b = a. (<label>10</label></formula><formula xml:id="formula_41">)</formula><p>From Eq. ( <ref type="formula" target="#formula_35">7</ref>) we have (0) = T ∧ η = and from Eqs. ( <ref type="formula" target="#formula_30">4</ref>) and ( <ref type="formula" target="#formula_37">8</ref>) we have = φ = β. This gives us:</p><formula xml:id="formula_42">β(0) = T ∧ β = η. (<label>11</label></formula><formula xml:id="formula_43">)</formula><p>From Eq. ( <ref type="formula" target="#formula_32">5</ref>) we have η = γ and from Eq. ( <ref type="formula" target="#formula_34">6</ref>) we have γ = δ. But from Eq. ( <ref type="formula" target="#formula_30">4</ref>) we have δ = φ and from Eq. ( <ref type="formula" target="#formula_37">8</ref>) we have φ = β, therefore η = β, which simplifies Eq. ( <ref type="formula" target="#formula_42">11</ref>) into:</p><formula xml:id="formula_44">β(0) = T ∧ β = β. (<label>12</label></formula><formula xml:id="formula_45">)</formula><p>Observe that the stream equation β = β is just a shorthand for the infinite set of equations</p><formula xml:id="formula_46">β(1) = β(0) ∧ β(2) = β(1) ∧ β(3) = β(2) ∧ β(4) = β(3) ∧ . . .. This simplifies Eq. (12) into β(0) = T ∧ β(1) = β(0) ∧ β(2) = β(1) ∧ β(3) = β(2) ∧ β(4) = β(3) ∧ . . . , or: ∀i ∈ N + β(i) = T.<label>(13)</label></formula><p>Eq. ( <ref type="formula" target="#formula_46">13</ref>) clearly shows that there is no relationship between the stream of input values, α, and the stream of output values, β, of this connector: whatever value comes through the node A, its corresponding output value through the node B is the constant value T. On the other hand, Eq. ( <ref type="formula" target="#formula_40">10</ref>) relates the input/output "timings" of this connector: passage of each pair of values through the nodes A and B is atomic. Eq. ( <ref type="formula" target="#formula_39">9</ref>) shows an internal subtlety of the behavior of this connector. For i &gt; 0, the value α(i) (and its corresponding value β(i)) can pass through A (and B) only after g(i -1). In other words, the constant value T must cycle through the node N2 once before the next pair of values passes through the nodes A and B. In theory, it is always possible to use "fast enough" internal channels such that this cycling of value through the node N2 does not "slow down" the passing of values through A and B. On the other hand, the relational nature of our behavioral equations implies that, in practice, the internal cycling of T will delay value transfers through A and B, if necessary, such that Eq. ( <ref type="formula" target="#formula_39">9</ref>) holds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.6.">Fibonacci series</head><p>A simple example of how a composition of a set of components yields a system that delivers more than the sum of its parts is the computation of the classical Fibonacci series. To assemble a component based application to deliver this series we actually need only one (instance of one) component plus a number of channels. The component we need is a realization of the Sum ABT that we already saw in Section 8.2.</p><p>Fig. <ref type="figure" target="#fig_5">5</ref> shows a component (the outermost thick enclosing box) with only one output port (the only exposed node on the right border of the box). This is our component based application for computing the Fibonacci series. Peeking inside this component, we see how it is made out of an instance of Sum, a FIFO 1 (1), a FIFO 1 (0), a FIFO 1 , and five Sync channels.</p><p>As long as the FIFO 1 (0) channel is full, nothing can happen: there is no way for the value in FIFO 1 (1) to move out. At some point in time, the value in FIFO 1 (0) moves into the FIFO 1 channel. Thereafter, the FIFO 1 (0) channel becomes empty and the two values in the FIFO 1 (1) and the FIFO 1 channels become available for Sum to consume. The intake of the value in FIFO 1 (1) by Sum inserts a copy of the same value into the FIFO 1 (0) channel. When Sum is ready to write its computed value out, it suspends waiting for some entity in the environment to accept this value. Transfer of this value to the entity in the environment also inserts a copy of the same value into the now empty FIFO 1 (1) channel. At this point we are back to the initial state, but with different values in the buffers of the FIFO 1 (1) and the FIFO 1 (0) channels.</p><p>The ABT models of the component Sum, channels, and Reo nodes that we presented earlier suffice for a formal analysis of the behavior of their composition in this example. Observe that all entities involved in this composed application are completely generic and, of course, neither knows anything about the Fibonacci series, nor the fact that it is "cooperating" with other entities to compute it. It is the specific glue code of this application, made by composing 8 simple generic channels in a specific topology in Reo, that coordinates the communication of the components (in this case, only one) with one another (in this case, with itself) and the environment to compute this series.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.7.">Dining philosophers</head><p>We can vividly demonstrate the significance of exogenous coordination in component based system composition through the classical dining philosophers problem. In this section we use instances of two components, each of which is a realization of one of the two ABTs Phil and Chop defined in Section 8.2.4, to (1) compose a dining philosophers application that exhibits the famous deadlock problem; and (2) compose another dining philosophers application that prevents the deadlock.</p><p>Fig. <ref type="figure" target="#fig_6">6a</ref> shows 4 philosophers and 4 chopsticks around a virtual round table. Each philosopher has 4 output ports, corresponding to the lt, lf , rt, and rf portals of the Phil ABT in Section 8.2.4. In this figure, philosophers face the table, thus their sense of left and right is obvious. Each chopstick has two input ports, corresponding to the t and f input portals of the Chop ABT in Section 8.2.4. In Fig. <ref type="figure" target="#fig_6">6a</ref>, chopstick ports on the outer-edge of the table are their t ports and the ones closer to the center of the table are their f ports. The t (take) port of each chopstick is connected to the take ports of its adjacent philosophers, and its f port to their respective free ports. All channels are of type Sync.</p><p>Consider what happens in the node at the three-way junction connected to the t port of Chop 1 . If Chop 1 is free and is ready to accept a token through its t port, as it initially is, whichever one of the two philosophers Phil 1 and Phil 4 happens to write its take request token first will succeed to take Chop 1 . Of course, it is possible for Phil 1 and Phil 4 to attempt to take Chop 1 at the same time. In this case, the semantics of this mixed node (by the definition of the ABT Mrg) guarantees that only one of them succeeds, nondeterministically; the write operation of the other remains pending until Chop 1 is free again. Because the definition of the ABT Phil states that a philosopher frees a chopstick only after it has taken it, there is never any contention at the three-way junction connected to the f port of a chopstick.</p><p>The composition of channels in this Reo application enables philosophers to repeatedly go through their "eat" and "think" cycles at their leisure, resolving their contentions for taking the same chopsticks non-deterministically. The possibility of starvation is ruled out because the non-determinism in Mrg is assumed to be fair. This simple glue code composed of nothing but common generic Sync channels directly renders a faithful implementation of the dining philosophers problem; all the way down to its possibility of deadlock. Because all philosophers are instances of the same component, they all attempt to fetch their chopsticks in the same order. The Phil ABT defines this to be left-first. If all chopsticks are free and all philosophers attempt to take their left chopsticks at the same time, of course, they will all succeed. However, this leaves no free chopstick for any philosopher to take before it can eat. No philosopher will relinquish its chopstick before it finishes its eating cycle. Therefore, this application deadlocks, as expected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.7.1.">Avoiding the deadlock</head><p>Interestingly, with Reo, solving the deadlock problem requires no extra code, central authority, or modification to any of the components. In order to prevent the possibility of a deadlock, all we need to do is to change the way in which we compose our application out of the very same components. Fig. <ref type="figure" target="#fig_6">6b</ref> shows a slightly different composition topology of the same set of Sync channels comprising the glue code that connects the exact same instances of Phil and Chop as before. We have flipped one philosopher's left and right connections to its adjacent chopsticks (in this particular case, those of Phil 2 ) without its knowledge. None of the components in the system are aware of this change, nor is any of them modified in any way to accommodate it. Our flipping of these connections is purely external to all components.</p><p>It is not difficult to see why this new topology prevents deadlock. If all philosophers attempt to take their left chopsticks now at the same time, one of them, namely Phil 2 , will actually reach for the one on its right-hand-side. Of course, Phil 2 is unaware of the fact that as it reaches out through its left port to take its first chopstick, it is actually the one on its right-hand-side it competes to take. In this case it competes with Phil 3 , which is also attempting to take its first chopstick. It makes no difference which one of the two wins this competition, one will be denied access to its first chopstick. This ensures that at least one chopstick will remain free (no philosopher attempts to take Chop 2 as its first chopstick) to enable at least one philosopher to obtain its second chopstick as well and complete its eating cycle.</p><p>Comparing the composition topologies in Fig. <ref type="figure" target="#fig_6">6a</ref> and<ref type="figure">b</ref>, we see that in Reo (1) different glue code connecting the same components produces different system behavior; and (2) coordination protocols are imposed by glue code on components that cooperate with one another through the glue code, without being aware of each other or their cooperation. The two fundamental notions that underpin this pair of highly desirable provisions are:</p><p>• The underlying notion of component (Section 6) in the ABT model prevents a component from distinguishing individual entities within its environment directly.</p><p>Components can exchange only passive data with their environment through The two systems in Fig. <ref type="figure" target="#fig_6">6a</ref> and b are made of the same number of constituent parts of the same types: the same number of component instances of the same kinds, and the same number of primitive connectors (Sync channels). The only difference between the two is in the topology of their inter-connections. This topological difference is the only cause of the difference between the "more than sum of the parts" in these two systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.7.2.">Making of a chopstick</head><p>A moment of reflection reveals that, especially since there is no computation involved in the behavior of a chopstick, it should be easy to realize the behavior defined by the ABT Chop through channel composition. The behavior defined as Chop is indeed all coordination: it must alternate enabling the write operations on one (t) then on the other ( f ) of its two input ports. Indeed, we can easily use a two-port sequencer (Fig. <ref type="figure" target="#fig_3">3e</ref>) plus two SyncDrain channels to realize this behavior. But a much simpler construction is possible as well.</p><p>The connector hidden inside the enclosing box in Fig. <ref type="figure" target="#fig_7">7</ref> is a simplified two-port sequencer which exactly implements the behavior of the ABT Chop. This connector consists of two channels: a FIFO 1 and a SyncDrain. Initially, the FIFO 1 is empty, therefore enabling the first write to its port t to succeed immediately. While this channel is empty, a write to its f port suspends because there is no data item to be "simultaneously" consumed by the opposite (source) end of the SyncDrain. Once a write to t succeeds, the FIFO 1 channel becomes full and the next write operation on port t will suspend until this channel becomes empty again. When the FIFO 1 channel is full, a write to f succeeds, causing the SyncDrain channel to consume the contents of the FIFO 1 channel as well. This returns the connector to its original state allowing it to cyclically repeat the same behavior. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.7.3.">Adaptation of a philosopher</head><p>As a simple example of the usefulness of Filter(P) channels, suppose the interface of the philosopher component we acquire for our application does not exactly match that of our Phil ABT. The component we obtain, Philos has only one output port and it writes all its tokens to the same port. Fig. <ref type="figure" target="#fig_8">8</ref> shows how Philos can be adapted to fit the interface of Phil, using four filter channels.</p><p>The wiggly segment in the representation of a filter channel suggests a "resistor" that inhibits the transmission of values that do not match its filter pattern. The text above the wiggly line is the filter pattern. Because Philos writes all of its tokens to the same port, it must distinguish them by their values. We assume it writes the four values lt, lf, rt, and rf to identify these tokens. Every value written to the output port of Philos is automatically replicated into the source ends of the four channel filters that coincide on this node. This copying happens whenever all four source channel ends are ready to consume the replicated value. Whatever the value is, three of the four channels will always be ready to accept it unconditionally, because it will not match their filters and they will immediately lose the value. The fourth channel, the one whose pattern matches the written value, is the one whose acceptance triggers the actual replication/transfer. This happens only when the node at the sink end of this filter channel can synchronously dispose of the value, which is possible only when there is a read on that node.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.8.">Microwave oven interface</head><p>In this section we present a number of generally useful connectors and show how they can be combined with a number of equally generic -plus some application specificcomponents to compose the user interface of a simple microwave oven. Of course, any of these connectors can be programmed as a black-box component as well, but in order to show the expressive power of Reo in practice, we construct them here out of the set of primitive channels of Section 9.3. In the sequel, we use the terms "input node" and "output node" of a connector or component as synonyms for, respectively, "source node" and "sink node" through which that component or connector consumes and produces data. For a component, its input and output nodes are its input and output ports, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.8.1.">Exclusive router</head><p>Fig. <ref type="figure" target="#fig_9">9a</ref> shows a very useful generic connector, called exclusive router. The dashed arrows are our graphical symbols representing LossySync channels. A data item arriving at the input node A flows through to only one of the output nodes B or C, depending on which one is ready to consume it. If both output nodes are prepared to consume a data item, then one is selected non-deterministically (by the merger ABT inherent in the mixed node in the middle of this connector). The input data is never lost nor replicated to more than one of the output nodes.</p><p>The behavior of this connector is the counterpart of the primitive non-deterministic selection inherent in the merge that a Reo (sink or mixed) node performs on its multiple input. In <ref type="bibr" target="#b9">[10]</ref> we show this by deriving the constraint automaton for this connector through composition of the constraint automata of its constituent channels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.8.2.">Selector</head><p>Fig. <ref type="figure" target="#fig_9">9b</ref> shows another generically useful connector, called selector, which uses an exclusive router of Section 9.8.1. Availability of a value at its input node E "enables" this connector to select a value available on one of the input nodes B1 or B2 for transfer through its respective output node S1 or S2. The prerequisite for a transfer of a value from B1 to S1 is the availability of a value at E and another at B1, plus the readiness of a consumer at S1. Likewise, the prerequisite for a transfer of a value from B2 to S2 is the availability of a value at E and another at B2, plus the readiness of a consumer at S2. As long as no value is available on E, all input values on B1 and B2 are lost, while consumers at S1 and S2, if any, wait. If a value is available on E while a value and a ready consumer are available for only one of the two pairs Bi-Si, then a value transfer takes place for that pair and the value on the other Bi node, if any, is lost. If both pairs have available values and ready consumers (when a value is available on E), then the exclusive router non-deterministically enables the value transfer for one of the two pairs and the value on the other Bi node is lost.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.8.3.">Shift-lossy FIFO 1</head><p>Fig. <ref type="figure" target="#fig_10">10a</ref> (due to J. Rutten) shows a connector that is often used as a simple channel in the construction of other connectors. It is called shift-lossy FIFO 1 because its behavior is  very similar to our FIFO 1 primitive channel of Section 9.3, except that it loses its current value if its buffer is full to accept a new input value instead. Thus, unlike the case of a FIFO 1 , no write to the in node of this connector/channel is ever delayed: as far as the writer is concerned, a shift-lossy FIFO 1 channel behaves the same as an unbounded FIFO. However, this channel keeps only the last of its input values for transfer through its out node.</p><p>The connector in Fig. <ref type="figure" target="#fig_10">10a</ref> is composed out of an exclusive router, a FIFO 1 channel initialized to contain a token value (o), a FIFO 2 channel, a SyncDrain channel, and 4 Sync channels. We derive the constraint automaton describing the behavior of this connector in <ref type="bibr" target="#b9">[10]</ref> by composing the constraint automata of its constituent channels.</p><p>Because this connector is so commonly useful, we treat it as a channel and use the graphical symbol shown in Fig. <ref type="figure" target="#fig_10">10b</ref> to represent it. This symbol is intentionally similar to that of a FIFO 1 primitive channel. The dashed half of the box representing its buffer suggests data loss. The fact that the sink-side of the box is dashed suggests that older values in the buffer are lost in favor of newer values, i.e., the buffer contents shift to the sink side, losing older values, to make room for newer arrivals.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.8.4.">Overflow-lossy FIFO 1</head><p>The counterpart of the shift-lossy FIFO 1 channel of Section 9.8.3 is the connector in Fig. <ref type="figure" target="#fig_11">11a</ref>. Recall that the dashed arrow used in this connector represents the LossySync primitive channel of Section 9.3. Although we do not use this connector to compose our microwave oven interface presented in Section 9.8.9, it is generally useful, interesting, and so complementary to the shift-lossy FIFO 1 channel, that it deserves to be mentioned here.</p><p>The connector in Fig. <ref type="figure" target="#fig_11">11a</ref> is composed out of a LossySync channel and a FIFO 1 channel. It, too, behaves as a lossy FIFO 1 channel, but contrary to the shift-lossy FIFO 1 Fig. <ref type="figure" target="#fig_1">12</ref>. A sequencer with reset. channel of Section 9.8.3, its data-loss policy favors retaining older buffer values over newer arrivals. We call this connector/channel overflow-lossy FIFO 1 and use the graphical symbol in Fig. <ref type="figure" target="#fig_11">11b</ref> to represent it. The dashed source-side half of the box representing the buffer of this channel symbol suggests that when its buffer is full, the newer arrivals simply "overflow" and are lost.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.8.5.">Sequencer with reset</head><p>Fig. <ref type="figure" target="#fig_1">12</ref> shows yet another generally useful connector that uses the exclusive router of Section 9.8.1. This connector behaves almost the same as our sequencer of Section 9.4.4. As long as no input value is available on its reset node, the exclusive router following the FIFO 1 channel that contains the token has no choice but to "decide" to forward the token through its upper output node down the chain, as if it were a simple Sync channel. This makes the transfer of the token conditional only on the availability of a ready consumer on the respective output node of the sequencer connector, exactly as in the case of the sequencer of Section 9.4.4.</p><p>When an input value is available on the reset node of this connector, the exclusive router following the token can allow it to "escape" the sequence chain through its lower output node back to the leftmost FIFO 1 channel, regardless of whether or not a ready consumer is available on its corresponding output node of the sequencer connector. This "resets" the sequencer to restart its sequence from the left. Observe that a race condition between reset and a ready sequenced output is non-deterministically resolved by the exclusive router.</p><p>The sequencer in Fig. <ref type="figure" target="#fig_1">12</ref> has 4 output nodes and thus repeats a sequence of length 4. Clearly, just as the case for the sequencer of Section 9.4.4, the constructor of this connector can be parameterized to instantiate a sequencer that repeats a sequence of any (finite) size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.8.6.">Cycler</head><p>The connector in Fig. <ref type="figure" target="#fig_12">13</ref> is called cycler. It uses three instances of the constant replacer connector of Section 9.5, in this case, initialized with constant values High, Med and Low, respectively. It also uses an exclusive router, a ternary version of the sequencer with reset of Section 9.8.5, and a shift-lossy FIFO 1 channel (of Section 9.8.3). The exclusive router here has three output nodes. This ternary router is obtained by a simple composition of two (binary) exclusive routers of Fig. <ref type="figure" target="#fig_9">9a</ref>, where one of the output nodes of one is connected with a Sync channel to the input node of the other. The cycler connector behaves as follows. The first input value through its node B places the value High in its shift-lossy FIFO 1 channel, ready for output through the V node of the cycler connector. Successive input values through B "cycle" through the remaining values in the sequence, Med and Low, restarting the cycle again from High, and make each value available, in turn, for output through V, by overriding the previous contents of the shiftlossy FIFO 1 channel. Whenever a value is consumed through V, the sequencer resets the connector to restart the cycle from its leftmost, High, value.</p><p>Clearly, the constructor of this connector can be parameterized such that it takes a (finite) list of values to create a cycler instance of the proper size, initialized with exactly those values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.8.7.">Valves</head><p>Fig. <ref type="figure" target="#fig_13">14a</ref> shows a connector that behaves as a valve. <ref type="foot" target="#foot_1">3</ref> It uses two exclusive routers and three FIFO 1 channels, two of which are initialized to contain token values X and O. As long as there is no value available on the input node i of this valve connector, values can flow from its node c to node d; the "valve" is initially open. The first input value through i, say a token value Y, causes the upper SyncDrain channel in this connector to consume the X token, as Y moves to fill the (upper) empty FIFO 1 channel. As long as the two FIFO 1 channels on the left of this connector are full, no data can flow between c and d: the valve is closed. A second input value through the node i allows the lower SyncDrain channel to consume the Y token, while this second value itself fills the buffer of the FIFO 1 channel on the right. Now the connector configuration is back to its original state and the valve is open again. In this way, successive values through the input node i alternately close and open the valve, enabling and disabling the flow of data from c to d, without any data loss.</p><p>The valve in Fig. <ref type="figure" target="#fig_13">14b</ref> is the same as the one in Fig. <ref type="figure" target="#fig_13">14a</ref>, except that it is initially closed. Successive values through its input node i alternately open and close this valve.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.8.8.">Value menu</head><p>The connector in Fig. <ref type="figure" target="#fig_14">15</ref> uses an initially closed valve and a cycler initialized with the parameter vector High, Med, Low. Initially, values on node B are lost, because the valve is closed, until an input value through A, say a, "activates" this connector. The token a first opens the valve, and then passes through the valve to kick the cycler, causing it to make High available as the output value of the connector. Arrival of another value on A before an input value on D is unacceptable for this connector; the environment must ensure that input to the nodes A and D alternate. Once thus activated, input tokens through B bump the cycler to make the sequence of values in its list available as the output of the connector. The actual output of the "current value" of the connector through the node V is possible only when a token, say d, arrives through the node D. The token d allows the output of the connector's current value and simultaneously closes the valve, disabling the connector. Observe that the output of its value also resets the cycler to start again with the first item in its list.</p><p>A race condition is possible when two tokens are simultaneously available on the nodes A and B. In this case, the mixed node at the sink of the LossySync channel nondeterministically resolves the race condition. However, this resolution is not symmetric: if the A token is selected, then the B token is lost and the value menu connector will have High as its current value. On the other hand, if the B token is selected, then the A token is not lost and it will subsequently bump the cycler to set the current value of the value menu connector to Med. While this asymmetric behavior may be a "bug" or a "feature" of this connector when used in different environments, in the context of our intended application, it causes no problem (see Section 9.8.9). It is, of course, possible to eliminate this asymmetric aspect of the behavior of our connector, at the cost of a few more channels (essentially, an exclusive router, a SyncDrain and some Sync channels), but we prefer our simpler connector here because it is sufficient for our purpose. 9.8.9. Composing the microwave interface Fig. <ref type="figure" target="#fig_15">16</ref> shows the composition of the interface of a simple microwave oven. Physically, this interface consists of four special-purpose buttons, plus a numeric input device. The four buttons are Time, Defrost, Power, and Start. The output of this interface is a pair of values indicating the radiation-time (Time node) and the power-setting (Power node) that are to be fed to the microwave engine. This interface allows an end-user to first press one of the two buttons Time or Defrost (if both are pressed, the interface selects one non-deterministically). Pressing the Time button indicates that both radiation-time and power-setting will be specified explicitly. Pressing the Defrost button, on the other hand, indicates that the microwave oven is to operate in its defrost mode. In this case, the enduser is expected to enter the weight of the item that is to be defrosted and the microwave oven is expected to calculate the proper radiation-time and power-setting automatically. When required, the same numeric input device is used to explicitly enter time as well as weight. Explicit power setting, when required, must be selected from a menu of the three alternative values High, Med, and Low, by successively pressing the power button to cycle through them. Once the proper selections are made and the values are entered, the end-user presses the Start button to confirm them and start the microwave engine.</p><p>Our interface in Fig. <ref type="figure" target="#fig_15">16</ref> uses four generic button components, a defrost calculator component, and a weight/time input component. These components are shown as solidcolor boxes in Fig. <ref type="figure" target="#fig_15">16</ref>. A button component is expected to interact with its corresponding physical button and produce a single token through its output node every time its button is pressed. The defrost calculator component has one input and two output nodes. Whenever a value is available on its input node, it consumes it and interprets it as a weight value. It then proceeds to compute the appropriate radiation-time and power-setting for defrosting this weight and makes them available through its respective output nodes. The weight/time input component has two input and a single output nodes. Availability of a token on one of its input nodes (the upper one in Fig. <ref type="figure" target="#fig_15">16</ref>) activates this component to interact with the end-user and obtain a weight (e.g., in 100 g incremental units). A token through the other input node (the lower one in the figure) activates the component to interact with the enduser to obtain a radiation-time (e.g., in minutes and seconds). If tokens are available on both of its input nodes (a case that does not arise in our context) then the component nondeterministically consumes one and acts accordingly. The component eventually makes the value it obtains through its interaction with the end-user available through its output node. The core of the interface in Fig. <ref type="figure" target="#fig_15">16</ref> is a four-step sequencer connector that produces tokens on its output nodes from top to bottom. In its first step, it enables the selector connector to let the user press one of the two buttons Defrost or Time. Its second step, allows the user to press the Start button. The last two steps of the sequencer allow the consumption of the two output values produced by this interface, in any order. To accomplish this, the Time and Power output nodes are connected to the last two nodes of the sequencer by a variant of the write-cue regulator connector of Section 9.4.1.</p><p>In the first step of the sequencer, pressing the Defrost button enables the weight/time input component to produce a weight, and places a token in the top FIFO 1 channel to allow the proper disposition of the eventual (weight) output of this component as the input for the defrost calculator component. Similarly, pressing the Time button enables the weight/time input component to produce a time, and places a token in the bottom FIFO 1 channel to allow the activation of the power value menu connector after the (time) output of the weight/time input component is available. Observe the use of the barrier synchronization construct of Section 9.4.2 in the coordination of the output of the weight/time input component.</p><p>Pressing the Start button has no effect unless the sequencer is in its second step and the lower exclusive router in the figure can dispose of its token one way or the other. If Defrost was pressed in the first step, this exclusive router can dispose of its token as soon as the (weight) output of the weight/time input component is available. On the other hand, if Time was pressed in the first step, this exclusive router can dispose of its (Start) token only by deactivating the power value menu connector, which implies some value is available through its value output node. In the interval between the pressing of the two buttons Time and Start, the end-user has the option of pressing the Power button to cycle through the three settings of the power value menu. Observe that a default value (of High) is available for output by this value menu connector as soon as it is activated.</p><p>An aspect of the interface that is not reflected in our connector shown in Fig. <ref type="figure" target="#fig_15">16</ref> is its display. One can assume that there is a built-in display under the control of the weight/time input component, and connect a separate display to show the current setting of the power menu connector. The race condition mentioned in Section 9.8.8 is possible in this environment only if the end-user presses the Power button exactly when the (time) output of the weight/time input component is available. Assuming that the power setting display shows a value only while the menu connector is enabled, it is reasonable to expect that, normally, the user presses the power button only after this time-output is available (to enable the menu connector). When the Power button is pressed at the same time that the time-output is available, the non-deterministic resolution of the race condition in the menu connector either ignores the pressing of the Power button (as if the menu connector is not activated yet) or behaves as if the Power button was pressed immediately after the menu connector was activated (bumping the power setting to Med). Both of these alternatives are acceptable in this situation.</p><p>This example shows the ease with which a coordinator for such non-trivial concurrent behavior can be composed out of "ignorant" components and connectors in Reo. While the generality of the value menu connector of Section 9.8.8 may be somewhat questionable, there is no question that the connectors described in Section 9.8.1 through 9.8.7 are generic and useful in a wide variety of applications. The button components used here are also generic. The only application specific entities in this example are the defrost calculator and to a lesser extent, the weight/time input component. Although they are clearly application specific, these components are "ignorant" of the environment in which they cooperate with each other and other entities to enact the coordinated protocol of their collective behavior.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">Conclusion</head><p>The operational interface that is inherent in the Abstract Data Type model and object oriented programming introduces two very different concepts for (1) entities, and (2) the mechanism of their composition. To their outside world, entities are what their interfaces advertise them to be: a set of operations. The mechanism that composes entities is based on performing the operations of other entities. This makes composition endogenous (i.e., an entity internally decides what operations of which other entities to perform) and relies on rather strong assumptions about the environment (i.e., the actual availability of appropriate other entities to support those operations with their expected semantics). Unlike the ADT model, main-stream object oriented models do not offer any formal semantics in their object/class interfaces. The purely syntactic nature of their interfaces becomes the weakest link in the reliability of the assumptions that underlie the validity of each composition: unless the entity that invokes the operation knows the entity whose operation it invokes rather intimately, the semantics that one assumes may be different than what the other guarantees; even subtle differences here can sabotage a composition. Furthermore, the composition of two objects does not produce another object.</p><p>Components are expected to be independent commodities, viable in their binary forms in the (not necessarily commercial) marketplace, developed, offered, exploited, deployed, integrated, maintained, and evolved by separate autonomous organizations in mutually unknown and unknowable contexts, over very long spans of time. The level of intimacy that is implicitly required of objects that compose by invoking each other's methods, is simply too unrealistic in the world of such components. Component models that rely on (variations of) object oriented programming (e.g., components as fortified collections of objects) and its composition mechanism of method invocation must, on the one hand, ameliorate its inherent endogenous rigidity (e.g., by intercepting, interpreting, retargeting, or suppressing messages), and on the other hand yield quite brittle compositions. Composition of two components, in such models, does not by itself yield another component.</p><p>Abstract Behavior Types presented in this paper offer a simpler and far more flexible model of components-and of their composition. An ABT is a mathematical construct that defines and/or constrains the behavior of an entity without any mention of operations or data types that may be used to realize that behavior. This puts the ABT model at a higher-level of abstraction than ADTs and makes it more suitable for components. The endogenous nature of their composition means that it is not possible for a third party, e.g., an entity in the environment, to compose two objects (or two ADTs) "against their own will" so to speak. In contrast, the composition of any two ABTs is always well-defined and yields another ABT.</p><p>The building blocks in the mathematical construction of the ABT model are the (generally) infinite streams that represent the externally observable sequences of I/O events that occur at an entity's interaction points (e.g., ports) through which it exchanges data with its environment. Such infinite structures, and thus the ABT model, naturally lend themselves to coalgebraic techniques and the coinduction reasoning principle. The ABT model supports a much looser coupling than is possible with ADT and is inherently amenable to exogenous coordination. We advocate both of these as highly desirable, if not essential, properties for component based systems.</p><p>The ABT model provides a simple formal foundation for definition and composition of components. However, direct composition of component ABTs does not generally provide much of an opportunity to systematically wield exogenous coordination. Reo is a channelbased exogenous coordination model that can be used as a glue language for dynamic compositional construction of component connectors in (non-)distributed and/or mobile systems. Connector construction in Reo can be seen as an application of the ABT model. A channel in Reo is just a special kind of an atomic connector (i.e., component): whereas components and connectors offer one or more ports to exchange information with their environment, a channel is an ABT that offers exactly two ports (i.e., its channel-ends) for interaction with its environment. Because all Reo connectors are ABTs, the semantics of channel composition in Reo can be defined in terms of ABT composition.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Abstract Data Types for stack and queue.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Representation of nodes in Reo.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>α, a</head><label>a</label><figDesc>Filter(P) β, b ≡ β(0) = α(0) ∧ b(0) = a(0) ∧ α , a Filter(P) β , b if α(0) P α , a Filter(P) β, b otherwise.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Examples of connectors in Reo.</figDesc><graphic coords="29,88.32,106.40,352.44,129.10" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Constant replacer.</figDesc><graphic coords="31,152.40,106.98,224.28,173.52" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Computing the Fibonacci series.</figDesc><graphic coords="33,143.88,108.27,240.72,82.22" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Dining philosophers in Reo.</figDesc><graphic coords="34,103.68,106.43,353.40,176.11" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Inside of a chopstick.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Adapting Philos to appear as Phil.</figDesc><graphic coords="37,205.32,107.51,117.60,85.03" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. An exclusive router and a selector.</figDesc><graphic coords="38,177.24,106.45,205.92,168.05" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. Shift-lossy FIFO 1 channel.</figDesc><graphic coords="39,100.32,107.84,328.32,96.70" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. Overflow-lossy FIFO 1 channel.</figDesc><graphic coords="39,109.32,244.81,309.96,60.41" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 13 .</head><label>13</label><figDesc>Fig. 13. A cycler connector.</figDesc><graphic coords="41,150.84,106.81,226.68,144.65" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 14 .</head><label>14</label><figDesc>Fig. 14. Valve connectors.</figDesc><graphic coords="42,103.20,106.23,353.76,146.30" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig. 15 .</head><label>15</label><figDesc>Fig. 15. A value menu connector.</figDesc><graphic coords="42,105.24,293.36,350.28,104.26" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Fig. 16 .</head><label>16</label><figDesc>Fig. 16. The interface for a simple microwave oven.</figDesc><graphic coords="44,103.68,108.15,352.80,264.38" type="bitmap" /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>The term "Abstract Behavior Type" is a variation of the term "Abstract Behavioral Type" proposed by F. de Boer for a related concept.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>Different valve connectors are presented in<ref type="bibr" target="#b2">[3]</ref>. This particular, more elegant connector circuit is due to Andrei Popescu of Nokia Research Center who is also a Ph.D. student at the Computer Science Department of the University of Helsinki.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>I am thankful for the fruitful discussions and the collaboration of all my colleagues at CWI, especially Jan Rutten, Marcello Bonsangue, and Frank de Boer, who have contributed to the ideas behind abstract behavior types. I am grateful for the attention and the creative influence of the participants in the ACG seminar series of Jaco de Bakker at CWI, where various aspects of Reo were presented and discussed in 2001 and 2002. I immensely appreciate the work of my colleagues involved in the development and implementation of Reo. I am particularly grateful for Jan Rutten's keen interest in Reo and his inspiring work on a coalgebraic formal semantics for it; and for his and Christel Baier's stimulating collaborations on the development of constraint automata for the operational semantics and model-checking of Reo-and more.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The IWIM model for coordination of concurrent activities</title>
		<author>
			<persName><forename type="first">F</forename><surname>Arbab</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Coordination Languages and Models</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Ciancarini</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Hankin</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1061</biblScope>
			<biblScope unit="page" from="34" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">What do you mean, coordination?</title>
		<author>
			<persName><forename type="first">F</forename><surname>Arbab</surname></persName>
		</author>
		<ptr target="http://www.cwi.nl/NVTI/Nieuwsbrief/nieuwsbrief.html" />
	</analytic>
	<monogr>
		<title level="j">Bulletin of the Dutch Association for Theoretical Computer Science NVTI</title>
		<imprint>
			<biblScope unit="page" from="11" to="22" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A channel-based coordination model for component composition</title>
		<author>
			<persName><forename type="first">F</forename><surname>Arbab</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Centrum voor Wiskunde en Informatica</title>
		<imprint>
			<biblScope unit="volume">413</biblScope>
			<date type="published" when="1098-02">1098. February 2002</date>
			<pubPlace>SJ Amsterdam, The Netherlands</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep. SEN-R0203</note>
	<note>Kruislaan</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Reo: A channel-based coordination model for component composition</title>
		<author>
			<persName><forename type="first">F</forename><surname>Arbab</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Structures in Computer Science</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1" to="38" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Coordination through channel composition</title>
		<author>
			<persName><forename type="first">F</forename><surname>Arbab</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Mavaddat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Coordination Languages and Models: Proc. Coordination</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Arbab</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Talcott</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2002">2002. 2002</date>
			<biblScope unit="volume">2315</biblScope>
			<biblScope unit="page" from="21" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Recent Trends in Algebraic Development Techniques</title>
		<author>
			<persName><forename type="first">F</forename><surname>Arbab</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rutten</surname></persName>
		</author>
		<ptr target="http://www.cwi.nl/ftp/CWIreports/SEN/SEN-R0216.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of 16th International Workshop on Algebraic Development Techniques, WADT 2002</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">P M</forename><surname>Wirsing</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Hennicker</surname></persName>
		</editor>
		<meeting>16th International Workshop on Algebraic Development Techniques, WADT 2002</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2755</biblScope>
			<biblScope unit="page" from="35" to="56" />
		</imprint>
	</monogr>
	<note>A coinductive calculus of component connectors</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A logical interface description language for components</title>
		<author>
			<persName><forename type="first">F</forename><surname>Arbab</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>De Boer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bonsangue</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Coordination Languages and Models: Proc. Coordination 2000</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Porto</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G.-C</forename><surname>Roman</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1906</biblScope>
			<biblScope unit="page" from="249" to="266" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A coordination language for mobile components</title>
		<author>
			<persName><forename type="first">F</forename><surname>Arbab</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>De Boer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bonsangue</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SAC&apos;00</title>
		<meeting>ACM SAC&apos;00</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="166" to="173" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">MoCha: A framework for coordination using mobile channels</title>
		<author>
			<persName><forename type="first">F</forename><surname>Arbab</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>De Boer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bonsangue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">G</forename><surname>Scholten</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Centrum voor Wiskunde en Informatica, Kruislaan</title>
		<imprint>
			<biblScope unit="volume">413</biblScope>
			<date type="published" when="1098-12">1098. December 2001</date>
			<pubPlace>The Netherlands</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep. SEN-R0128</note>
	<note>SJ Amsterdam</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Modeling component connectors in Reo by Constraint Automata</title>
		<author>
			<persName><forename type="first">F</forename><surname>Arbab</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Baier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J M M</forename><surname>Rutten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sirjani</surname></persName>
		</author>
		<ptr target="http://www.cwi.nl/ftp/CWIreports/SEN/SEN-R0304.pdf" />
	</analytic>
	<monogr>
		<title level="s">Electronic Notes in Theoretical Computer Science (ENTCS)</title>
		<imprint>
			<biblScope unit="volume">97</biblScope>
			<biblScope unit="page" from="25" to="46" />
			<date type="published" when="2004">2004</date>
			<publisher>Elsevier</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><surname>Barbosa</surname></persName>
		</author>
		<title level="m">Components as coalgebras</title>
		<meeting><address><addrLine>Braga, Portugal</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
		<respStmt>
			<orgName>Universidade do Minho</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><surname>Barringer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kuiper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<title level="m">Proceedings of Thirteenth Annual ACM Symposium on Principles of Programming Languages</title>
		<meeting>Thirteenth Annual ACM Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="173" to="183" />
		</imprint>
	</monogr>
	<note>A really abstract current model and its temporal logic</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Composing crosscutting concerns using composition filters</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bergmans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Aksit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="51" to="57" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A transition system semantics for the control-driven coordination language Manifold</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bonsangue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Arbab</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>De Bakker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rutten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Scutellá</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Zavattaro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">240</biblScope>
			<biblScope unit="page" from="3" to="47" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">A logical basis for component-based system engineering</title>
		<author>
			<persName><forename type="first">M</forename><surname>Broy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000-11">November 2000</date>
		</imprint>
		<respStmt>
			<orgName>Technische Universität München</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">The algebra of stream processing functions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Broy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Stefanescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">258</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Specification and development of interactive systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Broy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Stolen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Monographs in Computer Science</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<date type="published" when="2001">2001</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Ptolemy: a framework for simulating and prototyping heterogeneous systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Buck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Messerschmitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Computer Simulation (special issue)</title>
		<imprint>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1990-01">January 1990</date>
		</imprint>
	</monogr>
	<note>Simulation Software Development</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<author>
			<persName><forename type="first">L</forename><surname>Burdy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Cheon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Cok</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ernst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kiniry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">T</forename><surname>Leavens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R M</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Poll</surname></persName>
		</author>
		<ptr target="http://www.elsevier.com/locate/entcs" />
	</analytic>
	<monogr>
		<title level="m">Eighth International Workshop on Formal Methods for Industrial Critical Systems, FMICS 03</title>
		<title level="s">Electronic Notes in Theoretical Computer Science (ENTCS)</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Arts</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><surname>Fokkink</surname></persName>
		</editor>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">80</biblScope>
			<biblScope unit="page" from="73" to="89" />
		</imprint>
	</monogr>
	<note>An overview of JML tools and applications</note>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Url</forename><surname>Corba</surname></persName>
		</author>
		<ptr target="http://www.omg.org" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Towards a uniform topological treatment of streams and functions on streams</title>
		<author>
			<persName><forename type="first">J</forename><surname>De Bakker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kok</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th International Colloquium on Automata, Languages and Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">W</forename><surname>Brauer</surname></persName>
		</editor>
		<meeting>the 12th International Colloquium on Automata, Languages and Programming<address><addrLine>Nafplion</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1985">1985</date>
			<biblScope unit="volume">194</biblScope>
			<biblScope unit="page" from="140" to="148" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A compositional model for confluent dynamic data-flow networks</title>
		<author>
			<persName><forename type="first">F</forename><surname>De Boer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bonsangue</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. International Symposium of the Mathematical Foundations of Computer Science, MFCS</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Nielsen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Rovan</surname></persName>
		</editor>
		<meeting>International Symposium of the Mathematical Foundations of Computer Science, MFCS</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1893</biblScope>
			<biblScope unit="page" from="212" to="221" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<author>
			<persName><forename type="first">F</forename><surname>De Boer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bonsangue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Graf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Methods for Components and Objects</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">P</forename><surname>De Roever</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2852</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Enterprise</forename><surname>Javabeans</surname></persName>
		</author>
		<ptr target="http://java.sun.com/products/ejb" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Coordination languages and their significance</title>
		<author>
			<persName><forename type="first">D</forename><surname>Gelernter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Carriero</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communication of the ACM</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="97" to="107" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Gore</surname></persName>
		</author>
		<title level="m">Object Structures: Building Object-Oriented Software Components</title>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Grimes</surname></persName>
		</author>
		<title level="m">Professional DCOM Programming</title>
		<imprint>
			<publisher>Wrox Press</publisher>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><surname>Gumm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schröder</surname></persName>
		</author>
		<title level="m">Covarieties and complete covarieties</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">36</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Contracts: Specifying behavioural compositions in object-oriented systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Helm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Holland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gangopadhyay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings OOPSLA/ECOOP &apos;90</title>
		<meeting>OOPSLA/ECOOP &apos;90</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="169" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A formal method for the systematic reuse of specification components</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hennicker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wirsing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Methods of Programming</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">544</biblScope>
			<biblScope unit="page" from="49" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Modeling dynamic component interfaces</title>
		<author>
			<persName><forename type="first">F</forename><surname>Huber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rausch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Rumpe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Technology of Object-Oriented Languages and Systems, TOOLS &apos;98</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Singh</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Meyer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Gil</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Mitchell</surname></persName>
		</editor>
		<meeting>Technology of Object-Oriented Languages and Systems, TOOLS &apos;98</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="58" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Coalgebraic specifications and models of deterministic hybrid systems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Jacobs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Algebraic Methods and Software Technology</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Wirsing</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Nivat</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1101</biblScope>
			<biblScope unit="page" from="520" to="535" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Behaviour-refinement of object-oriented specifications with coinductive correctness proofs</title>
		<author>
			<persName><forename type="first">B</forename><surname>Jacobs</surname></persName>
		</author>
		<idno>CSI-R9618</idno>
	</analytic>
	<monogr>
		<title level="m">Also in the Proceedings of TAPSOFT &apos;97</title>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
		<respStmt>
			<orgName>Computing Science Institute, University of Nijmegen</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Inheritance and cofree constructions</title>
		<author>
			<persName><forename type="first">B</forename><surname>Jacobs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Conference on Object-Oriented Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Cointe</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1098</biblScope>
			<biblScope unit="page" from="210" to="231" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">A tutorial on (co)algebras and (co)induction</title>
		<author>
			<persName><forename type="first">B</forename><surname>Jacobs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rutten</surname></persName>
		</author>
		<ptr target="http://www.cs.kun.nl/~bart/PAPERS/JR.ps.Z" />
	</analytic>
	<monogr>
		<title level="j">Bulletin of EATCS</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="page" from="222" to="259" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<author>
			<persName><forename type="first">B</forename><surname>Jacobs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Moss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename></persName>
		</author>
		<ptr target="www.elsevier.com/locate/entcs" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First International Workshop on Coalgebraic Methods in Computer Science, CMCS &apos;98</title>
		<title level="s">Electronic Notes in Theoretical Computer Science (ENTCS)</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Reichel</surname></persName>
		</editor>
		<editor>
			<persName><surname>Rutten</surname></persName>
		</editor>
		<meeting>the First International Workshop on Coalgebraic Methods in Computer Science, CMCS &apos;98</meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">11</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title/>
		<author>
			<persName><surname>Jini</surname></persName>
		</author>
		<ptr target="http://www.sun.com/jini" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Semantic models for parallel computation in data flow, logic-and object-oriented programming</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kok</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989-05">May 1989</date>
			<pubPlace>Amsterdam</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Vrije Universiteit</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">JML: notations and tools supporting detailed design in Java</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">T</forename><surname>Leavens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R M</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Poll</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ruby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Jacobs</surname></persName>
		</author>
		<ptr target="ftp://ftp.cs.iastate.edu/pub/techreports/TR00-15/TR.ps.gz" />
	</analytic>
	<monogr>
		<title level="m">OOPSLA 2000 Companion, ACM</title>
		<meeting><address><addrLine>Minneapolis, MN</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="105" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">An overview of the ptolemy project</title>
		<author>
			<persName><forename type="first">E</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Messerschmitt</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
		<respStmt>
			<orgName>Dept. of Electrical Engineering and Computer Sciences, University of California at Berkeley</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep</note>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Dataflow process networks</title>
		<author>
			<persName><forename type="first">E</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Parks</surname></persName>
		</author>
		<ptr target="http://ptolemy.eecs.berkeley.edu/publications/papers/95/processNets" />
	</analytic>
	<monogr>
		<title level="j">Proceedings of the IEEE</title>
		<imprint>
			<biblScope unit="volume">83</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="773" to="799" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">A framework for comparing models of computation</title>
		<author>
			<persName><forename type="first">E</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1217" to="1229" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">An extended static checker for modula-3</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R M</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Compiler Construction CC&apos;98</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Koskimies</surname></persName>
		</editor>
		<meeting><address><addrLine>Lisbon</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1383</biblScope>
			<biblScope unit="page" from="302" to="305" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">ESC/java user&apos;s manual</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R M</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Saxe</surname></persName>
		</author>
		<idno>SRC-TN-2000-002</idno>
		<ptr target="http://www.hpl.hp.com/techreports/Compaq-DEC/SRC-TN-2000-002.html" />
		<imprint>
			<date type="published" when="2000-10-15">October 15, 2000</date>
		</imprint>
		<respStmt>
			<orgName>Hewlett Packard Laboratories</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">S</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Professional Jini, Mass Market Paperback</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">A behavioral notion of subtyping</title>
		<author>
			<persName><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wing</surname></persName>
		</author>
		<ptr target="http://www.acm.org/pubs/articles/journals/toplas/1994-16-6/p1811-liskov/p1811-liskov.pdf" />
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1811" to="1841" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title level="m" type="main">Applying Enterprise JavaBeans: Component-Based Development for the J2EE Platform, Java Series, Enterprise Edition</title>
		<author>
			<persName><forename type="first">V</forename><surname>Matena</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Stearns</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<author>
			<persName><forename type="first">N</forename><surname>Mehta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sirjani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Arbab</surname></persName>
		</author>
		<ptr target="http://www.cwi.nl/ftp/CWIreports/SEN/SEN-R0309.pdf" />
		<title level="m">Effective modeling of software architectural assemblies using Constraint Automata</title>
		<meeting><address><addrLine>The Netherlands</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-10">October 2003</date>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep. SEN-R0309</note>
	<note>Centrum voor Wiskunde en Informatica, Kruislaan 413, 1098 SJ Amsterdam</note>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">Eiffel: The Language</title>
		<author>
			<persName><forename type="first">B</forename><surname>Meyer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<title level="m" type="main">Reusable Software: The Base Object-Oriented Component Libraries</title>
		<author>
			<persName><forename type="first">B</forename><surname>Meyer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Elements of interaction</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="78" to="89" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">A calculus of mobile processes, parts I and II</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Parrow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">100</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="77" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Coalgebraic logic</title>
		<author>
			<persName><forename type="first">L</forename><surname>Moss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Pure and Applied Logic</title>
		<imprint>
			<biblScope unit="volume">96</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="277" to="317" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">On the foundations of corecursion</title>
		<author>
			<persName><forename type="first">L</forename><surname>Moss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Danner</surname></persName>
		</author>
		<ptr target="http://www.math.indiana.edu/home/moss/papers/corecursion-final.ps.gz" />
	</analytic>
	<monogr>
		<title level="j">Logic Journal of the IGPL</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="231" to="257" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<author>
			<persName><forename type="first">O</forename><surname>Nierstrasz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Achermann</surname></persName>
		</author>
		<title level="m">A calculus for modeling software components</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="339" to="360" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">S</forename><surname>Oaks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wong</surname></persName>
		</author>
		<editor>Nutshell, O&apos;Reilly &amp; Associates</editor>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Mathematical Techniques for Analyzing Concurrent and Probabilistic Systems</title>
		<author>
			<persName><forename type="first">P</forename><surname>Panangaden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">CRM Monograph Series</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Van Breugel</surname></persName>
		</editor>
		<idno type="ISSN">1065-8599</idno>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>American Mathematical Society</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Coordination models and languages</title>
		<author>
			<persName><forename type="first">G</forename><surname>Papadopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Arbab</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Computers-The Engineering of Large Systems</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Zelkowitz</surname></persName>
		</editor>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="page" from="329" to="400" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<monogr>
		<title level="m" type="main">Making components move: A separation of concerns approach</title>
		<author>
			<persName><forename type="first">D</forename><surname>Pattinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wirsing</surname></persName>
		</author>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="487" to="507" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">An approach to object semantics based on terminal coalgebras</title>
		<author>
			<persName><forename type="first">H</forename><surname>Reichel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Structures in Computer Science</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="129" to="152" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">CS-R9652, Centrum voor Wiskunde en Informatica</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rutten</surname></persName>
		</author>
		<ptr target="http://www.cwi.nl/ftp/CWIreports/AP/CS-R9652.ps.Z" />
	</analytic>
	<monogr>
		<title level="j">Kruislaan</title>
		<imprint>
			<biblScope unit="volume">413</biblScope>
			<date type="published" when="1098">1098. 1996</date>
			<pubPlace>SJ Amsterdam, The Netherlands</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep</note>
	<note>Universal coalgebra: A theory of systems</note>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Automata and coinduction (an exercise in coalgebra)</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rutten</surname></persName>
		</author>
		<ptr target="http://www.cwi.nl" />
	</analytic>
	<monogr>
		<title level="m">Also in the Proceedings of CONCUR &apos;98</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1466</biblScope>
			<biblScope unit="page" from="194" to="218" />
		</imprint>
	</monogr>
	<note>Report SEN-R9803, CWI</note>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Automata, power series, and coinduction: taking input derivatives seriously (extended abstract</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rutten</surname></persName>
		</author>
		<ptr target="http://www.cwi.nl" />
	</analytic>
	<monogr>
		<title level="m">Also in the Proceedings of ICALP &apos;99</title>
		<imprint>
			<date type="published" when="1999">1999. 1999</date>
			<biblScope unit="volume">1644</biblScope>
			<biblScope unit="page" from="645" to="654" />
		</imprint>
	</monogr>
	<note>Report SEN-R9901, CWI</note>
</biblStruct>

<biblStruct xml:id="b63">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Rutten</surname></persName>
		</author>
		<author>
			<persName><surname>Coalgebra</surname></persName>
		</author>
		<author>
			<persName><surname>Control</surname></persName>
		</author>
		<ptr target="http://www.cwi.nl" />
		<title level="m">Discrete Event Systems</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Boel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Stremersch</surname></persName>
		</editor>
		<imprint>
			<publisher>Kluwer</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page">2000</biblScope>
		</imprint>
	</monogr>
	<note>Report SEN-R9921, CWI</note>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Universal coalgebra: a theory of systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rutten</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">249</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="80" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Elements of stream calculus (an extensive exercise in coinduction</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rutten</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 17th Conf. on Mathematical Foundations of Programming Semantics</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Brookes</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Mislove</surname></persName>
		</editor>
		<meeting>of 17th Conf. on Mathematical Foundations of Programming Semantics<address><addrLine>Aarhus, Denmark; Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2001-05">May 2001. 2001</date>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page" from="23" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">An application of coinductive stream calculus to signal flow graphs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rutten</surname></persName>
		</author>
		<ptr target="http://www.cwi.nl/ftp/CWIreports/SEN/SEN-E0305.pdf" />
	</analytic>
	<monogr>
		<title level="m">Centrum voor Wiskunde en Informatica, Kruislaan 413, 1098 SJ Amsterdam</title>
		<meeting><address><addrLine>The Netherlands</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-10">October 2003</date>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep. SEN-E0305</note>
</biblStruct>

<biblStruct xml:id="b67">
	<monogr>
		<title level="m" type="main">Component connectors</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rutten</surname></persName>
		</author>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="page" from="73" to="87" />
		</imprint>
	</monogr>
	<note>Chapter 5</note>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">Asynchronous process calculi: the first-order and higher-order paradigms (tutorial)</title>
		<author>
			<persName><forename type="first">D</forename><surname>Sangiorgi</surname></persName>
		</author>
		<ptr target="http://www-sop.inria.fr/meije/personnel/Davide.Sangiorgi/mypapers.html" />
	</analytic>
	<monogr>
		<title level="m">Theoretical Computer Science 253</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<monogr>
		<title level="m" type="main">CORBA: Fundamentals and Programming, 1st edition</title>
		<author>
			<persName><forename type="first">J</forename><surname>Siegel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>John Wiley &amp; Sons Inc</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<monogr>
		<title level="m" type="main">Encapsulation and inheritance in object-oriented programming languages, OOPSLA &apos;86</title>
		<author>
			<persName><forename type="first">A</forename><surname>Snyder</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="38" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<monogr>
		<title level="m" type="main">Component Software-Beyond Object-Oriented Programming</title>
		<author>
			<persName><forename type="first">C</forename><surname>Szyperski</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<monogr>
		<title level="m" type="main">Reusable specification components</title>
		<author>
			<persName><forename type="first">M</forename><surname>Wirsing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hennicker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Breu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
		<respStmt>
			<orgName>Passau University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep. MIP-8817</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
