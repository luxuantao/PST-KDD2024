<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Message-Locked Encryption for Lock-Dependent Messages</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Martín</forename><surname>Abadi</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Microsoft Research Silicon Valley</orgName>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Santa Cruz</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Dan</forename><surname>Boneh</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ilya</forename><surname>Mironov</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Microsoft Research Silicon Valley</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ananth</forename><surname>Raghunathan</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Gil</forename><surname>Segev</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Message-Locked Encryption for Lock-Dependent Messages</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">DF9935BF621AA237D7A4F6236839594B</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T09:52+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Deduplication</term>
					<term>convergent encryption</term>
					<term>message-locked encryption</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Motivated by the problem of avoiding duplication in storage systems, Bellare, Keelveedhi, and Ristenpart have recently put forward the notion of Message-Locked Encryption (MLE) schemes which subsumes convergent encryption and its variants. Such schemes do not rely on permanent secret keys, but rather encrypt messages using keys derived from the messages themselves.</p><p>We strengthen the notions of security proposed by Bellare et al. by considering plaintext distributions that may depend on the public parameters of the schemes. We refer to such inputs as lock-dependent messages. We construct two schemes that satisfy our new notions of security for message-locked encryption with lock-dependent messages.</p><p>Our main construction deviates from the approach of Bellare et al. by avoiding the use of ciphertext components derived deterministically from the messages. We design a fully randomized scheme that supports an equality-testing algorithm defined on the ciphertexts.</p><p>Our second construction has a deterministic ciphertext component that enables more efficient equality testing. Security for lock-dependent messages still holds under computational assumptions on the message distributions produced by the attacker.</p><p>In both of our schemes the overhead in the length of the ciphertext is only additive and independent of the message length.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Deduplication, which eliminates redundant copies in user-provided data, is an important space-saving technique in communications and storage (see, for example, <ref type="bibr" target="#b28">[28,</ref><ref type="bibr" target="#b35">35,</ref><ref type="bibr" target="#b26">26]</ref>). Storage systems that rely on deduplication typically let the server have unfettered access to the clients' data. This set-up creates an obvious confidentiality problem, since the clients must trust the server with not only storing their documents but keeping them secret too.</p><p>The first solution for balancing confidentiality and efficiency in deduplication was described by Douceur et al. <ref type="bibr" target="#b18">[18]</ref> and called convergent encryption. According to this deterministic scheme, a message is encrypted under a message-derived key (a hash of the message) so that identical plaintexts are mapped to identical ciphertexts. After encrypting the message, the client uploads the ciphertext to the server, retaining the hash to allow later decryption. In the meantime, the server can recognize equal ciphertexts, storing only one copy of each: if two clients happen to upload the same file, the resulting ciphertexts will be identical and can be deduplicated. The clients need not coordinate their actions and might not even be aware of each other's existence. Implementations and variants of convergent encryption followed <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b25">25,</ref><ref type="bibr" target="#b30">30,</ref><ref type="bibr" target="#b33">33,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b0">1]</ref> but their precise security guarantees were never fully proven or even stated.</p><p>Message-Locked Encryption. Recently, Bellare, Keelveedhi, and Ristenpart <ref type="bibr" target="#b7">[7]</ref> brought much needed rigor into the area, by defining a new encryption primitive, Message-Locked Encryption (MLE), and several definitions that capture various aspects of MLE security. They also constructed and analyzed several schemes in their framework.</p><p>We briefly recall the definition of MLE and two security notions of privacy and tag integrity for MLE schemes introduced by Bellare et al. An MLE scheme encapsulates a standard (possibly randomized) symmetric-key encryption scheme where the encryption algorithm accepts a message m and a key k, and outputs a ciphertext c. The decryption algorithm reverses the process, recovering m from c given k. The scheme comes with a key derivation algorithm that, unlike a conventional key generation algorithm, is a deterministic function from m to k. It also includes a tag-generation algorithm that maps the ciphertext to a tag. Identical plaintexts result in equal tags. The corresponding ciphertexts, which may be randomized, are not necessarily equal. Tag integrity means that no computationally bounded adversary can trick the server into replacing a valid encryption with a ciphertext that does not decrypt to the same plaintext.</p><p>It is apparent that MLE, with its deterministic tag, cannot satisfy the standard notions of confidentiality (such as semantic security). Indeed, if the plaintexts can be feasibly enumerated, the adversary may always compute their tags and test them against that of the challenge ciphertext. A meaningful security guarantee can be achieved only if the input is sufficiently unpredictable. More concretely, in a CDA game (a chosen-distribution attack) the challenge consists either of a uniformly distributed string of bits or an encryption of a message drawn randomly from a distribution provided by the adversary. The security level is characterized by the distinguisher's running time, its advantage over a random guess, and the min-entropy of the distribution that the adversary is allowed to specify. A lower min-entropy requirement corresponds to a stronger security guarantee. This approach-basing security of the scheme on the assumption of unpredictability of the plaintexts-is similar to the theory of deterministic public-key encryption initiated by the work of Bellare, Boldyreva, and O'Neill <ref type="bibr" target="#b3">[4]</ref> (see also <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b5">5,</ref><ref type="bibr" target="#b12">12,</ref><ref type="bibr" target="#b19">19,</ref><ref type="bibr" target="#b24">24,</ref><ref type="bibr" target="#b32">32,</ref><ref type="bibr" target="#b29">29]</ref>).</p><p>Lock-Dependent Messages. In addition to the min-entropy requirement, there is another constraint on the adversarially chosen distribution of plaintexts implicit in the definition of MLE. If the adversary is allowed to specify a distribution of plaintexts, it may use the fact that the tags are deterministic for leaking unnecessary information on the messages (e.g., select a distribution that is concentrated on messages whose tags share a particular property, such as that they all start with a zero bit, or that the first bit of the tag reveals the first bit of the message). Doing so immediately gives the adversary a constant advantage in answering the challenge (of whether the output was a random string of bits or an encryption of a message drawn from the distribution). Similar attacks can be effective against any deterministic encryption scheme, where the adversary tailors the distribution to the scheme's public key. The common way of sidestepping this difficulty is to require that the distribution be chosen independently of the system parameters or, in the case of deterministic encryption, of the system's public key. More formally, the adversary must commit to the distribution of plaintexts before accessing the description of the system.</p><p>Since the parameters of the scheme are supposed to be publicly available, they must be included into the view of any realistic adversary. As soon as the adversary learns the parameters of the system and may influence, however indirectly, the distribution of plaintexts, the assumption of independence becomes false, voiding the security guarantees proven under this assumption.</p><p>In this paper we ask whether security guarantees can encompass also attacks that may depend on the scheme's parameters. Identifying the public parameters of an encryption scheme with a lock, we can paraphrase the problem addressed in this paper as follows:</p><p>Can message-locked encryption be secure for lock-dependent messages?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Our Contributions</head><p>In this paper we put forward two approaches for resolving this question in the affirmative, and provide schemes that are secure even for lock-dependent messages in realistic and rigorously defined adversarial models.</p><p>Our first approach is to avoid using tags that are derived deterministically from the messages. To this end, we design a fully randomized scheme that supports an equality-testing algorithm defined on the ciphertexts. We show that this enables us to satisfy a strong definition of security for an extension of the MLE notion, allowing the adversary to specify the distribution of the plaintexts adaptively, with no further restrictions on the distribution other than its min-entropy. Our construction is based on standard cryptographic tools in the random oracle model <ref type="bibr" target="#b8">[8]</ref> and on a natural variant of Canetti's entropy-based DDH assumption <ref type="bibr" target="#b13">[13]</ref>. The ciphertext overhead is only additive and polynomial in the security parameter.</p><p>Our second approach, on the other hand, continues using deterministic tags. Security for lock-dependent messages is guaranteed by limiting the computational power of the adversarial message distributions. (This approach is inspired by the recent work of Raghunathan, Segev, and Vadhan <ref type="bibr" target="#b29">[29]</ref> who proposed a similar adversarial model for deterministic public-key encryption.) Specifically, in the random oracle model, we consider adversaries that are allowed to choose the distribution of plaintexts adaptively, after seeing the scheme's parameters, subject to the condition that the distribution be efficiently samplable using at most q queries to the random oracle, where q is a pre-determined parameter. Our construction can be based on any semantically secure encryption scheme. Its overhead, defined as the increase in the length of the ciphertext, is additive and depends only on the security parameter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Paper Organization</head><p>In Section 2, we give a high-level overview of the fully randomized scheme and the deterministic scheme that we construct in this paper. In Section 3, we introduce a few preliminaries required to present our results. In Section 4, we formally define our notion of message-locked encryption for lock-dependent messages. In Section 5, we present the fully randomized scheme. In Section 7, we conclude and mention several interesting directions for further research. Because of space limitations all proofs and some definitions are deferred to the full version.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Overview of Our Schemes</head><p>In what follows we provide a high-level overview of the main ideas that underlie our schemes. Intuitively, constructing MLE schemes requires solving two technical challenges. We must design an algorithm that encrypts messages under a key that is highly correlated (via the key derivation algorithm) with the message and still remains secure. Secondly, the part of the ciphertext that allows the equality test must not leak any information about messages sampled from an adversarially chosen min-entropy distribution even given the public parameters. Construction 1: A Fully Randomized Scheme. An encryption of a message m in our first scheme consists of three components: a "payload" which is an encryption of m using some underlying randomized encryption scheme, a tag, and a proof of consistency showing that the payload and the tag correspond to the same message. A tag for a message m is computed as τ = g r , g r•h(m) , where g is a generator of a bilinear group, h is a sufficiently strong collision-resistant function, and r is chosen uniformly at random. Given two tags τ 1 = (g 1 , h 1 ) and τ 2 = (g 2 , h 2 ), the equality-testing algorithm computes the pairings ê(g 1 , h 2 ) and ê(g 2 , h 1 ), which match if the tags were derived from the same message (or if a non-trivial collision was found for h). The fact that tags do not reveal any more information than is necessary for the scheme's functionality is based on combining a variant of Canetti's entropy-based DDH assumption <ref type="bibr" target="#b13">[13]</ref>, and the concept of seed-dependent condensers, recently introduced by Dodis, Ristenpart, and Vadhan <ref type="bibr" target="#b17">[17]</ref>. A similar idea for equality testing (without hashing) was explored by Yang et al. <ref type="bibr" target="#b34">[34]</ref>, who designed public-key encryption schemes that support equality testing but offer a significantly weaker notion of security (only one-wayness).</p><p>As for the payload and the consistency proof, a natural approach would be to simply encrypt m using its hash h(m) as a key (as in <ref type="bibr" target="#b7">[7]</ref>), and provide a NIZK proof of consistency. This approach, however, seems to fail as we must use an encryption scheme for which it is secure to encrypt a message m under the key h(m). All existing constructions satisfying this property rely on the random oracle paradigm, which rules out using NIZK proofs as the language under consideration is no longer in NP.</p><p>We can resolve this issue with a cut-and-choose protocol applied to the encryption of the message. Naïvely, such a protocol would inflate the size of the ciphertext. However, a delicate combination of a secret-sharing scheme and a cut-and-choose technique enables us to realize an encryption scheme with a ciphertext overhead that is only additive and independent of the message length.</p><p>Specifically, the payload in our ciphertext consists of a randomized encryption E s (m; r 1 ) of m under a uniformly chosen key s, a commitment Commit(s t) to s and a uniformly chosen key t, an ElGamal encryption g r2 , g r2•h(m) • t of t using h(m) as a key, and a circular-secure encryption (r 3 , H(r 3 t) + s) of s using t as a key. The circular-secure encryption scheme is due to Black, Rogaway, and Shrimpton <ref type="bibr" target="#b9">[9]</ref> whose proof of security assumes a random oracle H.</p><p>The only component that requires a random oracle is the circular-secure encryption of s using t. We can use a NIZK proof for proving that all other components (including the tag) are consistent with the same message m. In addition, we use a cut-and-choose protocol (which we collapse using a random oracle to a non-interactive one) for showing that the commitment Commit(s t) is consistent with the circular-secure encryption (r 3 , H(r 3 t) + s), where s is encoded with a threshold secret-sharing scheme. The commitment Commit(s t) is used in both the NIZK proof and in the cut-and-choose components, and binds the two together to yield a proof of consistency for the entire ciphertext.</p><p>To ensure that the overhead of the scheme is additive and independent of the length of the message, first observe that the length of the commitment and the encryption of s under t (and hence the cut-and-choose part of the scheme) depend only on the security parameter. To further minimize the length of ciphertexts, we use a composition of an NIZK proof system with a succinct argument system in the random oracle model, where the length of the arguments depends only on the security parameter.</p><p>Construction 2: Deterministic encryption for computationally bounded distributions. As in the previous work <ref type="bibr" target="#b18">[18,</ref><ref type="bibr" target="#b7">7]</ref>, our second scheme uses any semantically secure randomized encryption E k (m; r). It encrypts a message m using a key k = k m and randomness r = r m that are derived from m in a deterministic manner (e.g., using a hash function modeled as a random oracle).</p><p>With lock-dependent message distributions, however, such a scheme does not satisfy a meaningful notion of security since it is completely deterministic (as discussed above).</p><p>Following Raghunathan et al. <ref type="bibr" target="#b29">[29]</ref> we show that this approach can be made secure even for lock-dependent message distributions, subject to the condition that these distributions are efficiently samplable using at most q queries to the random oracle, where q is a pre-determined parameter. (We do not ask for an a priori bound on the number of oracle calls that are made directly by the adversary.) Concretely, we derive the key k m and the randomness r m as</p><formula xml:id="formula_0">k m = ⊕ q+1 i=1 H 1 (m i) and r m = ⊕ q+1 i=1 H 2 (m i),</formula><p>where H 1 and H 2 are two hash functions modeled as independent random oracles.</p><p>Intuitively, the proof of security relies on the fact that k m and r m are pseudorandom against both the adversary and the sampling circuits of such "q-bounded" message distributions. Pseudorandomness against the adversary relies on the fact that m is sampled with a super-logarithmic min-entropy and that the underlying encryption scheme is secure. Pseudorandomness against the sampling circuits relies on the fact that for learning any information on k m or r m it is essential to query the random oracle q + 1 times.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Preliminaries</head><p>Notation. For an integer n ∈ N we denote by [n] the set {1, . . . , n}, by [a, b] the set {a, a + 1, . . . , b}, and by U n the uniform distribution over the set {0, 1} n . For a random variable X we denote by x ← X the process of sampling a value x according to the distribution of X. Similarly, for a finite set S we denote by x ← S the process of sampling a value x according to the uniform distribution over S. We denote by x (and sometimes x) a vector (x 1 , . . . , x |x| ). We denote by X = (X 1 , . . . , X T ) a joint distribution of T random variables, and by x = (x 1 , . . . , x T ) a sample drawn from X. For two bit-strings x and y we denote by x y their concatenation. A non-negative function f : N → R is negligible if it vanishes faster than any inverse polynomial. Entropy. The min-entropy of a random variable X is defined as</p><formula xml:id="formula_1">H ∞ (X) = -log(max x Pr [X = x]). A k-source is a random variable X with H ∞ (X) ≥ k. A (k 1 , . . . , k T )-source is a random variable X = (X 1 , . . . , X T ) where each X i is a k i -source. A (T, k)-source is a random variable X = (X 1 , . . . , X T ) where for each i ∈ [T ], it holds that X i is a k-source. A (T, k)-block-source is a random variable X = (X 1 , . . . , X T ) where for every i ∈ [T ] and x 1 , . . . , x i-1 it holds that X i | X1=x1,...,Xi-1=xi-1 is a k-source. The statistical distance between two random variables X and Y over a finite domain Ω is SD(X, Y ) = 1 2 ω∈Ω |Pr [X = ω] - Pr [Y = ω] |.</formula><p>The ME-DDH Assumption. We state a variant of Canetti's entropy DDH assumption <ref type="bibr" target="#b13">[13]</ref>. The β-min-entropy DDH assumption (abbreviated as ME-DDH) states that for a group G equipped with a non-degenerate bilinear map ê : G × G → G T , of prime order p (where p is a λ-bit prime) for any distribution X over Z p with H ∞ (X) ≥ β, for uniformly sampled a, c ← Z p and b ← X, it holds that the two distributions g, g a , g ab and (g, g a , g c ) are computationally indistinguishable. We make two remarks on the ME-DDH assumption:</p><p>1. We require β ≥ ω(log λ) for the assumption to be plausible. Otherwise, there exists an x * ← X such that Pr [X = x * ] is non-negligible and a distinguisher that, when given (g, g a , g c ), checks to see whether (g a ) x * = g c , succeeds in distinguishing the two distributions with non-negligible probability. 2. If X is the uniform distribution over Z p , then the assumption is unconditionally true as the two distributions ab and c are identical even given a.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">MLE for Lock-Dependent Messages</head><p>Extending the work of Bellare et al. <ref type="bibr" target="#b7">[7]</ref>, we propose a more general notion of the primitive MLE, which we call MLE2. In MLE2, we allow tags to be randomized and consider a definition of tag correctness that introduces a new polynomialtime algorithm EQ that subsumes the functionality of deterministic tags. In addition, we introduce a new validity-test algorithm, denoted Valid, that allows anyone with the public parameters to check if a given ciphertext is a valid ciphertext. In the context of using MLE2 for secure deduplication, EQ allows for deduplication of ciphertexts and Valid allows the server to reject adversarially constructed ciphertexts that subvert deduplication to replace a valid ciphertext with an invalid one that does not decrypt correctly.</p><p>The main benefit of the new notion is permitting a stronger security requirement (which we denote PRV-CDA2) that allows the adversary to see the public parameters before issuing oracle queries. Bellare et al. <ref type="bibr" target="#b7">[7]</ref> considered the notion of an equality-checking tag analogous to our notion of an equality algorithm EQ. A (publicly computable) tag-generation algorithm, on input a ciphertext c, produces a tag such that if two ciphertexts c 1 and c 2 are generated from the same message, the corresponding tags are equal with high probability. Our equality algorithm is a generalization of such an equality-checking tag. Given any scheme with equality-checking tags, we can describe a simple algorithm EQ that given c 1 and c 2 derives their respective tags and outputs 1 only if the tags are equal.</p><p>The notion analogous to tag correctness of Bellare et al. <ref type="bibr" target="#b7">[7]</ref> requires that for all λ ∈ N, all public parameters pp ← PPGen(1 λ ), and all messages m ∈ M, there is a negligible function ν(λ) such that for two encryptions c 1 and c 2 of m with KD pp (m) and independent random coins, it holds that EQ pp (c 1 , c 2 ) = 1 with probability at least 1ν(λ), where the probability is taken over random coins of all algorithms.</p><p>The notion of correctness for the validity-test algorithm Valid requires that for all λ ∈ N, all public parameters pp ← PPGen(1 λ ), and all messages m ∈ M, there is a negligible function ν(λ) such that for a ciphertext c ← Enc pp (KD pp (m), m),</p><formula xml:id="formula_2">Pr [Valid pp (c) = 1] ≥ 1 -ν(λ)</formula><p>, where the probability is taken over all random coins of all algorithms.</p><p>The usual notion of correctness of the decryption algorithm Dec applies. Specifically, for all λ ∈ N, all public parameters pp ← PPGen(1 λ ), and all messages m ∈ M, there is a negligible function ν(λ) such that</p><formula xml:id="formula_3">Pr[Dec pp (k m , Enc pp (k m , m)) = m | k m ← KD pp (m)] ≥ 1 -ν(λ),</formula><p>where the probability is taken over all random coins of all algorithms. MLE2 Adversaries. To capture a notion of security against an adversary that attacks the system by choosing messages that may depend on the public parameters, we introduce several adversary models. In what follows, we consider several parameters that are functions of the security parameter; q = q(λ) denoting the number of random oracle queries, k = k(λ) denoting min-entropy requirements over message sources, T = T (λ) denoting the number of blocks in the message source, and Γ = Γ (λ) denoting the size of a circuit that generates message sources.</p><p>In particular, inspired by recent work on deterministic encryption <ref type="bibr" target="#b29">[29]</ref>, for X ∈ {(T, k)-block, (T, k)} we define the class of Γ -sampling complexity X-source adversaries and a generalization to polynomial-size X-source adversaries. We stress that all algorithms are allowed polynomially many calls to the random oracle in the security definitions that follow. Additionally, in schemes that rely random oracles, we define q-query X-source adversaries. Although more restrictive, they are useful in constructing efficient and practical deterministic encryption schemes secure in the random oracle model <ref type="bibr" target="#b29">[29]</ref>. We begin by introducing a definition of the real-or-random encryption oracle used in definitions of security. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4.2 (Γ -sampling Complexity Adversary).</head><p>Consider an X-source where X ∈ {(T, k)-block, (T, k)}. Let A be a probabilistic polynomial-time algorithm that is given as input a pair (1 λ , pp) and oracle access to RoR(mode, pp, •) for some mode ∈ {real, rand}. Then, A is a Γ -sampling complexity X-source adversary if for each of A's RoR queries M it holds that M is an X-source that is samplable by a circuit of size at most Γ . In addition, for the case of (T, k)-source adversaries, we require that for each such query M it holds that M i = M j for all vectors (M 1 , . . . , M T ) in the support of M and for all i = j ∈ [T ].</p><p>We consider a stronger adversary that has no a-priori bound on the sampling complexity of its queries except that they are efficiently samplable by polynomial size circuits. Such an adversary subsumes Γ -sampling complexity adversaries for all Γ = poly(λ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4.3 (Polynomial-Sampling Complexity Adversary). Let X ∈ {(T, k)-block, (T, k)}, and let</head><p>A be a probabilistic polynomial-time algorithm that is given as input a pair (1 λ , pp) and oracle access to RoR(mode, pp, •) for some mode ∈ {real, rand}. Then, A is a polynomial-size X-source adversary if for each of A's RoR-queries M it holds that M is an X-source that is samplable by a circuit of (an arbitrary) polynomial size in the security parameter. Definition 4.4 (q-query Adversary <ref type="bibr" target="#b29">[29]</ref>). Consider an X-source where X ∈ {(T, k)-block, (T, k)}. Let A be a probabilistic polynomial-time algorithm that is given as input a pair (1 λ , pp) and oracle access to RoR(mode, pp, •) for some mode ∈ {real, rand}. Then, A is a q-query k-source adversary if for each of A's RoR-queries M it holds that M is an X-source that is samplable by a polynomialsize circuit that uses at most q queries to the random oracle.</p><p>A Stronger Notion of Message Privacy: PRV-CDA2. We define the following security notion with respect to polynomial-size X-source adversaries (see Definition 4.3), which we denote X-source PRV-CDA2 security. A simple modification to the experiments in the security definition allows us to restrict our class of adversaries to Γ -sampling complexity or q-query X-source adversaries. Such notions are referred to as Γ -sampling complexity or q-query X-source PRV-CDA2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4.5 (PRV-CDA2 Security</head><p>). An MLE2 scheme Π = (PPGen, KD, Enc, Dec, EQ, Valid) is X-source PRV-CDA2 secure, for X ∈ {(T, k)-block, (T, k)}, if for any probabilistic polynomial-time polynomial-size X-source adversary A, there exists a negligible function ν(λ) such that  where for each mode ∈ {real, rand} and λ ∈ N the experiment Expt mode Π,A (λ) is defined in Figure <ref type="figure" target="#fig_3">1</ref>. In addition, such a scheme is one-time secure if the above holds for any adversary A that queries the RoR oracle at most once.</p><formula xml:id="formula_4">Adv PRV-CDA2 Π,A (λ) def = Pr Expt real Π,A (λ) = 1 -Pr Expt rand Π,A (λ) = 1 ≤ ν(λ), PRV-CDA2 game: Expt mode Π,A (λ) TC2/STC2 game: Expt Z Π,A (λ) 1. pp ← PPGen(1 λ ). 2. b ← A RoR(mode,pp,•) (1 λ , pp). 3. Output b. 1. pp ← PPGen(1 λ ). 2. (m, c ) ← A(1 λ , pp). 3. If m = ⊥ or Valid(c ) = 0 output 0. 4. k ← KDpp(m).</formula><p>The assumption of the plaintexts' unpredictability and support for equality testing (for use in the context of deduplication) may appear to be at odds with each other. After all, a distribution of plaintexts with sufficiently large min-entropy cannot possibly benefit from deduplication as the number of clones in a moderately sized sample is going to be negligible. However, the definition does not presuppose a particular generative model for the plaintexts. Instead, it bounds from below the amount of uncertainty that the adversary has about a particular plaintext, or in the language of Bayesian probability theory, the adversary's prior. In other words, Alice and Bob may share the same document that can be deduplicated on the server and will stay private as long as the server cannot guess its exact content.</p><p>Our parameter-dependent security notion enables an immediate reduction of "multi-shot" adversaries to "single-shot" ones, as is standard in public-key encryption schemes. Theorem 4.6 stated below follows via a standard hybrid argument. <ref type="figure"></ref>and<ref type="figure">X ∈ {(T, k)-block, (T, k</ref>)}. Then, an MLE2 scheme is X-source PRV-CDA2-secure if and only if it is one-time Xsource PRV-CDA2-secure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 4.6 (Equivalence of PRV-CDA2 and One-time PRV-CDA2 Security). Let</head><formula xml:id="formula_5">k = k(λ), T = T (λ),</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4.7 (Tag Consistency</head><p>). An MLE2 scheme Π = (PPGen, KD, Enc, Dec, EQ, Valid) is tag consistent (resp., strongly tag consistent) if for any probabilistic polynomial-time adversary A, there exists a negligible function ν(λ) such that Adv expt Π,A (λ)</p><formula xml:id="formula_6">def = Pr Expt expt Π,A (λ) = 1 ≤ ν(λ)</formula><p>, where expt = TC2 (resp., expt = STC2) and for each Z ∈ {TC2, STC2}, λ ∈ N the experiment Expt Z Π,A (λ), is defined in Figure <ref type="figure" target="#fig_3">1</ref>.</p><p>Block-Source Adversaries vs. Single-Message Adversaries. In the somewhat similar setting of deterministic public-key encryption, Boldyreva et al. <ref type="bibr" target="#b10">[10]</ref> showed that for proving security against (T, k)-block-source adversaries it suffices to prove security against (1, k)-source adversaries. Their proof, however, does not seem to carry over to our setting, where all message distributions are required to be efficiently samplable by polynomial-sized circuits. Nevertheless, motivated by the works of Bellare et al. <ref type="bibr" target="#b7">[7]</ref> and Brakerski and Segev <ref type="bibr" target="#b12">[12]</ref>, we now present a strengthening of our notion of PRV-CDA2 security, for which we are able to prove an equivalence between security against (T, k)-block-source adversaries and security against (1, k)-source adversaries.</p><p>The strengthened notion, to which we refer as aux-PRV-CDA2 security (i.e., PRV-CDA2 security with auxiliary inputs), is obtained by modifying the real-orrandom encryption oracle. The modification is that its inputs are now of the form (mode, pp, (M, Aux)), where (M, Aux) is a joint distribution over messages and auxiliary inputs. If mode = real then the oracle samples (m 1 , . . . , m T , aux) ← (M, Aux), and if mode = rand then the oracle samples uniform and independent messages m 1 , . . . , m T ← M and aux ← Aux, independent of the messages. Next, for each i ∈ [T ], it samples k i ← KD pp (m i ), computes c i ← Enc pp (k i , m i ) and outputs the vector (c 1 , . . . , c T , aux). For X ∈ {(T, k)-block, (T, k)}, we say that a probabilistic polynomial-time algorithm A is a polynomial-size X-source adversary if for each of A's RoR-queries (M, Aux) it holds that: (1) the joint distribution (M, Aux) is samplable by a circuit of polynomial size, and (2) for every auxiliary input aux in the support of Aux, it holds that M| Aux=aux is an X-source. Equipped with this modification, we prove the following theorem:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 4.8 (Equivalence of (T, k)-block-source and (1, k)-source adversaries with auxiliary inputs).</head><p>Let k = k(λ) and T = T (λ) be polynomial in λ. Then, an MLE2 scheme is (T, k)-block-source aux-PRV-CDA2-secure if and only if it is (1, k)-source aux-PRV-CDA2-secure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Comparison to the Security Notion of Bellare et al. [7].</head><p>In the security notion of MLE <ref type="bibr" target="#b7">[7]</ref>, adversaries are not given access to the public parameters pp when interacting with the RoR encryption oracle (unlike in step 2 in our definition). Adversaries receive pp only after all queries to the RoR oracle are completed. (Once pp is published, subsequent oracle queries return ⊥.) Our security notion of MLE2 considers adversaries that are given access to the public parameters when interacting with the RoR encryption oracle. In particular, this enables adversaries to query the oracle with message distributions that depend on the public parameters pp (in a bounded manner, as described in the various adversary notions defined above).</p><p>The security notions of both MLE and MLE2 consider message distributions that are (T, k)-sources. All the MLE constructions of Bellare et al. are secure for (T, k)-sources, and our deterministic MLE2 construction for q-query adversaries is secure for (T, k)-sources as well (for any polynomial T = T (λ)). However, our fully randomized construction is secure only for k-sources (that is, for (1, k)-sources). This limitation seems to be inherent to our approach, which uses seed-dependent condensers. (See the work of Dodis et al. <ref type="bibr" target="#b17">[17]</ref> for a discussion on the limitations of seed-dependent condensers in the presence of auxiliary inputs).</p><p>The notions of TC2/STC2 tag consistency described above follow closely the definitions of Bellare et al., with small modifications to accommodate the more general notion of tags and the new algorithms EQ and Valid. In particular, the experiment outputs 1 only if EQ(c, c ) = 1, which corresponds to comparing tags in MLE. Additionally, we discard adversarially constructed ciphertexts c that can be recognized by algorithm Valid as invalid.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">A Fully Randomized Scheme</head><p>In this section, we present the scheme Π full , a fully randomized MLE2 scheme. An overview of the construction is presented in Section 2.</p><p>The Scheme. Let λ denote the security parameter. Let GroupGen be a probabilistic polynomial-time algorithm that takes as input a security parameter 1 λ , and outputs (G, G T , p, g, ê) where G and G T are groups of prime order p, G is generated by g, p is a λ-bit prime number, and ê : G × G → G T is a nondegenerate efficiently computable bilinear map. The scheme is parameterized by a parameter n that is polynomial in the security parameter. The MLE2 scheme Π full comprises the following building blocks.</p><p>-A one-time secure symmetric-key encryption scheme SE = (K, E, D). As a concrete example, let G : K → M be a pseudorandom generator that takes short keys and expands them to the message space. We can use such a PRG as a one-time pad to get a simple, efficient, and one-time secure scheme</p><formula xml:id="formula_7">E k (m) := G(k) ⊕ m ∈ M. -An (n+1)-out-of-(2n+1) secret sharing of a key k ∈ K. The secret is encoded</formula><p>as an element of the field F q for a prime q slightly larger than |K|. The additive secret-sharing scheme we use (based on interpolating polynomials) also satisfies the additional property that given 2n + 1 shares of a secret, one can efficiently reconstruct (via Reed-Solomon decoding techniques <ref type="bibr" target="#b23">[23]</ref>) the secret as long as at least (3n + 1)/2 shares are correctly computed. -Two hash functions RO : {0, 1} * → F q and FS : {0, 1} * → p n,2n+1 . The functions will be modeled in the proof of security as random oracles. RO is used to break circularity and FS denotes the random oracle required to implement Fiat-Shamir. Here p n,2n+1 denotes the set of all subsets of [2n + 1] of cardinality n.</p><formula xml:id="formula_8">-A collection H = {H λ } λ∈N of collision-resistant hash functions h : M → Z p . -A commitment scheme T C = (CGen, Commit, Reveal).</formula><p>-A simulation-sound non-interactive extractable zero-knowledge proof system ZK = (ZKGen, ZKProve, ZKVer, ZKFakeGen, ZKSim, ZKExt) for the NP language L defined at the end of the description of the scheme.</p><p>The scheme Π full = (PPGen, KD, Enc, Dec, EQ, Valid) is parameterized by a parameter n that is polynomial in the security parameter and is as follows:</p><p>-Parameter-generation algorithm: On input 1  (m) . Let et i = g ui , g ui•h(m) • t i . We let et = (et 1 , . . . , et 2n+1 ) and u = (u 1 , . . . , u 2n+1 ). Encrypting shares of s: The algorithm encrypts s i under t i with a construction by Black et al. <ref type="bibr" target="#b9">[9]</ref>. The algorithm samples v 1 , . . . , v 2n+1 ← {0, 1} λ and sets es i to the ciphertext (v i , RO(v i t i ) + s i mod q). We let es denote (es 1 , . . . , es 2n+1 ). Zero-knowledge proof: The algorithm computes a proof π using algorithm ZKProve that the statement σ = (d, com, et, τ) is in the language L defined below. Cut-and-choose: The algorithm computes X ← FS (σ π es) where X ⊂ [2n+ 1] of cardinality n. The algorithm reveals commitments com i for i ∈ X, denoted by rcom = {Reveal(com i )} i∈X . The algorithm outputs:  </p><formula xml:id="formula_9">c = d,</formula><formula xml:id="formula_10">R := ⎧ ⎪ ⎪ ⎨ ⎪ ⎪ ⎩ d, com, et, τ , s, t, m d = E s (m) com i = Commit(s i t i ) ∀ i ∈ [2n + 1] et i = g ui , g ui•h(m) for uniform u i ∈ Z p τ = g r , g r•h(m) for uniform r ∈ Z p ⎫ ⎪ ⎪ ⎬ ⎪ ⎪ ⎭ .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Correctness of the</head><formula xml:id="formula_11">m = h(m). If et i = (α, β), then we have β/(α km ) = g ui•h(m) • t i /(g ui ) h(m) = t i as required. Next, if es i = (α, β), we have β -RO(α t i ) = RO(v i t i ) + s i -RO(v i t i ) = s i (<label>mod</label></formula><p>q) as required. The secret-sharing scheme correctly reconstructs s given shares (s 1 , . . . , s 2n+1 ) (via Reed-Solomon decoding techniques <ref type="bibr" target="#b23">[23]</ref>) and therefore correctness of the scheme follows from correctness of the symmetric encryption scheme SE.</p><p>Correctness of algorithm EQ follows from properties of groups equipped with bilinear maps. If τ 1 = (α 1 , β 1 ) ∈ G 2 and τ 2 = (α 2 , β 2 ) ∈ G 2 are constructed by the encryption scheme with the same underlying message m, then</p><formula xml:id="formula_12">ê (α 1 , β 2 ) = ê g r1 , g r2•h(m) = ê (g, g) r1r2•h(m) , and ê (α 2 , β 1 ) = ê g r2 , g r1•h(m) = ê (g, g) r1r2•h(m) as required.</formula><p>Succinct Ciphertexts. In order to shrink the ciphertexts in the scheme Π full to be of length |E s (m)| + poly(λ), we replace the (long) NIZK proof π in our ciphertext with a non-interactive succinct extractable argument system whose length depends only on the security parameter. (Such argument systems are known to exist in the random oracle model-see the full version for the definition and instantiation.) Specifically, our parameter generation algorithm outputs additionally the public parameters pp SA for the argument system. The encryption scheme first computes an NIZK proof π for the statement σ = (d, com, et, τ), and then uses π as a witness for asserting (with a succinct proof π SA ), using the succinct argument system, that there exists a proof π that is accepted by the verifier of the NIZK system for the assertion that (σ, π) ∈ R. Finally, we discard the NIZK proof π and only include the succinct argument π SA in the ciphertext. The rest of the components of the ciphertext remain unchanged. Such a technique for shrinking NIZK proofs using succinct arguments was recently used, for example, in the work of Boneh, Segev, and Waters <ref type="bibr" target="#b11">[11]</ref>. And finally, we modify the validity test by invoking the verifier SAVer of the succinct argument system on π SA instead of the verifier of the NIZK proof system.</p><p>The following theorem states that the scheme Π full is k-source PRV-CDA2 secure (see Definition 4.5). A proof outline is presented in Section 2.</p><p>Theorem 5.1. Let SE be a one-time secure symmetric-key encryption scheme, T C be a statistically-hiding commitment scheme, ZK be a non-interactive extractable zero-knowledge proof system, and H be a family of poly, 2 -ω(log 2 λ)collision-resistant hash functions. Then, under the ω(log 2 λ)-min-entropy DDH assumption and the CDH assumption in group G, for any k &gt; ω(log 2 λ), Π full is k-source PRV-CDA2 secure with RO and FS modeled as random oracles.</p><p>Next, we state that the scheme Π full satisfies the notion of strong tag consistency as in Definition 4.7.</p><p>Theorem 5.2. Let T C be a secure commitment scheme, ZK be a non-interactive extractable zero-knowledge proof system, and H be a family of poly, 2 -ω(log 2 λ)collision-resistant hash functions. Then, setting n ≥ ω(log λ), Π full is strongly tag consistent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">A Deterministic Scheme for Bounded Message Distributions</head><p>The Scheme. Our deterministic MLE2 scheme uses as a building block an IND-CPA secure symmetric-key scheme SE = (K, E, D) with the same message space M as the MLE2 scheme, key space K, ciphertext space C, and randomness length ρ. It is additionally parameterized by an integer q = q(λ). The scheme Π (q) det = (PPGen, KD, Enc, Dec, EQ, Valid) is defined as follows:</p><p>-Parameter-generation algorithm: On input 1 λ , the algorithm PPGen chooses two hash functions -Equality algorithm: Algorithm EQ on input public parameters pp and ciphertexts c 1 and c 2 outputs 1 if and only if c 1 = c 2 . The following theorem, which is analogous to the combination of Theorems 5.1 and 5.2, captures security of Π (q) Det . However, security is established in a different, incomparable adversarial model: the source specified by the adversary is allowed to output T , possibly correlated, messages at a time as long as the sampling circuit makes no more than q random oracle queries. Theorem 6.1. Let q ∈ N be polynomial in the security parameter λ. det is q-query (T, k)-source PRV-CDA2-secure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">The scheme Π (q)</head><p>Det is strongly tag consistent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions and Open Problems</head><p>Prior definitions and schemes for message-locked encryption (MLE) admit only an adversary who is oblivious to the scheme's public parameters during the initial interaction. We explore two avenues for extending security guarantees of MLE towards a more powerful adversarial model, where the distribution of plaintexts can be correlated with the scheme's parameters (lock-dependent messages). In our first construction we augment the definition of MLE to allow fully random ciphertexts by supporting equality-testing functionality. One challenging aspect of the construction is ensuring ciphertext consistency in the presence of random oracles without inflating the length of the ciphertext. We achieve this goal via a combination of a cut-and-choose technique and NIZKs. The resulting scheme is secure against a fully adaptive adversary. Our second construction assumes a predetermined bound on the complexity of distributions specified by the adversary. It fits the original framework of deterministic MLE while satisfying a stronger security notion.</p><p>We formulate the following several directions for further research. First, we ask whether a fully adaptive randomized MLE2 can be constructed and proven secure in the standard model. Second, a randomized scheme for deduplication creates a potential leakage channel that allows one user to test whether her plaintext has already been uploaded to the system (similar to the attack described by Harnik et al. <ref type="bibr" target="#b20">[20]</ref> where the deduplication event was observable via traffic analysis). Designing a scheme resistant to this attack, for example, by supporting server-side rerandomization of ciphertexts, constitutes an interesting research question. Note that deterministic MLEs are immune to this problem. Finally, our first scheme requires a pairwise application of the equality-testing algorithm to identify all duplicate ciphertexts, and uses computationally expensive NIZKs as a building block. We leave reducing the overhead of the scheme as an open problem.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>MLE2. A message-locked encryption scheme for lock-dependent messages is a six-tuple Π = (PPGen, KD, Enc, Dec, EQ, Valid) operating over plaintext space M = {M λ } λ∈N , ciphertext space C = {C λ } λ∈N , and keyspace K = {K λ } λ∈N of polynomial-time randomized algorithms with the following properties: -The parameter generation algorithm takes as input 1 λ and returns public parameters pp. -The key derivation function KD takes as input public parameters pp, a message m, and outputs a message-derived key k m ← KD pp (m). -The encryption algorithm Enc takes as input public parameters pp, a message m, and a message-derived key k m . It outputs a ciphertext c ← Enc pp (k m , m). -The decryption algorithm Dec takes as input public parameters pp, ciphertext c, and a secret key k and outputs either a message m or ⊥. -The (new) equality algorithm EQ takes as input public parameters pp, and two ciphertexts c 1 and c 2 and outputs 1 if both ciphertexts are generated from the same underlying message. -The (new) validity-test algorithm Valid takes as input public parameters pp and a ciphertext c and outputs 1 if the ciphertext c is a valid ciphertext.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Definition 4 . 1 (</head><label>41</label><figDesc>Real-or-Random Encryption Oracle).The real-or-random encryption oracle, RoR, takes as input triplets of the form (mode, pp, M), where mode ∈ {real, rand}, pp denotes public parameters, and M is a polynomial size circuit representing a joint distribution over T messages. If mode = real then the oracle samples (m 1 , . . . , m T ) ← M, and if mode = rand then the oracle samples uniform and independent messages m 1 , . . . , m T ← M. Next, for each i ∈ [T ], it samples k i ← KD pp (m i ), computes c i ← Enc pp (k i , m i ) and outputs the ciphertext vector (c 1 , . . . , c T ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>5 . 6 .</head><label>56</label><figDesc>c ← (Encpp(k, m)) and m ← Decpp(k, c ). If Z = TC2, EQ(c, c ) = 1, m = m , and m = ⊥, output 1. 7. If Z = STC2, EQ(c, c ) = 1, and m = m , output 1. 8. Else, output 0.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Security games for Definitions 4.5 and 4.7.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>H 1 :</head><label>1</label><figDesc>{0, 1} * → K and H 2 : {0, 1} * → {0, 1} ρ . It outputs the public parameters pp = (H 1 , H 2 , q). -Key-derivation function: The algorithm KD takes as input public parameters pp, a message m, and outputs the message-derived keyk m = H 1 (m 1) ⊕ H 1 (m 2) ⊕ • • • ⊕ H 1 (m q + 1) ∈ K. -Encryption algorithm: The algorithm Enc takes as input public parameters pp, a message m, and a message-derived key k m . It computes r m = H 2 (m 1) ⊕ H 2 (m 2) ⊕ • • • ⊕ H 2 (m q + 1) and outputs E km (m; r m ) ∈ C. -Validity test: The algorithm Valid outputs 1 on any input c ∈ C. -Decryption algorithm: Dec takes as input public parameters pp, a ciphertext c, and a message-derived key k m and outputs m ← D km (c).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>1 .</head><label>1</label><figDesc>If SE is an IND-CPA secure scheme and H 1 and H 2 are modeled as random oracles, then, for any any T = poly(λ) and any k = ω(log λ), Π (q)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>λ , algorithm PPGen samples (G, G T , p, g, ê) ← GroupGen(1 λ ). It chooses a hash function h ← H from the family of collision-resistant hash functions, and specifies two additional hash functions RO and FS. It generates public parameters pp ZK ← ZKGen(1 λ ) and pp com ← CGen(1 λ ) and publishes pp = (G, G T , p, g, ê, h, pp ZK , pp com ).-Key-derivation function: KD takes as input public parameters pp, a message m, and outputs the message-derived key k m = h(m). -Encryption algorithm: Enc takes as input public parameters pp, a message m, and a message-derived key k m . It samples r ← Z p and first computes τ = g r , g r•h(m) ∈ G 2 . Creating shares of s: The algorithm chooses a key s ← K(1 λ ) for scheme SE and an (n + 1)-out-of-(2n + 1) additive secret sharing of s denoted s = (s 1 , . . . , s 2n+1 ) ∈ F 2n+1 q . It computes the encrypted message d = E s (m) ∈ C. Committing to deferring elements t i : The algorithm samples t 1 , . . . , t 2n+1 ← G and lets com i denote the commitment Commit(s i t i ). We let com = (com 1 , . . . , com 2n+1 ) and t = (t 1 , . . . , t 2n+1 ). Encrypting deferring elements t i : The algorithm samples random elements u 1 , . . . , u 2n+1 ← Z p and computes ElGamal encryptions of t i with public key g h</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>com, et, es, π, rcom, τ . On input a ciphertext c = d, com, et, es, π, rcom, τ , algorithm Valid constructs σ = d, com, et, τ . If ZKVer(pp ZK , σ, π) = 0, algorithm Valid outputs 0. Next, Valid computes X = FS (σ π es) ∈ p n,2n+1 and verifies for revealed values {rcom i } i∈X from rcom that the commitments and encryptions of s, {com i , es i } i∈X , are consistent with opened values {s i , t i } i∈X . It outputs 1 if they are consistent and 0 otherwise. -Decryption algorithm: On input the public parameters of the system pp, the ciphertext c = d, com, et, es, π, rcom, τ , and a secret key k m , if Valid(c) = 0, the decryption algorithm outputs ⊥. Else, the decryption algorithm first recovers t i from et i = (α, β) with secret key k m by computing t i = β/ α km . Next, using t i , the algorithm recovers s i from es i = (α, β) by computing s i = β -RO(α t i ) mod q. It reconstructs s, given the (n + 1)-outof-(2n+1) additive secret sharing of s, (s 1 , . . . , s 2n+1 ). Finally, the decryption algorithm outputs m ← D s (d). -Equality-testing algorithm: On input two ciphertexts, c 1 and c 2 , the algorithm recovers τ 1 and τ 2 . Let τ 1 = (g 1 , h 1 ) ∈ G 2 and τ 2 = (g 2 , h 2 ) ∈ G 2 . The algorithm outputs 1 if and only if ê(g 1 , h 2 ) = ê(g 2 , h 1 ).</figDesc><table><row><cell>statements σ = (d, com, et, τ) whose components are created with the secret values (m, r, s, t, u) in a consistent manner. More formally, we define the relation R = {(σ, w)} of statements σ and corresponding proof strings w below and note -Validity test: The Language L and Relation R. Intuitively, the language L contains only that L = {σ : ∃ w s.t. (σ, w) ∈ R}:</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments. We thank the anonymous CRYPTO 2013 reviewers for their helpful comments.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This work was supported by NSF, the DARPA PROCEED program, an AFO SR MURI award, a grant from ONR, an IARPA project provided via DoI/NBC, and by Samsung. Opinions, findings and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of DARPA or IARPA. Distrib. Statement "A:" Approved for Public Release, Distribution Unlimited. Part of the work was done at Microsoft Research Silicon Valley.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<ptr target="http://www.bitcasa.com" />
		<title level="m">Bitcasa</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="http://www.gnu.org/software/GNUnet/" />
		<title level="m">GNUNet</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">FARSITE: Federated, available, and reliable storage for an incompletely trusted environment</title>
		<author>
			<persName><forename type="first">A</forename><surname>Adya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Bolosky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Cermak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Chaiken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Douceur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Howell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Lorch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Theimer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wattenhofer</surname></persName>
		</author>
		<editor>Culler, Druschel</editor>
		<imprint>
			<biblScope unit="page" from="1" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Deterministic and efficiently searchable encryption</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Boldyreva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>O'neill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2007</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Menezes</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">4622</biblScope>
			<biblScope unit="page" from="535" to="552" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Hedged public-key encryption: How to protect against bad randomness</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Brakerski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ristenpart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Segev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Shacham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yilek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2009</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Matsui</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5912</biblScope>
			<biblScope unit="page" from="232" to="249" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Deterministic encryption: Definitional equivalences and constructions without random oracles</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fischlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>O'neill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ristenpart</surname></persName>
		</author>
		<imprint>
			<publisher>Wagner</publisher>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="360" to="378" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Message-locked encryption and secure deduplication</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Keelveedhi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ristenpart</surname></persName>
		</author>
		<editor>Johansson, Nguyen</editor>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="296" to="312" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Random oracles are practical: A paradigm for designing efficient protocols</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Computer and Communications Security</title>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Denning</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Pyle</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Ganesan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Sandhu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">V</forename><surname>Ashby</surname></persName>
		</editor>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="62" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Encryption-scheme security in the presence of key-dependent messages</title>
		<author>
			<persName><forename type="first">J</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Shrimpton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAC 2002</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Nyberg</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><forename type="middle">M</forename><surname>Heys</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2595</biblScope>
			<biblScope unit="page" from="62" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">On notions of security for deterministic encryption, and efficient constructions without random oracles</title>
		<author>
			<persName><forename type="first">A</forename><surname>Boldyreva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Fehr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>O'neill</surname></persName>
		</author>
		<imprint>
			<publisher>Wagner</publisher>
			<biblScope unit="page" from="335" to="359" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Targeted malleability: homomorphic encryption for restricted computations</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Segev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ITCS</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</editor>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="350" to="366" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Better security for deterministic public-key encryption: The auxiliary-input setting</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Brakerski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Segev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2011</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6841</biblScope>
			<biblScope unit="page" from="543" to="560" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Towards realizing random oracles: Hash functions that hide all partial information</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 1997</title>
		<editor>
			<persName><forename type="first">B</forename><forename type="middle">S</forename><surname>Kaliski</surname><genName>Jr</genName></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1294</biblScope>
			<biblScope unit="page" from="455" to="469" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Pastiche: Making backup cheap and easy</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">P</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">D</forename><surname>Murray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">D</forename><surname>Noble</surname></persName>
		</author>
		<editor>Culler, Druschel</editor>
		<imprint>
			<biblScope unit="page" from="285" to="298" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<author>
			<persName><forename type="first">R</forename><surname>Cramer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2012</title>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7194</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m">5th Symposium on Operating System Design and Implementation (OSDI 2002)</title>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Culler</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Druschel</surname></persName>
		</editor>
		<meeting><address><addrLine>Boston, Massachusetts, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2002">December 9-11. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Randomness condensers for efficiently samplable, seed-dependent sources</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ristenpart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Vadhan</surname></persName>
		</author>
		<imprint>
			<publisher>Cramer</publisher>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="618" to="635" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Reclaiming space from duplicate files in a serverless distributed file system</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Douceur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Adya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Bolosky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Simon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Theimer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="617" to="624" />
		</imprint>
		<respStmt>
			<orgName>ICDCS</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">A unified approach to deterministic encryption: New constructions and a connection to computational entropy</title>
		<author>
			<persName><forename type="first">B</forename><surname>Fuller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>O'neill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Reyzin</surname></persName>
		</author>
		<imprint>
			<publisher>Cramer</publisher>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="582" to="599" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Side channels in cloud services: Deduplication in cloud storage</title>
		<author>
			<persName><forename type="first">D</forename><surname>Harnik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shulman-Peleg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Security &amp; Privacy</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="40" to="47" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2013</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Johansson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">Q</forename><surname>Nguyen</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">7881</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m">Proceedings of the 2008 ACM Workshop on Storage Security and Survivability</title>
		<editor>
			<persName><forename type="first">Y</forename><surname>Kim</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><surname>Yurcik</surname></persName>
		</editor>
		<meeting>the 2008 ACM Workshop on Storage Security and Survivability<address><addrLine>StorageSS; Alexandria, VA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008-10-31">2008. October 31, 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">The theory of error-correcting codes</title>
		<author>
			<persName><forename type="first">F</forename><surname>Macwilliams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sloane</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1977">1977</date>
			<pubPlace>North-Holland</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Incremental deterministic publickey encryption</title>
		<author>
			<persName><forename type="first">I</forename><surname>Mironov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Pandey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Reingold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Segev</surname></persName>
		</author>
		<editor>Pointcheval, Johansson</editor>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="628" to="644" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">POST: A secure, resilient, cooperative messaging system</title>
		<author>
			<persName><forename type="first">A</forename><surname>Mislove</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Post</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Reis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Willmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Druschel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Wallach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Bonnaire</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Busca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">B</forename><surname>Arantes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HotOS</title>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">B</forename><surname>Jones</surname></persName>
		</editor>
		<imprint>
			<publisher>USENIX</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="61" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A low-bandwidth network file system</title>
		<author>
			<persName><forename type="first">A</forename><surname>Muthitacharoen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mazières</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SOSP</title>
		<imprint>
			<biblScope unit="page" from="174" to="187" />
			<date type="published" when="2001">2001. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2012</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Pointcheval</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Johansson</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7237</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Venti: A new approach to archival storage</title>
		<author>
			<persName><forename type="first">S</forename><surname>Quinlan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dorward</surname></persName>
		</author>
		<editor>Long, D.D.E.</editor>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>USENIX</publisher>
			<biblScope unit="page" from="89" to="101" />
		</imprint>
		<respStmt>
			<orgName>FAST</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Deterministic public-key encryption for adaptively chosen plaintext distributions</title>
		<author>
			<persName><forename type="first">A</forename><surname>Raghunathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Segev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Vadhan</surname></persName>
		</author>
		<editor>Johansson, Nguyen</editor>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="93" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Secure data deduplication</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W</forename><surname>Storer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">M</forename><surname>Greenan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">D E</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">L</forename><surname>Miller</surname></persName>
		</author>
		<editor>Kim, Yurcik</editor>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2008</title>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5157</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Dual projective hashing and its applications-lossy trapdoor functions and more</title>
		<author>
			<persName><forename type="first">H</forename><surname>Wee</surname></persName>
		</author>
		<editor>Pointcheval, Johansson</editor>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="246" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Tahoe: the least-authority filesystem</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Wilcox-O'hearn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Warner</surname></persName>
		</author>
		<editor>Kim, Yurcik</editor>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="21" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Probabilistic public key encryption with equality test</title>
		<author>
			<persName><forename type="first">G</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Wong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CT-RSA 2010</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Pieprzyk</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">5985</biblScope>
			<biblScope unit="page" from="119" to="131" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Avoiding the disk bottleneck in the data domain deduplication file system</title>
		<author>
			<persName><forename type="first">B</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Patterson</surname></persName>
		</author>
		<editor>Baker, M., Riedel, E.</editor>
		<imprint>
			<date type="published" when="2008">2008</date>
			<publisher>USENIX</publisher>
			<biblScope unit="page" from="269" to="282" />
		</imprint>
		<respStmt>
			<orgName>FAST</orgName>
		</respStmt>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
