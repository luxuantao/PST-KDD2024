<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Rethinking Graph Transformers with Spectral Attention</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Devin</forename><surname>Kreuzer</surname></persName>
							<email>devin.kreuzer@mail.mcgill.ca</email>
						</author>
						<author>
							<persName><forename type="first">Dominique</forename><surname>Beaini</surname></persName>
							<email>dominique@valencediscovery.com</email>
						</author>
						<author>
							<persName><forename type="first">William</forename><forename type="middle">L</forename><surname>Hamilton</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Vincent</forename><surname>L?tourneau</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Prudencio</forename><surname>Tossou</surname></persName>
							<email>prudencio@valencediscovery.com</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">McGill University</orgName>
								<address>
									<settlement>Mila Montreal</settlement>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Valence Discovery Montreal</orgName>
								<address>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">McGill University</orgName>
								<address>
									<settlement>Mila Montreal</settlement>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">University of Ottawa Ottawa</orgName>
								<address>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="department">Valence Discovery Montreal</orgName>
								<address>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Rethinking Graph Transformers with Spectral Attention</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-01-03T09:24+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In recent years, the Transformer architecture has proven to be very successful in sequence processing, but its application to other data structures, such as graphs, has remained limited due to the difficulty of properly defining positions. Here, we present the Spectral Attention Network (SAN), which uses a learned positional encoding (LPE) that can take advantage of the full Laplacian spectrum to learn the position of each node in a given graph. This LPE is then added to the node features of the graph and passed to a fully-connected Transformer. By leveraging the full spectrum of the Laplacian, our model is theoretically powerful in distinguishing graphs, and can better detect similar sub-structures from their resonance. Further, by fully connecting the graph, the Transformer does not suffer from over-squashing, an information bottleneck of most GNNs, and enables better modeling of physical phenomenons such as heat transfer and electric interaction. When tested empirically on a set of 4 standard datasets, our model performs on par or better than state-of-theart GNNs, and outperforms any attention-based model by a wide margin, becoming the first fully-connected architecture to perform well on graph benchmarks. * Equal contribution.</p><p>35th Conference on Neural Information Processing Systems (NeurIPS 2021).</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The prevailing strategy for graph neural networks (GNNs) has been to directly encode graph structure structure through a sparse message-passing process <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b18">19]</ref>. In this approach, vector messages are iteratively passed between nodes that are connected in the graph. Multiple instantiations of this message-passing paradigm have been proposed, differing in the architectural details of the message-passing apparatus (see <ref type="bibr" target="#b18">[19]</ref> for a review).</p><p>However, there is a growing recognition that the message-passing paradigm has inherent limitations. The expressive power of message passing appears inexorably bounded by the Weisfeiler-Lehman isomorphism hierarchy <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b38">39]</ref>. Message-passing GNNs are known to suffer from pathologies, such as oversmoothing, due to their repeated aggregation of local information <ref type="bibr" target="#b18">[19]</ref>, and over-squashing, due to the exponential blow-up in computation paths as the model depth increases <ref type="bibr" target="#b0">[1]</ref>.</p><p>As a result, there is a growing interest in deep learning techniques that encode graph structure as a soft inductive bias, rather than as a hard-coded aspect of message passing <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b23">24]</ref>. A central issue with message-passing paradigm is that input graph structure is encoded by restricting the structure of the model's computation graph, inherently limiting its flexibility. This reminds us of how early recurrent neural networks (RNNs) encoded sequential structure via their computation graph-a strategy that leads to well-known pathologies such as the inability to model long-range dependencies <ref type="bibr" target="#b19">[20]</ref>.</p><p>There is a growing trend across deep learning towards more flexible architectures, which avoid strict and structural inductive biases. Most notably, the exceptionally successful Transformer architecture removes any structural inductive bias by encoding the structure via soft inductive biases, such as positional encodings <ref type="bibr" target="#b35">[36]</ref>. In the context of GNNs, the self-attention mechanism of a Transformer can be viewed as passing messages between all nodes, regardless of the input graph connectivity.</p><p>Prior work has proposed to use attention in GNNs in different ways. First, the GAT model <ref type="bibr" target="#b36">[37]</ref> proposed local attention on pairs of nodes that allows a learnable convolutional kernel. The GTN work <ref type="bibr" target="#b41">[42]</ref> has improved on the GAT for node and link predictions while keeping a similar architecture, while other message-passing approaches have used enhancing spectral features <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b12">13]</ref> . More recently, the GT model <ref type="bibr" target="#b13">[14]</ref> was proposed as a generalization of Transformers to graphs, where they experimented with sparse and full graph attention while providing low-frequency eigenvectors of the Laplacian as positional encodings.</p><p>In this work, we offer a principled investigation of how Transformer architectures can be applied in graph representation learning. Our primary contribution is the development of novel and powerful learnable positional encoding methods, which are rooted in spectral graph theory. Our positional encoding technique -and the resulting spectral attention network (SAN) architectureaddresses key theoretical limitations in prior graph Transformer work <ref type="bibr" target="#b13">[14]</ref> and provably exceeds the expressive power of standard message-passing GNNs. We show that full Transformer-style attention provides consistent empirical gains compared to an equivalent sparse message-passing model, and we demonstrate that our SAN architecture is competitive with or exceeding the state-of-the-art on several well-known graph benchmarks. An overview of the entire method is presented in Figure <ref type="figure" target="#fig_2">1</ref>, with a link to the code here: https://github.com/DevinKreuzer/SAN.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Theoretical Motivations</head><p>There can be a significant loss in structural information if naively generalizing Transformers to graphs. To preserve this information as well as local connectivity, previous studies <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b13">14]</ref> have proposed to use the eigenfunctions of their Laplacian as positional encodings. Taking this idea further by using the full expressivity of eigenfunctions as positional encodings, we can propose a principled way of understanding graph structures using their spectra. The advantages of our methods compared to previous studies <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b13">14]</ref> are shown in Table <ref type="table">1</ref>.</p><p>Table <ref type="table">1</ref>: Comparison of the properties of different graph Transformer models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MODELS</head><p>GAT <ref type="bibr" target="#b36">[37]</ref> GT sparse <ref type="bibr" target="#b13">[14]</ref> GT full <ref type="bibr" target="#b13">[14]</ref>   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(d)</head><p>Generate node-wise embedding</p><p>For each node , generate a learned posi?onal embedding (LPE) of size .</p><p>A linear layer is applied, followed by a mul?-layer Transformer encoder with self-a?en?on on the sequence length of size .</p><p>Sequence length</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(e)</head><p>Pool the LPE Use a sum or mean pooling on the dimension of size of the node-wise embedding.</p><p>The result is the LPE matrix, where each line represents the learned posi?onal encoding of the -th node. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>LPE</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(f) Fully connect the graph</head><p>An edge is added to all pairs of disconnected nodes and given its own embedding.</p><p>The size of the edge embedding dic?onary increases by 1, and the number of edges becomes .</p><p>Add an MLP or linear layer for both the node and edge features.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(g)</head><p>Input layers for the feature</p><formula xml:id="formula_0">? ? ?</formula><p>Concatenate the node features from the MLP to those from the LPE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(h)</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Concatenate node features</head><p>A?en?on between all pairs of nodes features and the edge between them. Different linear projec?ons are used to compute a?en?on for real edges and added edges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(i)</head><p>Apply the main transformer Output Predic?on layer</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MLP</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MLP</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Transformer encoders</head><p>on the dimension of size </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Absolute and relative positional encoding with eigenfunctions</head><p>The notion of positional encodings (PEs) in graphs is not a trivial concept, as there exists no canonical way of ordering nodes or defining axes. In this section, we investigate how eigenfunctions of the Laplacian can be used to define absolute and relative PEs in graphs, to measure physical interactions between nodes, and to enable "hearing" of specific sub-structures -similar to how the sound of a drum can reveal its structure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.1">Eigenvectors equate to sine functions over graphs</head><p>In the Transformer architecture, a fundamental aspect is the use of sine and cosine functions as PEs for sequences <ref type="bibr" target="#b35">[36]</ref>. However, sinusoids cannot be clearly defined for arbitrary graphs, since there is no clear notion of position along an axis. Instead, their equivalent is given by the eigenvectors ? of the graph Laplacian L. Indeed, in a Euclidean space, the Laplacian (or Laplace) operator corresponds to the divergence of the gradient and its eigenfunctions are sine/cosine functions, with the squared frequencies corresponding to the eigenvalues (we sometimes interchange the two notions from here on). Hence, in the graph domain, the eigenvectors of the graph Laplacian are the natural equivalent of sine functions, and this intuition was employed in multiple recent works which use the eigenvectors as PEs for GNNs <ref type="bibr" target="#b14">[15]</ref>, for directional flows <ref type="bibr" target="#b3">[4]</ref> and for Transformers <ref type="bibr" target="#b13">[14]</ref>.</p><p>Being equivalent to sine functions, we naturally find that the Fourier Transform of a function</p><formula xml:id="formula_1">F [f ] applied to a graph gives F [f ](? i ) = f, ? i</formula><p>, where the eigenvalue is considered as a position in the Fourier domain of that graph <ref type="bibr" target="#b5">[6]</ref>. Thus, the eigenvectors are best viewed as vectors positioned on the axis of eigenvalues rather than components of a matrix as illustrated in Figure <ref type="figure" target="#fig_3">2</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.2">What do eigenfunctions tell us about relative positions?</head><p>In addition to being the analog of sine functions, the eigenvectors of the Laplacian also hold important information about the physics of a system and can reveal distance metrics. This is not surprising as the Laplacian is a fundamental operator in physics and is notably used in Maxwell's equations <ref type="bibr" target="#b15">[16]</ref> and the heat diffusion <ref type="bibr" target="#b5">[6]</ref>.</p><p>In electromagnetic theory, the (pseudo)inverse of the Laplacian, known in mathematics as the Green's function of the Laplacian <ref type="bibr" target="#b8">[9]</ref>, represents the electrostatic potential of a given charge. In a graph, the same concept uses the pseudo-inverse of the Laplacian G and can be computed by its eigenfunctions. See equation 1 , where G(j 1 , j 2 ) is the electric potential between nodes j 1 and j 2 , ?i and ?i are the i-th eigenvectors and eigenvalues of the symmetric Laplacian D</p><formula xml:id="formula_2">-1 2 LD -1</formula><p>2 , and D is the degree matrix, and ?i,j the j-th row of the vector.</p><formula xml:id="formula_3">G(j 1 , j 2 ) = d 1 2 j1 d -1 2 j2 i&gt;0 ( ?i,j1 ?i,j2 ) 2 ?i (1)</formula><p>Further, the original solution of the heat equation given by Fourier relied on a sum of sines/cosines known as a Fourier series <ref type="bibr" target="#b6">[7]</ref>. As eigenvectors of the Laplacian are the analogue of these functions in graphs, we find similar solutions. Knowing that heat kernels are correlated to random walks <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b3">4]</ref>, we use the interaction between two heat kernels to define in equation 2 the diffusion distance d D between nodes j 1 , j 2 <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b9">10]</ref>. Similarly, the biharmonic distance d B was proposed as a better measure of distances <ref type="bibr" target="#b27">[28]</ref>. Here we use the eigenfunctions of the regular Laplacian L.</p><formula xml:id="formula_4">d 2 D (j 1 , j 2 ) = k&gt;0 e -2t?i (? i,j1 -? i,j2 ) 2 , d 2 B (j 1 , j 2 ) = i&gt;0 (? i,j1 -? i,j2 ) 2 ? 2 i (2)</formula><p>There are a few things to note from these equations. Firstly, they highlight the importance of pairing eigenvectors and their corresponding eigenvalues when supplying information about relative positions in a graph. Secondly, we notice that the product of eigenvectors is proportional to the electrostatic interaction, while the subtraction is proportional to the diffusion and biharmonic distances. Lastly, there is a consistent pattern across all 3 equations: smaller frequencies/eigenvalues are more heavily weighted when determining distances between nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.3">Hearing the shape of a graph and its sub-structures</head><p>Another well-known property of eigenvalues is how they can be used to discriminate between different graph structures and sub-structures, as they can be interpreted as the frequencies of resonance of the graph. This led to the famous question about whether we can hear the shape of a drum from its eigenvalues <ref type="bibr" target="#b22">[23]</ref>, with the same questions also applying to geometric objects <ref type="bibr" target="#b11">[12]</ref> and 3D molecules <ref type="bibr" target="#b32">[33]</ref>. Various success was found with the eigenfunctions being used for partial functional correspondence <ref type="bibr" target="#b31">[32]</ref>, algorithmic understanding geometries <ref type="bibr" target="#b25">[26]</ref>, and style correspondence <ref type="bibr" target="#b11">[12]</ref>.</p><p>Examples of eigenvectors for molecular graphs are presented in Figure <ref type="figure" target="#fig_4">3</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Laplace Eigenfunctions etiquette</head><p>In Euclidean space and sequences, using sinusoids as PEs is trivial: we can simply select a set of frequencies, compute the sinusoids, and add or concatenate them to the input embeddings, as is done in the original Transformer <ref type="bibr" target="#b35">[36]</ref>. However, in arbitrary graphs, reproducing these steps is not as simple since each graph has a unique set of eigenfunctions. In the following section, we present key principles from spectral graph theory to consider when constructing PEs for graphs, most of which have been overlooked by prior methods. They include normalization, the importance of the eigenvalues and their multiplicities, the number of eigenvectors being variable, and sign ambiguities.</p><p>Our LPE architectures, presented in section 3, aim to address them.</p><p>Normalization. Given an eigenvalue of the Laplacian, there is an associated eigenspace of dimension greater than 1. To make use of this information in our model, a single eigenvector has to be chosen.</p><p>In our work, we use the L 2 normalization since it is compatible with the definition of the Green's function <ref type="bibr" target="#b0">(1)</ref>. Thus, we will always chose eigenvectors ? such that ?, ? = 1.</p><p>Eigenvalues. Another fundamental aspect is that the eigenvalue associated with each eigenvector supplies valuable information. An ordering of the eigenvectors based on their eigenvalue works in sequences since the frequencies are pre-determined. However, this assumption does not work in graphs since the eigenvalues in their spectrum can vary. For example, in Figure <ref type="figure" target="#fig_4">3</ref>, we observe how an ordering would miss the fact that both molecules resonate at ? = 1 in different ways.</p><p>Multiplicities. Another important problem with choosing eigenfunctions is the possibility of a high multiplicity of the eigenvalues, i.e. when an eigenvalue appears as a root of the characteristic polynomial more than once. In this case, the associated eigenspace may have dimension 2 or more as we can generate a valid eigenvector from any linear combination of eigenvectors with the same eigenvalue. This further complicates the problem of choosing eigenvectors for algorithmic computations and highlights the importance of having a model that can handle this ambiguity.</p><p>Variable number of eigenvectors. A graph G i can have at most N i linearly independent eigenvectors with N i being its number of nodes. Most importantly, N i can vary across all G i in the dataset. Prior work <ref type="bibr" target="#b13">[14]</ref> elected to select a fixed number k eigenvectors for each graph, where k ? N i , ?i. This produces a major bottleneck when the smallest graphs have significantly fewer nodes than the largest graphs in the dataset since a very small proportion of eigenvectors will be used for large graphs. This inevitably causes loss of information and motivates the need for a model which constructs fixed PEs of dimension k, where k does not depend on the number of eigenvectors in the graph.</p><p>Sign invariance. As noted earlier, there is a sign ambiguity with the eigenvectors. With the sign of ? being independent of its normalization, we are left with a total of 2 k possible combination of signs when choosing k eigenvectors of a graph. Previous work has proposed to do data augmentation by randomly flipping the sign of the eigenvectors <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b13">14]</ref>, and although it can work when k is small, it becomes intractable for large k.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Learning with Eigenfunctions</head><p>Learning generalizable information from eigenfunctions is fundamental to their succesful usage. Here we detail important points that support it is possible to do so if done correctly.</p><p>Similar graphs have similar spectra. Thus, we can expect the network to transfer patterns across graphs through the similarity of their spectra. In fact, spectral graph theory tells us that the lowest and largest non-zero eigenvalues are both linked to the geometry of the graph (algebraic connectivity and spectral radius).</p><p>Eigenspaces contain geometric information. Spectral graph theory has studied the geometric and physical properties of graphs from their Laplacian eigenfunctions in depth. Developing a method that can use the full spectrum of a graph makes it theoretically possible capture this information. It us thus important to capture differences between the full eigenspaces instead of minor differences between specific eigenvalues or eigenvectors from graph to graph.</p><p>Learned positions are relative within graphs. Eigenspaces are used to understand the relationship between nodes within graphs, not across them. Proposed models should therefore only compare the eigenfunctions of nodes within graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Model Architecture</head><p>In this section, we propose an elegant architecture that can use the eigenfunctions as PEs while addressing the concerns raised in section 2.2. Our Spectral Attention Network (SAN) model inputs eigenfunctions of a graph and projects them into a learned positional encoding (LPE) of fixed size.</p><p>The LPE allows the network to use up to the entire Laplace spectrum of each graph, learn how the frequencies interact, and decide which are most important for the given task.</p><p>We propose a two-step learning process summarized earlier in Figure <ref type="figure" target="#fig_2">1</ref>. The first step, depicted by blocks (c-d-e) in the figure, applies a Transformer over the eigenfunctions of each node to generate an LPE matrix for each graph. The LPE is then concatenated to the node embeddings (blocks g-h), before being passed to the Graph Transformer (block i). If the task involves graph classification or regression, the final node embeddings are subsequently passed to a final pooling layer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">LPE Transformer Over Nodes</head><p>Using Laplace encodings as node features is ubiquitous in the literature concerning the topic. Here, we propose a method for learning node PEs motivated by the principles from section 2.2. The idea of our LPE is inspired by Figure <ref type="figure" target="#fig_3">2</ref>, where the eigenvectors ? are represented as a non-uniform sequence with the eigenvalue ? being the position on the frequency axis. With this representation, Transformers are a natural choice for processing them and generating a fixed-size PE.</p><p>The proposed LPE architecture is presented in Figure <ref type="figure" target="#fig_5">4</ref>. First, we create an embedding matrix of size 2 ? m for each node j by concatenating the m-lowest eigenvalues with their associated eigenvectors. Here, m is a hyper-parameter for the maximum number of eigenvectors to compute and is analog to the variable-length sequence for a standard Transformer. For graphs where m &gt; N , a masked-padding is simply added. Note that to capture the entire spectrum of all graphs, one can simply select m such that it is equal to the maximum number of nodes a graph has in the dataset. A linear layer is then applied on the dimension of size 2 to generate new embeddings of size k. A Transformer Encoder then computes self-attention on the sequence of length m and hidden dimension k. Finally, a sum pooling reduces the sequence into a fixed k-dimensional node embedding.</p><p>The LPE model addresses key limitations of previous graph Transformers and is aligned with the first four etiquettes presented in section 2.2. By concatenating the eigenvalues with the normalized eigenvector, this model directly addresses the first three etiquettes. Namely, it normalizes the eigenvectors, pairs eigenvectors with their eigenvalues and treats the number of eigenvectors as a variable. Furthermore, the model is aware of multiplicities and has the potential to linearly combine or ignore some of the repeated eigenvalues.</p><p>However, this method still does not address the limitation that the sign of the pre-computed eigenvectors is arbitrary. To combat this issue, we randomly flip the sign of the pre-computed eigenvectors during training as employed by previous work <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b13">14]</ref>, to promote invariance to the sign ambiguity. N denoting the number of nodes. Since the Transformer loops over the nodes, each node can be viewed as an element of a batch to parallelize the computation. Here ? i,j is the j-th element of the eigenvector paired to the i-th lowest eigenvalue ? i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">LPE Transformer Over Edges</head><p>Here we present an alternative formulation for Laplace encodings. This method addresses the same issues as the LPE over nodes, but also resolves the eigenvector sign ambiguity. Instead of encoding absolute positions as node features, the idea is to consider relative positions encoded as edge features.</p><p>Inspired by the physical interactions introduced in 1 and 2, we can take a pair of nodes (j 1 , j 2 ) and obtain sign-invariant operators using the absolute subtraction |? i,j1 -? i,j2 | and the product ? i,j1 ? i,j2 . These operators acknowledge that the sign of ? i,j1 at a given node j 1 is not important, but that the relative sign between nodes j 1 and j 2 is important. One might argue that we could directly compute the deterministic values from equations (1, 2) as edge features instead. However, our goal is to construct models that can learn which frequencies to emphasize and are not biased towards the lower frequencies -despite lower frequencies being useful in many tasks.</p><p>This approach is only presented thoroughly in appendix A, since it suffers from a major computational bottleneck compared to the LPE over nodes. In fact, for a fully-connected graph, there are N times more edges than nodes, thus the computation complexity is O(m 2 N 2 ), or O(N 4 ) considering all eigenfunctions. The same limitation also affects memory and prevents the use of large batch sizes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Main Graph Transformer</head><p>Our attention mechanism in the main Transformer is based on previous work <ref type="bibr" target="#b13">[14]</ref>, which attempts to repurpose the original Transformer to graphs by considering the graph structure and improving attention estimates with edge feature embeddings.</p><p>In the following, note that h l i is the i-th node's features at the l-th layer, and e ij is the edge feature embedding between nodes i and j. Our model employs multi-head attention over all nodes:</p><formula xml:id="formula_5">?l+1 i = O l h H k=1 ( j?V w k,l ij V k,l h l j )<label>(3)</label></formula><p>where</p><formula xml:id="formula_6">O l h ? R d?d , V k,l ? R d k ?d</formula><p>, H denotes the number of heads, L the number of layers, and concatenation. Note that d is the hidden dimension, while d k is the dimension of a head ( d H = d k ). A key addition from our work is the design of an architecture that performs full-graph attention while preserving local connectivity with edge features via two sets of attention mechanisms: one for nodes connected by real edges in the sparse graph and one for nodes connected by added edges in the fully-connected graph. The attention weights w k,l ij in equation 3 at layer l and head k are given by:</p><formula xml:id="formula_7">?k,l ij = ? ? ? ? ? ? ? Q 1,k,l h l i ?K 1,k,l h l j ?E 1,k,l eij ? d k</formula><p>if i and j are connected in sparse graph</p><formula xml:id="formula_8">Q 2,k,l h l i ?K 2,k,l h l j ?E 2,k,l eij ? d k otherwise ? ? ? ? ? ? ?<label>(4)</label></formula><formula xml:id="formula_9">w k,l ij = ? ? ? 1 1+? ? softmax( d k ?k,l ij ) if i and j are connected in sparse graph ? 1+? ? softmax( d k ?k,l ij ) otherwise ? ? ?<label>(5)</label></formula><p>where ? denotes element-wise multiplication and</p><formula xml:id="formula_10">Q 1,k,l , Q 2,k,l , K 1,k,l , K 2,k,l , E 1,k,l , E 2,k,l ? R d k ?d . ? ? R + is</formula><p>a hyperparameter which tunes the amount of bias towards full-graph attention, allowing flexibility of the model to different datasets and tasks where the necessity to capture longrange dependencies may vary. Note that softmax outputs are clamped between -5 and 5 for numerical stability and that the keys, queries and edge projections are different for pairs of connected nodes</p><formula xml:id="formula_11">(Q 1 , K 1 , E 1 ) and disconnected nodes (Q 2 , K 2 , E 2 ).</formula><p>A multi-layer perceptron (MLP) with residual connections and normalization layers are then applied to update representations, in the same fashion as the GT method <ref type="bibr" target="#b13">[14]</ref>.</p><formula xml:id="formula_12">?l+1 = Norm(h l i + ?l+1 i ), ?l+1 i = W l 2 ReLU(W l 1 ?l+1 i ), h l+1 i = Norm( ?l+1 + ?l+1 i ) (6)</formula><p>with the weight matrices W l 1 ? R 2d?d , W l 2 ? R d?2d . Edge representations are not updated as it adds complexity with little to no performance gain. Bias terms are omitted for presentation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Limitations</head><p>The first limitation of the node-wise LPE, and noted in Table <ref type="table">1</ref> is the lack of sign invariance of the model. A random sign-flip of an eigenvector can produce different outputs for the LPE, meaning that the model needs to learn a representation invariant to these flips. We resolve this issue with the edge-wise LPE proposed in 3.2, but it comes at a computational cost.</p><p>Another limitation of the approach is the computational complexity of the LPE being O(m 2 N ), or O(N 3 ) if considering all eigenfunctions. Further, as nodes are batched in the LPE, the total memory on the GPU will be num_params * num_nodes_in_batch instead of num_params * batch_size. Although this is limiting, the LPE is not parameter hungry, with k usually kept around 16. Most of the model's parameters are in the Main Graph Transformer of complexity O(N 2 ).</p><p>Despite Transformers having increased complexity, they managed to revolutionalize the NLP community. We argue that to shift away from the message-passing paradigm and generalize Transformers to graphs, it is natural to expect higher computational complexities. This is exacerbated by sequences being much simpler to understand than graphs due to their linear structure. Future work could overcome this by using variations of Transformers that scale linearly or logarithmically <ref type="bibr" target="#b33">[34]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Theoretical properties of the architecture</head><p>Due to the full connectivity, it is trivial that our model does not suffer from the same limitations in expressivity as its convolutional/message-passing counterpart.</p><p>WL test and universality. The DGN paper <ref type="bibr" target="#b3">[4]</ref> showed that using the eigenvector ? 1 is enough to distinguish some non-isomorphic graphs indistinguishable by the 1-WL test.</p><p>Given that our model uses the full set of eigenfunctions, and given enough parameters, our model can distinguish any pair of non-isomorphic graphs and is more powerful than any WL test in that regard. However, this does not solve the graph isomorphism problem in polynomial time; it only approximates a solution, and the number of parameters required is unknown and possibly non-polynomial. In appendix C, we present a proof of our statement, and discuss why the WL test is not well suited to study the expressivity of graph Transformers due to their universality.</p><p>Reduced over-squashing. Over-squashing represents the difficulty of a graph neural network to pass information to distant neighbours due to the exponential blow-up in computational paths <ref type="bibr" target="#b0">[1]</ref>.</p><p>For the fully-connected network, it is trivial to see that over-squashing is non-existent since there are direct paths between distant nodes.</p><p>Physical interactions. Another point to consider is the ability of the network to learn physical interactions between nodes. This is especially important when the graph models physical, chemical, or biological structures, but can also help understanding pixel interaction in images <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref>. Here, we argue that our SAN model, which uses the Laplace spectrum more effectively, can learn to mimic the physical interactions presented in section 2.1.2. This contrasts with the convolutional approach that requires deep layers for the receptive field to capture long-distance interactions. It also contrasts with the GT model <ref type="bibr" target="#b13">[14]</ref>, which does not use eigenvalues or enough eigenfunctions to properly model physical interactions in early layers. However, due to the lack of sign-invariance in the proposed node-wise LPE, it is difficult to learn these interactions accurately. The edge-wise LPE (section 3.2) could be better suited for the problem, but it suffers from higher computational complexity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Experimental Results</head><p>The model is implemented in PyTorch <ref type="bibr" target="#b30">[31]</ref> and DGL <ref type="bibr" target="#b37">[38]</ref> and tested on established benchmarks from <ref type="bibr" target="#b14">[15]</ref> and <ref type="bibr" target="#b20">[21]</ref> provided under MIT license. Specifically, we applied our method on ZINC, PATTERN, CLUSTER, MolHIV and MolPCBA, while following their respective training protocols with minor changes, as detailed in the appendix B.1. The computation time and hardware is provided in appendix B.4.</p><p>We first conducted an ablation study to fairly compare the benefits of using full attention and/or the node LPE. We then took the best-performing model, tuned some of its hyperparameters, and matched it up against the current state-of-the-art methods. Since we use a similar attention mechanism, our code was developed on top of the code from the GT paper <ref type="bibr" target="#b13">[14]</ref>, provided under the MIT license.   <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b20">21]</ref> for the node LPE and full graph attention, with no hyperparameter tuning other than ? taken from Figure <ref type="figure" target="#fig_6">5</ref>. For a given dataset, all models use the same hyperparameters, but the hidden dimensions are adjusted to have ? 500k learnable parameters. Means and uncertainties are derived from four runs, with different seeds (except MolHIV).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Sparse vs. Full Attention</head><p>To study the effect of incorporating full attention, we present an ablation study of the ? parameter in Figure <ref type="figure" target="#fig_6">5</ref>. We remind readers that ? is used in equation 5 to balance between sparse and full attention. Setting ? = 0 strictly enables sparse attention, while ? = 1 does not bias the model in any direction.</p><p>It is apparent that molecular datasets, namely ZINC and MOLHIV, benefit less from full attention, with the best parameter being log ? ? (-7, -5). On the other hand, the larger SBM datasets (PATTERN and CLUSTER) benefit from a higher ? value. This can be explained by the fact that molecular graphs rely more on understanding local structures such as the presence of rings and specific bonds, especially in the artificial task from ZINC which relies on counting these specific patterns <ref type="bibr" target="#b14">[15]</ref>. Furthermore, molecules are generally smaller than SBMs. As a result, we would expect less need for full attention, as information between distant nodes can be propagated with few iterations of even sparse attention. We also expect molecules to have fewer multiplicities, thus reducing the space of eigenvectors. Lastly, the performance gains in using full attention on the CLUSTER dataset can be attributed to it being a semi-supervised task, where some nodes within each graph are assigned their true labels. With full attention, every node receives information from the labeled nodes at each iteration, reinforcing confidence about the community they belong to.</p><p>In Figure <ref type="figure">6</ref>, we present another ablation study to measure the impact of the node LPE in both the sparse and full architectures. We observe that the proposed node-wise LPE contributes significantly to the performance for molecular tasks (ZINC and MOLHIV), and believe that it can be attributed to the detection of substructures (see Figure <ref type="figure" target="#fig_4">3</ref>). For PATTERN and CLUSTER, the improvement is modest as the tasks are simple clustering <ref type="bibr" target="#b14">[15]</ref>. Previous work even found that the optimal number of eigenvectors to construct PE for PATTERN is only 2 <ref type="bibr" target="#b13">[14]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Comparison to the state-of-the-art</head><p>When comparing to the state-of-the-art (SOTA) models in the literature in Figure <ref type="figure">7</ref>, we observe that our SAN model consistently performs better on all synthetic datasets from <ref type="bibr" target="#b14">[15]</ref>, highlighting the strong expressive power of the model. On the MolHIV dataset, the performance on the test set is slightly lower than the SOTA. However, the model performs better on the validation set (85.30%) in comparison to PNA (84.25%) and DGN (84.70%). This can be attributed to a well-known issue with this dataset: the validation and test metrics have low correlation. In our experiments, we found higher test results with lower validation scores when restricting the number of epochs. Here, we also included results on the MolPCBA dataset, where we witnessed competitive results as well.</p><p>Other top-performing models, namely PNA <ref type="bibr" target="#b10">[11]</ref> and DGN <ref type="bibr" target="#b3">[4]</ref>, use a message-passing approach <ref type="bibr" target="#b16">[17]</ref> with multiple aggregators. When compared to attention-based models, SAN consistently outperforms the SOTA by a wide margin. To the best of our knowledge, SAN is the first fully-connected model to perform well on graph tasks, as is evident by the poor performance of the GT (full) model.  <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b20">21]</ref>, against GCN <ref type="bibr" target="#b24">[25]</ref>, GraphSage <ref type="bibr" target="#b17">[18]</ref>, GIN <ref type="bibr" target="#b38">[39]</ref>, GAT <ref type="bibr" target="#b36">[37]</ref>, GatedGCN <ref type="bibr" target="#b4">[5]</ref>, PNA <ref type="bibr" target="#b10">[11]</ref>, and DGN <ref type="bibr" target="#b3">[4]</ref>. Means and uncertainties are derived from four runs with different seeds, except MolHIV which uses 10 runs with identical seed. The number of parameters is fixed to ? 500k for ZINC, PATTERN and CLUSTER.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>In summary, we presented the SAN model for graph neural networks, a new Transformer-based architecture that is aware of the Laplace spectrum of a given graph from the learned positional encodings. The model was shown to perform on par or better than the SOTA on multiple benchmarks and outperforms other Attention-based models by a large margin. As is often the case with Transformers, the current model suffers from a computational bottleneck, and we leave it for future work to implement variations of Transformers that scale linearly or logarithmically. This will enable the edge-wise LPE presented in appendix A, a theoretically more powerful version of the SAN model.</p><p>Societal Impact. The presented work is focused on theoretical and methodological improvements to graph neural networks, so there are limited direct societal impacts. However, indirect negative impacts could be caused by malicious applications developed using the algorithm. One such example is the tracking of people on social media by representing their interaction as graphs, thus predicting and influencing their behavior towards an external goal. It also has an environmental impact due to the greater energy use that arises from the computational cost O(m 2 N + N 2 ) being larger than standard message passing or convolutional approaches of O(E).</p><p>Funding Disclosure.</p><p>Devin Kreuzer is supported by an NSERC grant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A LPE Transformer Over Edges</head><p>Consider one of the most fundamental notions in physics; Potential energy. Interestingly, potential energy is always measured as a potential difference; it is not an inherent individual property, such as mass. Strikingly, it is also the relative Laplace embeddings of two nodes that paint the picture, as a node's Laplace embedding on its own reveals no information at all. With this in mind, we argue that Laplace positional encodings are more naturally represented as edge features, which encode a notion of relative position of the two endpoints in the graph. This can be viewed as a distance encoding, which was shown to improve the performance of node and link prediction in GNNs <ref type="bibr" target="#b26">[27]</ref>.</p><p>The formulation is very similar to the method for learning positional node embeddings. Here, a Transformer Encoder is applied on each graph by treating edges as a batch of variable size and eigenvectors as a variable sequence length. We again compute up to the m-lowest eigenvectors with their eigenvalues but, instead of directly using the eigenvector elements, we compute the following vectors:</p><formula xml:id="formula_13">|? :,j1 -? :,j2 | (7) ? :,j1 ? ? :,j2<label>(8)</label></formula><p>where ":" denotes along all up to m eigenvectors, and ? denotes element-wise multiplication. Note that these new vectors are completely invariant to sign permutations of the precomputed eigenvectors.</p><p>As per the LPE over nodes, the 3-length vectors are expanded with a linear layer to generate embeddings of size k before being input to the Transformer Encoder. The final embeddings are then passed to a sum pooling layer to generate fixed-size edge positional encodings, which are then used to compute attention weights in equation 4.</p><p>This method addresses all etiquettes raised in section 2.2. However, it suffers from a major computational bottleneck compared to the LPE over nodes. Indeed, for a fully-connected graph, there are N times more edges than nodes, thus the computation complexity is O(m 2 N 2 ), or O(N 4 ) considering all eigenfunctions. This same limitation also affects the memory, as efficiently batching the N 2 edges will increase the memory consumption of the LPE by a drastic amount, preventing the model from using large batch sizes and making it difficult to train. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B Appendix -Implementation details B.1 Benchmarks and datasets</head><p>To test our models' performance, we rely on standard benchmarks proposed by <ref type="bibr" target="#b14">[15]</ref> and <ref type="bibr" target="#b20">[21]</ref> and provided under the MIT license. In particular, we chose ZINC, PATTERN, CLUSTER, and MolHIV.</p><p>ZINC <ref type="bibr" target="#b14">[15]</ref>. A synthetic molecular graph regression dataset, where the predicted score is given by the subtraction of computationally estimated properties logP -SA. Here, logP is the computed octanol-water partition coefficient, and SA is the synthetic accessibility score <ref type="bibr" target="#b21">[22]</ref>.</p><p>CLUSTER <ref type="bibr" target="#b14">[15]</ref>. A synthetic benchmark for node classification. The graphs are generated with Stochastic Block Models, a type of graph used to model communities in social networks. In total, 6 communities are generated and each community has a single node with its true label assigned. The task is to classify which nodes belong to the same community.</p><p>PATTERN <ref type="bibr" target="#b14">[15]</ref>. A synthetic benchmark for node classification. The graphs are generated with Stochastic Block Models, a type of graph used to model communities in social networks. The task is to classify the nodes into 2 communities, testing the GNNs ability to recognize predetermined subgraphs.</p><p>MolHIV <ref type="bibr" target="#b20">[21]</ref>. A real-world molecular graph classification benchmark. The task is to predict whether a molecule inhibits HIV replication or not. The molecules in the training, validation, and test sets are divided using a scaffold splitting procedure that splits the molecules based on their two-dimensional structural frameworks. The dataset is heavily imbalanced towards negative samples. It is also known that this dataset suffers from a strong de-correlation between validation and test set performance, meaning that more hyperparameter fine-tuning on the validation set often leads to lower test set results.</p><p>MolPCBA <ref type="bibr" target="#b20">[21]</ref>. Another real-world molecular graph classification benchmark. The dataset is larger than MolHIV and applies a similar scaffold spliting procedure. It consists of multiple, extremely skewed (only 1.4% positivity) molecular classification tasks, and employs Average Precision (AP) over them as a metric.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.2 Ablation studies</head><p>The results in Figures <ref type="figure" target="#fig_6">5</ref><ref type="figure">6</ref>are done as an ablation study with a minimal tuning of the hyperparameters of the network to measure the impact of the node LPE and full attention. A majority of the hyperparameters used were tuned in previous work <ref type="bibr" target="#b14">[15]</ref>. However, we altered some of the existing parameters to accommodate the parameter-heavy LPE, and modified the Main Graph Transformer hidden dimension such that all models have approximately ? 500k parameters for a fair comparison. We present results for the full attention with the optimal ? value optimized on the Node LPE model. We did this to isolate the impact that the Node LPE has on improving full attention. Details concerning the model architecture parameters are visible in Figure <ref type="figure">9</ref>.</p><p>procedures for consistency. We selected an initial learning rate of 10 -4 , a reduce factor of 0.5, a patience of 20, a minimum learning rate of 10 -5 , a weight decay of 0 and a dropout of 0.03.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.3 SOTA Comparison study</head><p>For the results in Figure <ref type="figure">7</ref>, we tuned some of the hyperparameters, using the following strategies. The optimal parameters are in bold.</p><p>ZINC. Due to the 500k parameter budget, we tuned the pairing {GT layers, GT hidden dimension} ? {{6, 72}, {8, 64}, {10,56}} and readout ? {"mean", "sum"} PATTERN. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C Expressivity and complexity analysis of graph Transformers</head><p>In this section, we discuss how the universality of Transformers translates to graphs when using different node identifiers. Theoretically, this means that by simply labeling each node, Transformers can learn to distinguish any graph, and the WL test is no longer suited to study their expressivity.</p><p>Thus, we introduce the notion of learning complexity to better compare each architecture's ability to understand the space of isomorphic graphs. We apply the complexity analysis to the LPE and show that it can more easily capture the structure of graphs than a naive Transformer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.1 Universality of Transformers for sequence-to-sequence approximations</head><p>In recent work <ref type="bibr" target="#b39">[40]</ref> [41], it was proven that Transformers are universal sequence-to-sequence approximators, meaning that they can encode any function that approximately maps any first sequence into a second sequence when given enough parameters. More formally, they proved the following theorems for the universality of Transformers: Theorem 1. For any 1 ? p &lt; ?, ? &gt; 0 and any function f : R d?n ? R d?n that is equivariant to permutations of the columns, there is a Transformer g such that the L p distance between f and g is smaller than ?.</p><p>Let B n be the n-dimensional closed ball and denote by C 0 (B d?n , R d?n ) the set of all continuous functions of the ball to R d?n . A Transformer with positional encoding g p is a Transformer g such that to each input X, a fixed learned positional encoding E is added such that g p (X) = g(X + E).</p><p>Theorem 2. For any 1 ? p &lt; ?, ? &gt; 0 and any function f ? C 0 (B d?n , R d?n ), there is a Transformer with positional encoding g such that the L p distance between f and g is smaller than ?.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.2 Graph Transformers approximate solutions to the graph isomorphism problem</head><p>We now explore the consequences of the previous 2 theorems on the use of Transformers for graph representation learning. We first describe 2 types of Transformers on graphs; one for node and one for edge inputs. They will be used to deduce corollaries of theorems 1 and 2 for graph learning and later comparison with our proposed architecture. Assume now that all nodes of the graphs we consider are given an integer label in {1, ..., N }.</p><p>The naive edge transformer takes as input a graph represented as a sequence of ordered pairs ((i, j), ? i,j ) with i ? j the indices of 2 vertices and ? i,j equal to 1 or 0 if the vertices i, j are connected or not. Recall there are N (N -1)/2 pairs of integers i, j in {1, ..., N } with i &lt; j the indices of 2 vertices and ? i,j equal to 1 or 0 if the vertices i, j are connected or not.</p><p>It is obvious that any ordering of these edge vectors describe the same graph. Recall there are N (N -1)/2 pairs of integers i, j in {1, ..., N } with i ? j. Consider the set of functions f : R N (N -1)/2?2 ? R N (N -1)/2?2 that are equivariant to the permutations of columns then theorem 1 says the function f can be approximated with arbitrary accuracy by Transformers on edge input.</p><p>The naive node Transformer can be defined as a Transformer with positional encodings. This graph Transformer will take as input the identity matrix and as positional encodings the padded adjacency matrix. This can be viewed as a one-hot encoding of each node's neighbors. Consider the set of continuous functions f : R N ?N ? R N ?N , then theorem 2 says the function f can be approximated with arbitrary accuracy by Transformers on node inputs.</p><p>From these two observations on the universality of graph Transformers, we get as a corollary that these 2 types of Transformers can approximate solutions of the graph isomorphism problem. In each case, pick a function that is invariant under node index permutations and maps non-isomorphic graphs to different values and apply theorem 1 or 2 that shows there is a Transformer approximating that function to an arbitrarily small error in the L p distance. This is an interesting fact since it is known that the discrimination power of most message passing graph networks is upper bounded by the Weisfeiler-Lehman test which is unable to distinguish some graphs.</p><p>This may seem strange since it is unlikely there is an algorithm solving the graph isomorphism problem in polynomial time to the number of nodes N , and we address this issue in the notes below.</p><p>Note 1: Only an approximate solution. The universality theorems do not state that Transformers solve the isomorphism problem, but that they can approximate a solution. They only learn the invariant functions only up to some error so they still can mislabel graphs.</p><p>Note 2: Estimate of number of Transformer blocks. For the approximation of the function f by a Transformer to be precise, a large number of Transformer blocks will be needed. In <ref type="bibr" target="#b39">[40]</ref>, it is stated that the universal class of function is obtained by composing Transformer blocks with 2 heads of size 1 followed by a feed-forward layer with 4 hidden nodes. In <ref type="bibr" target="#b40">[41]</ref> section 4.1, an estimate of the number of blocks is given. If</p><formula xml:id="formula_14">f : R d?n ? R d?n is L-Lipschitz, then ||f (X) -f (Y )|| &lt; ?/2 when ||X -Y || &lt; ?/2L = ? .</formula><p>In the notation of <ref type="bibr" target="#b40">[41]</ref>, the LPE has constants p = 2 and s = 1. If g is a composition of Transformer blocks then an error ||f -g|| L p &lt; ? can be achieved with a number of Transformer blocks larger than</p><formula xml:id="formula_15">dn ? + p(n -1) ? d + s + n ? dn = dn2L ? + 2(n -1)(2L) d ? d + 1 + n(2L) dn ? dn</formula><p>In the case of the node encoder described above, n = d = N (the number of nodes) and the last term in the sum above becomes N (2L/?) N 2 , so the number of parameters and therefore the computational time is exponential in the number of nodes for a fixed error ?. Note that this bound on the number of Transformer blocks might not be tight and might be much lower for a specific problem.</p><p>Note 3: Learning invariance to label permutations. In the above proof, the Transformer is assumed to be able to label all isomorphic graphs into the same class within a small error. However, given a graph of N nodes, there are N ! different node labeling permutations, and they all need to be mapped to the same output class. It seems unlikely that such function can be learned with polynomial complexity to N . Following these observations, it does not seem appropriate to compare Transformers to the WL test as is the custom for graph neural networks and we think at this point we should seek a new measure of expressiveness of graph Transformers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.3 Expressivity of the node-LPE</head><p>Here, we want to show that the proposed node-LPE can generate a unique node identifier that allows our Transformer model to be a universal approximator on graphs, thus allowing us to approximate a solution to graph isomorphism.</p><p>Recall the node LPE takes as input an N ? m ? 2 tensor with m the number of eigenvalues and eigenvectors that are used to represent the nodes. The output is a N ? k tensor. Notice that 2 non-isomorphic graphs on N nodes can have the same m &lt; N eigenvalues and eigenspaces and disagree on the last N -m eigenvalues and eigenspaces. Any learning algorithm missing the last N -m pieces of information won't be able to distinguish these graphs. Here we will fix some m and show that the resulting Transformer can approximately classify all graphs with N ? m.</p><p>Fix some linear injection M : R N ?2?m ? R N ?k?m . Let G be a graph and U ? R N ?2?m be bounded set containing all the tensor representations of graphs T G and let R be the radius of a ball containing M (U ). Consider the set C 0 (B N ?k?m R , R N ?k?m ) of continuous functions of the closed radius R ball in R N ?k?m . Finally, denote by S : R N ?k?m ? R N ?k the linear function taking the sum of all values in the m dimension. The following universality result for LPE Transformers is a direct consequence of theorem 2.</p><p>Proposition 1. For any 1 ? p &lt; ?, ? &gt; 0 and any continuous function F : B N ?k?m R ? R N ?k , there is an LPE Transformer g such that the L p distance between M ? f ? S and g is smaller than ?.</p><p>As a corollary, we get the same kind of approximation to solutions of the graph isomorphism problem as with the naive Transformers. Let f be a function of C 0 (B N ?k?m R , R N ?k?m ) that maps M (T G ) to a value that is only dependent of the isomorphism class of the graph and assigns different values to different isomorphism classes. We can further assume that f takes values that are 0 for all but one coordinate in the k dimension. The same type of argument is possible for the edge-LPE from figure <ref type="figure" target="#fig_7">8</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.4 Comparison of the learning complexity of naive graph Transformers and LPE</head><p>We now argue that while the LPE Transformer and the naive graph Transformers of section C.2 can all approximate a function f solution of the graph isomorphism problem, the complexity of the learning problem of the LPE is much lower since the spaces it has to learn are simpler.</p><p>Naive Node Transformer. First recall that the naive node Transformer learns a map f : R N 2 ? R N 2</p><p>. In this situation, each graph is represented by N ! different matrices which all have to be identified by the Transformer. This encoding also does not provide any high-level structural information about the graph.</p><p>Naive Edge Transformer. The naive edge Transformer has the same difficulty since the function its learning is R N (N -1) ? R N (N -1) and the representation of each edge depend on a choice of labeling of the vertices and the N ! possible labelings need to be identified again.</p><p>Node-LPE Transformer. In the absence of eigenvalues with multiplicity &gt; 1, the node LPE that learns a function R N ?2?m ? R N ?k does not take as input a representation of the graph that depends on the ordering of the nodes. It does, however, depend on the choice of the sign of each of the eigenvectors so there are still 2 N possible choices of graph representations that need to be identified by the Transformer but this is a big drop in complexity compared to the previous N !. The eigenfunctions also provide high-level structural information about the graph that can simplify the learning task of the graph.</p><p>Edge-LPE Transformer. Finally, the edge LPE of appendix A uses a graph representation as input that is also independent of the sign choice of the eigenvectors so each graph has a unique representation (considering the absence of eigenvalues with multiplicity &gt; 1). Again, the eigenfunctions provide high-level structural information that is not available to the naive Transformer.</p><p>LPE Transformers for non-isospectral graphs. Isospectral graphs are graphs that have the same set of eigenvalues despite having different eigenvectors. Here, we argue that the proposed node LPE can approximate a solution to the graph isomorphism problem for all pairs of non-isospectral graphs, without having to learn invariance to the sign of their eigenvectors nor their multiplicities. By considering only the eigenvalues in the initial linear layer (assigning a weight of 0 to all ?), and knowing that the eigenvalues are provided as inputs, the model can effectively learn to replicate the input eigenvalues at its output, thus discriminating between all pairs of non-isospectral graphs. Hence, the problem of learning an invariant mapping to the sign of eigenvectors and multiplicities is limited only to non-isospectral graphs. Knowing that the ratio of isospectral graphs decreases as the number of nodes increases (and is believed to tend to 0) <ref type="bibr" target="#b34">[35]</ref>, this is especially important for large graphs and mitigates the problem of having to learn to identify 2 N with eigenvectors with different signs. In Figure <ref type="figure" target="#fig_8">11</ref>, we present an example of non-isomorphic graphs that can be distinguished by their eigenvalues but not by the 1-WL test. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>th lowest eigenvalue : The normalized eigenvector associated to : The -th row of For each node , generate an ini?al posi?onal encoding (PE) using the -first and . If a graph has less than nodes, add a masked padding.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: The proposed SAN model with the node LPE, a generalization of Transformers to graphs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: a) Standard view of the eigenvectors as a matrix. b) Eigenvectors ? i viewed as vectors positionned on the axis of frequencies (eigenvalues).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Examples of eigenvalues ? i and eigenvectors ? i for molecular graphs. The low-frequency eigenvectors ? 1 , ? 2 are spread accross the graph, while higher frequencies, such as ? 14 , ? 15 for the left molecule or ? 10 , ? 11 for the right molecule, often resonate in local structures.</figDesc><graphic url="image-6.png" coords="4,217.79,612.43,64.49,66.86" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Learned positional encoding (LPE) architectures, with the model being aware of the graph's Laplace spectrum by considering m eigenvalues and eigenvectors, where we permit m ? N , withN denoting the number of nodes. Since the Transformer loops over the nodes, each node can be viewed as an element of a batch to parallelize the computation. Here ? i,j is the j-th element of the eigenvector paired to the i-th lowest eigenvalue ? i .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Effect of the ? parameter on the performance across datasets from [15, 21], using the Node LPE. Dotted black lines indicate sparse attention, which is equivalent to setting ? = 0. Each box plot consists of 4 runs, with different seeds (except MolHIV).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Edge-wise positional (LPE) architectures, where the relative position is considered instead of the absolute position. The model is aware of the graph's Laplace spectrum by considering m eigenvalues and eigenvectors, where we permit m ? N , with N denoting the number of nodes. Since the Transformer loops over the edges, each edge can be viewed as an element of a batch to parallelize the computation. The computational complexity is O(m 2 E) or O(m 2 N 2 ) for a fully-connected graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Example of non-isomorphic graphs that can be distinguished by the eigenvalues of their Laplacian matrix, but not by the 1-WL test.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Due to the 500k parameter budget and long training times, we only tuned the pairing {GT layers, GT hidden dimension} ? {{4,80}, {6, 64}} CLUSTER. Due to the 500k parameter budget and long training times, we only tuned the pairing {GT layers, GT hidden dimension} ? {{12, 64}, {16,48}} MolHIV. With no parameter budget, we elected to do a more extensive parameter tuning in a two-step process while measuring validation metrics on 3 runs with identical seeds. 1. We tuned LPE dimension ? {8, 16}, GT layers ? {4, 6, 8, 10}, GT hidden dimension ? {48, 64, 72, 80, 96} 2. With the highest performing validation model from step 1, we then tuned dropout ? {0, 0.01, 0.025} and weight decay ? {0, 10 -6 , 10 -5 } With the final optimized parameters, we reran 10 experiments with identical seeds. MolPCBA. With no parameter budget, we elected to do a more extensive parameter tuning as well. We tuned learning rate ? {0.0001, 0.0003, 0.0005}, dropout ? {0, 0.1, 0.2, 0.3, 0.4, 0.5}, GT layers ? {2, 4, 5, 6, 8, 10, 12}, GT layers ? {128, 256, 304, 512}, LPE layers ? {8, 10, 12} amd LPE</figDesc><table><row><cell cols="2">dimension ? {8, 16}</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">B.4 Computation details</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Dataset</cell><cell>Resource</cell><cell>Cluster</cell><cell>GPU</cell><cell>Epoch/Total time</cell></row><row><cell>ZINC</cell><cell>Compute Canada</cell><cell>Graham</cell><cell>Tesla P100-PCIE (12 GB)</cell><cell>106s/17.88hrs</cell></row><row><cell>PATTERN</cell><cell>Compute Canada</cell><cell>Graham</cell><cell>Tesla P100-PCIE (12 GB)</cell><cell>340s/12.52hrs</cell></row><row><cell>CLUSTER</cell><cell>Compute Canada</cell><cell>Beluga</cell><cell>Tesla V100-SXM2 (16 GB)</cell><cell>433s/11.30hrs</cell></row><row><cell>MOLHIV</cell><cell>Compute Canada</cell><cell>Cedar</cell><cell>Tesla V100-SXM2 (32 GB)</cell><cell>204s/5.34hrs</cell></row><row><cell>MOLPCBA</cell><cell>Compute Canada</cell><cell>Cedar</cell><cell>Tesla V100-SXM2 (32 GB)</cell><cell>883s/48.02hrs</cell></row><row><cell></cell><cell cols="4">Figure 10: Computational details for SOTA Comparison study.</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Presented results add full connectivity before computing the eigenvectors, thus losing the structural information of the graph.</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Attention</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>LPE LPE layers LPE dimension GT layers GT hidden dimension #Parameters</head><p>For the training parameters, we employed an Adam optimizer with a learning rate decay strategy initialized in {10 -3 , 10 -4 }as per <ref type="bibr" target="#b14">[15]</ref>, with some minor modifications:</p><p>ZINC <ref type="bibr" target="#b14">[15]</ref>. We selected an initial learning rate of 7 ? 10 -4 and increased the patience from 10 to 25 to ensure convergence. PATTERN <ref type="bibr" target="#b14">[15]</ref>. We selected an initial learning rate of 5 ? 10 -4 . CLUSTER <ref type="bibr" target="#b14">[15]</ref>. We selected an initial learning rate of 5 ? 10 -4 and reduced the minimum learning rate from 10 -6 to 10 -5 to speed up training time. MolHIV <ref type="bibr" target="#b20">[21]</ref>. We elected to use similar training</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">On the bottleneck of graph neural networks and its practical implications</title>
		<author>
			<persName><forename type="first">Uri</forename><surname>Alon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eran</forename><surname>Yahav</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2006.05205</idno>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
	<note>cs, stat</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Alexandre Duperr?, and Maxime Raison. Deep green function convolution for improving saliency in convolutional neural networks</title>
		<author>
			<persName><forename type="first">Dominique</forename><surname>Beaini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sofiane</forename><surname>Achiche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Visual Computer</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="227" to="244" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Improving convolutional neural networks via conservative field regularisation and integration</title>
		<author>
			<persName><forename type="first">Dominique</forename><surname>Beaini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sofiane</forename><surname>Achiche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maxime</forename><surname>Raison</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName><forename type="first">Dominique</forename><surname>Beaini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Saro</forename><surname>Passaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vincent</forename><surname>L?tourneau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">L</forename><surname>Hamilton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gabriele</forename><surname>Corso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pietro</forename><surname>Li?</surname></persName>
		</author>
		<title level="m">Directional graph networks. ICML2021</title>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">Xavier</forename><surname>Bresson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Laurent</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1711.07553</idno>
		<title level="m">Residual gated graph convnets</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Geometric deep learning: going beyond euclidean data</title>
		<author>
			<persName><forename type="first">M</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joan</forename><surname>Bronstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yann</forename><surname>Bruna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arthur</forename><surname>Lecun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Szlam</surname></persName>
		</author>
		<author>
			<persName><surname>Vandergheynst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Signal Processing Magazine</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="18" to="42" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">A History of Mathematics</title>
		<author>
			<persName><forename type="first">F</forename><surname>Cajori</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>AMS</publisher>
			<pubPlace>Chelsea</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Spectral graph attention network</title>
		<author>
			<persName><forename type="first">Heng</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yu</forename><surname>Rong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tingyang</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wenbing</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Somayeh</forename><surname>Sojoudi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Junzhou</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wenwu</forename><surname>Zhu</surname></persName>
		</author>
		<idno>CoRR, abs/2003.07450</idno>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Discrete green&apos;s functions</title>
		<author>
			<persName><forename type="first">Fan</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>Yau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Combinatorial Theory, Series A</title>
		<imprint>
			<biblScope unit="volume">91</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="191" to="214" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Diffusion maps</title>
		<author>
			<persName><forename type="first">Ronald</forename><forename type="middle">R</forename><surname>Coifman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">St?phane</forename><surname>Lafon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Special Issue: Diffusion Maps and Wavelets</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="5" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Principal neighbourhood aggregation for graph nets</title>
		<author>
			<persName><forename type="first">Gabriele</forename><surname>Corso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luca</forename><surname>Cavalleri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dominique</forename><surname>Beaini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pietro</forename><surname>Li?</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Petar</forename><surname>Veli?kovi?</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2004.05718</idno>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Isospectralization, or how to hear shape, style, and correspondence</title>
		<author>
			<persName><forename type="first">Luca</forename><surname>Cosmo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mikhail</forename><surname>Panine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arianna</forename><surname>Rampini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maks</forename><surname>Ovsjanikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">M</forename><surname>Bronstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emanuele</forename><surname>Rodola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR)</title>
		<meeting>the IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR)</meeting>
		<imprint>
			<date type="published" when="2019-06">June 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Graph neural networks with adaptive frequency response filter</title>
		<author>
			<persName><forename type="first">Yushun</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kaize</forename><surname>Ding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brian</forename><surname>Jalaian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shuiwang</forename><surname>Ji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jundong</forename><surname>Li</surname></persName>
		</author>
		<idno>CoRR, abs/2104.12840</idno>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">A generalization of transformer networks to graphs</title>
		<author>
			<persName><forename type="first">Vijay</forename><surname>Prakash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dwivedi</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Xavier</forename><surname>Bresson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><forename type="first">Vijay</forename><surname>Prakash Dwivedi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Chaitanya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Joshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yoshua</forename><surname>Laurent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xavier</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><surname>Bresson</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2003.00982</idno>
		<title level="m">Benchmarking graph neural networks</title>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">Richard</forename><surname>Phillips Feynman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Benjamin Leighton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><surname>Sands</surname></persName>
		</author>
		<title level="m">The Feynman lectures on physics; New millennium ed</title>
		<meeting><address><addrLine>New York, NY</addrLine></address></meeting>
		<imprint>
			<publisher>Basic Books</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="1963" to="1965" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Neural message passing for quantum chemistry</title>
		<author>
			<persName><forename type="first">Justin</forename><surname>Gilmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Samuel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrick</forename><forename type="middle">F</forename><surname>Schoenholz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oriol</forename><surname>Riley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><forename type="middle">E</forename><surname>Vinyals</surname></persName>
		</author>
		<author>
			<persName><surname>Dahl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th International Conference on Machine Learning</title>
		<meeting>the 34th International Conference on Machine Learning</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">70</biblScope>
			<biblScope unit="page" from="1263" to="1272" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Inductive representation learning on large graphs</title>
		<author>
			<persName><forename type="first">Will</forename><surname>Hamilton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhitao</forename><surname>Ying</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jure</forename><surname>Leskovec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1024" to="1034" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Graph Representation Learning</title>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">L</forename><surname>Hamilton</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2020">2020</date>
			<publisher>Morgan and Claypool</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Long short-term memory</title>
		<author>
			<persName><forename type="first">Sepp</forename><surname>Hochreiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J?rgen</forename><surname>Schmidhuber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neural computation</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1735" to="1780" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Open graph benchmark: Datasets for machine learning on graphs</title>
		<author>
			<persName><forename type="first">Weihua</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Fey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marinka</forename><surname>Zitnik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuxiao</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hongyu</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bowen</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michele</forename><surname>Catasta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jure</forename><surname>Leskovec</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2005.00687</idno>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Junction tree variational autoencoder for molecular graph generation</title>
		<author>
			<persName><forename type="first">Wengong</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Regina</forename><surname>Barzilay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tommi</forename><surname>Jaakkola</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1802.04364</idno>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
	<note>cs, stat</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Can one hear the shape of a drum?</title>
		<author>
			<persName><forename type="first">Mark</forename><surname>Kac</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The American Mathematical Monthly</title>
		<imprint>
			<biblScope unit="volume">73</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1966">1966</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Differentiable graph module (dgm) graph convolutional networks</title>
		<author>
			<persName><forename type="first">Anees</forename><surname>Kazi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luca</forename><surname>Cosmo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nassir</forename><surname>Navab</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Bronstein</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2002.04999</idno>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Semi-supervised classification with graph convolutional networks</title>
		<author>
			<persName><forename type="first">N</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Max</forename><surname>Kipf</surname></persName>
		</author>
		<author>
			<persName><surname>Welling</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1609.02907</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Laplace-beltrami eigenfunctions towards an algorithm that &quot;understands&quot; geometry</title>
		<author>
			<persName><forename type="first">B</forename><surname>Levy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Shape Modeling and Applications 2006 (SMI&apos;06)</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="13" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Distance encoding: Design provably more powerful neural networks for graph representation learning</title>
		<author>
			<persName><forename type="first">Pan</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yanbang</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hongwei</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jure</forename><surname>Leskovec</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Biharmonic distance</title>
		<author>
			<persName><forename type="first">Yaron</forename><surname>Lipman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Raif</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">A</forename><surname>Rustamov</surname></persName>
		</author>
		<author>
			<persName><surname>Funkhouser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2010-07">July 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<author>
			<persName><forename type="first">Heli</forename><surname>Haggai Maron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hadar</forename><surname>Ben-Hamu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yaron</forename><surname>Serviansky</surname></persName>
		</author>
		<author>
			<persName><surname>Lipman</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1905.11136</idno>
		<title level="m">Provably powerful graph networks</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Weisfeiler and leman go neural: Higher-order graph neural networks</title>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Ritzert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Fey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>William L Hamilton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gaurav</forename><surname>Eric Lenssen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Rattan</surname></persName>
		</author>
		<author>
			<persName><surname>Grohe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the AAAI Conference on Artificial Intelligence</title>
		<meeting>the AAAI Conference on Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="4602" to="4609" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Adam</forename><surname>Paszke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sam</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Soumith</forename><surname>Chintala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gregory</forename><surname>Chanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Edward</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zachary</forename><surname>Devito</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zeming</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alban</forename><surname>Desmaison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luca</forename><surname>Antiga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adam</forename><surname>Lerer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<author>
			<persName><forename type="first">Emanuele</forename><surname>Rodol?</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luca</forename><surname>Cosmo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">M</forename><surname>Bronstein</surname></persName>
		</author>
		<title level="m">Andrea Torsello, and Daniel Cremers. Partial functional correspondence</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Can one hear the shape of a molecule (from its coulomb matrix eigenvalues</title>
		<author>
			<persName><forename type="first">Joshua</forename><surname>Schrier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Chemical Information and Modeling</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="3804" to="3811" />
			<date type="published" when="2020">2020</date>
			<publisher>American Chemical Society</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Efficient transformers: A survey</title>
		<author>
			<persName><forename type="first">Yi</forename><surname>Tay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mostafa</forename><surname>Dehghani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dara</forename><surname>Bahri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Donald</forename><surname>Metzler</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Which graphs are determined by their spectrum?</title>
		<author>
			<persName><forename type="first">Edwin</forename><forename type="middle">R</forename><surname>Van Dam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Willem</forename><forename type="middle">H</forename><surname>Haemers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Linear Algebra and its Applications</title>
		<imprint>
			<biblScope unit="volume">373</biblScope>
			<biblScope unit="page" from="241" to="272" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Attention is all you need</title>
		<author>
			<persName><forename type="first">Ashish</forename><surname>Vaswani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Noam</forename><surname>Shazeer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Niki</forename><surname>Parmar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jakob</forename><surname>Uszkoreit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Llion</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aidan</forename><forename type="middle">N</forename><surname>Gomez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lukasz</forename><surname>Kaiser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Illia</forename><surname>Polosukhin</surname></persName>
		</author>
		<idno>CoRR, abs/1706.03762</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Graph attention networks</title>
		<author>
			<persName><forename type="first">Petar</forename><surname>Veli?kovi?</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guillem</forename><surname>Cucurull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arantxa</forename><surname>Casanova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adriana</forename><surname>Romero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pietro</forename><surname>Lio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yoshua</forename><surname>Bengio</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1710.10903</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Deep graph library: A graph-centric, highly-performant package for graph neural networks</title>
		<author>
			<persName><forename type="first">Minjie</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Da</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zihao</forename><surname>Ye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Quan</forename><surname>Gan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mufei</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiang</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jinjing</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chao</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lingfan</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yu</forename><surname>Gai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tianjun</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tong</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Karypis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jinyang</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zheng</forename><surname>Zhang</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1909.01315</idno>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<author>
			<persName><forename type="first">Keyulu</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Weihua</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jure</forename><surname>Leskovec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefanie</forename><surname>Jegelka</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1810.00826</idno>
		<title level="m">How powerful are graph neural networks? arXiv preprint</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Are transformers universal approximators of sequence-to-sequence functions?</title>
		<author>
			<persName><forename type="first">Chulhee</forename><surname>Yun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Srinadh</forename><surname>Bhojanapalli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ankit</forename><surname>Singh Rawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sashank</forename><forename type="middle">J</forename><surname>Reddi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sanjiv</forename><surname>Kumar</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">$o(n)$ connections are expressive enough: Universal approximability of sparse transformers</title>
		<author>
			<persName><forename type="first">Chulhee</forename><surname>Yun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yin-Wen</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Srinadh</forename><surname>Bhojanapalli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ankit</forename><surname>Singh Rawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sashank</forename><forename type="middle">J</forename><surname>Reddi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sanjiv</forename><surname>Kumar</surname></persName>
		</author>
		<idno>CoRR, abs/2006.04862</idno>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Seongjun</forename><surname>Yun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Minbyul</forename><surname>Jeong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raehyun</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jaewoo</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hyunwoo</forename><forename type="middle">J</forename><surname>Kim</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
	<note>Graph transformer networks</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
