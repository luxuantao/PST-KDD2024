<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Algorithms for Maximum Satisfiability using Unsatisfiable Cores</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Joao</forename><surname>Marques-Silva</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Electronics &amp; Computer Science</orgName>
								<orgName type="institution">University of Southampton</orgName>
								<address>
									<settlement>Southampton</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jordi</forename><surname>Planes</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Electronics &amp; Computer Science</orgName>
								<orgName type="institution">University of Southampton</orgName>
								<address>
									<settlement>Southampton</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Algorithms for Maximum Satisfiability using Unsatisfiable Cores</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">577F8D2070B42ACFAE99D8F85C256406</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:32+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Many decision and optimization problems in Electronic</head><p>Design Automation (EDA) can be solved with Boolean Satisfiability (SAT). Moreover, well-known extensions of SAT also find application in EDA, including Pseudo-Boolean  Optimization, Quantified Boolean Formulas, Multi-Valued  SAT and, more recently, Maximum Satisfiability (MaxSAT). Algorithms for MaxSAT are still fairly inefficient in industrial settings, in part because the most effective SAT techniques cannot be easily extended to MaxSAT. This paper proposes a novel algorithm for MaxSAT that improves existing state of the art solvers by orders of magnitude on industrial benchmarks. The new algorithm exploits modern SAT solvers, being based on the identification of unsatisfiable subformulas. Moreover, the new algorithm provides additional insights between unsatisfiable subformulas and the maximum satisfiability problem.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Boolean Satisfiability (SAT) is used for solving an ever increasing number of decision and optimization problems in Electronic Design Automation (EDA). These include model checking, equivalence checking, design debugging, logic synthesis, and technology mapping, among many others <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b25">26]</ref>. Besides SAT, a number of wellknown extensions of SAT also find application in EDA, including Pseudo-Boolean Optimization (PBO) (e.g. <ref type="bibr" target="#b20">[21]</ref>), Quantified Boolean Formulas (QBF) (e.g. <ref type="bibr" target="#b7">[8]</ref>), Multi-Valued SAT <ref type="bibr" target="#b19">[20]</ref> and, more recently, Maximum Satisfiability (MaxSAT) <ref type="bibr" target="#b23">[24]</ref>.</p><p>MaxSAT is a well-known problem in Computer Science, consisting of finding the largest number of satisfied clauses in unsatisfiable instances of SAT. Algorithms for MaxSAT are in general not effective for large industrial problem instances, in part because the most effective SAT techniques cannot be applied directly to MaxSAT <ref type="bibr" target="#b3">[4]</ref> (e.g. unit propagation).</p><p>Motivated by the recent and promising application of MaxSAT in EDA (e.g. <ref type="bibr" target="#b23">[24]</ref>) this paper proposes a novel algorithm for MaxSAT, msu4, that performs particularly well for large industrial instances. Instead of the usual algorithms for MaxSAT, the proposed algorithm exploits existing SAT solver technology, and the ability of SAT solvers for finding unsatisfiable subformulas. Despite building on the work of others, on the relationship between maximally satisfiable and minimally unsatisfiable subformulas <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b10">11]</ref>, the approach outlined in this paper is new, in that unsatisfiable subformulas are used for guiding the search for the solution to the MaxSAT problem. The msu4 algorithm builds on recent algorithms for the identification of unsatisfiable subformulas, which find other significant applications in EDA <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b22">23]</ref>. The msu4 algorithm also builds on recent work on solving PBO with SAT <ref type="bibr" target="#b9">[10]</ref>, namely on techniques for encoding cardinality constraints as Boolean circuits obtained from BDDs. Finally, the msu4 algorithm differs from the one in <ref type="bibr" target="#b10">[11]</ref> in the way unsatisfiable subformulas are manipulated, and in the overall organization of the algorithm. Experimental results, obtained on representative EDA industrial instances, indicate that in most cases the new msu4 algorithm is orders of magnitude more efficient than the best existing MaxSAT algorithms. The msu4 also opens a new line of research, that tightly integrates SAT, unsatisfiable subformulas, and MaxSAT.</p><p>The paper is organized as follows. The next section provides a brief overview of MaxSAT and existing algorithms. Section 3 describes the msu4 algorithm, and proves the correctness of the proposed approach. Section 4 provides experimental results, comparing msu4 with alternative MaxSAT algorithms. The paper concludes in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Background</head><p>This section provides definitions and background knowledge for the MaxSAT problem. Due to space constraints, familiarity with SAT and related topics is assumed and the reader is directed to the bibliography <ref type="bibr" target="#b4">[5]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">The MaxSAT Problem</head><p>The maximum satisfiability (MaxSAT) problem can be stated as follows. Given an instance of SAT represented in CNF, compute an assignment that maximizes the number of satisfied clauses. During the last decade there has been a growing interest on studying MaxSAT, motivated by an increasing number of practical applications, including scheduling, routing, bioinformatics, and EDA <ref type="bibr" target="#b23">[24]</ref>.</p><p>Despite the clear relationship with the SAT problem, most modern SAT techniques cannot be applied directly to the MaxSAT problem. As a result, most MaxSAT algorithms are built on top of the standard DPLL <ref type="bibr" target="#b5">[6]</ref> algorithm, and so do not scale for industrial problem instances <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b10">11]</ref>.</p><p>The usual approach (most of the solvers in the MaxSAT competition <ref type="bibr" target="#b0">[1]</ref>) is based on a Branch and Bound algorithm, emphasizing the computation of lower bounds and the application of inference rules that simplify the instance <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b17">18]</ref>. Results from the MaxSAT competition <ref type="bibr" target="#b0">[1]</ref> suggest that algorithms based on alternative approaches (e.g. by converting MaxSAT into SAT) do not perform well. As a result, the currently best performing MaxSAT solvers are based on branch and bound with additional inference rules.</p><p>More recently, an alternative, in general incomplete, approach to MaxSAT has been proposed <ref type="bibr" target="#b23">[24]</ref>. The motivation for this alternative approach is the potential application of MaxSAT in design debugging, and the fact that existing MaxSAT approaches do not scale for industrial problem instances.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Solving MaxSAT with PBO</head><p>One alternative approach for solving the MaxSAT problem is to use Pseudo-Boolean Optimization (PBO) (e.g. <ref type="bibr" target="#b18">[19]</ref>). The PBO approach for MaxSAT consists of adding a new (blocking) variable to each clause. The blocking variable b i for clause ω i allows satisfying clause ω i independently of other assignments to the problem variables. The resulting PBO formulation includes a cost function, aiming at minimizing the number of blocking variables assigned value 1. Clearly, the solution of the MaxSAT problem is obtained by subtracting from the number of clauses the solution of the PBO problem. Despite its simplicity, the PBO formulation does not scale for industrial problems, since the large number of clauses results in a large number of blocking variables, and corresponding larger search space. Observe that, for most instances, the number of clauses exceeds the number of variables. For the resulting PBO problem, the number of variables equals the sum of the number of variables and clauses in the original SAT problem. Hence, the modified instance of SAT has a much larger search space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Relating MaxSAT with Unsatisfiable Cores</head><p>In recent years there has been work on relating minimum unsatisfiable and maximally satisfiable subformulas <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b10">11]</ref>. Nevertheless, this work has not been extended to solving the MaxSAT problem.</p><p>This section summarizes properties on the relationship between unsatisfiable cores and MaxSAT, which are used in the next section for developing msu4. Let ϕ be an unsatisfiable formula with a number of unsatisfiable cores, which may or may not be disjoint. Note that two cores are disjoint if the cores have no identical clauses. Let |ϕ| denote the number of clauses in ϕ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 1 (MaxSAT Upper Bound) Let ϕ contain K disjoint unsatisfiable cores. Then |ϕ| -K denotes an upper bound on the solution of the MaxSAT problem.</head><p>Furthermore, suppose blocking variables are added to clauses in ϕ such that the resulting formula ϕ W becomes satisfiable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 2 (MaxSAT Lower Bound) Let ϕ W be satisfiable, and let B denote the set of blocking variables assigned value 1. Then |ϕ| -|B| denotes a lower bound on the solution of the MaxSAT problem.</head><p>Clearly, the solution to the MaxSAT problem lies between any computed lower and upper bound.</p><p>Finally, it should be observed that the relationship of unsatisfiable cores and MaxSAT was also explored in <ref type="bibr" target="#b10">[11]</ref> in the context of partial MaxSAT. This algorithm, msu1, removes one unsatisfiable core each time, by adding a fresh set of blocking variables to the clauses in each unsatisfiable core. A possible drawback of the algorithm of <ref type="bibr" target="#b10">[11]</ref> is that it can add multiple blocking variables to each clause, an upper bound being the number of clauses in the CNF formula <ref type="bibr" target="#b21">[22]</ref>. In constrast, the msu4 algorithm adds at most one additional blocking variable to each clause. Moreover, a number of algorithmic improvements to the algorithm of <ref type="bibr" target="#b10">[11]</ref> can be found in <ref type="bibr" target="#b21">[22]</ref>, i.e. msu2 and msu3. The proposed improvements include linear encoding of the cardinality constraints, and an alternative approach to reduce the number of blocking variables used.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">A New MaxSAT Algorithm</head><p>This section develops the msu4 algorithm, by building on the results of the section 2.3. As shown earlier, the major drawback of using a PBO approach for the MaxSAT problem is the large number of blocking variables that have to be used (essentially one for each original clause). For most benchmarks, the blocking variables end up being significantly more than the original variables, which is reflected in the cost function and overall search space. The large number of blocking variables basically renders the PBO approach ineffective in practice.</p><p>The msu4 algorithm attempts to reduce as much as possible the number of necessary blocking variables, thus simplifying the optimization problem being solved. Moreover, msu4 avoids interacting with a PBO solver and instead is fully SAT-based.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Overview</head><p>Following the results of section 2.3, consider identifying disjoint unsatisfiable cores of ϕ. This can be done by iteratively computing unsatisfiable cores, and adding blocking variables to the clauses in the unsatisfiable cores. The identification and blocking of unsatisfiable cores is done on a working formula ϕ W . Eventually, a set of disjoint unsatisfiable cores is identified, and the blocking variables allow satisfying ϕ W . From Proposition 2, this represents a lower bound on the solution of the MaxSAT problem. This lower bound can be refined, by requiring fewer blocking variables to be assigned value 1. This last condition can be achieved by adding a cardinality constraint to ϕ 1 .</p><p>The resulting formula can still be satisfiable, in which case a further refined cardinality constraint is added to ϕ W . Alternatively, the formula is unsatisfiable. In this case, some clauses of ϕ without blocking variables may exist in the unsatisfiable core. If this is the case, each clause is augmented with a blocking variable, and a new cardinality constraint can be added to ϕ W , which requires the number of blocking variables assigned value 1 to be less than the total number of new blocking clauses. Alternatively, the core contains no original clause without a blocking variable. If this is the case, then the highest computed lower bound is returned as the solution to the MaxSAT problem. The proof that this is indeed the case, is given below.</p><p>In contrast with the algorithms in <ref type="bibr" target="#b10">[11]</ref> and <ref type="bibr" target="#b21">[22]</ref>, the msu4 algorithm is not exclusively based on enumerating unsatisfiable cores. The msu4 algorithm also identifies satisfiable instances, which are then eliminated by adding additional cardinality constraints. 1 Encodings of cardinality constraints are studied for example in <ref type="bibr" target="#b9">[10]</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">The Algorithm</head><p>Following the ideas of the previous section, the pseudocode for msu4 is shown in Algorithm 1. The msu4 algorithm works as follows. The main loop (lines 8 to 33) starts by identifying disjoint unsatisfiable cores. The clauses in each unsatisfiable core are modified so that any clause ω i in the core can be satisfied by setting to 1 a new auxiliary variable b i associated with ω i . Consequently, a number of properties of the MaxSAT problem can be inferred. Let |ϕ| denote the number of clauses, let ν U represent the number of iterations of the main loop in which the SAT solver outcome is unsatisfiable, and let µ BV denote the smallest of the number of blocking variables assigned value 1 each time ϕ W becomes satisfiable. Then, an upper bound for the MaxSAT problem is |ϕ| -ν U , and a lower bound is |ϕ| -µ BV . Both the lower and the upper bounds provide approximations to the solution of the MaxSAT problem, and the difference between the two bounds provides an indication on the number of iterations. Clearly, the MaxSAT solution will require at most µ BV blocking variables to be assigned value 1. Also, each time the SAT solver declares the CNF formula to be unsatisfiable, then the number of blocking variables that must be assigned value 1 can be increased by 1. Each time ϕ W becomes satisfiable (line 25), a new cardinality constraint is generated (line 30), which requires the number of blocking variables assigned value 1 to be reduced given the current satisfying assignment (and so requires the lower bound to be increased, if possible). Alternatively, each time ϕ W is unsatisfiable (line 12), the unsatisfiable core is analyzed. If there exist initial clauses in the unsatisfiable core, which do not have blocking variables, then additional blocking variables are added (line 17). Formula ϕ W is updated accordingly, by removing the original clauses and adding the modified clauses (line 18). A cardinality constraint is added to require at least one of the blocking clauses to be assigned value 1 (line <ref type="bibr" target="#b18">19)</ref>. Observe that this cardinality constraint is in fact optional, but experiments suggest that it is most often useful. If ϕ W is unsatisfiable, and no additional original clauses can be identified, then the solution to the MaxSAT problem has been identified (line 22). Also, if the lower bound and upper bound estimates become equal (line 32), then the solution to the MaxSAT problem has also been identified. Given the previous discussion, the following result is obtained.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 3 Algorithm 1 gives the correct MaxSAT solution.</head><p>Proof: The algorithm iteratively identifies unsatisfiable cores, and adds blocking variables to the clauses in each unsatisfiable core that do not yet have blocking variables (i.e. initial clauses), until the CNF formula becomes satisfiable. Each computed solution represents an upper bound on the number of blocking variables assigned value 1, and so it also represents a lower bound on the MaxSAT solution. For each computed solution, a new cardinality constraint is added to the formula (see line 30), requiring a smaller number of blocking variables to be assigned value 1. If the algorithm finds an unsatisfiable core containing no more initial clauses without blocking variables, then the algorithm can terminate and the last computed upper bound represents the MaxSAT solution. Observe that in this case the same unsatisfiable core C can be generated, even if blocking clauses are added to other original clauses without blocking clauses. As a result, the existing lower bound is the solution to the MaxSAT problem. Finally, note that the optional auxiliar constraint added in line 19, does not affect correctness, since it solely requires an existing unsatisfiable core not to be re-identified.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">A Complete Example</head><p>This section illustrates the operation of the msu4 algorithm on a small example formula.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 2 Consider the following CNF formula:</head><formula xml:id="formula_0">ϕ = ω 1 • ω 2 • ω 3 • ω 4 • ω 5 • ω 6 • ω 7 • ω 8 (x 1 ) (x 1 + x2 ) (x 2 ) (x 1 + x3 ) (x 3 ) (x 2 + x3 ) (x 1 + x4 ) (x 1 + x 4 )</formula><p>Initially ϕ W contains all the clauses in ϕ. In the first loop iteration, the core ω 1 , ω 2 , ω 3 is identified. As a result, the new blocking variables b 1 , b 2 and b 3 are added, respectively, to clauses ω 1 , ω 2 and ω 3 , and the CNF encoding of the cardinality constraint b</p><formula xml:id="formula_1">1 + b 2 + b 3 ≥ 1 is also (option- ally) added to ϕ W . In the second iteration, ϕ W is satisfi- able, with b 1 = b 3 = 1. As a result, the CNF encoding of a new cardinality constraint, b 1 + b 2 + b 3 ≤ 1, is added to ϕ W .</formula><p>For the next iteration, ϕ W is unsatisfiable and the clauses ω 4 , ω 5 and ω 6 are listed in the unsatisfiable core. As a result, the new blocking variables b 4 , b 5 and b 6 are added, respectively, to clauses ω 4 , ω 5 and ω 6 , and the CNF encoding of the cardinality constraint b 4 + b 5 + b 6 ≥ 1 is also (optionally) added to ϕ W . In this iteration, since the lower and the upper bound become equal, then the algorithm terminates, indicating that two blocking variables need to be assigned value 1, and the MaxSAT solution is 6.</p><p>From the example, it is clear that the algorithm efficiency depends on the ability for finding unsatisfiable formulas effectively, and for generating manageable cardinality constraints. In the implementation of msu4, the cardinality constraints were encoded either with BDDs or with sorting networks <ref type="bibr" target="#b9">[10]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Experimental Results</head><p>The msu4 algorithm described in the previous section has been implemented on top of MiniSAT <ref type="bibr" target="#b8">[9]</ref>. Version 1.14 of MiniSAT was used, for which an unsatisfiable core extractor was available. Two versions of msu4 are considered, one (v1) uses BDDs for representing the cardinality constraints, and the other (v2) uses sorting networks <ref type="bibr" target="#b9">[10]</ref>.</p><p>All results shown below were obtained on a 3.0 GHz Intel Xeon 5160 with 4GB of RAM running RedHat Linux. A timeout of 1000s was used for all MaxSAT solvers considered. The memory limit was set to 2GB. The MaxSAT solvers evaluated are the best performing solver in the MaxSAT evaluation <ref type="bibr" target="#b0">[1]</ref>, maxsatz <ref type="bibr" target="#b17">[18]</ref>, minisat+ <ref type="bibr" target="#b9">[10]</ref> for the MaxSAT PBO formulation, and finally msu4. Observe that the algorithm in <ref type="bibr" target="#b10">[11]</ref> targets partial MaxSAT, and so performs poorly for MaxSAT instances <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b21">22]</ref>.  In order to evaluate the new MaxSAT algorithm, a set of industrial problem instances was selected. These instances were obtained from existing unsatisfiable subsets of industrial benchmarks, obtained from the SAT competition archives and from SATLIB <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b12">13]</ref>. The majority of instances considered was originally from EDA applications, including model checking, equivalence checking, and testpattern generation. Moreover, MaxSAT instances from design debugging <ref type="bibr" target="#b23">[24]</ref> were also evaluated. The total number of unsatisfiable instances considered was 691.</p><p>Table <ref type="table" target="#tab_1">1</ref> shows the number of aborted instances for each algorithm. As can be concluded, for practical instances, existing MaxSAT solvers are innefective. The use of the PBO model for MaxSAT performs better than maxsatz, but aborts more instances than either version of msu4. It should be noted that the PBO approach uses minisat+, which is based on a more recent version of MiniSAT than msu4.</p><p>Figures 1, 2 and 3 show scatter plots comparing maxsatz, the PBO formulation and msu4 v1 with msu4 v2. As can be observed, the two version of msu4 are clearly more efficient than either maxsatz or minisat+ on the MaxSAT formulations. Despite the performance advantage of both versions of msu4, there are exceptions. With few outliers, maxsatz can only outperform msu4 v2 on instances where both algorithms take less than 0.1s. In contrast, minisat+ can outperform msu4 v2 on a number of instances, in part because of the more recent version of MiniSAT used in minisat+. Finally, Table <ref type="table">2</ref> summarizes the results for design debugging instances <ref type="bibr" target="#b23">[24]</ref>. As can be concluded, both versions of msu4 are far more effective than either maxsatz or minisat+ on the PBO model for MaxSAT.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Conclusions</head><p>Motivated by the recent application of maximum satisfiability to design debugging <ref type="bibr" target="#b23">[24]</ref>, this paper proposes a new MaxSAT algorithm, msu4, that further exploits the relationship between unsatisfiable formulas and maximum satisfiability <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b10">11]</ref>. The motivation for the new MaxSAT algorithm is to solve large industrial problem instances, including those from design debugging <ref type="bibr" target="#b23">[24]</ref>. The experimental results indicate that msu4 performs in general significantly better than either the best performing MaxSAT Total maxsatz pbo msu4 v1 msu4 v2 29 26 21 3 3</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 2. Design debugging instances</head><p>algorithm <ref type="bibr" target="#b0">[1]</ref> or the PBO formulation of the MaxSAT problem <ref type="bibr" target="#b18">[19]</ref>. For a number of industrial classes of instances, which modern SAT solvers solve easily but which existing MaxSAT solvers are unable to solve, msu4 is able to find solutions in reasonable time. Clearly, msu4 is effective only for instances for which SAT solvers are effective at identifying small unsatisfiable cores, and from which manageable cardinality constraints can be obtained.</p><p>Despite the promising results, additional improvements to msu4 are expected. One area for improvement is to exploit alternative SAT solver technology. msu4 is based on MiniSAT 1.14 (due to the core generation code), but more recent SAT solvers could be considered. Another area for improvement is considering alternative encodings of cardinality constraints, given the performance differences observed for the two encodings considered. Finally, the interplay between different algorithms based on unsatisfiable core identification (i.e. msu1 <ref type="bibr" target="#b10">[11]</ref> and msu2 and msu3 <ref type="bibr" target="#b21">[22]</ref>) should be further developed.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Example 1</head><label>1</label><figDesc>Consider the CNF formula: ϕ = (x 1 ) (x 2 + x1 ) (x 2 ). The PBO MaxSAT formulation consists of adding a new blocking clause to each clause. The resulting instance of SAT becomes ϕ W = (x 1 + b 1 ) (x 2 + x1 + b 2 ) (x 2 + b 3 ), were b 1 , b 2 , b 3 denote blocking variables, one for each clause. Finally, the cost function for the PBO instance is: min 3 i=1 b i .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Scatter plot: maxsatz vs. msu4-v2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 .Figure 3 .</head><label>23</label><figDesc>Figure 2. Scatter plot: pbo vs. msu4-v2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 . Number of aborted instances</head><label>1</label><figDesc></figDesc><table><row><cell>Total maxsatz pbo msu4 v1 msu4 v2 691 554 248 212 163</cell></row><row><cell>10 -1</cell></row><row><cell>10 -2</cell></row></table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Argelich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Manyà</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Planes</surname></persName>
		</author>
		<ptr target="http://www.maxsat07.udl.es/" />
		<title level="m">MaxSAT evaluation</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Berre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Simon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Roussel</surname></persName>
		</author>
		<ptr target="http://www.satcompetition.org/" />
		<title level="m">Sat competition</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Symbolic model checking without BDDs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Biere</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cimatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Tools and Algorithms for the Construction and Analysis of Systems</title>
		<imprint>
			<date type="published" when="1999-03">March 1999</date>
			<biblScope unit="page" from="193" to="207" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Bonet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Levy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Manyà</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Resolution for Max-SAT</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">171</biblScope>
			<biblScope unit="page" from="606" to="618" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Propositional satisfiability and constraint programming: A comparative survey</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bordeaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Hamadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A machine program for theorem-proving</title>
		<author>
			<persName><forename type="first">M</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Logemann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Loveland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="394" to="397" />
			<date type="published" when="1962-07">July 1962</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Finding all minimal unsatisfiable sub-sets</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">G</forename><surname>De La Banda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Stuckey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wazny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Principles and Practice of Declarative Programming</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Bounded model checking with QBF</title>
		<author>
			<persName><forename type="first">N</forename><surname>Dershowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Hanna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Theory and Applications of Satisfiability Testing</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="408" to="414" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">An extensible SAT solver</title>
		<author>
			<persName><forename type="first">N</forename><surname>Een</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sörensson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Theory and Applications of Satisfiability Testing</title>
		<imprint>
			<date type="published" when="2003-05">May 2003</date>
			<biblScope unit="page" from="502" to="518" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Translating pseudo-Boolean constraints into SAT</title>
		<author>
			<persName><forename type="first">N</forename><surname>Een</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sörensson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Boolean Modeling and Computation</title>
		<imprint>
			<date type="published" when="2006-03">March 2006</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="1" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">On solving the partial MAX-SAT problem</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Theory and Applications of Satisfiability Testing</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="252" to="265" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">MiniMaxSat: a new weighted Max-SAT solver</title>
		<author>
			<persName><forename type="first">F</forename><surname>Heras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Larrosa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Oliveras</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Theory and Applications of Satisfiability Testing</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="41" to="55" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><surname>Hoos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Stützle</surname></persName>
		</author>
		<ptr target="http://www.satlib.org/" />
		<title level="m">Sat lib</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Robust boolean reasoning for equivalence checking and functional property verification</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kuehlmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Paruthi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Krohm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Ganai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on CAD of Integrated Circuits and Systems</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1377" to="1394" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Investigations on autark assignments</title>
		<author>
			<persName><forename type="first">O</forename><surname>Kullmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Applied Mathematics</title>
		<imprint>
			<biblScope unit="volume">107</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="99" to="137" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Lean clause-sets: generalizations of minimally unsatisfiable clause-sets</title>
		<author>
			<persName><forename type="first">O</forename><surname>Kullmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Discrete Applied Mathematics</title>
		<imprint>
			<biblScope unit="volume">130</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="209" to="249" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Detecting disjoint inconsistent subformulas for computing lower bounds for Max-SAT</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Manyà</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Planes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">National Conference on Artificial Intelligence</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">New inference rules for Max-SAT</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Manyà</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Planes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence Research</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
	<note>In press</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">On finding all minimally unsatisfiable subformulas</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Liffiton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">A</forename><surname>Sakallah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Theory and Applications of Satisfiability Testing</title>
		<imprint>
			<date type="published" when="2005-06">June 2005</date>
			<biblScope unit="page" from="173" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Cama: A multi-valued satisfiability solver</title>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kuehlmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W</forename><surname>Moskewicz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Computer-Aided Design</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="326" to="333" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Maximum circuit activity estimation using pseudo-boolean satisfiability</title>
		<author>
			<persName><forename type="first">H</forename><surname>Mangassarian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Veneris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Safarpour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">N</forename><surname>Najm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Abadir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design, Automation and Testing in Europe Conference</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="1538" to="1543" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">On using unsatisfiability for solving maximum satisfiability</title>
		<author>
			<persName><forename type="first">J</forename><surname>Marques-Silva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Planes</surname></persName>
		</author>
		<idno>abs/0712.0097</idno>
	</analytic>
	<monogr>
		<title level="j">Computing Research Repository</title>
		<imprint>
			<date type="published" when="2007-12">December 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Interpolation and SAT-based model checking</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer-Aided Verification</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Improved design debugging using maximum satisfiability</title>
		<author>
			<persName><forename type="first">S</forename><surname>Safarpour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Mangassarian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Veneris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Liffiton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">A</forename><surname>Sakallah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Methods in Computer-Aided Design</title>
		<imprint>
			<date type="published" when="2007-11">November 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Fault diagnosis and logic debugging using boolean satisfiability</title>
		<author>
			<persName><forename type="first">A</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Veneris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Ali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Viglas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on CAD of Integrated Circuits and Systems</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1606" to="1621" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Incremental learning approach and SAT model for boolean matching with don&apos;t cares</title>
		<author>
			<persName><forename type="first">K.-H</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-M</forename><surname>Chan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Computer-Aided Design</title>
		<imprint>
			<date type="published" when="2007-11">November 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Validating SAT solvers using an independent resolution-based checker: Practical implementations and other applications</title>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design, Automation and Testing in Europe Conference</title>
		<imprint>
			<date type="published" when="2003-03">March 2003</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
