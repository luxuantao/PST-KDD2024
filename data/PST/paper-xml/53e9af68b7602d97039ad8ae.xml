<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Muse: Mapping Understanding and deSign by Example</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Bogdan</forename><surname>Alexe #i</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Santa Cruz</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Laura</forename><surname>Chiticariu</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Santa Cruz</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Renee</forename><forename type="middle">J</forename><surname>Miller</surname></persName>
							<email>3miller@cs.toronto.edu</email>
							<affiliation key="aff1">
								<orgName type="institution">University of Toronto</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Wang-Chiew</forename><surname>Tan</surname></persName>
							<email>4wctan@cs.ucsc.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Santa Cruz</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Muse: Mapping Understanding and deSign by Example</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">8C93A027B2F0937D6E7410D41E671045</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:22+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A fundamental problem in information integration is that of designing the relationships, called schema mappings, between two schemas. The specification of a semantically correct schema mapping is typically a complex task. Automated tools can suggest potential mappings, but few tools are available for helping a designer understand mappings and design alternative mappings.</p><p>We describe Muse, a mapping design wizard that uses data examples to assist designers in understanding and refining a schema mapping towards the desired specification. We present novel algorithms behind Muse and show how Muse systematically guides the designer on two important components of a mapping design: the specification of the desired grouping semantics for sets of data and the choice among alternative interpretations for semantically ambiguous mappings. In every component, Muse infers the desired semantics based on the designer's actions on a short sequence of small examples. Whenever possible, Muse draws examples from a familiar database, thus facilitating the design process even further. We report our experience with Muse on some publicly available schemas.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>A fundamental problem in information integration is the specification of the relationships between a source schema and a target schema <ref type="bibr" target="#b0">[1]</ref>. Such a specification is called schema mappings. In some systems such as Map Force', Stylus Studio2 schema mappings are specified with transformation code (e.g., XSLT or Java code). In other systems, including Clio [2], <ref type="bibr" target="#b2">[3]</ref>, HePToX [4], Microsoft's mapping composer <ref type="bibr" target="#b4">[5]</ref>, and IBM's Rational Data Architect3 schema mappings are specified using a declarative language based on a logical formalism. A benefit of such languages is that they facilitate the reuse of mappings for different integration tasks: they can be used to generate executable transformation code for data exchange <ref type="bibr" target="#b1">[2]</ref>, for query translation (reformulation) in data integration <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b7">[8]</ref>, to compose mappings in a peer network environment <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b10">[11]</ref>, and numerous other model management tasks. Tools, such as Clio and HePToX, for semi-automatically creating mappings make the use of declarative mappings viable by automating a large amount of the mapping design task. 1http:llwww.altova.com 2http:llwww.stylusstudio.com/ 3http://www.ibm.com/software/data/integration/rda</p><p>The well-known 80-20 rule applies in mapping design. Mapping creation tools can automate 80% of the work, covering common cases and creating a mapping that is close to cor- rect. However, ensuring complete correctness can still require intricate manual work to perfect portions of the mapping. Previous research on mapping understanding and refinement <ref type="bibr" target="#b11">[12]</ref> and anecdotal evidence from mapping designers suggest that this perfection process can be facilitated by using data examples to explain the mapping and alternative mappings. Mapping designers usually understand their data better than they understand mapping specifications and could therefore, leverage familiar data examples to illustrate nuances of how a small change to a mapping specification changes its semantics. The work of Yan et al. <ref type="bibr" target="#b11">[12]</ref> is based on this observation. A designer can understand and refine a mapping specification, given by SQL queries, between two relational schemas by walking through examples of source data, and seeing how this data would be transformed by different choices of mapping specifications. As part of this work, they studied alternative in- terpretations of a semantically ambiguous mapping. Intuitively, a schema mapping is ambiguous if it specifies, in more than one way, how an atomic target schema element (or attribute) is to be obtained. For example, a schema mapping could be ambiguous because it asserts that a project supervisor is a project manager or a project tech-lead at the same time. In other words, it is not clear whether to extract the manager's name or the tech-lead's name (or both) from a source database as the supervisor of a project in the target database since there are two alternative interpretations to this ambiguous mapping.</p><p>Our work is largely inspired by Yan et al. <ref type="bibr" target="#b11">[12]</ref>. As in their work, Muse uses examples to differentiate between alter- native mapping specifications and infer the desired mapping semantics based on the designer's actions. However, we go significantly beyond the techniques and space of alternative mappings supported by <ref type="bibr" target="#b11">[12]</ref>.</p><p>First, Muse is capable of helping a designer derive the desired grouping semantics for a mapping specification using examples. For example, to infer whether a designer wishes to group projects by a a company's name and location or only by a company's name, Muse automatically constructs a small number of, essentially, yes-or-no questions using small examples. The designer's answers to these questions will allow Muse to infer the desired grouping semantics. For schemas without keys or functional dependencies, the number of questions we pose to the designer is the number of schema elements that the designer could use for designing the grouping semantics. The size of an example typically consists of at most two tuples in each (nested) relation. Furthermore, Muse exploits keys in the source schema (or more general functional dependencies when available) to reduce the number of questions a designer must consider.</p><p>Second, as in <ref type="bibr" target="#b11">[12]</ref>, Muse helps a designer choose among alternative interpretations of an ambiguous mapping. Muse constructs a small example that would illustrate, and differ- entiate, all interpretations. The example is at most as big as the size of the specification of the ambiguous mapping. Each (nested) relation in the source typically contains only a few tuples. In <ref type="bibr" target="#b11">[12]</ref>, the designer is asked to select among the target instances generated by the source example through each alternative interpretation of the mapping. There are as many target instances as the number of alternative interpretations, which can be overwhelming. In Muse, we show the designer one partial target instance and the designer is asked to select among a small set of data choices. Each choice is in fact a list of possible values for a target schema element, corresponding to all alternative interpretations. There are as many choices as the number of schema elements with more than one alternative interpretation, and this number is much smaller than the total number of alternative interpretations for the ambiguous mapping. The designer's actions on these choices translate into a unique interpretation of the ambiguous mapping.</p><p>Finally, unlike previous work which relies exclusively on a source instance to illustrate mappings, Muse can "fall back" to its own constructed example whenever a meaningful example cannot be drawn from the actual source instance. For the current source instance, two mappings may produce indistinguishable results. However, for mapping design it is important for a designer to understand the difference in the mappings over the space of possible source instances. Muse is able to automatically detect when an actual source instance is incapable of illustrating all design alternatives and if so, it is able to construct synthetic examples to illustrate differences in all design alternatives. We show experimentally that this feature of Muse is necessary to help design mappings for some real mapping settings and instances.</p><p>The design components of Muse have been shown to be im- portant mapping design parameters. Grouping has been shown to be important in mappings for not only nested data, including XML, but also in designing mappings for such common tasks as schema evolution <ref type="bibr" target="#b2">[3]</ref>. Furthermore, as described in <ref type="bibr" target="#b11">[12]</ref>, ambiguous mappings frequently arise in real schemas.</p><p>We describe our Muse wizard based on the schema mapping language <ref type="bibr" target="#b1">[2]</ref> for relational and nested relational schemas that has been proposed for data exchange (Sec. II). This language is a generalization of commonly used mapping languages in- cluding source-to-target tuple generating dependencies <ref type="bibr" target="#b12">[13</ref> where e.eid = el.eid and e.ename=e1.ename Fig. <ref type="figure">1</ref>. A mapping scenario. <ref type="bibr" target="#b6">[7]</ref>. The mapping generation algorithms of mapping discovery tools <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b3">[4]</ref> and some model management tools [14] make default decisions in creating mappings, which may not always be the desired ones. In the subsequent sections, we illustrate how Muse allows a designer to refine, understand, debug, and modify a mapping, using data examples, to create a mapping that corresponds to the designer's intended semantics.</p><p>II. BACKGROUND ON MAPPINGS Nested Relational Model. Fig. <ref type="figure">1</ref> shows a mapping scenario between two schemas, CompDB and OrgDB respectively, written in the nested relational (NR) representation of [2], <ref type="bibr" target="#b2">[3]</ref>. The NR model generalizes the relational model where tuples and relations are modeled as records and respectively, sets of records. In the NR model however, an element, such as a set of records, may be nested inside another element, such as a record, to form hierarchies. In the source schema, Companies is a set of Comp records where each record has three atomic elements: cid (company id), cname (company name) and location. Similarly, Projects and Employees are sets of Proj and respectively, Emp records. The two referential constraints fi and f2 specify that for every Proj tuple p, there must exist a Comp tuple c and an Emp tuple e such that p.cid = c.cid and p.manager = e.eid. The target schema is a slight reorganization of the source.</p><p>An NR schema is formally a set of labels {R1,...,Rk}, called roots, where each root is associated with a type T, defined by the following grammar: A (record) value of type Rcd[l: Tl.i-Tn] is a set of label-value pairs <ref type="bibr">[11 :</ref> a,,...,l an], where a,,...,a, are of types Tl, ...,T:, respectively. A value of type Choice[lI: Ti, ..., i 1 Tn] is a single label-value pair [lk : ak], where ak is of type Tk and 1 &lt; k &lt; n. The set type SetOf T (where T is a complex type) is used to model repeatable elements. Order is not considered, hence SetOf represents unordered sets. A value of type SetOf T is represented by a SetID and an associated (possibly empty) set of values {Vl, ..., Vm}, where each vi is of type T. Every type is associated with a path from the root to that type, and whenever we refer to a type, we assume that this path is implicit and uniquely determined (i.e., we cannot have two distinct types with the same path). We use the terms set types and nested sets interchangeably. For example, Orgs, Projects, Employees are all nested sets (or set types) in the target schema. We frequently use the term tuple to refer to a value of type record.</p><p>To simplify our discussions, we assume that XML schemas are modeled using a single schema root of record type whose elements are all of type SetOf. We also assume strict alternation of set and record types. In our implementation, however, we handle the NR model in its full generality.</p><p>Mappings. A schema mapping is a triple (S, T, Z), where E is a set of mappings specified using the language of <ref type="bibr" target="#b2">[3]</ref>. For ease of exposition, we use the mapping language of <ref type="bibr" target="#b1">[2]</ref>, which is a special sublanguage of <ref type="bibr" target="#b2">[3]</ref>, in this paper. Our implementation of Muse in fact handles the full generality of the language of <ref type="bibr" target="#b2">[3]</ref> (see <ref type="bibr" target="#b14">[15]</ref>). As an example, let S and T be the source and target schemas of Fig. <ref type="figure">1</ref>. Then, (S, T, {ml,m2,m3}) is a schema mapping, where ml to M3 are shown in the figure. Intuitively, ml is a specification that maps Comp names to Org names. More precisely, it states that whenever a Comp tuple c exists in the source, there must be an Org tuple o in the set OrgDB.Orgs in the target such that o.oname = c.cname. The value of o.Projects is the SetID (also called grouping function or Skolem function) SKProjs(c.cid,c.cname,c.location). By convention, we use SKN to denote the SetID name of a nested set N in the target schema. For example, the SetID name of the nested set Projects is SKProjects, which we write SKProjs for short (or SK when there is no ambiguity). We sometimes refer to a nested set N simply as SKN. We assume that every nested set in the target schema has a different SetID name. The mapping m2 states that for every Comp tuple c, Proj tuple p and Emp tuple e such that c, p and e satisfy the referential constraints fi and f2, then there must be corresponding Org, Proj and Emp tuples (o, P, and el respectively) in the target with the appropriate values extracted from c, p and e. The mapping m3 migrates employee information to the target, independently of whether the employee is a manager of some project.</p><p>These mappings are expressed in the "query-like" notation of <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b2">[3]</ref> where each variable in the for and exists clauses binds to tuples in a source and respectively, a target nested set. The type of each variable is, hence, a record. The corre- spondences between atomic schema elements (e.g., cname to oname), which are shown in Fig. <ref type="figure">1</ref> as arrows, are expressed as equalities (e.g., c.cname = o.oname) in the where clause of the mapping. In addition, the satisfy clauses following the for and respectively, the exists clause may contain equalities to express source and respectively, target referential constraints. In Muse, we will be constructing source and target instances that satisfy proposed mappings and any constraints on the schemas. Hence, to simplify our discussion in this paper, we assume that mappings are closed under source and target referential constraints. For example, ml, m2 and m3 in Fig. <ref type="figure">1</ref> are mappings that are closed under the source and target referential constraints. However, the following mapping m does not satisfy the source referential constraint fi because "c in CompDB.Companies" and "p.cid = c.cid" are missing from the for and corresponding satisfy clauses respectively. for p in CompDB.Projects, e In CompDB.Employees satisfy e.eid = p.manager exists eI in OrgDB.Employees where e.eid = ei.eid and e.ename = ei.ename A mapping that is not closed under referential constraints can always be transformed into an equivalent one that is closed under referential constraints by chasing <ref type="bibr" target="#b15">[16]</ref>. Mappings that are generated by tools such as Clio are always closed under acyclic referential constraints. The acyclicity condition can in fact be weakened in ways that have been studied by others. Solutions, chase and homomorphisms. Fig. <ref type="figure">2</ref> shows a source instance I and a solution for I with the schema mapping in Fig. <ref type="figure">1</ref>. A target instance J is a solution for I under the schema mapping if I and J together satisfy E.</p><p>The chase procedure has been used to generate solutions in data exchange <ref type="bibr" target="#b12">[13]</ref>. The target instance in Fig. <ref type="figure">2</ref> is in fact the the result of chasing the source instance I with E = {mi, M2, m3}. We describe intuitively the chase process and refer the interested reader to <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b12">[13]</ref> for details of the chase procedure. The instance I is chased with each member of S. Suppose I is first chased with ml. Due to ml and the two Comp records in I, two Org records are constructed in the target: Org(IBM, SKProjs(I1 ,IBM,Almaden)) and Org(SBC, SKProjs(112,SBC,NY)). Due to M2, the first Comp record and the two Proj records, along with their corresponding managers in I, two more Comp records, two Proj records (i.e., (DBSearch,el4) and (WebSearch,el5)) and their corresponding Employee records (i.e., Emp(eI4,Smith) and Emp(eI5, Anna)) are constructed in the target. The two Proj records that are constructed belong to distinct Projects sets whose SetIDs are SKProjs(I 1 1,IBM,Almaden,pl ,...) and respectively, SKProjs(lll,IBM,Almaden,p2,...). Next, I is chased with m3 and three Employee tuples are constructed in the target, two of which (Smith and Anna) have already been generated by M2. The result of chasing I with E is formed by taking the set union of all tuples that have been constructed. Special values, called labeled nulls, may be created during the chase. For example, suppose there is an extra attribute address in Org record, which does not correspond to any element in the source schema. The chase of I with ml will generate two Org tuples: (IBM, N1) and (SBC, N2), where N1 and N2 are labeled nulls used to represent, possible different, unknown address values.</p><p>In general, there are many possible solutions for a source instance I under a schema mapping M = {S, T, Z}. The space of all solutions for I under M is denoted as Sol (M, I), or Sol (E, I) when S and T are understood from the context. It was shown in <ref type="bibr" target="#b12">[13]</ref> that chasing I with E produces a universal solution for I under M. Intuitively, a universal solution J for I under M is a most general solution in the space of all solutions for I in that there is a homomorphism from J to every solution for I under M. We say that h is a homomorphism from an instance J to an instance J', denoted as h: J -&gt; J', if for every tuple R(cl, ..., c,) in J, where R is a relation symbol,</p><p>we have that R(h(cl),...,h(cn)) is a tuple in J', and for every tuple D(cl, ..., cn) in J, where D is a SetID, we have h(D)(h(cl), ..., h(cn)) is a tuple in J'. Furthermore, h has the following properties: (i) h(c) = c if c is a constant, (ii) h(D) = D' if D is a SetID and D' has the same set type as D, and (iii) h(N) is a constant or labeled null if N is a labeled null. In other words, h is the identity on constants but not necessarily on SetIDs or labeled nulls. We say that J and J' are homomorphically equivalent if there is a homomorphism from J to J' and a homomorphism from J' to J. We say that J and J' are isomorphic if there is a one-to-one homomorphism from J to J' and vice versa.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. DESIGNING GROUPING FUNCTIONS</head><p>Grouping or combining related data together is an essential functionality of many integration systems. In this section, we describe the grouping design wizard of Muse, called Muse- G. We show how Muse-G infers a desired grouping function through the actions taken by the designer on a short sequence of small data examples (or questions).</p><p>The mappings generated by mapping generation tools [2], <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b3">[4]</ref> and some model management tools <ref type="bibr" target="#b13">[14]</ref> define a default grouping function for every nested set in the target schema. The grouping functions are a restricted form of Skolem functions, where the ar- guments consist of only atomic attributes. For exam- ple, in [3], the default grouping function for Projects in m2 is SKProjs(c.cid,c.cname,c.location,p.pid,p.pname, p.cid,p.manager,e.eid,e.ename,e.contact). In other words, Proj records are grouped according to the values of all attributes of the Comp, Proj and Emp records. If SKProjs(cname) is the grouping function instead, then Proj records are grouped according to cname of Comp records (i.e., oname of Org records). (We write SKProjs(cname) instead of SKProjs(c.cname) when there is no ambiguity.) By default, there are no grouping functions for topmost-level sets. Hence, in Fig. <ref type="figure">1</ref>, there are no grouping functions for Orgs and Employees in the target. Most tools (Mapforce, Stylus Studio and [2], <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b3">[4]</ref>) only support the manual specification or modification of grouping functions, where the arguments of the grouping function have to be explicitly specified. This can prove to be a difficult task if the schemas are large or the number of possible arguments for a grouping function is large. Indeed, if there are n possible attributes to group by, then there are in fact 2' choices of grouping functions. Furthermore, it may not be obvious to a designer, what the n possible grouping attributes are (see <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b2">[3]</ref>).</p><p>The Muse-G wizard is always able to infer a grouping function that has the same grouping semantics as the actual grouping function that the designer has in mind. As the exam- ples illustrate the different possibilities of grouping, Muse-G can also be very useful when the designer only has a partial understanding of the desired grouping semantics. Naturally, an advanced designer can always choose to specify the desired grouping function explicitly without using Muse-G.</p><p>If there is at most one key per nested set in the source schema (a very common case) and there are n attributes that a designer can group by, then Muse-G asks at most n questions to infer the desired grouping function. All source schemas we have encountered in Sec. VI fall into this category. Moreover, each question makes use of a small (hence amenable) example, where each nested set in the source typically has two tuples. Our experimental results justify that for these schemas, the number of questions posed remains small for a natural class of desired grouping functions. In the following, we keep the discussion informal and illustrate the ideas behind Muse-G with examples. All algorithms and proofs of our technical results can be found in <ref type="bibr" target="#b14">[15]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. The Basic Algorithm behind Muse-G</head><p>We first describe the algorithm behind Muse-G when there are no functional dependencies (FDs) in the source schema. Extensions to handle keys (and FDs in general) in the source schema are described in Sec. Ill-B (and <ref type="bibr" target="#b14">[15]</ref> respectively).</p><p>Muse-G takes as input a schema mapping (S, T, Z). The designer can choose to design any grouping function that occurs in S. We assume that there is a real source instance I from which Muse-G can draw real data examples whenever possible, and show how Muse-G constructs its own examples otherwise. To illustrate our algorithm, we use the schema mapping (S, T, {m2}), where S, T and m2 are the source and target schemas and respectively, mapping, of Fig. 1.  Step 1. The first step is to determine an order to the set of grouping functions that the designer wishes to (re)design in a mapping in E by performing a breadth-first traversal of T starting from the root. This yields, for our example, the order Org, Emp, and Proj. Since SKOrgs and SKEmps are top-level sets without grouping functions, Muse-G will only design the grouping function for Projects (i.e., SKProjs) in M2. If there were another nested set Grants under Projects in T and m2 would be a mapping that maps to both Projects and Grants in the target, then Muse-G would design SKProjs before SKGrants. When designing SKGrants, Muse-G will make use of the grouping function already designed for SKProjs.</p><p>Step 2. Next, we determine the set poss(m2, SKProjs) of all possible arguments for SKProjs according to M2. According to the schema of OrgDB, a Projects SetID is nested inside an Org tuple in Orgs. According to the for clause of M2, the existence of an Org tuple is dependent on the existence of a Comp tuple in CompDB.Companies, an Emp tuple in CompDB.Employees and a Proj tuple in CompDB.Projects which agrees with the Comp and Emp tuples on the values of pid and manager, respectively. This means that poss(m2,SKProjs) consists of the set of at- tributes in the Comp, Proj and Emp records. However, to simplify our subsequent discussion, we shall assume that poss(nm2 ,SKProj s)={cid,cname,location}.</p><p>Step 3. Suppose the designer has SKProjs(Z) in mind, where Z C poss(m2, SKProjs). Muse-G now proceeds to probe and construct examples to infer the desired grouping function. Probe and construct examples. Muse-G probes every attribute in the set poss(nm2,SKProjs)={cid,cname,location}. The goal of each probe is to carefully construct a small example source instance 1e from which two differentiating target instances are obtained: one is the result of including the probed attribute as part of SKProjs in M2, and the other omits it. Suppose we probe on cid first. Muse-G first constructs its own example instance e, as shown below.</p><p>Ie:{Comp(cl, ni, 11), Proj(pi,pni, Cc, el), Emp(el, eni, cni), Comp(c2, ni, 1), Proj(p2,pn2, C2, e2), Emp(e2, en2, cn2)} Observe that each relation in 'e has two tuples. Furthermore, every attribute value of every tuple is distinct, except for cname and location values of Comp tuples. The reason for this is so that the target instances generated by m2 with SKProjs(cid,y), where y C {cname,location}, versus m2 with SKProj(y) will be non-isomorphic. Indeed, the former target instance will contain two distinct Proj sets, while the latter consists of only one Proj set. Next, Muse-G executes the following query against the actual source instance I in order to retrieve real tuples for the example instance 1e Ql-: Comp(cl, nl, 11) A Comp(c2, ni, 11)A Proj(pi, pnr, ci, el) A Proj(p2, pn2, c2, e2)A Emp(el, ernl, cnl) A Emp(e2, en2, cn2) A cl 7&amp; C2 All variables of Qlare universally-quantified. The two Company tuples must disagree on cid (the probed attribute) and agree on cname and location as explained earlier.</p><p>If Ql-(I) returns an empty result, Muse-G will present the designer with the synthetic instance e, shown earlier. Alter- natively, a "semi-real" 'e may also be constructed by putting together various real values drawn from I. However, this may lead to combinations that are misleading to the designer. If Q'-(I) returns a non-empty result, Muse-G constructs a real example based on the returned values. A possible real example constructed in this way is shown in Fig. <ref type="figure" target="#fig_0">3(a)</ref>, where each tuple in Companies, Projects and Employees exists in I.</p><p>Next, Muse-G obtains two differentiating target instances shown in Scenarios 1 and 2 in Fig. <ref type="figure" target="#fig_0">3(a)</ref>, by chasing 'e with mappings di and respectively, d2. Here, d, and d2 are identical to m2 except they have SKProjs(cid) and respectively, SKProjs( as grouping functions for Projects. Now, Muse-G asks the designer "which target instance looks correct"?</p><p>Note that the instance 'e has been carefully crafted so that the chase of 'e with d, is isomorphic to the chase of Je with dc/, where d' is a mapping obtained from m2 by replacing SKProjs with SKProjs({cid} U Y), where Y C {cname, location}.</p><p>Since cname and location values are identical for the two Comp tuples in e, the mapping di has the same effect as d' on e. Similarly, d2 has the same effect as d' on I, where d' is obtained from d2 by replacing SKProjs with SKProjs(Y). Hence, based on the designer's choice of Scenario 1 or 2, Muse-G correctly determines whether cid is part of the designer's desired grouping function. So with one question, we either eliminate all mappings using cid (not only SKProjs(cid), but SKProjs(cid, cname), SKProjs(cid, location), and SKProjs(cid, cname, location)), or we eliminate all mappings that do not use cid in the skolem function for Projects. Continuing with our example, suppose the designer has the grouping function SKProjs(cname) in mind. She would select Scenario 2 in Fig. <ref type="figure" target="#fig_0">3(a)</ref>. We now repeat the process for the other attributes cname and location. Fig. <ref type="figure" target="#fig_0">3(b)</ref> shows the example source instance and the two scenarios obtained by probing on cname. The two source Comp tuples must differ on the values of cname and agree on the values of location. Note that the cid values of the two Comp tuples are not required to be identical, since cid is not an argument of SKProjs. The designer will pick Scenario 1 in Fig. <ref type="figure" target="#fig_0">3</ref>(b), since she wants to group Projects by cname, and Muse-G infers that cname is an argument to SKProjs. Fig. <ref type="figure" target="#fig_0">3(c)</ref> shows the result of probing on location, where the designer will pick Scenario 2. Since cname is part of the grouping, the Comp tuples must agree on the cname values, otherwise, Muse-G would not be able to infer whether location is part of the groping from the designer's choice in Fig. <ref type="figure" target="#fig_0">3(c)</ref>. At this point, Muse-G concludes and returns SKProjs(cname).</p><p>For simplicity, we have assumed above that poss(rn2, SKProjs) is {cid,cname,location}, when in fact it consists of all attributes of Comp, Proj and Emp records. In this case, Muse-G concludes only after subsequently probing all the attributes of Proj and Emp records (the designer will choose Scenario 2 in each case).</p><p>Note that it is conceivable for Muse-G to generate homomorphically equivalent target instances for Scenarios I and 2 (e.g., Fig. <ref type="figure" target="#fig_0">3(b)</ref>). However, it is always possible to distinguish between such instances, as they are non-isomorphic. Properties of Basic Muse-G. There are 2' different grouping functions for each nested set SK in a mapping m, where n = lposs(m, SK) However, Muse-G determines the desired grouping function by asking the designer only Iposs(m, SK) questions. Furthermore, Muse-G constructs a small source example at each probe. The size of the source example is twice the number of "x C X" clauses in for clauses of m. This typically means there are at most two tuples in each nested set.</p><p>Next, we describe how we have extended the basic algorithm to potentially reduce the number of questions posed to the designer when keys are present in the source.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Muse-G with Keys</head><p>In this section, we assume that key constraints may be specified on nested sets in the source schema. A key of a nested set N is a minimal set of attributes in N that functionally determines all attributes of N. We say that an instance I is a valid instance for a set F of keys if I satisfies every key in F. In the presence of keys, the example 'e constructed when probing an attribute may not be valid with respect to the keys. To see this, suppose cid is the key for Companies. Consider SKProjs in m2 and suppose we probe on cname first.</p><p>Two Comp tuples (cj,nj,lj) and (cl,n2,l) are created, which clearly do not satisfy the key. Even if we had probed on cid before cname, we may still construct an instance that does not satisfy the key. For example, assume the designer's desired grouping function is SKProjs(cid,cname) and Muse-G first probes on cid. The source instance and two scenarios that are constructed are as shown in Fig. <ref type="figure" target="#fig_0">3(a)</ref>. Since the designer has SKProjs(cid,cname) in mind, she picks Scenario 1, and hence Muse-G infers that cid is part of SKProjs. Subsequently, when probing on cname, two Comp tuples, (cl,nj,lj) and (cl,n2,1l), are constructed. Clearly, they do not satisfy the key.</p><p>It turns out that if F is such that every nested set has at most one key (of any arity), then there is a natural order of attributes to probe such that a valid instance for F is always constructed by Muse-G. The procedure for computing this natural order is based on the following result which implies that if K is a key of poss(m,SK), then the inclusion of K as arguments of SK makes the inclusion of other attributes of poss(m,SK) as arguments of SK inconsequential (Thm 3.2). For example, if cid is the key for Companies, then m2 with SKProjs(cid) has the same effect as m2 with SKProjs(cid,cname) or SKProjs(cid,location) or SKProjs(cid,cname,location), for all instances. Definition 3.1: Let ml and m2 be two mappings between a source schema S and a target schema T. We say that ml has the same effect as m2 if for every instance I over S we have that Sol ({m1 }, I) = Sol ({m2}, I) This relation "has the same effect" is reflexive, symmetric and transitive. Note that two mappings have the same space of solutions if an only if their corresponding universal solutions are homomorphically equivalent <ref type="bibr" target="#b12">[13]</ref>. We already took advan- tage of a weaker form of this property in Sec. 3.1 where we constructed instances 'e on which a set of mappings would produce isomorphic results. But the property above is much stronger in that it must hold for all instances. In this paper, we are interested in comparing ml and m2 when they differ only in one grouping function (e.g., SKProjs(Xl) vs. SKProjs(X2) with X1 7t X2)). Theorem 3.2: Let m be a mapping and SK be a grouping function that is defined in m. Let K be a key of poss(m,SK), and let W be a set of attributes in poss(m,SK). Then m with SK(K) has the same effect as m with SK(K U W).</p><p>Given this result, a potentially rewarding order of attributes to probe in the presence of a key K would be K first, followed by the rest of attributes in poss(m,SK) if necessary (i.e., only if K is not chosen).</p><p>Continuing with our example, where cid is the key for Companies, suppose Muse-G is in the process of determining SKProjs by first probing on cid. If the designer picks Sce- nario 1 in Fig. <ref type="figure" target="#fig_0">3(a)</ref>, then Muse-G can immediately conclude SKProjs(cid), since any combination of grouping attributes that includes cid will have the same effect. Hence, Muse-G has avoided two probes on cname and location and consequently, avoided two unnecessary questions.</p><p>A technical difficulty that arises in the presence of multiple keys is that the technique used to construct the illustrative example 1e described in the previous section, may not always be valid with respect to the keys. For example, if both cid and cname are keys for Companies, then probing on cid will construct the instance 'e from Sec. III-A. Clearly, this instance does not satisfy the key cname for Companies. However, if cid is the only key, then probing on cid first does not result in an invalid instance.</p><p>Based on the observations above, we have extended the algorithm behind Muse-G to handle the case when the source schema has key constraints. Whenever there is only a single key, Muse-G avoids creating invalid instances by first probing attributes that belong to the key. In this case, Muse-G asks k questions, where k is the number of attributes in the key, before deciding on which attributes to probe next. In fact, if every nested set in the source schema has at most one key, we show that the number of questions asked by Muse-G is at most Iposs(m, SK) This is the case for all real schemas that we have encountered in Sec. VI. Corollary 3.3: Let m be a mapping between a source schema S and a target schema. Let SK be a grouping function defined in m. If every nested set in S has at most one key, then Muse-G on SK asks the designer at most Iposs(m, SK) questions.</p><p>If there are multiple keys per nested set in the source schema, Muse-G takes a different approach to infer the desired grouping function in order to avoid creating invalid instances. If the designer intends to group by only one of the keys, then Muse-G determines the desired grouping function by asking only one question. This is possible through exploiting the fact that grouping by one key has the same effect as grouping by any superset of the key (including all keys). Otherwise, Muse-G will attempt to understand which subset of non-key attributes is the designer's desired grouping function. The complete details of this part of Muse-G can be found in full version of our paper <ref type="bibr" target="#b14">[15]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Extensions to Muse-G</head><p>We briefly mention other extensions to Muse-G given in <ref type="bibr" target="#b14">[15]</ref>. Muse-G with Functional Dependencies. In [15], we detail how Muse-G constructs examples in the presence of FDs. We give a generalization of Theorem 3.2 for FDs. We show that if P -&gt; Q holds in poss(m,SK), then the inclusion of P as arguments of SK makes the inclusion of Q as arguments of SK inconsequential. We also give a necessary and sufficient condition that characterizes when a set of FDs F is singlekeyed. This allows us to generalize the Muse-G algorithm outlined in Sec. Ill-B to arbitrary functional dependencies. Incremental Muse-G. Even after all grouping functions for a mapping m have been designed, a designer may wish to return to refine her design sometime later. Incremental Muse- G helps a designer refine an existing grouping function SK of m, without restarting the Muse-G algorithm from scratch, by choosing to "group more" (i.e., merge multiple nested sets into a bigger nested set) or "group less" (i.e., split a nested set into multiple smaller nested sets) on SK. Designing grouping functions only for the instance I. Muse-G correctly designs grouping functions for a mapping m so that m produces the desired grouping effect on any source instance. If the designer is only interested in designing mappings for a specific source instance I, we have modified Muse-G to first identify attributes whose inclusion or exclusion as arguments of SKN is inconsequential for the grouping semantics of N records for the instance I. Muse-G will avoid some questions to the designer by not probing these attributes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. DISAMBIGUATING MAPPINGS</head><p>We use the scenario in Fig. <ref type="figure" target="#fig_1">4</ref>(a) to illustrate Muse-D, the component wizard of Muse that disambiguates mappings. Observe that atomic elements from two different record types Proj and Emp in the source are associated together in the same Proj record in the target. Moreover, there are two referential constraints in the source, from Proj to Emp.</p><p>The mapping scenario can be interpreted in several ways, four of which we have condensed into the mapping ma shown in Fig. <ref type="figure" target="#fig_1">4</ref>(a), which has been extended with or predicates to illustrate alternative interpretations. The non-bold parts are common to all four interpretations that we have, while each of the bold conjuncts represents two alternative ways of associating a supervisor (and email, respectively) with a Proj.pname. For example, the first set of or conditions specifies that one can extract either the manager's name or the tech-lead's name as the supervisor of a project.</p><p>We say that a mapping m is ambiguous if there exists at least one or predicate in its where clause. We assume that every group G of or conditions in an ambiguous mapping m are alternatives for an atomic target element A and is of the form (si.Al = A or ... or Sn.An = A). We say m is ambiguous for A and there are n alternatives for A according to m.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. The Muse-D Algorithm</head><p>The Muse-D algorithm takes as input a schema mapping (S, T, Z), where E is a set of possibly ambiguous mappings, and a real source instance I, if available. For each ambiguous mapping m C Z, Muse-D constructs an example source instance 'e that differentiates among the underlying set of alternative (unambiguous) mappings that m encodes. In other words, if m represents I alternative mappings, the chase of Je with each of the I unambiguous mappings results in I target instances that are pairwise different. Each target instance corresponds to one of the unambiguous mappings that m encodes. Hence, the designer's selection of one of these target instances can be translated into a selection of one of the underlying mappings. The example source instance that Muse- D generates for the schema mapping of Fig. <ref type="figure" target="#fig_1">4</ref>(a) is shown in Fig. <ref type="figure" target="#fig_1">4</ref>(b). Observe that Muse-D does not display four target instances. Instead, it compactly represents all target instances in one "instance" by factoring common parts (corresponding to chasing the non-bold part of mapping ma in Fig. <ref type="figure" target="#fig_1">4(a)</ref>) and displaying the alternatives for each ambiguous schema element according to ma. If the designer picks the values Anna for supervisor and Jon@ibm for email, this means that the desired mapping is one that uses "e2.ename = pl.supervisor" and "el.contact= pl.email" in the where clause of ma. Next, we briefly illustrate how Muse-D constructs an example source instance that differentiates among all alternative mappings of the ambiguous mapping ma in Fig. <ref type="figure" target="#fig_1">4(a)</ref>. Muse-D first constructs an example 'e which consists of a Proj tuple (pi,pni,eC,e2) and two Emp tuples (e1,en1,cn1) and (e2,en2,cn2), corresponding to the manager and respectively, the technical leader of the project P1. The query below is executed to replace 'e with real tuples from I:</p><p>Qle :Proj(pi,pni, e1, e2) A Emp(el, enl, cnl)A Emp(e2, en2, cn2) A en1 :t en2 A cn, :t cn2 All variables of Qlare universally quantified. Since supervisor and email are ambiguous elements according to ma, we add the inequalities en1 :t en2 and cn, :t cn2 to ensure that one can disambiguate mappings according to the designer's selection on these values. A possible real example constructed from Q1-(I) is shown Fig. <ref type="figure" target="#fig_1">4(b)</ref>. If Ql-(I) returns an empty result, then the synthetic instance 'e shown above would be presented to the designer instead.</p><p>Finally, Muse-D chases 'e to generate the target instance with "choices" shown in Fig. <ref type="figure" target="#fig_1">4(b)</ref>. Intuitively, the non-choice part of the target instance is generated by chasing Je with the non-ambiguous part of ma. The choices for an atomic target element are obtained by taking the union of values extracted from each alternative. After this, the designer "fills-in-the- choices" in the target instance. The completed target instance translates into an underlying mapping that ma encodes. Properties of Muse-D. For each ambiguous mapping m, Muse-D presents the designer with a single pair of source and target instances. The number of tuples in the source instance is the number of "x C X" clauses in the for clause of m. The number of choice values the designer has to select in the target instance is the number of ambiguous elements in m. More options. A designer may choose a subset of the four mappings as the desired interpretation in general. Muse-D allows the selection of multiple mappings by allowing the designer to select more than one value in each choice.</p><p>Note that the for clause of ma in Fig. <ref type="figure" target="#fig_1">4</ref>(a) expresses an inner join between Employees and Projects. Therefore, only employees that are both managers and technical leads are exchanged in the target. A designer can choose between inner or outer joins (e.g., exchange employees that are neither managers nor tech leads) in Muse-D. Here, we rely on the technique of Yan et al. <ref type="bibr" target="#b11">[12]</ref> for constructing examples to differentiate between inner and outer joins. Detecting ambiguities. So far we have assumed that ambiguities are specified as or predicates in the mapping. Techniques for detecting ambiguities when given a set of mappings (without or predicates) is an interesting subject for further investigation. However, we observe that Muse-D could work directly from mapping tools such as Clio, because ambiguities can be detected during mapping generation.</p><p>V. USING MUSE So far, we have described the Muse-G and Muse-D com- ponent wizards of Muse in isolation. These components may be used independently to refine mappings that are hand-coded or automatically generated. They may also be put together to form a complete mapping design wizard that would guide the designer, with examples, to the desired mapping specification, starting from mappings generated by tools such as Clio <ref type="bibr" target="#b1">[2]</ref> or HePToX <ref type="bibr" target="#b3">[4]</ref>. To exemplify, consider the Clio tool which helps a designer create a mapping scenario (e.g., those shown in Figs. 1 and 4(a)). Clio interprets such a mapping scenario into a set of (possibly ambiguous) mappings. If the default mappings generated are found to be unsatisfactory, Muse-D could be used to select the desired interpretation. The output of Muse-D is a set of unambiguous mappings. Muse-G can then be used to guide the designer towards the desired grouping semantics, if the default are unsatisfactory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. EXPERIENCE</head><p>To evaluate Muse, we use four pairs of source and target schemas as input to Clio, from which we design four mapping scenarios. The input schemas are (1) the relational and DTD schemas of the Mondial geographical database4 (2) two nested schemas for the DBLP bibliography obtained from the DBLP website and respectively, the Clio schemas repository5 (3) the relational TPCH schema <ref type="bibr" target="#b16">[17]</ref> and a nested version of this schema which we created, and (4) the first relational schema in the Amalgam data integration benchmark <ref type="bibr" target="#b17">[18]</ref> and a nested schema which we created based on the third Amalgam schema. As source instances, we used the Mondial database, scaled down versions of the DBLP bibliography and the TPCH database, and data for the first Amalgam schema. All schemas have key and foreign key constraints. The table below shows some characteristics of the mapping scenarios we designed. Muse-G. We considered three types of grouping functions, denoted as G1, G2 and G3, respectively. Under G1, every set is grouped by all possible attributes. Hence, G1 produces the largest number of possible groups. For our example in Fig. <ref type="figure">1</ref>, under G1, SKProjs((all attributes of c, p, e)) is the grouping function for Projects. Under G2, every set SK is grouped by all source atomic elements that are exported to records that appear on the path from the root of the target schema to SK. For example, under G2, the grouping function for Projects is SKProjs(c.cname). A slight variation of G2 is given by G3: Every set SK is grouped by all atomic elements in poss(m,SK) that are exported to the target schema. Under G3, the grouping function for Projects is SKProjs(c.cname, p.pname, p.manager, e.eid, e.ename). Fig. <ref type="figure">5</ref> summarizes our experience with Muse-G. We use DB2 v9 (with buffer pool size of 10 MB) and respectively, the Saxon-B implementation of XQuery to retrieve real tuples from relational and respectively, XML source instances. In all source schemas, there is at most one key for each nested set. Fig. <ref type="figure">5</ref> shows the average size of poss(m, SK) (i.e., the total size of poss(m,SK), over all m and SK, divided by the number of grouping functions in all mappings) and the average number of questions posed to the designer (i.e., the average number of attributes probed) over all sets SK. Muse-G was able to reduce the number of questions posed to the designer in most cases, in the presence of keys. For example, Muse-G asked, on average, only 1.5 questions per nested set under G1 and G3 in the DBLP scenario, where the average size of poss(m, SK) is 11. Recall that all attributes in poss(m, SK) are probed in the absence of keys. Hence, Muse-G avoided 9.5 questions per nested set in these cases, on average. However, Muse-G is unable to reduce the number of questions posed to the designer when she has G2 in mind because it happens that the attributes for G2 do not contain the key of poss(m, SK), for any mapping m and set SK of m in this scenario.</p><p>Fig. <ref type="figure">5</ref> shows that in all scenarios, Muse-G was able to extract real tuples from the source instance and present the designer with a "real" example 'e up to 52% of the time. Note that in all the schema mappings we have used in our ex- periments, it is not possible to extract real source examples all the time. Hence, the ability of Muse-G to construct appropriate examples is important. The average time required to construct and retrieve I from the source instance was subsecond in all cases. Note that the performance of Muse-G mainly depends on the performance of queries that extract 'e from the source instance I. We have implemented various strategies to avoid having the designer wait a long time for real examples from Muse-G in cases when I is large. For example, we exploit the "think time" of the designer on one example to precompute other examples ahead of time in the background. Muse-G also falls back to its own artificially constructed example if a real example was not found after a fixed amount of time. Muse-D. We used Muse-D to disambiguate among alternative mappings in the Mondial and TPCH scenarios. (There are no ambiguous mappings for the DBLP and Amalgam scenarios.) Below, we show the number of alternative mappings that are encoded by the ambiguous mappings that Clio generates. For example, for the Mondial scenario, the 7 ambiguous mappings encode 208 mapping alternatives in total. The number of pairs of source and target examples generated in each scenario (i.e., the number of questions posed to the designer) is also shown. This number is equal to the number of ambiguous mappings. In all cases, we were able to extract real examples from the actual source instance to illustrate the ambiguities. It is important to observe that the sizes of the example source instances and the number of ambiguous values Muse-D shows in the target instances are small compared to the number of mapping alternatives. In Mondial, for example, Muse-D disambiguates among 208 mapping alternatives by showing only 7 examples, where each source example consists of 3 to 4 tuples and the corresponding target instances have 4 to 5 ambiguous elements, each with two choice values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. RELATED WORK AND CONCLUSION</head><p>Grouping functions (or Skolem functions) have been used for schema translation and schema augmentation of objectbased data models <ref type="bibr" target="#b18">[19]</ref>, as well as in many tools for managing and creating schemas and mappings <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b19">[20]</ref>, <ref type="bibr" target="#b20">[21]</ref>. In all cases, grouping functions are automatically generated and may be manually modified. To the best of our knowledge, Muse-G is the first design wizard for grouping functions.</p><p>Muse-D is inspired by the vision of Yan et al. [12], but greatly extends its functionality (as described in Section I). Muse is fundamentally different from previous work on form filling <ref type="bibr" target="#b21">[22]</ref>, Query-By-Example (QBE) paradigms (perhaps the most notable one is <ref type="bibr" target="#b22">[23]</ref>), and browsing and querying paradigms (e.g., <ref type="bibr" target="#b23">[24]</ref>). Muse uses data examples to illustrate nuances in small changes to an existing mapping, while all the work mentioned above is about assisting a designer to build a (valid) query. The work of Rowe [22] is similar to Muse-D in that it requires the user to fill-in some values in a form with empty fields. A form corresponds to the schema of a view of the underlying database. Arbitrary values are allowed in each field, and each entered value translates to a selection predicate on the underlying query from which more tuples may be retrieved. In Muse-D, each "blank" in the target instance contains a list of alternatives (no arbitrary choices are allowed). A completion of the target instance corresponds to a selection of a unique underlying mapping.</p><p>Examples have been used to illustrate constraints, such as functional and inclusion dependencies <ref type="bibr" target="#b24">[25]</ref>. An example database (called an Armstrong database <ref type="bibr" target="#b25">[26]</ref>) is a database that satisfies exactly a given set of constraints and their logical consequences, and no other constraints. Since such databases illustrate constraints that hold or do not hold, it is useful for alerting the designer of possible extra or missing constraints. Muse uses data examples for illustrating the differences in semantics resulting from small changes to a mapping. It may not show which mappings are missing.</p><p>The work of <ref type="bibr" target="#b26">[27]</ref> allows a designer to understand and debug schema mappings by showing the relationships, called routes, between selected source or target data. Our work is complementary to <ref type="bibr" target="#b26">[27]</ref>. Their system does not automatically "guide" the designer, with examples, in creating or refining the schema mapping. Rather, the designer must manually change a mapping, once a problem has been identified by analyzing the routes. Moreover, the design of grouping functions is not considered in <ref type="bibr" target="#b26">[27]</ref>. Conclusion. We have described Muse, a mapping design wizard that uses data examples to help designers understand, design, and refine schema mappings. Muse permits a designer to work with data rather than with complex specifications to understand a mapping's semantics. Muse works on two im- portant components of a mapping specification, corresponding to the design of desired grouping semantics for mappings (Muse-G) and the desired interpretation of ambiguous mappings (Muse-D). Muse explores a large and comprehensive design space of alternative mappings to ensure a designer can efficiently arrive at her desired mapping semantics.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Probing on (a) cid, (b) cname, and (c) location when the designer has SKProjs(cname) in mind.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. (a) A mapping scenario and an ambiguous mapping; (b) Muse-D on the schema mapping in (a).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Schema [Alternatives Num. TSize of Je# Ambiguous vals. Mapping| encoded |questions (# tuples) in target inst.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>], a common form of global-and-local-as-view (GLAV) mappings</figDesc><table><row><cell>CompDB: Rcd</cell><cell>OrgDB: Rcd</cell></row><row><cell>Companies: Set of</cell><cell>Orgs: Set of</cell></row><row><cell>Company: Rcd</cell><cell>Org: Rcd</cell></row><row><cell>, cid</cell><cell>oname</cell></row><row><cell>cname</cell><cell>Projects: Set of</cell></row><row><cell>location</cell><cell>Project: Rcd</cell></row><row><cell>Projects: Set of</cell><cell>pname</cell></row><row><cell>Project: Rcd</cell><cell>manager</cell></row><row><cell>pid</cell><cell>Employees: Set of</cell></row><row><cell>pname</cell><cell>Employee: Rcd</cell></row><row><cell>cid</cell><cell>eid</cell></row><row><cell>manager</cell><cell>ename</cell></row><row><cell>f2 Employees: Set of Employee: Rcd eid</cell><cell></cell></row><row><cell>ename</cell><cell></cell></row><row><cell>contact</cell><cell></cell></row><row><cell cols="2">m1: for c in CompDB.Companies exists o in OrgDB.Orgs</cell></row><row><cell cols="2">where c.cname=o.oname and o.Projects = SKProjs(c.cid,c.cname,c.location)</cell></row><row><cell cols="2">m2: for c in CompDB.Companies, p in CompDB. Projects, e in CompDB. Employees</cell></row><row><cell cols="2">satisfy p.cid=c.cid and e.eid=p.manager</cell></row><row><cell cols="2">exists o in OrgDB.Orgs, p1 in o.Projects, e1 in OrgDB.Employees</cell></row><row><cell>satisfy p1.manager=e1.eid</cell><cell></cell></row><row><cell cols="2">where c.cname=o.oname and e.eid=el.eid and e.ename=e1.ename</cell></row><row><cell>and p.pname=p1.pname and</cell><cell></cell></row><row><cell>o.Projects</cell><cell></cell></row></table><note><p>= SKProjs(&lt;... all attributes of c, p and e ...&gt;) m3: for e in CompDB.Employees exists e1 in OrgDB.Employees</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>The types String and Int are atomic types and Rcd and Choice are complex types. (The atomic types are not shown in Fig.1.)</figDesc><table><row><cell>Source instance:</cell><cell>Target instance:</cell></row><row><cell>Companies</cell><cell>Orgs:</cell></row><row><cell>111 IBM Almaden</cell><cell>IBM</cell></row><row><cell>112 SBC NY</cell><cell>Projects: SKProjs(111 IBMAlmaden)</cell></row><row><cell>Projects 11 ffll 3 p1 DBSearch 111 e14 Projects</cell><cell>SBC Projects: SKProjs(112,SBC,NY)J records Org IBM</cell></row><row><cell>p2 WebSearch 111 e15</cell><cell>Projects: SKProjs(111,IBM,Almaden,pl..1, ....)J</cell></row><row><cell></cell><cell>DBSearch e14</cell></row><row><cell>Employees e14 Smith x2292 e15 Anna x2283</cell><cell>IBM Projects: SKProjs(111,IBM,Almaden,p2.e5 ....)J WebSearch e15</cell></row><row><cell>e16 Brown x2567</cell><cell></cell></row><row><cell></cell><cell>Employees:</cell></row><row><cell></cell><cell>e14 Smith</cell></row><row><cell></cell><cell>e15 Anna</cell></row><row><cell></cell><cell>e16 Brown</cell></row><row><cell cols="2">Fig. 2. The result of chasing the source with {ml,m2,m3}.</cell></row></table><note><p>T ::= String Int SetOf T Rcd[li Ti, ..., I Tn] Choice[li : Ti, ..., In Tn].</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>://www.dbis.informatik.uni-goettingen.de/Mondial/ 5http://www.cs.toronto.edu/db/clio/testSchemas.html 17</figDesc><table><row><cell cols="6">CompDB: Rcd Schema Average Number of% times Average timeGroup OrgDB: Rcd ma: for pin CompDB.Projects, Projects: Set of Projects: Set of el in CompDB.Employees, Project: Rcd Project: Rcd e2 in CompDB.Employees pid pname satisfy el.eid=p.manager and pname supervisor e2.eid=p.tech-lead manager email exists pl in OrgDB.Projects tech-lead where p.pname=pl.pname and Employees: Set of (el.ename=pl.supervisor Employee: Rcd mapping size of questions found to obtain strat. poss(m, SK)[ (average) real Je Ie (s) 2.6 38% 0.014 G1 Mondial 13.1 8.5 41% 0.187 G2 2.9 40% 0.015 G3 or e2.ename=pl.supervisor) and 1.5 17% 0.450 G1 eid ename (a) (el.contact=pl.email contact or e2.contact=pl.email) DBLP 11 11 11% 0.337 G2 1.5 17% 0.454 G3</cell><cell>Example source le: Target instance: Projects Orgs: P1 DB e4 e5 Projects: DB Jon J[n Q ibn Ann [a Ibm Employees e4Jon jon@ibm A A e5 Anna anna @ ibm (b) Choice values for supervisor and email</cell></row><row><cell></cell><cell></cell><cell>1.5</cell><cell>0%</cell><cell>0.785</cell><cell>G1</cell></row><row><cell>TPCH</cell><cell>26.7</cell><cell>17</cell><cell>12%</cell><cell>0.893</cell><cell>G2</cell></row><row><cell></cell><cell></cell><cell>1.5</cell><cell>0%</cell><cell>0.782</cell><cell>G3</cell></row><row><cell></cell><cell></cell><cell>2</cell><cell>29%</cell><cell>0.013</cell><cell>G1</cell></row><row><cell>Amalgam</cell><cell>14.1</cell><cell>3</cell><cell>52%</cell><cell>0.043</cell><cell>G2</cell></row><row><cell></cell><cell></cell><cell>_ _3</cell><cell>52%</cell><cell>0.030</cell><cell>G3</cell></row><row><cell></cell><cell cols="4">Fig. 5. Experimental results with Muse-G.</cell><cell></cell></row></table><note><p>4http</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>In the Mondial scenario, for example, the target schema has 8 nested sets with grouping functions. Clio generates 26 mappings of which 7 are ambiguous.</figDesc><table><row><cell cols="4">Mapping Size Target sets Number o Ambiguous Scenarios of I w/ groupingl mappings mappings</cell></row><row><cell>Mondial 1MB</cell><cell>8</cell><cell>26</cell><cell>7</cell></row><row><cell>DBLP 2.6MB</cell><cell>6</cell><cell>4</cell><cell>0</cell></row><row><cell>TPCH lOMB</cell><cell>4</cell><cell>5</cell><cell>1</cell></row><row><cell>Amalgam 2MB</cell><cell>2</cell><cell>14</cell><cell>0</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements. Alexe, Chiticariu and Tan are partly supported by NSF CAREER Award IIS-0347065 and NSF grant IIS-0430994. Work partially done while Tan was visiting the IBM Almaden Research Center.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Model Management 2.0: Manipulating Richer Mappings</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Melnik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Translating Web Data</title>
		<author>
			<persName><forename type="first">L</forename><surname>Popa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Velegrakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hernandez</surname></persName>
		</author>
		<author>
			<persName><surname>Fagin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="598" to="609" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Nested Mappings: Schema Mapping Reloaded</title>
		<author>
			<persName><forename type="first">A</forename><surname>Fuxman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Hernandez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Papotti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Popa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="67" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">HepToX: Heterogeneous Peer to Peer XML Databases</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bonifati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">Q</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">V S</forename><surname>Lakshmanan</surname></persName>
		</author>
		<ptr target="http://www.citebase.org/abstract?id=oai:arXiv.org:cs/0506002" />
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Implementing Mapping Composition</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Melnik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Nash</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="55" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Answering Queries Using Views</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Halevy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="270" to="294" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Data Integration: A Theoretical Perspective</title>
		<author>
			<persName><forename type="first">M</forename><surname>Lenzerini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="233" to="246" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Constraint-Based XML Query Rewriting For Data Integration</title>
		<author>
			<persName><forename type="first">C</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Popa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="371" to="382" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Composing Mappings Among Data Sources</title>
		<author>
			<persName><forename type="first">J</forename><surname>Madhavan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Halevy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="572" to="583" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Composing Schema Mappings: Second-Order Dependencies to the Rescue</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Kolaitis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Popa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TODS</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="994" to="1055" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Composition of Mappings given by Embedded Dependencies</title>
		<author>
			<persName><forename type="first">A</forename><surname>Nash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Melnik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="172" to="183" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Data-Driven Understanding and Refinement of Schema Mappings</title>
		<author>
			<persName><forename type="first">L</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="485" to="496" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Data Exchange: Semantics and Query Answering</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Kolaitis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Popa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TCS</title>
		<imprint>
			<biblScope unit="volume">336</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="89" to="124" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Model-Independent Schema and Data Translation</title>
		<author>
			<persName><forename type="first">P</forename><surname>Atzeni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Cappellari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="368" to="385" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Muse: Mapping Undestanding and deSign by Example</title>
		<author>
			<persName><forename type="first">B</forename><surname>Alexe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Chiticariu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Tan</surname></persName>
		</author>
		<idno>UCSC-CRL-07-10</idno>
		<imprint>
			<date type="published" when="2007">2007</date>
			<publisher>UC Santa Cruz</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">An Equational Chase for Path-Conjunctive Queries, Constraints, and Views</title>
		<author>
			<persName><forename type="first">L</forename><surname>Popa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Tannen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDT</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="39" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">TPC Transaction Processing Performance Council</title>
		<ptr target="http://tpc.org" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">The Amalgam schema and data integration test suite</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Fisla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kymlicka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Ku</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Lee</surname></persName>
		</author>
		<ptr target="www.cs.toronto.edu/-miller/amalgam" />
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">ILOG: Declarative Creation and Manipulation of Object Identifiers</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yoshikawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="455" to="468" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Supporting Executable Mappings in Model Management</title>
		<author>
			<persName><forename type="first">S</forename><surname>Melnik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Halevy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Rahm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="167" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Interactive schema translation with instance-level mappings</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Melnik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mork</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB (demo)</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="1283" to="1286" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Fill-in-the-Form&quot; Programming</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Rowe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="394" to="404" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Query-By-Example: A Data Base Language</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zloof</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM Sys. Journal</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="324" to="343" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">PESTO : An Integrated Query/Browser for Object Databases</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Carey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Maganty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="203" to="214" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A Method for Helping Discover the Dependencies of a Relation</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Melkanoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Adv. in Data Base Theory</title>
		<imprint>
			<date type="published" when="1979">1979</date>
			<biblScope unit="page" from="115" to="133" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">On the Structure of Armstrong Relations for Functional Dependencies</title>
		<author>
			<persName><forename type="first">C</forename><surname>Beeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dowd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Statman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JACM</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="30" to="46" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Debugging Schema Mappings with Routes</title>
		<author>
			<persName><forename type="first">L</forename><surname>Chiticariu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="79" to="90" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
