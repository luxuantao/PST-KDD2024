<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Robotic Exploration as Graph Construction</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Gregory</forename><surname>Dudek</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">McGill Research Center for Intelligent Machines</orgName>
								<orgName type="institution">McGill University</orgName>
								<address>
									<postCode>H3A 2A7</postCode>
									<settlement>Montreal</settlement>
									<region>Quebec</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">York University</orgName>
								<address>
									<postCode>M3J 1P3</postCode>
									<settlement>Toronto</settlement>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Michael</forename><surname>Jenkin</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">McGill Research Center for Intelligent Machines</orgName>
								<orgName type="institution">McGill University</orgName>
								<address>
									<postCode>H3A 2A7</postCode>
									<settlement>Montreal</settlement>
									<region>Quebec</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Evangelos</forename><surname>Milios</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">McGill Research Center for Intelligent Machines</orgName>
								<orgName type="institution">McGill University</orgName>
								<address>
									<postCode>H3A 2A7</postCode>
									<settlement>Montreal</settlement>
									<region>Quebec</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">David</forename><surname>Wilkes</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">McGill Research Center for Intelligent Machines</orgName>
								<orgName type="institution">McGill University</orgName>
								<address>
									<postCode>H3A 2A7</postCode>
									<settlement>Montreal</settlement>
									<region>Quebec</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Toronto</orgName>
								<address>
									<postCode>M5S 1A4</postCode>
									<settlement>Toronto</settlement>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Robotic Exploration as Graph Construction</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">6F1B172C3688ADA1CAE133062AAF3042</idno>
					<note type="submission">received April 28, 1989; revised February 20, 1991.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:33+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We address the problem of robotic exploration of a graphlike world, where no distance or orientation metric is assumed of the world. The robot is assumed to be able to autonomously traverse graph edges, recognize when it has reached a vertex, and enumerate edges incident upon the current vertex relative to the edge via which it entered the current vertex. The robot cannot measure distances, and it does not have a compass. We demonstrate that this exploration problem is unsolvable in general without markers, and, to solve it, we equip the robot with one or more distinct markers that can be put down or picked up at will and that can be recognized by the robot if they are at the same vertex as the robot. We develop and prove correct an exploration algorithm, we show its performance on several example worlds, and we discuss heuristics for improving its performance.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Robotic exploration and map-based navigation using dead reckoning is difficult to accomplish over large spatial scales without reference to external features of the world due to the accumulation of error in robot position and orientation. To address this fundamental issue, a number of approaches, e.g., <ref type="bibr" target="#b0">[4]</ref>, have been suggested in order to more accurately track the motion of a robot in relation to features of its environment so as to reduce positional errors.</p><p>Motivated by the need for spatial representations other than ones based on metric information, a four-level spatial semantic hierarchy is proposed in [15]. The four levels, starting with the lowest, are the sensorimotor (robot sensations and primitive actions), procedural (robot actions to accomplish place-finding and route-following tasks), topological (places and paths and their topological relations), and metric (places and paths and their metric relations). In this paper, we provide precise definitions of what correspond to the sensorimotor, procedural, and topological levels associated with learning and navigation in a graph-like world, assuming no metric information is either sensed or stored.</p><p>The problem addressed in this work is: Given an unknown environment modeled as a graph, formulate an exploration strategy for the robot, so that, after carrying out the actions specified by the strategy, the robot will have formed a representation of its environment sufficient for solving navigation tasks with the use of sensors, i.e., a map. We begin by defining the world the robot explores, the robot itself, and the actions and sensations with which it is equipped. To solve the problem of determining when the robot has returned to a previously visited location (the "am I there yet" problem) during map building, we use portable markers as part of the exploration strategy. We demonstrate that this is the only feasible approach given the lack of precise metric information and distinct landmark features.</p><p>Past work in this area involves metric representations of space, including metric graphs walks on graphs and our approach is that we visit vertices of a graph according to deterministic strategies as opposed to stochastic. In</p><p>[14] and [15] a topological model of the world is used. A rehearsal procedure is used to distinguish two places with identical signatures by exploring some of the surrounding area. Our work can be viewed as introducing a different rehearsal procedure that includes portable markers. <ref type="bibr">Davis [5]</ref> has tried to reduce problems at the topological level to problems involving only the geometric level, which are then solved by trigonometric means applied to fuzzy intervals. Permanent markers have been used in deterministic strategies for graph traversal [ll], where the goal is to visit all vertices of an unknown graph. The problem of exploring an unknown directed graph with a robot that can recognize edges and nodes, if it sees them again, has been addressed by <ref type="bibr">Deng and Papadimitriou [6]</ref>. This short paper is structured as follows. Section I1 defines our model of the world and the sensorimotor capabilities of the robot. Section III describes an exploration algorithm using k markers and gives a correctness proof and complexity bounds. Section IV presents experimental results on typical graphs and on a complex three-dimensional maze.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.">DEFINITIONS</head><p>In this section, we describe the environment in which our robot explorer exists as well as the robot's actions, perception, and goals. It is important to remember that this representation is minimal in nature. In reality, much more information is likely to be available at a given location than we assume here. A sensing system that can enumerate the exits from a given location might also give approximate relative orientations, and the addition of a compass to the robot would make these orientations absolute. The robot's "purpose in life" is to use its ability to act and to perceive in the graph domain in order to build a graph embedding that is isomorphic <ref type="bibr" target="#b8">[12]</ref> to the finite world it has been assigned to explore. The robot's inputs are its sensations, and it can interact with the world only through its actions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A . The World</head><p>The world is defined as an embedding of an undirected graph G:</p><formula xml:id="formula_0">G = ( V , E )</formula><p>with a set of vertices V and a set of edges E . The vertices are denoted by v = {U,,... 3 U N ) .</p><p>( 2 )</p><p>We will restrict the world model to graphs G that contain no cycles of length 5 2 , i.e., the graph contains no degenerate or redundant paths. This restriction prohibits the world from having multiple edges between two vertices or an edge incident twice at the same vertex.</p><p>The definition of an edge is extended slightly to allow for the explicit specification of the order of edges incident upon each vertex of the graph embedding. This ordering is obtained by enumerating the edges in a systematic (e.g., clockwise) manner from some standard starting direction. An edge E,,j incident upon U, and uj is assigned labels n and m , one for each of U, and uJ, respectively. n represents the ordering of the edge with respect to the consistent enumeration of edges at vi; m represents the ordering of the edge E,.i with respect to the consistent enumeration of the edges at uj. The labels m and n can be considered as general directions, e.g., from vertex U, the nth exit takes edge</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Movement and Action</head><p>The robot can move from one vertex to another by traversing an edge (a move), it can pick up a marker that is located at the current vertex, and it can put down a marker it holds at the current vertex (a marker operation). The robot in general has K markers at its disposal.</p><p>Assume the robot is at a single vertex U,, having entered the vertex through edge E i , / . In a single move, it leaves vertex U, for vertex uj by traversing the edge E i , j , which is r edges after E,,/ according to the edge order at vertex U, (see Fig. <ref type="figure" target="#fig_2">1</ref>). This is given by the transition function to vertex u j . <ref type="figure">,</ref><ref type="figure">E ,</ref><ref type="figure">,</ref><ref type="figure">,</ref><ref type="figure">,</ref><ref type="figure">r</ref>   <ref type="figure">E,</ref><ref type="figure">,</ref><ref type="figure">,</ref><ref type="figure">,</ref><ref type="figure">r</ref> ) = uJ and &amp;uJ, E , , J , s) = U k r then 6(uJ, EJ,k, -s) = U,. This implies that a sequence of moves is invertible, and can be retraced. We also assume that there does not exist a t # -S such that 6(uJ, E J , k , t ) = U,.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6(ui</head><p>A single move is thus specified by the order r of the edge along which the robot exits the current vertex, where r is defined with respect to the edge along which the robot entered such vertex. Note that in the special case of a planar embedding of a graph, enumeration of edges in a clockwise fashion satisfies the above assumption.</p><p>A marker operation is fully specified by indicating for each of the K markers whether it is being picked up, put down, or not operated upon. This is specified by a K-tuple Q K = ( o p , , o p , ; . ., o p K ) , where the element opk has a value from the set { p i c k u p , putdown, null}, according to the operation performed on marker k .</p><p>A simple action a is defined as a marker operation accompanied by a move; therefore, a = ( b , <ref type="bibr" target="#b2">6)</ref>, where b E Q K . The robot performs some action on the markers in the current vertex and then moves to a new location. A path A E a + is a nonempty sequence of actions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Perception</head><p>The robot's perception is of two kinds: marker-related and edgerelated perception.</p><p>Marker-Related Perception: Assume that the robot is at vertex U,, having arrived via edge E i , j . The marker-related perception of the robot is a K-tuple B, = (bs, , bs,, . . . , bsK), where bs, has a value from the set { present, not-present} , according to whether marker k is present at vertex ui.</p><p>Edge-Related Perception: The robot can determine the relative positions of edges incident on the vertex U, in a consistent manner, e.g., by a clockwise enumeration starting with E , , j . As a result, it can assign an integer label to each edge incident on U,, representing the order of that edge with respect to the edge enumeration at ui. The label 0 is assigned arbitrarily to the edge Ei. through which the robot entered vertex U,. The ordering is local because it depends on the edge E,,j. Entering the same vertex from two different edges will lead to two local orderings, one of which is a permutation of the other. Note that if the graph is planar and a spatially consistent (e.g., clockwise) enumeration of edges is used, then two permutations will be simple circular translations of each other. But, this will not hold in general, and in this work we only assume that the edges can be ordered consistently.</p><p>The sensory information that the robot acquires while at vertex U, is the pair consisting of the marker-related perception at that vertex and the order of edges incident on that vertex, with respect to the edge along which the robot entered the vertex. If the robot visits the same vertex twice, it must relate the two different local orderings produced and unify them into a single global ordering, for example, by finding the label of the zeroth edge of the second ordering with respect to the first ordering. Determining when the same vertex has been visited twice and generating a global ordering for each vertex is part of the task of the exploration algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. The Zero-Marker Case</head><p>Can an autonomous robot (as described above) explore an arbitrary finite environment without any markers? The answer is no. As an example, regular graphs of the same degree (i.e., graphs in which each vertex has a number of incident edges equal to the degree) are indistinguishable from each other without markers because each vertex appears identical to every other vertex.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="111.">THE EXPLORATION ALGOFUTHM</head><p>This section describes an algorithm for exploring a given graph using k markers. The algorithm will be shown to have polynomial running time in terms of the size of the graph. The basis of the algorithm is the maintenance of an explored graph. As new vertices are encountered, they are added to the explored graph, which is a subgraph of the full graph, and their outgoing edges are added to the set of edges that lead to unknown places and therefore must be explored.</p><p>More formally, the algorithm maintains an explored subgraph S and a set of unexplored edges U, which emanate from vertices of the explored subgraph. A step of the algorithm consists of selecting a set E of k unexplored edges from U and "validating" the vertex u2 at the unexplored end of each edge e = ( u l , u 2 ) in the set E.</p><p>Validating a vertex u2 means making sure that it is not identical to any other vertex in the explored subgraph. This is carried out by placing one of the k markers at u2 and visiting all vertices of the known subgraph S along edges of S, looking for the marker (and each of the other k -1 markers dropped at this step). Note that the other vertex u1 incident upon e is already in the subgraph S .</p><p>If the marker is found at vertex vi of the explored subgraph S , then vertex u2 (where the marker was dropped) is identical to the already known ui (where the marker was found). In this case, edge e = ( u l , U*) must be assigned an index with respect to the edge ordering of vertex u2. To determine this, the robot drops the marker at u I and goes back to u2 along the shortest path in the explored graph S . At U*, it tries going out of the vertex along each of its incident edges. One of them will take the robot back to u l , which the robot will immediately recognize by the existence of the marker.</p><p>Note that the index of e with respect to the edge ordering of u I is known by construction. Edge e is then added to the subgraph S and removed from U. If the marker is not found at one of the vertices of S, then vertex u2 is not in the subgraph S and therefore must be added to it. The unexplored edge e is also added to S, which has now been augmented by one edge and one vertex. Adding the vertex u2 to the subgraph causes all edges incident upon it to be assigned an index with respect to the edge e by which the robot entered the vertex (edge e is assigned index 0) and the new edges are added to the set of unexplored edges U . Note that no other edge of the new vertex u2 has been previously added to the subgraph because otherwise u2 would have already been in the explored subgraph. This index assignment establishes the edge ordering local to U*.</p><p>The algorithm terminates when the set of unexplored edges U is empty. A version of the algorithm incorporating the above characteristics is shown in the appendix. A formal proof of the correctness of the algorithm is presented in <ref type="bibr" target="#b4">[8]</ref>.</p><p>A different way of using the available k markers is to employ two distinct markers in the exploration of a single unexplored edge e = ( u l , u 2 ) . Then we can combine the validation and ordering steps by placing the markers at u 1 and U*. If u2 is found in S , then ordering of e with respect to u2 is accomplished by going out of u2 along each of its incident edges, without having to drop the marker at u1 and to return to u2 along the shortest path in S. This variation resulted in poorer performance on our test cases, with asymptotic worst case complexity that differs only by a constant factor. There is a tradeoff between easier vertex validation, with the modified algorithm, and fewer edges added per marker drop.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Complexity of the Algorithm</head><p>Certain steps of the algorithm are executed mechanically (edge traversals or marker pickup or drop) in the world G, while others are executed only electronically as the robot reasons about the model S (i.e., performs operations on the data structures maintained by the algorithm). The time constants for some simple operation, such as following an edge in a graph, may differ between the two cases by many orders of magnitude. Consequently, algorithms of higher asymptotic complexity may be tolerable for the electronic operations but not for the mechanical operations. For example, we may run a shortest-path algorithm electronically many times in order to save a few mechanical steps for the robot.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I) Mechanical Complexity:</head><p>Let m be the number of edges and n the number of vertices. We will count the steps that may be taken by the robot while executing the algorithm in the worst case, using simplifying bounds on some subexpressions. We assume that k is small enough that the algorithm does not frequently exhaust the set U of unknown edges at the step in which it chooses k elements from U. If this is not the case, then the advantage of the extra markers is reduced, since the excess markers are not used and hence provide absolutely no advantage. By counting the number of mechanical steps resulting from each call to a relevant routine as shown in Table <ref type="table">I</ref>, we obtain a bound on the number of mechanical steps of ( 5 + G) mn -3n2 + lower order terms <ref type="bibr" target="#b0">(4)</ref> where ns is the number of nodes in the explored subgraph, and d,,, is the maximum degree of a node in the world, both bounded by n . A similar analysis of the worst case asymptotic complexity of the modified algorithm, which places markers at each end of each unknown edge, gives a similar expression bounding the number of mechanical steps:</p><p>(3 + %) mn -n2 + lower order terms.</p><p>( 5 )</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2) Electronic Complexity:</head><p>The asymptotic electronic complexity of the algorithm is O(n2m + m2 log m ) if a shortest path algorithm is used in the routine search (), or O ( m 2 log m ) otherwise.</p><p>For planar graphs, this becomes O(n3) and O(n2 log n), respectively. If the robot is aware that it has at least n markers, then some simplification is afforded because the robot need not pick up any markers that it drops.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV . EXPEIUMENTS</head><p>Experiments were carried out by running the algorithm on various input graphs. These graphs were generated manually in order to exemplify performance characteristics of the technique and confirm the theoretical predictions. Equation (4) provides a theoretical upper limit on the number of robot steps required for the graph exploration. In practice, however, the actual number of steps for many operations may be substantially lower. In order to informally evaluate some of these issues, the behavior of a robot using this exploration strategy was simulated on a variety of input graphs. The actual number of mechanical steps taken varied between about 25 and 65% of the theoretical complexity bound.</p><p>An interesting example is provided by Daedalus' labyrinth, as described in <ref type="bibr" target="#b3">[7]</ref>. We reproduce this maze in Fig. <ref type="figure">2</ref>. Note that this maze is three dimensional with the entrance and exit located at the top level of the maze (Level 1). In order to test the ability of a robot equipped with a single marker, this maze was first reduced to a graph-based world model, with vertices in the graph representing intersections of paths or features (such as corners in the labyrinth). Two additional vertices were added for the entrance and exit rooms. The robot was then placed in the entrance room and allowed to start exploring. The robot knows which way is vertical, i.e., it has a sense of gravity but no sense of global orientation. The edge ordering follows the clockwise order for the horizontal edges, followed by the vertical up and vertical down edges, if any exist at the current vertex. It should be noted that this graph, as all graphs discussed in this paper, is undirected because vertical edges can be traversed both ways.</p><p>Internally the robot has no knowledge of the physical position of locations in the environment. It can only measure the exits from a   <ref type="figure">walk(+( u,</ref><ref type="figure">,</ref><ref type="figure">,</ref><ref type="figure">,</ref><ref type="figure">,</ref><ref type="figure">t</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TABLE I NUMBER OF MECHANICAL STEPS ASSOCIATED WITH THE ALGORITHM LISTED</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>$4 ut ))</head><p>sn,-1 n -1</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>followEdge(d(e,)) D to + ( u z )</head><p>1 n -1 pickup(marker,)</p><formula xml:id="formula_1">1 n -1 pickup(marker,) 1 included in (*) above</formula><p>node and the presence (or absence) of a marker. For display purposes only, we have attached to each node a physical location so that the resulting explored labyrinth can be compared with the original, shown in Fig. <ref type="figure">2</ref>. Two intermediate results with eight markers (after 1200 and 2400 mechanical steps) are shown in Fig. <ref type="figure">3</ref>. The robot's perception of the maze after completing the exploration is identical to the original.</p><p>Note that in Fig. <ref type="figure">2</ref> lines represent walls, while in Fig. <ref type="figure">3</ref> the lines represent valid movement paths for the robot.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The Advantages of Multiple Markers</head><p>As we have already mentioned, the use of multiple markers can improve the performance of the robot on a given environment. To confirm our previous observations on the effect of the number of markers on the robot's performance, we have plotted the total number of steps required to fully explore the maze with a number of markers ranging from 1 to 14, as shown in Fig. <ref type="figure" target="#fig_5">4</ref>. The dots and crosses correspond to two different starting points in the maze.</p><p>It can be seen that adding more markers does not result in a significant decrease in the total number of steps after a certain number of markers. We conjecture that this is due to the fact that the number of unexplored edges at any one time are generally few, and that it may be the case that there are actually markers that cannot be used at a given step of the algorithm. Even if all the markers can be used, it may be the case that the robot must traverse much of the explored graph just to deposit the markers, and that the </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. DISCUSSION</head><p>In this work, we proposed strategies that a mobile robot can use in exploring unknown graph-like environments. Contrary to most current approaches, our algorithms do not make use of distance metrics, but they use one or more markers that can be perceived by the robot and be put down or picked up at will. We show that one marker is sufficient to allow the robot to build a graph isomorphic to the environment in low-order polynomial time in both mechanical and computational complexity. The required perceptual abilities of the robot are well defined, and they amount to the ability to traverse an edge and to enumerate the edges incident upon the current vertex. The theoretically derived upper bounds on the complexity of the algorithm are confirmed by a computer simulation. By defining a minimal model for mobile robotic exploration, we point to interesting extensions for when the world is richer than our model.</p><p>The abstraction used here presents a particularly impoverished world. Only the number of exits from each location and one's own markers can actually be sensed. In practice, most real robotic systems can be expected to have richer perceptual inputs than these. The simple model used here, however, serves as a lowest common denominator for the capabilities of robotic systems. By showing that the map acquisition problem can be solved with acceptable complexity bounds under these circumstances, we demonstrate that such tasks are solvable within at least these bounds by more sophisticated systems. Furthermore, although more sophisticated perceptual mechanisms may be available, they are rarely completely dependable (not only must one account for sensor errors, but the sensed data is also domain dependent). Hence, even robots with powerful sensing systems may occasionally find themselves reduced to the level of the model described here. Finally, an abstraction of the robot exploration problem based on using more powerful but domain-dependent and error-prone sensors would make solid complexity bounds for the problem almost unobtainable.</p><p>It should be emphasized that the robotic exploration problem described here cannot be solved simply using a depth or breadth-first search. The identity of individual vertices of the graph cannot be established without first solving the mapping problem. Once the graph has been explored, it can then be searched efficiently by standard techniques (and the algorithm, in fact, does this within the portion of the graph that has already been mapped out).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX STATEMENT OF THE ALGORITHM</head><p>The following is one version of the algorithm incorporating these assumptions. We denote the mapping from model S to world G by +; I$ of a vertex in S is the real-world vertex to which the robot's label corresponds. Definitions of the subroutines used by the algorithm are given following the statement of the top-level algorithm.</p><p>In the top-level algorithm, mechanical steps are in italics, and electronic steps are in roman. Comments are preceded by the symbol D . for each e, E E, with known vertex u I D walk <ref type="bibr">((uc,,rent)</ref>   about graph traversal problems and the notion of isomorphism of graph embeddings. Prof. B. Kuipers, whose pioneering work in spatial reasoning provided the starting point for this paper, offered useful comments on a draft of the paper. Finally, we thank one of the anonymous reviewers for suggesting the possibility of using 2 k markers to explore k edges, and both reviewers for their thoughtful comments on the original manuscript.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Polynomial Time Collision Detection for Manipulator Paths Specified by Joint Motions</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Achim Schweikard</head><p>Abstract-An exact collision detection algorithm is described and analyzed. The time bound considers the complexity of the solids, the number of joints, and the number of distinct collision configurations. A bound for the number of collision configurations can be taken directly from the input data. The algorithm is based on an exact treatment of trigonometric expressions. The representation of trigonometric constants is discussed in an appendix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>The detection of intersections and collisions between objects is related to many geometric planning tasks. For example, collision detection methods are used as the basis of standard motion planning techniques. Clearly, in order to derive exact collision detection methods and asymptotic time bounds for collision detection, it is necessary to describe the complexity of given motions. The following problems are distinguished in this context. 1) Intersection detection: Given two objects in j x e d configuration, test whether the objects have a point in common. 2) Intersection computation: Given two fixed objects, compute the intersection, i.e., the set of points common to the two objects. 3) Collision detection: Given objects and motions, decide whether an intersection will occur during the motions.</p><p>The problem considered here is an extension of the third problem: Given solids and motions, compute the time intervals in which an intersection will occur. Thus, common points are not computed. In what follows we will refer to a single motion of several objects, i.e., simultaneous motions of several objects are specified with respect to a single common time parameter t .</p><p>The problem of collision detection has been studied in many contributions [2], [4]- <ref type="bibr" target="#b2">[6]</ref>, <ref type="bibr" target="#b4">[8]</ref>, [9], [ l l ] . Boyse <ref type="bibr">[2]</ref> considers two polyhedra, one of which is fixed while the other polyhedron is either translated or rotated; this case is useful in motion planning applications 1131. In <ref type="bibr" target="#b1">[5]</ref> and <ref type="bibr">[9]</ref>, arbitrary motions of polyhedra are considered and fast collision detection methods are derived using a discretization of the given motion; a discretization of a motion is a finite set of sample configurations that will occur during the motion. An intersection detection method is then applied to each sample configuration. Gilbert and Hong [SI describe an iterative collision detection method. With this method, it can be decided whether or not a collision will occur, but iterative root finding subalgorithms and a resolution parameter have to be used and time bounds considering the complexity of the motion cannot be derived. A fast method for computing the distance between polyhedra is given by Lin and Canny [ 111. This method finds the closest pair of features (i.e., vertices, faces, edges) for fixed polyhedra and can be applied to collision detection using discrete sample configurations. In general, criteria for the choice of the sample configurations are not available. A method in [SI, and [6] reduces collision detection for three-dimensional moving solids to intersection testing in higher dimensions. Here, extrusions of moving solids into an additional <ref type="bibr">Manuscript received September 19, 1990;</ref><ref type="bibr">revised July 17, 1991</ref> </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>[4], [13], [16], [19], [21], and probabilistic approaches, which typically associate probability distributions with spatial coordinates, [3], [9], [ 101, [ 171, [ 181, [20]. Graph theoreticians have examined the complexity required of a machine to traverse (without building a model of) a two-or three-dimensional space with obstacles [ 11, [2]. A major difference between random</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>) = vi.(3)We assume the following property about the transition function: if &amp;U,,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Transition function. Assuming that the robot started at U/, then the transition function 6 identifies exit r from vertex U, as being an edge to u j .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Daedalus' labyrinth. This maze is constructed within a 6 X 6 X 6 cube. The entrance and exit are on the top level (Level 1).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>n + l)dmax D marker not found, new vertex</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 3. Partial exploration results with eight markers</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>DDD</head><label></label><figDesc>Initially the robot starts at some vertex uinitial with D the markers on the floor for i from 1 to k D pickup( marker,) robot ends up taking a large number of steps when it would be more useful to simply explore the graph with the markers already dropped. Developing heuristics for improving the performance of the algorithm with multiple markers is an interesting area for future research. S := ({ uinitid}, { }) U := { + -' ( e ) I e is incident with +(uinitid)} D U is indexed by the known vertex incident with each edge e for each e in U index( e, ulnlflal) := consistent ordering of +(e) with respect to an arbitrary edge end for ucurrent := ')initial loop exit when U = { } D Select a subset of the unexplored edges in U D of up t o k elements and call this E choose( E ) D i.e., no unexplored edge remains D D consistent ordering with respect to ei add + -' ( f ) to U end for for each other marker, at +( For each new edge, move the robot there (U,) D Move along the new edge, drop the marker there (U,) D and return t o the known graph (U').</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>D</head><label></label><figDesc>e,)) D t o + ( u 2 ) drop( marker,) followEdge(+(e,)) D t o +(q) end for search through the graph looking for the dropped D markers search( S , markerFound, markerlocation) markerFound is n o w a k-vector of Boolean flags D markerLocation is a k-vector of vertex numbers for each i from k down to 1 if markerFound, then D Found a marker. D determine index of e, D with respect t o its unknown end u 2 : D walk(+(ucurr,nt) 9 +( ~1 ) ) drop( marker,) waW4,(u,), 4 4 ~~) ) for each edge f leaving u2 foNowEdge(+(f )) D t o Uunknown if marker, at uunknown then index(e,, u 2 ) := index(f, t find the marker. This is a new vertex D walk(+( ucurrent), 4( I)) followEdge(4(e1)) D to M u z ) pickup( marker,) add U, to S add e, to S index(e,, U,) := 0 for each other edge f leaving + ( u 2 )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>choose up t o k edges e,, e, , * . . e, from U</figDesc><table><row><cell>for each newly labeled vertex v</cell><cell></cell></row><row><cell>(i.e., from last loop pass)</cell><cell></cell></row><row><cell>label all vertices adjacent to U</cell><cell></cell></row><row><cell>end for</cell><cell></cell></row><row><cell>end loop</cell><cell></cell></row><row><cell>ACKNOWLEDGMENT</cell><cell></cell></row><row><cell>The authors would like to thank Prof. A. Borodin, Dr. I. Hart-</cell><cell></cell></row><row><cell>man, Dr. H. Everett, and Dr. B. Selman for useful discussions</cell><cell></cell></row><row><cell cols="2">such that the known</cell></row><row><cell cols="2">D incident vertex of e, is closest t o ucurrent, and</cell></row><row><cell>D for i = 1, 2,</cell><cell>k -1 w e have that the known</cell></row><row><cell cols="2">incident vertex of</cell></row><row><cell cols="2">D er+l is closest t o the known incident vertex of e,</cell></row><row><cell cols="2">run shortestpath k times to find edges satisfying the</cell></row><row><cell cols="2">above description.</cell></row><row><cell cols="2">walk( Ufrom, Ul0) run shortestpath to get shortest path (e,, e2, . . . e, )</cell></row><row><cell cols="2">from ufrom to uto, through S.</cell></row><row><cell>for i from 1 to k</cell><cell></cell></row><row><cell cols="2">followEdge(+( e,))</cell></row><row><cell>end for</cell><cell></cell></row><row><cell cols="2">search( S , markerFound, markerlocalion)</cell></row><row><cell cols="2">D a breadth-first approximation</cell></row><row><cell cols="2">D t o a traveling salesman problem solution seems</cell></row><row><cell>D appropriate</cell><cell></cell></row><row><cell cols="2">D since markers are likely t o be close t o current vertex</cell></row><row><cell>D in S</cell><cell></cell></row><row><cell cols="2">D Do traversal of S, stopping when k markers have</cell></row><row><cell cols="2">D been encountered</cell></row><row><cell cols="2">D or all vertices have been visited</cell></row><row><cell cols="2">run Kruskal's algorithm to get min spanning tree of S</cell></row><row><cell cols="2">for i from 1 to k set markerFound, to false</cell></row><row><cell cols="2">do breadth-first traversal,</cell></row><row><cell cols="2">taking "short cuts" across non-tree</cell></row><row><cell cols="2">edges to next vertex where possible.</cell></row><row><cell cols="2">We consider two versions here:</cell></row><row><cell cols="2">a) only take single-edge short cuts (check if current</cell></row><row><cell cols="2">and next vertex in traversal are adjacent).</cell></row><row><cell cols="2">b) run shortestpath to find shortest path from</cell></row><row><cell cols="2">current to next vertex at each step.</cell></row><row><cell cols="2">whenever a marker i is encountered,</cell></row><row><cell cols="2">set markerFound, to true, and</cell></row><row><cell cols="2">set markerLocation, to the vertex number in S , and</cell></row><row><cell cols="2">execute pickup( marker,).</cell></row><row><cell>shortestPath(s0urce)</cell><cell></cell></row><row><cell cols="2">D do a breadth-first labeling of vertices starting from</cell></row><row><cell>D vertex "source"</cell><cell></cell></row><row><cell cols="2">D where labels indicate previous vertex in path back</cell></row><row><cell>D t o sink. This</cell><cell></cell></row><row><cell cols="2">D is inspired by the Ford-Fulkerson labeling algorithm.</cell></row><row><cell cols="2">D It suffices for finding shortest paths in an</cell></row><row><cell cols="2">D unweighted graph,</cell></row><row><cell cols="2">D taking O(n) time. Use Dijkstra's algorithm if there</cell></row><row><cell cols="2">D are weights on the edges (O(n2)).</cell></row><row><cell>label source</cell><cell></cell></row><row><cell>loop</cell><cell></cell></row></table><note><p>index(+-'( f), U,) := D</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>. The author was with the Technische Universilt Berlin, Berlin, Germany. He is now with the Robotics Laboratory, Department of Computer Science, Stanford University, Stanford, CA 94305. IEEE Log Number 9103562. 1042-296X/91$01.00 0 1991 IEEE</figDesc><table /></figure>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This work was supported by the National Sciences and Engineering Research Council of Canada and by the Government of Ontario the Information Technology Research Center. Portions of this work were presented at the SPIE Symposium on Advances in Intelligent Robotics Systems, Philadelphia, PA, November 1989, and at Vision Interface, London, Ontario, June 1989.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">On deadlock detection in distributed systems</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">D</forename><surname>Gligor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">H</forename><surname>Shattuck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">5</biblScope>
			<date type="published" when="1980-09">Sept. 1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Deadlock prediction: Easy and difficult cases</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Gold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J . Comput</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1978-08">Aug. 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Notes on data base operating systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">N</forename><surname>Gray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Operating Systems-An Advanced Course</title>
		<editor>
			<persName><forename type="first">Graham</forename><surname>Bayer</surname></persName>
		</editor>
		<editor>
			<persName><surname>Segmuller</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">60</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Prevention of system deadlock</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">N</forename><surname>Habermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page">373</biblScope>
			<date type="published" when="1969">1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Comments on prevention of system deadlock</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Jolt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page">36</biblScope>
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Mixed solutions for the deadlock problem</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Howard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page">427</biblScope>
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A scaleable architecture for CIM shop floor control</title>
		<author>
			<persName><forename type="first">S</forename><surname>Joshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Wysk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CIMCON&apos;90</title>
		<meeting>CIMCON&apos;90</meeting>
		<imprint>
			<date type="published" when="1990">May 22-24. 1990</date>
			<biblScope unit="page" from="21" to="33" />
		</imprint>
		<respStmt>
			<orgName>National Institute of Standards and Technology</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Locking and deadlock detection in distributed data bases</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Menasce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Muntz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1979-05">May 1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Deadlock prevention in process computer systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Tsutsui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Fujimoto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. J</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="1978">1987. 1978</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">On the capability of finite automata in 2 and 3 dimensional space</title>
		<author>
			<persName><forename type="first">M</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Sakoda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. FOCS Cony</title>
		<meeting>FOCS Cony</meeting>
		<imprint>
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Two applications of complementation via inductive counting</title>
		<author>
			<persName><forename type="first">A</forename><surname>Borodin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Dymond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Ruzzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tompa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM Res. Div</title>
		<imprint>
			<biblScope unit="issue">58972</biblScope>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep. 13179</note>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">A robust layered control system for a mobile robot</title>
		<author>
			<persName><forename type="first">R</forename><surname>Brooks</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
		</imprint>
		<respStmt>
			<orgName>MIT AI Lab</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep. AIM-864</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Navigation for an intelligent mobile robot</title>
		<author>
			<persName><forename type="first">J</forename><surname>Crowley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE J. Robotics Automat</title>
		<imprint>
			<biblScope unit="page" from="31" to="41" />
			<date type="published" when="1985-03">Mar. 1985</date>
		</imprint>
	</monogr>
	<note>RA-I</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><surname>Davis</surname></persName>
		</author>
		<title level="m">Representing and Acquiring Geographic Knowledge</title>
		<meeting><address><addrLine>London</addrLine></address></meeting>
		<imprint>
			<publisher>Pitman and Morgan Kaufmann Publishqs</publisher>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Exploring an unknown graph</title>
		<author>
			<persName><forename type="first">X</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Papadimitriou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Ann. Symp. Foundations Comput. Sci</title>
		<meeting>Ann. Symp. Foundations Comput. Sci</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="335" to="361" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Old and new three-dimensional mazes</title>
		<author>
			<persName><forename type="first">A</forename><surname>Dewdney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sci. Amer</title>
		<imprint>
			<biblScope unit="page" from="136" to="139" />
			<date type="published" when="1988-09">Sept. 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Robotic exploration as graph construction</title>
		<author>
			<persName><forename type="first">G</forename><surname>Dudek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jenkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Milios</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wilkes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Univ. of Toronto, Res. in Biological and Computational Vision</title>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep. RBCV-TR-88-23</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Uncertain geometry in robotics</title>
		<author>
			<persName><forename type="first">H</forename><surname>Durrant-Whyte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE J. Robotics Automat</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<date type="published" when="1988-02">Feb. 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Sonar-based real-world mapping and navigation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Elfes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE J. Robotics Automat</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="249" to="265" />
			<date type="published" when="1987">1987</date>
			<pubPlace>Jline</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">L. Guibas and 1. Stolfi, &quot;himitives for the manipulation of general subdivisions and the computation of voronoi diagrams</title>
		<author>
			<persName><forename type="first">S</forename><surname>Even</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Algorithmic</forename><surname>Combinatorics</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graphics</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<date type="published" when="1973">1973. 1984</date>
			<publisher>Macmillan</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Learned navigation paths for a robot in unexplored terrain</title>
		<author>
			<persName><forename type="first">S</forename><surname>Iyengar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Jorgensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Weisbin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Proc. 2nd Cony. Artifcial Intell. Applicat</title>
		<imprint>
			<biblScope unit="page" from="147" to="156" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A qualitative approach to robot exploration and map-learning</title>
		<author>
			<persName><forename type="first">B</forename><surname>Kuipers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Byun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Workshop Spatial Reasoning Multisensor Fusion</title>
		<meeting>Workshop Spatial Reasoning Multisensor Fusion<address><addrLine>Los Altos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Navigation and mapping in large-scale space</title>
		<author>
			<persName><forename type="first">B</forename><surname>Kuipers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Levitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AI Mag</title>
		<imprint>
			<biblScope unit="page" from="25" to="43" />
			<date type="published" when="1988">1988</date>
			<pubPlace>Summer</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Building geometric world models with graph synthesis for sensor fusion in mobile robots</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shafer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Intel., L. Matthies</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="239" to="248" />
			<date type="published" when="1987-06">June 1987</date>
		</imprint>
	</monogr>
	<note>IEEE J. Robotics Automat.</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Sensor fusion in certainty grids for mobile robots</title>
		<author>
			<persName><forename type="first">H</forename><surname>Moravec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AI Mag</title>
		<imprint>
			<biblScope unit="page" from="61" to="74" />
			<date type="published" when="1988">Summer 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A stochastic map for uncertain spatial relationships</title>
		<author>
			<persName><forename type="first">N</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Iyengar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Self</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Cheeseman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Workshop Spatial Reasoning Multisensor Fusion</title>
		<meeting>Workshop Spatial Reasoning Multisensor Fusion</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
	<note>Proc. I f . Conf. Robotics Automat</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Low-level learning for a mobile robot: Environment model acquisition</title>
		<author>
			<persName><forename type="first">M</forename><surname>Turchan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2nd Conf</title>
		<meeting>2nd Conf</meeting>
		<imprint>
			<date type="published" when="1985">1985. 1990. 1988</date>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="1650" to="1655" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
