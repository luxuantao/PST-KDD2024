<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Deterministic solutions to QSAT and Q3SAT by spiking neural P systems with pre-computed resources</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Tseren-Onolt</forename><surname>Ishdorj</surname></persName>
							<email>tishdorj@abo.fi</email>
							<affiliation key="aff1">
								<orgName type="department">Department of Information Technologies</orgName>
								<orgName type="laboratory">Computational Biomodelling Laboratory</orgName>
								<orgName type="institution">Åbo Akademi University</orgName>
								<address>
									<postCode>20520</postCode>
									<settlement>Turku</settlement>
									<country key="FI">Finland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alberto</forename><surname>Leporati</surname></persName>
							<email>alberto.leporati@unimib.it</email>
							<affiliation key="aff2">
								<orgName type="department">Dipartimento di Informatica, Sistemistica e Comunicazione</orgName>
								<orgName type="institution">Università degli Studi di Milano -Bicocca</orgName>
								<address>
									<addrLine>Viale Sarca 336/14</addrLine>
									<postCode>20126</postCode>
									<settlement>Milano</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Linqiang</forename><surname>Pan</surname></persName>
							<email>lqpan@mail.hust.edu.cn</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Key Laboratory of Image Processing and Intelligent Control</orgName>
								<orgName type="department" key="dep2">Department of Control Science and Engineering</orgName>
								<orgName type="institution">Huazhong University of Science and Technology</orgName>
								<address>
									<postCode>430074</postCode>
									<settlement>Wuhan</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Xiangxiang</forename><surname>Zeng</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Key Laboratory of Image Processing and Intelligent Control</orgName>
								<orgName type="department" key="dep2">Department of Control Science and Engineering</orgName>
								<orgName type="institution">Huazhong University of Science and Technology</orgName>
								<address>
									<postCode>430074</postCode>
									<settlement>Wuhan</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Xingyi</forename><surname>Zhang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Key Laboratory of Image Processing and Intelligent Control</orgName>
								<orgName type="department" key="dep2">Department of Control Science and Engineering</orgName>
								<orgName type="institution">Huazhong University of Science and Technology</orgName>
								<address>
									<postCode>430074</postCode>
									<settlement>Wuhan</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Deterministic solutions to QSAT and Q3SAT by spiking neural P systems with pre-computed resources</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">904D99DD5B443A17E30ECCB206B2A699</idno>
					<idno type="DOI">10.1016/j.tcs.2010.01.019</idno>
					<note type="submission">Received 25 March 2009 Received in revised form 9 November 2009 Accepted 21 January 2010 Communicated by N. Jonoska</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:10+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Spiking neural P systems</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper we continue previous studies on the computational efficiency of spiking neural P systems, under the assumption that some pre-computed resources of exponential size are given in advance. Specifically, we give a deterministic solution for each of two well known PSPACE-complete problems: QSAT and Q3SAT. In the case of QSAT, the answer to any instance of the problem is computed in a time which is linear with respect to both the number n of Boolean variables and the number m of clauses that compose the instance. As for Q3SAT, the answer is computed in a time which is at most cubic in the number n of Boolean variables.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Spiking neural P systems (in short, SN P systems) were introduced in <ref type="bibr" target="#b5">[6]</ref> in the framework of Membrane Computing <ref type="bibr" target="#b15">[15]</ref> as a new class of computing devices which are inspired by the neurophysiological behavior of neurons sending electrical impulses (spikes) along axons to other neurons. Since then, many computational properties of SN P systems have been studied; for example, it has been proved that they are Turing-complete when considered as number computing devices <ref type="bibr" target="#b5">[6]</ref>, when used as language generators <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b1">2]</ref> and also when computing functions <ref type="bibr" target="#b13">[13]</ref>. We refer to the membrane computing website from <ref type="bibr" target="#b18">[18]</ref> for details.</p><p>Investigations related to the possibility to solve computationally hard problems by using SN P systems were first proposed in <ref type="bibr" target="#b2">[3]</ref>. The idea was to encode the instances of decision problems in a number of spikes, to be placed in an (arbitrarily large) pre-computed system at the beginning of the computation. It was shown that the resulting SN P systems are able to solve the NP-complete problem SAT (the satisfiability of propositional formulas expressed in conjunctive normal form) in a constant time. Slightly different solutions to SAT and 3-SAT by using SN P systems with pre-computed resources were considered in <ref type="bibr" target="#b6">[7]</ref>; here the encoding of an instance of the given problem is introduced into the pre-computed resources in a polynomial number of steps, while the truth values are assigned to the Boolean variables of the formula and the satisfiability of the clauses is checked. The answer associated to the instance of the problem is thus computed in a polynomial time. Finally, very simple solutions to the numerical NP-complete problem Subset Sum -by using SN P systems with exponential size pre-computed resources -have been presented in <ref type="bibr" target="#b8">[8]</ref>. All the systems constructed above work in a deterministic way.</p><p>A different idea of constructing SN P systems for solving NP-complete problems was given in <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b11">11]</ref>, where the Subset Sum and SAT problems were considered. In these papers, the solutions are obtained by using nondeterministic devices but without pre-computed resources. However, several ingredients are also added to SN P systems, such as extended rules and the possibility to choose rules in a non-standard way. An alternative to the constructions of <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b11">11]</ref> was given in <ref type="bibr" target="#b9">[9]</ref>, where only standard SN P systems without delaying rules, and having a uniform construction, are used. However, it should be noted that the systems described in <ref type="bibr" target="#b9">[9]</ref> either have an exponential size, or their computations last an exponential number of steps. Indeed, it has been proved in <ref type="bibr" target="#b11">[11]</ref> that a deterministic SN P system of polynomial size cannot solve an NP-complete problem in a polynomial time unless P = NP. Hence, under the assumption that P = NP, efficient solutions to NP-complete problems cannot be obtained without introducing features which enhance the efficiency of the system (pre-computed resources, ways to exponentially grow the workspace during the computation, nondeterminism, and so on).</p><p>The present paper deals with QSAT (the satisfiability of fully quantified propositional formulas expressed in conjunctive normal form) and with Q3SAT (where the clauses that compose the propositional formulas have exactly three literals), two well known PSPACE-complete problems. For QSAT we provide a family {Π QSAT (2n, m)} n,m∈N of SN P systems with precomputed resources such that for all n, m ∈ N the system Π QSAT (2n, m) solves all the instances of QSAT which are built using 2n Boolean variables and m clauses. Each system Π QSAT (2n, m) is deterministic, and computes the solution in a time which is linear with respect to both n and m; however, the size of Π QSAT (2n, m) is exponential with respect to the size of the instances of the problem. As for Q3SAT, we provide a family {Π Q 3SAT (2n)} n∈N of SN P systems with pre-computed resources, such that for all n ∈ N the system Π Q 3SAT (2n) solves all possible instances of Q3SAT which can be built using 2n Boolean variables. Also in this case the systems Π Q 3SAT (2n) are deterministic and have an exponential size with respect to n. Given an instance of Q3SAT, the corresponding answer is computed in a time which is at most cubic in n.</p><p>An important observation is that we will not specify how our pre-computed systems could be built. However, we require that such systems have a regular structure, and that they do not contain either ''hidden information'' that simplify the solution of specific instances, or an encoding of all possible solutions (that is, an exponential amount of information that allows one to cheat while solving the instances of the problem). These requirements were inspired by open problem Q27 in <ref type="bibr" target="#b15">[15]</ref>. Let us note in passing that the regularity of the structure of the system is related to the concept of uniformity, that in some sense measures the difficulty of constructing the systems. Usually, when considering families {C(n)} n∈N of Boolean circuits, or other computing devices whose number of inputs depends upon an integer parameter n ≥ 1, it is required that for each n ∈ N a ''reasonable'' description (see <ref type="bibr" target="#b0">[1]</ref> for a discussion on the meaning of the term ''reasonable'' in this context) of C (n), the circuit of the family which has n inputs, can be produced in polynomial time and logarithmic space (with respect to n) by a deterministic Turing machine whose input is 1 n , the unary representation of n. In this paper we will not delve further into the details concerning uniformity; we just rely on reader's intuition, by stating that it should be possible to build the entire structure of the system in a polynomial time, using only a polynomial amount of information and a controlled replication mechanism, as already happens in P systems with cell division. We will thus say that our solutions are expuniform (exponentially uniform) (instead of uniform), since the systems Π QSAT (2n, m) and Π Q 3SAT (2n) have an exponential size.</p><p>The paper is organized as follows. In Section 2 we recall the formal definition of SN P systems, as well as some mathematical preliminaries that will be used in the following. In Section 3 we provide an exp-uniform family {Π QSAT (2n, m)} n,m∈N of SN P systems with pre-computed resources such that for all n, m ∈ N the system Π QSAT (2n, m) solves all possible instances of QSAT containing 2n Boolean variables and m clauses. In Section 4 we present an exp-uniform family {Π Q 3SAT (2n)} n∈N of SN P systems with pre-computed resources such that for all n ∈ N the system Π Q 3SAT (2n) solves all the instances of Q3SAT</p><p>which can be built using 2n Boolean variables. Section 5 concludes the paper and suggests some possible directions for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Preliminaries</head><p>We assume the reader to be familiar with formal language theory <ref type="bibr" target="#b16">[16]</ref>, computational complexity theory <ref type="bibr" target="#b4">[5]</ref> as well as membrane computing <ref type="bibr" target="#b14">[14,</ref><ref type="bibr" target="#b15">15]</ref>. We mention here only a few notions and notations which are used throughout the paper.</p><p>For an alphabet V , V * denotes the set of all finite strings over V , with the empty string denoted by λ. The set of all nonempty strings over V is denoted by V + . When V = {a} is a singleton, then we simply write a * and a + instead of {a} * , {a} + .</p><p>A regular expression over an alphabet V is defined as follows: (i) λ and each a ∈ V is a regular expression, (ii</p><formula xml:id="formula_0">) if E 1 , E 2 are regular expressions over V , then E 1 E 2 , E 1 ∪ E 2 ,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>and E +</head><p>1 are regular expressions over V , and (iii) nothing else is a regular expression over V . With each regular expression E we associate a language L(E), defined in the following way: <ref type="figure"></ref>and<ref type="figure">L(E +</ref> 1 ) = L(E 1 ) + , for all regular expressions E 1 , E 2 over V . Non-necessary parentheses can be omitted when writing a regular expression, and also E + ∪ {λ} can be written as E * .</p><formula xml:id="formula_1">(i) L(λ) = {λ} and L(a) = {a}, for all a ∈ V , (ii) L(E 1 ∪ E 2 ) = L(E 1 ) ∪ L(E 2 ), L(E 1 E 2 ) = L(E 1 )L(E 2 ),</formula><p>For a string str = y 1 y 2 . . . y 2n , where y 2k-1 ∈ {0, 1}, y 2k ∈ {0, 1, x 2k }, 1 ≤ k ≤ n, we denote by str| i the ith symbol of the string str, 1 ≤ i ≤ 2n. For given 1 ≤ i ≤ n, if str such that the 2jth symbol is x 2j for all j ≤ i and the 2j th symbol equals to 1 or 0 for all j ≥ i, then we denote by str| 2i ← x a string which is obtained by replacing the 2ith symbol of str with x 2i . In particular, for a binary string bin ∈ {0, 1} 2n , bin| i and bin| 2 ← x 2 are defined as the ith bit of bin and the string obtained by replacing the second bit of bin with x 2 , respectively.</p><p>QSAT is a well known PSPACE-complete decision problem (see for example <ref type="bibr">[5, pages 261-262]</ref>, where some variants of the problem Quantified Boolean Formulas are defined). It asks whether or not a given fully quantified Boolean formula, expressed in the conjunctive normal form (CNF), evaluates to true or false. Formally, an instance of QSAT with n variables and m clauses is a formula γ</p><formula xml:id="formula_2">n,m = Q 1 x 1 Q 2 x 2 • • • Q n x n (C 1 ∧ C 2 ∧ • • • ∧ C m ) where each Q i , 1 ≤ i ≤ n, is either ∀ or ∃, and each clause C j , 1 ≤ j ≤ m, is a disjunction of the form C j = y 1 ∨ y 2 ∨ • • • ∨ y r j , with each literal y k , 1 ≤ k ≤ r j ,</formula><p>being either a propositional variable x s or its negation ¬x s , 1 ≤ s ≤ n. For example, the propositional formula</p><formula xml:id="formula_3">β = Q 1 x 1 Q 2 x 2 [(x 1 ∨ x 2 ) ∧ (¬x 1 ∨ ¬x 2 )] is true when Q 1 = ∀ and Q 2 = ∃, whereas it is false when Q 1 = ∃ and Q 2 = ∀.</formula><p>The decision problem Q3SAT is defined exactly as QSAT, the only difference being that all the clauses now contain exactly three literals. It is known that even under this restriction the problem remains PSPACE-complete (see, for example, <ref type="bibr">[5, page 262]</ref>).</p><p>In what follows we require that no repetitions of the same literal may occur in any clause. Without loss of generality we can also avoid the clauses in which both the literals x s and ¬x s , for any 1 ≤ s ≤ n, occur. Further, we will focus our attention on the instances of QSAT and Q3SAT in which all the variables having an even index (that is, x 2 , x 4 , . . .) are universally quantified, and all the variables with an odd index (x 1 , x 3 , . . .) are existentially quantified. We will say that such instances are expressed in normal form. This may be done without loss of generality. In fact, for any instance </p><formula xml:id="formula_4">γ n,m = Q 1 x 1 Q 2 x 2 • • • Q n x n (C 1 ∧ C 2 ∧ . . . ∧ C m ) of QSAT</formula><formula xml:id="formula_5">Q i = ∃, or by x 2i if Q i = ∀.</formula><p>Note that this transformation may require to introduce some ''dummy'' variables, that is, variables which are quantified in γ 2n,m to guarantee the alternation of even-numbered and odd-numbered variables, but that nonetheless do not appear in any clause. For example, for the propositional formula</p><formula xml:id="formula_6">β 1 = ∀x 1 ∃x 2 [(x 1 ∨ x 2 ) ∧ (¬x 1 ∨ ¬x 2 )] the normal form is β 1 = ∃x 1 ∀x 2 ∃x 3 ∀x 4 [(x 2 ∨ x 3 ) ∧ (¬x 2 ∨ ¬x 3 )]; for the propositional formula β 2 = ∃x 1 ∀x 2 [(x 1 ∨ x 2 ) ∧ (¬x 1 ∨ ¬x 2 )] we have the normal form β 2 = ∃x 1 ∀x 2 ∃x 3 ∀x 4 [(x 1 ∨ x 4 ) ∧ (¬x 1 ∨ ¬x 4 )].</formula><p>The same transformation may be applied on any instance of Q3SAT defined on n Boolean variables; in this case the result will be another instance of Q3SAT, defined on 2n variables. From now on we will denote by QSAT (2n, m) the set of all possible instances of QSAT, expressed in the above normal form, which are built using 2n Boolean variables and m clauses. Similarly, we will denote by Q 3SAT (2n) the set of all possible instances of Q3SAT, expressed in normal form, which can be built using 2n Boolean variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Spiking neural P systems</head><p>As stated in the Introduction, SN P systems have been introduced in <ref type="bibr" target="#b5">[6]</ref>, in the framework of Membrane Computing. They can be considered as an evolution of P systems, corresponding to a shift from cell-like to neural-like architectures.</p><p>In SN P systems the cells (also called neurons) are placed in the nodes of a directed graph, called the synapse graph. The contents of each neuron consists of a number of copies of a single object type, called the spike. Every cell may also contain a number of firing and forgetting rules. Firing rules allow a neuron to send information to other neurons in the form of spikes, which are accumulated at the target cell. The applicability of each rule is determined by checking the contents of the neuron against a regular set associated with the rule. In each time unit, if a neuron can use one of its rules, then one of such rules must be used. If two or more rules could be applied, then only one of them is nondeterministically chosen. Thus, the rules are used in the sequential manner in each neuron, but neurons function in parallel with each other. Note that, as usually happens in Membrane Computing, a global clock is assumed, marking the time for the whole system, and hence the functioning of the system is synchronized. When a cell sends out spikes it becomes ''closed'' (inactive) for a specified period of time, that reflects the refractory period of biological neurons. During this period, the neuron does not accept new inputs and cannot ''fire'' (that is, emit spikes). Another important feature of biological neurons is that the length of the axon may cause a time delay before a spike arrives at the target. In SN P systems this delay is modeled by associating a delay parameter to each rule which occurs in the system. If no firing rule can be applied in a neuron, then there may be the possibility to apply a forgetting rule, that removes from the neuron a predefined number of spikes.</p><p>Formally, a spiking neural membrane system (SN P system, for short) of degree m ≥ 1, as defined in <ref type="bibr" target="#b5">[6]</ref>, is a construct of the form Π = (O, σ 1 , σ 2 , . . . , σ m , syn, in, out), where:</p><p>(1) O = {a} is the singleton alphabet (a is called spike);</p><p>(2) σ 1 , σ 2 , . . . , σ m are neurons, of the form ; d is enabled and can be applied. This means consuming (removing) c spikes (thus only kc spikes remain in neuron σ i ); the neuron is fired, and it produces p spikes after d time units. If d = 0, then the spikes are emitted immediately; if d = 1, then the spikes are emitted in the next step, etc. If the rule is used in step t and d ≥ 1, then in steps t, t + 1, t + 2, . . . , t + d -1 the neuron is closed (this corresponds to the refractory period from neurobiology), so that it cannot receive new spikes (if a neuron has a synapse to a closed neuron and tries to send a spike along it, then that particular spike is lost). In the step t + d, the neuron spikes and becomes open again, so that it can receive spikes (which can be used starting with the step t + d + 1, when the neuron can again apply rules). Once emitted from neuron σ i , the p spikes reach immediately all neurons σ j such that (i, j) ∈ syn and which are open, that is, the p spikes are replicated and each target neuron receives p spikes; as stated above, spikes sent to a closed neuron are ''lost", that is, they are removed from the system. In the case of the output neuron, p spikes are also sent to the environment. Of course, if neuron σ i has no synapse leaving from it, then the produced spikes are lost. If the rule is a forgetting one of the form E/a c → λ, then, when it is applied, c ≥ 1 spikes are removed. In each time unit, if a neuron σ i can use one of its rules, then a rule from R i must be used. Since two firing rules</p><formula xml:id="formula_7">σ i = (n i , R i ), 1 ≤ i ≤ m,</formula><formula xml:id="formula_8">E 1 /a c 1 → a p 1 ; d 1 and E 2 /a c 2 → a p 2 ; d 2 can have L(E 1 ) ∩ L(E 2 ) = ∅, it</formula><p>is possible that two or more rules can be applied in a neuron; in such a case, only one of them is chosen in a nondeterministic way. However it is assumed that if a firing rule is applicable then no forgetting rule is applicable, and vice versa. Thus, the rules are used in the sequential manner in each neuron (at most one in each step), but neurons work in parallel with each other. It is important to note that the applicability of a rule is established depending on the total number of spikes contained in the neuron.</p><p>The initial configuration of the system is described by the numbers n 1 , n 2 , . . . , n m of spikes present in each neuron, with all neurons being open. During the computation, a configuration is described by both the number of spikes present in each neuron and the state of the neuron, that is, the number of steps to count down until it becomes open again (this number is zero if the neuron is already open). Thus, r 1 /t 1 , . . . , r m /t m is the configuration where neuron σ i contains r i ≥ 0 spikes and it will be open after t i ≥ 0 steps, for i = 1, 2, . . . , m; with this notation, the initial configuration of the system is C 0 = n 1 /0, . . . , n m /0 . Using the rules as described above, one can define transitions among configurations. Any sequence of transitions starting in the initial configuration is called a computation. A computation halts if it reaches a configuration where all neurons are open and no rule can be used.</p><p>Since in SN P systems the alphabet contains only one symbol (denoted by a), the input information is sometimes encoded as a sequence of ''virtual'' symbols, λ or a i , i ≥ 1, where λ represents no spike and a i represents a multiset of i spikes. The input sequence is then introduced in the input neuron one virtual symbol at each time unit, starting from the leftmost symbol of the sequence. For instance, the sequence a 2 λa 3 is composed of three virtual symbols: a 2 , λ and a 3 . When providing this sequence as input to an SN P system, the virtual symbol a 2 (that is, two spikes) is introduced at the first computation step, followed by λ (0 spikes) at the next step, and finally by a 3 (three spikes) at the third step.</p><p>Another useful extension to the model defined above, already considered in <ref type="bibr" target="#b9">[9,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b6">7]</ref>, is to use several input neurons, so that the introduction of the encoding of an instance of the problem to be solved can be done in a faster way, introducing parts of the code in parallel in various input neurons. Formally, we can define an SN P system of degree (m, ), with m ≥ 1 and 0 ≤ ≤ m, just like a standard SN P system of degree m, the only difference being that now there are input neurons denoted by in 1 , . . . , in . A valid input for an SN P system of degree (m, ) is a set of binary sequences (where each element of the sequence denotes the presence or the absence of a spike), that collectively encode an instance of a problem.</p><p>Spiking neural P systems can be used to solve decision problems, both in a semi-uniform and in a uniform way. When solving a problem Q in the semi-uniform setting, for each specified instance I of Q we build in a polynomial time (with respect to the size of I) an SN P system Π Q,I , whose structure and initial configuration depend upon I, that halts (or emits a specified number of spikes in a given interval of time) if and only if I is a positive instance of Q. On the other hand, a uniform solution of Q consists of a family {Π Q (n)} n∈N of SN P systems such that, when having an instance I ∈ Q of size n, we introduce a polynomial (in n) number of spikes in a designated (set of) input neuron(s) of Π Q (n) and the computation halts (or, alternatively, a specified number of spikes is emitted in a given interval of time) if and only if I is a positive instance.</p><p>The preference for uniform solutions over semi-uniform ones is given by the fact that they are more strictly related to the structure of the problem, rather than to specific instances. Indeed, in the semi-uniform setting we do not even need any input neuron, as the instance of the problem is embedded into the structure (number of spikes, graph of neurons and synapses, rules) from the very beginning. If the instances of a problem Q depend upon two parameters (as is the case of QSAT, where n is the number of variables and m the number of clauses in a given formula), then we will denote the family of SN P systems that solves Q by {Π Q (n, m)} n,m∈N . Alternatively, if one does not want to make the family of SN P systems depend upon two parameters, it is possible to define it as {Π Q ( n, m )} n,m∈N , where n, m indicates the positive integer number obtained by applying an appropriate bijection (for example, Cantor's pairing) from N 2 to N.</p><p>In the above definitions it is assumed that the uniform (resp., semi-uniform</p><formula xml:id="formula_9">) construction of Π Q (n) (resp., Π Q,I ) is</formula><p>performed by using a deterministic Turing machine, working in a polynomial time. As stated in the Introduction, the SN P systems we will describe will solve all the instances of QSAT and Q3SAT of a given size, just like in the uniform setting.</p><p>However, such systems will have an exponential size. Since a deterministic Turing machine cannot produce (the description of) an exponential size object in a polynomial time, we will say that our solutions are exp-uniform.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">An exp-uniform solution to QSAT</head><p>In this section we build an exp-uniform family {Π QSAT (2n, m)} n,m∈N of SN P systems such that for all n, m ∈ N the system Π QSAT (2n, m) solves all the instances of QSAT (2n, m) in a polynomial number of steps with respect to n and m, in a deterministic way.</p><p>The instances of QSAT (2n, m) to be given as input to the system Π QSAT (2n, m) are encoded as sequences of virtual symbols, as follows. For any given instance γ 2n,m = ∃x 1 ∀x 2 . . .</p><formula xml:id="formula_10">∃x 2n-1 ∀x 2n (C 1 ∧ C 2 ∧ • • • ∧ C m ) of QSAT (2n, m), let code(γ 2n,m ) = α 11 α 12 • • • α 12n α 21 α 22 • • • α 22n • • • α m1 α m2 • • • α m2n</formula><p>, where each α ij , for 1 ≤ i ≤ m and 1 ≤ j ≤ 2n, is a spike variable whose value is an amount of spikes (a virtual symbol), assigned as follows:</p><formula xml:id="formula_11">α ij =    a if x j occurs in C i ; a 2 if ¬x j occurs in C i ; λ otherwise.</formula><p>In this way the sequence α i1 α i2 • • • α i2n of spike variables represents the clause C i , and the representation of γ 2n,m is just the concatenation of the representations of the single clauses. As an example, the representation of γ 2,2 = ∃x</p><formula xml:id="formula_12">1 ∀x 2 [(x 1 ∨ ¬x 2 ) ∧ (¬x 2 )] is aa 2 λa 2 .</formula><p>The set of all the encoding sequences of all possible instances of QSAT (2n, m) is denoted by code(QSAT (2n, m)). For instance, QSAT (2, 1) contains the following nine formulas (the existential and the universal quantifiers are here omitted for the sake of readability):</p><formula xml:id="formula_13">γ 1 2,1 = no variable appears in the clause, γ 2 2,1 = x 2 , γ 3 2,1 = ¬x 2 , γ 4 2,1 = x 1 , γ 5 2,1 = x 1 ∨ x 2 , γ 6 2,1 = x 1 ∨ ¬x 2 , γ 7 2,1 = ¬x 1 , γ 8 2,1 = ¬x 1 ∨ x 2 , γ 9 2,1 = ¬x 1 ∨ ¬x 2 . Therefore, code(QSAT (2, 1)) = {λλ, λa, λa 2 , aλ, aa, aa 2 , a 2 λ, a 2 a, a 2 a 2</formula><p>}. The structure of the pre-computed SN P system that solves all possible instances of QSAT (2n, m) is illustrated in a schematic way in Figs. <ref type="figure" target="#fig_0">1</ref> and<ref type="figure" target="#fig_1">2</ref>. The system is a structure of the form</p><formula xml:id="formula_14">Π (2n,m) QSAT = (Π QSAT (2n, m), code(QSAT (2n, m))) with: • Π QSAT (2n, m) = (O, µ, in, out), where: 1. O = {a} is the singleton alphabet; 2. µ = (H, i∈H {m i }, j∈H R j , syn)</formula><p>is the structure of the SN P system, where:</p><p>-</p><formula xml:id="formula_15">H = H 0 ∪ H 1 ∪ H 2 ∪ H 3 is a finite set of neuron labels, with H 0 = {in, out, d} ∪ {d i | 0 ≤ i ≤ 2n}, H 1 = {Cx i , Cx i 1, Cx i 0 | 1 ≤ i ≤ 2n}, H 2 = {bin, Cbin | bin ∈ {0, 1} 2n</formula><p>}, H 3 = {y 1 y 2 . . . y 2n-1 y 2n | y i ∈ {0, 1} when i is odd and y i ∈ {0, 1, x i } when i is even, and there exists at least one k ∈ {1, 2, . . . , n} such that y 2k = x 2k } (we recall that even values of i correspond to universally quantified variables).</p><p>All the neurons are injectively labeled with elements from H;</p><formula xml:id="formula_16">-m d 0 = 2, m d = 1 and m i = 0 (i ∈ H, i = d 0 , d)</formula><p>are the numbers of spikes that occur in the initial configuration of the system; -R k , k ∈ H, is a finite set of rules associated with neuron σ k , where:</p><formula xml:id="formula_17">R in = {a → a, a 2 → a 2 }, R d = {a → a; 2mn + n + 6}, R d i = {a 2 → a 2 }, for i ∈ {0, 1, . . . , 2n -1}, R d 2n = {a 2 → a 2 , a 3 → λ}, R Cx i = {a → λ, a 2 → λ, a 3 → a 3 ; 2n -i, a 4 → a 4 ; 2n -i}, for i ∈ {1, 2, . . . , 2n}, R Cx i 1 = {a 3 → a 2 , a 4 → λ}, for i ∈ {1, 2, . . . , 2n}, R Cx i 0 = {a 3 → λ, a 4 → a 2 }, for i ∈ {1, 2, . . . , 2n}, R Cbin = {(a 2 ) + /a → a} ∪ {a 2k-1 → λ | k = 1, 2, . . . , 2n}, for bin ∈ {0, 1} 2n , R bin = {a m → a}, for bin ∈ {0, 1} 2n , R str = {a 2</formula><p>→ a}, where str ∈ H 3 and there exists at least one i ∈ {1, 2, . . . , n} such that</p><formula xml:id="formula_18">str| 2i = x 2i , R str = {a 2 → a 2 }, where str ∈ H 3 and str | 2k = x 2k , for all 1 ≤ k ≤ n, R out = {(a 2 ) + /a → a};</formula><p>-syn is the set of all the synapses between the neurons. The following synapses are used in the input module (see Fig. <ref type="figure" target="#fig_0">1</ref>):</p><formula xml:id="formula_19">(in, Cx i ), (d i-1 , d i ), (d i , Cx i ), (Cx i , Cx i 1</formula><p>) and (Cx i , Cx i 0), for all 1 ≤ i ≤ 2n, as well as (d 2n , d 1 ) and (d, d 2n ).</p><p>The synapses connecting the other neurons are illustrated in Fig. <ref type="figure" target="#fig_1">2:</ref> (Cx i j, Cbin), where bin ∈ {0, 1} 2n and bin| i = j, 1 ≤ i ≤ 2n, j ∈ {0, 1}, (Cbin, bin), where bin ∈ {0, 1} 2n , (bin, str), where bin ∈ {0, 1} 2n , str ∈ H 3 , and str = (bin| i ← x 2 ), (str j 1 , str j 2 ), where str j 1 , str j 2 ∈ H 3 and str j 2 = (str</p><formula xml:id="formula_20">j 1 | 2i ← x 2i ), 2 ≤ i ≤ n,</formula><p>(str, out), where str ∈ H 3 and str| 2k = x 2k , for all 1 ≤ k ≤ n; </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">in, out indicate the input and output neurons, respectively;</head><p>• code(QSAT (2n, m)) is the set of all the encoding sequences for all the possible instances of QSAT (2n, m), as defined above.</p><p>The system is composed of four modules: input, satisfiability checking, quantifier checking, and output. To simplify the description of the system and its working, the neurons in the system are arranged in n + 7 layers in Figs. <ref type="figure" target="#fig_0">1</ref> and<ref type="figure" target="#fig_1">2</ref>. The input module has three layers (the first layer contains three neurons σ d 0 , σ d and σ in ; the second layer contains 2n neurons σ d i , 1 ≤ i ≤ 2n; the third layer contains 2n neurons σ Cx i , 1 ≤ i ≤ 2n). The satisfiability checking module has also three layers (the fourth layer contains 4n neurons σ Cx i j , 1 ≤ i ≤ 2n, j = 0, 1; the fifth layer contains 2 2n neurons σ Cbin , bin ∈ {0, 1} 2n ; the sixth layer contains 2 2n neurons σ bin , bin ∈ {0, 1} 2n ). The quantifier checking module is composed of n layers, from the 7th to the (n + 6)th layer, where a total of 2 2n</p><p>-2 n neurons are used. The output module only contains one neuron σ out , which appears in the last layer. In what follows we provide a more detailed description of each module, as well as its working when solving a given instance γ 2n,m ∈ QSAT (2n, m).</p><p>• Input: The input module consists of 4n + 3 neurons, contained in the layers 1-3 as illustrated in Fig. <ref type="figure" target="#fig_0">1</ref>; σ in is the unique input neuron. The values of the spike variables of the encoding sequence code(γ 2n,m ) are introduced into σ in one by one, starting from the beginning of the computation. At the first step of the computation, the value of the first spike variable α 11 , which is the virtual symbol that represents the occurrence of the first variable in the first clause, enters into neuron σ in ; in the meanwhile, neuron σ d 1 receives two auxiliary spikes from neuron σ d 0 . At this step, the firing rule in neuron σ d is applied; as a result, neuron σ d will send one spike to neuron σ d 2n after 2mn + n + 6 steps (this is done in order to halt the computation after the answer to the instance given as input has been determined). In the next step, the value of the spike variable α 11 is replicated and sent to neurons σ Cx i , for all i ∈ {1, In this way, the values of the spike variables are introduced and delayed in the corresponding neurons until the value of the spike variable α 12n of the first clause and the two auxiliary spikes enter together into neuron σ Cx 2n at step 2n + 1. At that moment, the representation of the first clause of γ 2n,m has been entirely introduced in the system, and the second clause starts to enter into the input module. The entire sequence code(γ 2n,m ) is introduced in the system in 2mn+1 steps. • Satisfiability checking: Once all the values of spike variables α 1i (1 ≤ i ≤ 2n), representing the first clause, have appeared in their corresponding neurons σ Cx i in layer 3, together with a copy of the two auxiliary spikes, all the spikes contained in σ Cx i are duplicated and sent simultaneously to the pair of neurons σ Cx i 1 and σ Cx i 0 , for i ∈ {1, 2, . . . , 2n}, at the (2n + 2)nd computation step. In this way, each neuron σ Cx i 1 and σ Cx i 0 receives 3 or 4 spikes when x i or ¬x i occurs in C 1 , respectively, whereas it receives no spikes when neither x i or ¬x i occurs in C 1 . In general, if neuron σ Cx i 1 receives 3 spikes, then the literal x i occurs in the current clause (say C j ), and thus the clause is satisfied by all those assignments in which x i is true.</p><p>Neuron σ Cx i 0 will also receive 3 spikes, but it will delete them during the next computation step. On the other hand, if neuron σ Cx i 1 receives 4 spikes, then the literal ¬x i occurs in C j , and the clause is satisfied by those assignments in which x i is false. Since neuron σ Cx i 1 is designed to process the case in which x i occurs in C j , it will delete its 4 spikes. However, also neuron σ Cx i 0 will have received 4 spikes, and this time it will send two spikes to those neurons which are bijectively associated with the assignments for which x i is false. Note that all possible 2 2n truth assignments to x 1 , x 2 , . . . , x 2n are represented by the neurons' labels Cbin in layer 5, where bin is generated from {0, 1} 2n ; precisely, we read bin, where bin| i = j, j ∈ {0, 1}, as a truth assignment whose value for x i is j. In the next step, those neurons σ Cbin that received at least two spikes send one spike to the corresponding neurons σ bin in layer 6 (the rest of the spikes will be forgotten), with the meaning that the clause is satisfied by the assignment bin. This occurs in the (2n + 4)th computation step. Thus, the check for the satisfiability of the first clause has been performed; in a similar way, the check for the remaining clauses can proceed. All the clauses can thus be checked to see whether there exist assignments that satisfy all of them.</p><p>If there exist some assignments that satisfy all the clauses of γ 2n,m , then the neurons labeled with the values of bin ∈ {0, 1} 2n that correspond to these assignments succeed to accumulate m spikes. Thus, the rule a m → a can be applied in these neurons. The satisfiability checking module completes its process in 2mn + 5 steps.</p><p>• Quantifier checking: The universal and existential quantifiers of the fully quantified formula γ 2n,m are checked starting from step 2mn + 6. Since all the instances of QSAT (2n, m) are in the normal form, it is not difficult to see that we need only to check the universal quantifiers associated to even-numbered variables (x 2 , x 4 , . . .). These universal quantifiers are checked one by one, and thus the quantifier checking module needs n steps to complete its process. The module starts by checking the universal quantifier associated with x 2 , which is performed as follows. For any two binary sequences bin 1 and bin 2 with bin 1 | i = bin 2 | i for all i = 2 and bin 1 | 2 = 1, bin 2 | 2 = 0, if both neurons σ bin 1 and σ bin 2 contain m spikes, then neuron σ str will receive two spikes from them at step 2mn + 5, where str = (bin 1 | 2 ← x 2 ). This implies that, no matter whether x 2 = 1 or x 2 = 0, if we assign each variable x j with the value str| j , j = 2, 1 ≤ j ≤ 2n, then all the clauses of γ 2n,m are satisfied. As shown in Fig. <ref type="figure" target="#fig_1">2</ref>, in this way the system can check, in the 7th layer, the satisfiability of the universal quantifier associated to variable x 2 . The system is then ready to check the universal quantifier associated with variable x 4 , which is performed in a similar way as follows. For any two sequences str 1 and str 2 with str 1 | i = str 2 | i ∈ {0, 1}, for all i = 2, 4, and</p><formula xml:id="formula_21">str 1 | 2 = str 2 | 2 = x 2 , str 1 | 4 = 1, str 2 | 4 = 0,</formula><p>if both neurons σ str 1 and σ str 2 contain two spikes, then σ str 3 will receive two spikes, where str 3 is obtained by replacing the fourth symbol of str 1 with x 4 (i.e., str 3 = (str 1 | 4 ← x 4 )). In this way, we check the (simultaneous) satisfiability of the universal quantifiers associated to the two variables x 2 and x 4 . Similarly, the system can check the satisfiability of the universal quantifier associated with variable x 6 by using the neurons in the ninth layer. Therefore, after n steps (in the (n + 6)th layer) the system has checked the satisfiability of all the universal quantifiers associated with the variables x 2 , x 4 , . . . , x 2n . If a neuron σ str accumulates two spikes, where str| 2k = x 2k for all 1 ≤ k ≤ n, then we conclude that this assignment not only makes all the clauses satisfied, but also satisfies all the quantifiers. Therefore, the neurons which accumulate two spikes will send two spikes to the output neuron, thus indicating that the instance of the problem given as input is positive.</p><p>• Output: From the construction of the system, it is not difficult to see that the output neuron sends exactly one spike to the environment at the (2mn + n + 6)th computation step if and only if γ 2n,m is true. At this moment, neuron σ d will also send a spike to the auxiliary neuron σ d 2n (the rule is applied in the first computation step). This spike stays in neuron σ d 2n until two further spikes arrive from neuron σ d 2n-1 ; when this happens, all three spikes are forgotten by using the rule</p><formula xml:id="formula_22">a 3</formula><p>→ λ in neuron σ d 2n . Hence, the system eventually halts after a few steps since the output neuron fires. Note that the number m of clauses appearing in a QSAT (2n, m) problem may be very large (e.g., exponential) with respect to n: every variable can occur negated or non-negated in a clause, or not occur at all, and hence the number of all possible clauses is 3 2n . This means that the running time of the system may be exponential with respect to n, and also the rules a m → a in some neurons of the system are required to work on a possibly very large number of spikes. As we will see in the next section, these ''problems'' (if one considers them as problems) do not occur when considering Q3SAT, since each clause in the formula contains exactly three literals, and thus the number of possible clauses is at most cubic in n.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">An example</head><p>Let us present a simple example which shows how the system solves the instances of QSAT (2n, m), for specified values of n and m, in an exp-uniform way. Let us consider the following fully quantified propositional formula, which has two variables and two clauses (i.e., n = 1, m = 2):</p><formula xml:id="formula_23">γ 2,2 = ∃x 1 ∀x 2 (x 1 ∨ ¬x 2 ) ∧ x 1 .</formula><p>Such a formula is encoded as the sequence code(γ 2,2 ) = aa 2 aλ of virtual symbols.</p><p>The structure of the SN P system which is used to solve all the instances of QSAT (2, 2) is pre-computed as illustrated in Fig. <ref type="figure" target="#fig_2">3</ref>. It is composed of 22 neurons; its computations are performed as follows.</p><p>Input: Initially, neuron σ d 0 contains two spikes and neuron σ d contains one spike, whereas the other neurons in the system contain no spikes. The computation starts by inserting the leftmost symbol of the encoding sequence code(γ 2,2 ) = aa 2 aλ into the input neuron σ in . When this symbol (a) enters into the system, neuron σ d 0 emits its two spikes to neuron σ d 1 . At this moment, the rule occurring in neuron σ d also fires; as a result, it will send one spike to neuron σ d 2 after 11 steps. At the next step, two spikes from σ d 1 are sent to neurons σ d 2 and σ Cx 1 , while the symbol a is sent by σ in to neurons σ Cx 1 and σ Cx 2 . At the same time, the value a 2 of the second spike variable α 12 of code(γ 2,2 ) is introduced into σ in .</p><p>Neuron σ Cx 1 has accumulated three spikes and thus the rule a 3 → a 2 ; 1 can be applied in it, while the spike in neuron σ Cx 2 is forgotten by using the rule a → λ at the third computation step. Simultaneously, the value a 2 of the second spike variable α 12 from σ in and two spikes from σ d 2 enter together into σ Cx 2 ; neuron σ Cx 1 does not receive any spike, as it has been closed for this step. Thus, at the third computation step the representation of the first clause aa 2 has appeared in the input module. At this step, the value a of the first spike variable α 21 of the second clause also enters the input neuron, while neuron σ d 1 receives two spikes again, which triggers the introduction of the representation of the second clause (aλ) in the input module.</p><p>Satisfiability checking: Now, neuron σ Cx 1 is open and fires, sending three spikes to neurons σ Cx 1 1 and σ Cx 1 0 . The three spikes in neuron σ Cx 1 1 denote that literal x 1 occurs in the current clause (C 1 ), and thus the clause is satisfied by all those assignments in which x 1 = 1. And, in fact, σ Cx 1 1 sends two spikes to neurons σ C 11 and σ C 10 , to indicate that the first clause is satisfied by the assignments bin whose first value is 1. The three spikes in neuron σ Cx 1 0 denote that the current clause (C 1 ) does not contain the literal ¬x 1 . Hence, no spike is emitted from neuron σ Cx 1 0 ; its three spikes are forgotten instead. Similarly, the presence of four spikes in neuron σ Cx 2 1 (resp., in σ Cx 2 0 ) denotes the fact that literal x 2 (resp., ¬x 2 ) does not occur (resp., occurs) in clause C 1 . Hence, the spikes in neuron σ Cx 2 1 are forgotten, whereas neuron σ Cx 2 0 sends two spikes to neurons σ C 10 and σ C 00 to denote that clause C 1 is satisfied by those assignments in which x 2 = 0. In the same step, neuron σ in sends one spike (that represents the value of the spike variable α 21 previously introduced in the system) to both neurons σ Cx 1 and σ Cx 2 .</p><p>At step 5, the configuration of the system is as follows. Three spikes occur in neuron σ Cx 1 , since literal x 1 occurs in the second clause; no spikes occur in σ Cx 2 , as the clause does not contain variable x 2 ; the two auxiliary spikes appear alternately in neurons σ d 1 and σ d 2 in the input module. At the same time, neurons σ C 11 and σ C 00 contain two spikes each, whereas neuron σ C 10 contains four spikes.</p><p>In the next step, neuron σ Cx 1 sends three spikes to its two target neurons σ Cx 1 1 and σ Cx 1 0 , while each of the neurons σ C 11 , σ C 00 and σ C 10 sends one spike towards their related neurons in the next layer, thus confirming that the first clause is satisfied by the corresponding assignments. The rest of spikes in these neurons will be forgotten in the following step. At step 7, neuron σ Cx 1 1 sends two spikes to neurons σ C 11 and σ C 10 by using the rule a 3  → a 2 , whereas the three spikes in neuron σ Cx 1 0 are forgotten. Note that the spike in neurons σ 11 , σ 10 and σ 00 , which is received from their related neurons σ C 11 , σ C 00 and σ C 10 , remains unused until one more spike is received. At step 8, neuron σ C 11 sends one spike to its related neuron σ 11 and neuron σ C 10 sends one spike to its related neuron σ 10 , while the rest of spikes are forgotten. In this way, neurons σ 11 and σ 10 succeed to accumulate a sufficient number (two) of spikes to fire. On the other hand, neuron σ 00 fails to accumulate the desired number of spikes (it obtains only one spike), thus the rule in it cannot be activated. Quantifier checking: We now pass to the module which checks the universal and existential quantifiers associated to the variables. At step 9 neuron σ 1x 2 receives two spikes, one from σ 11 and another one from σ 10 , which means that the formula γ 2,2 is satisfied when x 1 = 1, no matter whether x 2 = 0 or x 2 = 1. On the other hand, neuron σ 0x 2 does not contain any spike. At step 10 the rule a 2 → a 2 is applied in neuron σ 1x 2 , making neuron σ out receive two spikes. Output: The rule occurring in neuron σ out is activated and one spike is sent to the environment, indicating that the instance of the problem given as input is positive (that is, γ 2,2 is true). At this step, as neuron σ d 2 will receive a ''trap'' spike from neuron σ d , the two auxiliary spikes circulating in the input module are deleted as soon as they arrive in it, because of the rule a 3  → λ.</p><p>Thus, the system halts after 13 computation steps since it has been started.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Solving Q3SAT</head><p>In this section we describe a family {Π Q 3SAT (2n)} n∈N of SN P systems such that for each n ∈ N, the system Π Q 3SAT (2n) solves all possible instances of Q3SAT which can be built using 2n Boolean variables. The system Π Q 3SAT (2n) will be deterministic, it will have an exponential size with respect to n, and will produce the correct answer associated to the instance of Q3SAT given as input after a polynomial (in n) number of computation steps.</p><p>Since our solution is exp-uniform, we need a way to encode the instances of Q3SAT to be given as input to Π Q 3SAT (2n). Recall that the instances of Q3SAT are defined like those of QSAT, with the constraint that each clause contains exactly three literals. In what follows, by Q 3SAT (2n) we will denote the set of all instances of Q3SAT which can be built using 2n Boolean variables x 1 , x 2 , . . . , x 2n , with the following additional three restrictions: (1) no repetitions of the same literal may occur in any clause, (2) no clause contains both the literals x s and ¬x s , for any s ∈ {1, 2, . . . , 2n}, and (3) the instance is expressed in the normal form described in section 2 (all even-numbered and odd-numbered variables are universally and existentially quantified, respectively).</p><p>As stated in the previous section, the number m of possible clauses that appear in a formula γ n,m ∈ QSAT (n, m) may be exponential with respect to n. On the contrary, the number of possible 3-clauses which can be built using 2n Boolean variables is 4n • (4n -2) • (4n -4) = Θ(n 3 ), a polynomial quantity with respect to n. This quantity, that we denote by Cl(2n), is obtained by looking at a 3-clause as a triple, and observing that each component of the triple may contain one of the 4n possible literals, with the constraints that we do not allow the repetition of literals in the clauses, or the use of the same variable two or three times in a clause.</p><p>Due to the above observation, after agreeing on a method to list all possible 3-clauses which can be built using 2n Boolean variables, an instance γ 2n,m of Q 3SAT (2n) can be simply represented as a binary sequence cod(γ n,m ) ∈ {0, 1} Cl(2n) , where a 1 in position i, 1 ≤ i ≤ Cl(2n), means that the corresponding clause occurs in γ 2n,m . It is easily seen that m is equal to the number of 1s occurring in cod(γ 2n,m ). Fig. <ref type="figure" target="#fig_3">4</ref> outlines the structure of the SN P system Π Q 3SAT (2n), which is a simple modification of the SN P system used in <ref type="bibr" target="#b6">[7]</ref> to uniformly solve all the instances of the NP-complete problem 3-SAT of a given size. In the following description, when referring to the rows and the columns that compose Π Q 3SAT (2n), consider that the system is rotated counterclockwise by 90 degrees in Fig. <ref type="figure" target="#fig_3">4</ref>. As we can see in the figure, the system is organized as a grid, having 2 2n rows (one for each possible Check Satisfiability(M (2n) )</p><formula xml:id="formula_24">res ← [1 1 • • • 1] // 2 2n elements for all columns C in M (2n)</formula><p>do if C corresponds to a clause in γ 2n,m then res ← res ∧ C // bit-wise and return res Fig. <ref type="figure">5</ref>. Pseudocode of the algorithm used to select the assignments that satisfy all the clauses of γ 2n,m ∈ Q 3SAT (2n).</p><p>assignment to the variables x 1 , x 2 , . . . , x 2n ) and Cl(2n) columns (one for each possible 3-clause which can be built using 2n</p><p>Boolean variables). The grid is followed by a tree-like structure, which is used to evaluate the quantifiers associated with the variables x 1 , x 2 , . . . , x 2n . The input to the system is the binary string cod(γ 2n,m ) that encodes the instance γ 2n,m of Q 3SAT (2n) we want to solve. This binary string is provided to Π Q 3SAT (2n) by putting, in the initial configuration, one spike in neuron σ sel i , 1 ≤ i ≤ Cl(2n), whenever the ith symbol of cod(γ 2n,m ) is 1 (and no spike otherwise). In the initial configuration of the system, the columns of neurons denoted by C 1 , C 2 , . . . , C Cl(2n) in Fig. <ref type="figure" target="#fig_3">4</ref> contain the truth tables of all possible 3-clauses, listed in the same order as the one considered when building cod(γ 2n,m ). Each truth table is represented in the system as we have done with the binary string cod(γ 2n,m ): the presence of one spike represents 1, whereas the absence of spikes represents 0. Finally, all the neurons that appear in the leftmost column of the system are initialized with one spike each.</p><p>When the computation starts, the spikes contained in the leftmost column of the system move towards the right. As it will become clear in a moment, such spikes undergo a filtering process each time they reach one of the columns made of neurons σ C j , 1 ≤ j ≤ Cl(2n). The filtering process is depicted in Fig. <ref type="figure" target="#fig_3">4</ref> by the boxes labelled with Filter. These boxes represent small subsystems, whose structure and functioning will be given in the following. The spikes that survive all the Cl(2n) filtering processes enter into the tree-like structure, where the universal and existential quantifiers associated to the Boolean variables x 1 , x 2 , . . . , x 2n are checked. The instance γ 2n,m of Q 3SAT (2n) given as input is positive if and only if one spike is emitted by neuron σ out after a predefined number of computation steps.</p><p>To see precisely how the system works, let us consider the family {M (2n) } n∈N of Boolean matrices, where M (2n) has 2 2n rows -one for each possible assignment to the variables x 1 , x 2 , . . . , x 2n -and Cl(2n) columns -one for each possible 3clause that can be built by using the same variables. For every j ∈ {1, 2, 3, . . . , 2 2n</p><p>} and i ∈ {1, 2, . . . , Cl(2n)}, the element</p><formula xml:id="formula_25">M (<label>2n</label></formula><formula xml:id="formula_26">)</formula><p>ji is equal to 1 if and only if the assignment associated with row j satisfies the clause associated with column i.</p><p>Let us now consider the algorithm given in pseudocode in Fig. <ref type="figure">5</ref>. The variable res is a vector of length 2 2n , whose components -which are initialized to 1 -are bijectively associated with all possible assignments of x 1 , x 2 , . . . , x 2n . The components of res are treated as flags: when a component is equal to 1, it indicates that the corresponding assignment satisfies all the clauses which have been examined so far. Initially we assume that all the flags are 1, since we do not have examined any clause yet. The algorithm then considers all the columns of M (2n) , one by one. If the column under consideration does not correspond to a clause in γ 2n,m , then it is simply ignored. If, on the other hand, it corresponds to a clause which has been selected as part of the instance, then the components of res are updated, putting to 0 those flags that correspond to the assignments which do not satisfy the clause. At the end of this operation, which can be performed in parallel on all the components, only those assignments that satisfy all the clauses previously examined, as well as the clause currently under consideration, survive the filtering process. After the last column of M (2n) has been processed, we have that the components of vector res indicate those assignments that satisfy all the clauses of the instance γ 2n,m of Q 3SAT (2n) given as input. Stated otherwise, res is the output column of the truth table of the unquantified propositional formula contained in γ 2n,m .</p><p>This algorithm can be easily transformed into an exponential size Boolean circuit, that mimics the operations performed on the matrix M (2n) , described by the pseudocode given in Fig. <ref type="figure">5</ref>. Such a circuit can then be easily simulated using the SN P system that we have outlined in Fig. <ref type="figure" target="#fig_3">4</ref> (precisely, the left side of the system, until the column of neurons that contain the final value of vector res). This part of the system is composed of three layers for each possible 3-clause that can be built using 2n Boolean variables. Two of these layers are used to store the intermediate values of vector res and the values contained in the columns of M (2n) , respectively. The third layer, represented by the boxes marked with Filter in Fig. <ref type="figure" target="#fig_3">4</ref>, transforms the current value of res to the value obtained by applying the corresponding iteration of the algorithm given in Fig. <ref type="figure">5</ref>. This layer is in turn composed by three layers of neurons, as we will see in a moment.</p><p>The last part of the system is used to check the satisfiability of the universal and existential quantifiers associated with the variables x 1 , x 2 , . . . , x 2n . The neurons in this part of the system compose a binary tree of depth 2n; the first layer of neurons corresponds to the bottom of the tree, and checks the satisfiability of the quantifier ∀x 2n ; the second layer checks the satisfiability of ∃x 2n-1 and so on, until the last layer, whose only neuron is σ out (the output neuron), that checks the satisfiability of ∃x 1 . To see how the check is performed, let us consider the fully quantified formula ∃x 1 ∀x 2 (¬x 1 ∨ x 2 ). This formula is composed of a single 2-clause (hence it is not a valid instance of Q3SAT), built using two Boolean variables. In Fig. <ref type="figure">6</ref> we can see the truth table of the clause, and an AND/OR Boolean circuit that can be used to check whether the quantifiers associated with x 1 and x 2 are satisfied. This circuit is a binary tree whose nodes are either AND or OR gates. Each layer of Fig. <ref type="figure">6</ref>. Example of a quantified Boolean formula formed by one clause, built using two Boolean variables. On the left, its truth table is reported with an indication of the truth assignments that make the formula true. On the right, the tree which is used to check the satisfaction of the quantifiers ∀ and ∃ is depicted.</p><p>Filter(sel i , res j , C i )</p><p>if sel i = 0 then return res j else return res j ∧ C i Fig. <ref type="figure">7</ref>. Pseudocode of the Boolean function computed by the blocks marked with Filter in Fig. <ref type="figure" target="#fig_3">4</ref>.</p><p>nodes is associated with a Boolean variable: precisely, the output layer is associated to x 1 , the next layer to x 2 , and so on until the input layer, which is associated to x n . If Q i = ∀ then the nodes in the layer associated with x i are AND gates; on the contrary, if Q i = ∃ then the nodes in such a layer are OR gates. The input lines of the circuit are bijectively associated to the set of all possible truth assignments. It is not difficult to see that when these input lines are fed with the values contained in the output column of clause's truth table, the output of the circuit is 1 if and only if the fully quantified formula is true. Since in the first part of the system we have computed the output column of the truth table of the unquantified propositional formula contained in γ 2n,m , we just have to feed these values to an SN P system that simulates the above AND/OR Boolean circuit to see whether γ 2n,m is true or not. Implementing such a Boolean circuit by means of an SN P system is trivial: to see how this can be done, just compare the last two layers of the circuits illustrated in Figs. <ref type="figure" target="#fig_4">8</ref> and<ref type="figure" target="#fig_5">9</ref>.</p><p>The overall system then works as follows. During the computation, spikes move from the leftmost to the rightmost layer of the system. One spike is expelled to the environment by neuron σ out if and only if γ 2n,m is true. In the initial configuration, every neuron in the first layer (which is bijectively associated with one of the 2 2n possible assignments to the Boolean variables x 1 , x 2 , . . . , x 2n ) contains one spike, whereas the input neurons sel 1 , sel 2 , . . . , sel Cl(2n) contain one or zero spikes, depending upon whether or not the corresponding clause is part of the instance γ 2n,m to be solved. In order to deliver these spikes at the correct moment to all the filters that correspond to the ith iteration of the algorithm, every neuron sel i contains the rule a → a; 4(i -1), whose delay is proportional to i. In order to synchronize the execution of the system, also the neurons that correspond to the ith column of M (2n) should deliver their spikes simultaneously with those distributed by neurons sel i , using the same rules. An alternative possibility is to provide the input string cod(γ 2n,m ) to the system in a sequential way, one bit at the time. In this case we should use a sort of delaying subsystem, that delivers -every four time steps -the received spike to all the neurons that correspond to the column of M (2n) currently under consideration. Since the execution time of our algorithm is proportional to the number Cl(2n) of all possible clauses containing 2n Boolean variables, this modification keeps the computation time of the entire system cubic with respect to n.</p><p>In the first computation step, all the inputs going into the first layer of filters are ready to be processed. As the name suggests, these filters put to 0 those flags which correspond to the assignments that do not satisfy the first clause (corresponding to the first column of M (2n) ). This occurs only if the clause has been selected as part of the instance γ 2n,m ∈ Q 3SAT (2n) given as input, otherwise all the flags are kept unchanged, ready to be processed by the next layer of filters. In either case, when the resulting flags have been computed they enter into the second layer of filters together with the values of the second column of M (2n) , and the input sel 2 that indicates whether this column is selected or not as being part of the instance. The computation proceeds in this way until all the columns of M (2n) have been considered, and the resulting flags (corresponding to the final value of vector res in the pseudocode of Fig. <ref type="figure">5</ref>) have been computed. Before looking at how the system checks the satisfiability of the universal and existential quantifiers ∃x 1 , ∀x 2 , . . . , ∀x 2n , let us describe in detail how the filtering process works. This process is performed in parallel on all the flags: if the clause C i has been selected then an and is performed between the value M (2n) ji (that indicates whether the jth assignment satisfies C i ) and the current value of the flag res j (the jth component of res); as a result, res j is 1 if and only if the jth assignment satisfies all the selected clauses which have been considered up to now. On the other hand, if the clause C i has not been selected then the old value of res j is kept unaltered.</p><p>This filtering process can be summarized by the pseudocode given in Fig. <ref type="figure">7</ref>, which is equivalent to the following Boolean function:</p><p>(¬sel i ∧ res j ) ∨ (sel i ∧ res j ∧ C i ).  Such a function can be computed by the Boolean circuit depicted in Fig. <ref type="figure" target="#fig_4">8</ref>, that in turn can be simulated by the SN P system illustrated in Fig. <ref type="figure" target="#fig_5">9</ref>. Note the system represented in this latter figure is a generic module which is used many times in the whole system outlined in Fig. <ref type="figure" target="#fig_3">4</ref>, hence we have not indicated the delays which are needed in neurons sel i and C i . Also neuron 1, which is used to negate the value emitted by neuron sel i , must be activated together with sel i , that is, after 4(i -1) steps after the beginning of the computation. The spike it contains can be reused in the namesake neuron that occurs in the next layer of filters.</p><p>The last part of the system illustrated in Fig. <ref type="figure" target="#fig_3">4</ref> is devoted to check the satisfiability of the universal and existential quantifiers ∃x 1 , ∀x 2 , . . . , ∀x 2n associated to the Boolean variables x 1 , x 2 , . . . , x 2n . As we have seen, the final values of vector res represent the output column of the truth table of the unquantified propositional formula contained in γ 2n,m . Hence, to check whether all the universal and existential quantifiers are satisfied, it suffices to feed these values as input to an SN P system that simulates a depth 2n AND/OR Boolean circuit that operates as described in Fig. <ref type="figure">6</ref>. Each gate is simply realized as a neuron that contains two rules, as depicted in the last two layers of Fig. <ref type="figure" target="#fig_5">9</ref>. At each computation step, one quantifier is checked; when the check terminates, one spike is emitted to the environment by the output neuron σ out if and only if the fully quantified formula γ 2n,m ∈ Q 3SAT (2n) given as input to the entire system is true. The total computation time of the system is proportional to the number Cl(2n) of columns of M (2n) , that is, Θ(n 3 ).</p><p>As we can see, the structure of the system that uniformly solves all the instances of Q 3SAT (2n) is regular, and does not contain ''hidden information''. For the sake of regularity we have also omitted some possible optimizations, that we briefly mention here. The first column of neurons in Fig. <ref type="figure" target="#fig_3">4</ref> corresponds to the initial value of vector res in the pseudocode given in Fig. <ref type="figure">5</ref>. Since this value is fixed, we can pre-compute part of the result of the first step of computation, and remove the entire column of neurons from the system. In a similar way we can also remove the subsequent columns that correspond to the intermediate values of res, and send these values directly to the next filtering layer. A further optimization concerns the values M (2n) ji , which are contained in the neurons labelled with C i . Since these values are given as input to and gates, when they are equal to 1 they can be removed since they do not affect the result; on the other hand, when they are equal to 0 also the result is 0, and thus we can remove the entire and gate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Conclusions and remarks</head><p>In this paper we have shown that QSAT, a well known PSPACE-complete problem, can be solved in deterministic linear time with respect to the number n of variables and the number m of clauses by an exp-uniform family of SN P systems with pre-computed resources. We have also considered Q3SAT, a restricted (but still PSPACE-complete) version of QSAT in which all the clauses of the instances have exactly three literals; we have shown that in this case the problem can be solved in a time which is at most cubic in n, independent of m. Each pre-computed SN P system of the family can be used to solve all the instances of QSAT (or Q3SAT), expressed in a normalized form, of a given size.</p><p>Note that using pre-computed resources in spiking neural P systems is a powerful technique, that simplifies the solution of computationally hard problems. Let us note in passing that the idea of using pre-computed resources is not new, and has sometimes been used in the literature to obtain small universal computation devices; see for example <ref type="bibr" target="#b12">[12,</ref><ref type="bibr" target="#b17">17]</ref>, where Turing machines having a small number of states and symbols reach universality due to a predefined regular pattern written on their tape. In <ref type="bibr" target="#b17">[17]</ref> universality is proved by simulating rule 110, another example of a small computation system that is universal thanks to a predefined regular pattern occurring in the cells of a cellular automaton.</p><p>The pre-computed SN P systems presented in this paper have an exponential size with respect to n but, on the other hand, have a regular structure. It still remains open as to whether such pre-computed resources can be constructed in a regular way by using appropriate computation devices that, for example, use a sort of controlled duplication mechanism to produce an exponential size structure in a polynomial number of steps. A related interesting problem is to consider whether alternative features can be introduced in SN P systems to uniformly solve PSPACE-complete problems. Nondeterminism is the first feature that comes to mind, but this is usually considered too powerful in the Theory of Computation.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. The input module of Π QSAT (2n, m).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Structure of the SN P system Π QSAT (2n, m).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. The pre-computed structure of the SN P system Π QSAT (2, 2).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Structure of a deterministic SN P system that solves all possible instances of Q 3SAT (2n).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. The Boolean circuit that computes the function Filter whose pseudocode is given in Fig. 7.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 9 .</head><label>9</label><figDesc>Fig.9. An SN P system that computes the function Filter given in Fig.7, simulating the Boolean circuit of Fig.8.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>having n variables and m clauses there exists an equivalent instanceγ 2n,m = ∃x 1 ∀x 2 . . . ∃x 2n-1 ∀x 2n (C 1 ∧ C 2 ∧ • • • ∧ C m ) with2n variables, where each clause C j is obtained from C j by replacing every variable x i by x 2i-1 if</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>where E is a regular expression over a, and c ≥ 1, p ≥ 0, d ≥ 0, with the restriction c ≥ p;(3) syn ⊆ {1, 2, . . . , m} × {1, 2, . . . , m}, with (i, i) ∈ syn for 1 ≤ i ≤ m, is the directed graph of synapses between neurons;(4) in, out ∈ {1, 2, . . . , m} indicate the input and the output neurons of Π.</figDesc><table><row><cell>where: ; d with p ≥ 1 is an extended firing (we also say spiking) rule; a rule E/a c (a) n i ≥ 0 is the initial number of spikes contained in σ i ; (b) R i is a finite set of rules of the form E/a c → a p → a p in the form E/a c → λ and is called an extended forgetting rule. Rules of the types E/a c → a; d and a c → a p with p = 0 is written → λ are said to be standard. If a rule E/a c → a p ; d has E = a c , then we will write it in the simplified form a c → a p ; d; similarly, if a rule E/a c → a p ; d has d = 0, then we can simply write it as E/a c → a p ; hence, if a rule E/a c → a p ; d has E = a c and d = 0, then we can write a c → a p . ; d, A rule E/a c The rules are applied as follows. If the neuron σ i contains exactly k spikes, and a k ∈ L(E), k ≥ c, then the rule E/a c → a p</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>2, . . . , 2n}; the two auxiliary spikes contained in σ d 1 are also sent to neurons σ Cx 1 and σ d 2 . Hence, neuron σ Cx 1 will contain 2, 3 or 4 spikes: if x 1 occurs in C 1 , then neuron σ Cx 1 collects 3 spikes; if ¬x 1 occurs in C 1 , then it collects 4 spikes; if neither x 1 nor ¬x 1 occur in C 1 , then it collects two spikes. Moreover, if neuron σ Cx 1 has received 3 or 4 spikes, then it will be closed for 2n -1 steps, according to the delay associated with the rules in it; on the other hand, if 2 spikes are received, then they are deleted and the neuron remains open. At the third step, the value of the second spike variable α 12 from neuron σ in is distributed to neurons σ Cx i , 2 ≤ i ≤ 2n, where the spikes corresponding to α 11 are deleted. At the same time, the two auxiliary spikes are duplicated and one copy of them enters into neurons σ Cx 2 and σ d 3 , respectively. The neuron σ Cx 2 will be closed for 2n -2 steps only if it contains 3 or 4 spikes, which means that this neuron will not receive any spike during this period. In neurons σ Cx i , 3 ≤ i ≤ 2n, the spikes represented by α 12 are forgotten in the next step.</figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>Valuable comments and suggestions from professor Mario J. Pérez-Jiménez are acknowledged. This work was supported by National Natural Science Foundation of China (Grant Nos. 60674106, 30870826, 60703047, and 60803113), Program for New Century Excellent Talents in University (NCET-05-0612), Ph.D. Programs Foundation of Ministry of Education of China (20060487014), Chenguang Program of Wuhan (200750731262), HUST-SRF (2007Z015A), and Natural Science Foundation of Hubei Province (2008CDB113 and 2008CDB180). The first author was partially supported by Academy of Finland, project 122426. The second author was supported by MIUR project ''Mathematical aspects and emerging applications of automata and formal languages'' (2007).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Balcázar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Díaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gabarró</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Structural Complexity</title>
		<imprint>
			<biblScope unit="volume">I</biblScope>
			<date type="published" when="1988">1988-1990</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">On string languages generated by spiking neural P systems</title>
		<author>
			<persName><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Freund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ionescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gh</forename><surname>Păun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Pérez-Jiménez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Fundamenta Informaticae</title>
		<imprint>
			<biblScope unit="volume">75</biblScope>
			<biblScope unit="page" from="141" to="162" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">On the efficiency of spiking neural P systems</title>
		<author>
			<persName><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ionescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T.-O</forename><surname>Ishdorj</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fourth Brainstorming Week on Membrane Computing</title>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Gutiérrez-Naranjo</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Gh</forename><surname>Păun</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Riscos-Núñez</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Romero-Campero</surname></persName>
		</editor>
		<meeting><address><addrLine>Sevilla</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-02-03">January 30-February 3. 2006</date>
			<biblScope unit="page" from="195" to="206" />
		</imprint>
		<respStmt>
			<orgName>Sevilla University, Fénix Editora</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Spiking neural P systems with extended rules: Universality and languages</title>
		<author>
			<persName><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ionescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T.-O</forename><surname>Ishdorj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Păun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gh</forename><surname>Păun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Pérez-Jiménez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Natural Computing</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="147" to="166" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Garey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">A Guide to the Theory of NP-Completeness</title>
		<meeting><address><addrLine>San Francisco</addrLine></address></meeting>
		<imprint>
			<publisher>W.H. Freeman and Company</publisher>
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Spiking neural P systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ionescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gh</forename><surname>Păun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Yokomori</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Fundamenta Informaticae</title>
		<imprint>
			<biblScope unit="volume">71</biblScope>
			<biblScope unit="issue">2-3</biblScope>
			<biblScope unit="page" from="279" to="308" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">T.-O</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Uniform solutions to SAT and 3-SAT by spiking neural P systems with pre-computed resources</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ishdorj</surname></persName>
		</author>
		<author>
			<persName><surname>Leporati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Natural Computing</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="519" to="534" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Solving Subset Sum by spiking neural P systems with pre-computed resources</title>
		<author>
			<persName><forename type="first">A</forename><surname>Leporati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Gutiérrez-Naranjo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Fundamenta Informaticae</title>
		<imprint>
			<biblScope unit="volume">87</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="61" to="77" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Uniform solutions to SAT and Subset Sum by spiking neural P systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Leporati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Mauri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zandron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gh</forename><surname>Păun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Pérez-Jiménez</surname></persName>
		</author>
		<idno type="DOI">10.1007/s11047-008-9091-y</idno>
	</analytic>
	<monogr>
		<title level="j">Natural Computing online version</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Solving numerical NP-complete problem with spiking neural P systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Leporati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zandron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ferretti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Mauri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Membrane Computing, International Workshop, WMC8, Selected and Invited Papers</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Eleftherakis</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Kefalas</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Gh</forename><surname>Păun</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Rozenberg</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Salomaa</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4860</biblScope>
			<biblScope unit="page" from="336" to="352" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">On the computational power of spiking neural P systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Leporati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zandron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ferretti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Mauri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Unconventional Computing</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="459" to="473" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><surname>Neary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Woods</surname></persName>
		</author>
		<idno type="arXiv">arXiv:0707.4489v1[cs.CC</idno>
		<title level="m">Small weakly universal Turing machines, Available on</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Small universal spiking neural P systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Păun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gh</forename><surname>Păun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BioSystems</title>
		<imprint>
			<biblScope unit="volume">90</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="48" to="60" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Computing with membranes</title>
		<author>
			<persName><surname>Gh</surname></persName>
		</author>
		<author>
			<persName><surname>Păun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">61</biblScope>
			<biblScope unit="page" from="108" to="143" />
			<date type="published" when="1998">2000. 1998</date>
		</imprint>
	</monogr>
	<note>See also Turku Centre for Computer Science -TUCS Report No. 208</note>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><surname>Gh</surname></persName>
		</author>
		<author>
			<persName><surname>Păun</surname></persName>
		</author>
		<title level="m">Membrane Computing. An Introduction</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Formal Languages</title>
		<author>
			<persName><forename type="first">A</forename><surname>Salomaa</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1973">1973</date>
			<publisher>Academic Press</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Small semi-weakly universal Turing machines</title>
		<author>
			<persName><forename type="first">D</forename><surname>Woods</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Neary</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machines, Computations and Universality</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Durand-Lose</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Margenstern</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007. 2007</date>
			<biblScope unit="volume">4664</biblScope>
			<biblScope unit="page" from="303" to="315" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<ptr target="http://ppage.psystems.eu" />
		<title level="m">The P systems Web page</title>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
