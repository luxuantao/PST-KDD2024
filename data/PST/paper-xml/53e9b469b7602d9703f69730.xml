<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Optimality Results for Multiprocessor Real-Time Locking *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Björn</forename><forename type="middle">B</forename><surname>Brandenburg</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of North Carolina at Chapel Hill</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">James</forename><forename type="middle">H</forename><surname>Anderson</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of North Carolina at Chapel Hill</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Optimality Results for Multiprocessor Real-Time Locking *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">C179DF25782DCC6F6C0B22216F12EDCF</idno>
					<idno type="DOI">10.1109/RTSS.2010.17</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T17:02+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>When locking protocols are used in real-time systems, bounds on blocking times are required when ensuring timing constraints. While the term "blocking" is well-understood in the context of uniprocessor real-time systems, the same is not true in the multiprocessor case. In this paper, two definitions of blocking are presented that are applicable to suspensionbased multiprocessor locking protocols. The need for two definitions arises because of differences in how suspensions are handled in existing schedulability analysis. For each definition, locking protocols are presented that have asymptotically optimal blocking behavior. In particular, protocols are presented for any job-level static-priority global or partitioned scheduling algorithm.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The recent shift by major chip manufacturers to multicore technologies has led to renewed interest in infrastructure and analysis techniques for supporting multiprocessor real-time applications. In order to support such applications, multiprocessor real-time scheduling algorithms and resource-sharing protocols are required that, when used together, enable a task system's timing constraints to be ensured. Ensuring such constraints usually requires restricting the supported task system in some way. For example, it may be necessary to restrict per-task utilizations or overall system utilization. With regard to lock-based resource sharing, such restrictions arise because of processor capacity that is lost when tasks block on one another as they wait to acquire shared resources. A good locking protocol should minimize such loss.</p><p>In the uniprocessor case, good locking protocols are well known. Indeed, uniprocessor protocols exist that ensure that each job (instance) of a task blocks for the duration of at most one (outermost) critical section, which is obviously asymptotically optimal <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b22">23]</ref>. In the multiprocessor case, however, the situation is much more murky, despite the considerable body of work on multiprocessor real-time locking protocols (which we review below). In fact, to the best of our knowledge, general, precise definitions of what actually constitutes "blocking" in this case do not even exist. Rather, existing protocols have been analyzed by providing upper * Work supported by AT&amp;T and IBM Corps.; NSF grants CNS 0834270 and CNS 0834132; ARO grant W911NF-09-1-0535; and AFOSR grant FA 9550-09-1-0549. bounds on lock-acquisition delays that would be sufficient under any reasonable definition of blocking. It goes without saying that without a precise definition of blocking, we clearly have no understanding of what constitutes optimal blocking behavior in multiprocessor systems.</p><p>Motivated by this, we discuss in this paper how to precisely define blocking in the multiprocessor case and present multiprocessor real-time locking protocols that have asymptotically optimal blocking behavior, i.e., protocols under which the amount of time lost to blocking (by any task set) is bounded within a constant factor of the loss shown to be unavoidable in the worst case (for some task sets). We specifically focus on implicit-deadline sporadic task systems that are scheduled by job-level static-priority schedulers <ref type="bibr" target="#b10">[11]</ref>. We consider three such schedulers in detail: global and partitioned earliest-deadline-first scheduling (G-EDF and P-EDF, resp.), in which jobs are prioritized in earliest-deadline-first order, and partitioned static-priority scheduling (P-SP), in which each task is assigned a fixed priority. Regarding resource sharing, our focus is locking protocols in which tasks wait by suspending. We assume that lock accesses are not nested, or equivalently, nested accesses are realized by using group locks <ref type="bibr" target="#b7">[8]</ref>.</p><p>Prior work. Due to space constraints, our discussion of prior work is not exhaustive, but rather focuses on those prior efforts that are of most relevance to the results we present. Rajkumar et al. <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b21">22]</ref> were the first to propose locking protocols for real-time multiprocessor systems. They presented two suspension-based protocols for P-SPscheduled systems, the multiprocessor priority-ceiling protocol (MPCP) <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b19">20]</ref> and the distributed priority-ceiling protocol (DPCP) <ref type="bibr" target="#b21">[22]</ref>. In later work on P-EDF-scheduled systems, Chen and Tripathi <ref type="bibr" target="#b11">[12]</ref> presented two protocols that only apply to periodic (and not sporadic) tasks, Lopez et al. <ref type="bibr" target="#b18">[19]</ref> presented a partitioning heuristic that transforms global resources (i.e., resources that can be accessed from multiple processors) into local resources, and Gai et al. <ref type="bibr" target="#b14">[15]</ref> proposed a protocol in which blocking for global resources is realized via spinning (i.e., busy-waiting) rather than suspending. More recently, Block et al. <ref type="bibr" target="#b7">[8]</ref> presented the flexible multiprocessor locking protocol (FMLP), which can be used under G-EDF, P-EDF, and P-SP <ref type="bibr" target="#b8">[9]</ref>. The FMLP categorizes critical sections as either "short" or "long": blocking is realized by spinning (suspension) for short (long) critical sections. Finally, Easwaran and Andersson <ref type="bibr" target="#b13">[14]</ref> recently pre-sented the suspension-based parallel priority-ceiling protocol (PPCP) and an analysis of the priority inheritance protocol (PIP) for globally-scheduled static-priority systems.</p><p>In all of the just-cited papers, the focus is on developing locking protocols for which blocking times can be sufficiently bounded. Issues of optimality are not considered. In many cases, the bounds that are derived are quite pessimistic. Pessimism will inevitably arise, for example, if a locking protocol is used that makes it difficult to disambiguate true blocking from ordinary demand, i.e., demand for processor time that must be accounted for assuming no locks exist. In such cases, lock-acquisition delays may get doubly charged as both blocking and ordinary demand. Of course, disambiguating blocking from demand requires formal definitions. Contributions. As in the uniprocessor case, we argue that, with respect to multiprocessor locking protocols, true blocking that must be accounted for arises when priority inversions occur. Accordingly, we use the term pi-blocking. Because the definition of pi-blocking is rooted in the notion of a "priority inversion," a formal definition of the former requires a formal definition of the latter. While the notion of a priority inversion is straightforward to define in the uniprocessor case, we argue that an appropriate definition in the multiprocessor case hinges on whether schedulability analysis is suspension-oblivious or suspension-aware. In brief (see Sec. 2), suspensions are modeled as ordinary computation under suspension-oblivious analysis, but as true suspensions under suspension-aware analysis.</p><p>Our complexity bounds apply to a system of n implicitdeadline sporadic tasks scheduled by a job-level, staticpriority scheduler on m processors, where the number of critical sections per job and the length of each critical section are taken to be constant. In the suspension-oblivious case, we present an Ω(m) lower bound on per-job worst-case blocking that applies to both partitioned and global schedulers (see Sec. 3.1). We also present global (Sec. 3.2) and partitioned (Sec. 3.3) variants of a new optimal locking protocol, the O(m) locking protocol (OMLP) (Secs. 3.2 and 3.3), for which per-job blocking times are O(m). These protocols have better blocking times than prior algorithms under suspension-oblivious analysis, so for them, we provide more exact (not just asymptotic) blocking analysis.</p><p>In the suspension-aware case, we show that O(m) blocking complexity is not possible by establishing an Ω(n) lower bound on blocking (Sec. 4.1). We show that the FMLP is optimal in the global case (Sec. 4.2), and present a simple, optimal FIFO algorithm that, in the partitioned case, has O(n) blocking complexity under suspension-aware analysis (Sec. 4.3). The simplicity of this algorithm derives from the fact that it greatly limits parallelism in accessing resources. One may question whether an asymptotically better approach might be possible by ordering requests on a static-priority or EDF basis. We show that this is not possible by establishing an Ω(mn) lower bound that is applicable to any such approach.</p><p>We formalize our system model and summarize relevant background next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background and Definitions</head><p>We consider the problem <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b17">18]</ref> of scheduling a set of n implicit-deadline<ref type="foot" target="#foot_0">1</ref> sporadic tasks τ = {T 1 , . . . , T n } on m processors; we let T i (e i , p i ) denote a task with a worst-case per-job execution time e i and a minimum job separation p i . J i,j denotes the j th job (j ≥ 1) of T i . J i,j is pending from its arrival (or release) time a i,j ≥ 0 until it finishes execution at time f i,j . If j &gt; 1, then a i,j ≥ a i,j-1 + p i . J i,j 's response time is given by f i,ja i,j . We omit the job index j if it is irrelevant and let J i denote an arbitrary job.</p><p>For a given scheduling algorithm A, task T i 's worst-case response time r i is the maximum response time of any job of T i in any schedule of τ produced by A. A task set is schedulable under A if r i ≤ p i for each T i , i.e., if every job completes by its implicit deadline <ref type="bibr" target="#b17">[18]</ref>.</p><p>A pending job is in one of two states: a ready job is available for execution, whereas a suspended job cannot be scheduled. A job resumes when its state changes from suspended to ready. We assume that pending jobs are ready unless suspended by a locking protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Resources.</head><p>The system contains q shared resources 1 , . . . , q (such as shared data objects and I/O devices) besides the m processors. When a job J i requires a resource k , it issues a request R for k . R is satisfied as soon as J i holds k , and completes when J i releases k . The request length, denoted R , is the time that J i must execute<ref type="foot" target="#foot_1">2</ref> before it releases k . We let N i,k denote the maximum number of times that any J i requests k , and let L i,k denote the maximum length of such a request, where</p><formula xml:id="formula_0">L i,k = 0 if N i,k = 0.</formula><p>A resource can be held by at most one job at any time. Thus, a locking protocol must be employed to order conflicting requests. A job J i that issues a request R incurs acquisition delay and cannot proceed with its computation while it waits for R to be satisfied. There are two principle mechanisms to realize waiting: a job can either busy-wait (or spin) in a tight loop, thereby wasting processor time, or it can relinquish the processor and suspend until its request is satisfied.</p><p>A resource k is local to a processor P if all jobs requesting k execute on P , and global otherwise. Local resources can be optimally managed with uniprocessor protocols <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b20">21]</ref>; the focus of this paper is global resources.</p><p>We assume non-nested resource requests, i.e., jobs request at most one resource at any time. We note, however, that nesting can be handled with group locks as in the FMLP <ref type="bibr" target="#b7">[8]</ref>, albeit at the expense of reduced parallelism.</p><p>Scheduling. All schedulers considered in this paper are assumed to be work-conserving job-level static-priority (JLSP) schedulers <ref type="bibr" target="#b10">[11]</ref>. We consider three such schedulers in detail: global and partitioned earliest-deadline-first scheduling (G-EDF and P-EDF, resp.), in which jobs are prioritized in order of increasing deadline (with ties broken in favor of lower-index tasks), and partitioned static-priority scheduling (P-SP), in which each task is assigned a fixed priority. We assume that P-SP-scheduled tasks are indexed in order of decreasing priority. Tasks (and their jobs) are statically assigned to processors under partitioning; in this case, we let P i , 1 ≤ P i ≤ m, denote T i 's assigned processor, and let part(x)</p><p>{T i | P i = x } denote the set of tasks assigned to processor x. Under global scheduling, jobs are scheduled from a single ready queue and may migrate <ref type="bibr" target="#b10">[11]</ref>.</p><p>Locking protocols may temporarily raise a job's effective priority. Under priority inheritance <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b22">23]</ref>, the effective priority of a job J i holding a resource k is the maximum of J i 's priority and the priorities of all jobs waiting for k . Alternatively, under priority boosting <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b21">22]</ref>, a resource-holding job's priority is unconditionally elevated above the highest-possible base (i.e., non-boosted) priority to expedite the request completion. Non-preemptive sections can be understood as a form of priority boosting. Blocking. For historical reasons, "blocking" is an overloaded term. In non-real-time settings, jobs waiting for a shared resource are commonly said to be "blocked." In the context of uniprocessor real-time resource sharing, "blocking" has a more specific meaning: a waiting job is not blocked whenever the currently-scheduled job is of higher priority <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b22">23]</ref>. This notion of blocking arises because acquisition delay can increase response times and must be accounted for when determining whether a task set is schedulable. Since acquisition delay that overlaps with higher-priority work does not affect response times, it is not counted as "blocking" even though the job is "blocked on" a resource. In this interpretation, a job incurs "blocking" only during times of priority inversion <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b22">23]</ref>, i.e., if a low-priority job is scheduled while a higher-priority job is pending.</p><p>Further, in the context of schedulability analysis, "blocking" can also refer to other delays unrelated to resource sharing that cause response-time increases. For example, this includes deferral blocking <ref type="bibr" target="#b23">[24]</ref>, which arises under staticpriority scheduling due to suspensions. Deferral blocking does not necessarily coincide with priority inversion.</p><p>In this paper, we consider the definition specific to resource sharing, which we denote as priority inversion blocking (pi-blocking) to avoid ambiguity. To reiterate, piblocking occurs whenever a job's completion is delayed and this delay cannot be attributed to higher-priority demand (formalized below). We let b i denote a bound on the total piblocking incurred by any J i .</p><p>Before we continue, we need to clarify the concept of a "priority inversion on a multiprocessor," which is complicated by two issues. First, on a uniprocessor, pi-blocking occurs when a low-priority job is scheduled in place of a higher-priority job. This intuitive definition does not generalize to multiprocessors: as some processors may idle while a job is waiting, pi-blocking may be incurred even when no lower-priority job is scheduled.</p><p>Second, multiprocessor schedulability analysis has not yet matured to the point that suspensions can be analyzed under all schedulers. In particular, none of the seven major G-EDF hard real-time schedulability tests <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b15">16]</ref> inherently accounts for suspensions. Such analysis is suspensionoblivious (s-oblivious): jobs may suspend, but each e i must be inflated by b i prior to applying the test to account for all additional delays. This approach is safe-converting execution time to idle time does not increase response timesbut pessimistic, as even suspended jobs are (implicitly) considered to prevent lower-priority jobs from being scheduled. In contrast, suspension-aware (s-aware) schedulability analysis that explicitly accounts for b i is available for global static-priority scheduling, P-EDF, and P-SP (e.g., see <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b20">21]</ref>). Notably, suspended jobs are not considered to occupy a processor under s-aware analysis.</p><p>Consequently, priority inversion is defined differently under s-aware and s-oblivious analysis: since suspended jobs are counted as demand under s-oblivious analysis, the mere existence of m pending higher-priority jobs rules out a priority inversion, whereas only ready higher-priority jobs can nullify a priority inversion under s-aware analysis.</p><p>Def. 1. Under global s-oblivious schedulability analysis, a job J i incurs s-oblivious pi-blocking at time t if J i is pending but not scheduled and fewer than m higher-priority jobs are pending.</p><p>Def. 2. Under global s-aware schedulability analysis, a job J i incurs s-aware pi-blocking at time t if J i is pending but not scheduled and fewer than m higher-priority jobs are ready. <ref type="foot" target="#foot_2">3</ref>In both cases, "higher-priority" is interpreted with respect to base priorities. The difference between s-oblivious and saware pi-blocking is illustrated in Fig. <ref type="figure" target="#fig_0">1</ref>. Notice that Def. 1 is weaker than Def. 2. Thus, lower bounds on s-oblivious piblocking apply to s-aware pi-blocking as well, and the converse is true for upper bounds.</p><p>In the case of partitioning, definitions similar to Defs. 1 and 2 apply on a per-processor basis, i.e., only local higherpriority jobs are considered and m = 1.</p><p>Blocking complexity. We study two characteristic complexity metrics that reflect overall pi-blocking: maximum pi-blocking, max Ti∈τ {b i }, which reflects per-task bounds that are required for schedulability analysis, and total piblocking,  <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b2">3)</ref>, and since no higher-priority jobs exist it is pi-blocked under either definition. J1, suspended during <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b3">4)</ref>, suffers pi-blocking under either definition during <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4)</ref> since it is among the m highest-priority pending jobs, but only s-aware pi-blocking during [2, 3) since J3 is pending but not ready then. (The notation in this figure is used in subsequent figures as well.)</p><p>whether the maximum pi-blocking bound is "typical." Assumptions. Concrete bounds on pi-blocking must necessarily depend on each L i,k -long requests will cause long priority inversions under any protocol. Similarly, bounds under any protocol become increasingly pessimistic as the total number of requests per job grows. Thus, when deriving asymptotic bounds, we consider, for each T i , 1≤k≤q N i,k and each L i,k to be constants and assume n ≥ m. All other parameters are considered variable (or dependent on m and n). In particular, we do not impose constraints on the ratio max{p i }/ min{p i } or the number of tasks sharing each k .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">S-Oblivious Pi-Blocking</head><p>We first consider s-oblivious pi-blocking. We begin by establishing lower bounds on maximum and total pi-blocking, and then present an optimal locking protocol for both global (Sec. 3.2) and partitioned scheduling (Sec. 3.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Lower</head><p>Bound Ω(m) pi-blocking is unavoidable in some cases. Consider the following pathological high-contention task set. Proof. Without loss of generality, assume that n is an integer multiple of m. Consider the schedule resulting from the <ref type="bibr" target="#b4">5</ref> 1 0 1 5 0 following periodic arrival sequence: each J i,j is released at time a i,j = ( i/m -1) • m + (j -1) • p i , and issues one request R i,j , where R i,j = 1, i.e., releases occur in groups of m jobs and each job requires 1 for its entire computation.</p><formula xml:id="formula_1">J 1 J 2 J 3 J 4 J 5 J 6</formula><p>The resulting G-EDF schedule is illustrated in Fig. <ref type="figure" target="#fig_2">2</ref>. There are n/m groups of m tasks each that release jobs simultaneously. Each group of jobs of T g•m+1 , . . . , T g•m+m , where g ∈ {0, . . . , n/m -1}, issues m concurrent requests for 1 . Since 1 cannot be shared, any locking protocol must impart some order, and thus there exists a job in each group that incurs d time units of pi-blocking for each d ∈ {0, . . . , m -1}. Hence, for each g,</p><formula xml:id="formula_2">g•m+m i=g•m+1 b i ≥ m-1 i=0 i = Ω(m 2</formula><p>), and thus, across all groups,</p><formula xml:id="formula_3">n i=1 b i = (n/m-1) g=0 g•m+m i=g•m+1 b i ≥ n/m • Ω(m 2 ) = Ω(nm), which implies max Ti∈τ {b i } = Ω(m).</formula><p>By construction, the schedule does not depend on G-EDF scheduling since no more than m jobs are pending at any time, and thus applies to other global JLSP schedulers as well. The lower bound applies equally to partitioned JLSP schedulers since τ seq (n) can be trivially partitioned such that each processor serves at least n/m and no more than n/m tasks.</p><p>Prior work shows this bound to be tight for spin-based protocols-if jobs busy-wait non-preemptively in FIFO order, then they must wait for at most m -1 earlier requests <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b12">13]</ref>. However, prior work has not yielded an O(m) suspension-based protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Optimal Locking under Global Scheduling</head><p>As mentioned in the introduction, Block et al.'s FMLP <ref type="bibr" target="#b7">[8]</ref> is the only prior locking protocol for G-EDF that allows waiting jobs to suspend. The FMLP's primary design goal is simplicity, in both implementation and analysis. Accordingly, conflicting requests for both short and long resources are satisfied in FIFO order. As pointed out above, this is optimal for busy-waiting. In contrast, the FMLP analysis for long resources is asymptotically worse-jobs can incur O(n) pi-blocking when waiting for a long resource <ref type="bibr" target="#b7">[8]</ref>, and schedules in which a job does indeed incur Θ(n) s-oblivious pi-blocking are readily created, as shown in Fig. <ref type="figure" target="#fig_4">3(a)</ref>.</p><formula xml:id="formula_4">5 0 (a) J 1 J 2 J 3 J 4 5 0 (b) J 1 J 2 J 3 J 4</formula><p>It is tempting to view this as an indictment of FIFO ordering, as one might reasonably expect a real-time locking protocol to reflect job priorities. However, ordering requests by job priority, as done in <ref type="bibr" target="#b13">[14]</ref>, does not improve the bound: since a low-priority job can be starved by later-issued higherpriority requests, it is easy to construct an arrival sequence in which a job incurs Ω(n) s-oblivious pi-blocking, as seen in Fig. <ref type="figure" target="#fig_4">3(b</ref>). Thus, ordering all requests by job priority is, at least asymptotically speaking, not preferable to the muchsimpler FIFO queuing.</p><p>Fortunately, by combining FIFO and priority ordering, it is possible to realize O(m) pi-blocking, as shown next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">The Global OMLP</head><p>The O(m) locking protocol (OMLP ) is a suspension-based resource sharing protocol in which jobs incur at most O(m) s-oblivious pi-blocking. In the global OMLP, each resource is protected by two locks: a priority-based m-exclusion lock 4  that limits access to a regular FIFO mutex lock, which in turn serializes access to the resource.</p><p>Structure. For each resource k , there are two job queues: FQ k , a FIFO queue of length at most m, and PQ k , a priority queue (ordered by job priority) that is only used if more than m jobs are contending for k . The job at the head of FQ k (if any) holds k .</p><p>Rules. Let queued k (t) denote the number of jobs queued in both FQ k and PQ k at time t. Requests are ordered according to the following rules.</p><formula xml:id="formula_5">G1 A job J i that issues a request R for k at time t is appended to FQ k if queued k (t) &lt; m; otherwise, if queued k (t) ≥ m, it is added to PQ k . R is satisfied</formula><p>when J i becomes the head of FQ k . 4 An m-exclusion lock can be held concurrently by up to m jobs. G2 All queued jobs are suspended, with the exception of the job at the head of FQ k , which is ready and inherits the priority of the highest-priority job in FQ k and PQ k .</p><formula xml:id="formula_6">G3 When J i releases k , it is dequeued from FQ k and the new head of FQ k (if any) is resumed. Also, if PQ k is non-empty, then the highest-priority job in PQ k is moved to FQ k .</formula><p>The key insight is the use of an m-exclusion lock to safely defer requests of lower-priority jobs without allowing a piblocked job to starve. This can be observed in the example depicted in Fig. <ref type="figure">4</ref>. At time 1.5, m = 2 jobs hold the mexclusion lock, i.e., have entered FQ 1 , and thus J 3 must enter PQ 1 . Hence it is safely deferred when 1 is later requested by higher-priority jobs (J 4 , J 5 , J 6 ). At the same time, J 2 , which incurs pi-blocking until J 6 's arrival at time 2, precedes the later-issued requests since it already held the m-exclusion lock-this avoids starvation in scenarios such as the one depicted in Fig. <ref type="figure" target="#fig_4">3(b</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Global OMLP Schedulability Analysis</head><p>We first derive a bound on the number of requests that cause J i to be pi-blocked. We then show how such bounds affect scheduling analysis by considering G-EDF.</p><p>In the following, let t 0 denote the time at which J i issues R, t 1 denote the time at which J i enters FQ k , and t 2 denote the time at which R is satisfied (see Fig. <ref type="figure">4</ref>). Further, let entered (t), t 0 ≤ t &lt; t 1 , denote the number of jobs that have been moved from PQ k to FQ k during [t 0 , t] due to Rule G3, i.e., that preceded J i in entering FQ k . For example, for J 6 in Fig. <ref type="figure">4</ref>, entered (3.5) = 0 and entered (6) = 2.</p><p>Lemma 2. For each point in time t ∈ [t 0 , t 1 ), if J i is piblocked at time t, then entered (t) &lt; m.</p><p>Proof. By Rule G3, because J i has not yet entered FQ k at time t, there must be m pending jobs queued in FQ k . Due to FIFO ordering, if entered (t) ≥ m, then each job queued in FQ k at time t must have been enqueued in FQ k during [t 0 , t]. By Rule G3, this implies that each job in FQ k must have a priority that exceeds J i 's priority. By the definition of s-oblivious pi-blocking (Def. 1), the presence of m higherpriority pending jobs implies that J i is not pi-blocked. Lemma 3. During [t 0 , t 2 ], J i incurs pi-blocking for the combined duration of at most 2 • (m -1) requests. Proof. Due to the bounded length of FQ k , at most m -1 requests complete in [t 1 , t 2 ] before a given request is satisfied. By Lemma 2 and Rule G3, at most m -1 requests complete before J 1 is no longer pi-blocked in [t 0 , t 1 ).</p><p>Combining Lemma 3 with the maximum request length for each k yields the following bound.</p><formula xml:id="formula_7">Lemma 4. J i is pi-blocked for at most b i q k=1 N i,k • 2 • (m -1) • max 1≤i≤n {L i,k }.</formula><p>Proof. By Lemma 3, J i is pi-blocked for the duration of at most 2 • (m -1) requests each time it requests a resource k . Due to priority inheritance, the resource-holding job has an effective priority among the m highest priorities whenever J i is pi-blocked; requests are thus guaranteed to progress towards completion when J i is pi-blocked. As J i requests k at most N i,k times, it suffices to consider the longest request for k N i,k • 2 • (m -1) times. The sum of the per-resource bounds yields b i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1. S-oblivious pi-blocking under the global</head><p>OMLP is asymptotically optimal.</p><p>Proof. Follows from Lemmas 1, 3, and 4.</p><p>Practically speaking, the bound given in Lemma 4 can be pessimistic since it does not take the actual "demand" for shared resources into account, i.e., this bound cannot reflect low-contention scenarios in which each k is requested by only few tasks. For example, consider a message buffer that is shared between only two tasks and suppose m = 100: assuming that every request is interfered with by 198 requests is clearly needlessly pessimistic. We provide a less pessimistic bound that reflects individual request frequencies and lengths in Appendix A.</p><p>Recall that b i was derived assuming that suspended higher-priority jobs are accounted for as demand. Thus, each per-job execution time must be inflated by b i before applying existing G-EDF schedulability tests that assume tasks to be independent.</p><p>Theorem 2. A task set τ is schedulable under G-EDF and the OMLP if τ is deemed schedulable by an s-oblivious G-EDF schedulability test for independent tasks <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b15">16]</ref>, where τ</p><formula xml:id="formula_8">= {T i (e i + b i , p i ) | T i ∈ τ }.</formula><p>Note that the derivation of b i itself does not depend on G-EDF; the OMLP can thus also be applied to other global JLSP schedulers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Optimal Locking under Partitioned Scheduling</head><p>Additional challenges arise under partitioning since priority inheritance across partitions is, from an analytical point of view, ineffective. Under global scheduling (and on uniprocessors), priority inheritance ensures that the resourceholding job has sufficient priority to be scheduled whenever a waiting job is pi-blocked. In contrast, the highest local priority may be lower than the priority of any remote job under partitioning and thus progress cannot be guaranteed.</p><p>In prior work, three partitioned, suspension-based realtime locking protocols have been proposed: the DPCP <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b21">22]</ref> and MPCP <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b20">21]</ref> for P-SP scheduling, and the FMLP for both P-EDF <ref type="bibr" target="#b7">[8]</ref> and P-SP <ref type="bibr" target="#b8">[9]</ref> scheduling. These protocols share two characteristics: they all employ priority boosting instead of (or in addition to) priority inheritance, and they use global, per-resource wait queues, in which jobs are ordered either by priority (DPCP and MPCP) or in FIFO order (FMLP). Interestingly, either design choice can result in schedules with Ω(n) pi-blocking for some jobs. This is avoided by the partitioned OMLP.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">The Partitioned OMLP</head><p>Since comparisons of local and remote priorities cannot be used to bound pi-blocking under partitioning, the partitioned OMLP uses a token abstraction to limit global contention. A "contention token" is a virtual, local resource that a job must hold before it may request a global resource. There is only a single contention token per processor, i.e., the same token is used for all global resources. This serves to limit the number of jobs that can cause pi-blocking due to priority boosting. Structure. The contention token CT P local to processor P , P ∈ {1, . . . , m}, is a binary semaphore with an associated priority queue PQ P (ordered by job priority). There is one global FIFO queue FQ k of length at most m for each resource k . The job at the head of FQ k holds k . Rules. Let J i denote a job on processor P i that issues a request R for a global resource k at time t.</p><p>P1 If CT Pi is not held by any (local) job at time t, then J i acquires CT Pi and proceeds with Rule P3. Otherwise, J i is suspended and enqueued in PQ Pi .</p><p>P2 If J i was suspended due to Rule P1, then it resumes and acquires CT Pi at the earliest point in time such that both (a) J i is the highest-priority pending job assigned to P i and (b) CT Pi is not being held.</p><p>P3 Once J i holds CT Pi , it is added to FQ k . J i is suspended unless FQ k was empty before adding J i .</p><p>P4 J i 's effective priority is boosted while holding CT Pi , i.e., J i is scheduled unless suspended.</p><formula xml:id="formula_9">1 0 1 5 0 acquires CT B prio i B trans i B fifo i J 1 J 2 J 3 J 4 J 5 J 6</formula><p>Figure 5: Illustration of s-oblivious pi-blocking under P-EDF and the partitioned OMLP for six tasks sharing one resource on m = 2 processors. J1 incurs direct pi-blocking (B fifo i ) while waiting for J3 to release 1 until the higher-priority job J2 is released at time 4. J2 is preempted and incurs pi-blocking (B prio i ) when J1 is priorityboosted during <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b7">8)</ref>. J4 incurs pi-blocking immediately on release at time 2 because J3 is priority-boosted (B prio i ), and again during [5.5, 6.5] while waiting for J1 to release 1 (B fifo i ). J4 is no longer pi-blocked when the higher-priority J6 is released at time 6.5. J6 incurs pi-blocking during <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b8">9)</ref> while it waits for J6 to release CT2. The first half of the interval is accounted for by B trans 6 since J6 is transitively pi-blocked by a remote request while J4 is waiting itself. This changes at time 8 when J4 is priority-boosted to complete its request, which is accounted for by B prio 6 . Note that J5 does not resume until time 11 when it becomes the highest-priority pending job despite CT2 becoming available at time 10.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>P5 When</head><formula xml:id="formula_10">J i releases k , it is removed from FQ k , releases</formula><p>CT Pi , and the new head of FQ k (if any) is resumed.</p><p>An example schedule is depicted in Fig. <ref type="figure" target="#fig_11">5</ref>. Under the partitioned OMLP, jobs that do not share resources themselves may still incur pi-blocking due to priority boosting (e.g., this happens to J 2 at time 5 in Fig. <ref type="figure" target="#fig_11">5</ref>). This is not the case under the global OMLP, which highlights the advantage of using priority inheritance if possible. Note that the set of all m contention tokens implements an m-exclusion algorithm-thus, at most m jobs may contend for global resources at any time. This property is essential to obtaining the following O(m) bound on pi-blocking.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">Partitioned OMLP Schedulability Analysis</head><p>Pi-blocking arises in three ways under the partitioned OMLP, as illustrated in Fig. <ref type="figure" target="#fig_11">5</ref>. J i may incur pi-blocking 1. due to a local request if it is preempted by a priorityboosted job (Rule P4)-this delay is denoted B prio i ; 2. directly due to remote requests while waiting in a FIFO queue (Rule P3)-this delay is denoted B fifo i ; and 3. transitively due to remote requests while waiting for CT Pi (Rules P1 and P2) if the CT Pi -holding job is suspended itself (Rule P3)-this delay is denoted B trans i .</p><p>We bound each of these sources individually and begin with interference due to lower-priority jobs.</p><p>Lemma 5. No job local to P i with priority lower than J i 's priority acquires CT Pi while J i is pending.</p><p>Proof. Suppose a lower-priority job J x acquires CT Pi at time t while J i is pending, i.e., t ∈ [a i , f i ). If J x was suspended by Rule P1, then, by Rule P2(a), J x cannot resume and acquire CT Pi at time t. Thus, to issue a request at time t, J x must be ready and scheduled, which implies that J i is suspended. If J i is suspended due to Rule P4, then it holds CT Pi itself. If J i is suspended due to Rule P1, then CT Pi is not available at time t. Thus, in either case J x cannot acquire CT Pi at time t ∈ [a i , f i ).</p><p>Lemma 6. J i is pi-blocked due to local, priority-boosted, lower-priority jobs (Rule P4) for at most</p><formula xml:id="formula_11">B prio i max {L x,k | T x ∈ part(P i ) ∧ 1 ≤ k ≤ q } .</formula><p>Proof. Let J x denote a lower-priority job that is priorityboosted while J i is pending. By Rule P4, J x must hold CT Pi . By Lemma 5, J x must have acquired CT Pi before J i 's release. At most one such J x can exist. J x releases CT Pi after one request (Rule P5). Thus, J i is blocked for the length of at most one local request.</p><p>Next, we bound pi-blocking due to Rule P3, which only affects jobs that issue requests. Lemma 7. While holding CT Pi , J i incurs pi-blocking for at most</p><formula xml:id="formula_12">B fifo i q k=1 N i,k • (m -1) • max 1≤x≤n {L x,k }.</formula><p>Proof. Due to Rule P1, at most one job on every remote processor can globally contend at any time. Thus, due to the FIFO ordering of each FQ k , at most (m -1) requests precede J i 's request each time that J i requires k . Priority boosting ensures that the resource-holding job is always scheduled (Rule P4), thus progress is ensured. Since FIFO queues are not shared among resources, the sum of the individual per-resource bounds yields B fifo i . Finally, we need to bound pi-blocking due to Rule P1. Lemma 8. While waiting for CT Pi , J i incurs at most</p><formula xml:id="formula_13">B trans i (m -1) • max 1≤k≤q max 1≤x≤n {L x,k }</formula><p>pi-blocking due to requests issued by remote jobs. Proof. J i must wait for CT Pi if it is held by either a higherpriority or a lower-priority local job J x . By the definition of s-oblivious pi-blocking, J i is only pi-blocked in the latter case. By Lemma 5, this can occur at most once. While J i waits for J x to release CT Pi , it is transitively pi-blocked by at most (m -1) remote requests since at most m -1 jobs can precede J x in the FIFO queue. Priority boosting ensures the progress of resource-holding jobs.</p><p>Note that B prio i already accounts for the execution of the lower-priority job's request, and that B trans i thus only accounts for pi-blocking that J i incurs while the CT Pi -holding job is suspended (e.g., see J 6 in Fig. <ref type="figure" target="#fig_11">5</ref>). Further, note that B trans i and B fifo i only apply to tasks that share resources, i.e., if</p><formula xml:id="formula_14">q k=1 N i,k &gt; 0. Lemma 9. J i incurs pi-blocking for at most b i B prio i if q k=1 N i,k = 0, i.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>e., if T i does not access resources, and b</head><formula xml:id="formula_15">i B prio i + B fifo i + B trans i otherwise.</formula><p>Proof. Follows from the preceding discussion.</p><p>Note that the above bound is again very coarse-grained and thus likely pessimistic. As in the global case, we provide a less pessimistic bound that reflects individual request frequencies and lengths in Appendix A. However, Lemma 9 suffices to establish optimality. Schedulability under P-EDF can be established with the classic s-oblivious EDF utilization bound <ref type="bibr" target="#b17">[18]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 4. A task set τ is schedulable under P-EDF and the OMLP if, for each processor</head><formula xml:id="formula_16">o, 1 ≤ o ≤ m, Ti∈part(o) ei+bi pi ≤ 1.</formula><p>As in the global case, the derivation of b i does not inherently depend on EDF scheduling, and can be applied to other JLSP schedulers by substituting an appropriate s-oblivious schedulability test.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">S-Aware Pi-Blocking</head><p>One can easily construct schedules with later-arriving, higher-priority jobs similar to Fig. <ref type="figure" target="#fig_4">3(b</ref>) that demonstrate that the OMLP does not ensure O(m) s-aware pi-blocking. Naturally, the question arises: can the OMLP be "tweaked" to achieve this bound? This is, in fact, impossible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Lower Bound</head><p>The following lemma shows that maximum s-aware piblocking of Ω(n) is fundamental. Lemma 10. There exists an arrival sequence for τ seq (n) (see Def. 3) such that, under s-aware analysis, max Ti∈τ {b i } = Ω(n) and n i=1 b i = Ω(n 2 ), under any locking protocol and JLSP scheduler.</p><p>Proof. Without loss of generality, assume that n is an integer multiple of m. We first consider the partitioned case and assume that P i = i/m , i.e., n/m tasks are assigned to each processor.</p><p>Consider the schedule S seq resulting from a synchronous, periodic arrival sequence: each J i,j is released at a i,j = (j -1) • p i , and issues one request R i,j , where R i,j = 1. S seq is illustrated in Fig. <ref type="figure" target="#fig_9">6</ref>(a) assuming P-EDF scheduling. Note that linear suspension times are immediately apparent. However, to bound b i under any JSLP scheduler, we need to take into account the times in which a suspended job is not pi-blocked because a higher-priority job executes. Towards this aim, consider the schedule S par resulting from the same arrival sequence assuming that jobs are independent, i.e., each J i executes for e i without requesting 1 . S par is illustrated in Fig. <ref type="figure" target="#fig_9">6(b)</ref>.</p><formula xml:id="formula_17">5 0 J 1 J 2 J 3 J 4 (a) 5 0 J 1 J 2 J 3 J 4 (b)</formula><p>Under S seq , because jobs are serialized by 1 , only one job completes every time unit until no jobs are pending; thus, Under S par , because jobs are independent and the scheduler is, by assumption, work-conserving, m jobs complete concurrently every time unit until no jobs are pending; thus, under any job prioritization,</p><formula xml:id="formula_18">n i=1 r par i = n i=1 i/m .</formula><p>By construction, no job is pi-blocked in S par . In contrast, jobs incur pi-blocking in S seq under the same JLSP scheduler, i.e., jobs are prioritized consistently in S par and S seq . Thus, the observed response time increase of every job reflects the amount of pi-blocking incurred in S seq . Therefore, for each T i , b i ≥ r seq i,1r par i,1 , and thus</p><formula xml:id="formula_19">n i=1 b i ≥ n i=1 r seq i,1 - n i=1 r par i,1 = n i=1 i- n i=1 i m ≥ n i=1 i- 1 m n i=1 i- n i=1 1 = 1 -1 m (n+1) n 2 -n = Ω(n 2 ). This implies max Ti∈τ {b i } = Ω(n).</formula><p>Since at most one job is scheduled in S seq at any time, pi-blocking does not decrease under global scheduling.</p><p>We next show this bound to be tight under both global and partitioned scheduling.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Optimal Locking under Global Scheduling</head><p>The suspension-based "long" FMLP for G-EDF <ref type="bibr" target="#b7">[8]</ref> uses perresource FIFO queues with priority inheritance, i.e., there is a FIFO queue FQ k for each resource k , J i is appended to FQ k when requesting k , and the job at the head of FQ k holds k and inherits the priority from any job blocked on k . <ref type="foot" target="#foot_3">5</ref> This, in fact, ensures asymptotically optimal s-aware pi-blocking.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 5. S-aware pi-blocking under the global, suspension-based FMLP [8] is asymptotically optimal.</head><p>Proof. We derive a simple bound on s-aware pi-blocking under the FMLP.</p><p>Each time that J i requests a resource k , it is enqueued in FQ k . Thus, it must wait for the completion of at most n -1 requests. Due to priority inheritance, the job at the head of FQ k is guaranteed to be scheduled whenever J i is pi-blocked. Thus, J i incurs pi-blocking for at most</p><formula xml:id="formula_20">b i q k=1 N i,k • (n -1) max 1≤x≤n {L x,k } across all requests. Since max 1≤x≤n {L x,k } and q k=1 N i,k are considered constant (see Sec. 2), this implies that max Ti∈τ {b i } = O(n) and thus n i=1 b i = O(n 2 ).</formula><p>This implies that the bound established in Lemma 10 is tight under global scheduling. Further note that, even though the FMLP was originally proposed for G-EDF, the above analysis does not depend on G-EDF and can be applied to other global JLSP schedulers as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Optimal Locking under Partitioned Scheduling</head><p>As discussed in Sec. 3.3, the lack of (in an analytical sense) effective priority inheritance under partitioning complicates matters. In particular, in the case of the partitioned FMLP, it is easy to show a (likely pessimistic) bound of O(n 2 ) maximum pi-blocking, but the FMLP's reliance on priority boosting makes it challenging to derive a tighter bound.</p><p>However, it turns out that a much simpler protocol suffices to establish tightness of the Ω(n) lower bound. Consider the following simple, partitioned FIFO locking protocol (SPFP): there is only one global FIFO queue FQ G that is used to serialize requests to all requests, and the job at the head of the queue is priority-boosted. Theorem 6. S-aware pi-blocking under the SPFP is asymptotically optimal. Proof. Analogously to Thm. 5: each request is preceded by at most n -1 requests, and the job at the head of FQ G is guaranteed to be scheduled since it is the only priority-boosted job. Thus, J i incurs pi-blocking under the SPFP for at most</p><formula xml:id="formula_21">b i max 1≤x≤n {L x,k | 1 ≤ k ≤ q } • (n -1) • q k=1 N i,k .</formula><p>The theorem follows.</p><p>The "trick" behind the SPFP is to avoid pessimism that arises when multiple jobs sharing a processor are concurrently priority-boosted. Obviously, serializing all requests is of only limited practical value. However, the asymptotic optimality of the SPFP does establish that Ω(n) s-aware piblocking is a tight lower bound in the general case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Lower Bound on EDF and Static-Priority Queuing</head><p>Intuitively, one might reasonably expect queuing disciplines that order lock requests on a static-priority or EDF basis to cause no more blocking than simple FIFO queuing. However, asymptotically speaking, this is not the case.</p><formula xml:id="formula_22">5 1 0 1 5 0 J 1 J 2 J 3 J 4 J 5 J 6</formula><p>Consider the following task set.</p><p>Def. 4. Let τ prio (n), where n ≥ 2m, denote a set of n tasks sharing one resource 1 such that, for each</p><formula xml:id="formula_23">T i , e i = 1, N i,1 = 1, L i,1 = 1, and p i = m if i &lt; m, p i = mn/2 if m ≤ i ≤ 2m -2,</formula><p>and p i = mn otherwise.</p><p>Lemma 11. There exists an arrival sequence for τ prio (n) such that max Ti∈τ {b i } = Ω(mn) (under s-aware analysis) when ordering requests by either non-decreasing job deadline or static priority under any JLSP scheduler.</p><p>Proof. Without loss of generality, assume that n is an integer multiple of 2m. We first consider partitioned scheduling and assume that τ prio (n) is partitioned such that P i = i if i &lt; m and P i = m otherwise. Consider the synchronous, periodic arrival sequence, i.e., each J i,j is released at a i,j = (j -1) • p i , and issues one request R i,j , where R i,j = 1. The resulting schedule for m = 3 and n = 6 is illustrated in Fig. <ref type="figure" target="#fig_7">7</ref>.</p><p>Since the task set is serialized by 1 , the order of job completions is fully determined by the queuing discipline under any work-conserving scheduler. Recall from Sec. 2 that tasks are indexed in order of decreasing priority, and that deadline ties are broken in favor of jobs of higher-indexed tasks. Thus, if requests are either EDFor static-priority-ordered, then, by construction, J n,1 's request is the last one to be satisfied at time n • m -1. By Def. 2, J n,1 incurs pi-blocking whenever no higher-priority job is scheduled on P m during [0, n • m -1). By construction, P m is used for only n -1 time units during [0, n • m -1). Thus, J n,1 is pi-blocked for at least b n ≥ n • m -1 -(n -1) = (m -1) • n = Ω(mn) time units. Since at most one job is scheduled at any time, pi-blocking does not decrease under global scheduling.</p><p>Total pi-blocking is similarly non-optimal in such cases.  <ref type="bibr" target="#b13">[14]</ref> priority Ω(n) Ω(mn) PPCP <ref type="bibr" target="#b13">[14]</ref> priority</p><formula xml:id="formula_24">Ω(n) Ω(mn) OMLP hybrid Θ(m) Ω(mn)</formula><p>partitioned DPCP <ref type="bibr" target="#b21">[22]</ref> priority Ω(n) Ω(mn) MPCP <ref type="bibr" target="#b19">[20]</ref> priority  Note that Lemmas 11 and 12 depend on max{p i }/ min{p i } = mn/m not being constant. If max{p i }/ min{p i } is constrained to be constant, then any (reasonable) protocol likely ensures O(n) maximum pi-blocking if shared resources are not continuously in use.</p><formula xml:id="formula_25">Ω(n) Ω(mn) FMLP [8] FIFO O(n 2 ) O(n 2 ) OMLP hybrid Θ(m) Ω(mn) SPFP FIFO Θ(n) Θ(n)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>We have presented precise definitions of pi-blocking for soblivious and s-aware multiprocessor schedulability analysis. Using these definitions, we have established a number of bounds on pi-blocking that are applicable to any JLFP global or partitioned scheduling algorithm. For the case of soblivious analysis, we have shown that Ω(m) worst-case piblocking is fundamental. We have also presented global and partitioned variants of a new asymptotically optimal locking protocol, the OMLP. Worst-case s-oblivious pi-blocking under the global (partitioned) OMLP is O(m) under any global (partitioned) JLFP scheduler. The OMLP is not just of theoretical interest. For example, the only prior proposed locking protocol for G-EDF is the FMLP, and the OMLP has substantially better pi-blocking bounds than the FMLP.</p><p>For the case of s-aware analysis, we have shown that O(m) worst-case pi-blocking is not possible by presenting a general Ω(n) lower bound. We have also shown that the global FMLP meets this bound and thus is asymptotically optimal. In the partitioned case, we have presented a simple FIFO locking protocol that also meets this bound. This algorithm achieves O(n) worst-case pi-blocking by serializing requests of all resources. While such an approach may be of questionable practical utility, its existence nonetheless shows that our lower bound is tight. We have further shown that no locking protocol that orders lock requests on a static-priority or EDF basis can be optimal by establishing an Ω(mn) lower bound that is applicable to any such protocol. Our results are summarized in Table <ref type="table" target="#tab_2">1</ref>.</p><p>It is important to note that asymptotic optimality as a function of m or n does not imply that a locking protocol is the best to use in all circumstances. Obviously, asymptotic claims ignore constant factors. Additionally, a non-optimal algorithm could yield lower pi-blocking delays for some task systems (just like the non-optimal Quicksort algorithm is often faster than optimal sorting algorithms).</p><p>In future work, it would be interesting to empirically investigate such practical tradeoffs with schedulability and implementation studies. Likewise, as shown in Table <ref type="table" target="#tab_2">1</ref>, asymptotic upper bounds have yet to be derived for many existing protocols-finding bounds that are asymptotically tight may be non-trivial in some cases. With regard to locking optimality, we would like to more carefully examine the effects of certain parameters (like request lengths and the number of requests per job) that we have assumed to be constant. Similarly, bounds in the case where the maximum number of tasks sharing a resource is constant (e.g., if any resource is accessed by at most three tasks) are of practical interest. Also, nesting with fine-grained locking (i.e., not using group locks) and reader/writer locks warrant further attention. Finally, we note that current hard real-time G-EDF analysis is s-oblivious. S-aware analysis may enable resource sharing to be treated less pessimistically.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Improved Bounds</head><p>As noted in Sec. 3.2.2, the bound given in Lemma 4 (and, respectively, in Lemma 7 under partitioning) overestimate worst-case pi-blocking incurred when requesting resources that are not heavily contended: if requests are infrequent and mostly short, then assuming that that all queues are "saturated" with the longest-possible request is needlessly pessimistic. This is best illustrated with an example. Ex. 1. Consider three tasks T 1 , T 2 , and T 3 with parameters as indicated in these tasks are scheduled on m = 16 processors (together with a number of other tasks that do not access 1 ). Under the global OMLP, by Lemma 4, a job J 3 is pi-blocked for at most b</p><formula xml:id="formula_26">3 = N 3,1 • 2 • (m -1) • max{L 1,1 , L 2,1 , L 3,1 } = 1 • 2 • 15 • 3 = 90 time units.</formula><p>Given that only jobs of T 2 issue requests of length 3, this clearly overestimates actual worst-case pi-blocking. Based on this coarse-grained bound, T 3 would be (wrongly) deemed unschedulable since b 3 &gt; p 3 .</p><p>In this appendix, we derive less-pessimistic, albeit notationally more tedious, bounds for s-oblivious pi-blocking under the global and partitioned OMLP that better reflect task periods and per-task maximum request lengths.</p><p>A.1 S-Oblivious Pi-Blocking under the Global OMLP Lemma 4 can be improved by deriving a better approximation of the set of requests that can delay a job in the worst case. Intuitively, the idea is to "count" how many times each task T x can request a shared resource while J i is pending, and to charge each L x,k individually based on these counts. Ex. 2. Continuing Ex. 1, we derive the "worst-case interference" for J 3 , which we then use to bound maximum piblocking. Because p 3 &lt; p 2 &lt; p 1 , J 3 can overlap (i.e., be pending concurrently) with at most two jobs of T 1 and T 2 each. Each J 1 can request 1 twice, and each J 2 can request 1 once. Thus, at most six requests (4 × T 1 , 2 × T 2 ) can interfere with J 3 in the worst case. Since L 1,1 = 1, this method yields a much tighter upper bound of b</p><formula xml:id="formula_27">3 = 4•L 1,1 +2•L 2,1 = 4 • 1 + 2 • 3 = 10.</formula><p>To formalize this approach, we require a safe approximation of the set of possibly-interfering requests issued by jobs of each competing task T x . As illustrated in Ex. 2, this requires a bound on the maximum number of jobs of T x that may execute (and thus issue requests) concurrently with J i .</p><p>Lemma 13 (from <ref type="bibr" target="#b9">[10]</ref>). At most (t + r x )/p x jobs of a task T x can execute during any interval of length t.</p><p>By the definition of N x,k , Lemma 13 implies that jobs of T x issue at most (t + r x )/p x • N x,k requests for k over any interval of length t. This yields the following definition. Def. 5. The worst-case task interference generated by jobs of T x over any interval of length t is the set of requests</p><formula xml:id="formula_28">tif (T x , k , t) {R x,y | 1 ≤ y ≤ N x,j • (t + r x )/p x },</formula><p>where R x,y = L x,k for each R x,y . Def. 5 characterizes the worst-case demand for k by jobs of T x , i.e., it is a safe upper bound of both the number of requests issued by T x as well as their respective lengths.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Ex. 3. Suppose r</head><formula xml:id="formula_29">i = p i for each T i (see Sec. A.3 below). Continuing Ex. 2, let t = p 3 = 20. Then tif (T 1 , 1 , 20) = {R 1,1 , R 1,2 , R 1,3 , R 1,4 }, where R 1,1 = R 1,2 = R 1,3 = R 1,4 = 1, since (20 + p 1 )/p 1 = 2 and N 1,1 = 2. Similarly, tif (T 2 , 1 , 20) = {R 2,1 , R 2,2 }, where R 2,1 = R 2,2 = 3.</formula><p>Task interference bounds contention due to a single task. We similarly define interference from a subset of τ . We formalize this bound next on a per-resource basis. We provide a per-resource bound in anticipation of a later refinement for special cases (Lemma 15 below). Proof. Follows from Lemma 3 and Def. 6: total pi-blocking does not exceed the length of the N i,k • 2 • (m -1) longest interfering requests (if that many exist, hence α k ).</p><p>Deriving the worst-case request interference avoids overcounting long-but-infrequent requests. However, if a resource is shared by at most m tasks, then the above bound fails to fully reflect the strict FIFO-ordering of jobs in FQ k . Proof. If A k ≤ m, then J i never enters PQ k . Due to the FIFO ordering in FQ k , J i is pi-blocked by at most one request from A k -1 other tasks each time that it requests k , for a total of at most N i,k requests per task. However, if jobs of a competing task T x issue fewer than N i,k requests, then not each request of J i is blocked by a request of T x . Hence, J i is pi-blocked for a total duration of at most min(N i,k , C x,k ) • L x,k for each T x (note that C x,k = 0 if N x,k = 0).</p><p>Thus, J i is pi-blocked in total for at most b i = q k=1 b i,q , with each b i,q defined as given in Lemma 15 if A k ≤ m, and defined as given in Lemma 14 otherwise.</p><p>A.2 S-Oblivious Pi-Blocking under the Part. OMLP</p><p>The same approach, namely to derive a more accurate approximation of the worst-case request interference, can be easily transferred to the partitioned OMLP. In particular, Lemma 7 overestimates the contention arising on each remote processor if resources are requested only infrequently. Based on Def. 6, we can state the following more-accurate bound that takes worst-case interference into account. Proof. Each time that J i requests a resource k , J i must wait for the completion of at most one request originating from each remote processor. Hence, it is sufficient to consider the N i,k longest requests for k originating from each remote processor (if that many exist, hence α k,o ).</p><p>It is further possible to improve Lemmas 6 and 8 by considering only resources accessed by lower-priority jobs. This, however, requires scheduling-algorithm-specific analysis. Note that Lemma 16 does not depend on the employed scheduling algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.3 Computing b i</head><p>Both tif (T i , k , t) and xif (S, k , r i ) (Defs. 5 and 6) depend on each T i 's worst-case response time r i , which in turn depends on the worst-case acquisition delay and thus worstcase interference. This circular dependency can be resolved either by conducting a fixed-point search for an upper bound on r i (a similar approach is used to analyze the MPCP <ref type="bibr" target="#b16">[17]</ref>), or by simply substituting p i for r i , which is a safe approximation if the resulting τ is schedulable. The former requires repeated response time approximations (e.g., see <ref type="bibr" target="#b6">[7]</ref>), whereas the latter can be computed immediately, albeit at the cost of increased pessimism.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Example of s-oblivious and s-aware pi-blocking of three jobs J1, J2, and J3, sharing one resource on two G-EDF-scheduled processors. J3 suffers acquisition delay during<ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b2">3)</ref>, and since no higher-priority jobs exist it is pi-blocked under either definition. J1, suspended during<ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b3">4)</ref>, suffers pi-blocking under either definition during<ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4)</ref> since it is among the m highest-priority pending jobs, but only s-aware pi-blocking during [2, 3) since J3 is pending but not ready then. (The notation in this figure is used in subsequent figures as well.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Def. 3 .Lemma 1 .</head><label>31</label><figDesc>Let τ seq (n) denote a task set of n identical tasks that share one resource 1 such that e i = 1, p i = 2n, N i,1 = 1, and L i,1 = 1 for each T i , where n ≥ m ≥ 2. There exists an arrival sequence for τ seq (n) such that, under s-oblivious analysis, max Ti∈τ {b i } = Ω(m) and n i=1 b i = Ω(nm) under any locking protocol and JLSP scheduler.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: G-EDF schedule of τ seq (n) for n = 6 and m = 3, and thus g ∈ {0, 1}. The first group of jobs (J1,1, J2,1, J3,1) is released at time 0; the second group (J4,1, J5,1, J6,1) is released at time 3. Each group incurs 0 + 1 + 2 = P m-1 i=0 i total pi-blocking.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Two examples of n = 4 tasks sharing one resource 1 on m = 2 G-EDF-scheduled processors. Each job requires 1 for the entirety of its computation. (a) If conflicting requests are satisfied in FIFO order, then the job with the earliest deadline (J1) may incur Ω(n) pi-blocking if its request is issued just after all other requests. (b) If conflicting requests are satisfied in order of job priority, then a job's request may be deferred repeatedly even though it is among the m highest-priority jobs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Theorem 3 .</head><label>3</label><figDesc>S-oblivious pi-blocking under the partitioned OMLP is asymptotically optimal. Proof. Recall from Sec. 2 that k N i,k and each L i,k are assumed constant. It follows that B prio i = O(1), B fifo i = O(m), and B trans i = O(m), and hence max Ti∈τ {b i } = O(m) and n i=1 b i = O(nm).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :-r par 4 = 4 - 2 = 2 .-r par 3 = 3 -</head><label>6442233</label><figDesc>Figure 6: Illustration of (a) S seq and (b) S par for n = 4 and m = 2 under P-EDF. Note that bi ≥ r seq i r par i . For example, J4 incurs pi-blocking during [0, 2) in S seq ; consequently b4 ≥ r seq 4r par 4 = 4 -2 = 2. Similarly, b3 ≥ r seq 3r par 3 = 3 -1 = 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>irrespective of how requests are ordered or jobs prioritized.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Illustration of τ prio (n) for n = 6 and m = 3. The depicted schedule arises under any partitioned JLSP scheduler if requests are ordered either by deadline or by static priority (with task indexed in order of decreasing priority). Also, an equivalent schedule arises under global scheduling since only one job is scheduled at any time. J6 incurs pi-blocking for (m -1) • n = 12 time units under partitioning and for mn -1 = 17 time units under global scheduling (throughout [0, 17) only one job is scheduled).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Lemma 12 .</head><label>12</label><figDesc>There exist task systems withn i=1 b i = Ω(m(nm) 2 + m 2 ) (under s-aware analysis) when ordering requests by either non-decreasing job deadline or static priority under any JLSP scheduler.Proof. Omitted due to space constraints; can be shown analogously to Lemma 10 by considering a modified version ofτ prio (n) in which p i = m • (nm + 1) if i ≥ m.The -m and m 2 terms arise because T 1 ,. . .,T m-1 incur only little piblocking.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Def. 6 .</head><label>6</label><figDesc>For a set of tasks S, we let xif (S, k , t) Tx∈S tif (T x , k , t) denote the worst-case request interference, and, for each v, 1 ≤ v ≤ |xif (S, k , t)|, let xif v (S, k , t) denote the vth longest request in xif (S, k , t) (with ties broken arbitrarily). Ex. 4. Continuing Ex. 3, let S = {T 1 , T 2 } and t = 20. Then xif (S, 1, 20) = {R 2,1 , R 2,2 , R 1,1 , R 1,2 , R 1,3 , R 1,4 } in order of non-increasing length, i.e., xif 1 (S, 1 , 20) = 3, xif 2 (S,1 , 20) = 3, xif 3 (S, 1 , 20) = 1, etc. Thus, the bound that was manually derived in Ex. 2 can be expressed as b 3 = 6 v=1 xif v (S, 1 , p 3 ) = 10.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Def. 7 .</head><label>7</label><figDesc>Let b i,k denote a bound on the total pi-blocking incurred by J i due to requests for resource k . Under the global OMLP, b i = q k=1 b i,k . Combining the worst-case interference (Def. 6) with Lemma 3 yields the following more accurate (but asymptotically unchanged) bound. Lemma 14. Let S = τ \ {T i }, and let α k = min(N i,k • 2 • (m -1), |xif (S, k , r i )|). J i is pi-blocked due to requests for k for at most b i,k α k v=1 xif v (S, k , r i ) .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Ex. 5 .</head><label>5</label><figDesc>Consider the task set from Ex. 1. Since only two other tasks access 1 and m = 16, J 3 is guaranteed to immediately enter FQ 1 when it requests 1 . Thus, J 3 has to await the completion of at most one request of T 1 and one request of T 2 since jobs are FIFO-ordered in FQ 1 and at most one job per task is pending at any time. This implies a tighter bound of b3 = N 3,1 • L 1,1 + N 3,1 • L 2,1 = 1 • 1 + 1 • 3 = 4.This improvement is formalized next.Def. 8. Let A k denote the number of tasks accessing k , i.e.,A k |{T i | 1 ≤ i ≤ n ∧ N i,k &gt; 0 }|. Lemma 15. Let C x,k = |tif (T x , k , r i )|denote the maximum number of times that jobs of T x request k while J i is pending. If A k ≤ m, then J i is pi-blocked due to requests for k for at most b i,k n x=1;x =i min(N i,k , C x,k ) • L x,k .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Lemma 16 .</head><label>16</label><figDesc>While holding CT Pi , J i is pi-blocked for at most xif v (part(o), k , r i ) , where α k,o = min(N i,k , |xif (part(o), k , r i )|).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Figure 4: Example showing the global OMLP under G-EDF for six tasks sharing one resource on m = 2 processors. J6 issues a request at t0 = 3, enters FQ1 at t1 = 7, and holds 1 at t2 = 8.Note that J1 and J2 enter FQ1 immediately for lack of contention, and thus J2's request precedes J4's request in spite of J4 having an earlier deadline. In contrast, J4 and J5 arrive and enqueue after J6, but enter FQ1 before J6 due to their earlier deadlines and Rule G3.</figDesc><table><row><cell>enters PQ</cell><cell>t 0</cell><cell>t 1</cell><cell>t 2</cell></row><row><cell>J 6</cell><cell></cell><cell></cell><cell></cell></row><row><cell>J 5</cell><cell></cell><cell></cell><cell></cell></row><row><cell>J 4</cell><cell></cell><cell></cell><cell></cell></row><row><cell>J 3</cell><cell></cell><cell></cell><cell></cell></row><row><cell>J 2</cell><cell></cell><cell></cell><cell>enters FQ</cell></row><row><cell>J 1</cell><cell></cell><cell></cell><cell></cell></row><row><cell>0</cell><cell>5</cell><cell></cell><cell>1 0</cell><cell>1 5</cell></row></table><note><p>Similarly, J6 acquires k before J3, despite J3's earlier request.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 :</head><label>1</label><figDesc>Summary of results. Only the OMLP is optimal in the soblivious case because both FIFO-and priority-ordered queues give rise to Ω(n) s-oblivious pi-blocking (see Sec. 3.2). In the s-aware case, all protocols employing priority queues are subject to a lower bound of Ω(mn) (Lemma 11), and similar reasoning also applies to the OMLP. Recall from Sec. 2 that an upper bound on s-aware piblocking bounds s-oblivious pi-blocking as well. A comparison of each protocol's exact (i.e., non-asymptotic) bounds requires empirical experiments since such bounds usually cannot be expressed as closed-form expressions and is thus beyond the scope of this paper.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2</head><label>2</label><figDesc>sharing one resource 1 . Suppose that</figDesc><table><row><cell cols="2">Task e i</cell><cell>p i</cell><cell>N i,1</cell><cell>L i,1</cell></row><row><cell>T 1</cell><cell>9</cell><cell>50</cell><cell>2</cell><cell>1</cell></row><row><cell>T 2</cell><cell>6</cell><cell>30</cell><cell>1</cell><cell>3</cell></row><row><cell>T 3</cell><cell>3</cell><cell>20</cell><cell>1</cell><cell>1</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 2 :</head><label>2</label><figDesc>Example tasks set. Three tasks T1, T2, T3 sharing one resource 1.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The presented results do not depend on the choice of deadline constraint. Implicit deadlines were chosen to avoid irrelevant detail.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p><ref type="bibr" target="#b1">2</ref> We assume that J i must be scheduled to complete its request. This is required for shared data objects, but may be pessimistic for I/O devices. The latter can be accounted for at the expense of more verbose notation.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>Easwaran and Andersson [14]  provide a definition of "job blocking" that conceptually resembles our notion of s-aware pi-blocking. However, their definition specifically applies to global static-priority scheduling and does not encompass all of the effects that we consider to be "blocking" (e.g., such as priority boosting).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_3"><p>This is a somewhat simplified-but faithful-description of the suspension-based "long" FMLP; see Block et al.<ref type="bibr" target="#b7">[8]</ref> for details. Our discussion does not apply to the spin-based "short" FMLP.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Stack-based scheduling for realtime processes</title>
		<author>
			<persName><forename type="first">T</forename><surname>Baker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Real-Time Systems</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="67" to="99" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Multiprocessor EDF and deadline monotonic schedulability analysis</title>
		<author>
			<persName><forename type="first">T</forename><surname>Baker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 24th IEEE Real-Time Systems Symposium</title>
		<meeting>of the 24th IEEE Real-Time Systems Symposium</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="120" to="129" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Techniques for multiprocessor global schedulability analysis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Baruah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 28th IEEE Real-Time Systems Symposium</title>
		<meeting>of the 28th IEEE Real-Time Systems Symposium</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="119" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Improved multiprocessor global schedulability analysis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Baruah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Bonifaci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Marchetti-Spaccamela</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Stiller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Real-Time Systems</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="24" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Response-time analysis for globally scheduled symmetric multiprocessor platforms</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bertogna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Cirinei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 28th IEEE Real-Time Systems Symposium</title>
		<meeting>of the 28th IEEE Real-Time Systems Symposium</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="149" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Improved schedulability analysis of EDF on multiprocessor platforms</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bertogna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Cirinei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lipari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 17th Euromicro Conference on Real-Time Systems</title>
		<meeting>of the 17th Euromicro Conference on Real-Time Systems</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="209" to="218" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Schedulability analysis of global scheduling algorithms on multiprocessor platforms</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bertogna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Cirinei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lipari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Parallel and Distributed Systems</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="553" to="566" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A flexible real-time locking protocol for multiprocessors</title>
		<author>
			<persName><forename type="first">A</forename><surname>Block</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Leontyev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Brandenburg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 13th IEEE Conference on Embedded and Real-Time Computing Systems and Applications</title>
		<meeting>of the 13th IEEE Conference on Embedded and Real-Time Computing Systems and Applications</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="47" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">An implementation of the PCP, SRP, D-PCP, M-PCP, and FMLP real-time synchronization protocols in LITMUS RT</title>
		<author>
			<persName><forename type="first">B</forename><surname>Brandenburg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 14th IEEE Real-Time and Embedded Technology and Applications Symposium</title>
		<meeting>of the 14th IEEE Real-Time and Embedded Technology and Applications Symposium</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="185" to="194" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Spin-based reader-writer synchronization for multiprocessor real-time systems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Brandenburg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Real-Time Systems</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="25" to="87" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A categorization of real-time multiprocessor scheduling problems and algorithms</title>
		<author>
			<persName><forename type="first">J</forename><surname>Carpenter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Funk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Holman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Srinivasan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Baruah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Scheduling: Algorithms, Models, and Performance Analysis</title>
		<imprint>
			<publisher>Chapman and Hall/CRC</publisher>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Multiprocessor priority ceiling based protocols</title>
		<author>
			<persName><forename type="first">C</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tripathi</surname></persName>
		</author>
		<idno>CS-TR-3252</idno>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
		<respStmt>
			<orgName>Univ. of Maryland</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Efficient synchronization under global EDF scheduling on multiprocessors</title>
		<author>
			<persName><forename type="first">U</forename><surname>Devi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Leontyev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 18th Euromicro Conference on Real-Time Systems</title>
		<meeting>of the 18th Euromicro Conference on Real-Time Systems</meeting>
		<imprint>
			<date type="published" when="2006-07">July 2006</date>
			<biblScope unit="page" from="75" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Resource sharing in global fixedpriority preemptive multiprocessor scheduling</title>
		<author>
			<persName><forename type="first">A</forename><surname>Easwaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Andersson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 30th IEEE Real-Time Systems Symposium</title>
		<meeting>of the 30th IEEE Real-Time Systems Symposium</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="377" to="386" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A comparison of MPCP and MSRP when sharing resources in the Janus multiple processor on a chip platform</title>
		<author>
			<persName><forename type="first">P</forename><surname>Gai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Di Natale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lipari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ferrari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gabellini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Marceca</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 9th IEEE Real-Time And Embedded Technology Application Symposium</title>
		<meeting>of the 9th IEEE Real-Time And Embedded Technology Application Symposium</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="189" to="198" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Priority-driven scheduling of periodic task systems on multiprocessors</title>
		<author>
			<persName><forename type="first">J</forename><surname>Goossens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Funk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Baruah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Real-Time Systems</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2-3</biblScope>
			<biblScope unit="page" from="187" to="205" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Coordinated task scheduling, allocation and synchronization on multiprocessors</title>
		<author>
			<persName><forename type="first">K</forename><surname>Lakshmanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Niz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rajkumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 30th IEEE Real-Time Systems Symposium</title>
		<meeting>of the 30th IEEE Real-Time Systems Symposium</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="469" to="478" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Scheduling algorithms for multiprogramming in a hard real-time environment</title>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Layland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="46" to="61" />
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Utilization bounds for EDF scheduling on real-time multiprocessor systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Lopez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Diaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Garcia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Real-Time Systems</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="39" to="68" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Real-time synchronization protocols for shared memory multiprocessors</title>
		<author>
			<persName><forename type="first">R</forename><surname>Rajkumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 10th International Conference on Distributed Computing Systems</title>
		<meeting>of the 10th International Conference on Distributed Computing Systems</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="116" to="123" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Synchronization In Real-Time Systems -A Priority Inheritance Approach</title>
		<author>
			<persName><forename type="first">R</forename><surname>Rajkumar</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
			<publisher>Kluwer Academic Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Real-time synchronization protocols for multiprocessors</title>
		<author>
			<persName><forename type="first">R</forename><surname>Rajkumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Sha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lehoczky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 9th Real-Time Systems Symposium</title>
		<meeting>of the 9th Real-Time Systems Symposium</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="259" to="269" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Priority inheritance protocols: an approach to real-time synchronization</title>
		<author>
			<persName><forename type="first">L</forename><surname>Sha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rajkumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lehoczky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Computers</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1175" to="1185" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">The deferrable server algorithm for enhanced aperiodic responsiveness in hard real-time environments</title>
		<author>
			<persName><forename type="first">J</forename><surname>Strosnider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lehoczky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Sha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Computers</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="73" to="91" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
