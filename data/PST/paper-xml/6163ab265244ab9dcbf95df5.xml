<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">AS-Level BGP Community Usage Classification</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2021-10-07">7 Oct 2021</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Thomas</forename><surname>Krenc</surname></persName>
							<email>tkrenc@nps.edu</email>
						</author>
						<author>
							<persName><forename type="first">Robert</forename><surname>Beverly</surname></persName>
							<email>rbeverly@nps.edu</email>
						</author>
						<title level="a" type="main">AS-Level BGP Community Usage Classification</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2021-10-07">7 Oct 2021</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/3487552.3487865</idno>
					<idno type="arXiv">arXiv:2110.03816v1[cs.NI]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2023-01-01T13:33+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Border Gateway Protocol (BGP), BGP communities</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>BGP communities are a popular mechanism used by network operators for traffic engineering, blackholing, and to realize network policies and business strategies. In recent years, many research works have contributed to our understanding of how BGP communities are utilized, as well as how they can reveal secondary insights into real-world events such as outages and security attacks. However, one fundamental question remains unanswered: "Which ASes tag announcements with BGP communities and which remove communities in the announcements they receive?" A grounded understanding of where BGP communities are added or removed can help better model and predict BGP-based actions in the Internet and characterize the strategies of network operators.</p><p>In this paper we develop, validate, and share data from the first algorithm that can infer BGP community tagging and cleaning behavior at the AS-level. The algorithm is entirely passive and uses BGP update messages and snapshots, e.g. from public route collectors, as input. First, we quantify the correctness and accuracy of the algorithm in controlled experiments with simulated topologies. To validate in the wild, we announce prefixes with communities and confirm that more than 90% of the ASes that we classify behave as our algorithm predicts. Finally, we apply the algorithm to data from four sets of BGP collectors: RIPE, RouteViews, Isolario, and PCH. Tuned conservatively, our algorithm ascribes community tagging and cleaning behaviors to more than 13k ASes, the majority of which are large networks and providers. We make our algorithm and inferences available as a public resource to the BGP research community.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CCS CONCEPTS</head><p>• Networks → Network protocols; Network management.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Border Gate Protocol (BGP) communities <ref type="bibr" target="#b15">[16]</ref>, an optional transitive attribute attached to routing announcements, are widely used to communicate information and actions within and between Autonomous Systems (ASes). The flexibility to define communities, tag routes with communities, and automatically take a prescribed action on aggregates of tagged routes, has enabled a variety of common uses including traffic engineering, remote triggered blackholing (RTBH) <ref type="bibr" target="#b3">[4]</ref>, and other custom network policies and business strategies <ref type="bibr" target="#b6">[7]</ref>.</p><p>Community values are simply byte strings, and there is no globally defined semantic to these values beyond a handful with special meaning. ASes define particular community values either for internal network use, e.g. to tag the geographic location where prefixes are received, or for signaling to peers, e.g. to request AS path prepending. While it is a general convention that the high-order bytes of the community are set to the AS Number (ASN) of the entity defining the community meaning, the low-order bytes are set according to each network's policy. And while some networks publicly publish their community conventions, many networks do not. Thus, for both operational and research purposes, it is often difficult to understand the intent of communities that are seen attached to routes, for instance at route collectors.</p><p>Even more fundamentally, the macro-level community usage behavior of different ASes is unknown. As BGP announcements propagate, individual ASes may arbitrarily ignore, add, modify, or remove communities. In this paper, we develop, validate, and employ a passive algorithm to infer per-AS community usage. At its core, our algorithm implements a system of constraints that groups ASes according to those that do or do not tag announcements with communities, namely, tagger and silent ASes, as well those that remove or ignore communities in updates, namely, cleaner and forward ASes. When our algorithm has conflicting information, for instance due to complex per-peer selective behavior, it labels the AS as undecided, and if it cannot make any inference, none.</p><p>We first characterize the coverage and accuracy of our algorithm, along with the sensitivity of its parameters, using simulations of large AS topologies. We then validate a subset of our inferences by using the PEERING testbed <ref type="bibr" target="#b22">[23]</ref> to announce a prefix under our control into the BGP. Using data from three large route collectors, we show that our algorithm correctly infers the community usage behavior of 90% of the ASes we predict, for those ASes in observed paths.</p><p>Understanding per-AS community usage behavior is important to not only measurement research that utilizes communities, but also in uncovering important properties of operational networks in the wild. For instance, work on measuring community propagation and security <ref type="bibr" target="#b25">[26]</ref>, community-driven routing load and unnecessary updates <ref type="bibr" target="#b14">[15]</ref>, community-based outage detection <ref type="bibr" target="#b7">[8]</ref> and blackholing <ref type="bibr" target="#b10">[11]</ref>, and hijack detection schemes <ref type="bibr" target="#b23">[24]</ref> can all benefit from a grounded per-AS understanding of BGP community usage behavior. Thus we see our work filling an important gap for the measurement and network research community, akin to AS relationship inference <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b8">9]</ref>. Our contributions include:</p><p>• A novel passive algorithm to infer per-AS BGP community usage behavior.</p><p>• Analysis of simulated and real-world experiments demonstrating the coverage, accuracy, and sensitivity of our algorithm. • Application of our algorithm to data from four major route collectors. • We make our algorithm and database of community usage behavior publicly available to the network measurement community <ref type="bibr" target="#b4">[5]</ref>.</p><p>The remainder of this paper is organized as follows: In Section 2 we introduce related work in this area and provide background information on BGP and BGP communities in Section 3. In Section 4 we introduce the data sets that we use throughout this work and the sanitation steps involved. In Section 5, we present our mental model and derive constraints to implement in to the inference algorithm. In Section 6 we evaluate its performance using generated ground truth data sets. In Section 7 we present our classification results using publicly available routing information. We conclude in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>As the Internet's inter-domain routing glue, the BGP <ref type="bibr" target="#b18">[19]</ref> is critical protocol in the operation of the network. It is therefore natural that the behavior, evolution, stability, and security of BGP have been extensively analyzed, e.g. <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b26">27]</ref> to name a few studies. Similarly, the adoption of BGP communities <ref type="bibr" target="#b15">[16]</ref> has driven research into the ways in which communities are used, as well as how they can reveal important properties and events in the Internet.</p><p>Benoit et al. provided the first taxonomy of BGP communities <ref type="bibr" target="#b6">[7]</ref>. Since then, community usage has continued to increase. Specifically, among more than 78,000 unique regular communities observed in the recent routing data we analyze, there are more than 6,300 distinct high-order two-byte values -indicative of the wide variety of use and breadth of adoption. Giostas et al. provided one of the first examples of using communities as a measurement tool, by leveraging observed activity of blackhole communities to estimate the prevalence, frequency, and duration of denial-of-service attacks <ref type="bibr" target="#b10">[11]</ref>. Subsequent work used communities as a proxy to detect peering infrastructure outages <ref type="bibr" target="#b7">[8]</ref>.</p><p>Further motivating our work, Streibelt et al. explored the potential attack vectors using BGP communities, and their feasibility due to a general lack of community filtering <ref type="bibr" target="#b25">[26]</ref>. Streibelt's work showed that the lack of common understanding in community values, combined with their transitive property, leads to communities propagating further than intended. As a result, malicious actors in the BGP system can potentially blackhole or re-route traffic.</p><p>Moreover, while Streibelt et al. explore the extent to which communities propagate, they do not attempt to determine whether individual ASes are taggers (or silent). Similarly, Streibelt examines filtering and propagation of communities on a per-edge basis in the AS graph, but do not reconcile conflicting information or make per-AS filtering classifications. Our algorithm holistically takes into account filtering and tagging behaviors and is specifically tuned to make precise inferences. Last, whereas prior work was entirely inferential, we use lab experiments, simulations, and live announcements to validate and understand the limits of our approach.</p><p>Also closely related and motivating our investigation, Krenc et al. explore the BGP update message load and impact due to communities <ref type="bibr" target="#b14">[15]</ref> and permissive propagation. In particular, Krenc's longitudinal study finds a large number of unnecessary updates that could be avoided, benefiting security and performance, with stricter community filtering by providers.</p><p>Our algorithm could thus usefully be combined with these prior efforts to provide a richer understanding of both which ASes are filtering too permissively, as well as which ASes are vulnerable to attack or contributing to unnecessary routing traffic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">BACKGROUND</head><p>The Internet consists of more than 70k Autonomous Systems (AS). An AS comprises one to multiple networks under the same administrative control and it is identified by the AS Number (ASN), a 16-bit integer value. As with many resource identifiers in the Internet, the ASN is a scarce resource which limits the number of public ASes in the Internet to 2 16 . Today, while not all 16-bit ASNs are actively routed, the 16-bit address space is allocated. In order to allow more ASes to participate in the Internet, the ASN address space has been expanded to 32 bits <ref type="bibr" target="#b27">[28]</ref>.</p><p>ASes exchange traffic with each other to allow communication among all Internet users. Thereby, the traffic flow is determined by contractual business relationships between pairs of ASes. In the following, we explain how ASes exchange routing information via the Border Gateway Protocol (BGP) and introduce the BGP community attribute, which allows ASes to signal information across the AS level graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Border Gateway Protocol</head><p>Business relationships are implemented using the Border Gateway Protocol, often based on the size and the traffic volumes of the involved ASes. There exist two primary types of business relationships: peer-to-peer and provider-customer. ASes typically form peer-to-peer relationships when both networks have a similar volume of traffic to exchange. On the other hand, in a customerprovider relationship, one of the ASes is the customer who pays the provider to exchange traffic. This is typically the case, e.g., when a small network requests transit to the global Internet via a larger network.</p><p>Geographically close ASes can interconnect directly at convenient locations and thus potentially circumvent transit costs and keep traffic local. Popular peering locations are Internet Exchange Points (IXP) which provide a shared infrastructure, large hubs in metropolitan areas, for hundreds of ASes to exchange traffic directly, either publicly or privately. In order to facilitate multi-lateral peering, IXPs offer router servers as value-added service <ref type="bibr" target="#b19">[20]</ref>. Also, IXPs offer remote peerings where no physical presence by the AS is required <ref type="bibr" target="#b9">[10]</ref>. Given the multitude of possibilities, two ASes can interconnect, it is little surprising that they can have different business relationships at different locations which further increases the complexity of relationships <ref type="bibr" target="#b8">[9]</ref>.</p><p>In order for an AS to become globally reachable, it sends prefix announcements -encapsulated in BGP update messages -to neighboring ASes, which in turn forward the prefix announcements to their neighbors, and so on. The path a prefix is forwarded along is called the AS path. An AS path 𝑝 is a sequence of 𝑛 ASNs: 𝐴 1 , 𝐴 2 , . . . , 𝐴 𝑛 , while each ASN corresponds to the AS that has forwarded the announcement.</p><p>For purposes of exposition in this paper, for any AS path 𝑝 and AS 𝐴 𝑥 ∈ 𝑝, we distinguish between upstream ASes of 𝐴 𝑥 , i.e., all ASes 𝐴 𝑖 ∈ 𝑝, 𝑖 &lt; 𝑥, and downstream ASes, i.e., all ASes 𝐴 𝑗 ∈ 𝑝, 𝑗 &gt; 𝑥. We refer to 𝐴 1 as the collector peer, or simply peer AS, and 𝐴 𝑛 as the origin AS, while the announcement originates at 𝐴 𝑛 and is forwarded upstream towards 𝐴 1 .</p><p>Our inference algorithm relies on views of BGP routes, in particular AS paths and community attributes, which we obtain via public route collector "looking glasses," (Section 4). Peer ASes forward announcements to route collectors, where the announcements are archived and made publicly accessible to, e.g., network operators to monitor or debug their routing configurations.</p><p>We further distinguish between leaf and transit ASes: Given a set of AS paths</p><formula xml:id="formula_0">𝑃, AS 𝐴 𝑥 is a leaf AS, 𝑖 𝑓 𝑝 ∈ 𝑃 with 𝐴 𝑥 ∈ 𝑝 ∧ 𝑥 ≠ |𝑝 |. Con- versely, 𝐴 𝑥 is a transit AS, 𝑖 𝑓 ∃𝑝 ∈ 𝑃 with 𝐴 𝑥 ∈ 𝑝 ∧𝑥 &lt; |𝑝 |.</formula><p>In other words, a leaf AS only originates prefixes but never forwards other prefixes, because it has no downstream neighbors. transit ASes on the other hand forward announcements from downstream ASes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">BGP communities</head><p>The BGP Communities Attribute <ref type="bibr" target="#b15">[16]</ref> is appended to updates and is used to aggregate routes with common properties. It is a variablelength attribute and can store multiple communities. Also, the community attribute is a transitive attribute which allows communities to be propagated across multiple ASes.</p><p>A regular BGP community is simply a 32-bit integer that is denoted in the form 𝛼:𝛽, where typically 𝛼 represents the AS that defines the value 𝛽. Thus, every AS can define its own values without collisions. Note that this convention applies only to encoding 16-bit ASNs. In order to accommodate 32-bit ASes as well, the BGP Large Communities Attribute has been introduced <ref type="bibr" target="#b12">[13]</ref>. A large community is a 3𝑥32-bit integer denoted in the form 𝛼:𝛽:𝛾, while 𝛼 represents a 32-bit ASN and 𝛽 and 𝛾 are additional 64 bits for the community value. For simplicity, we refer to 𝛼 in both community variants as the upper field in the remainder of this work 1 . In order to determine the community usage of 32-bit ASes, in this work we consider large communities as well. Note that 16-bit ASes can also use large communities.</p><p>Source of communities: Communities can be used to simply convey meta information, e.g., the location where an announcement has been received. In the following example, AS 𝑍 propagates information to the upstream AS 𝑋 : 𝑋 𝑍 : * ← −− − 𝑍 𝑍 : * is also referred to as informational community <ref type="bibr" target="#b24">[25]</ref>. However, communities are not always set by the AS that defines it. For example, communities can instruct other ASes to perform a certain task, e.g., blackholing or path prepending. In the following example, AS 𝑍 instructs AS 𝑋 to perform a specific action on the announced routes, indicated by the value defined by AS 𝑋 : Here, 𝑋 : * is also referred to as action community. We note that the source of communities can be ambiguous: Some ASes define communities (action and informational) using a nonpublic ASN instead of their own in the upper field, e.g., ASes with a 32-bit ASN using regular (32-bit) communities, or they use standardized, well-defined communities <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b15">16]</ref>. Further, while route servers at IXPs utilize communities as well, their ASN typically does not appear in the AS path which further obfuscates the source those communities.</p><p>Because the community attribute is an optional attribute, and BGP provides no mechanisms to validate the source, any AS along the AS path may add, modify or delete communities. Thus, it is not guaranteed that the upper field corresponds to the tagging AS.</p><p>Our visibility into the BGP system is limited by available collectors and the ASes to which they peer. Since we cannot reliably determine the source of a community, we at a minimum require its upper field to be present in the associated AS path. For that purpose, we group communities based on the upper field in relation to the position of the upper field in the AS path. We define the following community source groups:</p><p>• A peer community is a community where the upper field corresponds to the peer ASN in the AS path, i.e., 𝐴 1 . • In a foreign community, the upper field does not equal the peer's ASN, but any other ASN in the AS path, i.e., 𝐴 𝑖 , 𝑖&gt;1. • stray is a community with the upper field representing a public ASN, but the ASN is not in the AS path. • private is a community with the upper field representing a non-public ASN, i.e., private, reserved, not assigned or allocated, etc. Note, a peer community in given AS path 𝑝 1 can appear as a foreign community in AS path 𝑝 2 .</p><p>Our inference algorithm, which we introduce in Section 5, necessarily ignores stray and private communities, since there is no indication as to which AS set those communities without additional knowledge beyond what is available in a BGP announcement. For peer and foreign communities, we assume the community was set by the AS that corresponds to the upper 2 bytes (or upper 4 bytes) of the community. We consider all community types when we verify the correct functioning of our inference method in Section 7.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Community usage</head><p>We define community usage to describe the way ASes generally configure their routers to tag routes with communities or filter them, irrespective of the semantic meaning of community values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Mental Model.</head><p>In order to better understand community usage in the wild, we distinguish ASes according to their individual community usage. To start with, we ask for two basic properties: (1) whether or not an AS adds its own communities to the community attribute of an announcement, and (2) whether or not it cleans existing communities received in the announcement (set by other ASes along the AS path). We refer to the first property as tagging behavior and the second property as forwarding behavior.</p><p>Since any AS along the AS path can arbitrarily modify the community attribute, we narrow down the two properties to reflect consistent behavior, as described in Section 3.2. For the tagging behavior, we define a tagger AS that defines and sets informational communities internally in a consistent and automated fashion and forwards them on external BGP sessions. The counterpart, a silent AS, does not set its own communities or does not forward them on external sessions. In addition, we specify the forwarding behavior to reflect the forwarding of communities set by taggers. Thereby, a forward AS forwards communities on external sessions set by other taggers. Conversely, a cleaner is an AS that does not forward communities on external sessions. In summary:</p><p>• tagging behavior tagger: A tagger AS adds its own communities in a consistent and automated fashion, i.e., informational communities, and forwards them on external links. -silent: A silent AS may use its own communities internally, but it does not forward them on external links. 𝑖 𝑓 𝑖𝑠_cleaner(𝐴) Here, the function returns the community set input from a neighboring AS if 𝐴 is a forward, and an empty community set if 𝐴 is a cleaner AS. Thus, the combined community set output of AS 𝐴 is simply the union of the tagging and forwarding functions: output(𝐴) = tagging(𝐴) ∪ forwarding(𝐴, input(𝐴)) When, for example, the tagging and forwarding functions for AS 𝐴 return an empty set (because 𝐴 is a silent and cleaner AS) then the community set output output(𝐴) will be empty as well.</p><p>In Section 5, we discuss implications of our mental model and introduce an inference method that classifies the community usage behavior of an AS 𝐴, based on its community set output output(𝐴).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.3">Selective tagging.</head><p>Thus far, we assume that ASes employ a uniform community usage policy for all BGP peers. The simplest form of community configuration is to enable or disable tagging and forwarding behaviors identically for all neighbors. Naturally, more complex configurations exist. A large AS with sessions to multiple ASes may perform different actions for different neighbors, e.g. based on the business relationship. For instance, some ASes configure their BGP to only propagate communities (e.g. geolocation communities) to customers or to BGP collectors, but not to peers or providers. Depending on the visibility afforded by different route collectors, our algorithm can discover such selective community usage behavior. However, as our primary goal is to definitively classify those ASes with consistent behavior with high precision, our algorithm labels these instances as undecided.</p><p>In a worst-case scenario, a peer AS is configured to not forward any communities to the collectors but to customers or peers. Our algorithm can potentially misclassify this behavior as silent, which can have a detrimental impact on the inferences of other ASes, as we will discuss in Section 5.4. We explore the performance of our algorithm in the presence of consistent and selective community behaviors in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">DATA SETS</head><p>Our inferences and analyses utilize AS path / community set pairs, which we denote as the tuple (𝑝𝑎𝑡ℎ, 𝑐𝑜𝑚𝑚). We obtain these tuples from public BGP collectors <ref type="foot" target="#foot_0">2</ref> .</p><p>Archived BGP update messages contain only a subset of all ASes and AS paths. There exist a significant number of ASes that do not appear in update data because they do not re-announce their routes frequently. These stable ASes and paths can only be found in RIB snapshots, which are also available from route collectors. Similarly, updates capture the intermediate changes to the routing system which are not available from RIBs. In this work we consider the combined use of archived updates and RIB snapshots.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Download and sanitation</head><p>We download RIBs as well as updates encoded in the Multi-Threaded Routing Toolkit (MRT) format from three major route collector projects: RIPE <ref type="bibr" target="#b20">[21]</ref>, RouteViews <ref type="bibr" target="#b21">[22]</ref>, and Isolario <ref type="bibr" target="#b13">[14]</ref> for the complete day May 19, 2021. While we focus mostly on this date, we also download and analyze other data sets; each time at day granularity. We also obtain PCH <ref type="bibr" target="#b17">[18]</ref> updates, however, PCH does not provide RIBs that include the community attribute. To avoid impairing our inferences due to missing stable ASes from RIBs, we exclude the PCH data set from most of our analyses.</p><p>Before analyzing the routing data, we first filter and transform it so as not to impart unintentional bias into our results. We remove routing information that includes unallocated prefixes or ASNs using current allocation information from the regional registries. We further remove AS_SET s from AS paths which usually occur when routes are aggregated. Also, we prepend the Peer AS Number from every MRT message to the AS path, if the first ASN (𝐴 1 ) does not equal the Peer AS Number <ref type="bibr" target="#b0">[1]</ref>. This is the case for route servers at IXPs which typically do not participate in the routing decision process, but still can modify the community attribute. Finally, we remove path prepending from AS paths by collapsing identical ASNs in succession. In Section 7 we provide inference results for each individual collector project. However, for the majority of our analyses, we consider the aggregated data set of RIPE, RouteViews, and Isolario. In the remainder of this work, we refer to this data set as 𝑑 𝑀𝑎𝑦21 . In Section 5 we use the AS paths from the aggregated data set 𝑑 𝑀𝑎𝑦21 in order to generate ground truth data sets to validate the algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Data overview</head><p>Table <ref type="table" target="#tab_1">1</ref> provides an overview of the available data sets. Each of the three data sets -RIPE, RouteViews, and Isolario-provide us with Billions of entries with around 45% obtained from RIBs in the case of RIPE, 67% RouteViews, and 61% Isolario. Note that the route collector projects employ different update file binnings and snapshot intervals. There are more than 9G entries in the aggregate 𝑑 𝑀𝑎𝑦21 , of which we extract 77M unique (𝑝𝑎𝑡ℎ, 𝑐𝑜𝑚𝑚) pairs.</p><p>Overall, the number of distinct ASes observed in RIPE, Route-Views, and Isolario are comparable: we find approximately 72k ASes which consist of ∼60k leaf ASes and ∼12k transit ASes. Furthermore, there exist around 31k 32-bit ASNs in the data set. An AS can be a leaf AS and 32-bit AS at the same time. Regarding the number of collector peers, PCH has the highest number followed by RIPE, RouteViews, and Isolario. Note that a peer AS can peer at multiple BGP collectors.</p><p>Lastly, looking at the communities, we observe ∼40G communities in 𝑑 𝑀𝑎𝑦21 , of which around 7G stem from the large community attribute. Overall, there are 84k unique communities. Those communities exhibit 6,643 unique upper fields in both community variations, while regular communities contribute 6,385 unique upper fields and large communities 384. Recall from Section 3.2 that 16-bit ASNs can also be encoded in large communities. Interestingly, PCH shows the highest number of unique upper fields in large communities.</p><p>As mentioned in Section 3.2, our inference method has no use for private and stray communities. When we discard communities where the upper field resembles a private ASN, 6,025 remain. When we further discard communities where the upper field is never in the corresponding AS path (i.e. stray), we end up with 4,579 unique upper fields. Those are candidates for tagger ASes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">INFERENCE METHOD</head><p>While some ASes publicly document their community definitions, there is no documentation as to how those ASes generally set communities on external sessions, e.g., consistent or selective tagging, and whether or not they filter communities set by other taggers. Thus, the community usage has to be inferred. The purpose of the inference method is to infer the BGP community usage per AS by observing the community set output.</p><p>Recall from Section 3.3 that it is possible to utilize the community set output output(𝐴) of an AS 𝐴 to make statements about its community usage. Ideally, the more ASes that propagate their community set output to BGP collectors the better the visibility on the community usage of non-peer ASes. Unfortunately, only a small fraction of ASes (∼1,751 in 𝑑 𝑀𝑎𝑦21 ∪ PCH) peer with BGP collectors. The determination of community usage behavior of the remaining ASes is thus not trivial. Therefore, we devise an inference method that infers community usage only by utilizing the community set output of BGP collector peers.</p><p>In Section 5.1 we state the implications of our mental model on the inference algorithm, which we detail in Sections 5.2 through 5.6. Also, we provide a discussion of our column-based approach in Section 5.7. In Section 6 we verify the functioning of the algorithm by generating and using customized ground truth data sets with known community usage behavior.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Implications from mental model</head><p>As mentioned above, our inference method is limited to the community set output of collector peers, i.e., given a collector 𝐶, an AS path 𝑝, and the community set output(𝐴 1 ) of the peer AS, such that: 𝐶, 𝐴 1 , 𝐴 2 , . . . , 𝐴 𝑛 |output(𝐴 1 ). The tagging function of any peer AS 𝐴 1 can be directly observed in its community set output, because output(𝐴 1 ) = tagging(𝐴 1 ) ∪ forwarding(𝐴 1 , input(𝐴 1 )). Consider the following example where ASes 𝑋 and 𝑌 peer with collector 𝐶:</p><formula xml:id="formula_1">𝐶 𝑋 : * ← −− − 𝑋 𝐶 ∅ ← − 𝑌</formula><p>Assuming that every AS uses its own ASN in the upper field of the community, we can safely conclude that in this context AS 𝑋 is a tagger and 𝑌 is a silent AS.</p><p>Further, it is possible to use output(𝐴 1 ) to infer the community usage of any AS 𝐴 𝑥 ∈𝑝. Note that input(𝐴 𝑥 ) is the community set output of downstream neighbor 𝐴 𝑥+1 , i.e.: input(𝐴 𝑥 ) = output(𝐴 𝑥+1 ). Since output() is recursive, output(𝐴 1 ) can contain information about the community usage of downstream ASes. However, the information can be ambiguous or hidden, as we will explore next. If AS 𝑌 is a visible tagger AS (not hidden behind a cleaner AS), then (b) and (c) will not impact our classification. If, however, 𝑌 is a silent AS, (b) and (c) can lead to a misclassification of AS 𝑌 to be a tagger. In Section 6.4 we show that noise, e.g. caused by (b) and (c), has no significant impact on the inference of tagger and forward behaviors, but on the inference of silent and cleaner behavior. To minimize misclassifications, we allow an AS to be labeled undecided, if it cannot be clearly assigned silent or tagger.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2">Hidden behavior.</head><p>Other forms of ambiguity emerge when the tagging and forwarding behavior is hidden behind a cleaner AS, or when there are no downstream tagger ASes to illuminate the forwarding behavior of upstream ASes. Let us look at an example where AS 𝑋 has a downstream tagger 𝑍 :</p><formula xml:id="formula_2">𝐶 𝑍 : * ← −− − 𝑋 𝑍 : * ← −− − 𝑍</formula><p>If we see the community 𝑍 : * at collector 𝐶, we can conclude that AS 𝑍 is a tagger while AS 𝑋 is silent. More importantly, the fact that we can observe 𝑍 : * allows us to conclude that 𝑋 is a forward AS (and not a cleaner AS). But it is not always as trivial. Consider now the following example:</p><formula xml:id="formula_3">𝐶 ∅ ← − 𝑋 ? ← − 𝑍 Not knowing</formula><p>a priori that 𝑍 is a tagger (𝐶 receives an empty community set), it is impossible for us to tell, whether (a) AS 𝑍 is silent and 𝑋 is a forward AS, or whether (b) AS 𝑍 actually adds communities which are then removed by cleaner 𝑋 . These kinds of ambiguities exacerbate the identification of consistent behavior as we show next. Consider the simplified sequence of updates at collector 𝐶, where 𝑋 is a forward and 𝑌 is a cleaner AS:</p><formula xml:id="formula_4">𝐶 𝑍 : * ← −− − 𝑋 ? ← − 𝑍 𝐶 ∅ ← − 𝑌 ? ← − 𝑍 𝐶 ∅ ← − 𝑌 ? ← − 𝑍</formula><p>From the collector's point of view, one could conclude that 𝑍 is a tagger because we observe and count the community 𝑍 : * . One could also count the two occurrences where 𝑍 appears silent (∅). Given a configurable threshold, 𝑍 can then be classified as either tagger or silent. However, this approach comes with two problems. First, finding the optimal threshold to work in the wild requires ground-truth which is not available. Second, the approach does not consider the possibility that 𝑌 is a cleaner AS, erroneously counting those instances as silent.</p><p>Since our goal is to identify consistent behavior with high precision, it is not sufficient to simply count the occurrences of communities (or the absence thereof). In addition to the existence of communities, our approach requires 𝑋 and 𝑌 to be a forward AS in order to count the behavior of AS 𝑍 . Assuming that 𝑋 is a forward AS and 𝑌 is a cleaner in the above example, we consider only the first update for counting, leading to the classification of 𝑍 as tagger.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.3">AS-level periphery.</head><p>Another form of hidden behavior is shown by leaf ASes (as defined in Section 3.1). Leaf ASes have no downstream ASes and thus no input() to determine their forwarding behavior. We consider leaf ASes useful since their tagging behavior can still help to illuminate the forwarding behavior of upstream ASes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Conditions</head><p>In order to deal with ambiguous or hidden information, and subsequently minimize wrong inferences, in the following we define conditions that fit our mental model and are required when counting the community usage per AS, see Section 5.3. If the conditions are not true, we cannot make any statement about the community usage of an AS 𝐴 𝑥 , given a (𝑝𝑎𝑡ℎ, 𝑐𝑜𝑚𝑚) pair 𝐶, 𝐴 1 , 𝐴 2 , . . . , 𝐴 𝑛 |output(𝐴 1 ).</p><formula xml:id="formula_5">Cond1: 𝑖𝑠_forward(𝐴 𝑖 )|∀𝐴 𝑖 , 𝑖&lt;𝑥</formula><p>In order to make any statement about AS 𝐴 𝑥 ∈ 𝑝𝑎𝑡ℎ we need to make sure that all upstream ASes 𝐴 𝑖 , with 𝑖&lt;𝑥 are forward. Conversely, when a single upstream AS is a cleaner, e.g., if 𝐴 𝑥−1 is a cleaner AS, then output(𝐴 𝑥 ) is hidden. Thus, 𝐶𝑜𝑛𝑑 1 must be fulfilled in order to determine the forwarding and tagging behavior of AS 𝐴 𝑥 (forwarding(𝐴 𝑥 , 𝑖𝑛𝑝𝑢𝑡) and tagging(𝐴 𝑥 )).</p><p>Cond2: 𝑖𝑠_forward(𝐴 𝑗 )∧𝑖𝑠_tagger(𝐴 𝑡 )|∀𝐴 𝑗 ∃𝐴 𝑡 , 𝑥 &lt; 𝑗 &lt;𝑡 In order to determine the forwarding behavior of AS 𝐴 𝑥 , an additional condition is required. Recall from Section 5.1.1 that in order to determine the forwarding behavior of an AS, it requires input from a downstream tagger, here 𝐴 𝑡 . Thus, if there are no downstream taggers, or the downstream taggers are hidden by a cleaner, we cannot make any statement about the forwarding behavior of 𝐴 𝑥 . For example, assume 𝑖𝑠_silent(𝐴 𝑥+1 ) ∧ 𝑖𝑠_cleaner(𝐴 𝑥+1 ) is true, then output(𝐴 𝑥+1 ) = ∅ and forwarding(𝐴 𝑥 , ∅) = ∅.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">Race conditions.</head><p>Under certain topological conditions, both the tagging and forwarding behavior of ASes cannot be determined. Consider the following scenario: AS 𝑋 is the only upstream provider of AS 𝑌 , while 𝑌 is the only downstream AS of 𝑋 .</p><formula xml:id="formula_6">𝐶 ? ← − 𝑋 ? ← − 𝑌</formula><p>In order to infer the forwarding behavior of AS 𝑋 , at least one downstream AS is required, here AS 𝑌 , to be a visible tagger (𝐶𝑜𝑛𝑑 2 ). However, to count the tagging behavior of AS 𝑌 in the first place, it requires all upstream ASes, here AS 𝑋 , to be forward (𝐶𝑜𝑛𝑑 1 ). Thus, AS 𝑋 requires pre-existing knowledge about AS 𝑌 and vice versa which our inference method cannot resolve.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">Summary.</head><p>The community set output(𝐴 1 ) allows us to determine the tagging and forwarding behavior of ASes 𝐴 𝑖 ∈ path 𝑝. However, noise, as well as silent and cleaner ASes that hide information about other ASes, can lead to ambiguities. In order to minimize wrong inferences, the tagging function requires 𝐶𝑜𝑛𝑑 1 , and the forwarding function requires both, 𝐶𝑜𝑛𝑑 1 and 𝐶𝑜𝑛𝑑 2 to be true. However, race conditions can occur which leave some ASes without class, i.e., none. In Section 6.4 we measure the impact of race conditions on our inference coverage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Counting community usage</head><p>In order to infer the community usage per AS, we observe and count patterns that satisfy requirements derived from the implications in Section 5.1. Given input 𝐶, 𝐴 1 , 𝐴 2 , . . . , 𝐴 𝑛 |output(𝐴 1 ), we increase the class counter for a given AS 𝐴 𝑥 if the following conditions hold true:</p><formula xml:id="formula_7">• tagging -t[𝐴 𝑥 ] ++ 𝑖 𝑓 𝐶𝑜𝑛𝑑 1 ∧ 𝐴 𝑥 : * ∈ output(𝐴 1 ) -s[𝐴 𝑥 ] ++ 𝑖 𝑓 𝐶𝑜𝑛𝑑 1 ∧ 𝐴 𝑥 : * ∉ output(𝐴 1 ) • forwarding -f[𝐴 𝑥 ] ++ 𝑖 𝑓 𝐶𝑜𝑛𝑑 1 ∧ 𝐶𝑜𝑛𝑑 2 ∧ 𝐴 𝑡 : * ∈ output(𝐴 1 ) -c[𝐴 𝑥 ] ++ 𝑖 𝑓 𝐶𝑜𝑛𝑑 1 ∧ 𝐶𝑜𝑛𝑑 2 ∧ 𝐴 𝑡 : * ∉ output(𝐴 1 )</formula><p>Note that 𝐶𝑜𝑛𝑑 1 drops out if 𝑥=1, i.e., it is trivial to determine the tagging function of peer ASes. Also, if conditions for forwarding counters f[] and c[] are met, the conditions for tagging counters are met as well. If 𝐶𝑜𝑛𝑑 1 or 𝐶𝑜𝑛𝑑 2 are not met, none of the counters is increased. Based on those counters, we can query the tagging and forwarding behavior of 𝐴:</p><formula xml:id="formula_8">• tagging -𝑖𝑠_tagger(𝐴) = t[𝐴] t[𝐴]+s[𝐴] ≥ tagger_𝑡ℎ𝑟𝑠ℎ -𝑖𝑠_silent(𝐴) = s[𝐴] t[𝐴]+s[𝐴] ≥ silent_𝑡ℎ𝑟𝑠ℎ • forwarding -𝑖𝑠_forward(𝐴) = f[𝐴] f[𝐴]+c[𝐴] ≥ forward_𝑡ℎ𝑟𝑠ℎ -𝑖𝑠_cleaner(𝐴) = c[𝐴] f[𝐴]+c[𝐴] ≥ cleaner_𝑡ℎ𝑟𝑠ℎ</formula><p>For example, an AS A is a tagger if the share of t[𝐴] exceeds the tagger threshold. Recall from Section 3.3 that a tagger is an AS that sets its own communities in a consistent manner. Thus, we want the threshold to be as high as possible, but at the same time allow for exceptions, e.g., 99%. We explore different thresholds in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Selective behavior</head><p>Not all ASes have a uniform tagging and forwarding behavior. An AS may add own and remove other communities selectively, e.g., on a per-session basis or based on the business relationship. Selective tagging can lead to a contradicting perception of community usage, i.e., the tagger counter t[𝑍 ] for a given AS 𝑍 is increased in one instance, the silent counter s[𝑍 ] for the same AS may be increased in another. Consider the following two updates, where 𝑋 and 𝑌 are forward ASes:</p><formula xml:id="formula_9">𝐶 𝑍 : * ← −− − 𝑋 𝑍 : * ← −− − 𝑍 𝐶 ∅ ← − 𝑌 ∅ ← − 𝑍</formula><p>We assume that AS 𝑍 is a selective tagger that adds communities only to customers, here AS 𝑋 , but not to peers (AS 𝑌 ). Based on that observation we increase the tagger and silent counters for the same AS 𝑍 . When both tagging counters t[𝑍 ] and s[𝑍 ] are such that neither 𝑖𝑠_tagger(𝑍 ) nor 𝑖𝑠_silent(𝑍 ) is true, we simply classify 𝑍 as undecided, see Section 5.5.</p><p>While undecided ASes invalidate 𝐶𝑜𝑛𝑑 1 and 𝐶𝑜𝑛𝑑 2 and thus exacerbate further inferences, misclassifications due to selective tagging can lead to further misclassification, as we show next. Consider the following scenario, where AS 𝑍 always tags routes toward the collector using its own communities, but never to any other AS:</p><formula xml:id="formula_10">𝐶 𝑍 : * ← −− − 𝑍 𝐶 ∅ ← − 𝑋 ∅ ← − 𝑍</formula><p>If there are sufficient occurrences of the first update in the input data, AS 𝑍 will be classified as tagger. Now, assume that the algorithm attempts to determine the forwarding behavior of 𝑋 using the second update. If there are sufficient occurrences visible, the algorithm will classify 𝑋 as cleaner, because 𝑖𝑠_tagger(𝑍 ) is true, and the community 𝑍 : * is not present.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.1">Conclusion.</head><p>Selective community usage is a root cause that leads to a limited view of community usage behavior. They can invalidate conditions 𝐶𝑜𝑛𝑑 1 and 𝐶𝑜𝑛𝑑 2 and thus exacerbate the counting. Subsequently, the missing counts of one AS can have a detrimental impact on the counting of another AS, etc. In Section 6.4 we show how our algorithm deals with selective tagging.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Classification</head><p>After the counting is done, we determine the community usage behavior, i.e., the tagging and forwarding behavior of AS 𝐴 like this:</p><formula xml:id="formula_11">𝑔𝑒𝑡_𝑐𝑙𝑎𝑠𝑠 (𝐴) = 𝑔𝑒𝑡_tagging(𝐴)||𝑔𝑒𝑡_forwarding(𝐴) 𝑔𝑒𝑡_tagging(𝐴) =              n, 𝑖 𝑓 t[𝐴] + s[𝐴] == 0 𝑒𝑙𝑠𝑒          t, 𝑖 𝑓 𝑖𝑠_tagger(𝐴) s, 𝑒𝑙𝑖 𝑓 𝑖𝑠_silent(𝐴) u, 𝑒𝑙𝑠𝑒 𝑔𝑒𝑡_forwarding(𝐴) =              n, 𝑖 𝑓 f[𝐴] + c[𝐴] == 0 𝑒𝑙𝑠𝑒         </formula><p>f, 𝑖 𝑓 𝑖𝑠_forward(𝐴) c, 𝑒𝑙𝑖 𝑓 𝑖𝑠_cleaner(𝐴) u, 𝑒𝑙𝑠𝑒 The function 𝑔𝑒𝑡_𝑐𝑙𝑎𝑠𝑠 (𝐴) returns a two-character string which indicates the inferred tagging (first character) and forwarding (second character) behavior of AS 𝐴.  Both indicators can assume n (none) if the respective counters are zero. Recall, when any of the required conditions 𝐶𝑜𝑛𝑑 1 or 𝐶𝑜𝑛𝑑 2 cannot be fulfilled, none of the counters are increased. Thus, it can occur that all counters for an AS result in zero. When both tagging counters t[𝐴] and s[𝐴] for a given AS 𝐴 are zero, there is not enough information to make any decision about the tagging behavior of 𝐴. The same applies to forwarding counters.</p><p>When tagging counters are available, the resulting tagging indicator can be t (tagger), s (silent), or u (undecided). Similarly, the forwarding indicator can be either f (forward), c (cleaner), or u. Note, that the resulting class depends on the thresholds that are used during counting, see Section 5.3.</p><p>The resulting two-character string for AS 𝐴 can range among tf (tagger-forward), sc (silent-cleaner), or nu (none-undecided).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Algorithm</head><p>Considering the requirements for counting community usage (see Section 5.3) we note that counting each class depends on preexisting knowledge of other ASes in the AS path, i.e., 𝐶𝑜𝑛𝑑 1 and 𝐶𝑜𝑛𝑑 2 . In particular counters c[] and f[] require for conditions to hold true for upstream ASes as well as downstream ASes. Fortunately, it is trivial to count the tagging behavior of peer ASes (𝐴 1 ), which can be used as initial knowledge to feed follow-up inferences. In order to meet the conditions 𝐶𝑜𝑛𝑑 1 and 𝐶𝑜𝑛𝑑 2 as often as possible, we design an algorithm that generates pre-existing knowledge by iterating over the input data a total of two times, in a column-based fashion (as opposed to row-based), see Figure <ref type="figure" target="#fig_3">1</ref>. Iterating the data by column, i.e., the path index, we can utilize the recursive output of 𝐴 1 and apply the conditions as the algorithm progresses to higher indices. To show a sample implementation of the algorithm, we provide the corresponding pseudo-code in Listing 1 in the appendix.</p><p>In the following, we describe the steps of the algorithm in detail. Given as input 𝐿 = {(path,comm)}, a list of AS path and community set tuples, where 𝑝𝑎𝑡ℎ = 𝐴 1 , 𝐴 2 , . . . , 𝐴 𝑛 and 𝑐𝑜𝑚𝑚 = output(𝐴 1 ), we begin with counting the tagging behavior of peer ASes: Summary: In essence, the inference method iterates over the input list 𝐿 two times, i.e., 2 * (𝑁 * |𝐿|), where 𝑁 corresponds to the maximum path index. For each path index (column) we first count the tagging behavior, then the forwarding behavior. With each iteration over a path index, the gained knowledge is transferred to the next iteration. We note that at high path indices the number of ASes that need to fulfill 𝑐𝑜𝑛𝑑 1 increases, and thus, the probability of inference decreases. Although the maximum observed path length in the input data is 19 (after cleaning), we observe that the algorithm stops increasing counters, e.g., due to missing information, typically at around 𝑁 =7.</p><formula xml:id="formula_12">• path index 1 -count</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.7">Discussion</head><p>In order to apply rules that require pre-existing knowledge and at the same time traverse the input data efficiently, we chose an approach that considers both. Instead of traversing the entire paths one by one (row-based), in our approach we traverse all paths by the path index (column-based), starting with the collector peer. Recall, output(𝐴 1 ) is recursive and thus can contain the community output of other ASes along the path.</p><p>Row-based: In a row-based approach, each path is processed separately and independently from the other paths. Thus, the counters for observing communities (or the lack thereof) associated with an AS path cannot be connected to observations in other paths. Inferences can be made based on the counters only after all paths are processed. In order to achieve our objectives, i.e., classifying consistent behavior with high precision, additional refinement and optimization steps would be required.</p><p>Further, since the row-based approach counts observations without pre-existing knowledge about the ASes in the AS path, it is susceptible to misclassification, e.g. due to noise or hidden behavior. Also, since there is no ground truth information available about the community usage in the wild, finding the right threshold to adjust the precision is not possible. In the appendix, we provide pseudo-code that serves as an example for a row-based approach, see Listing 2.</p><p>Column-based: Like the row-based approach, our column-based approach allows us to count while we traverse the AS paths. However, in addition, it can generate pre-existing knowledge at one path index and used it at later indices. This further enables us to implement rules, i.e. 𝐶𝑜𝑛𝑑 1 and 𝐶𝑜𝑛𝑑 2 that base on our mental model, on every AS path. Thus, our algorithm is able to identify</p><p>• ASes which behavior is hidden behind a cleaner AS and • ASes that are not illuminated by a downstream tagger.</p><p>Both abilities allow us not only to minimize misclassification, but also they increase the robustness of inferences in the presence of noise. In Section 6 we show that our algorithm avoids misclassifications and that it classifies less than 0.5% of ASes that are actually hidden.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">VERIFICATION OF ALGORITHM</head><p>In this section, we apply the algorithm to different scenarios in controlled simulations, in order to verify that it performs according to our expectations. We generate multiple data sets with known community usage behavior. Therefore, we take all available AS paths from RIPE, RouteViews, and Isolario (𝑑 𝑀𝑎𝑦21 ), assign roles to each AS, e.g., tf (tagger-forward), sc (silent-cleaner), and compute the community output of each peer AS (output(𝐴 1 )), according to our mental model in Section 3.3. Thus, we have an AS path substrate from real-world BGP data augmented with known community usage behavior per AS. Specifically, we know which AS's behavior is consistent (tagger, forward, ...) and selective and which behavior is always hidden and thus cannot be inferred. Further, each scenario uses the AS paths from 𝑑 𝑀𝑎𝑦21 as a substrate. Thus, each generated data set includes 72,951 ASes among which 60,420 are leaf ASes and 766 are collector peers. All presented results were inferred using a threshold of 99% in order to increase the inference counters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Consistent behavior</head><p>To test our algorithm against the average and extreme cases, we generate ground truth data sets with different settings in the community usage behavior of ASes. Initially, we consider consistent behavior of ASes, e.g., a tagger adds communities towards all BGP neighbors (including collectors), irrespective of the business relationship.</p><p>• alltf: To test how the algorithm performs under optimal conditions, in this scenario, we maximize the visibility of communities by assigning the role tf to all ASes. This way the tagging and forwarding behavior of all ASes becomes visible. • alltc: In this scenario, we test the opposite case, i.e., where the visibility of communities is minimized. Therefore, the role tc is assigned to all ASes. • random: Since there exist no ground truth information regarding the community usage of ASes, we create an average case scenario, where all roles tf , tc, sf , and sc are uniformly assigned at random among all ASes, i.e., 25% are tf , 25% tc, 25% sf , and 25% sc.</p><p>Intuitively, the algorithm should perform best in the alltf scenario and perform worst in the alltc scenario. Note, since each AS behaves consistently, the tagging and forwarding behavior, if not hidden, will be inferred correctly, irrespective of the threshold.</p><p>In order to better understand the sensitivity of our inference method, we add additional communities to the generated ground truth data sets that stress the ability of the algorithm to infer the tagging and forwarding behavior of ASes correctly.</p><p>• noise: First, to test the tagging behavior inference, we let around 50% of all ASes set communities using the ASN of their upstream neighbor in the upper field, simulating action communities. Second, to test the forwarding inference, we add a community with the upper field corresponding to the ASN of the originator.</p><p>These two noise sources occur with a 5% probability, such that each affected AS can exhibit inconsistent behavior. In the next section, we introduce additional scenarios in which we explore the selective behavior of ASes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Selective behavior</head><p>Since not all ASes exhibit a consistent community usage behavior, their tagging and forwarding counters may lead to an undecided inference, or even to a misclassification, see Section 5.4. In order to test how the algorithm reacts to selective behavior, we use the random scenario with consistent behavior and modify around 50% of the assigned tagger ASes to selectively tag routes based on the business relationship:</p><p>• random-p: In this scenario, the selective tagger ASes do not set communities on provider links, but on all other links, i.e., peers, customers and collectors. • random-pp: In this scenario, the selective tagger ASes do not set communities on provider and peer links; only towards and customers and collectors.</p><p>For our convenience, we use CAIDA's business relationship inferences <ref type="bibr" target="#b2">[3]</ref> to augment the ground truth data sets with the corresponding behavior. For example, a selective tagger AS 𝐴 𝑥 in scenario random-pp adds a community towards its neighbor 𝐴 𝑥−1 , only if 𝐴 𝑥−1 is a customer of 𝐴 𝑥 . Since we create a hypothetical scenario, we do not rely on the accuracy of the business relationship inferences.</p><p>Other than that, the parameters of the random scenario of Section 6.1 are used. Since in random-p and random-pp the propagation of communities is limited, the algorithm is expected to perform worse compared to the random scenario.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Results</head><p>In Table <ref type="table" target="#tab_4">2</ref> we present the classification results for the scenarios with consistent behavior (random, alltf, alltc), and those with selective behavior (random-p, random-pp). In each random scenario, we use 10 different ground truth data sets, each generated with a different (random) distribution of roles (tf , tc, sf , sc). Since, the resulting inferences are comparable in all 10 variations, we only show the mean values in the table.</p><p>For simplicity, we calculate the recall by considering only tagging and forwarding behaviors that are not selective, hidden or missing (i.e., forwarding behavior at leaf ASes). Thereby, the false negatives  include cases where the tagging or forwarding behavior was not inferred, i.e., none, or the inference results in undecided.</p><p>Let us first look at scenarios with consistent behavior:</p><p>• Precision and recall: All scenarios with consistent behavior (including random+noise) show a precision of 100%, i.e., there is no wrong inference of tagging and forwarding behavior. Also, the recall is relatively high when inferring tagging (93-100%) and forwarding (70-82%). However, the recall in the case of random+noise is low, i.e., 55% for tagging and 45% for forwarding behavior. • full classification: In the random scenario, the algorithm yields around 1,300 inferred ASes for each of the assigned roles, i.e., both, the tagging and forwarding behaviors were inferred. Further, in the alltc scenario 578 ASes are tc and in the alltf scenario 10,427 ASes are tf . • partial classification: A significant amount of ASes have an inferred tagging behavior but no forwarding behavior. ∼20k ASes are identified as tagger and ∼20k as silent in the random scenario. • none / undecided: Looking at the number of not classified ASes, the algorithm performs best in the alltf scenario, and worst in the alltc scenario, as expected. Notably, the ran-dom+noise scenario leads to undecided behavior in particular the tagging behavior is affected, see u* (tagging is undecided).</p><p>Next, we look at the selective behavior of ASes, i.e., random-p and random-pp. Compared to the simple random scenario, the selective behavior of ASes leads to an increase of undecided inferences in the case of tagging and forwarding, see u* (tagging is undecided) and *u (forwarding is undecided) in Table <ref type="table" target="#tab_4">2</ref>. Note that undecided behavior exacerbates the inference of other ASes, see Section 5.4. Unsurprisingly, the distribution of inferences is skewed compared to the simple random scenario. Also, when we consider the none cases as a performance metric, we find that the algorithm still performs better than the alltc scenario and worse than the alltf scenario.</p><p>The most important difference resulting from those scenarios is recall and precision. Because of selective taggers the precision of our inference method in both scenarios is affected, i.e., 86%/99% in the case of tagging and 97%/94% in the case of forwarding. The recall is more affected: 42%/18% in the case of tagging and 39%/18% in the case of forwarding. Given the increased difficulty in the random-p and random-pp, these results are expected. In scenario random-p (left) taggers add communities on customer and peering links, and in scenario random-pp (right) taggers add communities on customer links only (increased difficulty). Performance not sensitive to threshold.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.1">Performance under different thresholds.</head><p>Selective tagging behavior can lead to a contradicting perception of community usage, i.e., the tagger counter t[𝑍 ] for a given AS 𝑍 is increased in one instance, the silent counter s[𝑍 ] for the same AS may be increased in another. In the following, we show how the sensitivity and specificity of our inferences change when different thresholds are used to infer the tagging or forwarding behavior of an AS. We repeat the inference method on both scenarios, random-p and random-pp, for every threshold between 50% and 100%.</p><p>Figure <ref type="figure" target="#fig_4">2</ref> show the ROC curves for the tagging and the forwarding inferences, for the scenarios random-p (left) and random-pp (right), respectively. The false-positive rate is on the x-axis and the true-positive rate on the y-axis. As we can see, by increasing the threshold from 50% to 100% the specificity increases and the sensitivity decreases. However, those are minute changes: The false-positive rate decreases from 10% to 1% in case of the tagging classifier, and from 1% to 0% in case of the forwarding classifier. These results indicate that the inferences are not very sensitive to the threshold, in particular when inferring the forwarding behavior. Also, the true-positive rate decreases by ∼20% in both cases. Since the difficulty in scenario random-pp is increased, the number of undecided ASes increase as well. Thus, we observe a lower true-positive rate compared to random-p. In general, the number of not inferred ASes (none) increases in all cases compared to the random scenario. Since selective ASes are not tagging towards their providers, fewer communities make it to the collector. Regarding the visible tagger and silent ASes, there are no misclassifications. However, almost 50% of the ASes in both cases are not inferred. Interestingly, from the ∼12k visible selective ASes, around 5.9k are classified either tagger or silent. Only 837 ASes are undecided.</p><p>Summary: The algorithm classifies consistent behavior with a high precision. It avoids misclassifications of silent in the presence of noise (undecided instead), while tagger ASes are mostly unaffected. Furthermore, the algorithm avoids classifying ASes that are hidden or leaf ASes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">ANALYSIS</head><p>In the previous section, we have introduced an inference method that allows us to infer the tagging and forwarding behaviors of ASes. We devised an algorithm that utilizes routing information, specifically AS paths and community attributes, and validated its properties using customized data sets.</p><p>Next, we show the classification results when the inference method is applied on actual, unmodified routing data, characterize the involved ASes, and validate our inferences by actively injecting route announcements with attached communities to the real-world routing system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Classification results</head><p>Table <ref type="table" target="#tab_5">3</ref> summarizes the community usage classification per route collector project and of the aggregation of RIPE, RouteViews, and Isolario (𝑑 𝑀𝑎𝑦21 ). We also include the inferences based on PCH update data only. Note that the PCH data set does not include RIB information, see Section 4. We split the statistics by tagging and forwarding. The algorithm exhibits a similar share of identified behavior among the three collector projects RIPE, RouteViews, and Isolario: 717 to 809 ASes exhibit tagger behavior, 9,901 to 10,594 Regarding the full classification, i.e., both, the tagging and the forwarding for an AS are inferred, we see that tf (tagger-forward), tc (tagger-cleaner), and sf (silent-forward) show similar numbers; between 47 and 88. sc (silent-cleaner) is the most common with 129 to 173 inferred ASes. The aggregated data set shows an increase compared to the individual collectors with a total of 523 fully classified ASes out of which 273 are collector peers. Next, we take a closer look at the stability and longitudinal changes of our inferences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.1">Stability and longitudinal view.</head><p>In order to better understand how adding more data impacts our inferences, we next apply our algorithm to a day worth of data which we incrementally increase by a successive day for a total of 5 days, starting in May 19, 2021. Thus, the final data set from May 23 contains data from all 5 days. Since the inference numbers in Table <ref type="table" target="#tab_5">3</ref> for the collectors and the aggregated 𝑑 𝑀𝑎𝑦21 are comparable, in the following we focus only on RouteViews data sets.</p><p>Figure <ref type="figure">3</ref> shows the number of new, stable, and recurrent ASes for each full class (tf , tc, sf , sc). We can see that except for day 1, only a few ASes are new, i.e., a maximum of 10 at day +2 in the case of sc. Moreover, while we observe some amount of recurring ASes, the majority (90-97%) of ASes appear stable since day 1. We are confident that using our algorithm on a day's worth of routing data is of sufficient granularity to provide stable inferences.</p><p>Next, we investigate how the number of fully classified ASes (tf , tc, sf , and sc) change over time. Therefore we use aggregated data sets, i.e., RIPE, RouteViews, and Isolario combined, one day every three months over a time period of two years, see Figure <ref type="figure">4</ref>. The time period ranges from December 15, 2019 to (and including) September 15, 2021. There is no significant increase or decrease in the number of fully classified ASes discernible. Rather, the number of individual ASes per class and per day are comparable to those presented in Table <ref type="table" target="#tab_5">3</ref> for 𝑑 𝑀𝑎𝑦21 . Overall, these results are indicative 0 100 250 q q q q q q q q Dec'19 of a stable, consistent community usage behavior throughout the past two years, involving a small set of ASes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Peer ASes</head><p>In the following, we take a closer look at 273 collector peers of the 523 fully classified ASes, see Section 7.1. Since peer ASes are connected directly to BGP collectors, their community set output (output(𝐴 1 )) should be not impaired by other ASes along the path. Specifically, we investigate whether output(𝐴 1 ) corresponds to the inferred tagging and forwarding behavior of a peer AS 𝐴 1 . For that, we count the type of communities that are included in output(𝐴 1 ), i.e., peer, foreign, stray, and private, see Section 3.2.</p><p>Based on our mental model in Section 3.3, the intuition of our approach is as follows: peer communities should only be observable when the peer AS is a tagger. We should not be able to observe peer communities when the AS is silent. On the other hand, foreign should only be visible if the peer AS is forward, and not visible if that AS is a cleaner. Note, since our inference method discards stray and private communities (Section 5.1), we expect to see them independent of the peer AS classification.</p><p>Figure <ref type="figure">5</ref> shows four scatter plots, one for each (full) class tf (tagger-forward), tc (tagger-cleaner), sf (silent-forward), and sc (silentcleaner). In each plot, the x-axis contains peer ASes of the corresponding class, ordered by the number of total communities, and the y-axis indicates the community types. The color palette indicates the number of total communities in a logarithmic scale, ranging from 1 to 71M+.</p><p>In accordance with our expectations, we observe a large number peer communities in the cases tf and tc, indicated by the bottom bar of the respective plots. We observe few to no peer communities in the cases sf and sc. Furthermore, we observe a large amount of foreign communities in the cases tf and sf , i.e., when the peer ASes do not remove communities from other ASes in the AS path (see second bottom bar). Conversely, we see only few to no foreign communities when the peer AS is tc or sc, i.e., the AS is removing communities from other ASes in the AS path. However, there are also some cleaner ASes that, given the number of foreign communities, contradict their inference. Those foreign communities can be caused, e.g., by one or multiple downstream ASes that our algorithm was not able to identify as tagger (and thus invalidate 𝐶𝑜𝑛𝑑 2 ). Last, since we do not consider stray and private communities in our inference method, we observe them in all classes, in particular when the peer AS is forward, but also when it is a cleaner.</p><p>Conclusion: Overall, our observations of community usage at collector peers align with our mental model and corroborate the correct functioning of our inference method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">AS characterization</head><p>Next, we explore the characteristics of ASes based on their classification. For that we make use of CAIDA's customer cone data sets <ref type="bibr" target="#b2">[3]</ref>. The customer cone of an AS includes itself and all ASes that can be reached by only traversing customer links. Leaf ASes thus have a customer cone size of 1. We use the customer cone size as an indicator for the size of an AS.</p><p>In Figure <ref type="figure">6</ref>, we plot CDFs over customer cone sizes for all ASes in 𝑑 𝑀𝑎𝑦21 . Starting with the tagging behavior (top plot), we see a significant difference of cone sizes between ASes that are classified as tagger and those that are classified as silent. ∼70% of silent ASes have a cone size of 1, i.e., they are leaf ASes. Also, while around 10% of silent ASes have a cone size greater than 10, it is around 50% for tagger ASes, indicating that ASes at the edge of the AS-level graph usually do not add their own communities. Interestingly, ASes with undecided behavior exhibit a similar distribution of cone sizes as taggers. Lastly, ASes with no inference are mostly leaf ASes, i.e. in ∼90% of the cases. Most notably for forwarding behavior (bottom plot), cleaner and silent ASes show a similar distribution of cone sizes, indicating that cleaner and silent ASes are common across all AS sizes. Again, ASes with no inference are mostly leaf ASes.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Validation of inferences</head><p>Finally, we validate our inferences with external ground truth information obtained by injecting route announcements with consistent use of communities. Thus, by having control over a tagger, we check how often the observation of our communities contradicts the inferences of AS behaviors along the corresponding AS path. For example, given an AS path and a community set that includes our communities, the AS path must not include a cleaner AS, otherwise the community would have been not visible (see Section 5.1). Similarly, if the community set does not include any of our communities, there must be at least one cleaner in the AS path.</p><p>We utilized the PEERING testbed to conduct our real-world validation <ref type="bibr" target="#b22">[23]</ref>. Using PEERING, we announce a /24 prefix via 12 available Points of Presence (PoPs) for approximately one week beginning on May 19, 2021. To each PoP, we add a unique pair of communities to the announcement; these communities use PEER-ING's 47065 ASN in the upper 2 bytes and unique values in the lower 2 bytes. Via these PoPs, PEERING had 460 active BGP peers in total at the time of our experiment.</p><p>We extract the relevant announcements from our data set 𝑑 𝑀𝑎𝑦21 by filtering for the prefix. We observe a total of 7,503 announcements corresponding to that prefix. From the 12 community sets we have configured, only 6 appear in around 30% of those announcements. From the observed announcements, we extract 549 unique AS paths. Interestingly, only 5 AS paths are not consistently attached with our communities, i.e., they appear with and without our communities. The remaining 544 AS paths are either always, or never, associated with our communities. This indicates a consistent usage of communities along the same path.</p><p>In order to validate our inferences, we count how often a cleaner exists in the AS paths, when a) the corresponding community set contains our communities, and when b) the community set does not contain our communities. We first look at 367 unique tuples that do not include any of our communities: in 285 cases (∼78%) at least one cleaner exists in the AS path. 81 cases (∼22%) include at least one AS that exhibits undecided behavior. Only 1 AS path does not include an identified cleaner and thus contradicts our inferences. Next, we select 177 unique AS path / community set tuples that do contain our communities: Here, 6 (3%) AS paths contradict our inferences, i.e., the AS path contains a cleaner AS. However, we note that 152 AS paths (∼85%) include at least one AS with undecided behavior. The remaining 19 AS paths include neither. In Table <ref type="table" target="#tab_9">4</ref> we show a summary of this and two additional experiments we have performed, with similar outcomes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSIONS AND FUTURE WORK</head><p>In this work, we take a step toward achieving a more grounded understanding of BGP community usage behavior at a per-AS granularity. While our algorithm is inferential and its ability to classify an AS's community usage depends both upon BGP visibility and the complexity of the AS's policies, ours is the first work to take on this challenging task. Furthermore, through extensive testing and validation, we show that our algorithm has high precision -when it does make an inference, it is generally correct.</p><p>We apply our algorithm to large-scale, real-world BGP data from the major route collectors in order to maximize coverage and make inferences for the most ASes possible. We characterize the ASes exhibiting different usage behaviors and find that tagger, forward and cleaner ASes typically have a large customer cone, while silent are typically at the edge.</p><p>We publicly release our algorithm and inferences to the community to support related BGP and network research, including automated community processing in networks based on inferences, Internet modeling, and improved BGP security posture <ref type="bibr" target="#b4">[5]</ref>.</p><p>In future work, we plan to extend and improve the algorithm, especially removing the strict assumption that community tags use the ASN of the network that added the community. In this fashion, we wish to identify not only whether an AS is a tagger, but also which communities it adds. This ability will be especially useful to differentiate signaling versus informational communities, and to support efforts directed toward automated and safe community filtering.</p><p>Postgraduate School. Views and conclusions are those of the authors and should not be interpreted as representing the official policies or position of the U.S. government, the NSF, ERC, BMBF, or NRC.</p><p>A APPENDIX   </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>𝑋</head><label></label><figDesc>𝑋 : * ← −− − 𝑍 1 RFC8092 calls the field the Global Administrator.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>5.1.1 Noise. The simplest form of ambiguity stems from the fact that any AS along the AS path can arbitrarily modify the communities in the community attribute. The resulting noise can lead to a wrong perception of community usage. Consider the following example: 𝐶 𝑌 : * ← −− − 𝑋 ? ← − 𝑌 ? ← − 𝑍 Without additional information beyond what exists in BGP data we are not able to determine the source of community 𝑌 : * . There are multiple interpretations: (a) AS 𝑌 might have tagged the route with an informational community to indicate the ingress location. (b) AS 𝑍 might have used an action community defined by AS 𝑌 to instruct 𝑌 to perform a specific action on that route. (c) AS 𝑋 could have unconventionally defined and set this community.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Inference algorithm workflow. Two passes over input (𝑝𝑎𝑡ℎ, 𝑐𝑜𝑚𝑚) tuples: 1) to count tagging behavior and 2) to count forwarding behavior for each AS. Tuples are iterated per column (AS path index), starting with left-most ASes (𝐴 1 ). Knowledge from one iteration is transferred to the next.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: ROC curves show effects when changing threshold.In scenario random-p (left) taggers add communities on customer and peering links, and in scenario random-pp (right) taggers add communities on customer links only (increased difficulty). Performance not sensitive to threshold.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>tagging and forwarding behavior, e.g. an AS can be tagger and forward at the same time (but not tagger and silent at the same time). Note, that our definitions do not exclude the possibility that communities are used only AS-internally and filtered upon reannouncing. However, this case is difficult to classify and requires AS-specific insights that go beyond the scope of this work.</figDesc><table><row><cell cols="3">• forwarding behavior</cell></row><row><cell cols="4">-forward: A forward AS does not remove communities</cell></row><row><cell cols="4">added by other tagger ASes and forwards them on ex-</cell></row><row><cell cols="2">ternal links.</cell><cell></cell></row><row><cell cols="4">-cleaner: A cleaner AS removes communities set by other</cell></row><row><cell cols="4">tagger ASes, either upon receiving or upon forwarding on</cell></row><row><cell cols="2">external links.</cell><cell></cell></row><row><cell cols="4">Every AS has a 3.3.2 Formal Model. To capture the tagging behavior of AS 𝐴 we</cell></row><row><cell cols="4">define a function that returns a non-empty community set with</cell></row><row><cell cols="4">communities 𝐴: *  if 𝐴 is a tagger and an empty community set if 𝐴</cell></row><row><cell>is a silent AS:</cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="3">𝐴: * , 𝑖 𝑓 𝑖𝑠_tagger(𝐴)</cell></row><row><cell>tagging(𝐴) =</cell><cell>∅,</cell><cell cols="2">𝑖 𝑓 𝑖𝑠_silent(𝐴)</cell></row><row><cell cols="4">Analogously to the tagging function, we define a forwarding</cell></row><row><cell cols="4">function that captures the forwarding behavior of AS 𝐴:</cell></row><row><cell></cell><cell></cell><cell></cell><cell>𝑖𝑛𝑝𝑢𝑡, 𝑖 𝑓 𝑖𝑠_forward(𝐴)</cell></row><row><cell cols="3">forwarding(𝐴, 𝑖𝑛𝑝𝑢𝑡) =</cell><cell>∅,</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Data sets overview: RIBs + updates for collector projects RIPE, RouteViews, Isolario, PCH in May 19, 2021. 𝑑 𝑀𝑎𝑦21 represent the aggregation of RIPE, RouteViews, and Isolario. PCH is treated separately due to missing communities in RIB snapshots.</figDesc><table><row><cell>Input data</cell><cell cols="3">RIPE RouteViews Isolario</cell><cell>𝑑 𝑀𝑎𝑦21</cell><cell>PCH</cell></row><row><cell>Entries total</cell><cell>2,242M</cell><cell>4,679M</cell><cell>2,088M</cell><cell>9,010M</cell><cell>532M</cell></row><row><cell>incl. RIB entries</cell><cell>1,022M</cell><cell>3,160M</cell><cell>1,275M</cell><cell>5,458M</cell><cell>0</cell></row><row><cell>Uniq. (𝑝𝑎𝑡ℎ, 𝑐𝑜𝑚𝑚)</cell><cell>46M</cell><cell>30M</cell><cell>16M</cell><cell>77M</cell><cell>1M</cell></row><row><cell>AS numbers</cell><cell>79,192</cell><cell>80,097</cell><cell>78,454</cell><cell>80,651</cell><cell>77,082</cell></row><row><cell>After cleaning</cell><cell>72,737</cell><cell>72,837</cell><cell>72,625</cell><cell>72,951</cell><cell>67,541</cell></row><row><cell>incl. Leaf ASes</cell><cell>60,418</cell><cell>60,838</cell><cell>60,834</cell><cell>60,420</cell><cell>56,703</cell></row><row><cell>incl. 32-bit ASes</cell><cell>31,147</cell><cell>31,193</cell><cell>31,082</cell><cell>31,239</cell><cell>29,077</cell></row><row><cell>Collector peers</cell><cell>525</cell><cell>291</cell><cell>108</cell><cell>766</cell><cell>1,304</cell></row><row><cell>Communities</cell><cell>12,133M</cell><cell cols="4">16,513M 11,056M 39,703M 2,185M</cell></row><row><cell>incl. large</cell><cell>2,614M</cell><cell>2,196M</cell><cell>2,283M</cell><cell>7,093M</cell><cell>660M</cell></row><row><cell>Unique communities</cell><cell>75,681</cell><cell>73,720</cell><cell>67,816</cell><cell>84,186</cell><cell>35,804</cell></row><row><cell>incl. large</cell><cell>4,147</cell><cell>4,605</cell><cell>3,581</cell><cell>5,326</cell><cell>3,383</cell></row><row><cell>Uniq. upper field (regular)</cell><cell>5,904</cell><cell>6,091</cell><cell>5,713</cell><cell>6,385</cell><cell>3,303</cell></row><row><cell>Uniq. upper field (large)</cell><cell>378</cell><cell>357</cell><cell>358</cell><cell>384</cell><cell>884</cell></row><row><cell>Uniq. upper field (both)</cell><cell>6,160</cell><cell>6,340</cell><cell>5,958</cell><cell>6,643</cell><cell>4,292</cell></row><row><cell>w/o private</cell><cell>5,660</cell><cell>5,739</cell><cell>5,474</cell><cell>6,025</cell><cell>3,931</cell></row><row><cell>w/o stray</cell><cell>4,316</cell><cell>4,373</cell><cell>4,189</cell><cell>4,579</cell><cell>2,574</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>𝑖 𝑓 𝐴 1 : * ∈ output(𝐴 1 ). Otherwise, we increase the silent counter 𝑠 [𝐴 1 ]. Note that 𝐶𝑜𝑛𝑑 1 drops out at path index 1, since there are no upstream ASes. -count forwarding Next, we use the previously obtained tagging counters to fulfill 𝐶𝑜𝑛𝑑 2 of forwarding counters 𝑖 [] and 𝑐 [], and count the forwarding behavior at path index 1. We increase the forward counter 𝑖 [𝐴 1 ] 𝑖 𝑓 𝐴 𝑡 : * ∈ output(𝐴 1 ). Else, we increase the cleaner counter 𝑐 [𝐴 1 ]. • path index 𝑖 &gt; 1 (𝐶𝑜𝑛𝑑 1 kicks in) -count tagging We use forwarding counters from previous steps to fulfill 𝐶𝑜𝑛𝑑 1 and count the tagging behavior at path index 𝑖. We increase 𝑡 [𝐴 𝑖 ], 𝑖 𝑓 𝐴 𝑖 : * ∈ output(𝐴 1 ). Otherwise, we increase 𝑠 [𝐴 𝑖 ]. -count forwarding We use forwarding and tagging counters from previous steps to fulfill 𝐶𝑜𝑛𝑑 1 and 𝐶𝑜𝑛𝑑 2 and count the forwarding behavior at path index 𝑖. We increase 𝑖 [𝐴 𝑖 ], 𝑖 𝑓 𝐴</figDesc><table /><note>tagging We begin by counting the tagging behavior at path index 1, i.e., 𝐴 1 of every AS path. For that, we increase the tagger counter 𝑡 [𝐴 1 ] 𝑡 : * ∈ output(𝐴 1 ). Otherwise, we increase 𝑐 [𝐴 𝑖 ].</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 2 :</head><label>2</label><figDesc>Classification results and performance using scenarios with consistent and selective behavior. The numbers represent mean values from 10 iterations per random scenario. Thresholds 99%, ground truth data substrate: 𝑑 𝑀𝑎𝑦21 , 72,951 ASes (60,420 leafs, 31,239 32-bit, 766 collector peers), inMay 19, 2021.    </figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 3 :</head><label>3</label><figDesc>Classification results using real BGP data (RIBs + updates), May 19, 2021. RIPE, RouteViews, and Isolario are comparable. Aggregated data set 𝑑 𝑀𝑎𝑦21 yields most classifications. PCH includes only updates.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>Figure 3: Impact of incrementally adding more days to the input data. For each full classification , tc, sf , sc), barplot shows the total number of ASes (y-axis) and the number of successive days used (x-axis). New ASes appear for the first time in the respective full class, stable ASes appear consistently since day 1 (May 19, 2021), and recurrent ASes occur with interruptions. RouteViews data only. silent, 198 to 216 forward, and 239 to 309 ASes exhibit cleaner behavior. Looking at the aggregate (𝑑 𝑀𝑎𝑦21 ) the numbers are comparable (860, 12,315, 271, and 417, respectively). PCH shows the least amount of inferred classes.</figDesc><table><row><cell></cell><cell cols="3">tagger−forward</cell><cell></cell><cell></cell><cell cols="3">tagger−cleaner</cell><cell></cell></row><row><cell>new</cell><cell></cell><cell>stable</cell><cell></cell><cell>recurring</cell><cell>new</cell><cell></cell><cell>stable</cell><cell></cell><cell>recurring</cell></row><row><cell>0 30 60 0 30 60</cell><cell></cell><cell></cell><cell></cell><cell>0 20 50 0 20 50</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>day 1</cell><cell>+2</cell><cell>+3</cell><cell>+4</cell><cell>+5</cell><cell>day 1</cell><cell>+2</cell><cell>+3</cell><cell>+4</cell><cell>+5</cell></row><row><cell></cell><cell cols="3">silent−forward</cell><cell></cell><cell></cell><cell cols="3">silent−cleaner</cell><cell></cell></row><row><cell>new</cell><cell></cell><cell>stable</cell><cell></cell><cell>recurring</cell><cell>new</cell><cell></cell><cell>stable</cell><cell></cell><cell>recurring</cell></row><row><cell>30 60 30 60</cell><cell></cell><cell></cell><cell></cell><cell>100 100</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>0 0</cell><cell></cell><cell></cell><cell></cell><cell>0 0</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>day 1</cell><cell>+2</cell><cell>+3</cell><cell>+4</cell><cell>+5</cell><cell>day 1</cell><cell>+2</cell><cell>+3</cell><cell>+4</cell><cell>+5</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>CDFs showing customer cone size distribution of ASes per tagging behavior (top) and forwarding behavior (bottom). All behaviors (except for silent, and those that are none) are attributed to mostly larger and non-leaf ASes.</figDesc><table><row><cell>Proportion &lt;= x</cell><cell>0.0 0.4 0.8</cell><cell></cell><cell></cell><cell></cell><cell>tagging tagger silent undecided none</cell></row><row><cell></cell><cell>1</cell><cell>10</cell><cell>100</cell><cell>1000</cell><cell>10000</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">customer cone size</cell></row><row><cell>Proportion &lt;= x</cell><cell>0.0 0.4 0.8</cell><cell></cell><cell></cell><cell></cell><cell>forwarding cleaner forward undecided none</cell></row><row><cell></cell><cell>1</cell><cell>10</cell><cell>100</cell><cell>1000</cell><cell>10000</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">customer cone size</cell></row><row><cell cols="6">Figure 6: experiment date communities present communities not present</cell></row><row><cell></cell><cell>2021-05-19</cell><cell></cell><cell>6/177 (3%)</cell><cell></cell><cell>285/367 (78%)</cell></row><row><cell></cell><cell>2021-07-15</cell><cell></cell><cell>1/104 (1%)</cell><cell></cell><cell>286/365 (78%)</cell></row><row><cell></cell><cell>2021-08-15</cell><cell></cell><cell>0/61 (0%)</cell><cell></cell><cell>300/359 (84%)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Table 4 :</head><label>4</label><figDesc>PEERING experiments: Table shows the share of paths containing at least one cleaner AS, when a) communities are present and b) when communities are not present. We perform three temporally uncorrelated experiments.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head></head><label></label><figDesc>𝐴 𝑥 ]++ i f 𝐴 𝑥 : * in comm 6 s [𝐴 𝑥 ]++ i f 𝐴 𝑥 : * not in comm 7 # PHASE 2 : c o u n t forwarding 8 f o r e a c h (𝑝𝑎𝑡ℎ, 𝑐𝑜𝑚𝑚) : 9 a s s e r t ( cond1 and cond2 ) 10 i [𝐴 𝑥 ]++ i f 𝐴 𝑡 : * in comm 11 c [𝐴 𝑥 ]++ i f 𝐴 𝑡 : * not in comm Listing 1: Inference algorithm, iterating over (𝑝𝑎𝑡ℎ, 𝑐𝑜𝑚𝑚) pairs by path index 𝑥, where 𝑝𝑎𝑡ℎ = 𝐴 1 , 𝐴 2 , ..., 𝐴 𝑛 , and 𝑐𝑜𝑚𝑚 = 𝑜𝑢𝑡𝑝𝑢𝑡 (𝐴 1 ). 𝐴 𝑥 ]++ i f 𝐴 𝑥 : * in comm 8 s [𝐴 𝑥 ]++ i f 𝐴 𝑥 : * not in comm 9 # PHASE 2 : c o u n t forwarding 10 f o r e a c h (𝑝𝑎𝑡ℎ, 𝑐𝑜𝑚𝑚) : 11 f o r e a c h x = n − 1 , . . . , 1 : 12 c [𝐴 𝑥 ]++ i f 𝐴 𝑥 +1 not in comm 13 e l s e : 14 i [𝐴 𝑗 ]++ f o r j in 1 , . . . , 𝐴 𝑥 +1 Listing 2: Alternative inference algorithm, iterating over (𝑝𝑎𝑡ℎ, 𝑐𝑜𝑚𝑚) pairs without conditions, where 𝑝𝑎𝑡ℎ = 𝐴 1 , 𝐴 2 , ..., 𝐴 𝑛 , and 𝑐𝑜𝑚𝑚 = 𝑜𝑢𝑡𝑝𝑢𝑡 (𝐴 1 ).</figDesc><table><row><cell>1</cell><cell>f o r x = 1 , . . . , N :</cell></row><row><cell>2</cell><cell># PHASE 1 : c o u n t tagging</cell></row><row><cell>3</cell><cell>f o r e a c h (𝑝𝑎𝑡ℎ, 𝑐𝑜𝑚𝑚) :</cell></row><row><cell>4</cell><cell>a s s e r t ( cond1 )</cell></row><row><cell cols="2">5 t [1 # I N I T</cell></row><row><cell>2</cell><cell>a s l i s t [ ] = silent | forward</cell></row><row><cell>3</cell><cell></cell></row><row><cell>4</cell><cell># PHASE 1 : c o u n t tagging</cell></row><row><cell>5</cell><cell>f o r e a c h (𝑝𝑎𝑡ℎ, 𝑐𝑜𝑚𝑚) :</cell></row><row><cell>6</cell><cell>f o r e a c h i = 1 , . . . , n :</cell></row><row><cell>7</cell><cell>t [</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>Table 5 :</head><label>5</label><figDesc>Assigned roles vs. classification results: ConfusionMatrices for tagging behavior per scenario.</figDesc><table><row><cell>assigned roles:</cell><cell></cell><cell cols="2">classification result:</cell><cell></cell></row><row><cell>alltf:</cell><cell cols="3">forward cleaner undecided</cell><cell>none</cell></row><row><cell>forward</cell><cell>10,427</cell><cell>0</cell><cell>0</cell><cell>2,104</cell></row><row><cell>forward (leaf)</cell><cell>0</cell><cell>0</cell><cell cols="2">0 60,420</cell></row><row><cell>alltc:</cell><cell cols="3">forward cleaner undecided</cell><cell>none</cell></row><row><cell>cleaner</cell><cell>0</cell><cell>578</cell><cell>0</cell><cell>124</cell></row><row><cell>cleaner (hidden)</cell><cell>0</cell><cell>0</cell><cell cols="2">0 11,829</cell></row><row><cell>cleaner (leaf)</cell><cell>0</cell><cell>0</cell><cell cols="2">0 60,420</cell></row><row><cell>random:</cell><cell cols="3">forward cleaner undecided</cell><cell>none</cell></row><row><cell>forward</cell><cell>2,400</cell><cell>0</cell><cell>0</cell><cell>1,091</cell></row><row><cell>cleaner</cell><cell>0</cell><cell>2,433</cell><cell>0</cell><cell>1,106</cell></row><row><cell>forward (hidden)</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>2,750</cell></row><row><cell>cleaner (hidden)</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>2,750</cell></row><row><cell>forward (leaf)</cell><cell>0</cell><cell>0</cell><cell cols="2">0 30,335</cell></row><row><cell>cleaner (leaf)</cell><cell>0</cell><cell>0</cell><cell cols="2">0 30,085</cell></row><row><cell>random+noise:</cell><cell cols="3">forward cleaner undecided</cell><cell>none</cell></row><row><cell>forward</cell><cell>2,294</cell><cell>0</cell><cell>63</cell><cell>1,134</cell></row><row><cell>cleaner</cell><cell>1</cell><cell>738</cell><cell>1,647</cell><cell>1,153</cell></row><row><cell>forward (hidden)</cell><cell>0</cell><cell>2</cell><cell>2</cell><cell>2,746</cell></row><row><cell>cleaner (hidden)</cell><cell>0</cell><cell>1</cell><cell>0</cell><cell>2,750</cell></row><row><cell>forward (leaf)</cell><cell>0</cell><cell>0</cell><cell cols="2">0 30,335</cell></row><row><cell>cleaner (leaf)</cell><cell>0</cell><cell>0</cell><cell cols="2">0 30,085</cell></row><row><cell>random-p:</cell><cell cols="3">forward cleaner undecided</cell><cell>none</cell></row><row><cell>forward</cell><cell>925</cell><cell>75</cell><cell>266</cell><cell>1,666</cell></row><row><cell>cleaner</cell><cell>0</cell><cell>1,355</cell><cell>0</cell><cell>1,663</cell></row><row><cell>forward (hidden)</cell><cell>0</cell><cell>52</cell><cell>0</cell><cell>3,265</cell></row><row><cell>cleaner (hidden)</cell><cell>0</cell><cell>47</cell><cell>0</cell><cell>3,217</cell></row><row><cell>forward (leaf)</cell><cell>0</cell><cell>0</cell><cell cols="2">0 30,480</cell></row><row><cell>cleaner (leaf)</cell><cell>0</cell><cell>0</cell><cell cols="2">0 29,940</cell></row><row><cell>random-pp:</cell><cell cols="3">forward cleaner undecided</cell><cell>none</cell></row><row><cell>forward</cell><cell>221</cell><cell>72</cell><cell>279</cell><cell>2,341</cell></row><row><cell>cleaner</cell><cell>0</cell><cell>610</cell><cell>0</cell><cell>2,386</cell></row><row><cell>forward (hidden)</cell><cell>0</cell><cell>14</cell><cell>0</cell><cell>3,322</cell></row><row><cell>cleaner (hidden)</cell><cell>0</cell><cell>19</cell><cell>0</cell><cell>3,267</cell></row><row><cell>forward (leaf)</cell><cell>0</cell><cell>0</cell><cell cols="2">0 30,480</cell></row><row><cell>cleaner (leaf)</cell><cell>0</cell><cell>0</cell><cell cols="2">0 29,940</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head>Table 6 :</head><label>6</label><figDesc>Assigned roles vs. classification results: ConfusionMatrices for forwarding behavior per scenario.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0">BGP collectors used: RIPE: rrc00-26, RouteViews: route-views{2,3,4,6}, amsix, chicago, chile, eqix, flix, gorex, isc, kixp, jinx, linx, napafrica, nwax, phoix, telxatl, wide, sydney, saopaulo, sg, perth, peru, sfmix, siex, soxrs, mwix, rio, fortaleza, gixa, bdix, bknix, uaeix, Isolario: Alderaan, Dagobah, Korriban, Naboo, Taris, PCH: 236 collectors.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We would like to thank our shepherd, Neil Spring, and the anonymous reviewers for useful and constructive feedback. We would also like to thank Italo Cunha and Ethan Katz-Bassett for providing access to the PEERING test bed. This work has been partially funded by NSF grant CNS-1855614, the European Research Council (ERC) Starting Grant ResolutioNet (ERC-StG-679158), BMBF BI-FOLD 01IS18025A and 01IS18037A, and performed while the first author held an NRC Research Associateship award at the Naval</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Scenario Impact</head><p>In this section, we explain the impact of the different scenarios on the inference of tagging and forwarding behavior, respectively. Thereby, we contrast the assigned roles against classification results with the help of confusion matrices, as provided in the tables below. Where necessary, we also include the information (hidden) if the assigned role is hidden (Section 5.1.2), and (leaf) if the forwarding behavior is assigned to a leaf AS (Section 5. <ref type="bibr">1.3)</ref>. Recall that each scenario uses the AS paths from 𝑑 𝑀𝑎𝑦21 as a substrate which includes 72,951 ASes, among which are 60,420 leaf ASes and 766 collector peers. In the following, we provide a selection of results. For a complete list, see Tables <ref type="table">5 and 6</ref> in the appendix.</p><p>alltf: Let us consider the scenario alltf where all ASes are assigned the role tagger-forward and the visibility is maximized: The algorithm is able to attribute a correct tagging behavior to more than 95% of the ASes. For the remaining 2,954 ASes, the algorithm cannot generate pre-existing knowledge for neighboring ASes due to the race condition limitation of our algorithm as described in Section 5.2.1. Thus, there are no counters and the inference returns none.</p><p>When we look at the forwarding behavior in the same scenario, we see that more than 60k ASes are leaf ASes, and are therefore not attributed a forwarding behavior: Given those ASes that are not leaf, the algorithm is able to correctly classify more than 83% (10,427) as forward.</p><p>alltc: In this scenario, all ASes are tagger-cleaner. Since all ASes are cleaners, we correctly infer the tagging behavior of all 766 collector peers: The remaining ∼72k ASes are hidden behind the those peers and thus fall into none. Next, we look at the forwarding behavior in the same scenario: From the 766 tagger collector peers, 578 are followed by other collector peers in the AS-level graph. Recall, the algorithm first determines the tagging behavior of all peers, and then uses them as downstream taggers to determine their forwarding behavior. 124 peer ASes (as well as 11,829 transit ASes) are never followed by another peer AS, thus they fall into none. The remaining 64 peer ASes appear as leaf and are included in the set of 60,420 leaf ASes.</p><p>random: Next, we look at the tagging behavior in the random scenario where, due to lack of ground truth, we assign roles uniformly at random. Since there are 72,951 ASes in the data set, each tagging role (tagger, silent) occurs approximately ∼36k times: Given the distribution of roles in this scenario, around ∼13k tagger ASes and ∼13k silent ASes are hidden behind a cleaner. From the remaining ∼23k ASes, more than 90% (∼22k) are correctly assigned to the respective class, while for ∼1.5k ASes the algorithm fails to generate pre-existing knowledge.</p><p>random+noise: Thus far, our algorithm is able to correctly infer the tagging and forwarding behavior of ASes and avoids (mis)classifying hidden ASes. In the following, we show how the inferences change when the same random scenario (same seed to randomly assign roles) is augmented with noise: Here, 1,647 (or ∼68%) of cleaner ASes are labeled undecided compared to the random scenario.</p><p>random-p: Lastly, we consider the random scenario where around 50% of the tagger ASes are randomly chosen to tag selectively, i.e., not on provider links but on all other links (including collectors). This results in the following distribution of tagging roles: selective ∼18k, tagger ∼18k, and around 36k silent ASes. </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><forename type="first">Larry</forename><surname>Blunk</surname></persName>
			<affiliation>
				<orgName type="collaboration">RFC 6396.</orgName>
			</affiliation>
		</author>
		<author>
			<persName><forename type="first">Craig</forename><surname>Labovitz</surname></persName>
			<affiliation>
				<orgName type="collaboration">RFC 6396.</orgName>
			</affiliation>
		</author>
		<author>
			<persName><forename type="first">Manish</forename><surname>Karir</surname></persName>
			<affiliation>
				<orgName type="collaboration">RFC 6396.</orgName>
			</affiliation>
		</author>
		<ptr target="https://rfc-editor.org/rfc/rfc6396.txt" />
		<title level="m">Multi-Threaded Routing Toolkit (MRT) Routing Information Export Format</title>
				<imprint>
			<date type="published" when="2011-10">2011. Oct. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">Jay</forename><surname>Borkenhagen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Randy</forename><surname>Bush</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ron</forename><surname>Bonica</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Serpil</forename><surname>Bayraktar</surname></persName>
		</author>
		<idno type="DOI">10.17487/RFC8642</idno>
		<ptr target="https://doi.org/10.17487/RFC8642" />
	</analytic>
	<monogr>
		<title level="j">Policy Behavior for Well-Known BGP Communities. RFC</title>
		<imprint>
			<biblScope unit="volume">8642</biblScope>
			<date type="published" when="2019-08">2019. Aug. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<ptr target="https://www.caida.org/catalog/datasets/as-relationships/" />
		<title level="m">CAIDA. 2021. AS Relationships</title>
				<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Remotely Triggered Black Hole Filtering -Destination Based and Source Based</title>
		<ptr target="http://www.cisco.com/c/dam/en_us/about/security/intelligence/blackhole.pdf." />
		<imprint>
			<date type="published" when="2005">2005. 2005</date>
		</imprint>
		<respStmt>
			<orgName>CISCO ; Cisco White Paper</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<ptr target="https://www.cmand.org/communityusage/." />
		<title level="m">CMAND. 2021. AS-Level BGP Community Usage Classification</title>
				<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Twelve years in the evolution of the internet ecosystem</title>
		<author>
			<persName><forename type="first">Amogh</forename><surname>Dhamdhere</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Constantine</forename><surname>Dovrolis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Transactions on Networking</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1420" to="1433" />
			<date type="published" when="2011">2011. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">On BGP Communities</title>
		<author>
			<persName><forename type="first">Benoit</forename><surname>Donnet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Olivier</forename><surname>Bonaventure</surname></persName>
		</author>
		<idno type="DOI">10.1145/1355734.1355743</idno>
		<ptr target="https://doi.org/10.1145/1355734.1355743" />
	</analytic>
	<monogr>
		<title level="m">ACM SIGCOMM CCR</title>
				<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Detecting Peering Infrastructure Outages in the Wild</title>
		<author>
			<persName><forename type="first">Vasileios</forename><surname>Giotsas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christoph</forename><surname>Dietzel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georgios</forename><surname>Smaragdakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anja</forename><surname>Feldmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arthur</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emile</forename><surname>Aben</surname></persName>
		</author>
		<idno type="DOI">10.1145/3098822.3098855</idno>
		<ptr target="https://doi.org/10.1145/3098822.3098855" />
	</analytic>
	<monogr>
		<title level="m">ACM SIGCOMM</title>
				<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Inferring Complex AS Relationships</title>
		<author>
			<persName><forename type="first">Vasileios</forename><surname>Giotsas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><surname>Luckie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bradley</forename><surname>Huffaker</surname></persName>
		</author>
		<author>
			<persName><surname>Claffy</surname></persName>
		</author>
		<idno type="DOI">10.1145/2663716.2663743</idno>
		<ptr target="https://doi.org/10.1145/2663716.2663743" />
	</analytic>
	<monogr>
		<title level="m">ACM IMC</title>
				<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Petros Gigis, Lefteris Manassakis, Christoph Dietzel, Stavros Konstantaras, and Xenofontas Dimitropoulos. 2020. O Peer, Where Art Thou? Uncovering Remote Peering Interconnections at IXPs</title>
		<author>
			<persName><forename type="first">Vasileios</forename><surname>Giotsas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Nomikos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vasileios</forename><surname>Kotronis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pavlos</forename><surname>Sermpezis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE/ACM ToN</title>
				<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Inferring BGP Blackholing Activity in the Internet</title>
		<author>
			<persName><forename type="first">Vasileios</forename><surname>Giotsas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georgios</forename><surname>Smaragdakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christoph</forename><surname>Dietzel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philipp</forename><surname>Richter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anja</forename><surname>Feldmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arthur</forename><surname>Berger</surname></persName>
		</author>
		<idno type="DOI">10.1145/3131365.3131379</idno>
		<ptr target="https://doi.org/10.1145/3131365.3131379" />
	</analytic>
	<monogr>
		<title level="m">ACM IMC</title>
				<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">An Analysis of BGP Convergence Properties</title>
		<author>
			<persName><forename type="first">G</forename><surname>Timothy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gordon</forename><surname>Griffin</surname></persName>
		</author>
		<author>
			<persName><surname>Wilfong</surname></persName>
		</author>
		<idno type="DOI">10.1145/316194.316231</idno>
		<ptr target="https://doi.org/10.1145/316194.316231" />
	</analytic>
	<monogr>
		<title level="m">ACM SIGCOMM CCR</title>
				<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">Jakob</forename><surname>Heitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Job</forename><surname>Snijders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keyur</forename><surname>Patel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ignas</forename><surname>Bagdonas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nick</forename><surname>Hilliard</surname></persName>
		</author>
		<ptr target="https://rfc-editor.org/rfc/rfc8092.txt" />
	</analytic>
	<monogr>
		<title level="j">BGP Large Communities Attribute. RFC</title>
		<imprint>
			<biblScope unit="volume">8092</biblScope>
			<date type="published" when="2017-02">2017. Feb. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName><surname>Isolario</surname></persName>
		</author>
		<ptr target="https://www.isolario.it/." />
		<imprint>
			<date type="published" when="2021">2021. 2021</date>
		</imprint>
	</monogr>
	<note>Isolario project</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Keep your Communities Clean: Exploring the Routing Message Impact of BGP Communities</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Krenc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Beverly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georgios</forename><surname>Smaragdakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CoNEXT</title>
				<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">Tony</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ravi</forename><surname>Chandra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><forename type="middle">S</forename><surname>Traina</surname></persName>
		</author>
		<ptr target="https://rfc-editor.org/rfc/rfc1997.txt" />
	</analytic>
	<monogr>
		<title level="j">BGP Communities Attribute. RFC</title>
		<imprint>
			<date type="published" when="1996">1996. 1997. Aug. 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">End-to-End Routing Behavior in the Internet</title>
		<author>
			<persName><forename type="first">Vern</forename><surname>Paxson</surname></persName>
		</author>
		<idno type="DOI">10.1145/248156.248160</idno>
		<ptr target="https://doi.org/10.1145/248156.248160" />
	</analytic>
	<monogr>
		<title level="m">ACM SIG-COMM</title>
				<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<ptr target="https://www.pch.net/" />
		<title level="m">PCH. 2021. Packet Clearing House</title>
				<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">Yakov</forename><surname>Rekhter</surname></persName>
			<affiliation>
				<orgName type="collaboration">RFC 4271.</orgName>
			</affiliation>
		</author>
		<author>
			<persName><forename type="first">Susan</forename><surname>Hares</surname></persName>
			<affiliation>
				<orgName type="collaboration">RFC 4271.</orgName>
			</affiliation>
		</author>
		<author>
			<persName><forename type="first">Tony</forename><surname>Li</surname></persName>
			<affiliation>
				<orgName type="collaboration">RFC 4271.</orgName>
			</affiliation>
		</author>
		<ptr target="https://rfc-editor.org/rfc/rfc4271.txt" />
		<title level="m">A Border Gateway Protocol 4 (BGP-4)</title>
				<imprint>
			<date type="published" when="2006-01">2006. Jan. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Peering at Peerings: On the Role of IXP Route Servers</title>
		<author>
			<persName><forename type="first">Philipp</forename><surname>Richter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georgios</forename><surname>Smaragdakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anja</forename><surname>Feldmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nikolaos</forename><surname>Chatzis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Boettger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Walter</forename><surname>Willinger</surname></persName>
		</author>
		<idno type="DOI">10.1145/2663716.2663757</idno>
		<ptr target="https://doi.org/10.1145/2663716.2663757" />
	</analytic>
	<monogr>
		<title level="m">ACM IMC</title>
				<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<ptr target="http://ris.ripe.net/" />
		<title level="m">RIPE. 2021. RIS -RIPE Network Coordination Centre</title>
				<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">University of Oregon RouteViews project</title>
		<author>
			<persName><surname>Routeviews</surname></persName>
		</author>
		<ptr target="http://www.routeviews.org/" />
		<imprint>
			<date type="published" when="2021">2021. 2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">PEERING: Virtualizing BGP at the Edge for Research</title>
		<author>
			<persName><forename type="first">Brandon</forename><surname>Schlinker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><surname>Arnold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Italo</forename><surname>Cunha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ethan</forename><surname>Katz-Bassett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th International Conference on Emerging Networking Experiments And Technologies</title>
				<meeting>the 15th International Conference on Emerging Networking Experiments And Technologies</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="51" to="67" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">ARTEMIS: Neutralizing BGP hijacking within a minute</title>
		<author>
			<persName><forename type="first">Pavlos</forename><surname>Sermpezis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vasileios</forename><surname>Kotronis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Petros</forename><surname>Gigis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xenofontas</forename><surname>Dimitropoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Danilo</forename><surname>Cicalese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alistair</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alberto</forename><surname>Dainotti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Transactions on Networking</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="2471" to="2486" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Use of BGP Large Communities</title>
		<author>
			<persName><forename type="first">Job</forename><surname>Snijders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Heasley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martijn</forename><surname>Schmidt</surname></persName>
		</author>
		<ptr target="https://rfc-editor.org/rfc/rfc8195.txt" />
		<imprint>
			<date type="published" when="2017-06">2017. June 2017</date>
		</imprint>
	</monogr>
	<note>RFC 8195.</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">BGP Communities: Even more Worms in the Routing Can</title>
		<author>
			<persName><forename type="first">Florian</forename><surname>Streibelt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Franziska</forename><surname>Lichtblau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Beverly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anja</forename><surname>Feldmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cristel</forename><surname>Pelsser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georgios</forename><surname>Smaragdakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Randy</forename><surname>Bush</surname></persName>
		</author>
		<idno type="DOI">10.1145/3278532.3278557</idno>
		<ptr target="https://doi.org/10.1145/3278532.3278557" />
	</analytic>
	<monogr>
		<title level="m">ACM IMC</title>
				<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Profiling BGP Serial Hijackers: Capturing Persistent Misbehavior in the Global Routing Table</title>
		<author>
			<persName><forename type="first">Cecilia</forename><surname>Testart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philipp</forename><surname>Richter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alistair</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alberto</forename><surname>Dainotti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Clark</surname></persName>
		</author>
		<idno type="DOI">10.1145/3355369.3355581</idno>
		<ptr target="https://doi.org/10.1145/3355369.3355581" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Internet Measurement Conference (IMC &apos;19)</title>
				<meeting>the Internet Measurement Conference (IMC &apos;19)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="420" to="434" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">BGP Support for Four-Octet Autonomous System (AS) Number Space. RFC 6793</title>
		<author>
			<persName><forename type="first">Quaizar</forename><surname>Vohra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Enke</forename><surname>Chen</surname></persName>
		</author>
		<idno type="DOI">10.17487/RFC6793</idno>
		<ptr target="https://doi.org/10.17487/RFC6793" />
		<imprint>
			<date type="published" when="2012-12">2012. Dec. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
