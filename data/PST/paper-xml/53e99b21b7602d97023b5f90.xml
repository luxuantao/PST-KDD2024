<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">On Objects and Events *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Patrick</forename><forename type="middle">Th</forename><surname>Eugster</surname></persName>
							<email>patrick.eugster@epfl.ch</email>
						</author>
						<author>
							<persName><forename type="first">Rachid</forename><surname>Guerraoui</surname></persName>
							<email>rachid.guerraoui@epfl.ch</email>
						</author>
						<author>
							<persName><forename type="first">Christian</forename><forename type="middle">Heide</forename><surname>Damm</surname></persName>
							<email>damm@daimi.au.dk</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Distributed Programming Laboratory Swiss Federal Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<address>
									<postCode>CH-1015</postCode>
									<settlement>Lausanne</settlement>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Distributed Programming Laboratory Swiss Federal Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<address>
									<postCode>CH-1015</postCode>
									<settlement>Lausanne</settlement>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Aarhus</orgName>
								<address>
									<postCode>8200</postCode>
									<settlement>Aarhus N</settlement>
									<country key="DK">Denmark</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">On Objects and Events *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">5C6E8AD19D9B1F80D59BCF4732C5279A</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:47+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C.2 [Computer Systems Organization]: Computer Communication</term>
					<term>C.2.4 [Computer Communication Networks]: Distributed Systems-distributed applications</term>
					<term>D.3 [Software]: Programming Languages</term>
					<term>D.3.3 [Programming Languages]: Language Constructs and Features-concurrent programming structures Java, type, publish/subscribe, event, linguistic support</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper presents linguistic primitives for publish/subscribe programming using events and objects. We integrate our primitives into a strongly typed objectoriented language through four mechanisms: (1) serialization, (2) multiple subtyping, (3) closures, and (4) deferred code evaluation. We illustrate our primitives through Java, showing how we have overcome its respective lacks.</p><p>A precompiler transforms statements based on our publish/subscribe primitives into calls to specifically generated typed adapters, which resemble the typed stubs and skeletons generated by the rmic precompiler for remote method invocations in Java.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION 1.1 RPC et al.</head><p>One of the most popular styles of distributed programming relies on extending the notion of invocation to a distributed context, i.e., offering some form of remote procedure call (RPC) <ref type="bibr" target="#b7">[7]</ref>. The integration of this distributed interaction style with an object-oriented programming language has been thoroughly studied, e.g., <ref type="bibr" target="#b41">[41,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b42">42,</ref><ref type="bibr" target="#b10">10]</ref>. More recently, Java <ref type="bibr" target="#b29">[29]</ref> has introduced its own variant, the remote method invocation (RMI) <ref type="bibr" target="#b61">[61]</ref>, through a precompiler approach.</p><p>By using the same abstraction for distributed interactions as for local ones, RPC and its derivatives integrate naturally with a language, and make distributed programming look simple.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Publish/Subscribe</head><p>Motivated by the observation that RPC is not always the best solution, the integration of alternative distributed interaction styles, like asynchronous RPC (e.g., <ref type="bibr" target="#b65">[65,</ref><ref type="bibr" target="#b43">43]</ref>) or the tuple space <ref type="bibr" target="#b28">[28]</ref> paradigm (e.g., <ref type="bibr" target="#b45">[45]</ref>) with a language have also been studied. More recently, Oki et al. <ref type="bibr" target="#b50">[50]</ref> have pointed out the existence of many distributed "event-based" applications for which a publish/subscribe interaction style is very appealing, thanks to its strong decoupling of participants in (1) time (participants don't have to be up at the same time), <ref type="bibr" target="#b2">(2)</ref> space (participants don't have to know each other), and (3) flow (data reception/sending does not block participants).</p><p>Several authors suggested libraries for distributed interaction based on publish/subscribe (e.g., JavaSpaces <ref type="bibr" target="#b27">[27]</ref>, SmartSockets <ref type="bibr" target="#b16">[16]</ref>, Distributed Asynchronous Collections <ref type="bibr" target="#b24">[24]</ref>), also implementing standardized API's (CORBA Event &amp; Notification Services <ref type="bibr" target="#b53">[53,</ref><ref type="bibr" target="#b51">51]</ref>, Java Message Service <ref type="bibr" target="#b31">[31]</ref>, etc.), but to our knowledge, very little effort has been done to inherently support publish/subscribe in a language.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Linguistic Support for Publish/Subscribe</head><p>The goal of this paper is precisely to explore the ramifications of integrating publish/subscribe primitives into a strongly typed object-oriented language. <ref type="foot" target="#foot_0">1</ref>Our linguistic primitives have been designed based on four simple principles: 2 LP1 Type safety. In a strongly typed language, strong typing is enforced in local interactions, and as far as possible, should also be enforced for remote object interaction. Type errors should be recognized at compilation, alleviating the already cumbersome debugging of distributed applications.</p><p>LP2 Encapsulation preservation. Events are to be considered as objects, and hence as instances of abstract types. Their implementation details should not be revealed, and should not be systematically used to describe subscription criteria.</p><p>LP3 Application-defined events. Events should be definable by the application, with minimal imposed design choices.</p><p>LP4 Composable event semantics. To express some form of Qualities of Service (QoS), different semantics should be assignable to events, and these semantics should be composable.</p><p>Combining these principles is not straightforward. For instance, combining (1) content-based subscription based on event properties and (2) preservation of encapsulation of event objects (i.e., not systematically expressing subscriptions as attribute-value pairs, ruling out any query languages such as SQL) is already commonly pictured as a contradiction per se <ref type="bibr" target="#b38">[38]</ref>. Further complexity is added by requiring (3) transparency of subscriptions, i.e., giving the underlying publish/subscribe system full access to subscription criteria in order to optimize the filtering of events (e.g, by factoring out redundancies between subscriptions of different subscribers <ref type="bibr" target="#b1">[1]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">Contributions</head><p>We present two language primitives for the expression of type-based publish/subscribe programming: publish and subscribe.</p><p>Instead of introducing a new programming language, we illustrate our three primitives through the well-known general-purpose Java language. Along the way, we identify a set of four mechanisms, which provided by a language, strongly enforce its support for publish/subscribe; roughly serialization, multiple subtyping, closures, and deferred code evaluation. These are however not to be viewed as sufficient nor as necessary conditions, as shown by Java, which does not incorporate all these mechanisms.</p><p>Our solution for the Java language relies on a precompiler, which transforms our specific constructs to invocations on specifically generated typed adapters.</p><p>In that sense, our precompiler can be seen as the publish/subscribe counterpart to the Java RMI compiler, and we but rather to explore the ramifications of an integration approach (see <ref type="bibr">Section 7)</ref>. 2 These principles have resulted from our previous experiences around objects and publish/subscribe (e.g., <ref type="bibr" target="#b24">[24,</ref><ref type="bibr" target="#b22">22]</ref>), including applications we have helped devising in the domains of banking and telecommunications. Obviously, these principles are not exclusive; other application domains might identify different requirements.</p><p>show that the two interaction paradigms are in fact not contradictory, but that a combination of these two paradigms can be seen as a powerful tool for devising distributed applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.5">Status</head><p>Our primitives were implemented using the infrastructure offered by the Distributed Asynchronous Computing Environment (DACE). This infrastructure has already been the base for a library approach to integrating publish/subscribe with Java <ref type="bibr" target="#b24">[24,</ref><ref type="bibr" target="#b22">22]</ref> along similar principles, making however use of other mechanisms to their achievement, namely reflection and parametric polymorphism together with serialization.</p><p>The goal of this paper is to emphasize language issues, leaving aside issues related to distribution; the implementation of our distributed architecture, its underlying algorithms and their performance and scalability have been addressed in other publications, e.g., <ref type="bibr" target="#b23">[23,</ref><ref type="bibr" target="#b21">21]</ref>.</p><p>Supported by our two complementary approaches, we believe that the current work is not intrinsically tied to our architecture, but could be deployed on most existing publish/subscribe systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.6">Roadmap</head><p>This paper is structured as follows: Section 2 introduces the type-based publish/subscribe variant which has allowed us to combine objects and events. Section 3 discusses the semantics of our primitives and their syntax in Java. Section 4 presents the implementation of our primitives. Section 5 discusses several issues, like design alternatives. Section 6 discusses related work. Section 7 concludes this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">TYPE-BASED PUBLISH/SUBSCRIBE</head><p>This section introduces our model of events and objects, and the type-based variant of publish/subscribe intrinsically coupled with that model. We depict the effects of subscribing to types in Java, and give a rough idea of our primitives for publish/subscribe interaction along with a simple example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Model</head><p>The core idea underlying our integration of publish/subscribe with objects consists in viewing events as first class citizens, and subscribing to these events by explicitly specifying their type.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.1">Obvents</head><p>By considering events as first class citizens, that is, not as specific constructs (e.g., <ref type="bibr" target="#b30">[30]</ref>), but as specific applicationdefined objects, we strongly enforce the support of LP3. To emphasize the object nature of events, we call these event objects, or to abbreviate notation, simply obvents.</p><p>Similarly to <ref type="bibr" target="#b50">[50]</ref>, we distinguish mainly between two categories of objects, but introduce two further (sub)categories.</p><p>Unbound objects: Unbound objects are locality-unbound, that is, their semantics do not depend on any local resource. Such objects could be serialized and transferred to another address space (in <ref type="bibr" target="#b50">[50]</ref> these are termed data objects).</p><p>Obvents: Obvents represent a specific kind of unbound objects. Such objects are used to notify events, and can in a nested way contain other unbound objects Bound objects: These objects are locality-bound, i.e., they are tied to an address space and remain in that address space during their entire lifetime. They may make use of local resources (service objects in <ref type="bibr" target="#b50">[50]</ref>).</p><p>Subscribers: Potentially, any bound object could take the role of subscriber, but in general, only particular objects subscribe to obvents.</p><p>An obvent class can best be pictured as a factory for instances incarnating notifications for events of the same kind, i.e., from the same event source. A notification from such an event source is reified through an obvent; basically an object which is serialized and sent over the wire to a set of destinations, where each copy is deserialized.</p><p>Note that we do not introduce a specific publisher type. Any object (bound but also unbound) can publish obvents. The subscribers introduced will mainly be used for illustration purposes. As we will see shortly, the application will not be explicitly dealing with such objects, but will view these as obvent handlers, or simply handlers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.2">Effects of Publishing Obvents</head><p>Publishing an obvent o can thus be understood as some form of distributed object creation, where the created objects are clones of o which acts as template. More precisely, a distinct copy of a published obvent is created for each subscriber:</p><p>Obvent Global Uniqueness: Suppose an obvent o1 published from an address space a1: if an address space a2 contains two subscribers s1 and s2, these will receive references to two new distinct clones of o1, say o2 and o3.</p><p>Obvent Local Uniqueness: In the above scenario, if the address space a1 also contains a subscriber s3, then s3 will receive a reference to a new obvent o4.</p><p>A subscription can in that sense be seen as a contract for hosting objects created as copies of published objects. Note that if the same obvent is published twice, two distinct copies will be created again for every subscriber.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.3">Type-Based Subscription</head><p>By using the type of obvents as basic subscription criterion, we strongly enforce the integration of publish/subscribe interaction into a language in a way that respects type safety (LP1 ): by matching the notion of event kind with that of an event type, i.e., using the type scheme of the programming language as subscription scheme, the type of the received events is known, and compile-time type checks can be performed.</p><p>Figure <ref type="figure">1</ref> illustrates the intuitive idea underlying our approach, through a recurring example for publish/subscribe interaction, which is the stock trade application. A possible scenario is the following. The stock market, here denoted by p1, publishes stock quotes, and receives purchase requests. These can be "spot price" requests, which have to be satisfied immediately, or "market price" requests for purchasing quotes only at the end of the day, or once another given criterion is fulfilled. Latter requests can however expire, and for the broker's (such as p2) convenience, an intermediate party (p3), e.g., a bank, might also handle such requests in behalf of her/him, for instance by issuing spot price requests to the stock market once the broker's criterion is satisfied.</p><p>Note that by subscribing to a type StockObvent, p3 receives all instances of its subtypes StockQuote and StockRequest, and hence all objects of type SpotPrice and MarketPrice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>StockRequest</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SpotPrice</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>StockObvent</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MarketPrice p1 p2 p3</head><p>Figure <ref type="figure">1</ref>: Type-based publish/subscribe</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Type-Based Publish/Subscribe in Java</head><p>In many strongly typed object-oriented languages like C++ <ref type="bibr" target="#b19">[19]</ref> or Eiffel <ref type="bibr" target="#b46">[46]</ref>, the inheritance hierarchy determines the conformance (subtype) relation. In such type schemes, the notions of type (abstract type, type definition, interface, signature) and class (concrete type, type implementation) are identical.</p><p>The Java type system is inspired by the separation of inheritance and subtyping in the sense of <ref type="bibr" target="#b15">[15]</ref>. To avoid problems known from multiple inheritance, Java offers only single inheritance, yet introduces multiple subtyping through interfaces. In Java, types can be defined in the following two ways:</p><p>Explicit declaration: A type can be explicitly declared by declaring an interface, which can subtype several superinterfaces: an interface I1 which extends another interface I2 represents a subtype of the type declared by I2.</p><p>Implicit declaration: Defining a class C implicitly declares a type, and at the same time gives the class which implements it. If a class C1 inherits from another class C2, then the type defined by C1 is a subtype of the type of C2.</p><p>A class can subtype multiple interfaces: for any interface I implemented by a class C, the type defined by C is a subtype of I.</p><p>Note that a class C which implements a single interface I without adding any new methods also defines a new type, which is a subtype of I's type.</p><p>As a consequence of the intertwining of types and classes in Java, it must be possible to subscribe to interfaces as well as to classes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Expressing Type-Based Publish/Subscribe</head><p>To express event-based distributed interaction based on the type-based publish/subscribe paradigm, we introduce two primitives. We give here an abstract overview of these, and give more details in Section 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.1">Publishing</head><p>An obvent o is published through a primitive publish, leading to the simple syntax:</p><formula xml:id="formula_0">publish o;</formula><p>This statement triggers the creation of a copy of o for every subscribed object, according to the rules described beforehand. In that sense, the publish primitive can be seen as a distributed variant of the new primitive found in many languages. Syntactically, the publish primitive bears more resemblances with the very common return primitive, or the throw primitive for the raising of an exception in Java.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.2">Subscribing</head><p>In attempt to satisfy LP1, LP2, and LP4, we chose the obvent type as the basic subscription criterion. A pure static subscription scheme, like topics (e.g., <ref type="bibr" target="#b50">[50,</ref><ref type="bibr" target="#b59">59,</ref><ref type="bibr" target="#b2">2,</ref><ref type="bibr" target="#b16">16,</ref><ref type="bibr" target="#b64">64]</ref>, also called subjects) or types in our case, has been shown to offer only limited expressiveness. This observation has motivated content-based publish/subscribe (e.g., <ref type="bibr" target="#b1">[1,</ref><ref type="bibr" target="#b17">17,</ref><ref type="bibr" target="#b12">12,</ref><ref type="bibr" target="#b58">58]</ref>, also called property-based publish/subscribe), where a subscription takes properties of obvents into consideration. When subscribing, the desired properties are expressed through a predicate, or filter. We thus combine a subscription to a type T with the declaration of such a filter:</p><formula xml:id="formula_1">Subscription s = subscribe (T t) {...} {...};</formula><p>The first expression enclosed in brackets represents a block, provided by the application, which expresses how to handle obvents of type T (represented by a formal argument called t here) in order to return a boolean value indicating whether the obvent is of interest or not. The second expression is a block which is evaluated every time an event successively passes the filtering phase, and corresponds thus to the subscriber object. The same formal argument t represents the event of interest in this case. A subscription handle is returned by a subscription expression. It allows, among other things, the activation and deactivation of a subscription.</p><p>The motivation of capturing the code for filtering in a closure is to delay its evaluation: to avoid redundant filtering, as well as wasting network bandwidth, it is interesting to apply filters on foreign hosts, which are possibly entirely dedicated to filtering. By gathering filters of several subscribers on a given host, a compound filter can be generated which factors out redundancies between these individual filters. By doing so, performance can be significantly improved (e.g., <ref type="bibr" target="#b1">[1]</ref>).</p><p>The use of a closure also to capture the code applied for the evaluation of received events enables the avoiding of a callback mechanism, which greatly enforces type safety and has the great advantage of regrouping code related to a subscription in a single succinct expression.</p><p>Note that one can easily subscribe to all obvents of a type T by doing something like the following: Subscription s = subscribe (T t) { return true; } {...};</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.3">Example</head><p>Consider the stock market example introduced above. Stock quotes are published by the stock market, and are received by brokers. Stock quotes carry a set of attributes, like the amount and price of the stock quotes. Figure <ref type="figure" target="#fig_0">2</ref> shows the Java code for simple stock quotes and stock quote subscribers.</p><p>The stock market can publish a stock quote obvent by doing something like the following:</p><p>StockQuote q = new StockQuote("Telco Mobiles", 80, 10); publish q; Below, we give an example of a subscription, which expresses an interest in all stock quotes of the Telco group with a price less than 100$: Subscription s = subscribe (StockQuote q) { return (q.getPrice() &lt; 100 &amp;&amp; q.getCompany().indexOf("Telco") != -1); } { System.out.print("Got offer: "); System.out.println(q.getPrice()); };</p><p>It can easily be seen that the stock quote published in the above example satisfies these criteria.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">JAVAPS</head><p>This section illustrates mechanisms which strongly support the implementation of publish/subscribe in a language according to our model. We discuss the syntax and precise semantics of our language primitives, and informally show how these fit into the Java language (leading to a new instance of StatementWithoutTrailingSubstatement, and a new PrimaryNoNewArray expression, ยง 14.5 and ยง 15.8 in <ref type="bibr" target="#b29">[29]</ref> respectively). We refer to this extension as Javaps. The classes and interfaces related to our approach are regrouped in a package java.pubsub.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Inside Obvents</head><p>Obvents are objects that are serialized, sent over the wire, and deserialized. Java incorporates a default serialization mechanism, which can be exploited by subtyping java.io.Serializable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Basic Type</head><p>The basic Java Obvent type (Figure <ref type="figure" target="#fig_1">3</ref>) thus subtypes that type. This eases the implementation of our obvent model in general, and we state this as a first mechanism which enforces the realization of our model in a language:  A languageprovided serialization/deserialization mechanism eases the transformation of event objects into conveyable low-level messages. This principle strongly supports LP3 : with a default serialization mechanism, developers can be relieved from the burden of implementing specific operations or hooks in their obvents. The design phase of obvents can be cut down to the essential meaning of the event.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Obvent Semantics</head><p>Obvents can also be viewed as reified messages, or message objects. According to the different semantics that such messages can manifest, several semantics are imaginable for obvents. The first kind of characteristics are the delivery semantics associated with obvents; an expression of quality of delivery.</p><p>Unreliable: When such an obvent is published, there is no guarantee that it will be received by any subscriber.</p><p>There is only a best-effort attempt to deliver it. This is assumed by default.</p><p>Reliable: Once successfully published, a reliable obvent will be received by any subscriber that is "up for long enough". A subscriber which never fails will eventually deliver every such obvent.</p><p>Certified: With such obvents, even if a subscriber temporarily disconnects or fails, it will eventually deliver the obvent.</p><p>Totally ordered: Obvents can furthermore be notified in a total order to the subscribers: roughly spoken, two subscribers s1 and s2 which deliver two obvents o1 and o2 both deliver o1 and o2 in the same order (we also term this subscriber-side order ).  FIFO ordered: Two obvents o1 and o2 that are published through the same object are delivered to all objects whose subscription matches both o1 and o2, and in the same order they were published (publisher-side order ).</p><p>Causally ordered: This type of obvents are delivered in the order they are published, as determined by the happensbefore relationship <ref type="bibr" target="#b39">[39]</ref>. Note that the notion of event in <ref type="bibr" target="#b39">[39]</ref> represents either a message send or receive. These translate respectively to the publishing and receiving of an obvent in our case (global order ).</p><p>Further semantics, called transmission semantics, can be associated to obvents. These govern the handling of obvents when they are in transit, also with respect to other obvents.</p><p>Prioritary: Obvents can have priorities, that is, the delivery of obvents can be delayed to defer to obvents with a higher priority.</p><p>Timely: Similarly, obvents can be delayed to prioritize more recent obvents. Also, obvents might expire, and become obsolete.</p><p>These different semantics are not all mutually exclusive. For instance, obvents can be certified and have some notion of priority, or be certified and totally ordered at the same time. It appears that contradictions reside for instance between reliable and simultaneously timely limited obvents, as well as between total, fifo or causal order and priorities. In the above cases, the first type takes precedence (Figure <ref type="figure" target="#fig_2">4</ref> illustrates the dependencies between the different semantics). Note however that we have not yet explored all possible ramifications and combinations, and that the identification and implementation of these semantics is an ongoing task.</p><p>Note also that for any kind of order expressed by an obvent type, its instances satisfy that order with respect to instances of the same type, its subtypes, and supertypes with that same order only.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Priority Timely</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Certified</head><p>Causal Order Total Order </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Unreliable</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.3">Expressing Obvent Semantics</head><p>In our model, such characteristics are associated with the obvents, and should thus be part of these obvents. Indeed, it makes most sense that every obvent reflects its semantics (which can be seen as a context), such that a correct handling of the obvent can be assured at every moment of the transfer. Since instances of an obvent type are bound to the same obvent source, they present the same characteristics. In addition, the obvent type is the only contract between publishers and subscribers, and we have thus chosen to use subtyping to express this limited form of QoS, mandated by LP4. Figure <ref type="figure" target="#fig_1">3</ref> shows the Java types corresponding to the different semantics outlined above.</p><p>Since several characteristics can be combined, this scheme requires some mechanism of expressing multiple subtyping.</p><p>LM2 Multiple subtyping. While simple subtyping eases the expression and addition of different event semantics, multiple subtyping enforces the composition of such semantics.</p><p>This is independent of whether it is assured through some form of multiple inheritance as offered by C++, Cecil <ref type="bibr" target="#b14">[14]</ref> or Eiffel, through subtyping abstract types (e.g., interfaces in Java), or even mixins (e.g., Flavors <ref type="bibr" target="#b47">[47]</ref>, Ada <ref type="bibr" target="#b35">[35]</ref>). The term multiple subtyping here simply denotes the ability of expressing multiple specialization relationships.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The publish Primitive</head><p>An obvent can be published, which means that it will be asynchronously sent to any concerned subscriber. Following the Java language specification grammar <ref type="bibr" target="#b29">[29]</ref>, based on a LALR(1) syntax, we introduce a new statement:</p><formula xml:id="formula_2">PublishStatement: publish Expression ;</formula><p>Here Expression is a non-null expression of type Obvent, as opposed to most classes relying on Java serialization: in Java, a serializable root type is often "faked" by using formal parameters of the root type java.lang.Object, yet expecting an object of a specific type java.io.Serializable and throwing an exception if the actual argument is not of that type. We prefer detecting such type errors at compilation. Nevertheless, this primitive can throw an exception of type CannotPublishException, signalling any problems in transmitting the obvent. Figure <ref type="figure" target="#fig_1">3</ref> summarizes the basic exceptions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">The subscribe Primitive</head><p>As briefly shown in Section 2, we introduce a second primitive subscribe, to express a subscription.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Syntax</head><p>A subscription expression combines the subscription to a type T with (1) a closure declaration representing a filter, where the full signature of that first closure is the following: boolean (T t) {...} and (2) the declaration of a second closure representing the handler, where the full signature is the following:</p><formula xml:id="formula_3">void (T t) {...}</formula><p>A subscription expression hence has the following syntax in Java (details are given in Figure <ref type="figure" target="#fig_3">5</ref>):  </p><formula xml:id="formula_4">SubscriptionExpression: subscribe ( ObventType</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">Handlers</head><p>Handlers are very close to the closures known from Smalltalk (block closure) or Cecil (anonymous function), and represent an intuitive way of handling callbacks from the underlying event dissemination system.</p><p>In languages like Java, which lack support for closures (or higher order functions <ref type="bibr" target="#b49">[49]</ref>), such callbacks are often implemented by having the application provide a callback object with a callback method. The argument of such a method represents the effective event of interest. In Java, an interface implemented for callbacks is commonly called a listener. To enforce strong typing, the type of the formal argument of a callback method in a listener must conform to the type of the event of interest. This can easily be achieved in languages which support parametric polymorphism <ref type="bibr" target="#b22">[22]</ref>, but in any case leads to isolating the event handling in a separate class.</p><p>The use of a closure on the other hand enables the regrouping of all code related to a subscription in a single succinct expression, and since handlers are a specific type of closures, a language which already provides some general form of closures can easily support the integration of subscription expressions.</p><p>LM3 Closures. With handlers being a specific type of closures, a language which provides general closures supports the expression of safely typed subscription primitives.</p><p>By viewing these closures as objects, the handlers take the role of the subscriber objects outlined in Section 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.3">Filters</head><p>Akin to handlers, filters are closures with a specific signature. Besides the concentration of subscription-related code, the use of such a syntax in the case of filters is further conducted by the desire of confining the code for the filtering, while still "revealing" it. This enables (1) the migration of such code to foreign hosts, as well as (2) the factoring out of redundancies between filters of different subscribers gathered on individual hosts.</p><p>The compilation of these filters is hence deferred, in a sense similar to the paradigm of deferred code evalution known from two-level programming <ref type="bibr" target="#b48">[48]</ref> (or generalized to more than two levels, multi-stage programming as advocated by MetaML <ref type="bibr" target="#b63">[63]</ref>).</p><p>LM4 Deferred code evaluation. A mechanism providing some form of deferred code evaluation can easily support the expression of safely typed content-based filters, in a way that supports optimizations (avoiding redundant queries) and the checking of the code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.4">Restrictions on Closures</head><p>"Local" closures vary in the degree of self-containment they advocate: the first class block closure in Smalltalk can use any variables in scope at the closure declaration (at compilation), and these variables are bound for the entire lifetime of the closure, even if it is executed in a context where some of these variables are not visible. To avoid some of this binding of variables, an anonymous class in Java can only access final variables from the enclosing block in addition to the non-local variables (members) in scope at compilation. The handlers described previously adopt these semantics.</p><p>Our "distributed" use of closures in the case of filters requires even more restrictions. Any variable used in a filter might reference an object (which might reference an object, etc.) of a type which is not known on a host where that filter is evaluated, forcing the transfer of code. Similarly, any method invocation, whether performed on a variable or as a static call, might force the transfer of further code. In the case of Java, a class can be compiled if the types it uses are present as byte code, and it is very difficult to foresee the effects of calls to classes based on their byte code. Thus, method invocations (including the use of constructors) should be cut down to the essential ones, in order to avoid filters using opaque code as well as types unknown on filtering hosts.</p><p>Invocations: The only method invocations allowed in a filter are (nested) invocations on its variables.</p><p>Variables: The only variables allowed in a filter are (1) the formal argument representing a filtered obvent, (2) local variables, and (3) final outer variables (from the enclosing block or class members). Latter two types of variables are restricted to primitive types (e.g., int) and their object-counterparts (e.g., java.lang.Integer), including java.lang.String.</p><p>These restrictions enforce the location-independency of the expressed filter, offering the possibility of applying it at a more favourable stage (e.g., a remote host) to reduce network load and filtering cost. If the filter declares any local variables of unallowed types, or performs invocations differing from the ones described above, its migration might be problematic. In such a scenario, the filter is applied locally (cf. next section).</p><p>Note that the above restrictions do not fully guarantee the location-independency of the filter, e.g., any Java object referred to by a variable gives access to a meta-object representing its class (java.lang.Class), through which many "undesired" things can be done. We will come back to this particular case in Section 5. At the present, we are investigating a precise semantical definition of filters, aimed at ensuring their "mobility".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.5">Thread Policies</head><p>Once an obvent has reached a process hosting an interested subscriber, it is delivered by executing the handler. This is comparable to an RPC-style invocation of an arbitrary method of a bound object, in the sense that the thread which is used in that target object's process for the invocation is blocked until completion of that invocation; the main difference being that an invocation made in the context of an RPC can yield a reply which is sent back to the invoker. There are different levels of concurrency which can be supported. In our context, we distinguish between two kinds of thread policies:</p><p>Multi-threading: A handler can be executed concurrently for any number of obvents. These semantics are assumed by default, except in the case of ordered obvents.</p><p>Single-threading: A handler never processes more than one obvent at a time.</p><p>One could easily extend this set, for instance by a thread policy ensuring that only one instance of the same obvent class is processed at a time.</p><p>Note that Java already integrates mechanisms for concurrency control with which the two above policies can be achieved. To ensure that never more than one obvent is processed at a time by a handler, one could easily write: However, in languages which do not integrate any concurrency mechanisms, to obtain more sophisticated concurrency control, or to involve the publish/subscribe system into concurrency issues with the goal of optimizing concurrency, thread policies should be made explicit. In our case, it seems most straightforward to express these through the subscription handle, since such an object uniquely defines a subscription. To control such parameters, corresponding methods are added to the Subscription type shown in Figure <ref type="figure" target="#fig_1">3</ref>.</p><p>In general, the expression of QoS has been probably the most tedious task when devising our language primitives. Such QoS seem to become increasingly important when programming at a distributed scale, but there is to our knowledge only very little work on how to inherently express QoS in a programming language, in an other way than through an API.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Managing Subscriptions</head><p>As explained above, the subscribe primitive creates an expression representing a subscription. Such a subscription must then be activated, triggering the effective action of subscribing, and later on, deactivated, representing the action of unsubscribing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.1">Activating a Subscription</head><p>A subscription is activated by a call to the activate() method on the corresponding subscription handle. This method throws a CannotSubscribeException exception if the subscription can not be issued, e.g., if the subscription is already activated. Subscription s = ...; s.activate(); ... The variant of the activate() method with a long argument is used in combination with certified events. Indeed, with such events, the lifetime of subscriptions might exceed the actual lifetime of the hosting process. When recovering from a failure, or reactivating an intentionally deactivated subscription, the concerned subscription can be (locally) uniquely identified by using this method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.2">Deactivating a Subscription</head><p>Similarly, the action of unsubscribing is expressed through a deactivate() method defined on subscription handles, which can throw an exception of type CannotUnsubscribeException.</p><p>... s.deactivate(); ... As an immediate consequence, subscriptions can be cancelled also from inside a subscription, i.e., its associated handler. This is interesting when a particular event, from the point of view of the concerned subscriber, supersedes any following events, or signals the absence of any further events. Since a handler can only handle final variables declared in its enclosing block however, the variable that the subscription handle is assigned to must be declared outside of that block, for instance as a private attribute of the enclosing class.</p><p>The activation/deactivation of subscriptions can be interleavingly performed an unlimited number of times. Corresponding exceptions are also thrown upon an attempt of (de-)activating an already (de-)activated subscription.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">IMPLEMENTATION ISSUES</head><p>This section depicts how we have implemented our primitives for publish/subscribe interaction in Java in a way that satisfies the principles stated in Section 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">General Implementation Choices</head><p>Along the lines of extensions to the Java language like Pizza <ref type="bibr" target="#b49">[49]</ref> (adding parametric polymorphism, algebraic types and closures) or <ref type="bibr" target="#b8">[8]</ref> (for multi-methods), we refrain from incorporating any new features into the Java virtual machine, as well as from extending a given compiler, or even modifying existing packages and classes of the Java environment. Instead, we advocate the use of a precompiler as the publish/subscribe counterpart to the rmic compiler for generation of remote invocation proxies <ref type="bibr" target="#b61">[61]</ref>.</p><p>Since remote invocations benefit from an inherent support from the language, they require no specific primitives, and hence only remotely invocable Java types have to be compiled with rmic. Besides generating obvent-specific classes, our psc precompiler translates publish/subscribe statements and expressions to calls to these classes, and must hence be run not only on obvent types, but also on any class making use of our primitives.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">DACE Distributed Architecture</head><p>The Distributed Asynchronous Computing Environment (DACE) infrastructure has been initially developed as a general architecture to support publish/subscribe interaction, and has later been specialized for type-based publish/subscribe. The DACE architecture can be roughly pictured as relying on a class-based dissemination <ref type="bibr" target="#b22">[22]</ref>. Every obvent class is mapped to a dissemination channel, representing a multicast group, which we refer to as multicast class. In the DACE architecture, such multicast classes are then implemented with different multicast protocols with guarantees ranging from strong guarantees (exploiting a broad variety of primitives from group communication <ref type="bibr" target="#b6">[6]</ref>, e.g., for causal ordering) to primitives with weaker guarantees but strong focus on scalability (network-level protocols like IP multicast <ref type="bibr" target="#b18">[18]</ref> or its derivates, e.g., <ref type="bibr" target="#b54">[54,</ref><ref type="bibr" target="#b33">33,</ref><ref type="bibr" target="#b26">26]</ref>, or gossip-based protocols, e.g., <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b62">62,</ref><ref type="bibr" target="#b23">23]</ref>).</p><p>We have adopted a reflexive approach, by using specific channels to disseminate protocol messages, like subscription/unsubscription requests, or the advertisement of the publishing of obvents. Such messages are obvents themselves, and allow distributed processes to learn about other, possibly new, multicast classes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Typed Adapters</head><p>To avoid making the Java virtual machine distributionaware, and also to exploit our class-based dissemination, we adopt the adapter <ref type="bibr" target="#b50">[50]</ref> concept. Adapters are intermediate entities between the communication system and the application, whose role consists mainly in mediating between events in a serialized representation and objects.</p><p>In our case, adapters mainly mediate between serialized generic objects and strongly typed obvents. In other terms, adapters are type-specific, and are generated for each obvent class by the psc compiler. For any given obvent class C psc generates a class CAdapter with code for publishing/subscribing instances of C. Similarly, to support subscriptions to abstract types (interfaces), for any given abstract obvent type I, psc generates a class IAdapter with code for subscribing to instances of I. Figure <ref type="figure">6</ref> illustrates an adapter for a given obvent type T. <ref type="foot" target="#foot_1">3</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Translating Primitives</head><p>With our psc precompiler, publish/subscribe statements and expressions are translated to method invocations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.1">Publishing</head><p>Since a published obvent is disseminated through the adapter for its dynamic type, which is only known at runtime, a PublishStatement can not be directly transformed to a call to publish on the corresponding adapter class. Hence, we add a publish() method to the Obvent interface </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.3">Filters</head><p>The handling of filters represents the most complex task during precompilation. A filter whose statements deviate from the guidelines which strongly enforce its mobility according to the previous section, is similarly transformed into an anonymous class representing a unary predicate of type LocalFilter shown in Figure <ref type="figure" target="#fig_5">7</ref>, and applied locally. A subscription expression such as what is done for application-specific handlers (ASHs) <ref type="bibr" target="#b20">[20]</ref>, low-level message filters, except that those are applied locally and expressed in a neutral specification language, while our filters promote the use of the native language syntax. Our precompiler generates two tree-like constructs, which are more specific than for instance the parse trees used in Smalltalk <ref type="bibr" target="#b57">[57]</ref>.</p><p>Invocation tree: First, a representation of the invocations made in the filter is generated: the root represents the filtered obvent, and every node represents a method invocation. A leaf node stands for the outcome of a condition on the value obtained by applying the methods of the nodes on the path downto that leaf in a nested fashion (nodes can also represent attribute accesses).</p><p>Evaluation tree: Second, a tree representing the relationships between the leaves of the former tree and the outcome of the filtering is generated: its nodes represent mainly logical combinations of its subnodes aso., and the leaves are references to the leaves of the former tree.</p><p>This information is stored in an instance of RemoteFilter (Figure <ref type="figure" target="#fig_5">7</ref>).</p><p>A general description of our approach to instrumenting Java with first class parse trees, based on a generalization of deferred code evaluation expressed through filters, will be the subject of a future paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">DISCUSSION</head><p>This section discusses several issues, including two design alternatives as well as interoperability issues. We also contrast our type-based publish/subscribe with RMI, pointing our the fact that the two paradigms are not contradictory but complementary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Fork</head><p>We have explored several alternative primitives for the expression of publish/subscribe based on our obvent model, among which we outline what we believe to be the two which are most likely to come into mind. This first alternative for the expression of publish/subscribe based on our obvent model makes use of a fork-similar primitive for notification delivery.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1">Obvent Variable</head><p>A new notification is assigned to a variable, and a block representing a handler is executed every time a new value is put into the variable:</p><formula xml:id="formula_5">T t = null; t = subscribe {...} {...}; /* here t is null */</formula><p>This primitive could, in the case of Java, be implemented similarly to the solution presented throughout this paper. However this syntax makes it difficult to express unsubscriptions, a problem which does not occur in the case of the fork primitive: when spawning a new coroutine, the execution of the corresponding block takes place once only. Here, notifications are delivered continuously, leading to a repeated evaluation of the handler. By the absence of a subscription handle, a subscription can not be referred to from outside of its expression. Unsubscriptions would have to be dealt with inside the handlers, either through a parameterless unsubscription statement, or by having the handler return a boolean value after each obvent evaluation to signal whether the subscription is to be pursued. Either variant leads to a restrictive solution, where a subscription can only be cancelled after the next event has been delivered. While this can be desirable in many cases, it should not be the only possibility of cancelling a subscription.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2">Filter</head><p>Note that alternatively, with this model, one could think of implementing filters by giving the application the possibility of instantiating the future variable t, and in that sense, using it simultaneously as a template object:</p><formula xml:id="formula_6">T t = new T(...); t = subscribe {...};</formula><p>However, filtering events by matching them against template objects offers only little expressiveness: template objects are usually compared attribute-wise with events, making the matching of an attribute against a range of values, or, since attributes might themselves be objects, the matching only of a nested attribute difficult to express. Alternatively, the matching can be performed inside the template object, which renders the matching opaque, disabling any optimizations targeted at avoiding redundancies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Callback</head><p>As outlined in Section 3, a very common way of implementing a callback in a language such as Java consists in asking the application to provide a callback object implementing a given interface.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">Listener</head><p>This second considered alternative, which is promoted by nearly all Java API's for common publish/subscribe engines, introduces a specific listener like the Subscriber type presented in Figure <ref type="figure" target="#fig_5">7</ref>. This type, which, as depicted, is inherently implemented by every anonymous class representing a handler, would in this case be explicitly implemented and instantiated by the application to catch event notifications, e.g.: Subscriber sr = ...; Subscription s = subscribe (T t) { / *filter* / } sr;</p><p>The declared notify() method with its weakly typed argument does however not address LP1. A dynamic overriding of the notify() method, i.e., adding a variant with an argument type T that subtypes Obvent in order to subscribe to instances of T public void notify(T t) {...} would also allow handlers for several obvent types to be provided by the same subscriber, yet does not add type safety.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">Dispatching</head><p>Through this dynamic overriding, the notify method becomes a so-called multi-method. Yet, dispatching (method selection) in Java, unlike CLOS <ref type="bibr" target="#b36">[36]</ref> or Cecil, does not support multi-methods. Dispatching in Java, similarly than in C++, offers dynamic uni-dispatch, i.e., the class of the object referenced by an invoked variable (representing its dynamic type) is determined at runtime, but only static multidispatch. This prevents a typed solution based on dynamic overriding of the notify() method desribed above.</p><p>There have been several approaches to overcoming Java's lack for multi-methods, ranging from using reflection over modifying the compilation to extending the virtual machine. Another common technique is also given by double dispatch <ref type="bibr" target="#b34">[34]</ref>, which could however not be applied in this case, like some of the other solutions, unless a specific subscriber TSubscriber is generated and implemented for every obvent type T that a subscriber type handles. This would however remove the main advantage of this approach based on listeners, which consists namely in giving much freedom to the developer in defining event handlers for any types (including subtypes of subscribed types). In addition, the required dynamic multi-dispatch is a high price to pay, especially if only introduced for the use with publish/subscribe primitives, also given the fact that it does not improve type safety.</p><p>Note furthermore, that the scenario of multiple subscriptions of a subscriber to the same type, or through subtyping related types, is not straightforward to handle: are the different filters combined, and is the same event delivered several times? On the other hand, the callback approach enables an easy expressing of thread policies: by subtyping a SingleThreadSubscriber, the developer could express the desire of processing only one instance of a given obvent type at a time. Multiple subtyping, introduced to express a limited form of QoS for obvents, could here be used again to express complex event handling semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Obvents vs Objects</head><p>In languages which provide a default serialization mechanism through a type which must be subtyped, e.g., Java (java.io.Serializable), obvents are instances of that type. Hence in a general case, as shown by our distinction between bound/unbound objects, not every object can be an obvent: the opposite would have not only mandated the type system to be singly-rooted (requiring extensions to languages like C++ and Ada), but also to integrate the before-mentioned serialization mechanism at that very root like in Smalltalk, possibly including a publish() method.</p><p>How about an obvent publishing obvents, or subscribing to obvents? The former case does not bear any particular dangers, and should thus not be prohibited. Similarly, subscriptions could also be issued inside obvents, since a subscription expression does not affect the object in which it was declared. The effective handlers/subscribers can not be referenced, and hence can not be passed around, and in particular, can not be attributes of obvents. To underline this characteristic of subscriptions, the Subscription type is not serializable.</p><p>Note that in the second presented design alternative, any application object can be defined as a subscriber by implementing a given interface, that is, a notify() method. Equipping all objects with the ability of subscribing would have translated to adding that notify() method to the root type. Furthermore, subscribers could be attributes of obvents. The danger of endless recursions whenever an ob-vent subscribes to itself could however easily be banned, by not considering a subscription as part of the state of a subscribed obvent: once published, the copies of an obvent would have to reissue any subscriptions performed by their "master copy".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">RPC and Publish/Subscribe</head><p>Originally introduced as remote procedure call (RPC) <ref type="bibr" target="#b7">[7]</ref>, remote invocations have been quickly applied to objectoriented languages, leveraging some form of remotely accessible entity, e.g., guardians in Argus <ref type="bibr" target="#b41">[41]</ref> (its follow-up CLU <ref type="bibr" target="#b42">[42]</ref>), network objects in Modula-3 <ref type="bibr" target="#b11">[11]</ref> and Obliq <ref type="bibr" target="#b10">[10]</ref> (every object is potentially a network object), and of course remote objects in Java RMI <ref type="bibr" target="#b61">[61]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.1">Invocations vs Events</head><p>There are mainly two differences between such remote invocations and our event-based model:</p><p>Interaction styles: The RPC model promotes the same abstraction for remote object interactions as for local ones. By doing so, (synchronous) RPC is inherently integrated with the language, and requires little more support than that very inherent interaction abstraction. In contrast, our model promotes two interaction styles, namely (1) event-based publish/subscribe interaction remotely, and</p><p>(2) method invocations locally, making the application developer more aware of distribution.</p><p>Object passing semantics: With remote invocations, there are two possible ways of passing objects, namely (1) by reference, i.e., a proxy object is created in the receiver's address space, and (2) by value. The distinction goes along the notion of the granularity mediated in Section 2, i.e., "large" locality-bound objects interact via remote invocations, where the invocation arguments are "small" unbound objects or references to "large" remotely invocable objects. In contrast, when using our obvent-based model, objects are primarily passed by value.</p><p>However, publish/subscribe and RPC are not contradictory, but complement each other. A combination of both represents a very powerful tool for devising distributed applications, e.g., by passing object references with obvents.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.2">Hand in Hand</head><p>A collaboration between the two interaction styles can be illustrated by reconsidering the simple example given in Section 2. Though the use of a publish/subscribe interaction for the dissemination of stock quotes seems appropriate by scaling easily to many brokers, it might seem more appropriate to use a sychronous interaction with the stock market when purchasing stock options, e.g., a remote method invocation.</p><p>Figure <ref type="figure">8</ref> shows how Java RMI and publish/subscribe can work together, hand in hand. To correctly handle the serialization of remote objects (in the sense of RMI), the RMI serialization mechanism is used, enabling a transparent integration of RMI and publish/subscribe. However, the current implementation of Java RMI presents a severe caveat, which becomes especially visible through this integration with events. In fact, the distributed garbage collection keeps a remotely accessible object from being garbage collected as long as there is at least one proxy for that object. When publishing an event containing a reference to a remote object, such a proxy is created for each subscriber, which can sum up to several 1000's. Every time a proxy is garbage collected, the Java virtual machine hosting the represented object is notified. Consequently, if a single subscriber crashes, the remote object will never be garbage collected. With a "weaker" implementation of Java RMI, such as the one proposed in <ref type="bibr" target="#b13">[13]</ref>, this problem could be circumvented.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">100% Pure Content</head><p>Java, like most statically typed languages, uses name equivalence of types, which means that two types are compatible only if declared so. If two different types T1 and T2 have exactly the same parents in their type hierarchy, instances of T1 can not be assigned to variables of T2 or vice versa. A type scheme which allows this is said to enforce structural equivalence of types.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5.1">Reflection</head><p>When subscribing to obvents it might be of interest in certain cases to subscribe to any obvents which implement a given method (specified by its name and formal/actual parameters) irrespective of the types of these obvents. Java, just like Smalltalk, provides introspection mechanisms <ref type="bibr" target="#b60">[60]</ref>, that enable the querying of objects for their type, and also members (attributes and methods, including facilities for dynamically reading/writing former ones and invoking latter ones). Every Java object gives access to these features through a method getClass(), which would enable the expression of a purely content-based subscription like the following: Now, any obvent type which implements a given method getPrice() (e.g., the StockQuote class) could be captured by this filter, and the following handler could similarly dynamically extract information from a conforming event. This feature, though giving much flexibility to the application developer, is somehow opposed to our requirement for type safety (LP1 ), and we therefore do not consider introspection as a necessary language mechanism, though our current Java prototype supports such untyped filters. As shown by most currently existing engines, the lack for reflection in programming languages can be made up easily by providing specific event types which explicitly implement a form of introspection, like the self-describing messages advocated by <ref type="bibr" target="#b50">[50]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5.2">Tuples: Back to the Roots</head><p>Another way of achieving structural equivalence could consist in coming back to the concept of tuples used in Linda <ref type="bibr" target="#b28">[28]</ref> (see next section), one of the spiritual ancestors of the publish/subscribe pardigm. In that sense, the publish primitive could be extended in order to accept any number of actual arguments: which could all be used as subscription criteria by the filter, and could all be accessed by the handler.</p><p>Though one can argue that languages which do not inherently support structural equivalence should not be instrumented with a distributed interaction style that relies on that paradigm, we believe that this could lead to a very appealing style of distributed programming; requiring however a more complex filtering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Language Integration vs Interoperability</head><p>Language integration seems to be somehow contradictory with the requirement of interoperability expressed in <ref type="bibr" target="#b50">[50]</ref>. Publish/subscribe has however nowadays found application in various contexts (e.g, virtual reality <ref type="bibr" target="#b30">[30]</ref>, group collaboration <ref type="bibr" target="#b44">[44]</ref>, real time <ref type="bibr" target="#b25">[25]</ref>), mainly due to its scalability properties achieved through strong decoupling of participants.</p><p>Just like CORBA <ref type="bibr" target="#b52">[52]</ref> has added interoperability to the RPC through a neutral interface description language (IDL), there have been several approaches to using a neutral event description language (EDL) to help adding interoperability to publish/subscribe. Proposals for such languages are plentiful, like the OMG's object definition language (ODL) used in the Cambridge Event Architecture <ref type="bibr" target="#b4">[4]</ref>, languages used in tuple space implementations, e.g., object interchange language (OIL) in Objective Linda <ref type="bibr" target="#b37">[37]</ref>, or more recently, XML.</p><p>We believe that such a specification language could help adding interoperability to our system, and that in that sense, the types in package java.pubsub can be seen as a Java mapping. However, since events are in our case not pictured as structures as in the above cases, but also encompass methods and thus code, an EDL can not by itself provide for interoperability. The issue of passing objects by value from one language to another has also been tackled in CORBA, and we are currently investigating on the impact of an application of those concepts to our system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RELATED WORK</head><p>Though publish/subscribe engines are plentiful, there has been only little work on integrating publish/subscribe interaction with an object-oriented programming language up to now. We first overview the two closest efforts, and then focus on linguistic support for alternative distributed interaction styles other than RPC, which has already been discussed previously.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Publish/Subscribe</head><p>Most event-based solutions focus less on language integration, and more on interoperability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.1">ECO</head><p>One approach to integrating event-based interaction with C++ is discussed in <ref type="bibr" target="#b30">[30]</ref>, but also starting from a general event model. The authors dissociate two ways of adding event semantics to an object-oriented language, namely (1) by extension with specific constructs and (2) by addition of specific classes, adopting the first approach. Their ECO (events + constraints + objects) model incorporates events as specific language constructs which are complementary to objects, and thus necessitate a considerable number of language add-ons. The use of a precompiler to handle these extensions is also mentioned, but <ref type="bibr" target="#b30">[30]</ref> gives no details about its implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.2">CEA</head><p>The Cambridge Event Architecture (CEA) <ref type="bibr" target="#b4">[4]</ref> promotes a publish/register/notify interaction style, where an intermediate event trader mediates between publishers and subscribers. The CEA is based on an interopable object model, in which events are described by the ODMG's object definition language (ODL), but alternative specification languages, like XML, are also mentioned. Events are typed according to the definition language, and C++ and Java mappings are mentioned. Filtering mechanisms are also included, however based on viewing the events as sets of attributes, forcing the application to define filters based on attribute-value pairs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Message Passing</head><p>Language integration has evolved along the communication paradigms. One of the first distributed interaction paradigms was message passing, consisting basically of a usually asynchronous send of messages (mainly for single sends, but also for addressing groups similar to publish), and a blocking receive primitive. Like many "distributed" interaction paradigms, message passing has also extensively been used first in parallel and concurrent programming. Early, mainly procedural and process-oriented languages, like Occam <ref type="bibr" target="#b56">[56]</ref> (using named unidirectional channels) or also SR <ref type="bibr" target="#b3">[3]</ref> (first only with semi-synchronous sends, later also with synchronous remote procedure calls), included some form of message passing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Tuple Spaces</head><p>The well-known tuple space paradigm <ref type="bibr" target="#b28">[28]</ref> represents the distributed interaction scheme which is closest to publish/subscribe.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.1">The Original</head><p>The tuple space, first introduced for parallel computing in Linda, can be viewed as a form of distributed shared memory, with the main difference being the structured form of data inserted into and retrieved from the tuple space: tuples inserted into a tuple space are sets of values, and tuples read from the space are specified as a set of formal and actual arguments, where former ones can be seen as placeholders defining the types of the corresponding elements, and latter ones define the values of the corresponding elements for a candidate tuple.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.2">Decoupling</head><p>The original tuple space in Linda was based on a form of name-based addressing, i.e., tuple elements could be strings carrying a specific name. This idea has been reused in the "original" publish/subscribe variant based on topics, and the possibility of using more than one name element in Linda has been straightforwardly transposed to topic hierarchies, expressing containment relationships on topics. In general, the publish/subscribe paradigm has been strongly influenced by the tuple space, more specifically by its strong decoupling of participants in time and in space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.3">Publish/Subscribe vs Tuple Space</head><p>Publish/subscribe further increases this decoupling by adding flow decoupling, that is, replacing the synchronous interaction (pulling) of the subscribers with an asynchronous notification mechanism. In fact, the original tuple space had three primitives, namely (1) out to push a tuple into the space (similarly to publish), (2) read to read a tuple without erasing it, and (3) in to withdraw a tuple from the space. Publish/subscribe adds an asynchronous callback mechanism, and by omitting an equivalence to in, sacrifices concurrency control to scalability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.4">Linguistic Support</head><p>There have been a series of attempts to transform the structured form of tuples to an object form, mainly by extending the exact type equivalence for tuple elements in Linda to the notion of subtyping. While early approaches to integrating the tuple space with an object language like <ref type="bibr" target="#b45">[45]</ref> (for Smalltalk) promoted tuples as sets of objects, later approaches, like <ref type="bibr" target="#b55">[55]</ref> (C++) or <ref type="bibr" target="#b37">[37]</ref> (Objective Linda) considered tuples, just like events in our case, as single first class citizens, and added some form of content-based matching based on templates. Very recently, callback mechanisms have also been added, e.g. JavaSpaces <ref type="bibr" target="#b27">[27]</ref>, TSpaces <ref type="bibr" target="#b40">[40]</ref> (both Java), supporting a publish/subscribe-like interaction. In contrast to our approach however, latter ones basically promote publish/subscribe interaction through some weakly typed first class channel, and advocate templatebased matching.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUDING REMARK</head><p>Throughout the history of computing, many paradigms have first been implemented as separate libraries, and have then made their way into programming languages. The monitor abstraction for concurrent programming introduced by Hoare <ref type="bibr" target="#b32">[32]</ref> for instance, was first implemented through a library before becoming a specific language construct (e.g., Portal <ref type="bibr">[9]</ref>). Nowadays, every Java object is potentially a monitor.</p><p>This evolution does however not apply to all paradigms, as can be shown again by Java, which currently only includes a limited form of pointers through a library (Reference in java.lang.ref), while one of main spiritual ancestors, C++, integrates pointers as a first class concept. This paper does not aim at advocating an integration vs a library approach to support publish/subscribe program-ming. Yet, we hope that based on the practical experience we are currently gathering with both our library approach <ref type="bibr" target="#b24">[24,</ref><ref type="bibr" target="#b22">22]</ref> and the present integration approach, we will be able to answer the question of which kind of approach is more adequate to achieve "object-oriented publish/subscribe".</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Stock quote notifications</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Obvents, exceptions, and subscriptions</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Dependencies between obvent semantics</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Precise syntax of subscription statements</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>final</head><label></label><figDesc>Object lock = new Object(); Subscription s = subscribe (T t) {...} { synchronized(lock) { /* handler */ } };</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Details of Obvent, and further types in java.pubsub</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>subscribe (T t) { /* filter */ } {...} is hence transformed into an invocation of the corresponding adapter class: If the depicted restrictions are respected, psc generates an intermediate representation of the filter, in a way similar to</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>Subscription s = subscribe (Obvent o) { ... Class c = o.getClass(); Method m = c.getMethod("getPrice", null); return m.invoke(o,null).equals(new Float(150)); ... } {...};</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The goal of this paper is not to advocate for a library vs an integration approach in the case of publish/subscribe,</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>Interestingly, the same parametric polymorphism applied to the first class adapters used in our library approach<ref type="bibr" target="#b24">[24]</ref>, can not be applied here due to the purely static nature of the adapters.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>Subscription s = subscribe (String company, float price, int amount, StockMarket market) { /* filter */ } { /* handler */ };</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">ACKNOWLEDGMENTS</head><p>Many ideas presented here have been refined through discussions with Andrew Black (Oregon Graduate Institute of Science and Technology), Joe Sventek (Agilent Laboratories, Edinburgh), Martin Odersky, Mathias Zenger, and Michel Schinz (Swiss Federal Institute of Technology, Lausanne), and Nicolas Ricci (Lombard &amp; Odier, Geneva). We would like to thank all the above-mentioned, as well as the anonymous reviewers, for their valuable comments and suggestions.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This work is partially supported by Agilent Laboratories and Lombard Odier &amp; Co. โ Christian is currently visiting the Swiss Federal Institute of Technology in Lausanne.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>is transformed into a call to the publish() method of o, provided that o's static type can be widened to Obvent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>o.publish();</head><p>Note that every obvent class must implement a public no-argument constructor, in order to enforce deserialization with Java's built-in mechanisms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.2">Subscriptions</head><p>By similarly transforming subscriptions to (static) calls to the corresponding obvent types, subscriptions to interfaces would be impossible. Hence, subscriptions, as well as unsubscriptions, are handled differently. In short, a subscription statement involving a type T is transformed to an invocation of one of the subscribe() methods in class TAdapter (possibly also OventAdapter in package java.pubsub), as shown in Figure <ref type="figure">6</ref>.</p><p>An instance of an anonymous class representing a subscriber is created from the handler of a subscription expression such as the following: subscribe (StockQuote q) { return (q.getPrice() &lt; 100 &amp;&amp; q.getCompany().indexOf("Telco") != -1); } { ... boolean bought = q.getMarket().buy(q.getCompany(), q.getPrice(), q.getAmount(), broker); ... }; ... Inversely, the subscribe primitive could be used with an arbitrary number of formal arguments, e.g,</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Matching Events in a Content-Based Subscription System</title>
		<author>
			<persName><forename type="first">M</forename><surname>Aguilera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Strom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sturman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Astley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Chandra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">18th ACM Symposium on Principles of Distributed Computing</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">iBus -a Software Bus Middleware for the Java Platform</title>
		<author>
			<persName><forename type="first">M</forename><surname>Altherr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Erzberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Maffeis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Workshop on Reliable Middleware Systems of the 13th IEEE Symposium On Reliable Distributed Systems</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The Evolution of the SR Language</title>
		<author>
			<persName><forename type="first">G</forename><surname>Andrews</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Olsson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1986-04">Apr. 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Generic Support for Distributed Applications</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bacon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Moody</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bates</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hayton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mcneil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Seidel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Spiteri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="68" to="76" />
			<date type="published" when="2000-03">Mar. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">K</forename><surname>Birman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hayden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Ozkasap</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Budiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Minsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bimodal Multicast. ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="41" to="88" />
			<date type="published" when="1999-05">May 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Reliable Communication in Presence of Failures</title>
		<author>
			<persName><forename type="first">K</forename><surname>Birman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Joseph</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="47" to="76" />
			<date type="published" when="1987-02">Feb. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Implementing Remote Procedure Calls</title>
		<author>
			<persName><forename type="first">A</forename><surname>Birrel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Nelson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="39" to="59" />
			<date type="published" when="1984-02">Feb. 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Parasitic Methods: Implementation of Multi-Methods for Java</title>
		<author>
			<persName><forename type="first">J</forename><surname>Boyland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Castagna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th ACM Conference on Object-Oriented Programming Systems, Languages and Applications</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">PORTAL Language Description</title>
		<author>
			<persName><forename type="first">A</forename><surname>Businger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Number 198 in LNCS</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A Language with Distributed Scope</title>
		<author>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">14th ACM Symposium on Principles of Distributed Computing</title>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The Modula-3 Type System</title>
		<author>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Donahue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jordan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kalsow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">16th ACM Symposium on Principles of Programming Languages</title>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Architectures for an Event Notification Service Scalable to Wide-area Networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Carzaniga</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998-12">Dec. 1998</date>
		</imprint>
		<respStmt>
			<orgName>Politecnico di Milano</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A More Efficient RMI for Java</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Ch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Nester</surname></persName>
		</author>
		<author>
			<persName><surname>Haumacher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM 1999 Conference on Java Grande</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">The Cecil Language Specification and Rationale: Version 2.0</title>
		<author>
			<persName><forename type="first">C</forename><surname>Chambers</surname></persName>
		</author>
		<idno>UW-CS Technical Report 93-03-05</idno>
		<imprint>
			<date type="published" when="1995-12">Dec. 1995</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science and Engineering, University of Washington</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Inheritance is not Subtyping</title>
		<author>
			<persName><forename type="first">W</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Canning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">17th ACM Symposium on Principles of Programming Languages</title>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><surname>Corporation</surname></persName>
		</author>
		<ptr target="http://www.talarian.com/" />
		<title level="m">Everything You Need to Know About Middleware: Mission-Critical Interprocess Communication (White Paper)</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Exploiting an Event-Based Infrastructure to Develop Complex Distributed Systems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Cugola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">D</forename><surname>Nitto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fuggetta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">10th International Conference on Software Engineering</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Multicast Routing in Datagram Internetworks and Extended LANs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Deering</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Cheriton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="85" to="110" />
			<date type="published" when="1990-05">May 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">The Annotated C++ Reference Manual</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ellis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Stroustrup</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Design and Implementation of a Modular, Flexible, and Fast System for Dynamic Protocol Composition</title>
		<author>
			<persName><forename type="first">D</forename><surname>Engler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wallach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Kaashoek</surname></persName>
		</author>
		<idno>TM-552</idno>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
		<respStmt>
			<orgName>Massachusetts Institute of Technology, Laboratory for Computer Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Effective Multicast Programming in Large Scale Distributed Systems</title>
		<author>
			<persName><forename type="first">P</forename><surname>Th</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Eugster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Boichat</surname></persName>
		</author>
		<author>
			<persName><surname>Guerraoui</surname></persName>
		</author>
		<idno>DSC/2001/003</idno>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
		<respStmt>
			<orgName>Swiss Federal Institute of Technology, Lausanne</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Content-Based Publish/Subscribe with Structural Reflection</title>
		<author>
			<persName><forename type="first">P</forename><surname>Th</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Eugster</surname></persName>
		</author>
		<author>
			<persName><surname>Guerraoui</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">6th Usenix Conference on Object-Oriented Technologies and Systems</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Lightweight Probabilistic Broadcast</title>
		<author>
			<persName><forename type="first">P</forename><surname>Th</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Eugster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Guerraoui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A.-M</forename><surname>Handurukande</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kermarrec</surname></persName>
		</author>
		<author>
			<persName><surname>Kouznetsov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Dependable Systems and Networks</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Distributed Asynchronous Collections: Abstractions for Publish/Subscribe Interaction</title>
		<author>
			<persName><forename type="first">P</forename><surname>Th</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Eugster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Guerraoui</surname></persName>
		</author>
		<author>
			<persName><surname>Sventek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">14th European Conference on Object-Oriented Programming</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Fail-Aware Publish/Subscribe in Erlang</title>
		<author>
			<persName><forename type="first">C</forename><surname>Fetzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">4th International Erlang User Conference</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A Reliable Multicast Framework for Light-Weight Sessions and Application Level Framing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Floyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Jacobson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mccanne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">G</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Transactions on Networking</title>
		<imprint>
			<date type="published" when="1996-11">Nov. 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">JavaSpaces Principles, Patterns, and Practice</title>
		<author>
			<persName><forename type="first">E</forename><surname>Freeman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hupfer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Arnold</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Generative Communication in Linda</title>
		<author>
			<persName><forename type="first">D</forename><surname>Gelernter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="80" to="112" />
			<date type="published" when="1985-01">Jan. 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">The Java Language Specification</title>
		<author>
			<persName><forename type="first">J</forename><surname>Gosling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Joy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Steele</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
	<note>Second Edition</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Filtering and Scalability in the ECO Distributed Event Model</title>
		<author>
			<persName><forename type="first">M</forename><surname>Haahr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Meier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Nixon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Cahill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Jul</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">5th International Symposium on Software Engineering for Parallel and Distributed Systems</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">M</forename><surname>Happner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Burridge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><surname>Java Message</surname></persName>
		</author>
		<author>
			<persName><surname>Service</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
		<respStmt>
			<orgName>Sun Microsystems Inc.</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Monitors: An Operating System Structuring Concept</title>
		<author>
			<persName><forename type="first">C</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="549" to="557" />
			<date type="published" when="1974-10">Oct. 1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Log-Based Receiver-Reliable Multicast for Distributed Interactive Simulation</title>
		<author>
			<persName><forename type="first">H</forename><surname>Holbrook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Singhal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Cheriton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Conference on Applications, Technologies, Architectures, and Protocols for Computer Communication</title>
		<imprint>
			<date type="published" when="1995">1995. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">A Simple Technique for Handling Multiple Polymorphism</title>
		<author>
			<persName><forename type="first">D</forename><surname>Ingalls</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Object-Oriented Programming Systems, Languages and Applications</title>
		<imprint>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">International Organization for Standardization. Ada 95 Reference Manual -The Language -The Standard Libraries</title>
		<idno>ANSI/ISO/IEC-8652:1995</idno>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">CommonLisp the Language</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><genName>Jr</genName></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>Digital Press</publisher>
		</imprint>
	</monogr>
	<note>second edition</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Object-Oriented Distributed Programming with Objective Linda</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kielmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">First International Workshop on High Speed Networks and Open Distributed Platforms</title>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Messages vs. Objects for Application Integration</title>
		<author>
			<persName><forename type="first">P</forename><surname>Koenig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="44" to="45" />
			<date type="published" when="1999-04">Apr. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Time, Clocks, and the Ordering of Events in a Distributed System</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="558" to="565" />
			<date type="published" when="1978-07">July 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Tspaces: The Next Wave</title>
		<author>
			<persName><forename type="first">T</forename><surname>Lehman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Laughry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wyckoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hawaii International Conference on System Sciences</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Distributed Programming in Argus</title>
		<author>
			<persName><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="300" to="312" />
			<date type="published" when="1988-03">Mar. 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">A History of CLU</title>
		<author>
			<persName><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="133" to="147" />
			<date type="published" when="1993-03">Mar. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Promises: Linguistic Support for Efficient Asynchronous Procedure Calls in Distributed Systems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Shrira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Programming Language Design and Implementation</title>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title level="m" type="main">The Publish/Subscribe Paradigm for Scalable Group Collaboration Systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Mathur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Jahanian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Prakash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rasmussen</surname></persName>
		</author>
		<idno>CSE-TR-270-95</idno>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
		<respStmt>
			<orgName>University of Michigan, EECS Department</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Using Tuple Space Communication in Distributed Object-Oriented Languages</title>
		<author>
			<persName><forename type="first">S</forename><surname>Matsuoka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kawai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">3rd ACM Conference on Object-Oriented Programming Systems, Languages and Applications</title>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title level="m" type="main">Eiffel: The Language. Object-Oriented Series</title>
		<author>
			<persName><forename type="first">B</forename><surname>Meyer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Prentice-Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Object-Oriented Programming with Flavors</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Moon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Object-Oriented Programming Systems, Languages and Applications</title>
		<imprint>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Two-Level Semantics and Code Generation</title>
		<author>
			<persName><forename type="first">F</forename><surname>Nielson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Nielson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="59" to="133" />
			<date type="published" when="1988-01">Jan. 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Pizza into Java: Translating Theory into Practice</title>
		<author>
			<persName><forename type="first">M</forename><surname>Odersky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wadler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">24th ACM Symposium on Principles of Programming Languages</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">The Information Bus -an Architecture for Extensible Distributed Systems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Oki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pfluegl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Siegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Skeen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">14th ACM Symposium on Operating System Principles</title>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Notification Service Standalone Document</title>
		<author>
			<persName><surname>Omg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">OMG</title>
		<imprint>
			<date type="published" when="2000-06">June 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<title level="m" type="main">The Common Object Request Broker: Architecture and Specification. OMG</title>
		<author>
			<persName><surname>Omg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001-02">February 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<author>
			<persName><surname>Omg</surname></persName>
		</author>
		<author>
			<persName><surname>Corbaservices</surname></persName>
		</author>
		<title level="m">Common Object Services Specification</title>
		<imprint>
			<date type="published" when="2001-03">March 2001</date>
		</imprint>
	</monogr>
	<note>Chapter 4: Event Service. OMG</note>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Reliable Multicast Transport Protocol (RMTP)</title>
		<author>
			<persName><forename type="first">S</forename><surname>Paul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sabnani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bhattacharyya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal on Selected Areas in Communications</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="407" to="421" />
			<date type="published" when="1997-04">Apr. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Using the Object Space: A Distributed Parallel Make</title>
		<author>
			<persName><forename type="first">A</forename><surname>Polze</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">4th IEEE Workshop on Future Trends of Distributed Computing Systems</title>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">The Transputer and its Special Language</title>
		<author>
			<persName><forename type="first">D</forename><surname>Pountain</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Occam. Byte Magazine</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="361" to="366" />
			<date type="published" when="1984-08">Aug. 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Smalltalk : a Reflective Language</title>
		<author>
			<persName><forename type="first">F</forename><surname>Rivard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Metalevel Architectures and Reflection</title>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Elvin has Left the Building: A Publish/Subscribe Notification Service with Quenching</title>
		<author>
			<persName><forename type="first">B</forename><surname>Segall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Arnold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Australian UNIX and Open Systems User Group Conference</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<monogr>
		<title level="m" type="main">Vitria&apos;s Publish-Subscribe Architecture: Publish-Subscribe Overview</title>
		<author>
			<persName><forename type="first">D</forename><surname>Skeen</surname></persName>
		</author>
		<ptr target="http://www.vitria.com" />
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<monogr>
		<author>
			<persName><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><surname>Java</surname></persName>
		</author>
		<title level="m">Core Reflection API and Specification</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<monogr>
		<title level="m" type="main">Remote Method Invocation -Distributed Computing for Java (White Paper)</title>
		<author>
			<persName><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><surname>Java</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">A Gossip-Based Reliable Multicast for Large-Scale High-Throughput Applications</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sturman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Dependable Systems and Networks</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Multi-Stage Programming</title>
		<author>
			<persName><forename type="first">W</forename><surname>Taha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Sheard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM International Conference on Functional Programming</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<monogr>
		<title level="m" type="main">TIB/Rendezvous White Paper</title>
		<author>
			<persName><surname>Tibco</surname></persName>
		</author>
		<ptr target="http://www.rv.tibco.com/" />
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Object-Oriented Concurrent Programming in ABCL/1</title>
		<author>
			<persName><forename type="first">A</forename><surname>Yonezawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Briot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shibayama</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Object-Oriented Programming Systems, Languages and Applications</title>
		<imprint>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
