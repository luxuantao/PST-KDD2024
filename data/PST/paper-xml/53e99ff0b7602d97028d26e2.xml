<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">On the Generic Insecurity of the Full Domain Hash</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Yevgeniy</forename><surname>Dodis</surname></persName>
							<email>dodis@cs.nyu.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">New York University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Roberto</forename><surname>Oliveira</surname></persName>
							<email>riolivei@us.ibm.com</email>
							<affiliation key="aff1">
								<orgName type="institution">IBM T.J. Watson Research Center</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Krzysztof</forename><surname>Pietrzak</surname></persName>
							<email>pietrzak@inf.ethz.ch</email>
						</author>
						<title level="a" type="main">On the Generic Insecurity of the Full Domain Hash</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">44C447E4DF70DDF2689669889E3C42E5</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:24+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The Full-Domain Hash (FDH) signature scheme <ref type="bibr" target="#b2">[3]</ref> forms one the most basic usages of random oracles. It works with a family F of trapdoor permutations (TDP), where the signature of m is computed as f -1 (h(m)) (here f ∈R F and h is modelled as a random oracle). It is known to be existentially unforgeable for any TDP family F [3], although a much tighter security reduction is known for a restrictive class of TDP's [10,14] -namely, those induced by a family of claw-free permutations (CFP) pairs. The latter result was shown <ref type="bibr" target="#b10">[11]</ref> to match the best possible "black-box" security reduction in the random oracle model, irrespective of the TDP family F (e.g., RSA) one might use.</p><p>In this work we investigate the question if it is possible to instantiate the random oracle h with a "real" family of hash functions H such that the corresponding schemes can be proven secure in the standard model, under some natural assumption on the family F. Our main result rules out the existence of such instantiations for any assumption on F which (1) is satisfied by a family of random permutations; and (2) does not allow the attacker to invert f ∈R F on an a-priori unbounded number of points. Moreover, this holds even if the choice of H can arbitrarily depend on f . As an immediate corollary, we rule out instantiating FDH based on general claw-free permutations, which shows that in order to prove the security of FDH in the standard model one must utilize significantly more structure on F than what is sufficient for the best proof of security in the random oracle model.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Full Domain Hash. Dating back to Diffie-Hellman <ref type="bibr" target="#b12">[13]</ref>, the simplest classical suggestion for the design of digital signature schemes is to set the signature of the message m to be σ = f -<ref type="foot" target="#foot_0">1</ref> (m), where f comes from a family of trapdoor permutations (TDP) F such RSA. Unfortunately, this simple scheme is existentially forgeable (even under no message attack), since any σ happens to be the signature of m = f (σ). A folklore suggestion to fix this problem, which is the basis of several existing standards such as PKCS #1 <ref type="bibr" target="#b0">[1]</ref>, is to hash the message before inverting f : namely, to set σ = f -1 (h(m)) for a carefully chosen hash function h. This invalidates the trivial existential forgery above and seems to work well in practice for a "crazy" enough h, such as SHA-1. This signature scheme is commonly called Full Domain Hash (FDH), and yields one of the simplest and most practical signature schemes known.</p><p>From a theoretical point of view, however, one can wonder if it is possible to formally prove the security of FDH for some TDP f and hash function h? Random Oracle Model. Partially motivated by this question, in their seminal paper Bellare and Rogaway <ref type="bibr" target="#b2">[3]</ref> introduced the random oracle (RO) model as a "paradigm for designing efficient protocols". It mathematically models h as a truly random function, which is freely available to all the parties including the adversary. In particular, under this idealized assumption Bellare and Rogaway formally confirmed the intuition of practitioners that the FDH signature scheme is existentially unforgeable in the RO model, for any TDP family F . In fact, this was one of the first applications of the so called "random oracle methodology". Namely, one first formally analyzes and proves the security of a scheme like FDH in the RO model, and then practically instantiates this abstract scheme by replacing the ideal hash function h by some "real" implementation (such as SHA-1, or, more abstractly, some family of "real" functions H), heuristically hoping that no security flaws will suddenly appear in the standard model. Therefore, it is clearly of fundamental importance to understand under which conditions one can provably instantiate the random oracles in the standard model. In particular, in this work we will concentrate on the FDH signature scheme, which, as we said, is one of the most basic and important applications of random oracles. Before addressing it in more detail, however, let us summarize what is known about this scheme in the RO model.</p><p>FDH in RO model. As we mentioned, Bellare and Rogaway showed that FDH is existentially unforgeable in the RO model, for any TDP family F . On the other hand, a much tighter security reduction in the random oracle model was subsequently found by <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b13">14]</ref> for a special class of TDP's: namely, those induced by a family of claw-free permutation (CFP) pairs 1 which luckily includes all popular families such as RSA. Moreover, Coron <ref type="bibr" target="#b10">[11]</ref> subsequently showed that the above tighter reduction from CFP-induced TDP's is optimal, as long as the reduction treats the adversary as a "black-box" and irrespective of which particular TDP family F is used (e.g., even with RSA one cannot find a better black-box reduction in the RO model).</p><p>Our Goal. As we see, in the RO model very weak assumptions on the function family F are sufficient to prove the security of FDH: in fact, a single (although "ideal") hash function h simultaneously works for all such F . Unfortunately, it is not hard to see that previously studied "realizable" properties of random oracles, such as collision-resistance, pseudorandomness (even verifiable; see <ref type="bibr" target="#b4">[5]</ref>) or perfect one-wayness <ref type="bibr" target="#b8">[9]</ref> are not sufficient in general to implement the random oracle h, even for specific function families F (i.e., one can come up with an artificial counter-example family H which nevertheless satisfies the given property but for which the FDH scheme is insecure with F ). On the other hand, many practitioners strongly believe that for most "real" TDP families F there should probably exist "good enough" hash functions like SHA-1 which would make FDH with F secure. Therefore, our main question is to examine for which TDP families F can we provably instantiate FDH in the standard model? Initial Attempt. Let us make this question more precise. Given a function family F , we are trying to design a hash family H, such that a random h sampled from H will make FDH secure. Clearly, H should be allowed to depend on F (since assuming otherwise seems to place unfair restrictions on the signature designer). In fact, we also want to allow H to depend on a specific function f sampled from F (and whatever public information is associated with such f ). For example, if F is induced by a family of claw-free permutation pairs (which, as we know, is very beneficial in the RO model), a random member f from F is sampled by choosing a random pair (f, g) from the CFP family, and then "ignoring" g. In this case it seems natural that the signature designer might want to use both f and g in designing the hash function h. For example, setting h = g results in a signature scheme f -1 (g(m)) which is provably unforgeable under no message attack. Although the latter task can be easily achieved by other means (e.g., making h to be a random constant), this shows a potential utility one might get by using g in a less obvious manner.</p><p>Thus, the ambitious question would be to characterize the TDP families F for which one can choose an efficient H (depending of f ) which would make FDH secure. Unfortunately, this seems to be an extremely difficult question given our current state-of-the-art knowledge. In particular, even for specific families such as RSA we do not seem to be able to say anything more meaningful than making a tautological assumption of the form "SHA-1 makes a good RSA-based FDH signature scheme".</p><p>Our Approach. Instead, we will ask a slightly more general question: which security assumptions on F are sufficient to instantiate FDH in the standard model. For example, can we match the RO result stating that any TDP family can be instantiated? And, if not, maybe more restricted CFP-induced families can? Or maybe some other elegant assumption on F will be sufficient?</p><p>While a positive answer to these kind of questions would be even harder and more remarkable than the ambitious question asked about specific families F like RSA, the extra generality will allow us to get a meaningful negative result, which we believe is still very important. In particular, it will allow us to further realize the differences between the standard and the random oracle model. For example, we will see that being induced by a family of CFP's by itself is insufficient to instantiate FDH, in contrast to the RO model, where nothing beyond this prop-erty is likely to be of any extra advantage! Additionally, looking at the current general proofs of security of FDH in the RO model, it seems reasonable to hope that even in the standard model some natural and relatively general assumption on F might be sufficient for the proof to "go through" (with an appropriately chosen H). In this regard, our approach allows us to further understand which security assumptions on F will certainly be insufficient (by themselves) to try instantiating FDH. In particular, if a given set of properties of F will be consistent with some assumption that we formally rule out, then more properties are needed. For example, it easily follows from our result below that one cannot instantiate FDH even if we assume F to be one-way against any distribution of "super-logarithmic" entropy. This is an extremely strong assumption that might appear quite useful for FDH upon the first look: for example, a similar assumption was recently utilized by Wee <ref type="bibr" target="#b27">[28]</ref> to successfully obfuscate "equality" queries in the standard model, which was previously known only in the random oracle model <ref type="bibr" target="#b23">[24]</ref>. Yet, we show that this assumption is insufficient for FDH.</p><p>Our Modeling. A bit more formally, we will study the question if there exists a black-box reduction (see <ref type="bibr" target="#b20">[21]</ref>) from a given security assumption on F (such as being one-way or induced by CFP family, etc.) to the security of FDH. This means that all the relevant parties -adversary and "challenger" for the assumption (see below), potential forger for FDH, as well as the designer of the hash family H<ref type="foot" target="#foot_1">2</ref> -should work given oracle access to f (and possibly even f -1 ; see below). While seemingly restrictive, we believe this captures the essence of what it means to instantiate FDH given any F satisfying a given security assumption. Indeed, allowing non-black-box access to F essentially maps us back to the original "beyond-the-reach" question, where the designer of H can use some "extra" properties of F which do not follow from the security assumption alone. For example, we do not know how to show the insecurity of RSA-based FDH when the designer of the scheme chooses h to be SHA-1. In fact, most practitioners actually hope that the resulting scheme is secure!</p><p>In our modeling, a given security assumption is formalized by a "game" G between the adversary A and the challenger C. At the start of the game, a random f is chosen from F (possibly with some other public information), after which A and C engage in some protocol using oracle access to f , and the end of which C output 1 if the adversary has won and 0 otherwise. For example, in the one-wayness game defining plain TDP's the challenger simply asks A to invert f (x), for a random x of its choice. Similarly, in the "claw-free" game defining F induced by some CFP family, C simply waits for A to provide a claw (x, y), where A can have oracle access to both f and its "twin" permutation g. Many other assumptions can be put in this framework as well.</p><p>Given such an abstract game G, we can look at the corresponding class of black-box permutation families F for which no polynomial time adversary can win with non-negligible probability. To argue a separation result for a given game G, we must essentially (see below) show that there exist a black-box family F such that (1) F is "black-box" secure with respect to G, but (2) F cannot be instantiated for the use in FDH, for any polynomial size circuit family H (which is allowed to depend on F , but in a "black-box" manner).</p><p>Our Main Result. Our main result is pretty general: we show than no game G between A and C can lead to an "instantiable" security assumption on F , provided that a family of truly random permutations satisfies the security of G. Intuitively, it rules out all the assumptions involving "inverting" f on more or less arbitrary inputs (since random permutations are very hard to invert), or finding some inputs to f whose images satisfy some non-trivial relation (e.g., x and y such that f (x) = f (y) ⊕ 1), etc. In fact, our main results extends even to games where the challenger is allowed to invert f to the attacker, as long as this is done for an a-priori bounded number of times. <ref type="foot" target="#foot_2">3</ref> To state this result differently, any assumption on F which ( <ref type="formula">1</ref>) is satisfied by a family of random permutations; and where (2) the challenger does not invert f on an a-priori unbounded number of points, is insufficient to instantiate FDH in the standard model.</p><p>Thus, to generically instantiate FDH one must assume a property on F which is not satisfied by random permutations, such as being "homomorphic" or "selfreducible".</p><p>Other Results. As special cases, we rule out such instantiations based on plain TDP's, as well the sub-class of TDP's induced by CFP's, since both of those are easily seen to be satisfied by random permutations. In particular, this shows that more assumptions on F are needed in the standard model than what is sufficient for the best reduction in the RO model, giving yet another separation between the standard the the RO model (see related work below). As another interesting corollary, we notice that many cryptographic primitives such as collision-resistant hash functions, trapdoor commitments and even general signature schemes follow -in a black-box manner -from the existence of CFP families. Our separation result therefore shows that even assuming the existence of all these powerful primitives is not sufficient to build an "FDHlike" signature scheme (in a black-box manner), despite the fact that general, "non-FDH-like" signature schemes can be built! For example, there seem to be a "price to pay" for insisting on inverting a trapdoor permutation on the hash of the message, as opposed to applying to it any secure signature scheme on short messages: the latter is provably secure as long as the hash is collisionresistant (this is the famous "hash-then-sign" paradigm), while we show that much stronger assumptions seem to be required for the former.</p><p>We remark that our main impossibility result uses the full power of the chosen message attack, since our FDH breaker is allowed to ask more signing queries than the description of the hash function h. If we restrict our attention to the class of general TDP's (as opposed to all hard games satisfied by random permutations), we also strengthen our separation and show that there is no black-box reduction from the security of TDP's to the security of FDH even as a one-time signature scheme, as long as the message space is super-polynomial in the security parameter. <ref type="foot" target="#foot_3">4</ref>Our Techniques. In both of our results we use an elegant "two-oracle" observation of Hsiao and Reyzin <ref type="bibr" target="#b20">[21]</ref> for showing general black-box separation results. Applied to our setting, they show that it is sufficient to design an oracle F for F and another "breaking" oracle G, such that G does not help the attacker to win the game G with F, but always helps the forger to break the security of FDH (even if H can depend of F but not on G). In both of our results we use a family of random permutations to model the oracle F for our TDP family F . The oracles G, however, are very different.</p><p>For our general separation result we use a novel oracle G which takes a description of the hash function h, and will forge the FDH-like signature of a new message only if the attacker can "prove" that he has oracle access to the FDH signing oracle. Remarkably, the oracle G is designed in such a careful way that its addition is literally of "no use" to the attacker in any game G! So if G was secure with random permutations, addition of G will not change this fact. Yet, it clearly breaks any FDH instantiation H, since the forger has a "real" access to the signing oracle, and thus can successfully utilize G.</p><p>On the other hand, the oracle G for our TDP-specific separation is very different and is based on to the corresponding oracle by Simon <ref type="bibr" target="#b26">[27]</ref> used to separate collision-resistant hash functions from one-way permutations. <ref type="foot" target="#foot_4">5</ref> In essence, this oracle returns collisions for any length-decreasing function h (which could depend of f ), but in a careful way which does not allow the attacker to invert f . On the other hand, any collision clearly makes FDH insecure against one-message attack, as both of the colliding messages have the same signature. The main technical difficulty we have to resolve here is the fact that Simon's oracle only covers length-decreasing function families H (in fact, it is completely useless for most length-increasing hash families). Therefore, we have to non-trivially extend it to allow one break FDH for arbitrary function families H, and yet without suddenly helping the adversary to invert f at a random point. Related Work. Our work is related to several important results <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b1">2]</ref> showing that various schemes provably secure in the random oracle model cannot be securely instantiated in the standard model. Canetti, Goldreich and Halevi <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8]</ref> gave concrete (although somewhat artificial) examples of general signature and encryption scheme with this property. Nielsen <ref type="bibr" target="#b25">[26]</ref> considered the question of designing so called "non-committing encryption schemes" <ref type="bibr" target="#b5">[6]</ref> capable of encrypting arbitrary number of messages, and showed that one cannot build such scheme at all in the standard model, although simple solutions in the random oracle model exist. Goldwasser and Tauman <ref type="bibr" target="#b19">[20]</ref> concentrated on the soundness of the Fiat-Shamir heuristics <ref type="bibr" target="#b14">[15]</ref>, and showed a secure (although artificial) 3round identification scheme which does not result in a secure signature scheme in the standard model, no matter how one implements the hash family. Finally, Bellare, Boldyreva and Palacio <ref type="bibr" target="#b1">[2]</ref> showed a natural ElGamal-based key encapsulation mechanism for hybrid encryption which is secure in the random oracle model (for any symmetric-key component), but where for every real hash family one can come up with (artificial) symmetric-key encryption scheme making the overall hybrid scheme insecure.</p><p>We notice that an attractive feature of all these results as compared to our result, is that their separations are not black-box. However, our setting appears to be significantly more constrained as well. Intuitively, in all of the above results the syntax of the question allowed one enough freedom to adapt the scheme after the hash function h was chosen. While such adaptation was pretty non-trivial in each of the above works, our setting appears to be more restrictive. Namely, we must "commit" to a "real" TDP family F (possibly satisfying even more constraints), and then, given an arbitrary non-black-box function h depending of f , find some point m where we can invert h(m)! Without "reverse-engineering" such an h, the latter task seems quite hopeless to do (even using the signing oracle since it is hard to predict on which points it will invert f ). Indeed, our black-box assumption essentially allows us to get a weak, but luckily sufficient "handle" to determine how h actually depends on f . From a different perspective, our work naturally relates to a rich body of work on various black-box separations <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b20">21]</ref>. For example, we already pointed out how our breaking oracle for the case of general TDP's relates to the oracle of Simon <ref type="bibr" target="#b26">[27]</ref>, and how we use the simplified framework of Hsiao and Reyzin <ref type="bibr" target="#b20">[21]</ref> to get our black-box separations. To the best of our knowledge, however, our work is the first to show a black-box separation result with respect to instantiating random oracles in the standard model, as opposed to separating different cryptographic assumptions from each other <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b20">21]</ref> or showing lower bounds on the efficiency or exact security of various "black-box" reductions <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b13">14]</ref>.</p><p>Finally, we already mentioned a complimentary recent work of Boldyreva and Fischlin <ref type="bibr" target="#b4">[5]</ref>, who considered the question of instantiating random oracles in various scenarios, including FDH, by popular families of "realizable" hash functions, such as verifiable pseudorandom functions <ref type="bibr" target="#b24">[25]</ref> (VRFs). In particular, they showed that such VRFs cannot generically instantiate FDH, no matter which TDP family F is used.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>Basic Definitions and Notation. For a set X we denote by x ∈ R X a value chosen uniformly at random from X . A function µ : N → [0, 1] is negligible if for any c &gt; 0 there is an n 0 such that µ(n) ≤ 1/n c for all n ≥ n 0 . We write negl(•) as a shorthand for a negligible function.</p><p>TM is a shorthand for Turing-machine. We use the standard definition of probabilistic polynomial-time TMs (pptTM for short) and pptTMs with oracle access (opptTM for short). We say that something can be efficiently computed (relative to an oracle O) if it can be computed by a pptTM (by a opptTM with oracle access to O).</p><p>Trapdoor permutations. A trapdoor permutation family (TDP) is a pair of efficient algorithms (KeyGen, F ). KeyGen is probabilistic and on input 1 n generates a key/trapdoor pair KeyGen(1 n ) → (pk, td) where F (pk, •) implements a permutation f pk (.) over {0, 1} n and F (td, •) implements its inverse f -1 pk (.). Security of TDPs. The standard security property for TDPs is one-wayness which says that inverting is hard without the trapdoor, i.e. for any pptTM A</p><formula xml:id="formula_0">Pr KeyGen(1 n )→(pk,td),x∈R{0,1} n [A(f pk (x), pk) = x] = negl(n).</formula><p>A stronger security property is claw-freeness which says that given two independently sampled permutations it is hard to find a collision, i.e. for any pptTM A</p><formula xml:id="formula_1">Pr i∈{1,2}:KeyGen(1 n )→(pki,tdi) [A(pk 1 , pk 2 ) = (x 1 , x 2 ) where f pk1 (x 1 ) = f pk2 (x 2 )] = negl(n).</formula><p>A TDP with this property is not a standard assumption, but it implies the following popular primitive.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Claw-free pairs of trapdoor permutations. A family of claw-free pairs of trapdoor permutations (CFP) is a triple of efficient algorithms (KeyGen, F, G)</head><p>where KeyGen is probabilistic and on input 1 n generates a key/trapdoor pair KeyGen(1 n ) → (pk, td) for which F (pk, •) and G(pk, •) implement permutations f pk (.) and g pk (.) over {0, 1} n respectively. F (td, •) and G(td, •) implement the inverses f -1 pk (.) and g -1 pk (.). The security property for CFPs requires that for any pptTM A Pr KeyGen(1 n )→(pk,td) [A(pk) = (x 1 , x 2 ) where f pk (x 1 ) = g pk (x 2 )] = negl(n).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Hash-function.</head><p>A family of hash-functions is a pair of efficient algorithms (Index, H). Index is probabilistic and on input 1 n generates an index i ∈ I n . For each i ∈ I n , H(i, .) implements a function h i : {0, 1} * → {0, 1} n . A family of hash-functions is collision resistant if</p><formula xml:id="formula_2">Pr Index(1 n )→i [A(1 n , i) = (x 1 , x 2 ) where x 1 = x 2 and h i (x 1 ) = h i (x 2 )] = negl(n).</formula><p>Full-domain hash (FDH). The FDH signature-scheme based on a trapdoor permutation family (KeyGen F , F ) and a family of hash functions (Index, H) is defined as a triple of functions (KeyGen F DH , sign, verify) where for security parameter n <ref type="foot" target="#foot_5">6</ref>It outputs the triple (pk, td, i). The public-key of the signature scheme is (pk, i) and the secret key is (td, i).</p><formula xml:id="formula_3">-KeyGen F DH (1 n ) first runs KeyGen F (1 n ) → (pk, td) and Index(1 n ) → i.</formula><p>sign(m, td, i), the signature of a message m ∈ {0, 1} * is f -1 pk h i (m) (i.e. computed as F (td, H(i, m))).</p><p>verif y(σ, m, pk, i), the verification function evaluates to 1 (with the meaning that the signature is valid) iff f pk (σ) = h i (m) and to 0 otherwise.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Security of FDH.</head><p>A FDH signature scheme as above is secure against an existential forgery in a chosen message attack if for any opptTM A Pr KeyGenF DH (1 n )→(pk,td,i) [A sign(.,td,i) (pk, i) → (m, σ) where verif y(σ, m, pk, i) = 1 and A did not make the oracle query m] = negl(n). <ref type="bibr" target="#b0">(1)</ref> This means that A cannot come up with a valid signature/message pair for a message that he had not already signed by the signing oracle.</p><p>Game. A game is defined by two opptTMs, a prover A and a challenger C, which have a common communication tape over which they can exchange messages. The challenger finally output a decision bit. We say that A wins the game if this bit is 1 and denote this event by A, C → 1.</p><p>Hard Game. An opptTM C as above defines a hard game if no opptTM A can win the game when the oracle is instantiated with t (where t = t(n) is implicitly defined by C and can be polynomial in n) uniform random permutations π 1 , . . . , π t over {0, 1} n . I.e. C defines a hard game if for all opptTM A Pr[ A π1(.),...,πt(.) (1 n ), C π1(.),...,πt (.) </p><formula xml:id="formula_4">(1 n ) → 1] = negl(n).<label>(2)</label></formula><p>A TDP (KeyGen, F ) is secure for the hard game C if (2) is satisfied even if the random permutations are replaced with this TDP, i.e. for all pptTM A Pr ∀i=1...t:KeyGen(n)→(pki,tdi) [ A(pk 1 , . . . , pk t ), C F (pk1,•),...,F (pkt,•)</p><formula xml:id="formula_5">(1 n ) → 1] = negl(n).</formula><p>Hard games capture many natural security properties, in particular one-wayness: C f (.) (1 n ) samples x ∈ {0, 1} n uniformly at random and sends f (x) to A. It outputs 1 iff it receives as the next message x. -claw-freeness: C f1(.),f2(.) (1 n ) just expects x 1 , x 2 ∈ {0, 1} n and outputs 1 iff</p><formula xml:id="formula_6">f 1 (x 1 ) = f 2 (x 2 ).</formula><p>In the next section we will show that a TDP which is secure for all hard games cannot be black-box reduces the security of FDH. There does not exist a TDP which is secure for all hard games in the standard model, 7 but we show an impossibility result, and showing impossibility from such a hypothetic TDP implies 7 Consider for example a game where C expects as input a circuit and then checks if the circuit computes the same value as its oracle on a few (n is enough) random inputs and outputs 1 only if this is the case. In the standard model A can always win this game by sending a circuit which computes C's oracle F (pk, .). But this is a hard game as if the oracle is a random permutation, it will with high probability disagree with every polynomial size circuit on most inputs, and C will reject almost certainly.</p><p>impossibility for any assumption it implies. Then in section 4 we will extend the notion of hard games and give the challenger also access to inversion oracles π -1 i (.) which he may query at most polynomially many times (for some arbitrary but a priori fixed polynomial). With such games we can cover additional natural assumptions for TDPs, which will therefore be also insufficient to get a reduction to an FDH signature scheme.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">No Reduction from Any Hard Game</head><p>Theorem 1. There is no black-box reduction from a trapdoor permutations family which is secure for all hard games to a FDH signature scheme secure against chosen-message attacks.</p><p>More precisely, given a TDP (KeyGen, F ) which is secure for all hard games and any hash function family (Index, H), the security of the signature scheme sign(m) = f -1 pk h(m) (where KeyGen(1 n ) → (pk, sk) and Index(1 n ) → i) cannot be black-box reduced from the security of the TDP. Here the hash function can use the TDP as a black-box and the randomness used for KeyGen and Index can be arbitrarily correlated. Moreover, if we let s(n) = max{|h i | : i ∈ Range(Index(1 n ))} denote an upper bound on the size of a description of the hash function used, then the theorem even holds if we restrict the number of chosen message queries to s(n) and the size of the message-space of the signature scheme to s(n) + 1.</p><p>As corollaries we get that any assumption on TDPs which can be formulated as a hard game will not be enough to get a reduction to FDH, e.g.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary 1.</head><p>There is no black-box reduction from claw-free pairs of trapdoor permutations to a FDH signature scheme secure against chosen-message attacks.</p><p>Proof (of Theorem 1). Following <ref type="bibr" target="#b20">[21]</ref> (Lemma 1), as to rule out black-box reductions, it is enough to prove that there are two oracles F and G such that the following holds:</p><p>1. There is an opptTM D such that D F implements<ref type="foot" target="#foot_6">8</ref> TDP. 2. There is an opptTM A such that A F,G finds a forgery for any signature scheme of the form sign(m) = f -1 (h F (m)) in a chosen message attack, where f is the TDP implemented by D F and h is any oracle circuit. 3. There is no opptTM B where B F,G breaks the security of TDP implemented by D F . This means that B F,G cannot win any hard game C instantiated with this TDP with non-negligible probability.</p><p>Points 2 and 3 will follow from Lemmas 1 and 2 below. The first point is satisfied by the definition of the oracle F we will give, which implements TDP. This F alone is trivially a secure implementation of TDP. We then define a breaking oracle G for which we will show that it can be used to break any FDH scheme based on the TDP implemented by F but not the security of the TDP itself. The oracle G will simply provide a forgery (for the message m = 0) to any signature scheme of the form sign(m) = f -1 (h F (m)) (where f ∈ F and h is any oracle circuit), but only if it can be sure that the requesting party can compute those signatures herself (e.g. because she has access to the signing oracle sign(m) = f -1 (h F (m)) or knows the trapdoor for f ). For this our G expects as input the values f -1 (h F (m)) for m = 1 . . . , where = |h|. This choice of should make it impossible for an adversary to hardwire the outputs of h on all the inputs requested to values where she can invert f . However, there would still be at least two ways in which an adversary could abuse the oracle G to break the security of TDP implemented by F.</p><p>1. She could define an h such that the output of h F collides on (some of) the requested inputs. Say h F (i) = y for all 1 ≤ i ≤ (where she knows f -1 (y)) and h F (0) = z (where z could be a challenge in the one-wayness game). As she can provide the requested signatures f -1 (h F (i)) to G, G will output a forgery w = f -1 (h F (0)) = f -1 (z) and she wins the game! To avoid this our G will check if there is such a collision before providing the forgery. This will not affect the usability of G to provide forgeries, as having a collision for h F one can compute a forgery without the help of G anyway. 2. She could use f in the definition of h F in a clever way, for example by choosing an h where h F (m) = f (m) for m = 0 (then f -1 (h F (m)) = m) and h(0) = z (where z could be a challenge in the one-wayness game). Our G will prevent this by checking whether in the computation of h F on any of the requested inputs, the oracle for f is queried on an input x where f (x) = h F (i) for i, 1 ≤ i ≤ . Again, if this check fails we have a forgery as x = f -1 (h F (i)).</p><p>We will show that the two above checks are not only necessary, but already sufficient to guarantee that G cannot be used to break the security of TDP implemented by F.</p><p>Definition of F (TDP secure for every hard game). The definition of the oracle F is straight forward. For any n ∈ N choose 2 n + 1 permutations f 0,n , . . . , f 2 n -1,n and t n at random. Now F is defined as</p><formula xml:id="formula_7">9 -F(td2pk, n, td) → t n (td) -F(eval, n, pk, x) → f pk,n (x) -F(invert, n, td, y) → f -1 pk,n (y)</formula><p>9 With this F a TDP (KeyGen, F ) can be implemented as follows. KeyGen(1 n ) first samples a random trapdoor td ∈R {0, 1} n , then computes the corresponding publickey F(td2pk, n, td) → pk and outputs (pk, td). F (pk, .) and F (td, .) are computed by F(eval, n, pk, .) and F(invert, n, td, .) respectively. Informally the reason that this TDP is secure for every hard game follows from the fact that a permutation, chosen at random from a set of 2 n randomly chosen permutations, is computationally indistinguishable from a truly random permutation. But if there was a hard game that this TDP could win, we could turn it into a distinguisher.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition of G (Breaking Oracle).</head><p>The oracle G takes as input (n ∈ N, k ∈ {0, 1} n , h ∈ {0, 1} * , V ) where h is (the description of) an oracle circuit. <ref type="foot" target="#foot_7">10</ref> This can be seen as a request for an existential forgery for the signature scheme sign(m) = f -1 pk,n (h F (m)). The vector V = [v 1 , . . . , v |h| ] is a "proof" that the requesting party can compute those signatures herself. We say that G accepts the input if the input has the correct form (as above) and</p><formula xml:id="formula_8">1. f -1 pk,n (h F (i)) = v i for all i = 1, . . . , |h|. 2. v i = v j for all 1 ≤ i &lt; j ≤ |h|. 3. {h F (1), . . . , h F (|h|)} ∩ Y h F = ∅ where Y h F is defined as Y h F = {f pk,n (x)| ∃i, 1 ≤ i ≤ |h|, h F (i) makes the query F(eval, n, pk, x)} (3)</formula><p>If G accepts the input it outputs a forgery f -1 pk,n (h F (0)) and ⊥ otherwise.</p><p>G Breaks any FDH Signature Scheme. Now we will show that G breaks any FDH signature scheme based on F.</p><p>Lemma 1. There is an opptTM A which outputs a forgery for any signature scheme sign(m) = f -1 pk,n (h F (m)) with probability 1, i.e.</p><formula xml:id="formula_9">Pr[A F,G,sign(.) (n, pk, h) → (m, s) where s = f -1 pk,n (h F (m)</formula><p>) and sign(.) was not queried on input m ] = 1 Proof (of Lemma). A must only check if h satisfies conditions 2 and 3. If one of them is not satisfied, this directly gives a forgery, otherwise A can use G to get a forgery. More formally A does the following:</p><p>-Compute h F (1), . . . , h F (|h|), doing this also compute Y h F as in (3). • If any of the h F (1), . . . , h F (|h|) collide we have a forgery: If say h F (i) = h F (j), then query sign(i) and output the forgery (j, sign(i)). • If {h F (1), . . . , h F (|h|)}∩Y h F = ∅, then we have found an x and an i satisfying f pk,n (x) = h F (i) and thus have a forgery as</p><formula xml:id="formula_10">sign(i) = f -1 pk,n (h F (i)) = x.</formula><p>-If none of the above is the case, then call the oracle sign on inputs 1, . . . , |h| and let V = [sign(1), . . . , sign(|h|)]. Now query G on input (n, pk, h, V ) to get a forgery for the message m = 0. ♦ G does not break the security of F. In this section we will prove that F is a secure implementation of a family of claw-free trapdoor permutations, even when given access to G, i.e.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 2.</head><p>With probability 1 (over the choice of F) for any opptTM B and any hard game C (with t = t(n) implicitly defined by C)</p><formula xml:id="formula_11">Pr ∀i=1...t:KeyGen(n)→(pki,tdi) [(B F,G (pk 1 , . . . , pk t ), C f pk 1 ,n ,...,f pk t ,n (1 n )) → 1] = negl(n).<label>(4)</label></formula><p>Proof (Proof Sketch of Lemma). If the oracle G was not there, then (4) would follow from the fact that for a random pk, f pk,n is computationally indistinguishable from a random permutation and that the randomly chosen permutation t n is one-way (thus one cannot get the trapdoor t -1 n (pk)). Now we must argue that the presence of the oracle G will not help to win any hard game. This is not so obvious, after all G provides forgeries f -1 pk,n (h F (0)) for an h of our choice. But to learn such a forgery we must find an accepting input (see the definition of G) for G. From Lemma 3 below it now follows that B cannot find such an accepting input for a random pk and thus will not learn anything about the f pki,n 's that he could not compute on its own. <ref type="foot" target="#foot_8">11</ref>♦ Lemma 3. Let f be a random permutation on {0, 1} n and c ≥ 1 be a constant. For any oracle TM A which makes at most n c oracle calls, we have (the probability is over the random permutation f )</p><formula xml:id="formula_12">Pr[A f → (h, x 1 , . . . , x |h| )] = negl(n)</formula><p>where h, |h| ≤ n c is an oracle circuit and the output satisfies the conditions 1. f -1 (h f (i)) = x i for all i = 1, . . . , |h|.</p><p>2.</p><formula xml:id="formula_13">x i = x j for all 1 ≤ i &lt; j ≤ |h|. 3. {h f (1), . . . , h f (|h|)} ∩ Y h f = ∅ where Y h f is defined as Y h f = {f (x)| ∃i, 1 ≤ i ≤ |h|, h f (i)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>makes the oracle query x}</head><p>Proof (of Lemma). Consider any oracle TM A where A f makes n c oracle queries. After having used up all his oracle queries A f must come up with an output (h, x 1 , . . . , x |h| ) where h satisfies conditions 2 and 3. Below we prove that with overwhelming probability there does not even exist an h which satisfies conditions 2 and 3 and where A f has made all the queries x 1 , . . . , x |h| satisfying condition 1. But in this case, even when choosing an h which satisfies conditions 2 and 3, A f would still have to guess at least one x i (i.e. f -1 (h f (i))). The probability that it will guess correctly (i.e. this x i will satisfy condition 1) is negligible. <ref type="foot" target="#foot_9">12</ref> We must now prove the above statement, i.e. that an h satisfying conditions 2 and 3 and where A f made all the queries x 1 , . </p><formula xml:id="formula_14">H := {f -1 (h f (1)), . . . , f -1 (h f (|h|))}. Condition 3 states that f (H) ∩ f (X h f ) = ∅, and as f is a permutation this is equivalent to H ∩ X h f = ∅. Given X h f and conditioned on h f satisfying condition 3, the set H is a ran- dom subset of {0, 1} n \ X h f . If condition 2 is satisfied then |H| = |h| moreover |X h f | ≤ |h| 2 ≤ n 2c</formula><p>. Now the probability that H ⊆ X A f can be upper bounded as (here the probability is over the random permutation f and for a fixed h conditioned on h f satisfying conditions 2 and 3)</p><formula xml:id="formula_15">Pr[H ⊆ X A f ] = |H|-1 i=0 |X A f | -|X A f ∩ X h f | -i 2 n -i -|X h f | ≤ |X A f | 2 n -n c -|X h f | |H| = n c 2 n -2n 2c |h| .</formula><p>By taking the union bound over all oracle circuits h, |h| ≤ n c we can now upper bound the probability that there exists an h satisfying conditions 2 and 3 and where A f knows all x i satisfying condition 1 as</p><formula xml:id="formula_16">n c |h|=1 2 |h| n c 2 n -2n 2c |h| ≤ 2n c 2 n -2n 2c = negl(n)</formula><p>where in the first step we assumed that the sum takes it maximum for |h| = 1 which holds for all sufficiently large n. ♦</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Hard Games with Inversions</head><p>In the last section we have seen that a TDP which is secure for all hard games (and thus has the one-wayness and claw-freeness security property) cannot be black-box reduced to a FDH signature scheme. In this section we will see that even a stronger notion of hard games does not allow for such a reduction. We extend the definition of a hard-game and allow (a limited number of) inversion queries. 13 To motivate this let us define one more security property for TDPs which can be modelled as such a game.</p><p>-A TDP has the one-way with q(.)-inversions security property if it is oneway, even with an oracle for f -1 pk that can be used at most q(n) times on any input except the challenge f pk (x), i.e. 14   Pr KeyGen( <ref type="formula">1</ref></p><formula xml:id="formula_17">n )→(pk,td),x∈R{0,1} n [A f -1 pk (.) (f pk (x), pk) = x] = negl(n).</formula><p>Hard game with q(.) inversions. An opptTM C defines a hard game with q(.) inversions if for a random permutation π and all opptTM A</p><formula xml:id="formula_18">Pr[ A π(.) (1 n ), C π(.),π -1 (.) (1 n ) → 1] = negl(n)<label>( 5 )</label></formula><p>where C may query the π -1 (.) oracle at most q(n) times. A TDP (KeyGen, F ) is secure for a hard game C with q(.) inversions if</p><formula xml:id="formula_19">Pr KeyGen(n)→(pk,td) [ A(pk), C F (pk,.),F (td,.) (1 n ) → 1] = negl(n).</formula><p>The one-way with q(.) inversions property is captured by such a game as follows:</p><p>-C f (.),f -1 (.) (1 n ) samples x ∈ R {0, 1} n and sends f (x) to A. Now C answers at most q(n) queries z ∈ {0, 1} n where z = f (x) with f -1 (z). C accepts and outputs 1 if it receives x as the (q(n) + 1)'th message.</p><p>Lemma 2 is easily seen not to extend to hard games with q(.) inversions already for q(n) = O(n). 15 But if in the definition of the breaking oracle G we increase the number of requested signatures from |h| to |h| + q(n), then it is again impossible to find an accepting input for G and Lemma 2 can be shown to hold even for hard games with q(.) inversions (using a similar strengthening of Lemma 3). 13 For clarity of exposition we will consider the case where C expects only one permutation oracle, i.e. t = 1. 14 This property directly implies some others like security for the known-target inversion problem introduced in <ref type="bibr" target="#b3">[4]</ref>. Here one gets q(n) + 1 random challenges to invert and may use an inversion oracle on arbitrary inputs q(n) times, i.e. once less than the number of challenges. 15 For example A could win the one-way with cn inversions game (for some constant c) as follows. On challenge y = f pk (x) let h(x) = x ⊕ y (the c must satisfy |h| ≤ cn). Now use the cn inversion queries to C to find an accepting input for the breaking oracle G, which will then provide the forgery s = f -1 pk (h(0) = y). Send s = x to C and win the game. Theorem 2. For any polynomially bounded function q(.), there is no blackbox reduction from a TDP family which is secure for all hard games with q(.) inversions to a FDH signature scheme secure against chosen-message attacks. <ref type="foot" target="#foot_10">16</ref>As corollaries we get that any assumption on TDPs which can be formulated as such a game will not be enough to get a reduction to FDH, e.g. Corollary 2. For any polynomially bounded function q(.), there is no blackbox reduction from a TDP satisfying the one-way with q(.) inversions security property to a FDH signature scheme secure against chosen-message attacks.</p><p>Finally, let us remark that in Theorem 2 it is necessary to have q(.) bounded by some fixed polynomial. As if one allows a superpolynomial q(n) ∈ n ω (1) then a TDP which is secure for all hard games with q(.) inversions can be blackbox reduced to a secure FDH signature scheme (note that this has a priori no practical consequences as such TDPs do not exist in the standard model). The main observation here is that the "existential forgery in a chosen message attack" (1) can be seen as a game where the challenger plays the role of the signing oracle sign(m, td, i) → f -1 pk (h i (m)) and finally accepts if it receives a forgery from the prover A. We have not yet defined which FDH signature scheme to use in the above game. This scheme can not be arbitrary as we must make sure that this game is actually a hard game (i.e. no efficient A can win it when the oracles are instantiated with random permutations), but it is not difficult to construct a secure FDH scheme from random permutations π 1 , π 2 , . . . with only the signer having access to inversion oracles. For example, for a message space restricted to {0, 1} n , sign(m) = π -1 1 (π 2 (m)) will already do it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">No Reduction from Trapdoor Permutations</head><p>We conclude the paper by observing that "the plain TDP assumption" implies an extreme black-box security limitation for FDH: not even security against a one-chosen-message attack can be achieved.<ref type="foot" target="#foot_11">17</ref> </p><p>Theorem 3. There is no black-box reduction from trapdoor permutation families to a full-domain hash scheme secure against one-chosen-message attacks.</p><p>For space reasons, we leave the proof of this theorem to a full version of the paper, here only discussing the key choice in the proof: that of the oracle G that breaks FDH but not TDP (cf. the proof of Theorem 1; F is the same as before).</p><p>G is partly based on the collision-finding oracle of Simon <ref type="bibr" target="#b26">[27]</ref>. However, his "collision-finding" oracle only works for length-decreasing hash functions. To deal with arbitrary (potentially length-increasing) hash functions, we extend Simon's oracle to forge the FDH signature of a special input when no "good collision" to h was found: But we have to make sure that the inversion of f pk,n resulting from this forgery will not allow the attacker to invert f pk,n on its own challenge.</p><p>More specifically, G takes inputs of the form (1 L , 1 t , h , pk), where h is the description of a deterministic oracle TM. Such a query can be seen as a request for a forgery to signature scheme sign(m) = f -1 pk,n (h(m)), here n = |pk|. G first checks if the running time of h F0 (x) is &gt; t/2 for some x ∈ {0, 1} L and all potential choices F = F 0 for the oracle F; if so, it outputs ⊥ and stops. Otherwise, u ∈ R {0, 1} L is chosen and w ≡ h F (u) is computed; then v ∈ R {0, 1} L is sampled conditioned on h F (v) = w. If u = v, |w| = n and L ≥ µ(n), where µ(n) = log 2 (n), F outputs (u, v, y, f -1 pk,n (w), s, inversion), where s describes the computations h F (u) and h F (v) (including all F-queries). Else, the output of G is (u, v, w, s, collision), with s as above.</p><p>It is easy to see that with this oracle G one can forge sign(m) = f -1 pk,n (h(m)) for any efficient h: Just query G(1 L , 1 t , h , pk) (for appropriate L, t) to obtain u and v with h(u) = h(v). If u = v, we can forge a signature for v by asking the signing oracle to sign u, which will also give a signature of v. If u = v, then G also outputs f -1 pk,n (h(u)), which is a direct forgery (with no queries to its signing oracle).</p><p>More subtleties arise when showing that G does not help the adversary to invert F. In particular, they motivate the need for t and the "µ-test" in G. The former avoids that an adversary A = A F,G receives the result of more oracle queries than she would have time to compute. As for the µ-test, it avoids that the TDP is inverted on specific inputs, for it makes negligible the probability that A could use G to invert some specific y of interest (e.g., the challenge in the one-wayness game). Indeed, for this to happen (1) a random u should map to y; and (2) a random preimage v of y (v ∈ h -1 (y)) should be u again. Now, it is easy to see that the probability of this happening is negligible indeed:</p><formula xml:id="formula_20">Pr[u ∈ h -1 (y)]Pr[v = u | v ∈ h -1 (y)] = |h -1 (y)| 2 L 1 |h -1 (y)| = 2 -L ≤ 2 -µ(n) .</formula><p>(6) This simple fact turns out to be ultimately responsible for G not breaking the TDP property. More details will be given in the full version.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>. . , x |h| satisfying condition 1 exists only with negligible probability. Let X A f , |X A f | = n c denote all oracle queries made by A f , i.e.</figDesc><table><row><cell>X A f := {x| A f makes the oracle query x}.</cell></row><row><cell>Now consider any fixed oracle circuit h, |h| ≤ n c which satisfies the conditions 2</cell></row><row><cell>and 3. Let X h f = {f -1 (y)|y ∈ Y h f }, i.e.</cell></row><row><cell>X h f := {x| ∃i, 1 ≤ i ≤ |h|, h f (i) makes the oracle query x}</cell></row><row><cell>and let</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Such families consist of pairs of functions (f, g) for which is it infeasible to find a "claw" (x, y) satisfying f (x) = g(y). One get an induced TDP family by taking f and "ignoring" g.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>As we stated, it seems very restrictive not to allow such a dependency.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>Essentially, for a number of times slightly smaller than the number of signing queries the FDH forger is allowed to make. Without this restriction, one can define games modeling tautological assumptions of the form "SHA-1 makes FDH secure for a given F" (which are trivially instantiable by setting h equal to SHA-1).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>Otherwise, one can of course instantiate FDH by "hardwiring" an independent random challenge ym to be the hash of m.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p><ref type="bibr" target="#b4">5</ref> For example, such oracle cannot be extended to cover CFP-induced TDP's, since it is known how to build collision-resistance hash functions from CFP's.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>One would probably choose the randomness for Index and for KeyGenF independent here, but we make no such assumption. In particular, (pk, td) and i can be arbitrarily correlated.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_6"><p>Here implement has a purely functional meaning and does not imply any security assumptions.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_7"><p>Usually the hash function h is given as a TM and not as a circuit, but a TM can be simulated by a circuit whose size is only polynomial in the running time of the TM. In particular for every efficient h there is an m ∈ N and a circuit hc such that ∀i ∈ {0, 1} m : hc(i) = h(i) and |hc| &lt; 2 m , moreover such hc can be efficiently computed and is sufficient here.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11" xml:id="foot_8"><p>To make the proof and the statement of Lemma 3 simple (i.e. purely information theoretic), we will consider a computationally unbounded TM with oracle access to a truly random permutation which it can access a polynomial number of times, whereas Lemma 2 is about a opptTM and permutations chosen randomly from some family of exponential size. But as already mentioned, considering a random permutation is fine as a opptTM cannot distinguish a random permutation from f pk,n where pk ∈R {0, 1} n anyway. And considering any computationally unbounded oracle TM (instead of only opptTMs) makes the lemma only stronger.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="12" xml:id="foot_9"><p>It can easily be upper bounded by 1/(2 nn cn 2c ): given the n c oracle queries (not containing the query xi) made by A f and additionally the ≤ n 2c oracle queries made by h f on inputs 1, . . . , |h| (which will not contain the query xi because of condition 3), xi is a random variable with the uniform distribution over a set of size ≥ 2 nn cn 2c .</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="16" xml:id="foot_10"><p>Moreover, if we let s(n) = max{|hi| : i ∈ Range(Index(1 n ))} denote an upper bound on the size of a description of the hash function used, then the theorem even holds if we restrict the number of chosen message queries to s(n) + q(n) and the size of the message-space of the signature scheme to s(n) + q(n) + 1.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="17" xml:id="foot_11"><p>A one-chosen-message attack is precisely an attack where at most one query to the signing oracle is allowed.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Supported by NSF CAREER Award CCR-0133806 and TC Grant No. CCR-0311095. Supported by the Swiss National Science Foundation, project No. 200020-103847/1.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">PKCS #1 v2.1, RSA Cryptography Standard (draft), document available at www.rsa security</title>
		<ptr target=".com/rsalabs/pkcs" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">An Uninstantiable Random-Oracle-Model Scheme for a Hybrid-Encryption Problem. EURO-CRYPT 04</title>
		<author>
			<persName><forename type="first">Mihir</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexandra</forename><surname>Boldyreva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adriana</forename><surname>Palacio</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="171" to="188" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Random Oracles are Practical: A Paradigm for Designing Efficient Protocols</title>
		<author>
			<persName><forename type="first">Mihir</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Phillip</forename><surname>Rogaway</surname></persName>
		</author>
		<imprint>
			<publisher>ACM CCS</publisher>
			<biblScope unit="volume">93</biblScope>
			<biblScope unit="page" from="62" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The One-More-RSA-Inversion Problems and the Security of Chaum&apos;s Blind Signature Scheme</title>
		<author>
			<persName><forename type="first">Mihir</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chanathip</forename><surname>Namprempre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Pointcheval</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Semanko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of Cryptology</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="185" to="215" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Analysis of Random Oracle Instantiation Scenarios for OAEP and Other Practical Schemes</title>
		<author>
			<persName><forename type="first">Alexandra</forename><surname>Boldyreva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc</forename><surname>Fischlin</surname></persName>
		</author>
		<idno>CRYPTO 05</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Adaptively Secure Multi-Party Computation</title>
		<author>
			<persName><forename type="first">Ran</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Uri</forename><surname>Feige</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oded</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moni</forename><surname>Naor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">STOC</title>
		<imprint>
			<biblScope unit="volume">96</biblScope>
			<biblScope unit="page" from="22" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">The Random Oracle Methodology</title>
		<author>
			<persName><forename type="first">Ran</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oded</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shai</forename><surname>Halevi</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="209" to="218" />
		</imprint>
	</monogr>
	<note>Revisited. STOC 98</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On the Random Oracle Methodology as Applied to Length-Restricted Signature Schemes</title>
		<author>
			<persName><forename type="first">Ran</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oded</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shai</forename><surname>Halevi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TCC</title>
		<imprint>
			<biblScope unit="volume">04</biblScope>
			<biblScope unit="page" from="40" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Perfectly One-Way Probabilistic Hash Functions</title>
		<author>
			<persName><forename type="first">Ran</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniele</forename><surname>Micciancio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Omer</forename><surname>Reingold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">STOC</title>
		<imprint>
			<biblScope unit="volume">98</biblScope>
			<biblScope unit="page" from="131" to="140" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">On the Exact Security of Full Domain Hash</title>
		<author>
			<persName><forename type="first">Jean-Sébastian</forename><surname>Coron</surname></persName>
		</author>
		<idno>CRYPTO 00</idno>
		<imprint>
			<biblScope unit="page" from="229" to="235" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Optimal Security Proofs for PSS and other Signature Schemes</title>
		<author>
			<persName><forename type="first">Jean-Sébastian</forename><surname>Coron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EUROCRYPT</title>
		<imprint>
			<biblScope unit="volume">02</biblScope>
			<biblScope unit="page" from="272" to="287" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Collision-Free Hash Functions and Public-Key Signature Schemes</title>
		<author>
			<persName><forename type="first">Ivan</forename><surname>Damgård</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EUROCRYPT</title>
		<imprint>
			<biblScope unit="volume">87</biblScope>
			<biblScope unit="page" from="203" to="216" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">New directions in cryptography</title>
		<author>
			<persName><forename type="first">Whitfield</forename><surname>Diffie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Hellman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="644" to="654" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">On the Power of Claw-Free Permutations</title>
		<author>
			<persName><forename type="first">Yevgeniy</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Reyzin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SCN</title>
		<imprint>
			<biblScope unit="volume">02</biblScope>
			<biblScope unit="page" from="55" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">How to prove yourself: Practical solutions to identification and signature problems</title>
		<author>
			<persName><forename type="first">Amos</forename><surname>Fiat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adi</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CRYPTO</title>
		<imprint>
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="page" from="186" to="194" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Lower Bounds on the Efficiency of Encryption and Digital Signature Schemes</title>
		<author>
			<persName><forename type="first">Rosario</forename><surname>Gennaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yael</forename><surname>Gertner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC 03</title>
		<imprint>
			<biblScope unit="page" from="417" to="425" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Lower Bounds on the Efficiency of Generic Cryptographic Constructions</title>
		<author>
			<persName><forename type="first">Rosario</forename><surname>Gennaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luca</forename><surname>Trevisan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS 00</title>
		<imprint>
			<biblScope unit="page" from="305" to="313" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">On the Impossibility of Basing Trapdoor Functions on Trapdoor Predicates</title>
		<author>
			<persName><forename type="first">Yael</forename><surname>Gertner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tal</forename><surname>Malkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Omer</forename><surname>Reingold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">FOCS</title>
		<imprint>
			<biblScope unit="volume">01</biblScope>
			<biblScope unit="page" from="126" to="135" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The Relationship Between Public-Key Encryption and Oblivious Transfer</title>
		<author>
			<persName><forename type="first">Yael</forename><surname>Gertner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sampath</forename><surname>Kannan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Omer</forename><surname>Tal Malkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mahesh</forename><surname>Reingold</surname></persName>
		</author>
		<author>
			<persName><surname>Viswanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS 00</title>
		<imprint>
			<biblScope unit="page" from="325" to="335" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">On the (In)security of the Fiat-Shamir Paradigm</title>
		<author>
			<persName><forename type="first">Shafi</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yael</forename><surname>Tauman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS 03</title>
		<imprint>
			<biblScope unit="page" from="102" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Finding Collisions on a Public Road, or do Secure Hash Functions Need Secret Coins? CRYPTO 04</title>
		<author>
			<persName><forename type="first">Chun-Yuan</forename><surname>Hsiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Reyzin</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="92" to="105" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Limits on the Provable Consequences of One-Way Permutations</title>
		<author>
			<persName><forename type="first">Russell</forename><surname>Impagliazzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steven</forename><surname>Rudich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">STOC</title>
		<imprint>
			<biblScope unit="volume">89</biblScope>
			<biblScope unit="page" from="44" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Limits on the Efficiency of One-Way Permutation-Based Hash Functions</title>
		<author>
			<persName><forename type="first">Han</forename><surname>Jeong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">R</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Prasad</forename><surname>Simon</surname></persName>
		</author>
		<author>
			<persName><surname>Tetali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">FOCS</title>
		<imprint>
			<biblScope unit="volume">99</biblScope>
			<biblScope unit="page" from="535" to="542" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Positive Results and Techniques for Obfuscation</title>
		<author>
			<persName><forename type="first">Ben</forename><surname>Lynn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manoj</forename><surname>Prabhakaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amit</forename><surname>Sahai</surname></persName>
		</author>
		<imprint>
			<biblScope unit="volume">04</biblScope>
			<biblScope unit="page" from="20" to="39" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Verifiable Random Functions</title>
		<author>
			<persName><forename type="first">Silvio</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Rabin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Salil</forename><surname>Vadhan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">FOCS</title>
		<imprint>
			<biblScope unit="volume">99</biblScope>
			<biblScope unit="page" from="120" to="130" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Separating Random Oracle Proofs from Complexity Theoretic Proofs: The Non-Committing Encryption Case</title>
		<author>
			<persName><forename type="first">Jesper</forename><surname>Buus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nielsen</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CRYPTO</title>
		<imprint>
			<biblScope unit="volume">02</biblScope>
			<biblScope unit="page" from="111" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Finding Collisions on a One-Way Street: Can Secure Hash Functions be Based on General Assumptions?</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Simon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EUROCRYPT</title>
		<imprint>
			<biblScope unit="volume">98</biblScope>
			<biblScope unit="page" from="334" to="345" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">On Obfuscating Point Functions</title>
		<author>
			<persName><forename type="first">Hoeteck</forename><surname>Wee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC 05</title>
		<imprint>
			<biblScope unit="page" from="523" to="532" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
