<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main"></title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">D03847FF48465955190DB95BC9B3C554</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:13+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Java has demonstrated the utility of type systems for mobile code, and in particular their use and implications for security. Security properties rest on the fact that a well-typed Java program (or the corresponding verified bytecode) cannot cause certain kinds of damage. In this paper we provide a type system for mobile computation, that is, for computation that is continuously active before and after movement. We show that a well-typed mobile computation cannot cause certain kinds of run-time fault: it cannot cause the exchange of values of the wrong kind, anywhere in a mobile system.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In previous work <ref type="bibr" target="#b2">[3]</ref> we introduced the (untyped, monadic) ambient calculus, a process calculus for mobile computation and mobile devices. That calculus is able to express, via encodings, standard computational constructions such as channel-based communication, functions, and agents.</p><p>The type system presented in this paper is able to provide typings for those encodings, recovering familiar type systems for processes and functions. In addition, we obtain a type system for mobile agents and other mobile computations. The type system is obtained by decorating the untyped calculus with type information.</p><p>An ambient, in our sense, is a confined place where processes run. Each ambient has a name, and may contain multiple processes and subambients. A process can cause its surrounding ambient to move in or out of other ambients, transporting all the subambients and active processes with it. A process may also open an ambient, that is, it can dissolve an ambient boundary while preserving its contents. Finally, processes within the same ambient may exchange messages.</p><p>Our type system tracks the typing of messages exchanged within an ambient. For example, the following system consists of two ambients, named a and b:</p><p>The ambient named a contains a process (x:Int).P that is ready to read an integer message into a variable x and proceed with P, and a process open b that is ready to open (dissolve the boundary) of an ambient b found within a. The ambient named b contains a process in a. j3k that moves the ambient b inside a (by executing in a) and then outputs a <ref type="bibr">[(x:Int)</ref></p><formula xml:id="formula_0">.P | open b] | b[in a. j3k]</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Types for Mobile Ambients</head><p>Luca Cardelli Andrew D. Gordon the message 3. The ambient b is opened after moving into a, so the output comes into direct contact with the reading process within a. The result is the binding of an integer message to an integer variable, yielding the state:</p><p>The challenge of the type system is to verify that this exchange of messages is welltyped. Note that in the original system the input and the output were contained in separate locations.</p><p>Our ambient calculus is related to earlier distributed variants of the π-calculus, some of which have been equipped with type systems. The type system of Amadio <ref type="bibr" target="#b0">[1]</ref> prevents a channel from being defined at more than one location. Sewell's system <ref type="bibr" target="#b7">[8]</ref> tracks whether communications are local or non-local, so as to allow efficient implementation of local communication. In Riely and Hennessy's calculus <ref type="bibr" target="#b6">[7]</ref>, processes need appropriate permissions to perform actions such as migration; a well-typed process is guaranteed to possess the appropriate permission for any action it attempts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The Polyadic Ambient Calculus</head><p>We begin by reviewing and slightly extending the ambient calculus of <ref type="bibr" target="#b2">[3]</ref>. In that calculus, communication is based on the exchange of single values. Here we extend the calculus with communication based on tuples of values (polyadic communication), since this simple extension greatly facilitates the task of providing an expressive type system. In addition, we annotate bound variables with type information.</p><p>Four of our process constructions (restriction, inactivity, composition and replication) are commonly found in process calculi. To these we add ambients, capabilities, and a simple form of communication. We briefly discuss these constructions; see <ref type="bibr" target="#b2">[3]</ref> for a more detailed introduction.</p><p>The restriction operator, (νn:W)P, creates a new (unique) name n of type W within a scope P. The new name can be used to name ambients and to operate on ambients by name. The inactive process, 0, does nothing. Parallel composition is denoted by a binary operator, P|Q, that is commutative and associative. Replication is a technically convenient way of representing iteration and recursion: the process !P denotes the unbounded replication of the process P and is equivalent to P|!P.</p><p>An ambient is written M <ref type="bibr">[P]</ref>, where M is the name of the ambient, and P is the process running inside the ambient.</p><p>The process M.P executes an action regulated by the capability M, and then continues as the process P. We consider three kinds of capabilities: one for entering an ambient, one for exiting an ambient and one for opening up an ambient. (The latter requires special care in the type system.) Capabilities are obtained from names; given a name n, the capability in n allows entry into n, the capability out n allows exit out of n and the capability open n allows the opening of n. Implicitly, the possession of one or all of these capabilities is insufficient to reconstruct the original name n from which they were extracted. Capabilities can also be composed into paths, M.M', with ε for the empty path.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>a[P{x←3}]</head><p>Communication is asynchronous and local to an ambient. It is similar to channel communication in the π-calculus, except that the channel has no name: the surrounding ambient provides the context where the communication happens. The process jM 1 , ..., M k k represents the output of a tuple of values, with no continuation. The process (n 1 :W 1 , ..., n k :W k ).P represents the input of a tuple of values, with continuation P.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Polyadic Ambient Calculus</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Syntactic conventions</head><p>The following tables describe the operational semantics of the calculus. The type annotations present in the syntax do not play a role in reduction; they are simply carried along by the reductions and will be explained in the next section.</p><p>Terms are identified up to an equivalence relation, , called structural congruence. This relation provides a way of rearranging expressions so that interacting parts can be brought together. Then, a reduction relation, xyyz, acts on the interacting parts to produce computation steps. The core of the calculus is given by the reduction rules (Red In), (Red Out), and (Red Open), for mobility, and (Red Comm), for communication. </p><formula xml:id="formula_1">)P n[] $ n[0] M $ M.0</formula><p>(where appropriate)</p><p>Terms are also identified up to the consistent renaming of bound variables, in the restriction and input constructs. We write P{n←M} for the substitution of M for each free occurrence of the name n in the process P. Similarly for M{n←M'}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Free names</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Structural Congruence</head><p>fn((νn:W)P) $ fn(P) -{n} fn(0 </p><formula xml:id="formula_2">) $ Ô fn(P|Q) $ fn(P) ∪ fn(Q) fn(n) $ {n} fn(in M) $ fn(M) fn(out M) $ fn(M) fn(!P) $ fn(P) fn(M[P])$ fn(M) ∪ fn(P) fn(M.P) $ fn(M) ∪ fn(P) fn(open M) $ fn(M) fn(ε) $ Ô fn(M.M') $ fn(M) ∪ fn(M') fn((n 1 :W 1 , ..., n k :W k ).P) $ fn(P) -{n 1 , ..., n k } fn(jM 1 , ..., M k k) $ fn(M 1 ) ∪ ... ∪ fn(M k ) P P P Q ⇒ Q P P Q, Q R ⇒ P R (Struct Refl) (Struct Symm) (Struct Trans) P Q ⇒ (νn:T)P (νn:T)Q P Q ⇒ P | R Q | R P Q ⇒ !P !Q P Q ⇒ M[P] M[Q] P Q ⇒ M.P M.Q P Q ⇒ (n 1 :T 1 , ..., n k :T k ).P (n 1 :T 1 , ..., n k :T k ).Q (Struct Res) (Struct Par) (Struct Repl) (Struct Amb) (Struct Action) (Struct Input) P | Q Q | P (P | Q) | R P | (Q | R</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Reduction 3 Exchange Types</head><p>An ambient is a place where other ambients can enter and exit, and where processes can exchange messages. The first aspect, mobility, is regulated by run-time capabilities and will not be restricted by our type system. The second aspect, communication, is what we now concentrate on.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Topics of Conversation</head><p>Within an ambient, multiple processes can freely execute input and output actions. Since the messages are undirected, it is easily possible for a process to utter a message that is not appropriate for some receiver. The main idea of our type system is to keep track of the topic of conversation that is permitted within a given ambient, so that talkers and listeners can be certain of exchanging appropriate messages.</p><p>The range of topics is described in the following table by message types, W, and exchange types, T. The message types are Amb[T], the type of names of ambients that allow exchanges of type T, and Cap[T], the type of capabilities that when used may cause the unleashing of T exchanges (as a consequence of opening ambients that exchange T). The exchange types are Shh, the absence of exchanges, and W 1 ×...×W k , the exchange of a tuple of messages with elements of the respective message types. For k=0, the empty tuple type is called 1; it allows the exchange of empty tuples, that is, it allows pure synchronization. The case k=1 allows any message type to be an exchange type.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Types</head><p>For example: • A synchronization ambient: Amb <ref type="bibr" target="#b0">[1]</ref> • An ambient that allows the exchange of harmless capabilities: Amb[Cap <ref type="bibr">[Shh]</ref>]</p><formula xml:id="formula_3">n[in m. P | Q] | m[R] xyyz m[n[P | Q] | R] m[n[out m. P | Q] | R] xyyz n[P | Q] | m[R] open n. P | n[Q] xyyz P | Q (n 1 :W 1 , ..., n k :W k ).P | jM 1 , ..., M k k xyyz P{n 1 ←M 1 , ..., n k ←M k } (Red In) (Red Out) (Red Open) (Red Comm) P xyyz Q ⇒ (νn:W)P xyyz (νn:W)Q P xyyz Q ⇒ n[P] xyyz n[Q] P xyyz Q ⇒ P | R xyyz Q | R (Red Res) (Red Amb) (Red Par) P' P, P xyyz Q, Q Q' ⇒ P' xyyz Q' (Red ) W ::= Amb[T]</formula><p>• A capability that may unleash the exchange of names of quiet ambients:</p><formula xml:id="formula_4">Cap[Amb[Shh]]</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Intuitions</head><p>Before presenting the formal type rules, we discuss the intuitions that lead to them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Typing of Processes</head><p>If a message M has message type W, then jMk is a process that outputs (exchanges) W messages. Therefore, we will have a rule stating that:</p><p>If P is a process that may exchange W messages, then (x:W).P is also a process that may exchange W messages. Therefore:</p><p>The process 0 exchanges nothing, so it naturally has exchange type Shh. However, we may also consider 0 as a process that may exchange any type. This is useful when we need to place 0 in a context that is already expected to exchange some type.</p><p>If P and Q are processes that may exchange T, then P|Q is also such a process. Similarly for !P.</p><p>Therefore, by keeping track of the exchange type of a process, T-inputs and T-outputs are tracked so that they match correctly when placed in parallel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Typing of Ambients</head><p>An ambient n[P] is a process that exchanges nothing at the current level, so, like 0, it can have any exchange type, and can be placed in parallel with any process.</p><p>There needs to be, however, a connection between the type of n and the type of P. We give to each ambient name a type Amb[T], meaning that only T exchanges are allowed in any ambient of that name. Ambients of different names may permit internal exchanges of different types. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Typing of Open</head><p>Tracking the type of I/O exchanges is not enough by itself. We also need to worry about open, which might open an ambient and unleash its exchanges inside the surrounding ambient.</p><p>If ambients named n permit T exchanges, then the capability open n may unleash those T exchanges. We then say that open n has a capability type Cap[T], meaning that it may unleash T exchanges when used:</p><p>As a consequence, any process that uses a Cap[T] must be a process that is already willing to participate in exchanges of type T, because further T exchanges may be unleashed.</p><p>The capability types Cap[T] do not keep track of any information concerning in and out capabilities; only the effect of open is tracked.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Typing Rules</head><p>We base our type system on three judgments. The main judgment tracks the exchange type of a process, that is the type of the I/O operations of the process, and of the I/O operations that the process may unleash by opening other ambients.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Judgments</head><p>Based on the discussion in the previous section, we can formalize the type system as described in the following table. Convention: a list of assumptions E J 1 ... E J k for k=0 means E /.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Rules</head><formula xml:id="formula_5">n : Amb[T] ⇒ open n : Cap[T] M : Cap[T], P : T ⇒ M.P : T E /</formula><p>good environment E M: W good expression of message type W E P:T good process of exchange type T</p><formula xml:id="formula_6">(Env Ô) (Env n) (Exp n) E / nÑdom(E) E', n:W, E" / Ô / E, n:W / E', n:W, E" n : W (Exp ε) (Exp .) E / E M : Cap[T] E M' : Cap[T] E ε : Cap[T] E M.M' : Cap[T]</formula><p>• Example: A process that outputs names of quiet ambients:</p><p>• Example: A capability that may unleash S-exchanges. Note that the in n action contributes nothing to the type of the path; only the open m action does:</p><p>The correctness of the type system is expressed by the following proposition:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3-1 Proposition (Subject Reduction)</head><p>If E P :</p><formula xml:id="formula_7">U and P x xy yyz yz Q then E Q : U. Proof See Appendix 7.</formula><p>1</p><p>As a consequence, certain "run-time error" expressions, such as in n[P], n.P, and jin (in n)k cannot arise. These are not initially typeable, and cannot be produced by well-typed processes because Proposition 3-1 says that the evolution of well-typed processes leads only to well-typed processes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Applications</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Channel Types</head><p>We now begin to explore the expressiveness of our type system. The first test case is whether we can represent typed communication channels, that is, whether we can find a typed encoding of the π-calculus <ref type="bibr" target="#b4">[5]</ref>.</p><formula xml:id="formula_8">(Exp In) (Exp Out) (Exp Open) E M : Amb[S] E M : Amb[S] E M : Amb[T] E in M : Cap[T] E out M : Cap[T] E open M : Cap[T] (Proc Action) (Proc Amb) E M : Cap[T] E P : T E M : Amb[T] E P : T E M.P : T E M[P] : S (Proc Res) (Proc Zero) (Proc Par) (Proc Repl) E, n:Amb[T] P : S E / E P : TE Q : T E P : T E (νn:Amb[T])P : S E 0 : T E P|Q : T E !P : T (Proc Input) (Proc Output) E, n 1 :W 1 , ..., n k :W k P : W 1 ×...×W k E M 1 : W 1 ...E M k : W k E (n 1 :W 1 , ..., n k :W k ).P : W 1 ×...×W k E jM 1 , ..., M k k : W 1 ×...×W k Ô !(νn:Amb)jnk :Amb Ô, n:Amb[T], m:Amb[S] in n. open m :Cap[S]</formula><p>The basic idea for the encoding of channels is to use an ambient as a buffer where input and output processes can exchange messages. An output operation generates an output packet that enters the buffer and (after being opened) deposits an output. An input operation generates an input packet that similarly enters the buffer, reads an input, and creates a return packet that exits the buffer and continues with the rest of the process. Each name of the π-calculus becomes a pair of names in the ambient calculus: the name of the buffer and the name of the packets. Therefore, communication of a πcalculus name becomes the communication of a pair of ambient calculus names. A πcalculus channel type Ch[W] for names of type W is translated as Amb <ref type="bibr">[W×W]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Encoding of the Typed Polyadic Asynchronous π-calculus</head><p>The translation induces the following derived typing rules. Each π-calculus process is given the type Shh, since no communication happens at the level of processes. Instead, communication happens within buffers, so each buffer receives the type of the corresponding π-calculus channel. Input and output packets receive the same type as the buffers where they are opened.</p><p>Georges Gonthier has devised two other encodings of the π-calculus as ambients. The first encoding uses a single name n for both the buffer and the associated packets, instead of pairs of names n, n p . The packets are temporarily hidden inside another layer of ambients, so that there is no confusion between packets and buffers. For the π-calculus this techniques leads to a nicer encoding, where a channel type maps simply to an ambient type. Still, the technique of passing packet names along with associated ambient names, as in the previous encoding, is often useful.</p><formula xml:id="formula_9">nE Po $nEo nPo : Shh nÔ, n 1 :W 1 , ..., n k :W k o $ Ô, n 1 :nW 1 o, n 1 p :nW 1 o, ..., n k :nW k o, n k p :nW k o nCh[W 1 , ..., W k ]o $ Amb[nW 1 o×nW 1 o×...×nW k o×nW k o] n(ν π n:Ch[W 1 , ..., W k ])Po $ (νn,n p :nCh[W 1 , ..., W k ]o) (n[!open n p ] | nPo) nn(n 1 :W 1 , ..., n k :W k ).Po $ (νp:Amb) (open p | n p [in n. (n 1 ,n p 1 :nW 1 o, ..., n k ,n p k :nW k o). p[out n. nPo]]) nnjn 1 , ..., n k ko$n p [in n. jn 1 , n p 1 , ..., n k , n p k k] nP|Qo $nPo|nQo n!Po$!nPo nE,n:Ch[W 1 , ..., W k ] Po ⇒ nE (ν π n:Ch[W 1 , ..., W k ])Po nE n : Ch[W 1 , ..., W k ]o, nE n 1 : W 1 o, ..., nE n k : W k o ⇒ nE njn 1 , ..., n k ko nE n : Ch[W 1 , ..., W k ]o, nE, n 1 :W 1 , ..., n k :W k Po ⇒ nE n(n 1 :W 1 , ..., n k :W k ).Po nE Po, nE Qo ⇒ nE P|Qo nE Po ⇒ nE !Po</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Gonthier's Encoding</head><p>Gonthier's second encoding also uses single names for buffers and packets. In addition, the encoding does not rely on buffers being generated at the place of ν: buffers are generated whenever (and wherever!) needed by I/O operations. For the π-calculus this makes little difference, but if we imagine using channels freely within the ambient calculus, then it is important not to rely on a fixed location for the buffer: we may want I/O operations on a channel to interact whenever they occur within the same ambient. The potential problem with this idea is that, since there are multiple buffers, all the output packets may go in one buffer, and all the input packets may go in a different buffer.</p><p>To solve this problems, the buffers are designed to be self-coalescing. This technique is useful in general, when buffers need to be generated in a decentralized fashion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Gonthier's Coalescing Encoding</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Parent-Child Communication</head><p>It is often useful for an ambient to communicate with its parent or its children, as when an agent enters a server and wants to exchange information with it. We now describe such a derived communication mechanism, and how to type it.</p><formula xml:id="formula_10">nCh[W 1 , ..., W k ]o $ Amb[nW 1 o×...×nW k o] n(ν π n:Ch[W 1 , ..., W k ])Po $ (νn:nCh[W 1 , ..., W k ]o) n[!open n] | nPo nn(n 1 :W 1 , ..., n k :W k ).Po $ (νp:Amb) (open p | (νk:nCh[W 1 , ..., W k ]o) k[in n. n[out k. open k. (n 1 :nW 1 o, ..., n k :nW k o). p[out n. nPo]]) nnjn 1W1 , ..., n kWk ko$(νk:nCh[W 1 , ..., W k ]o) k[in n. n[out k. open k. jn 1 , ..., n k k]] nP|Qo $nPo|nQo n!Po$!nPo nCh[W 1 , ..., W k ]o $ Amb[nW 1 o×...×nW k o] n(ν π n:Ch[W 1 , ..., W k ])Po $ (νn:nCh[W 1 , ..., W k ]o) nPo nn(n 1 :W 1 , ..., n k :W k ).Po $ (νp:Amb) (open p.p[] | n[!open n | in n | (n 1 :nW 1 o, ..., n k :nW k o). p[!out n | open p.nPo]]) nnjn 1 , ..., n k ko$n[!open n | in n | jn 1 , ..., n k k] nP|Qo $nPo|nQo n!Po$!nPo</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Parent-Child I/O</head><p>We could adopt the following reduction rules as primitive:</p><p>Instead of taking these operators as primitive, it is possible to approximate parent I/O with normal ambient I/O. The encoding given below, however, fails to provide the same atomicity guarantees than the reductions above. When using this encoding, parent-child I/O operations are partially sensitive to disruptions of the protocol due to sudden movement of the child. To avoid this problem, the child has to implement its own synchronization.</p><p>The encoding of parent-to-child messaging is quite simple, using the child ambient as the communication buffer. Messages from the parent down to a child n ch use packets labeled n dn . This messaging is not sensitive to sudden movement of the child: messages from parent to child may get blocked but do not get lost.</p><p>The encoding of child-to-parent messaging, instead, is more problematic. There is a choice of where to put the communication buffer: in the child or in the parent. If the buffer is in the child, the parent has to send a process to fetch the message; such a process may get lost on the way back if the child has moved. If the buffer is in the parent, the child has to send a process to deposit the message; such a process may get lost if the child moves before the (asynchronous) process can get out.</p><p>In both cases, though, the child can wait for a confirmation from the parent that the message has reached the parent; this can be done with parent-to-child communication, which is reliable. After the confirmation, the child is free to move.</p><p>We describe the case where the buffer is kept in the parent. This arrangement seems more interesting because, with a simple modification, it can be extended to anonymous communication between arbitrary children and a parent.</p><p>Each communication from a child n ch to a parent happens within a mailbox n box within the parent; the mailboxes are self-coalescing. Messages from a child n ch up to the parent use packets labeled n up that are sent out of the child and then into n box . b njMk c n(x:W).P parent outputs to child n child n inputs from parent c njMk b n(x:W).P child n outputs to parent parent inputs from child n The type of names of child ambients that admit parent-child I/O is given by: That is, if n:Amb cb [T] then n ch , n up , n dn , n box are the four components.</p><formula xml:id="formula_11">b n(x:W).P | n[ c njMk | Q] xyyz P{x←M} | n[Q] b njMk | n[ c n(x:W).P | Q] xyyz n[P{x←M} | Q] b njMk $ n dn [in n ch .</formula><p>The derived type rules are as follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Function Types</head><p>By using a typed encoding of channels in the ambient calculus, we can provide typed encodings of λ-calculi simply by using the known encodings of λ-calculi into the π-calculus <ref type="bibr" target="#b5">[6]</ref>. For example:</p><p>Encoding of the Call-by Value λ λ-calculus in the π π-calculus </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Encoding of the</head><formula xml:id="formula_12">Amb cb [W] = Amb[W]×Amb[W]×Amb[W]×Amb[W] (n : Amb cb [W] ⇒ P : T) ⇒ (ν n : Amb cb [W]).P : T M : W, n : Amb cb [W] ⇒ b njMk : U (any U) M : W, n : Amb cb [W] ⇒ c njMk : U (any U) n : Amb cb [W], (x : W ⇒ P : W) ⇒ c n(x:W).P : W n : Amb cb [W], (x : W ⇒ P : W) ⇒ b n(x:W).P : W ?xA k $ k j j x k k ?λx.bA k $ (ν π n) (k j j n k k | !n(x, k'). ?bA k' ) ?b(a)A k $ $ (ν π k', k") (?bA k' | k'(x). (?aA k" | k"(y). x j j y, k k k</formula><p>))</p><p>?E b:TA $ ?EA (ν π k:Ch[?TA]) ?bA k : Shh ?Ô, x 1 :A 1 , ..., x n :A n A $ Ô, x 1 :?A </p><formula xml:id="formula_13">?xA k $ kjxk ?λx:A.b A→B A k $ (ν π n:?A→BA) (kjnk | !n(x:?AA, k':Ch[?BA]). ?b B A k' ) ?b A→B (a A )A k $ $ (ν π k':Ch[?A→BA], k":Ch[?AA]) (?bA k' | k'(x:?A→BA). (?aA k" | k"(y:?AA). xjy, kk))</formula><p>Therefore, as in the π-calculus, a function is represented by a channel that communicates an argument and a channel for the result. The derived types reflect this structure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Records</head><p>We define operations for handling records of mutable cells; these will be useful in the next example.</p><p>A record r containing cells c i has the general structure r[ ...</p><formula xml:id="formula_14">| c i buf [jM i k | !open c i ip ] | ... ],</formula><p>where r is the cell container, c i buf are the value containers for each cell, c i ip are input packets for reading and writing cell contents, and M i are the cell contents. The operations consist of creating an empty record named r (record r), adding a cell named c with initial contents M to a record r (add r c M), reading the contents of cell c of record r and binding it to a variable x in a scope P (get r c (x:W). P), and setting the contents of a cell c of record r to a value M and continuing with P (set r c jMk. P).</p><p>The names c buf and c ip related to a cell c are assigned the type Amb[W], where W is the type of the values held by the cell. The name r of a record is simply assigned the type Amb <ref type="bibr">[Shh]</ref>. A record is able to hold cells of different types.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Agents</head><p>One of the original motivations of the ambient calculus was to provide a natural semantics for wide-area network languages. We now define a simple agent language inspired by Telescript <ref type="bibr" target="#b8">[9]</ref>. In the Telescript model, agents travel over the network between places (agent servers) where agents can meet and communicate with other agents. Agents carry with them a suitcase containing local agent data.</p><p>The syntax of our stripped-down agent language (Telestrip'd) is described in the following table, together with an informal description of the various constructions. We give the semantics of Telestrip'd by translation to the ambient calculus. The dynamic hierarchical structure of places, agents and suitcases is preserved by our translation; it would not be preserved so obviously by translations into standard process calculi. We are able to assign types to our definitions, yielding a typed agent language. No exchange happens at the network level, so the network has type Shh. Each arena has also type Shh, so the name of each place has type Amb <ref type="bibr">[Shh]</ref>.</p><formula xml:id="formula_15">nrecord ro $ r[] nadd r c Mo $ c buf [!open c ip | in</formula><p>The type of an ambient reflects only the type of the exchanges performed within it; each agent welcomes (inputs) a single type of data, but can output to agents of several different types. The meet primitive given above is asynchronous; a (more natural) synchronous version is possible but more complicated.</p><p>The name of the agent suitcase, sut, is a global distinguished name of type Amb <ref type="bibr">[Shh]</ref>. A suitcase is a record containing a collection of cells. Each suitcase contains a cell named at, a global distinguished name of type Amb[Amb <ref type="bibr">[Shh]</ref>], containing the name of the agent's current place.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Linear Capability Types</head><p>In this section, we describe an extension of our type system obtained by adding a new type of linear capabilities Cap 1 [T]. We enforce the rule that whenever a process inputs a capability of this type, the process may exercise or output the capability at most once.</p><p>The motivation for this type system is that in some situations we may want capabilities to play the role of tickets or stamps that may be used once to access a valuable resource (for example, a compute server, or a printer). We would like to guarantee that if a well-typed process is presented with k capabilities for accessing a resource, perhaps after a fee has been paid, then that resource is exercised at most k times.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Limiting the Use of Capabilities</head><p>Linear type systems for the π-calculus, beginning with the work of Kobayashi, Pierce, Turner <ref type="bibr" target="#b3">[4]</ref>, restrict the usages of bound names in a variety of ways. Our system is analogous. We modify the syntax of types by renaming Cap[T] to Cap ω [T] and by introducing a new type, Cap 1 [T], of linear capabilities. The multiplicities 0, 1 and ω are used to count the number of occurrences of names in terms. We enforce the following simple principles:</p><p>• An input name of type Cap 1 [T] may be exercised at most once.</p><p>• An input name of type Cap ω [T] or Amb[T] may be exercised as often as desired, as before.</p><p>• A restricted name of type Amb[T] may be exercised as often as desired, as before.</p><p>?  Here is the syntax of the extended type system:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Types</head><p>We let µ + range over {1, ω}.</p><p>Let the multiplicity order, µ ≤ µ', be the least reflexive and transitive relation to satisfy 0 ≤ 1 ≤ ω. Let the addition, µ+µ' of multiplicities µ and µ' be the multiplicity defined by the equations µ+0 = 0+µ = µ, 1+1 = ω, and µ+ω = ω+µ = ω. Let the replication, !µ, of a multiplicity be the multiplicity µ+µ.</p><p>The functions n occurs M and n occurs P, given by the following equations, count the occurrences of the name n in the term M and in the process P, respectively. Note that any name under a ! has multiplicity ω. For example:</p><formula xml:id="formula_16">W ::= Amb[T] Cap 1 [T] Cap ω [T]</formula><p>We define a new type system using the same rules as before except for the modifications listed below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Rules</head><p>A subject reduction result can be proven for the modified system.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Avoiding a Synchronization Error Using Linear Types</head><p>To illustrate the use of linear capability types, we describe a taxi protocol. This protocol uses linearity to achieve proper movement synchronization between two parties. The taxi publishes a capability for a passenger to enter a seat in the back of the taxi. The passenger enters and tells the taxi a route to follow. At the end of the trip the taxi door is unlocked, and the passenger may exit. The capabilities for entering and exiting the taxi, and for the route, are given linear types.</p><p>If the capability to enter the taxi were to be accidentally or maliciously duplicated, a synchronization error could arise, in which a passenger holding a valid capability would attempt to enter the taxi, but would be left behind because another passenger got the taxi first. This possibility is ruled out by linear typing.</p><formula xml:id="formula_17">n occurs (n 1 :W 1 , ..., n k :W k ).P $ n occurs P for n Ñ{n 1 , ..., n k } n occurs jM 1 , ..., M k k $ (n occurs M 1 ) + ... + (n occurs M k ) n occurs (m[] | (νn:W) n[]) = 0 n occurs m[n.0] = 1 n occurs (m[n.0] | jnk) = ω (Exp ε) (Exp .) E / E M : Cap µ + [T] E M' : Cap µ + [T] E ε : Cap µ + [T] E M.M' : Cap µ + [T] (Exp In) (Exp Out) (Exp Open) E M : Amb[S] E M : Amb[S] E M : Amb[T] E in M : Cap µ + [T] E out M : Cap µ + [T] E open M : Cap µ + [T] (Proc Action) (Proc Input) (where ÒiÐ1..k. W i =Cap 1 [T i ] ⇒ n i occurs P ≤ 1) E M : Cap µ + [T] E P : T E, n 1 :W 1 , ..., n k :W k P : W 1 ×...×W k E M.P : T E (n 1 :W 1 , ..., n k :W k ).P : W 1 ×...×W k</formula><p>In the following, the parameter M is the route the taxi is to follow, and the parameter P is the behavior of the passenger at the destination.</p><p>If we suppose there is some environment E with: then:</p><p>(N.B.: the passenger-taxi system can also be given type Cap ω [Shh]. We can force the Cap 1 [Shh] typing by situating the system within an ambient whose name has type</p><formula xml:id="formula_18">Amb[Cap 1 [Shh]].)</formula><p>Initially, the system reduces as follows, up to the point where the passenger has entered the taxi and the taxi is ready to follow the route M:</p><p>Once the route M has been followed, the lock ambient is opened, and the passenger exits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Dispensing Transferrable Tokens Using Linear Types</head><p>A second example demonstrates that linear types allow capabilities to serve as consumable, transferrable tokens for a resource. We consider a system consisting of several principals that are given access to a printer. Each principal has an API (interface) allowing it to print messages on the printer. Each time it accesses the API, a principal must consume a token, the capability open api. This capability is given the linear type Cap 1 [Msg], where Msg is the type of messages printed by the printer. By dispensing different numbers of these tokens to different principals, we may selectively control the number of messages each principal has a passenger M P $ (enter:Cap right to print. The top-level of our system, sys, serves as a printer spool; any outputs here may be thought of as being sent to a printer. We describe each principal as follows:</p><p>The process parameter P models the specific behavior of the principal. We assume that the names api and print are not free in P. The ambient named toks represents a channel on which the principal receives capabilities for printing. A token open api provides access to the printer API, which is defined by: Our example system consists of two principals, named alice and bob:</p><p>In this example, we dispense two tokens to alice, via the process toks[in alice. in toks | jopen apik | jopen apik], but none to bob. Principal alice inputs the two tokens as variables x 1 and x 2 ; she uses x 1 herself to print M, but donates the other to bob, who inputs it as y, and uses it to print N.</p><p>The process sys has type Msg. We have:</p><p>We may easily add more principals to this example, and we may dispense as many tokens as is appropriate to each new principal. By using linear types to regulate the use of printer tokens, principals are free to transfer tokens amongst themselves, but the total number of messages printed is limited by the number of tokens dispensed initially. Without linear types, it would be harder to allow the transfer of printer tokens between principals while still controlling their total number.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusions</head><p>We have presented a type system for the ambient calculus. The types arising from this work are unusual in that they do not correspond directly to channel or function types. The type system guarantees the soundness of message exchanges, while leaving great flexibility in mobility. As an example, we have given a natural semantics for a typed agent language. </p><formula xml:id="formula_19">principal n P $ n[open n | printAPI n | toks[!open toks | P]] printAPI n $ !api[(x:Msg).</formula><formula xml:id="formula_20">* jMk | jNk</formula><p>Our type system is rather basic, roughly corresponding to the simply-typed discipline for the λ-calculus. Much richer typing disciplines can be imagined, along the usual lines. Perhaps more interestingly, it is appealing to try and use static type systems to restrict mobility; this is the subject of current work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>By mutual induction on the derivations of P Q and Q P.    </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>) !P P | !P (Struct Par Comm) (Struct Par Assoc) (Struct Repl Par) (νn:T)(νm:U)P (νm:U)(νn:T)P if n ≠ m (νn:T)(P | Q) P | (νn:T)Q if n Ñ fn(P) (νn:T)m[P] m[(νn:T)P]if n ≠ m (Struct Res Res) (Struct Res Par) (Struct Res Amb) P | 0 P (νn:Amb[T])0 0 !0 0 (Struct Zero Par) (Struct Zero Res) (Struct Zero Repl) ε.P P (M.M').P M.M'.P (Struct ε) (Struct .)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>M</head><label></label><figDesc>: W ⇒ jMk : W P : W ⇒ (x:W).P : W 0 : T for any T P : T, Q : T ⇒ P|Q : T P : T ⇒ !P : T n[P] : T for any T n : Amb[T], P : T ⇒ n[P] is well-formed (and can have any type) By tagging the name of an ambient with the type of exchanges, we know what kind of exchanges to expect in any ambient we enter. Moreover, we can tell what happens when we open an ambient of a given name.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>jMk] c n(x:W).P $ open n dn . (x:W). P (The idioms open p. p[] and p[ ... open p. P] are used to delay the activation of P until P reaches the proper position.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>(x:Cap 1 [T]). (jxk|jxk), (x:Cap 1 [T]). (jxk|n[x.P]) • Allowed: (x:Cap ω [T]). (jxk|jxk|n[x.P]), (x:Amb[T]). (x[]|x[]), (x:Amb[T]). (x[P]|x[Q]), (νx:Amb[T]). (jopen xk|jopen xk|(y:Cap 1 [T]). jyk)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>1</head><label>1</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>:</head><label></label><figDesc>) Then P R, R Q for some R. By induction hypothesis (1), ) Then P = (νn:W)P' and Q = (νn:W)Q', with P' Q'. This must have been derived from (Proc Res), with E, n:Amb[T] P' : U, where W=Amb[T]. By induction hypothesis, E, n:Amb[T] ) Then P = P' | R, Q = Q' | R, and P' Q'. Assume E P' | R : U. This must have been derived from (Proc Par), with E P' : U and E R : U. By induction hypothesis E Q' : U. By (Proc Par) E Q' | R : U. (Struct Repl) Then P = !P', Q = !Q', and P' Q'. Assume E P : U. This must have been derived from (Proc Repl), with E P' ) Then P = M[P'], Q = M[Q'], and P' Q'. This must have been derived from (Proc Amb), with E M : Amb[T] and E P' :T for some T. By induction hypothesis, ) Then P = M.P', Q = M.Q', and P' Q'. This must have been derived from (Proc Action), with E ) Then P = (n 1 :W 1 , ..., n k :W k ).P', Q = (n 1 :W 1 , ..., n k :W k ).Q', and P' Q'. This must have been derived from (Proc Input), with E, n1 :W 1 , ..., n k :W k P' : U, where U = W 1 ×...×W k . By induction hypothesis, E, n 1 :W 1 , ..., n k :W k Q' : U. By (Proc Input) E (n 1 :W 1 , ..., n k :W k ).Q' : U.(Struct Par Comm) Then P = P' | P" and Q = P" | P'. Assume E P' | P" : U. This must have been derived from (Proc Par), with E Assoc) Then P = (P' | P") | P'" and Q = P' | (P" | P'"). Assume E (P' | P") | P'" : U. This must have been derived from (Proc Par) twice, Par) Then P = !P' and Q = P' | !P'. This must have been derived from (Proc Repl), with E P' Res) Then P = (νn:W)(νm:V)P' and Q = (νm:V)(νn:W)P' with n ≠ m. Assume E (νn:W)(νm:V)P' : U. This must have been derived from (Proc Res) twice, with E, n:Amb[T], m:Amb[S] P' : U, where W=Amb[T] and V=Amb[S]. By Lemma 7-4 we have E, m:Amb[S], n:Amb[T] P' : U. By (Proc Res) twice we have E (νm:Amb[S])(νn:Amb[T])P' : U. (Struct Res Par) Then P = (νn:W)(P' | P") and Q = P' | (νn:W)P", with n Ñ fn(P'). This must have been derived from (Proc Res), with E, n:Amb[T] P' | P" : U and W = Amb[T], and from (Proc Par), with E, n:Amb[T] P' : U and E, n:Amb[T] P" : U. By Lemma 7-6, since n Ñ fn(P'), we have E P' : U. By (Proc Res) we have E (νn:Amb[T])P" : U. By (Proc Par) we have E P' | (νn:Amb[T])P" : U. (Struct Res Amb) Then P = (νn:W)m[P'] and Q = m[(νn:W)P'], with n ≠ m. Assume E P : U. This must have been derived from (Proc Res) with E, n:Amb[T] m[P'] : U with W = Amb[T], and from (Proc Amb) with E, n:Amb[T] P' : S and E, n:Amb[T] m : Amb[S] for some S. By (Proc Res) we have E (νn:Amb[T])P' : S. By Lemma 7-6, since n ≠ m, we have E m : Amb[S]. By (Proc Amb) we can derive E m[(νn:Amb[T])P'] : U. (Struct Zero Par) Then P = P' | 0 and Q = P'. This must have been derived from (Proc Par) with E P' Res) Then P = (νn:W)0 and Q = 0. This must have been derived from (Proc Res) with E, n:Amb[T] 0 : U and W = Amb[T]. By Lemma 7-6, E 0 : U. (Struct Zero Repl) Then P = !0 and Q = 0. This must have been derived from (Proc Repl) with E 0 : U. (Struct ε ε) Then P = ε.P' and Q = P'. Assume E P : U. This must have been derived from (Proc Action) with E P' : U. (Struct .) Then P = (M.M').P' and Q = M.M'.P'. Assume E P : U. This must have been derived from (Proc Action) with E M.M' : Cap[U] and E P' : U. The former must come from (Exp .) with E M ) Then Q R, R P for some R. By induction hypothesis (2), Symmetrical to case (1). (Struct Par) Symmetrical to case (1). (Struct Repl) Symmetrical to case (1).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>(</head><label></label><figDesc>Struct Amb) Symmetrical to case<ref type="bibr" target="#b0">(1)</ref>.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>(</head><label></label><figDesc>Struct Action) Symmetrical to case<ref type="bibr" target="#b0">(1)</ref>.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>( 0 :::Proof::U(</head><label>0</label><figDesc>Struct Input) Symmetrical to case (1). (Struct Par Comm) Then Q = P' | P" and P = P" | P'. Assume E P" | P' : U. This must have been derived from (Proc Par), with E Assoc) Symmetrical to case (1). (Struct Repl Par) Then Q = !P' and P = P' | !P'. Assume E P' | !P' : U. This must have been derived from (Proc Par), with E !P' : U. (Struct Res Res) Then Q = (νn:W)(νm:V)P' and P = (νm:V)(νn:W)P' with n ≠ m. Assume E (νm:V)(νn:W)P' : U. This must have been derived from (Proc Res) twice, with E, m:Amb[S], n:Amb[T] P' : U, where W=Amb[T] and V=Amb[S]. By Lemma 7-4 we have E, n:Amb[T], m:Amb[S] P' : U. By (Proc Res) twice we have E (νn:Amb[T])(νm:Amb[S])P' : U. (Struct Res Par) Then Q = (νn:W)(P' | P") and P = P' | (νn:W)P", with n Ñ fn(P'). This must have been derived from (Proc Par), with E P' : U and E (νn:W)P" : U, and the latter from (Proc Res), with E, n:Amb[T] P" : U where W=Amb[T]. By Lemma 7-5, since n Ñ dom(E'), we have E, n:Amb[T] P' : U. By (Proc Par) we have E, n:Amb[T] P' | P" : U. By (Proc Res) we have E (νn:Amb[T])(P' | P") : U. (Struct Res Amb) Then Q = (νn:W)m[P'] and P = m[(νn:W)P'], with n ≠ m. Assume E P : U. This must have been derived from (Proc Amb) with E m : Amb[S] and E (νn:W)P' : S for some S. The latter must have been derived from (Proc Res) with E, n:Amb[T] P' : S with W = Amb[T]. By Lemma 7-5, since n Ñ dom(E), we have E, n:Amb[T] m : Amb[S]. By (Proc Amb) we can derive E, n:Amb[T] m[P'] : U. By (Proc Res) we have E (νn:Amb[T])m[P'] : U. (Struct Zero Par) Then Q = P' | 0 and P = P'. By Lemma 7-3, E /. By (Proc Zero) E Res) Then Q = (νn:Amb[T])0 and P = 0. Repl) Then Q = !0 and P = 0. Assume E P : U. By (Proc Repl) with E !0 : U. (Struct ε ε) Then Q = ε.P' and P = P'. By Lemma 7-3, E /. By (Exp ε), E ε Then Q = (M.M').P' and P = M.M'.P'. This must have been derived from (Proc Action) twice, with E M By induction on the derivation of P x xy yyz yz Q. (Red In) Then P = n[in m. P' | P"] | m[P'"] and Q = m[n[P' | P"] | P'"]. This must have been derived from (Proc Par), with E n[in m. P' | P"] Those two judgments must have been derived from (Proc Amb), with E n : Amb[T], E in m. P' | P" : T for some T, and E m : Amb[S], E P'" : S for some S. Moreover, E in m. P' | P" : T must come from (Proc Par) with E in m. P' : T and E P" : T, and E in m. P' : T must come from (Proc Action) with E in m : Cap[T] and E P' : T. Note that E m : Amb[S] is consistent with E in m : Cap[T], by (Exp In). By (Proc Par) we have E P' | P" : T, and by (Proc Amb) we can derive E n[P' | P"] : S. Then, by (Proc Par) we have E n[P' | P"] | P'" : S, and by (Proc Amb) we can derive E m[n[P' | P"] | P'"] : U. (Red Out) Then P = m[n[out m. P' | P"] | P'"] and Q = n[P' | P"] | m[P'"]. Assume E P : U. This must have been derived from (Proc Amb), with E m : Amb[T] and E n[out m. P' | P"] | P'" : T for some T. The latter must come from (Proc Par) with E P'" : T and E n[out m. P' | P"] : T. The latter must come from (Proc Amb) with E n Amb[S] and E out m. P' | P" : S for some S. The latter must come from (Proc Par) with E P" : S and E out m. P' : S. The latter must come from (Proc Action) with E out m : Cap[S] and E P' : S. Note that E m : Amb[T] is consistent with E out m : Cap[S], by (Exp Out). By (Proc Par) we have E P' | P" : S, and by (Proc Amb) we can derive E n[P' | P"] : U. Then, by (Proc Amb) we can derive E m[P'"] : U, and by (Proc Par) we have E n[P' | P"] | m[P'"] : U. (Red Open) Then P = open n. P' | n[P"] and Q = P' | P". This must have been derived from (Proc Par), with E must have been derived from (Proc Action), with E open n : Cap[U] and E P' : U, and from (Exp Open) with E n : Amb[U]. The judgment E n[P"] : U must have then been derived from (Proc Amb) with E n : Amb[U'], and E P" : U'. By Lemma 7-2, U'=U. By (Proc Par) we have E P' | P" : U. (Red Comm) Then P = (n 1 :W 1 , ..., n k :W k ).P' | jM 1 , ..., M k k and Q = P'{n 1 ←M 1 , ..., n k ←M k }. Assume E P : U. This must have been derived from (Proc Par) with E (n 1 :W 1 , ..., n k :W k ).P' : U and E jM 1 , ..., M k k : U. The former must have been derived from (Proc Input) with E, n 1 :W 1 , ..., n k :W k P' : W 1 ×...×W k , and U = W 1 ×...×W k . The latter must have been derived from (Proc Output) with E M 1 : W1 '...E M k : W k ', and U = W 1 '×...×W k '. Hence, W 1 = W 1 ' ... W k = W k '.By k applications of Lemma 7-7, we have that E P'{n 1 ←M 1 , ..., n k ←M k } : U.(Red Res) Then P = (νn:W)P', Q = (νn:W)Q', and P' This must have been derived from (Proc Res) with E, n:Amb[T] P' : U, where W = Amb[T]. By induction hypothesis E, n:Amb[T] ) Then P = n[P'], Q = n[Q'], and P' This must have been derived from (Proc Amb) with E n : Amb[T] and E P' :T for some T. By induction hypothesis, ) Then P = P' | R, Q = Q' | R, and P' This must have been derived from (Proc Par) with E P' Red ) Then P P', Q Q', and P'</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>$ n up [out n ch . in n box . jMk] b n(x:W).P $ (νp:Amb[W]) (open p. p[] | n box [open n up . (x:W). p[out n box . open p. P] | !open n box |in n box ])</figDesc><table /><note><p>Typed Call-by-Value λ λ-calculus in the Ambient Calculus c njMk.P</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>r. jMk] nget r c (x:W). P S o $</figDesc><table><row><cell></cell><cell cols="2">Telestrip'd Syntax</cell></row><row><cell>Net ::=</cell><cell cols="2">the network</cell></row><row><cell cols="2">noplace</cell><cell>no place</cell></row><row><cell cols="2">place p[Arena]</cell><cell>a place called p</cell></row><row><cell cols="2">Net | Net</cell><cell>more places</cell></row><row><cell>Arena ::=</cell><cell cols="2">inside a place</cell></row><row><cell>empty</cell><cell></cell><cell>nobody there</cell></row><row><cell cols="2">agent a[Code]</cell><cell>an agent with fresh name a</cell></row><row><cell cols="2">Arena | Arena</cell><cell>more agents</cell></row><row><cell>Code ::=</cell><cell cols="2">agent code</cell></row><row><cell>stop</cell><cell></cell><cell>stop</cell></row><row><cell cols="2">go p. Code</cell><cell>go to place p and continue</cell></row><row><cell cols="2">spawn a'[Code']. Code</cell><cell>spawn a fresh agent a' in the current place</cell></row><row><cell cols="2">welcome (x 1 , ..., x m ). Code</cell><cell>accept input from any local agent</cell></row><row><cell cols="2">meet njn 1 , ..., n m k. Code</cell><cell>meet local agent n and output to it</cell></row><row><cell cols="2">folder n m. Code</cell><cell>add new folder n with contents m to the suitcase</cell></row><row><cell cols="2">get n(x). Code</cell><cell>get contents of folder n from the suitcase</cell></row><row><cell cols="2">set njmk. Code</cell><cell>set contents of folder n to m in the suitcase</cell></row><row><cell>...</cell><cell></cell><cell>iteration and data handling (omitted)</cell></row><row><cell></cell><cell cols="2">Typed Telestrip'd Semantics</cell></row><row><cell>?noplaceA</cell><cell>$ 0</cell></row><row><cell cols="3">?place p[Arena]A $ p[?ArenaA p ](for a global p:Amb[Shh])</cell></row><row><cell cols="2">?Net | NetA $ ?NetA | ?NetA</cell></row><row><cell cols="2">?emptyA p $ 0</cell></row><row><cell cols="2">?agent (a:Agent[W 1 , ..., W k ])[Code]A p</cell></row></table><note><p>(νop:Amb[S]) (open op. op[] | c ip [in r. in c buf . (x:W). (jxk | op[out c buf . out r. open op. nPo])) nset r c jM W k. P S o $ (νop:Amb[S]) (open op. op[] | c ip [in r. in c buf . (x:W). (jMk | op[out c buf . out r. open op. nPo])) ?Agent[W 1 , ..., W k ]A $ Amb[?W 1 A×...×?W k A] ?NetA : Shh ?ArenaA p : Shhif p : Amb[Shh] ?CodeA a : ?W 1 A×...×?W k A if a : ?Agent[W 1 , ..., W k ]A $ (νa:?Agent[W 1 , ..., W k ]A) a[record sut | add sut at p | ?CodeA a ] ?Arena | ArenaA p $ ?ArenaA p | ?ArenaA p ?stopA a $ 0 ?go p. CodeA a $ get sut at(q:Amb[Shh]). set sut atjpk. out q. in p. ?CodeA a ?spawn (a':Agent[W 1 , ..., W k ])[Code']. CodeA a $ (for a' ≠ a) get sut at(p:Amb[Shh]). (νa',u:?Agent[W 1 , ..., W k ]A) (a'[record sut | add sut at p | out a. open u. ?Code'A a' ]] | open u. ?CodeA a | (νt:Amb) t[out a. in a'. out a'. (u[out t. in a'] | u[out t. in a])])</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>meet njn 1W 1 , ..., n kW k k. CodeA a $ (νk:?Agent[W 1 , ..., W k ]A) k[out a. in n. n[out k. open k. jn 1 , ..., n m k]] | ?CodeA ?welcome (n 1 :W 1 , ..., n k :W k ). CodeA a $ open a | (n 1 :?W 1 A, ..., n k :?W k A). ?CodeA a ?folder n m W . CodeA a $ (νn:Cell[?WA]Shh) (add sut n m | ?CodeA a ) ?get n(x:W). CodeA a $ get sut n(x:?WA). ?CodeA a ?set njmk. CodeA a $ set sut njmk. ?CodeA a ...</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>print[out n. jxk]] toks[in alice. in toks | jopen apik | jopen apik] | principal alice ((x 1 :Cap 1 [Msg]). (x 2 :Cap 1 [Msg]). alice[out toks | x 1 . jMk | toks[out alice. in bob. in toks. jx 2 k]]) principal bob ((y:Cap 1 [Msg]). bob[out toks. y. jNk]))</figDesc><table><row><cell>sys $</cell></row><row><cell>(ν alice:Amb[Msg], bob:Amb[Msg])</cell></row><row><cell>(ν api:Amb[Msg], print:Amb[Msg], toks:Amb[Cap 1 [Msg]])</cell></row><row><cell>(!open print |</cell></row><row><cell>x xy yyz yz</cell></row><row><cell>sys</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Microsoft Research</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>Monday,August 31, 1998, 3:30 pm   </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>Monday, August 31, 1998, 3:30 pm Draft</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_3"><p>Monday, August 31, 1998, 3:31 pm Draft</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_4"><p>Monday, August 31, 1998, 3:32 pm Draft</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>Georges Gonthier made useful remarks on an early draft, and discovered new π-calculus encodings that illustrate interesting techniques.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Appendix: Subject Reduction 7-1 Lemma</head><p>If E', n:W, E" J then n Ñ dom(E', E").   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7-4 Lemma (Exchange)</head><p>If E', n:W', m:W", E" J then E', m:W", n:W', E" J. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7-5 Lemma (Weakening)</head><p>If E', E" J and n Ñ dom(E', E") then E', n:W, E" J. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7-6 Lemma (Strengthening)</head><p>If E', n:W, E" J and n Ñ fn(J) then E', E" J. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7-7 Lemma (Substitution)</head><p>If E', n:W, E" J and E' M : W then E', E" J{n←M}. (Struct Symm) Then Q P. By induction hypothesis, we have n occurs Q = n occurs P.</p><p>(Struct Trans) Then P R, R Q for some R. By induction hypothesis, n occurs P = n occurs R. Again by induction hypothesis, n occurs R = n occurs Q. Hence, n occurs P = n occurs Q.</p><p>(Struct Res) Then P = (νm:W)P' and Q = (νm:W)Q', with P' Q'. Since m is bound, we may assume that m ≠ n. By induction hypothesis, n occurs P' = n occurs Q'. Therefore, n occurs P = n occurs P' = n occurs Q' = n occurs Q.</p><p>(Struct Par) Then P = P' | R, Q = Q' | R, and P' Q'. By induction hypothesis, n occurs P' = n occurs Q'. Therefore, n occurs P = (n occurs P')</p><p>(Struct Repl) Then P = !P', Q = !Q', and P' Q'. By induction hypothesis, n occurs P' = n occurs Q'. Therefore, n occurs P = !(n occurs P') = !(n occurs Q') = n occurs Q.</p><p>(Struct Amb) Then P = M[P'], Q = M[Q'], and P' Q'. By induction hypothesis, n oc- curs P' = n occurs Q'. Therefore, n occurs P = (n occurs M) + (n occurs P') = (n occurs M) + (n occurs Q') = n occurs Q.</p><p>(Struct Action) Then P = M.P', Q = M.Q', and P' Q'. By induction hypothesis, n oc- curs P' = n occurs Q'. Therefore, n occurs P = (n occurs M) + (n occurs P') = (n occurs M) + (n occurs Q') = n occurs Q.</p><p>(Struct Input) Then P=(n 1 :W 1 , ..., n k :W k ).P', Q=(n 1 :W 1 , ..., n k :W k ).Q', and P' Q'. Since the names n 1 , ..., n k are bound, we may assume that n Ñ{n 1 , ..., n k }. By induction hypothesis, n occurs P' = n occurs Q'. Therefore, n occurs P = n occurs P' = n occurs Q' = n occurs Q.</p><p>(Struct Par Comm) Then P = P' | P" and Q = P" | P'. By Lemma 8-1, we have: n occurs P = (n occurs P') + (n occurs P") = (n occurs P")+(n occurs P') = n occurs Q. Draft Monday, August 31, 1998, 3:32 pm 27 (Struct Par Assoc) Then P = (P' | P") | P'" and Q = P' | (P" | P'"). By Lemma 8-2, we have: n occurs P = ((n occurs P') + (n occurs P")) + (n occurs P'") = (n occurs P')+((n occurs P")+(n occurs P'")) = n occurs Q.</p><p>(Struct Repl Par) Then P = !P' and Q = P' | !P'. By Lemma 8-3, we have: n occurs P = !(n occurs P') = (n occurs P') + !(n occurs P') = n occurs Q.</p><p>(Struct Res Res) Then P = (νm:W)(νm':V)P' and Q=(νm':V)(νm:W)P' with m ≠ m'. Since the names m and m' are bound, we may assume that n ≠ m and n ≠ m. Therefore, n occurs P = n occurs P' = n occurs Q.</p><p>(Struct Res Par) Then P = (νm:W)(P' | P") and Q = P' | (νm:W)P", with m Ñ fn(P').</p><p>Since the name m is bound, we may assume that n ≠ m. Therefore, n occurs P = (n occurs P') + (n occurs P") = n occurs Q.</p><p>(Struct Res Amb) Then P = (νm:W)m'[P'] and Q = m'[(νm:W)P'], with m ≠ m'. Since the name m is bound, we may assume that n ≠ m. Therefore, n occurs P = (n occurs m')+(n occurs P') = n occurs Q.</p><p>(Struct Zero Par) Then P = P' | 0 and Q = P'. We have: n occurs P = (n occurs P') + 0 = n occurs P' = n occurs Q.</p><p>(Struct Zero Res) Then P = (νm:W)0 and Q = 0. Since the name m is bound, we may assume that n ≠ m. Therefore, n occurs P = n occurs 0 = n occurs Q.</p><p>(Struct Zero Repl) Then P = !0 and Q = 0. We have n occurs P = 0 = n occurs Q.</p><p>(Struct ε ε) Then P = ε.P' and Q = P'. We have n occurs P = n occurs P' = n occurs Q. (Struct .) Then P = (M.M').P' and Q = M.M'.P'. By Lemma 8-2, we have n occurs P = ((n occurs M) + (n occurs M')) + n occurs P' = n occurs M + (n occurs M' + n occurs P') = n occurs Q.   The extended type system is as follows: the judgments are as in Section 3.3, and the rules are as in Section 3.3, except for the modifications described in Section 5. We now prove subject reduction for the extended system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>8-7 Lemma</head><p>If E M : T then fn(M) ⊆ dom(E). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>8-8 Lemma</head><p>If E', n:W, E" J then n Ñ dom(E',E").  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>8-11 Lemma (Exchange)</head><p>If E', n:W', m:W", E" I then E', m:W", n:W', E" J. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>8-12 Lemma (Weakening)</head><p>If E', E" J and n Ñ dom(E',E") then E', n:W, E" J. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>8-13 Lemma (Strengthening)</head><p>If E', n:W, E" J and n Ñ fn(J) then E', E" J. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>8-14 Lemma (Substitution)</head><p>If E', n:W, E" J and E' M : W then E', E" J{n←M}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>By induction on the derivation of E', n:W, E" J.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(Proc Input)</head><p>We have E', n:W, E" (n 1 :W 1 , ..., n k :W k ).P : T derived from E', n:W, E", <ref type="figure">E',</ref><ref type="figure">E",</ref><ref type="figure">n</ref>  By Lemma 8-6, n i occurs P{n←M}) = n i occurs P, for all i Ð 1..k. By (Proc Input), E', E" (n 1 :W 1 , ..., n k :W k ).(P{n←M}) : T. Since ({n} ∪ fn(M)) ∩ {n 1 , ..., n k } = Ô, this is to say that E', E" ((n 1 :W 1 , ..., n k :W k ).P){n←M}) : T.</p><p>Other cases. The other cases are almost exactly as before. (Struct Input) Then P = (n 1 :W 1 , ..., n k :W k ).P', P' Q', and Q = (n 1 :W 1 , ..., n k :W k ).Q'.</p><p>For part <ref type="bibr" target="#b0">(1)</ref>, assume E P : U. This must have been derived from (Proc Input), with E, n 1 :W 1 , ..., n k :W k P': U, where U = W 1 ×...×W k . Moreover, for all i Ð 1..k, if W i = Cap 1 [T i ] then n i occurs P' ≤ 1. By induction hypothesis, E, n 1 :W 1 , ..., n k :W k Q': U. By Lemma 8-4, P' Q' implies that n i occurs P'</p><p>Part (2) follows by symmetric considerations.</p><p>Other cases. The other cases are almost exactly as before.  </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">An asynchronous model of locality, failure, and process mobility</title>
		<author>
			<persName><forename type="first">R</forename><surname>Amadio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CO-ORDINATION&apos;97</title>
		<title level="s">LNCS</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1282</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Abstractions for Mobile Computation</title>
		<author>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
	<note>To appear. (See www.luca.demon.co.uk.</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mobile</forename><surname>Ambients</surname></persName>
		</author>
		<title level="m">Foundations of Software Science and Computational Structures</title>
		<editor>
			<persName><forename type="first">Maurice</forename><surname>Nivat</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="140" to="155" />
		</imprint>
	</monogr>
	<note>LNCS 1378</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Linearity and the Pi-Calculus</title>
		<author>
			<persName><forename type="first">N</forename><surname>Kobayashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">N</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc ACM POPL&apos;96</title>
		<meeting>ACM POPL&apos;96</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="358" to="371" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">A calculus of mobile processes, Parts 1-2. Information and Computation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Parrow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">100</biblScope>
			<biblScope unit="page" from="1" to="77" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Polarized Name Passing</title>
		<author>
			<persName><forename type="first">M</forename><surname>Odersky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc FST&amp;TCS</title>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A typed language for distributed mobile processes</title>
		<author>
			<persName><forename type="first">J</forename><surname>Riely</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hennessy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc ACM POPL&apos;98</title>
		<meeting>ACM POPL&apos;98</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="378" to="390" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Global/Local Subtyping and Capability Inference for a Distributed π π-calculus</title>
		<author>
			<persName><forename type="first">P</forename><surname>Sewell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc ICALP&apos;98</title>
		<meeting>ICALP&apos;98</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Mobile agents</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>White</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Software Agents</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Bradshaw</surname></persName>
		</editor>
		<imprint>
			<publisher>AAAI Press / The MIT Press</publisher>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
