<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Fairness in an Unfair World: Fair Multiparty Computation from Public Bulletin Boards</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Arka</forename><forename type="middle">Rai</forename><surname>Choudhuri</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Abhishek</forename><surname>Jain</surname></persName>
							<email>abhishek@cs.jhu.edu</email>
						</author>
						<author>
							<persName><forename type="first">Gabriel</forename><surname>Kaptchuk</surname></persName>
							<email>gkaptchuk@cs.jhu.edu</email>
						</author>
						<author>
							<persName><forename type="first">Ian</forename><surname>Miers</surname></persName>
							<email>imiers@cs.jhu.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Johns Hopkins University Matthew Green</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Johns Hopkins University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Johns Hopkins University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">Johns Hopkins University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution">Johns Hopkins University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Fairness in an Unfair World: Fair Multiparty Computation from Public Bulletin Boards</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">3F815DB4F759AD1EB60251EC448EDFF4</idno>
					<idno type="DOI">10.1145/3133956.3134092</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T03:31+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Secure Multiparty Computation, Fairness</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Secure multiparty computation allows mutually distrusting parties to compute a function on their private inputs such that nothing but the function output is revealed. Achieving fairness -that all parties learn the output or no one does -is a long studied problem with known impossibility results in the standard model if a majority of parties are dishonest.</p><p>We present a new model for achieving fairness in MPC against dishonest majority by using public bulletin boards implemented via existing infrastructure such as blockchains or Google's certificate transparency logs. We present both theoretical and practical constructions using either witness encryption or trusted hardware (such as Intel SGX).</p><p>Unlike previous works that either penalize an aborting party or achieve weaker notions such as ∆-fairness, we achieve complete fairness using existing infrastructure.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Secure multiparty computation (MPC) allows a collection of mutually distrusting parties to jointly compute a function on their private inputs while revealing nothing beyond the function output. Since its conception three decades ago <ref type="bibr" target="#b38">[41,</ref><ref type="bibr" target="#b59">62]</ref>, MPC has found wide applicability to important tasks such as electronic auctions, voting, valuation of assets, and privacy-preserving data mining.</p><p>Fairness. Over the years, several security definitions for MPC have been studied. One natural and desirable definition for MPC stipulates that either all parties receive the protocol output or no party does. This is referred to as fair MPC.</p><p>The notion of fairness is very important (and necessary) in applications such as auctions and contract signing. For example, if Alice is the first to learn she did not win an auction, she may abort, claim a network failure, and try again with a new bid that just exceeds the previous winning bid. More generally when the "value" of the function output may be enhanced by an information asymmetry, e.g., if Alice is better off exclusively knowing the true value of a financial asset than all parties knowing it, fairness is an issue.</p><p>In a seminal work, Cleve <ref type="bibr" target="#b22">[25]</ref> proved that fair MPC is impossible to realize for general functions when a majority of the parties are dishonest. This result even holds when the parties have access to a trusted setup such as a common reference string.</p><p>The pursuit of fairness. In light of Cleve's impossibility result, a vast amount of research effort has been dedicated towards the study of mitigations to the fairness problem. In particular, two prominent lines of research have emerged over the years. The first research direction considers the problem of achieving fairness in the standard model for a restricted classes of functions <ref type="bibr">[7-9, 45, 47]</ref>.</p><p>The second research direction studies fairness for general functions by augmenting the computation model and/or by relaxing the definition of fairness. The prominent examples in this direction range from using a trusted party to restore fairness <ref type="bibr" target="#b17">[20]</ref>, to weaker models where the honest parties can recover the output at computational cost or time at most ∆-times that of the adversary <ref type="bibr" target="#b10">[13,</ref><ref type="bibr" target="#b28">31,</ref><ref type="bibr" target="#b31">34,</ref><ref type="bibr" target="#b39">42,</ref><ref type="bibr" target="#b56">59,</ref><ref type="bibr" target="#b57">60]</ref> (where ∆ is a constant), to penalizing aborting parties monetarily <ref type="bibr" target="#b3">[6,</ref><ref type="bibr" target="#b14">17,</ref><ref type="bibr" target="#b49">52,</ref><ref type="bibr" target="#b50">53]</ref>. (See Section 2 for a more elaborate discussion.) While these mitigations are helpful, they fall short of solving the problem in many circumstances. In particular, they either require appointing trusted parties for very specific tasks (related to the protocol) that can be hard to find, or require that the parties' possess precise estimates of the adversary's resources and incentives. If the adversary values exclusive knowledge of the output very highly, it may not be practical to have a large enough computational differential or penalty to deter aborts. Indeed, in many cases it may be impossible value the MPC output at all.</p><p>Our Model: Public Bulletin Boards. In this work, we take a new approach to achieving complete fairness in MPC for general functions. We consider a setting where the parties have access to a public ledger, or a bulletin board that allows anyone to publish arbitrary strings. Upon publishing its data D on the bulletin board, a party receives a proof (or a signature) to establish that D was published. The bulletin board is public, in that anyone can see all of its contents. The main security requirements from the bulletin board are that its contents cannot be erased, nor can a proof of publish be forged.</p><p>Our choice of the bulletin board model as a viable model for fair MPC is motivated by the fact that implementations of public bulletin boards already exist in practice. We can realize a bulletin board from an existing centralized system: Google's certificate transparency project which logs issued certificates. <ref type="foot" target="#foot_0">1</ref>A decentralized implementation of a bulletin board can be realized from blockchain-based ledgers such as Etherium and Bitcoin implemented with proofs of stake or proofs of work <ref type="bibr" target="#b13">[16]</ref>. Proof of work based blockchains rely on the assumption that the majority of the network's computational power is honest. In contrast, proof of stake systems assume that some quorum of users are honest. For each block, proof of stake systems select the quorum users, typically at random but proportional to the amount of currency or stake they have in the system, and that quorum must sign the next block and (randomly) select the next quorum. The signature on a block by the quorum constitutes an unforgeable proof that data is on the bulletin board. In contrast to e.g. byzantine agreement protocols, however, the user group is ad-hoc and tolerant to churn. Proof of Stake and hybrid Proof of Stake/Proof of Work systems are an area of active research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Our Results</head><p>In this work, we construct theoretical and practical fair MPC protocols for general functions in the bulletin board model. We, in fact, provide general transformations from any (possibly unfair) n-party MPC protocol that supports t &lt; n corruptions to a fair MPC protocol secure against the same number of corruptions. Crucially, the assumptions used in our transformations affect fairness only: the correctness and privacy properties of the underlying MPC scheme are completely preserved even if the assumptions were not to hold. I. Fair MPC from Witness Encryption. Our first contribution is a fair MPC protocol in the bulletin board model assuming the existence of witness encryption (WE) <ref type="bibr" target="#b34">[37]</ref> and injective one-way functions. In order to rely on the standard security of WE, we require the bulletin board's proof of publish to be implemented via unique signatures <ref type="bibr" target="#b40">[43,</ref><ref type="bibr" target="#b53">56]</ref>. If the bulletin board is implemented via standard signatures (e.g., in Google Transparency Certificates) or proofs of stake (e.g., in Etherium), then we require the stronger assumption of extractable witness encryption <ref type="bibr" target="#b16">[19]</ref>.</p><p>Candidate constructions of WE for NP <ref type="bibr" target="#b34">[37,</ref><ref type="bibr" target="#b36">39]</ref> are known from multilinear maps <ref type="bibr" target="#b33">[36]</ref>. Since present constructions <ref type="bibr" target="#b23">[26,</ref><ref type="bibr" target="#b24">27,</ref><ref type="bibr" target="#b33">36,</ref><ref type="bibr" target="#b35">38]</ref> of multilinear maps are quite inefficient, we view our first construction as a feasibility result. We note, however, that our construction requires WE for a specific NP language for which constructing efficient schemes from simpler assumptions might be easier. Indeed, a fascinating open question for future work is whether WE for the specific language used in our constructions can be implemented from existing constructions for the related notion of hash proof systems <ref type="bibr" target="#b25">[28]</ref>.</p><p>II. Fair MPC from Secure Processors. Our second contribution is a fair MPC protocol in the bulletin board where all the parties have access to secure processors. In fact, Cleve's impossibility result holds even in the presence of secure processors, and was proved recently in <ref type="bibr" target="#b55">[58]</ref>. For concreteness, we work with Intel SGX as a secure processor, following the formalization of <ref type="bibr" target="#b56">[59]</ref>. For this result, we only need standard cryptographic assumptions such as secret-key authenticated encryption and signatures. We provide an implementation of this protocol in Section 8.</p><p>Comparison with recent works. Recently, <ref type="bibr" target="#b3">[6,</ref><ref type="bibr" target="#b14">17]</ref> showed how block-chain based decentralized cryptocurrencies such as Bitcoin can be used to achieve a notion of fairness with penalties where aborting parties are forced to pay a pre-agreed financial penalty. We note that while we also use blockchain based bulletin boards in our work, our end result is quite different in that we achieve the standard notion of fairness -either all parties get the output or none do.</p><p>Very recently, <ref type="bibr" target="#b56">[59]</ref> studied fairness in the model where each party has access to a secure hardware equipped with secure clock. They achieve a notion of ∆-fairness which guarantees that if an aborting adversary can learn the output in time T , then the honest party can also learn the output in time ∆ • T for ∆ = 2. A disadvantage of this model is that T is controlled by the adversary, who can set it arbitrarily to create large delay (e.g., in the order of several minutes or hours) between the times when it gets the output and when the honest party does.</p><p>We note that while we also use secure hardware for our second result, we do not require them to implement secure clocks. <ref type="foot" target="#foot_1">2</ref> More importantly, we achieve the standard notion of fairness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Technical Overview</head><p>We now describe the main ideas used in our constructions. For simplicity of exposition, we restrict this discussion to the twoparty case. It is easy to generalize the ideas presented below to the multiparty case.</p><p>Starting Ideas. Our starting idea is to run an unfair MPC protocol to compute an encryption of the function output as opposed to computing it in the clear. We then design a special decryption procedure such that either no party is able to perform the decryption or both parties can. In other words, we reduce the fairness problem in MPC to the problem of fair decryption.</p><p>At first, it may seem that we haven't made any progress because it is unclear why fair decryption would be any easier than achieving fairness for general functions. Indeed, fair decryption was shown to be a complete functionality for fair MPC in <ref type="bibr" target="#b43">[46]</ref>.</p><p>Our key insight is that a public bulletin board can be used to implement a fair decryption protocol for a witness encryption scheme. We elaborate on this idea below.</p><p>Fairness from Witness Encryption. A witness encryption scheme for a language L can be used to encrypt a message m with a statement x in such a manner that the resulting ciphertext can only be decrypted using a witness w for x. We now explain how we use witness encryption to implement our fair MPC protocol.</p><p>In order to securely compute a function f with complete fairness, the parties first run a standard (possibly unfair) MPC protocol to compute a randomized function that takes the private inputs say (y 1 , y 2 ) of the parties and returns a witness encryption ciphertext CT of the desired output F (y 1 , y 2 ). The statement x associated with CT is set to be such that a valid witness for x corresponds to the proof of posting a "release token" α (to be determined later) on the bulletin board.</p><p>The only way for any party to obtain such a witness is to post α on the bulletin board and obtain the corresponding proof of posting σ . However, in doing so, the pair (α, σ ) is made public, and therefore, anyone can obtain it. Thus, if a malicious adversary learns the witness for decrypting CT, then so can the honest party since it can simply read the public bulletin board. This mechanism puts the honest party and the adversary on equal footing and resolves the fairness problem.</p><p>While the above constitutes the core idea behind our work, we run into several technical issues in implementing this idea. We discuss these next, together with the solutions.</p><p>Issue #1: Setting the release token. An immediate issue with implementing the above idea is that we cannot set the release token α to be an a priori fixed value that is known to the adversary. Indeed, if this is the case, then the adversary can simply abort during the execution of the unfair MPC protocol so that it learns the ciphertext CT, but the honest party does not. Now, even if the honest party can obtain (α, σ ) once the adversary has posted it on the bulletin board, it cannot learn the output F (y 1 , y 2 ) since it does not have CT to decrypt.</p><p>To address this issue, we set α to be a pair of random values (α 1 , α 2 ) where α i is chosen by the i-th party. During the initial MPC phase, each party uses α i as an additional input such that the output of the MPC is (β, CT) where β i = f (α i ) for some one-way function f and β = (β 1 , β 2 ). Now, even given (β, CT), the value α is not completely known to the adversary. Therefore, if it aborts prematurely, then the honest party aborts as well, knowing that the adversary would not be able to recover the output.</p><p>On the other hand, if the first phase is successfully completed, then the parties execute a second phase where each party i simply sends over α i to the other party. Of course, the adversary may abort in this phase after learning α. However, in order to decrypt CT, it will have to post α on the bulletin board which means the honest party would learn it as well. This restores the balance between the honest party and the adversary.</p><p>Issue #2: Security of WE. The standard definition of witness encryption only guarantees semantic security for a ciphertext CT if the statement x associated with it is false. In our case, the statement is always true. The only way to argue security in this case is to use a stronger notion of extractable witness encryption <ref type="bibr" target="#b16">[19]</ref> which guarantees that for any statement x, if an adversary can distinguish between witness encryption of m from an encryption of m ′ m, then one can efficiently recover from that adversary a witness w for x. Now, if the witness w is computationally hard to find, then we can get a contradiction.</p><p>It was shown in <ref type="bibr" target="#b16">[19]</ref> that for languages with statements that have only polynomially many witnesses, the standard definition of WE implies the stronger definition of extractable WE. We note that if we set f to be an injective one-way function and implement the proof of posting on the bulletin board via unique signatures <ref type="bibr" target="#b40">[43,</ref><ref type="bibr" target="#b53">56]</ref>, then we can bound the number of valid witnesses. In this case, we can rely on the standard definition of WE.</p><p>Issue #3: Rewinding. We run into yet another issue while arguing security of the above construction. Recall that in order to prove security of a fair MPC protocol, we must construct a simulator who can "force" the correct output on the real adversary, provided that the adversary did not abort prematurely. In our protocol, the only opportunity for the simulator to "program" the output is inside the ciphertext CT computed during the initial MPC phase. However, this point in our overall protocol is "too early" for the simulator to determine with enough confidence whether the real adversary is going to later abort or not. If the simulator's decision to program the output turns out to be wrong, then it would immediately lead to a distinguisher between the outputs of the real and ideal experiments.</p><p>To deal with this issue, we use a rewinding strategy previously used in <ref type="bibr" target="#b37">[40,</ref><ref type="bibr" target="#b41">44,</ref><ref type="bibr" target="#b43">46]</ref> to determine the aborting probability of the adversary with enough accuracy, while still ensuring (expected) polynomial running time for the simulator. In order to ensure indistinguishability of the adversary's view in the real and ideal experiments, we allow the simulator to also rewind the bulletin board to a previous state, as and when necessary. Indeed, without this capability, the simulator cannot prevent an adversary from "detecting rewinding" by continuously posting on the bulletin board. A consequence of this is that we must model the bulletin board as a "local" functionality as opposed to a "global" functionality <ref type="bibr" target="#b18">[21,</ref><ref type="bibr" target="#b19">22]</ref>. Furthermore, since our simulator performs rewinding, we only achieve stand-alone security.</p><p>Fairness from Secure Hardware. Roughly, the main idea in our second protocol is to replace the witness encryption in the plain model with a secure hardware that implements (essentially) the same functionality as witness encryption. We require that each party is equipped with such a secure hardware (e.g., Intel SGX). While much of the details in this protocol are similar to the previous one, there are some key differences. We explain them below.</p><p>Once the parties have "installed" an appropriate program P (discussed below) in their own local secure hardware and attestation of the same is successfully performed by everyone, they run (as in the previous protocol) an execution of a standard MPC protocol to compute an encryption CT of the desired output. Unlike the previous scheme where CT was computed using witness encryption, here we use a regular secret-key encryption scheme. The secret key K used for encryption is secret-shared amongst the parties who use their respective shares as additional inputs to the MPC. The key K is also loaded in each party's secure hardware, and is in fact computed by the secure hardware devices during an initial key-exchange phase.</p><p>As in the previous protocol, we require that the ciphertext CT can only be decrypted if the release token α has been posted on the bulletin board. The program P loaded in each party's secure hardware implements such a conditional decryption mechanism. Specifically, upon receiving a ciphertext CT, a release token α and a corresponding proof of posting σ , the program P verifies the validity of α and σ . If the verification succeeds, then it decrypts CT and returns the output; otherwise it returns ⊥.</p><p>We remark upon two security issues: first, in order to prevent malleability attacks, we require that an authenticated encryption scheme is used in order to compute CT. Further, to prevent an adversary from performing a related key attack (by changing its input key share in the MPC), we require that the secure hardware also provide commitments C i of each key share K i to all the parties upon generation of K. A party i is required to input the decommitment to C i in the MPC protocol, and the MPC functionality checks that all the input key shares are valid by verifying the decommitment information.</p><p>Second, for this protocol, we can completely dispense with rewinding and instead construct a black-box, non-rewinding simulator. This is because the use of secure hardware allows the simulator to "program" the output at the very end, when the adversary makes a decryption query to its secure hardware. <ref type="foot" target="#foot_3">3</ref> Indeed, in the secure hardware model, the simulator has the ability to observe (and modify) the queries made by the adversary to its secure hardware. This means that when the adversary makes a final decryption query, the simulator can check if it is valid. If this is the case, then it queries the trusted party to obtain the function output. At this point, the simulator sends a "fake" decryption query to the secure hardware that already contains the desired output. Upon receiving this query, the secure hardware returns the programmed output to the adversary. We note that this programming technique for secure hardware was recently used in <ref type="bibr" target="#b56">[59]</ref>.</p><p>Because of the above modifications, in this protocol, we can model the bulletin board as a global functionality. In this manuscript, however, we do not prove UC security of our protocol and leave it for future work.</p><p>Realizing the Bulletin Board. Our constructions assume a public bulletin board that is capable of producing an unforgeable proof that a string has been published to the bulletin board. Such bulletin boards can easily be constructed practice if one is willing to instantiate the board using a single trusted party. While this seems a strong assumption, the advantage of this approach is that such systems already exist and have been widely deployed in practice for applications such as Certificate Transparency [1]. Re-using them to achieve fairness in arbitrary MPC protocols requires no specific to the existing systems.</p><p>Alternatively, a bulletin board can be realized using a decentralized systems such as proof of stake blockchains (e.g., <ref type="bibr" target="#b46">[49]</ref>). These systems allow a quorum of honest users -who together possess a majority ownership "stake" in a cryptocurrency -to securely authenticate an append-only log using signatures. Finally, a weaker notion of security can be achieved using a proof of work blockchain. In the latter case, the "proof" of publication is not a cryptographically unforgeable signature, but rather the solution to a sequence of one or more computational puzzles which may be, in practice, prohibitively expensive for an attacker to forge. <ref type="foot" target="#foot_4">4</ref> We explore this approach in our experimental implementation, although we stress that this is merely an implementation detail. Our bulletin board could easily be replaced with one of the alternatives above.</p><p>Optimizations. We mention a few optimizations to the above protocols to improve efficiency. First, we can add an optimistic decryption phase in the above protocols that allows the parties to learn the output using a simple decryption process, without using the bulletin board, provided that all the parties are honest. Roughly, the MPC protocol executed in the first phase now additionally computes another encryption CT ′ of the function output, where CT ′ is implemented using a regular encryption scheme. The decryption key K ′ corresponding to CT ′ is secret-shared between the parties. Now, if the release-token exchange performed in the second phase is successful, then the parties execute a third phase (that we refer to as the optimistic decryption phase) where they exchange the key shares corresponding to K ′ . If all the parties are honest, then they all learn K ′ and use it to decrypt CT ′ , without using the bulletin board. However, if one or more parties are adversarial and abort in this phase, then the honest parties can still post the release token α (that they learned in the second phase) on the bulletin board and then use the proof of posting to decrypt CT as before.</p><p>We remark that in order to avoid related key attacks by an adversary, we would need a slight modification to the above protocol where the MPC in the first phase outputs commitments to each key share K ′ i to both the parties. During the optimistic decryption phase, each party must reveal the decommitment value together with K ′ i . A party only accepts the key share as valid if the associated decommitment information is correct.</p><p>Finally, we note that the size of the release token α = (α 1 , α 2 ) used in the above described protocols grows with the number of parties N . However, it is easy to make it independent of N by setting α = ⊕ i α i and using β = f (α) to verify the correctness of release token. An advantage of this modification is that the witness length for the witness encryption used in our construction, as well as the length of the string that is posted on the bulletin board becomes independent of the number of parties.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>A large body of research work has addressed the problem of fairness in secure protocols over the years. Below, we provide a nonexhaustive summary of prior works. A more elaborate summary can be found, e.g., in <ref type="bibr" target="#b14">[17]</ref>.</p><p>Fairness in Standard Model. Assuming an honest majority of parties, fair MPC can be achieved in both computational <ref type="bibr" target="#b38">[41]</ref> and information-theoretic setting <ref type="bibr" target="#b58">[61]</ref>. Cleve <ref type="bibr" target="#b22">[25]</ref> proved the impossibility of MPC for general functions n the dishonest majority setting. Subsequently, an exciting sequence of works <ref type="bibr">[7-9, 45, 47]</ref> have shown that complete fairness can still be achieved for a restricted class of functions. The works of <ref type="bibr" target="#b2">[5,</ref><ref type="bibr" target="#b11">14,</ref><ref type="bibr" target="#b45">48]</ref> study the problem of partial fairness.</p><p>Optimistic Models. Starting from the early work of <ref type="bibr" target="#b12">[15]</ref>, optimistic models for fair exchange have been studied in a long sequence of works <ref type="bibr" target="#b8">[11,</ref><ref type="bibr" target="#b9">12,</ref><ref type="bibr" target="#b27">30,</ref><ref type="bibr" target="#b30">33,</ref><ref type="bibr" target="#b51">54,</ref><ref type="bibr" target="#b54">57</ref>]. An optimistic model for fair two-party computation using a semi-trusted third party was studied in <ref type="bibr" target="#b17">[20,</ref><ref type="bibr" target="#b48">51]</ref>.</p><p>Session C5: Using Blockchains CCS'17, October 30-November 3, 2017, Dallas, TX, USA Gradual Release Mechanisms. A different approach to fairness that avoids trusted third parties was considered in a long sequence of works <ref type="bibr" target="#b15">[18,</ref><ref type="bibr" target="#b29">32,</ref><ref type="bibr" target="#b32">35,</ref><ref type="bibr" target="#b57">60]</ref>, following the early works of <ref type="bibr" target="#b10">[13,</ref><ref type="bibr" target="#b28">31,</ref><ref type="bibr" target="#b39">42]</ref>. The protocols in these works employ a "gradual release" mechanism where the parties take turns to release their secrets in a bit-by-bit fashion. The intuitive security guarantee (formalized in <ref type="bibr" target="#b31">[34]</ref>) is that even if an adversary aborts prematurely, the honest party can recover the output in time comparable to that of the adversary by investing equal (or more) computational effort. ∆-Fairness. Very recently, <ref type="bibr" target="#b56">[59]</ref> considered a notion of ∆-fairness with the guarantee that if an adversary aborts, then the honest party can learn the output in time ∆ • T , where T is the time in which the adversary would learn the output. They propose a fair two-party computation protocol with (∆ = 2)-fairness assuming that all the parties have secure hardware equipped with secure clocks.</p><p>Fairness with Penalties. Recently, with the popularity of decentralized cryptocurrencies such as Bitcoin, a sequence of works <ref type="bibr" target="#b3">[6,</ref><ref type="bibr" target="#b14">17,</ref><ref type="bibr" target="#b49">52,</ref><ref type="bibr" target="#b50">53]</ref> have shown how to implement a fairness-with-penalties model for MPC where adversarial parties who prematurely abort are forced to pay financial fines. Prior works in similar spirit considered fairness with reputation systems <ref type="bibr" target="#b7">[10]</ref> and legally enforced fairness <ref type="bibr" target="#b21">[24,</ref><ref type="bibr" target="#b52">55]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">DEFINITIONS 3.1 Fair Multi Party Computation</head><p>A secure fair multi-party computation protocol is a protocol executed by n number of parties P 1 , • • • , P n for a n-party functionality F . We allow for parties to exchange messages simultaneously. In every round, every party is allowed to broadcast messages to all parties. We require that at the end of the protocol, all the parties receive the output F (x 1 , . . . , x n ), where x i is the i t h party's input. <ref type="foot" target="#foot_5">5</ref>We formalize the security notion below.</p><p>Ideal World. We start by describing the ideal world experiment where n parties P 1 , • • • , P n interact with an ideal functionality for computing a function F . An adversary may corrupt any subset P A ⊂ P of the parties. We denote the honest parties by H .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Inputs: Each party P i obtains an initial input x i . The adversary</head><p>Sim is given auxiliary input z. Sim selects a subset of the parties P A ⊂ P to corrupt, and is given the inputs x k of each party P k ∈ P A . Sending inputs to trusted party: Each honest party P i sends its input x i to the trusted party. For each corrupted party P i ∈ P A , the adversary may select any value x * i and send it to the ideal functionality. Trusted party computes output: Let x * 1 , . . . , x * n be the inputs that were sent to the trusted party. If any of the received inputs were ⊥, then the trusted party sends ⊥ to all the parties. Else, the trusted party sends F (x * 1 , . . . , x * n ) to all the parties. Outputs: Honest parties output the function output they obtained from the ideal functionality. Malicious parties may output an arbitrary PPT function of the adversary's view.</p><p>The overall output of the ideal-world experiment consists of the outputs of all parties. For any ideal-world adversary Sim with auxiliary input z ∈ {0, 1} * , input vector ì</p><p>x, and security parameter λ, we denote the output of the corresponding ideal-world experiment by IDEAL Sim, F 1 λ , ì x, z .</p><p>Real World. The real world execution begins by an adversary A selecting any arbitrary subset of parties P A ⊂ P to corrupt. The parties then engage in an execution of a real n-party protocol Π.</p><p>Throughout the execution of Π, the adversary A sends all messages on behalf of the corrupted parties, and may follow an arbitrary polynomial-time strategy. In contrast, the honest parties follow the instructions of Π.</p><p>At the conclusion of all the update phases, each honest party P i outputs whatever output it received from the computation. Malicious parties may output an arbitrary PPT function of the view of A.</p><p>For any adversary A with auxiliary input z ∈ {0, 1} * , input vector ì</p><p>x, and security parameter λ, we denote the output of the</p><formula xml:id="formula_0">MPC protocol Π by REAL A, Π 1 λ , ì x, z .</formula><p>MPC with Complete Fairness. We say that a protocol Π is a secure protocol if any adversary, who corrupts a subset of parties and runs the protocol with honest parties, gains no information about the inputs of the honest parties beyond the protocol output.</p><p>Definition 3.1. A protocol Π is a secure n-party protocol computing F with complete fairness if for every PPT adversary A in the real world, there exists a PPT adversary Sim corrupting the same parties in the ideal world such that for every initial input vector ì</p><p>x, every auxiliary input z, it holds that</p><formula xml:id="formula_1">IDEAL Sim, F 1 λ , ì x, z ≈ c REAL A, Π 1 λ , ì x, z .</formula><p>Security with Abort. For our constructions, we shall require a weaker security notion of MPC referred to as security with abort. This definition differs from the above only in the ideal world, where the adversary receives the output prior to the honest parties and then decides if the trusted party should give the output to the honest parties or not.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Authentication Scheme with Public Verification</head><p>An authentication scheme with public verification consists of three polynomial algorithms (Gen, Tag, Verify).</p><p>-Gen is PPT algorithm that takes as input λ and generates a key for signing. sk ← Gen(λ). -Tag is a deterministic algorithm that computes a tag on a message x. σ = Tag sk (x). -Verify is a deterministic algorithm that allows for public verification of the tag. Verify(x, σ ) returns 1 if the tag σ verifies.</p><p>Definition 3.2. A scheme Σ = (Gen, Tag, Verify) is an authentication scheme with public verification if for any sequence of messages m 1 , . . . , m q and any PPT adversary A, the following is negligible Session C5: Using Blockchains CCS'17, October 30-November 3, 2017, Dallas, TX, USA in the security parameter:</p><formula xml:id="formula_2">Pr        sk ← Gen(λ); ∀i σ i = Tag sk (m i ); (m ′ , σ ′ ) ← A {m i , σ i } q i=1 : Verify(m ′ , σ ′ ) = 1 m ′ {m 1 , . . . , m q }       </formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Witness Encryption</head><p>In this section, we define witness encryption <ref type="bibr" target="#b36">[39]</ref> and state its relation with extractable witness encryption <ref type="bibr" target="#b16">[19]</ref> for polynomial witness languages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.3 (Extractable Witness Encryption</head><p>). An extractable witness encryption ExtWE = (Enc, Dec) for a NP language L associated with relation R consists of the following algorithms:</p><p>-Encryption, Enc(1 λ , x, m): On input instance x and message m ∈ {0, 1}, it outputs a ciphertext CT.</p><p>-Decryption, Dec(CT, w): On input ciphertext CT and witness w, it outputs m ′ . We require that the above primitive satisfies the following properties:</p><p>-Correctness: For every x ∈ L, let w be such that (x, w) ∈ R, for every m ∈ {0, 1},</p><formula xml:id="formula_3">Pr[m ← Dec(Enc(x, m), w)] = 1</formula><p>-Security: Let A be a PPT adversary such that the following holds: for every x, m 0 , m 1 , every auxiliary information z ∈ {0, 1} poly(λ) :</p><formula xml:id="formula_4">Pr[1 ← A(1 λ , Enc(x, m 0 ))] -Pr[1 ← A(1 λ , Enc(x, m 1 ))] ≤ ε</formula><p>Then there exists a PPT extractor Ext such that:</p><formula xml:id="formula_5">Pr[w ← Ext A (1 λ , x) : (x, w) ∈ R] ≥ ε -negl</formula><p>We now define the notion of polynomial witness languages.</p><p>Definition 3.4 (Witness Languages). Consider an NP language L and let R be its associated relation. We say that L is a polynomial witness language if there exists a fixed polynomial p such that for every x ∈ L it holds that there exists a size p(|x |) set of witnesses w such that w ∈ {0, 1} poly( |x |) and (x, w) ∈ R.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.5 (Witness Encryption).</head><p>A witness encryption WE = (Enc, Dec) for a NP language L consists of the following algorithms:</p><p>-Encryption, Enc(1 λ , x, m): On input instance x, message m and it outputs a ciphertext CT. -Decryption, Dec(CT, w): On input ciphertext CT and witness w, it outputs m ′ . We require that the following properties hold:</p><p>-Correctness: For every x ∈ L, let w be such that (x, w) ∈ R, for every m ∈ {0, 1},</p><formula xml:id="formula_6">Pr[m ← Dec(Enc(x, m), w)] = 1</formula><p>-Message Indistinguishability: For every PPT adversary A, there is a negligible function ε, such that for every x L the following holds:</p><formula xml:id="formula_7">Pr[1 ← A(1 λ , Enc(x, m 0 ))] -Pr[1 ← A(1 λ , Enc(x, m 1 ))] ≤ ε.</formula><p>The following theorem was shown in <ref type="bibr" target="#b16">[19]</ref>.</p><p>Theorem 3.6. Suppose L is a polynomial witness language. Then, witness encryption for L implies extractable witness encryption for L.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">MODELING THE BULLETIN BOARD</head><p>We describe briefly our modeling of the bulletin board. The bulletin board models a public ledger that lets parties publish arbitrary strings. On publishing the string on the bulletin board, the party receives a proof to establish the string was indeed published. In our setting, we model these proofs via authentication tags that can be publicly verified and the string subsequently publicly accessible. For security, we require that the authentication tags follow the standard notion of unforgeability described earlier (see definition 3.2).</p><p>In addition, the bulletin board implements a counter. Each time a string is published on the bulletin board, the counter is incremented and the authentication tag is produced on the string and counter pair. While the counter value of the bulletin board is assumed to be publicly accessible, we shall model it as an explicit query. The counter also serves as an index to the string on the bulletin board.</p><p>Hence, we model the bulletin board BB through the following queries:</p><p>-getCurrentCounter: the bulletin board returns the current value of the counter.</p><p>t ← BB(getCurrentCounter).</p><p>post: on receiving value x, the bulletin board increments the counter value by 1 to t, computes the authentication tag on (t ||x) and responds with the tag and t to the posting party.</p><p>The value and the corresponding tag can be retrieved by querying the bulletin board on t.</p><p>(σ , t) ← BB(post, x)</p><p>such that Verify BB (σ , (t ||x)) = 1. -getContent: on receiving input t, it returns the value and the corresponding tag stored at counter value t. If t is greater than the current counter value, it returns ⊥. Else,</p><formula xml:id="formula_8">(σ , x) ← BB(getContent, t)</formula><p>We note that bulletin boards have previously been considered in works such as <ref type="bibr" target="#b47">[50]</ref>, but their model differs significantly from ours.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">FAIR MPC FROM WITNESS ENCRYPTION</head><p>Overview. We start by giving an overview of our protocol. Our protocol builds on an MPC protocol that achieves the weaker notion of security with abort, where the fairness condition is not required to hold. The initial phase constitutes of the parties using this unfair MPC protocol to compute a witness encryption ciphertext of the function value they wish to compute. To decrypt, a party must post messages of a specific form (referred to as "release tokens") on to the bulletin board which the bulletin board validates with an authentication tag. The idea then is that any party can use this posted information and authentication tag to decrypt the witness encryption ciphertext. The release token must include shares of all parties that are secret prior to the completion of this initial phase. These shares must also be easily verifiable. Our construction uses injective one-way functions, where the images of these shares are sent out during the initial phase.</p><p>The next phase, on completion of the initial phase, constitutes of parties sending these secrets to every other party. Once a party releases its share, it must not abort until it is sure that the other parties cannot post to the bulletin board, and hence decrypt the message thereafter. Otherwise, the adversary on receiving the secret shares will wait for the honest parties to abort before posting to the bulletin board. This is resolved by parameterizing the protocol by a cut-off period which once elapsed, effectively ends the protocol. If there isn't a valid post to the bulletin board at this time, no party gets the output.</p><p>To argue security, we require each statement in the language corresponding to the witness encryption to have only a polynomial size witness set. To do so, we use an injective one-way function and a unique signature scheme. The witness for the statement are the pre-images of the values sent during the initial phase, and the corresponding tag from the bulletin board. This pair is unique for a given statement. But we need to incorporate the cut-off period into the witness. This is enforced by the counter in the bulletin board as described in section 4. In the protocol, this translates to a window (set) of counter values which qualify as the additional variable in the witness. To ensure that the number of witnesses are still polynomial, the window size has to be polynomial. We parameterize the protocol with the size of this window, and the parties choose the start point of the window.</p><p>As discussed in the introduction, for the proof in this model, it is essential that the simulator is able to reset the bulletin board to a prior point (in essence, rewinding).</p><p>rewind: This functionality is reserved for the simulator in the ideal world. On receiving additional input t, the bulletin board internally resets its counter to t and clears all data stored beyond the counter value t. The simulator gets no output on this query.</p><p>⊥← BB(rewind, t)</p><p>We want to stress that this additional capability is only limited to the construction in this section and the construction in the next section (using trusted hardware) we will not require this.</p><p>We additionally discuss an extension to an optimistic phase where the parties can share some additional secrets (different from before) that enable them to decrypt a (different) ciphertext containing the output, without having to post to the bulletin board. Of course, the adversary can prematurely abort in this phase and obtain the output for itself. To protect against this, the optimistic phase is reached only once it has been established that the parties have enough information that would enable them to use the bulletin board, to decrypt to the output, in case the adversary aborts in this phase.</p><p>Construction. We now proceed to describe our protocol Π fair . It uses the cryptographic primitives and a bulletin board as described below. The formal protocol description is given in Figure <ref type="figure">1</ref>.</p><p>(1) A injective one-way functions f . (2) An authentication scheme with public verification (Gen, Tag, Verify BB ) such that the authentication tags are unique for a given message.</p><p>(3) A witness encryption WE for the language</p><formula xml:id="formula_9">L WE, ∆t = {y i } i ∈[n] ,T ∃ t, σ , {ρ i } i ∈[n] s.t. (∀i ∈ [n], y i = f (ρ i )) AND t ∈ {T ,T + 1, • • • ,T + ∆t } AND Verify BB ((t ||ρ 1 || • • • ||ρ n ), σ ) = 1</formula><p>For a given x ∈ L WE, ∆t , if f is an injective one-way function and (Gen, Tag, Verify BB ) is a scheme that generates unique authentication tags, it is easy to see that there are only ∆t + 1 witnesses for x. If ∆t is set to be polynomial in the size of x, there are only polynomially many witnesses for any given statement, and thus L WE, ∆t is a polynomial witness language (see Definition 3.4). From Theorem 3.6, given L WE, ∆t is a polynomial witness language, we know that a witness encryption for L WE, ∆t is also an extractable witness encryption for L WE, ∆t . (4) An MPC protocol that computes:</p><formula xml:id="formula_10">F ′ ∆t ((x 1 , ρ 1 , t 1 ), • • • , (x n , ρ n , t n )) = c, { f (ρ i )} i ∈[n] ,T</formula><p>where</p><formula xml:id="formula_11">T = max(t 1 , • • • , t n ) and c = WE.Enc(x WE, ∆t , F (x 1 , • • • , x n )) for x WE, ∆t = ({ f (ρ i )} i ∈[n]</formula><p>,T ). We do not require this protocol to be fair. Importantly, we use the MPC protocol in the common random string (CRS) model. This allows for black-box simulation of the adversary without the necessity of rewinding. For this section, we shall drop the CRS notation, but it will be implicit.</p><p>Remark 1. In the construction described above, the size of the witness encryption circuit is dependent on the number of parties in the protocol. This can be remedied by using the XOR of the ρ i values as the release token, and applying the injective one-way function on this. The rest of the protocol remains the same.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Proof of Security</head><p>We prove the security of our construction in the F ′ ∆t -hybrid model. Simulator S. We start by constructing a simulator S. Our simulator uses rewinding strategy similar to the one described in <ref type="bibr" target="#b41">[44]</ref> (which in turn builds on <ref type="bibr" target="#b37">[40]</ref>). The simulator has access to an ideal functionality for computing F , and simulates F ′ ∆t for the real world adversary. In addition, for the proof in this model, the simulator reserves the right to reset the bulletin board to prior point (in essence, rewinding). (We will not require this property in the protocol based on secure hardware.) Further, S forwards any queries the adversary makes to the bulletin board, and returns the corresponding response from the bulletin board.</p><p>(1) S receives inputs {(x a , ρ a , t a )} a ∈A sent by the adversary that are intended for F ′ ∆t . (2) Mark the current value of the counter so that S can rewind the bulletin board to this point. Protocol Π fair in the F ′ ∆t -Hybrid model Inputs: Each party P i has an input x i . Common input: The verification key for the bulletin board vk BB . The protocol:</p><p>(1) Computation of F ′ ∆t .</p><p>-P i samples token ρ i $ ← {0, 1} poly(λ) . -P i queries the bulletin board to get the current counter value, i.e. t i ← BB(getCurrentCounter).</p><p>-P i sends (x i , ρ i , t i ) to the ideal functionality F ′ ∆t and receives c, {y i } i ∈[n] ,T . It aborts if it receives ⊥ from the ideal functionality.</p><p>(2) Exchange of tokens. P i broadcasts ρ i to all other parties, and receives { ρ l } l ∈[n]\{i } .</p><p>(3) Obtaining the output. We split this into three cases, where either (i) P i can post on the bulletin board to receive a valid witness; or (ii) P i waits for another party to post to the bulletin board; or (iii) no party posts to the bulletin board. (i) P i received ρ j from all the other parties, such that ∀j ∈ [n] \ {i} : f (ρ j ) = y j . In this case, P i waits for the counter to get to T before posting to the bulletin board. Prior to posting, it check to see if another party has already posted the same. This could be done either by observing the broadcasts sent (to the bulletin board), or querying the bulletin board at most ∆t times. On obtaining the appropriate authentication tag, the witness encryption can be decrypted to get the output. (ii) P i received a ρ j such that f (ρ j ) y j , or ρ j =⊥ (i.e. a party didn't send its token). In this case, P i checks if the right message is posted to the bulletin board for counter values between T and T + ∆T . If it finds the right value, it obtains the authentication tag and decrypts the witness encryption to get the output. (iii) If there are no posts on the bulletin board satisfying the given requirements, and the counter has progressed beyond T + ∆t, P i aborts.</p><p>Figure <ref type="figure">1</ref>: Π fair in the F ′ ∆t -Hybrid model. The protocol relies on the security of witness encryption for a polynomial witness language, injective one-way functions and authentication scheme with public verification and unique tags.</p><formula xml:id="formula_12">(c) ∀i ∈ [n], y i f (ρ i ). (d) Compute out ← F ( x 1 , • • • , x n ) where x h = 0 for all h ∈ H . (e) Set x WE {y i } i ∈[n]</formula><p>,T and compute c ← WE.Enc x WE , out .</p><p>(f) Send (c, {y i } i ∈[n] ,T ) to the adversarial parties. (g) If the adversary responds with an abort, S sends abort to the ideal functionality computing F , and exits. For our analysis, we denote this by abort 1 . (4) S sends values {ρ h } h ∈H to the adversary. If the adversary sends values {ρ a } a ∈A such that ∀a, y a = f (ρ a ); or sends a post query to the bulletin board with value (ρ</p><formula xml:id="formula_13">1 || • • • ||ρ n )</formula><p>when counter value is betweenT andT +∆t such that ∀i, y i = f (ρ i ), the adversary has not aborted.</p><p>(5) If the adversary aborted in the previous step, S sends abort to the ideal functionality computing F , and exits. For our analysis, we denote this by abort 2 . (6) If the adversary didn't abort prior to this, we need to estimate the probability of the adversary not aborting. Let q represents the true of probability of this event, where the randomness is over random coins used in step 3(b) and 3(e). The estimated probability will be denoted by q. (a) S fixes some number t = poly(λ). (b) S rewinds the adversary to step 3, rewinds the bulletin board BB(rewind, t mark ) and repeats steps 3 and 4 (other than 3(g)) with fresh randomness each time. Repeat till the adversary has not aborted t times.</p><p>(c) S estimates q as q = t # of repetitions . The polynomial defining t is chosen to be large enough that Pr</p><formula xml:id="formula_14">1 2 ≤ q q ≤ 2 &gt; 1 -2 λ . (<label>7</label></formula><formula xml:id="formula_15">)</formula><p>The simulator sends {x a } a ∈A to the ideal functionality for F and receives out. S repeats the following at most t q times. (a) With fresh randomness each time, S rewinds the adversary to step 3, rewinds the bulletin board BB(rewind, t mark ) and repeats steps 3 and 4 (other than 3(g)) replacing out with out. (b) If the adversary does not abort, we output its view and the simulator terminates. ( <ref type="formula">8</ref>) If S has not terminated yet, output fail and terminate the simulation.</p><p>Claim 1. If simulator S does not outputs fail, the hybrid world and the ideal world are indistinguishable.</p><p>Proof. We split the analysis into two cases:</p><p>-Case 1: The adversary does not abort. Since the simulator does not output fail, it has successfully got the adversary to accept the transcript for the right output. In this case, the main thread of the adversary is statistically indistinguishable from the real execution. Additionally, since the simulator is able to rewind the bulletin board, the adversary's view of the bulletin board is that of a straight line execution. Thus the joint distribution consisting of the view of the adversary and the honest party outputs is indistinguishable.</p><p>-Case 2: The adversary aborts. As noted in the simulator, the adversary can abort in two phases of the protocol. We deal with the two case separately:</p><p>abort 1 : The adversary aborts immediately after running the MPC for F ′ ∆t . In both the real and ideal world, honest parties do not get any output. Thus, we need to argue that the adversary's view is indistinguishable when he receives a witness encryption of the actual output as opposed to when he received the witness encryption of a random string. To the contrary, assume that the adversary can distinguish between these two cases. Since there only polynomially many witnesses, we use the extractor for the adversary to recover the witness. Since the honest parties aborts without revealing its share of the token, we can use the extractor to construct an adversary that breaks the security of the injective one-way function.</p><p>abort 2 : The adversary aborts on receiving the honest party's tokens without posting to the bulletin board. We use the same technique as above, leveraging the extractor for witness encryption, to construct an adversary that breaks the unforgability of the authentication tags issued by the bulletin board.</p><p>Claim 2. The simulator S outputs fail with only negligible probability.</p><p>The proof can be found in Appendix A.; We assume that the value of T chosen in the protocol is such that the real execution of the protocol ends in time bounded above by a polynomial д(λ). Otherwise F ′ ∆t implements an additional check to ensure this. Claim 3. The simulator S runs in expected polynomial time.</p><p>Proof. With probability 1 -q, the simulator aborts prior to step 6. With probability q, the simulator goes through the estimation phase and then attempts to force an accepting transcript onto the adversary. The expected number of iterations for the estimation phase is t q and the cut-off point for forcing the transcript is t q &lt; t 2q . Hence the total expected running time is bounded by</p><formula xml:id="formula_16">д(λ) • q • t q + 2t q = д ′ (λ)</formula><p>Thus S runs in expected polynomial time.</p><p>Given the above claims, the following theorem follows.</p><p>Theorem 5.1. Assuming the security of injective one-way functions, witness encryption for polynomial witness language and the unforgeability of the authentication scheme, the above protocol satisfies Definition 3.1 in the F ′ ∆t -hybrid model.</p><p>As mentioned in the introduction, in order to rely on the standard security of WE, we require the bulletin board's proof of publish to be implemented via unique signatures <ref type="bibr" target="#b40">[43,</ref><ref type="bibr" target="#b53">56]</ref>. If the bulletin board is implemented via standard signatures (e.g., in Google Transparency Certificates) or proofs of stake (e.g., in Etherium), then we require the stronger assumption of extractable witness encryption <ref type="bibr" target="#b16">[19]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">FAIRNESS FROM SECURE HARDWARE</head><p>A key limitation of our previous constructions is the need to use Witness Encryption (WE) to protect the output of the MPC protocol. Unfortunately, current proposed WE construction are inefficient, due to the high overhead of current constructions of multilinear maps. Moreover, the Witness Encryption paradigm requires the parties to compute a new WE ciphertext for each invocation of the MPC protocol.</p><p>In this section we investigate an alternative paradigm that uses secure hardware. Our work is motivated by the recent deployment of commodity virtualization technologies such as Intel's Software Guard Extensions (SGX). These technologies allow for the deployment of secure "enclave" functionalities that can store secrets and perform correct computation even when executed in an adversarial environment. Moreover, these systems allow an enclave to remotely attest to their correct functioning, which allows for the establishment of trustworthy communications between enclaves running on different machines.</p><p>Model Following the approach of Pass et al. <ref type="bibr" target="#b56">[59]</ref> we model all available trusted hardware processors from a given manufacturer as a single, globally shared functionality denoted G att (see Figure <ref type="figure">5</ref>). We describe the functionalities required for our construction, and refer the reader to <ref type="bibr" target="#b56">[59]</ref> for details. install loads the program prog onto the attested hardware. It returns an enclave identifier eid. (For simplicity, we skip the session identifier used in <ref type="bibr" target="#b56">[59]</ref>.) The enclave identifier is be used to identify the enclave upon resume. resume allows for a stateful resume using the unique enclave identifier generated. On running over a given input, the output produced is signed to attest that the enclave with identifier eid was installed with a program prog, which was then executed to produce the output. The program's input is not included in the attestation.</p><p>Description. We describe here the main ideas in this construction that differ from the previous construction. Upon loading the program onto the attested hardware (enclaves), there is an initial key exchange to establish a secure authenticated channel between the enclaves. Any information passed over this channel is hidden from the parties. It is important that enclaves attest to the fact that they are running the correct programs prior to the key exchange.</p><p>Next, the shares of the release token and the key are input to the enclave. The enclaves use the established secure authenticated channel to exchange this information and set up consistent parameters (over all enclaves) for the decryption circuit. The parties then run an MPC protocol external to the enclaves to compute an encrypted version of the output. As in our previous construction, the players exchange shares of the release token that they are required to post onto the bulletin board in order to decrypt.</p><p>For technical reasons, we need to ensure that the key share that a party sends to the enclave is the one used in the MPC. This is ensured by using a commitment scheme which the MPC computation verifier before returning the output.</p><p>Our protocol makes requires the following primitives:</p><p>(1) A one-way function f . <ref type="foot" target="#foot_6">6</ref>(2) A signature schemes (Gen, Sign, Verify).</p><p>(3) An authentication scheme with public verification (Gen, Tag, Verify BB ). (4) A multi-party computation in the CRS model for computing F ′ defined as</p><formula xml:id="formula_17">F ′ x i , k i , {com i j } j ∈[n] , r i i ∈[n] =            ⊥ if ∃i, i ′ s.t. {com i j } j ∈[n] {com i ′ j } j ∈[n] ⊥ if ∃i s.t. com ii Com(k i ; r i ) y otherwise where y = AE.Enc n i =1 k i (F (x 1 , • • • , x n )).</formula><p>Essentially the MPC takes in a the input, key share, a commitment tuple and a decommitment from each party. It checks if the tuple pairs received are the same throughout and the commitment linked to each party decommits to the key share. If this check fails it just returns ⊥, or it returns the output y.</p><p>(5) Two instances of AE scheme (Enc, Dec) with INT-CTXT security for authentication and semantic security. (6) A commitment scheme (Com) with computational hiding and statistically binding. We describe and prove the protocol in the two party setting. Both extended naturally to the multi-party setting. The protocol is described in Figure <ref type="figure" target="#fig_1">2</ref>.</p><p>We note that there are two trapdoors installed into functionalities of prog fair . These are used for the security reduction of the one-way function, and to program the output correspondingly. Specifically, the trapdoor is used to get the enclave to attest to a value of choice. These trapdoors can be used by an adversarial party, but this makes no difference to the security since these values are not sent across to the other party. Theorem 6.1. Assume that F is one-way, the signature scheme is existentially unforgeable under chosen message attacks, the authentication scheme satisfies standard notion of unforgeability, the encryption scheme is perfectly correct, authenticated encryption scheme that is perfectly correct and satisfies standard notions of INT-CTXT and semantic security, decisional Diffie-Hellman assumption holds in the algebraic group adopted. Then, the above protocol satisfies Definition 3.1 in the (G att , F ′ )-hybrid model.</p><p>The proof can be found in Appendix A.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">INSTANTIATING THE BULLETIN BOARD</head><p>Our proposed paradigm relies on a verifiable public bulletin board that makes three guarantees about entries posted to it:</p><p>-The entry's presence can be cryptographically verified using a public operation. -Once posted, the entry is available to all parties.</p><p>-Entries are assigned a unique monotonically increasing sequence number. We now consider several existing techniques that we can leverage to obtain such a bulletin board.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Certificate Transparency Logs. Certificate Transparency (CT) [1]</head><p>is a public audit log operated by a coalition of browser vendors and certificate authorities. CT allows individual certificate authorities to post newly-issued certificates to a public log. These entries are then (1) signed by the log maintainer, and (2) added to a Merkle hash tree. The root of the hash tree is also signed by (one or more) log maintainers and published to the world.</p><p>A collection of users known as monitors can access the CT log to view the contents of certificates. While the CT log is itself not fundamentally tamper resistant -since the servers operating it can remove portions and/or be disabled by remote network attacksany tampering is detectable due to the structure of the Merkle hash tree. The location of the entry within the Merkle hash tree also serves to act as a proxy for a monotonically increasing sequence number.</p><p>Under the assumption that the existing CT logs are reliable and trustworthy, we can use CT to build fairness systems by entombing the required public data into a component of an X.509 certificate signing request and requesting the certificate from a free certificate authority such as LetsEncrypt <ref type="bibr" target="#b0">[2]</ref>. Because LetsEncrypt submits all certificates to a public log<ref type="foot" target="#foot_7">7</ref> it is possible for any party to recover these certificates and verify a cryptographic proof that the entries have been published.</p><p>Public blockchains. Crypto-currencies such as Bitcoin or Etherium rely on a publicly available data structure called a blockchain. Blockchains are an append-only ledger that is maintained by an ad-hoc group of network peers. Blockchains come in two basic types. The first type use computational proofs of work to determine which peer should be allowed to add a new block of transactions to the blockchain. Clients accept the longest chain that contains well formed transactions; as a result the system is secure as long as a supermajority of the computational power in the network is controlled by honest peers. This approach is tolerant of churn, and thus we need not pick a set of honest parties in advance.</p><p>An alternative approach uses proof of stake <ref type="bibr" target="#b13">[16]</ref>. In these systems a quorum of peers is sampled from the network with probability proportional to the fraction of monetary holdings controlled by each peer. This quorum is responsible for producing the next block and selecting the next quorum by the same mechanism. The peers authenticate the resulting block by signing it using a secure digital signature scheme. The security assumption here assumes that the parties with the largest share of the cryptocurrency have a vested interest in keeping it running. Proof of stake systems are in their infancy both in terms of deployment and theory. However, they provide an interesting middle ground between the costs of a pure proof of work approach and the challenges with selecting a set of trusted parties a priori to maintain the bulletin board.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">IMPLEMENTATION</head><p>In this section we present an implementation of the protocol given in Section 6, and show that the protocol is efficient. Our implementation consists of three major pieces: the bulletin board instantiated using Bitcoin, the MPC protocol instantiated using the SPDZ framework <ref type="bibr" target="#b1">[3,</ref><ref type="bibr" target="#b26">29]</ref>, and a "witness decryptor" instantiated using an Intel SGX secure enclave. We describe each component in more detail below.</p><p>prog fair [∆t, P 0 , P 1 , vk BB , i] where i ∈ {0, 1} //for party P i On input ("keyex"): Let a $ ← Z p , and return д a On input ("init", k, t, ρ, r ):</p><formula xml:id="formula_18">let k i k, t i t, ρ i ρ i com i</formula><p>Com(k i ; r ), return com i On input ("send", д b ):</p><formula xml:id="formula_19">let sk = д b a</formula><p>, ct i ← AE.Enc sk (k i , t i , ρ i , com i ) return ct i On input ("receive", ct ′ 1-i ): assert "init" and "send" have been called.</p><formula xml:id="formula_20">(k 1-i , t 1-i , ρ 1-i , com 1-i ) AE.Dec sk ct ′ 1-i return com 1-i</formula><p>On input ("getParams", v): assert "init", "send" and "receive" have been called Prot fair [F , ∆t, P 0 , P 1 , vk BB , i] where i ∈ {0, 1} //for party P i , P j = P 1-i Input: x i Protocol:</p><formula xml:id="formula_21">T max{t 0 , t 1 }, y f (ρ 0 ⊕ ρ 1 ), K k 0 ⊕ k 1 if v ⊥,</formula><p>(1) let eid i ← G att .install(prog fair [∆t, P 0 , P 1 , vk BB , i]).</p><p>(2) Initiate the key exchange procedure. Let (д a , σ i ) ← G att .resume(eid i , "keyex"). Send (eid i , д a , σ i ) to P j , await eid j , д b , σ j from P j .</p><p>Check if Ver mpk ((eid j , prog fair [∆t, P 0 , P 1 , vk BB , j], д b ), σ j ) = 1, else abort.</p><p>(</p><formula xml:id="formula_22">) k i $ ← {0, 1} λ , ρ i $ ← {0, 1} λ , r i $ ← {0, 1} λ , t i ← BB(getCurrentCounter).<label>3</label></formula><p>(4) Initialize the enclave with the values obtained in the previous step. (com i , _) G att .resume(eid i , "init", ρ i , k i , t i , r i ).</p><p>(5) Set up the exchange of information between enclaves. Let (ct i , _) ← G att .resume(eid i , "send"). Send ct i to P j and wait for ct j in response. On receiving ct j , send it to the enclave (com 1-i , _) ← G att .resume(eid i , "receive", ct j ). At this point, both commitments are available to the party. (6) Get parameters for the MPC computation, (T , y) ← G att .resume(eid i , "getParams", ⊥) (7) Send (x i , k i , com 0 , com 1 , r i ) to F ′ and receive ct MPC . Abort if ⊥ is received. // ct MPC of the form AE.Enc K (F (x 0 , x 1 )) (8) Send token share ρ i to P j and wait for token share ρ j .</p><p>-If ρ j not received, or f (ρ 0 ⊕ ρ 1 ) y, then wait to see if P j posts the right value on the bulletin board, when the counter is between T and T + ∆t. If the counter goes beyond T + ∆t, and no such value posted, abort. If the right value is posted at counter t BB , (σ BB , ρ) ← BB(getContent, t BB ). -ρ j received and f (ρ 0 ⊕ ρ 1 ) = y. Wait for the counter value to get to T , and then post ρ 0 ⊕ ρ 1 on the bulletin board to get the corresponding authentication tag, i.e. (σ BB , t BB ) ← BB(post, ρ 0 ⊕ ρ 1 ). -Output G att .resume(eid i , "output", t BB , ρ 0 ⊕ ρ 1 , σ BB , ⊥). Initialization Decrypt mean 1.180 ± 0.112 0.039 ± 0.001 mean 0.002 ± 0.000 0.037 ± 0.001 Table <ref type="table">1</ref>: Performance of SGX enclave setup and decryption (not MPC). Average and standard deviation of 500 runs.</p><p>Bitcoin as a bulletin board. For our prototype implementation we use the Bitcoin network, which supports a limited scripting system called Bitcoin Script. In Bitcoin each transaction contains a script that is evaluated to ensure the transaction is authorized. This scripting system supports an instruction named OP_RETURN, which allows the sender of a transaction to embed up to 40 bytes of arbitrary data into a transaction that is transmitted for inclusion in the Bitcoin blockchain. Each block of transactions in the blockchain contains a computational proof of work (PoW) that is computed by the network. This proof is bound cryptographically to all of the transactions within a block, as well as to the hash of the previous block. At current network difficulty, computing a proof of work for a single block requires an expected 2 64 invocations of the SHA2 hash function on the standard Bitcoin network. To verify publication on the bulletin board, our implementation requires a fragment consisting of six consecutive blocks (where the transaction is located in the first block of the fragment). The cost of forging such a fragment scales linearly in the number of blocks required.</p><p>We note that the use of a computational proof of work bulletin board provides somewhat different fairness properties than a signature-based bulletin board, e.g., Certificate Transparency or a proof-of-stake blockchain. Specifically, in this setting an attacker with sufficient time or computational power can always "forge" a satisfying chain of blocks, and use this private result as a witness to enable decryption. Such an attack would be economically costly, since the corresponding effort -if applied to crypto-currency mining -would be worth a substantial sum of money. <ref type="foot" target="#foot_8">8</ref> However, we can further restrict this attacker by employing a trusted clock within the witness decryptor (e.g., Intel SGX) <ref type="foot" target="#foot_9">9</ref> . This optimization requires the attacker to complete the forgery within a pre-defined time limit that approximates the expected time for the full Bitcoin network. Thus a successful attacker must possess most of the available hashpower of the Bitcoin network (which currently approximates the electrical consumption of Turkmenistan).</p><p>For our experiments, we use the public Bitcoin testnet. The Bitcoin testnet functions similarly to the main Bitcoin network, but uses a zero-value currency and a low difficulty setting for the proof of work. We selected testnet for our experiments mainly because blocks are mined extremely rapidly and transactions require no monetary expenditure for "transaction fees". However our code can use the production Bitcoin blockchain without any code changes.</p><p>MPC Protocol. Our protocol can be used to extend any MPC scheme that supports efficient symmetric encryption. We note that one could employ Intel SGX directly to perform a naive form of MPC. However, our goal in this work is to demonstrate that our approach works efficiently even when instantiated with a "cryptographic" MPC protocol. <ref type="foot" target="#foot_10">10</ref>Thus for our implementation we use the SPDZ-2 framework developed by the University of Bristol <ref type="bibr" target="#b1">[3]</ref>. SPDZ-2 is designed to tolerate dishonest majorities during computation. In SPDZ circuits are designed in python and then compiled down into a circuit structure. The computation is done in two phases: an offline phase that does not require the computation inputs and an online phase that performs the actual computation. In order to optimize the running time of the online phase, the pre-computation and compilation phases are relatively more time consuming.</p><p>The maintainers of SPDZ-2 have implemented the AES-128 cipher in order to benchmark its efficiency. We repurpose this code to build a simple authenticated encryption system for that uses 3 rounds of AES to encrypt and authenticate one 128-bit block of data output from the computation. The encryption scheme takes as input each party's private computation input x i and keyshare k i . It computes as output a ciphertext C encrypted under msk. We also use this AES-128 cipher to implement a commitment scheme.</p><p>The randomness of the commitment scheme is used as the key to the cipher, with the commitment message as the plaintext.</p><p>We construct an MPC circuit for SPDZ-2 that takes in a private input x i , a keyshare k i , a randomness share r i , and commitment to the master key com(msk; r ). The first circuit computes the output of the desired MPC functionality f (x 1 , . . . , x N ). Next it computes r = ⊕ 1≤i ≤N r i and opens the commitment. It compares ⊕ 1≤i ≤N k i with the msk from the commitment. If they do not match, sets f (x 1 , . . . , x N ) = 0. Finally, the circuit computes the encryption of f (x 1 , . . . , x N ) using msk and outputs the final ciphertext.</p><p>SGX as Witness Decryptor. Intel's SGX is a set of extensions to the x86 instruction set that allows for code to be executed in a protected enclave. SGX programs are segmented into two pieces: an untrusted application and a trusted enclave. The application consists of standard software running on a standard operating system and we assume that it may behave maliciously if the i t h player is corrupted. Code within an enclave is verified upon startup and isolated from inspection and tampering, even from an adversary that controls the system's operating system. The root of trust of an SGX enclave is the Intel processor, which enforces the enclave's isolation. It is worth noting that the code run within an enclave is not private; however secrets may be generated or retrieved after the enclave is initialized. Note that the enclave has no direct access to network communications, and must rely on the untrusted part of the application. <ref type="foot" target="#foot_11">11</ref>We adapt an existing SGX-bitcoin client called Obscuro [4] to perform the role of the Witness Decryptor. This enclave is instantiated by each of the N parties participating in the protocol. A single master instance of the enclave uses the sgx_read_rand function, supplied by the SGX environment, to generate an AES master key msk that will eventually encrypt the output of the MPC circuit. Additionally, the master enclave generates a random 320-bit release token t that must be verifiably posted to a bulletin board before the ciphertext can be decrypted. Next, the master applies a secret sharing scheme to derive secret shares (k 1 , . . . , k N ) of msk and (t 1 , . . . , t N ) of t. Finally, the master computes a commitment com(msk; r ) and secret shares the randomness into r 1 . . . r N . Now for i = 1 to N it distributes the tuple (k i , t i , msk, t, com(msk; r ), r i ) to the i t h enclave via a secure channel. <ref type="foot" target="#foot_12">12</ref>Once all secrets have been distributed by the master enclave, the channels are closed and each enclave outputs its key share k i to the application. The users now invokes SPDZ to conduct the MPC protocol, using as its private inputs x i , k i , r i , and com(msk; r ). If the MPC protocol does not complete successfully, the application aborts and a full restart is required. Otherwise, the application obtains a ciphertext C output by the MPC protocol and provides this as input to the enclave. The enclave attempts to decrypt the ciphertext under msk and if and only if this decryption check completes successfully (and the result is the proper format and length), it releases t i , which the application then transmits to all of the remaining parties.</p><p>To access the encrypted output of the MPC, at least one party must re-compute the release token as t = (t 1 ⊕ • • • ⊕ t N ) and post this value to the Bitcoin network inside of a transaction. Each user's application monitors the Bitcoin network using RPC calls to a local Bitcoin client bitcoincli which is running on the user's machine. This userland code then feeds the resulting blockchain fragment (which consists of six consecutive blocks) back to the enclave, which confirms that the release token matches its stored value t, and also verifies the proofs of work on each block. While an adversarial user can block this response, they are unable to falsify or tamper with it due to the fact that such tampering would require an impractical amount of computation. The application also supplies the enclave with the output of the MPC C.</p><p>If all verifications succeed, the enclave decrypts the ciphertext C using an authenticated encryption scheme under msk, and outputs the resulting plaintext. Optimizations. In a bid to optimize the implementation, there are a few differences from the described protocol in section 6. They do not make a difference to the security of the protocol, and are briefly described here:</p><p>-Instead of each party generating its key and token shares, a designated master enclave chooses them and distributes them to the other enclaves. -Instead of a commitment for each share of the key, there is only a single "master commitment" of the key.</p><p>Sample computation and performance. For proof of concept, we implemented a search program that takes as input a search value x from one party and a list (y 1 , . . . , y n ), from the other party. These circuits each calculate an integer output M and encrypt the result as Enc( n 1 k i ; M). Since these are two-party functions we tested with N = 2 and n = (100, 500, 1000). Cost of fairness in the MPC. Our implementation demonstrates that our approach can be used add fairness to MPC schemes efficiently using current technology. We recall that fairness in MPC is particularly important when the output of the MPC is extremely valuable. While adding three rounds of AES to a simple MPC scheme represents a high cost, it adds a only a negligible cost when considering more time consuming computations. In Figure <ref type="figure" target="#fig_2">3</ref> we show the average runtime over 50 trials of a number of different circuits in SPDZ-2. The cost of encryption is clearly dwarfed by large search problems and set intersection.</p><p>While we ran the MPC experiments with N=2 players, SPDZ-2 allows computations with more players. In Figure <ref type="figure" target="#fig_3">4</ref> we consider only the cost of running the encryption component of the MPC protocol with higher numbers of players. Because each player contributes a key share, the cost of running the protocol increases with each player. While the runtime of the encryption operation does increase, we note that it is still adds only a fraction of one second of online computation time up to N = 6. SGX Runtime. Intel SGX offers an extremely efficient method of trusted program execution. We benchmark our SGX Enclave over 500 trials of the two party protocol for some fixed parameters. We run our test on an Intel i5-6600K 3.5GHz processor with 16 GB of RAM running Ubuntu 14.04 and SGXSDK-1.7, running both the master and minion on the same hardware. For the purpose of benchmarking, we hardcode into the master enclave the master AES key and fix the release token to be the results of an OP_RETURN instruction in a known block of the Bitcoin Testnet. Additionally, we run the MPC protocol once to generate a valid ciphertext. With the pre-fixed values, we can effectively check the running time of the various parts of the enclave's execution. All key exchange and interaction with the bitcoincli is still run as in the real protocol. In Table <ref type="table">1</ref> we show the average running times of the various segments of the enclave, both for the master instance and minion instance. For the minion's execution time, we pause the timer while it is waiting for the minion to open a network connection. It is clear that the slowest piece of the program is the enclave initialization. This is because the enclave must provision all memory that it may require from the SGX driver during initialization. Our implementation allocates more memory than it will use to be conservative.</p><p>Proof. Since the only changes are additional checks, it is enough to show that S outputs ⊥ AE 2 with only negligible probability. This follows directly from the INT-CTXT security of the AE scheme. Specifically, we can receive the challenge ciphertext to the be the encryption of the function value (either under the challenge key, or a random key). If the adversary is able to produce a verifying ciphertext different from the one it receives it constitutes a forgery, thus breaking the INT-CTXT security of the AE scheme. Proof. The change is only statistical since the execution thread reaches the point only if all prior checks pass.</p><p>Hyb 8 : Identical to Hyb 7 except that we replace the value inside the ciphertext to be F (0, x 1 ). Claim 12. If the semantic security of the encryption scheme holds, Hyb 8 is computationally indistinguishable from Hyb 7 .</p><p>Proof. If the two hybrids are distinguishable, then we can build an adversary that breaks the semantic security of the encryption scheme. Proof. Follows directly from DDH security.</p><p>Hyb 9 is the same as our simulator, and hence we're done.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B SGX FUNCTIONALITY</head><p>The SGX functionality is presented in Figure <ref type="figure">5</ref>. Additional notation from <ref type="bibr" target="#b56">[59]</ref> used is described below:</p><p>-P is the identifier of party.</p><p>reg refers to the registry of machines with the trusted hardware. -prog is the program.</p><p>inp, outp refers to the input and output.</p><p>mem is the program's memory tape.</p><p>-Σ is a signature scheme.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>t mark ← BB(getCurrentCounter) (3) S simulates the output of ideal functionality computing F ′ ∆t as follows: (a) Set T = max{{t a } a ∈A , t mark }. (b) Randomly pick {ρ h } h ∈H for the honest parties.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Two party fair protocol Prot fair in the (G att , F ′ )-hybrid model.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Mean runtimes for a linear search on n items using SPDZ taken over 50 iterations. Only the online portion of the MPC is shown. In blue, we show the cost of running the search without any provision for fairness. In red, the overhead from AES encryption needed for fairness.</figDesc><graphic coords="13,53.80,422.06,240.24,175.30" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Mean runtimes for our AES circuit varied over the number of players participating. Only the online portion of the MPC is shown. This circuit is dominated by 3 AES operations.</figDesc><graphic coords="13,317.96,83.69,240.24,180.18" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Hyb 7 :</head><label>7</label><figDesc>Identical to Hyb 6 except that if check did not result in a failure, send x 1 to the trusted party to obtain out. If the witness checks succeeds, program the output of the enclave to be out. Else program output to be ⊥. Claim 11. Hyb 7 is statistically indistinguishable from Hyb 6 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Hyb 9 :</head><label>9</label><figDesc>Identical to Hyb 8 except that we replace all occurrences of sk with д ab again. Claim 13. Assume DDH is hard, Hyb 9 is computationally indistinguishable from Hyb 8 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>return v, else return (T , y) On input ("output", ct MPC , t, ρ, σ , v):if v ⊥, return v assert "getParams" has been called assert t ∈ {T ,T + 1, • • • ,T + ∆t } assert f (ρ) = y assert Ver BB (t, ρ, σ ) return AE.Dec K (ct MPC )</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Looking forward, our protocol only needs to post a constant sized token to the blockchain and this can readily be embedded in a URL or certificate.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>In the specific case where the bulletin board is implemented using a proof of work blockchain, we can use secure clocks to achieve stronger security guarantees. This is unnecessary when the bulletin board uses signatures. We discuss this further in Section 8.Session C5: Using Blockchains CCS<ref type="bibr" target="#b14">'17,</ref> October  </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p><ref type="bibr" target="#b27">30</ref>-November 3, 2017, Dallas, TX, USA</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_3"><p>We also use an MPC in the common random string (CRS) model (e.g.,<ref type="bibr" target="#b20">[23]</ref>) to implement the first phase of the protocol. By using the CRS trapdoor, the simulator for this phase can avoid any rewinding of the adversary.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_4"><p>  4  In practice, such proof of work blockchains provide a slightly weaker security that is related to ∆-fairness. An attacker, given enough time, may be able to forge the proof of work necessary to prove publication. However, in the trusted hardware setting we are able to mitigate this concern to some extent by requiring the attacker to provide a proof in a limited period of time, as judged by the hardware.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_5"><p>One can also consider asymmetric functionalities where every party receives a different output. Since there are generic transformations from the symmetric case to the asymmetric case, we only consider symmetric functionalities for simplicity of exposition.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_6"><p>In practice we suggest using a hash function.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_7"><p>See https://crt.sh/?id=15707024 Session C5: Using Blockchains CCS'17, October 30-November 3, 2017, Dallas, TX, USA</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_8"><p>At present rates as of July 2017, this opportunity cost is approximately $28,000 per block forged.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_9"><p>Correctly accessing trusted time from within an enclave is part of the Intel SGX specification, but it is not yet supported as it relies on platform services which are not active. In our implementation, we include code to properly access trusted time, but do not include it in our measurements because of the lack of support.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_10"><p>Additionally, we remark that if SGX is used to implement the MPC protocol itself, a security breach of the SGX system will result in the loss of all security properties provided by the MPC. On the other hand, if we employ a cryptographic MPC protocol, then a failure of Intel's SGX risks only the fairness property. We view this as a benefit of our approach.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11" xml:id="foot_11"><p>This enables the application to censor or tamper with communications between the application and the network.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="12" xml:id="foot_12"><p>SGX supports the creation of authenticated, secure channels using attestation and DHKE.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Session C5: Using Blockchains CCS'17, October 30-November 3, 2017, Dallas, TX, USA</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">ACKNOWLEDGMENTS</head><p>This research was supported in part by the National Science Foundation under awards CNS-1010928, CNS-1228443, CNS-1653110, CNS-1414023 and EFMA-1441209; The Office of Naval Research under contract N00014-14-1-0333; DARPA/ARL Safeware Grant W911NF-15-C-0213; and the Mozilla Foundation.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A PROOFS A.1 Proof of Claim 2</head><p>The analysis for the proof below is taken from <ref type="bibr" target="#b37">[40,</ref><ref type="bibr" target="#b41">44]</ref>.</p><p>Proof. The simulator S outputs fail only if it has reached step 7 and then fails in producing an accepting transcript. S fails to reach step 7 with probability q.</p><p>We denote by p, the probability that the adversary does not aborts when given the witness encryption of the correct functionality, i.e., p is the probability when the adversary is given the witness encryption of F (x 1 , • • • , x n ). Recollect that q is the probability of the adversary not aborting when given the witness encryption of F ( x 1 , • • • , x n ) where ∀a, x a = x a and ∀h, x h = 0. From the security of witness encryption, we require |q -p| is negligible in the security. (probability is taken over the random coins used to generate the output of F ′ ∆t .</p><p>)</p><p>To show that the above equation is negligible in λ, we split the analysis into two cases:</p><p>-Case 1: p ≥ q 2 . Substituting, we get</p><p>To the contrary, let us assume Equation 1 is non-negligible. Then, there is a polynomial poly and infinitely many values λ such that</p><p>.</p><p>Thus q &gt; 1 poly ′ (λ) for some polynomial poly ′ . This gives us</p><p>. This breaks the security of the witness encryption scheme.</p><p>Thus S outputs fail with only negligible probability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 Proof of Theorem 6.1</head><p>We consider the two party setting where P 1 is corrupted. The other case is symmetric. The simulator S works as follows:</p><p>(1) Unless otherwise mentioned, S passes through messages between adversary A(P 1 ) and G att . (2) S loads the program to get the corresponding eid 0 , i.e. eid 0 ← G att .install(prog fair [∆t, P 0 , P 1 , vk BB , 0]). (3) Next, S initiates the key exchange phase (д a , σ 0 ) ← G att . resume(eid 0 , "keyex") and sends (eid 0 , д a , σ 0 ) message to A.</p><p>(4) S waits to receive eid 1 , д b , σ 1 from A.</p><p>The simulator sees messages between A and G att , and can see if eid 1 , д b , σ 1 sent by A is different from the corresponding tuple it received from G att . If the tuples differ and the signature verifies, output ⊥ G att and exit.</p><p>(</p><p>and initialize G att with these values, (com 0 , _)G att .resume(eid 0 , "init", ρ 0 , k 0 , t 0 , r 0 ). Simulator sees the values (ρ 1 , k 1 , t 1 , r 1 ) that A sends to G att . (6) S calls (ct 1 , _) ← G att .resume(eid 0 , "send"), sends ct 1 to A and waits for ct 0 .</p><p>As before, the simulator observes if ct 0 sent by A is different from the value it received from G att . If so, and G att doesn't throw an exception, output ⊥ AE 1 and exit. ( <ref type="formula">7</ref>) Make a call to G att to get the parameters, (T , y, _) ← G att . resume(eid 0 , "getParams", ⊥).</p><p>If the commitment values are not the same as the ones received earlier, send abort to the ideal functionality and send ⊥ to the adversary. If k ′ 1 k 1 , i.e. the key shares sent at different points differ, and if com ′ 1 = Com(k ′ 1 ; r ′ 1 ) output ⊥ com and exit. Else, pick K ′ randomly and compute ct MPC ← AE.Enc K ′ (F (0, x 1 )) to send to A. (9) S obtains its token share from G att , (ρ 0 , _) ← G att .resume (eid 0 , "getTokenShare", ⊥). (10) If A aborts immediately after receiving the output from F ′ without the honest party getting it, send abort to the ideal functionality. But continue running S. If the adversary sends to the bulletin board or enclave the correct pre-image of y, S outputs ⊥ f and exits. (11) If A has not aborted, send ρ 0 to A. If the adversary does not send ρ 1 , or post a valid pre-image during the interval T to T + ∆T , but queries G att for the output on a valid authentication tag, then we output ⊥ BB and exit. ( <ref type="formula">12</ref>) Alternatively, we split the behavior of the simulator three cases:</p><p>-If A responds with a valid ρ 1 (i.e. f (ρ 0 ⊕ ρ 1 ) = y), then post to the bulletin board. Recollect that S has reached this point only if the key shares sent by A were consistent. Send x 1 to the ideal functionality to receive out. If A makes the correct query to the enclave, i.e. the ciphertext sent is the same as the one from the MPC, S programs the output by returning G att .resume(eid 1 , "output", t BB , σ BB , out).</p><p>If the ciphertext is different and authenticates under key K ′ , then output ⊥ AE 2 and exit.</p><p>-If the adversary does not send ρ 1 but posts a pre-image of y during the interval T to T + ∆T , S follows the same approach as the previous step. -If A attempts to use the backdoor, forward the message to G att without modification.</p><p>We prove indistinguishability of the real and ideal worlds through a sequence of hybrids.  Claim 4. Assuming that the underlying signature scheme is secure, Hyb 1 is computationally indistinguishable from Hyb 0 .</p><p>Proof. Hyb 1 exits with output ⊥ G att with only negligible probability. If not, we can use A to construct an adversary that breaks the signature scheme.   Proof. The only changes are in the checks performed. We argue that Hyb 3 will output a special abort with only negligible probability:</p><p>-⊥ AE 1 is output with only negligible probability. Else, we can leverage the adversary to break the INT-CTXT security of the AE scheme.</p><p>-⊥ com is output with only negligible probability. Else, we can leverage the adversary to break the statistical binding property of the commitment scheme. -⊥ f is output with only negligible probability. Else we can break the security of the one way function. This follows from the fact that the simulator is see the queries that the adversary makes to the enclave and the bulletin board. Since we want to force the challenge value y * onto the adversary, we use a backdoor in the function. This backdoor does not give the adversary any undue advantage as the value is not sent across to the other party. -⊥ BB is output with negligible probability. Else, we can leverage the adversary to break the unforgeability of the authentication scheme for the bulletin board. This is because the adversary was able to produce a signature that has not been queried for before.</p><p>Hyb 4 : Identical to Hyb 3 except that we intercept the ciphertext query for the output, and program the output using the trapdoor to be AE.Dec K (ct) if the other conditions are satisfied. Here K is the key in the enclave. Proof. This follows from the fact that it was only a statistical change. This is because we moved the exact check to the outside of the enclave. Proof. If the two hybrids are distinguishable, we can leverage the adversary to break the computational hiding of the commitment scheme.</p><p>Hyb 5 : Identical to Hyb 4 except that we pick K ′ randomly and use K ′ to encrypt the output. Now, the output is programmed in the last round with respect to the key K ′ . Claim 9. If the semantic security of the AE scheme holds, Hyb 5 is computationally indistinguishable from Hyb 4 .</p><p>Proof. If the two hybrids are distinguishable, then we can build an adversary that breaks the semantic security of the AE scheme.  </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Let&apos;s Encrypt</title>
		<ptr target="https://letsencrypt.org/" />
		<imprint>
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Multiparty computation with SPDZ online phase and MASCOT offline phase</title>
		<ptr target="https://github.com/bristolcrypto/SPDZ-2" />
	</analytic>
	<monogr>
		<title level="j">Github</title>
		<imprint>
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Almost-Optimally Fair Multiparty Coin-Tossing with Nearly Three-Quarters Malicious</title>
		<author>
			<persName><forename type="first">Bar</forename><surname>Alon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eran</forename><surname>Omri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC, Part I</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="307" to="335" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Secure Multiparty Computations on Bitcoin</title>
		<author>
			<persName><forename type="first">Marcin</forename><surname>Andrychowicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Dziembowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Malinowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lukasz</forename><surname>Mazurek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="443" to="458" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Towards Characterizing Complete Fairness in Secure Two-Party Computation</title>
		<author>
			<persName><forename type="first">Gilad</forename><surname>Asharov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="291" to="316" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Complete Characterization of Fairness in Secure Two-Party Computation of Boolean Functions</title>
		<author>
			<persName><forename type="first">Gilad</forename><surname>Asharov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amos</forename><surname>Beimel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nikolaos</forename><surname>Makriyannis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eran</forename><surname>Omri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC, Part I</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="199" to="228" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A Full Characterization of Functions that Imply Fair Coin Tossing and Ramifications to Fairness</title>
		<author>
			<persName><forename type="first">Gilad</forename><surname>Asharov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yehuda</forename><surname>Lindell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tal</forename><surname>Rabin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="243" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Fair and Efficient Secure Multiparty Computation with Reputation Systems</title>
		<author>
			<persName><forename type="first">Gilad</forename><surname>Asharov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yehuda</forename><surname>Lindell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hila</forename><surname>Zarosim</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note>In ASIACRYPT. 201-220</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Optimistic Protocols for Fair Exchange</title>
		<author>
			<persName><forename type="first">N</forename><surname>Asokan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Schunter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Waidner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS &apos;97, Proceedings of the 4th ACM Conference on Computer and Communications Security</title>
		<meeting><address><addrLine>Zurich, Switzerland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-04-01">1997. April 1-4, 1997</date>
			<biblScope unit="page" from="7" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Optimistic Fair Exchange of Digital Signatures (Extended Abstract)</title>
		<author>
			<persName><forename type="first">N</forename><surname>Asokan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Shoup</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Waidner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="591" to="606" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Multiparty Computation with Faulty Majority</title>
		<author>
			<persName><forename type="first">Donald</forename><surname>Beaver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shafi</forename><surname>Goldwasser</surname></persName>
		</author>
		<idno>CRYPTO. 589-590</idno>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">2011. 1/p-Secure Multiparty Computation without Honest Majority and the Best of Both Worlds</title>
		<author>
			<persName><forename type="first">Amos</forename><surname>Beimel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yehuda</forename><surname>Lindell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eran</forename><surname>Omri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ilan</forename><surname>Orlov</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="277" to="296" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A Fair Protocol for Signing Contracts (Extended Abstract)</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Ben-Or</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oded</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Silvio</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ronald</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP</title>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="43" to="52" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Cryptocurrencies without proof of work</title>
		<author>
			<persName><forename type="first">Iddo</forename><surname>Bentov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ariel</forename><surname>Gabizon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alex</forename><surname>Mizrahi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Financial Cryptography and Data Security</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="142" to="157" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">How to Use Bitcoin to Design Fair Protocols</title>
		<author>
			<persName><forename type="first">Iddo</forename><surname>Bentov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ranjit</forename><surname>Kumaresan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="421" to="439" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moni</forename><surname>Naor</surname></persName>
		</author>
		<title level="m">Timed Commitments. In CRYPTO</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="236" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">On Extractability Obfuscation</title>
		<author>
			<persName><forename type="first">Elette</forename><surname>Boyle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kai-Min</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rafael</forename><surname>Pass</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="52" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Optimistic Fair Secure Computation</title>
		<author>
			<persName><forename type="first">Christian</forename><surname>Cachin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2000-01">Jan Camenisch. 2000</date>
			<biblScope unit="page" from="93" to="111" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Universally Composable Security with Global Setup</title>
		<author>
			<persName><forename type="first">Ran</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yevgeniy</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rafael</forename><surname>Pass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shabsi</forename><surname>Walfish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theory of Cryptography, 4th Theory of Cryptography Conference, TCC 2007</title>
		<meeting><address><addrLine>Amsterdam, The Netherlands</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-02-21">2007. February 21-24, 2007</date>
			<biblScope unit="page" from="61" to="85" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Practical UC security with a Global Random Oracle</title>
		<author>
			<persName><forename type="first">Ran</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Abhishek</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alessandra</forename><surname>Scafuro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security</title>
		<meeting>the 2014 ACM SIGSAC Conference on Computer and Communications Security<address><addrLine>Scottsdale, AZ, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-11-03">2014. November 3-7, 2014</date>
			<biblScope unit="page" from="597" to="608" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Universally composable two-party and multi-party secure computation</title>
		<author>
			<persName><forename type="first">Ran</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yehuda</forename><surname>Lindell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rafail</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amit</forename><surname>Sahai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings on 34th Annual ACM Symposium on Theory of Computing</title>
		<meeting>on 34th Annual ACM Symposium on Theory of Computing<address><addrLine>Montréal, Québec, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-05-19">2002. May 19-21, 2002</date>
			<biblScope unit="page" from="494" to="503" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Concurrent Signatures</title>
		<author>
			<persName><forename type="first">Liqun</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Caroline</forename><surname>Kudla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kenneth</forename><forename type="middle">G</forename><surname>Paterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="287" to="305" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Limits on the Security of Coin Flips when Half the Processors Are Faulty (Extended Abstract)</title>
		<author>
			<persName><forename type="first">Richard</forename><surname>Cleve</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="364" to="369" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Practical Multilinear Maps over the Integers</title>
		<author>
			<persName><forename type="first">Jean-Sébastien</forename><surname>Coron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tancrède</forename><surname>Lepoint</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mehdi</forename><surname>Tibouchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="476" to="493" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">New Multilinear Maps Over the Integers</title>
		<author>
			<persName><forename type="first">Jean-Sébastien</forename><surname>Coron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tancrède</forename><surname>Lepoint</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mehdi</forename><surname>Tibouchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="267" to="286" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A Practical Public Key Cryptosystem Provably Secure Against Adaptive Chosen Ciphertext Attack</title>
		<author>
			<persName><forename type="first">Ronald</forename><surname>Cramer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Shoup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO &apos;98, 18th Annual International Cryptology Conference</title>
		<meeting><address><addrLine>Santa Barbara, California, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998-08-23">1998. August 23-27, 1998</date>
			<biblScope unit="page" from="13" to="25" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Practical Covertly Secure MPC for Dishonest Majority -or: Breaking the SPDZ Limits</title>
		<author>
			<persName><forename type="first">Ivan</forename><surname>Damgard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marcel</forename><surname>Keller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Enrique</forename><surname>Larraia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Valerio Pastro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nigel</forename><forename type="middle">P</forename><surname>Scholl</surname></persName>
		</author>
		<author>
			<persName><surname>Smart</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2012/642" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2012">2012. 2012/642. 2012</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Optimistic Fair Exchange in a Multi-user Setting</title>
		<author>
			<persName><forename type="first">Yevgeniy</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pil Joong</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dae</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Hyun</forename><surname>Yum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Public Key Cryptography -PKC 2007, 10th International Conference on Practice and Theory in Public-Key Cryptography, Beijing</title>
		<meeting><address><addrLine>China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-04-16">2007. April 16-20, 2007</date>
			<biblScope unit="page" from="118" to="133" />
		</imprint>
	</monogr>
	<note>Proceedings</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A Randomized Protocol for Signing Contracts</title>
		<author>
			<persName><forename type="first">Shimon</forename><surname>Even</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oded</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Abraham</forename><surname>Lempel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="637" to="647" />
			<date type="published" when="1985">1985. 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Timed Release of Standard Digital Signatures</title>
		<author>
			<persName><forename type="first">Juan</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><surname>Jakobsson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Financial Cryptography</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="168" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Abuse-Free Optimistic Contract Signing</title>
		<author>
			<persName><forename type="first">Juan</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><surname>Jakobsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philip</forename><forename type="middle">D</forename><surname>Mackenzie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="449" to="466" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Resource Fairness and Composability of Cryptographic Protocols</title>
		<author>
			<persName><forename type="first">Juan</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philip</forename><forename type="middle">D</forename><surname>Mackenzie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manoj</forename><surname>Prabhakaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ke</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="404" to="428" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Timed Fair Exchange of Standard Signatures: [Extended Abstract]</title>
		<author>
			<persName><forename type="first">Juan</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carl</forename><surname>Pomerance</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Financial Cryptography, 7th International Conference, FC 2003</title>
		<meeting><address><addrLine>Guadeloupe, French West Indies</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-01-27">2003. January 27-30, 2003</date>
			<biblScope unit="page" from="190" to="207" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Candidate Multilinear Maps from Ideal Lattices</title>
		<author>
			<persName><forename type="first">Sanjam</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Craig</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shai</forename><surname>Halevi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<author>
			<persName><forename type="first">Sanjam</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Craig</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amit</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2013/258" />
		<title level="m">Witness Encryption and its Applications. Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2013">2013. 2013. 2013</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Graph-Induced Multilinear Maps from Lattices</title>
		<author>
			<persName><forename type="first">Craig</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sergey</forename><surname>Gorbunov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shai</forename><surname>Halevi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC, Part II</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="498" to="527" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Witness Encryption from Instance Independent Assumptions</title>
		<author>
			<persName><forename type="first">Craig</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Allison</forename><forename type="middle">B</forename><surname>Lewko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brent</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="426" to="443" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">How to Construct Constant-Round Zero-Knowledge Proof Systems for NP</title>
		<author>
			<persName><forename type="first">Oded</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ariel</forename><surname>Kahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Cryptology</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="167" to="190" />
			<date type="published" when="1996">1996. 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">How to play any mental game</title>
		<author>
			<persName><forename type="first">Oded</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Silvio</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Avi</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Fair Computation of General Functions in Presence of Immoral Majority</title>
		<author>
			<persName><forename type="first">Shafi</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><forename type="middle">A</forename><surname>Levin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="77" to="93" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Invariant Signatures and Non-Interactive Zero-Knowledge Proofs are Equivalent (Extended Abstract)</title>
		<author>
			<persName><forename type="first">Shafi</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rafail</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="228" to="245" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">On Fairness in Secure Computation</title>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Dov</forename><surname>Gordon</surname></persName>
		</author>
		<ptr target="https://www.cs.umd.edu/~jkatz/THESES/gordon.pdf" />
		<imprint>
			<date type="published" when="2010">2010. 2010</date>
		</imprint>
	</monogr>
	<note>Ph.D. Dissertation.</note>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Complete fairness in secure two-party computation</title>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Dov</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carmit</forename><surname>Hazay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yehuda</forename><surname>Lindell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="413" to="422" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">On Complete Primitives for Fairness</title>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Dov</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuval</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tal</forename><surname>Moran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rafail</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amit</forename><surname>Sahai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="91" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Complete Fairness in Multi-party Computation without an Honest Majority</title>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Dov</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theory of Cryptography, 6th Theory of Cryptography Conference</title>
		<meeting><address><addrLine>San Francisco, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-03-15">2009. March 15-17, 2009</date>
			<biblScope unit="page" from="19" to="35" />
		</imprint>
	</monogr>
	<note>TCC 2009</note>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Partial Fairness in Secure Two-Party Computation</title>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Dov</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="157" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title level="m" type="main">Ouroboros: A Provably Secure Proof-of-Stake Blockchain Protocol</title>
		<author>
			<persName><forename type="first">Aggelos</forename><surname>Kiayias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Russell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernardo</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roman</forename><surname>Oliynykov</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page">17</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Impossibility Results for Universal Composability in Public-Key Models and with Fixed Inputs</title>
		<author>
			<persName><forename type="first">Dafna</forename><surname>Kidron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yehuda</forename><surname>Lindell</surname></persName>
		</author>
		<idno type="DOI">10.1007/s00145-010-9069-7</idno>
		<ptr target="https://doi.org/10.1007/s00145-010-9069-7" />
	</analytic>
	<monogr>
		<title level="j">J. Cryptology</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="517" to="544" />
			<date type="published" when="2011">2011. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Efficiently Making Secure Two-Party Computation Fair</title>
		<author>
			<persName><forename type="first">Handan</forename><surname>Kilinç</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alptekin</forename><surname>Küpçü</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-662-54970-4_11</idno>
		<ptr target="https://doi.org/10.1007/978-3-662-54970-4_11" />
	</analytic>
	<monogr>
		<title level="m">Financial Cryptography and Data Security -20th International Conference</title>
		<meeting><address><addrLine>Christ Church, Barbados</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-02-22">2016. 2016. February 22-26, 2016</date>
			<biblScope unit="page" from="188" to="207" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Amortizing Secure Computation with Penalties</title>
		<author>
			<persName><forename type="first">Ranjit</forename><surname>Kumaresan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iddo</forename><surname>Bentov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="418" to="429" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">How to Use Bitcoin to Play Decentralized Poker</title>
		<author>
			<persName><forename type="first">Ranjit</forename><surname>Kumaresan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tal</forename><surname>Moran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iddo</forename><surname>Bentov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="195" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Usable Optimistic Fair Exchange</title>
		<author>
			<persName><forename type="first">Alptekin</forename><surname>Küpçü</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anna</forename><surname>Lysyanskaya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CT-RSA</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="252" to="267" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Legally Enforceable Fairness in Secure Two-Party Communication</title>
		<author>
			<persName><forename type="first">Yehuda</forename><surname>Lindell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Chicago J. Theor. Comput. Sci</title>
		<imprint>
			<date type="published" when="2009">2009. 2009. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Unique Signatures and Verifiable Random Functions from the DH-DDH Separation</title>
		<author>
			<persName><forename type="first">Anna</forename><surname>Lysyanskaya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="597" to="612" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Simple and fast optimistic protocols for fair electronic exchange</title>
		<author>
			<persName><forename type="first">Silvio</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODC</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="12" to="19" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Formal Abstractions for Attested Execution Secure Processors</title>
		<author>
			<persName><forename type="first">Rafael</forename><surname>Pass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Elaine</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Florian</forename><surname>Tramèr</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2016/1027" />
	</analytic>
	<monogr>
		<title level="m">IACR Cryptology ePrint Archive 2016</title>
		<imprint>
			<date type="published" when="2016">2016. 2016</date>
			<biblScope unit="page">1027</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Formal Abstractions for Attested Execution Secure Processors</title>
		<author>
			<persName><forename type="first">Rafael</forename><surname>Pass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Elaine</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Florian</forename><surname>Tramèr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="260" to="289" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Fair Secure Two-Party Computation</title>
		<author>
			<persName><forename type="first">Benny</forename><surname>Pinkas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="87" to="105" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Verifiable Secret Sharing and Multiparty Protocols with Honest Majority (Extended Abstract)</title>
		<author>
			<persName><forename type="first">Tal</forename><surname>Rabin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Ben-Or</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="73" to="85" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Protocols for Secure Computations (Extended Abstract)</title>
		<author>
			<persName><forename type="first">Chi-Chih</forename><surname>Andrew</surname></persName>
		</author>
		<author>
			<persName><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="160" to="164" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
