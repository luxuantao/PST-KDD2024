<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Syntax for Free: Representing Syntax with Binding Using Parametricity</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Robert</forename><surname>Atkey</surname></persName>
							<email>bob.atkey@ed.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="department">School of Informatics</orgName>
								<orgName type="institution">University of Edinburgh</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Syntax for Free: Representing Syntax with Binding Using Parametricity</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">DD0B0C653B4007C89774B35901D7F487</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:32+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We show that, in a parametric model of polymorphism, the type ∀α.((α → α) → α) → (α → α → α) → α is isomorphic to closed de Bruijn terms. That is, the type of closed higher-order abstract syntax terms is isomorphic to a concrete representation. To demonstrate the proof we have constructed a model of parametric polymorphism inside the Coq proof assistant. The proof of the theorem requires parametricity over Kripke relations. We also investigate some variants of this representation.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Representing, computing with, and reasoning about syntax with binding has been of interest to computer scientists for the last 30 or 40 years. The crucial point that makes these activities difficult is the notion of α-equivalence, the obvious idea that if we have two terms equal up to the swapping of the names of their bound variables, e.g. λx.x and λy.y, then the terms should be treated equally. Unfortunately, the obvious representation of binders as a pair of a variable name and a subterm does not respect α-equivalence, so operations on such data must be carefully written in order to respect it.</p><p>In this paper, we look at two solutions that have been put forward to deal with this (we do not look at the third major approach: nominal sets <ref type="bibr" target="#b6">[7]</ref>): de Bruijn indicies and higher-order abstract syntax, and relate the two.</p><p>The de Bruijn index approach <ref type="bibr" target="#b4">[5]</ref>, approaches the problem by removing the names of bound variables altogether. Bound variables are represented by pointers to the construct that binds them. For instance, the λ-term λx.λy.xy is represented as λ.λ.1 0. The bound variable x has been replaced by a pointer to the binder one step away from the occurrence, and the bound variable y has been replaced by a binder zero steps away. The advantage of this representation is that α-equivalent terms are now structurally equal. The disadvantage is the complicated definitions of common operations such as substitution, where non-intuitive shifting operations are required to maintain the correct pointers.</p><p>Another common approach is to use higher-order abstract syntax <ref type="bibr" target="#b12">[13]</ref>. In this approach, we use the binding structure of the meta-language to represent binding in the object-language. For the untyped λ-calculus, we suppose that there is a type tm and operations lam : (tm → tm) → tm and app : tm → tm → tm.</p><p>The object-level term λx.λy.xy is thus represented as the meta-language term lam (λx. lam (λy. app x y)). The key advantage of this approach is that, since object-level variables are represented using meta-level variables, substitution becomes very easy to define. A disadvantage of this representation is the need to make sure that we do not allow too many terms into our type tm. Proving that we have not done so is called adequacy <ref type="bibr" target="#b7">[8]</ref>, and is usually performed by reasoning on the canonical forms of some weak type theory such as LF.</p><p>The key to higher-order abstract syntax is that the meta-level variables that are used to represent object-level variables are only used as variables, and cannot be further analysed. Washburn and Weirich <ref type="bibr" target="#b17">[18]</ref> noted that parametric type abstraction, as available in System F, is a viable way of ensuring that represented terms are well behaved. They consider the type</p><formula xml:id="formula_0">∀α.((α → α) → α) → (α → α → α) → α</formula><p>and derive a fold operator and some reasoning principles from it. This type captures the two operations of higher-order abstract syntax, the lam and the app, but abstracts over the carrier type. Washburn and Weirich claim that this type represents exactly the terms of the untyped λ-calculus, but do not provide a proof. Coquand and Huet <ref type="bibr" target="#b3">[4]</ref> also state that this type represents untyped lambda terms, also without proof. In this paper we provide such a proof.</p><p>The reason that this approach works is that System F terms of type ∀α.τ must act parametrically in α, that is, they cannot reflect on what actual instantiation of α they have been provided with. Reynolds <ref type="bibr" target="#b15">[16]</ref> formalised this idea by stating that for any two instantiations of α, parametric terms must preserve all relations between them.</p><p>We take this idea, and extend it to use Kripke relations <ref type="bibr" target="#b14">[15]</ref>. Kripke relations are relations R indexed by some preorder W , such that if w ≤ w in W , then Rwxy implies Rw xy. By requiring that all terms of polymorphic type preserve all Kripke logical relations, we can prove that the denotation of the type given by Washburn and Weirich is isomorphic to the type of closed de Bruijn terms: de Bruijn terms that do not have dangling pointers. The preorder-indexing of the relations is used to handle the expansion of the number of meta-variables being used as object-variables as we go under binders.</p><p>Traditionally, parametric models of System F have been hard to come by, and have generally involved fiddly constructions with PERs. We make life easier for ourselves by starting with a meta-theory 1 that already has impredicative polymorphism and construct a parametric model of System F inside it. We use a version of Coq with impredicative polymorphism for this purpose, and we have formalised most of our results here 2 . isomorphism between the Washburn-Weirich HOAS type and de Bruijn terms. In Section 4 we investigate two alternative representations that take different views on how variables are represented. In Section 5, we show how the computational aspect of System F can be integrated into our object-level representations, and prove that a simplified version of the Haskell ST monad can be represented using de Bruijn-style terms. Finally, Section 6 concludes with a discussion of related work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">A Model of Parametric Polymorphism</head><p>To state and prove our main results, we construct, inside the Coq proof assistant, a denotational model of System F that supports parametricity. For simplicity, we want to let System F types be denoted by objects of sort Set; we can then express denotations of terms as normal Coq functions that preserve all Kripke relations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Preparing the Meta-theory</head><p>In order to use Sets as denotations of System F types, we require impredicativity. The denotation of the type ∀α.τ quantifies over all denotations of types (i.e. Sets). By default, Coq's type theory is predicative for Set (although it is impredicative in the type of propositions, Prop), so one cannot construct a new object of sort Set by quantifying over all objects of sort Set. Fortunately, Coq supports a command line option -impredicative-set that allows us to proceed.</p><p>We also require three axioms to be added to Coq's theory. The first of these is proof irrelevance, which states that all proofs of a given proposition are equal:</p><formula xml:id="formula_1">∀P : Prop. ∀p 1 , p 2 : P. p 1 = p 2 .</formula><p>We also require extensionality for functions, which states that two functions are equal if they are equal for all inputs: ∀A : Type, B : A → Type, f, g : (∀a.Ba). (∀x. f x = gx) → f = g Extensionality for functions allows our denotational model to support the ηequality rules of System F. We also require propositional extensionality, which will allow us to treat equivalent propositions as equal:</p><formula xml:id="formula_2">∀P, Q : Prop, (P ↔ Q) → P = Q</formula><p>These axioms allow us to define data with embedded proofs that are equal if their computational contents are equal, which will aid us in proving equalities between denotations of System F types.</p><p>We informally justify our use of these axioms, plus impredicativity, by the existence of models of CIC in intuitionistic set theory. In the remainder of the paper, we use informal set theoretic notation and do not explicitly highlight the uses of these axioms. Note that everywhere we use the word "set", we are referring to Coq objects of sort Set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Denotational Semantics of System F</head><p>The syntax of System F types is standard:</p><formula xml:id="formula_3">τ ::= α | τ 1 → τ 2 | ∀α.τ</formula><p>where α is taken from a countably infinite set of variables, and ∀α.τ binds α in τ . We actually use a de Bruijn representation of types (and terms) of System F in our Coq development, but we will use the usual concrete representation for exposition.</p><p>As we mentioned in the introduction, in order to prove the isomorphisms below involving syntax with binding, we require that the denotation of ∀α.τ be parametric over all Kripke relations over all preorders. Preorders consist of a carrier W : Type and a binary relation ≤ W : W → W → Prop that is reflexive and transitive. For a given preorder W , a W -Kripke logical relation over sets</p><formula xml:id="formula_4">A, B : Set is a predicate R : W → A → B → Prop, such that ∀w, w , a, b. w ≤ W w → Rwab → Rw ab.</formula><p>For brevity, we write the collection of all W -Kripke relations over A, B as KRel(W, A, B). Note that, even though we are using W -indexed Kripke relations, we do not use sets indexed by any particular W as denotations of System F types-we are not constructing a model of System F in the presheaf category for some preorder W . We will require multiple instantiations of W in our proofs.</p><p>Type environments γ are mappings from type variables to sets. For a preorder W and a pair of type environments γ 1 , γ 2 , a relation environment ρ is a mapping from type variables α to W -Kripke relations over γ 1 (α), γ 2 (α). For any type environment γ and preorder W , there is a relation environment Δ W γ that maps all type variables to the equality relation.</p><p>We now define the denotations of types and the induced Kripke relations between them. The mapping Tmaps types with type environments to sets and the mapping Rmaps types τ , preorders W and relation environments over type environments γ 1 , γ 2 to W -Kripke relations over T τ γ 1 , T τ γ 2 . These mappings are mutually defined over the structure of types:</p><formula xml:id="formula_5">T α γ = γ(α) T τ 1 → τ 2 γ = T τ 1 γ → T τ 2 γ T ∀α.τ γ = { x : ∀A : Set. T τ (γ[α → A]) | ∀W, A 1 , A 2 , R : KRel(W, A 1 , A 2 ), w : W. R τ W (Δ W γ [α → R]) w (x A 1 ) (x A 2 ) } R α W ρ w x y = ρ(α) w x y R τ 1 → τ 2 W ρ w f g = ∀w : W, x : T τ 1 γ 1 , y : T τ 1 γ 1 . w ≤ W w → R τ 1 W ρ w x y → R τ 2 W ρ w (f x) (gy) R ∀α.τ W ρ w x y = ∀A 1 , A 2 , R : KRel(W, A 1 , A 2 ). R τ W (ρ[α → R]) w (x A 1 ) (y A 2 )</formula><p>These clauses are mostly straightforward for Kripke logical relations, but we draw the reader's attention to the clause for T ∀α.τ . We have used impredicative quantification over all sets here. We also constrain the denotations of polymorphic types to be those that preserve all W -Kripke relations, for all preorders W . It is this parametricity property that we will use to prove the isomorphisms in Section 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 1.</head><p>The following hold, for all τ and preorders W :</p><formula xml:id="formula_6">1. For all γ 1 , γ 2 and ρ, R τ W ρ is a W -Kripke relation over T τ γ 1 , T τ γ 2 .</formula><p>2. For all γ and w, R τ W Δ W γ w x y iff x = y. Proof. Both by induction over the structure of τ .</p><p>Note that this denotational semantics of types validates the usual representations of inductive types in System F, e.g.</p><formula xml:id="formula_7">T ∀α.α → (α → α) → α γ ∼ = N etc.</formula><p>Denotations of System F terms. We also define a denotation for every well-typed System F term, but we have elided these for lack of space. Please see the formal development for more details. The main result is that every well-typed System F term has a meaning in the model as a function from the denotation of the context to the denotation of the result type, such that all Kripke relations over any preorder are preserved by this function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Representing λ-Terms Using Parametricity</head><p>We will show that, in our model, the denotation of the type</p><formula xml:id="formula_8">τ H = ∀α.((α → α) → α) → (α → α → α) → α</formula><p>is isomorphic to the set of closed de Bruijn terms. This task is not so straightforward as producing two functions and showing that they are mutually inverse: we must show that the function from the above type to de Bruijn terms actually does give a well-formed closed de Bruijn term.</p><p>We define the set of well-formed de Bruijn terms as a natural number-indexed inductively defined set Term : N → Set with constructors:</p><formula xml:id="formula_9">Var : {i : N | i &lt; n} → Term(n) Lam : Term(n + 1) → Term(n) App : Term(n) → Term(n) → Term(n)</formula><p>The set of all closed de Bruijn terms is hence given by Term(0). This definition admits the following recursion principle<ref type="foot" target="#foot_0">3</ref> : term rec : ∀P : N → Set.</p><p>(∀n.{i :</p><formula xml:id="formula_10">N | i &lt; n} → P (n)) → (∀n.P (n + 1) → P (n)) → (∀n.P (n) → P (n) → P (n)) → ∀n.Term(n) → P (n)</formula><p>We will also need the set of "pre-de Bruijn" terms-terms that are not necessarily known to be well-formed-as an intermediate staging ground. The set preTerm is defined inductively with the following constructors:</p><formula xml:id="formula_11">preVar : N → preTerm preLam : preTerm → preTerm preApp : preTerm → preTerm → preTerm</formula><p>There is an obvious relation n t relating context sizes to preTerms well-formed in that context, and an isomorphism between Term(n) and {t : preTerm | n t}. Note that the type preTerm is a normal inductive type and is therefore representable in parametric System F. The mapping from τ H to preTerm that we give is also expressible in pure System F.</p><p>We are now ready to define this mapping from denotations of the type τ H to Term(0). We do this first by mapping to preTerm and then showing that the produced term satisfies 0 t. By the definition of T τ H , the underlying set for this type is ∀A :</p><formula xml:id="formula_12">Set.((A → A) → A) → (A → A → A) → A.</formula><p>We define φ(t) = t (N → preTerm) lam app 0, where:</p><formula xml:id="formula_13">lam = λf.λi.preLam (f (λj.preVar (j -(i + 1))) (i + 1)) app = λx.λy.λi.preApp (x i) (y i)</formula><p>We instantiate a value of type τ H with the set N → preTerm, intending that applying a function of this type to a number n will produce a term well-formed in the context of size n. Inside the definition of these functions, the argument represents the depth of context (or the number of binders) surrounding the current term. In the case for app, we do not go under a binder, so we do not increase the depth when applying it to the sub-terms. In the case for lam, given a function f of type (N → preTerm) → (N → preTerm), and a depth i, we apply f to an argument that will evaluate to a bound variable for a future depth j. The arithmetic computes the distance between the bound variable and its binder. Crucially, it is always the case that j &gt; i, since we only ever count upwards in the depth of terms. This is the meat of the following: Lemma 2. For all t : T τ H γ, 0 φ(t).</p><p>Proof. We use the parametricity of the denotation of τ H . Unfolding the definition of R τ H , this tells us that the following property holds of all t : T τ H γ:</p><formula xml:id="formula_14">∀W, A 1 , A 2 , R : KRel(W, A 1 , A 2 ), w : W. (∀w 1 ≥ w, lam 1 : (A 1 → A 1 ) → A 1 , lam 2 : (A 2 → A 2 ) → A 2 . (∀w 2 ≥ w 1 , f 1 : A 1 → A 1 , f 2 : A 2 → A 2 . (∀w 3 ≥ w 2 , x : A 1 , y : A 2 .R w 3 x y → R w 3 (f 1 x) (f 2 y)) → R w 2 (lam 1 f 1 ) (lam 2 f 2 )) → (∀w 4 ≥ w 1 , app 1 : A 1 → A 1 → A 1 , app 2 : A 2 → A 2 → A 2 . (∀w 5 ≥ w 4 , x 1 : A 1 , x 2 : A 2 .R w 5 x 1 x 2 → (∀w 6 ≥ w 5 , y 1 : A 1 , y 2 : A 2 .R w 6 y 1 y 2 → R w 6 (app 1 x 1 y 1 ) (app 2 x 2 y 2 ))) → R w 4 (t A 1 lam 1 app 1 ) (t A 2 lam 2 app 2 )))</formula><p>We let W be N with the usual ordering. We will not need to use both type arguments for this proof, so we set A 1 = N → preTerm and A 2 = 1, the one element set (we use dummy implementations of lam and app for this type). We set R n x y iff ∀n ≥ n.n x(n ). It is easy to verify that this is a Kripke relation. This relation will suffice to prove our lemma, provided we can prove that our implementations of lam and app in the definition of φ satisfy the requirements of t's parametricity property.</p><p>For lam, we must prove that at all depths n ≥ 0, if we are given a functional argument f : (N → preTerm) → (N → preTerm) satisfying the property at all n ≥ n, then for all n ≥ n, we have</p><formula xml:id="formula_15">n preLam (f (λj.preVar (j -(n + 1))) (n + 1))</formula><p>This is true if</p><formula xml:id="formula_16">n + 1 f (λj.preVar (j -(n + 1))) (n + 1)</formula><p>Since f preserves R, we need only show that the argument λj.preVar (j -(n +1)) satisfies R at all n ≥ n + 1. This amounts to showing that</p><formula xml:id="formula_17">n preVar(n -(n + 1))</formula><p>which is trivial.</p><p>The case for app is easier and is a straightforward application of the required property being satisfied by the two arguments.</p><p>This proof is very similar to the Kripke logical relations proof employed by Rhiger <ref type="bibr" target="#b16">[17]</ref> to prove that a single language embedded using higher-order abstract syntax always gives well-formed terms. We have extended this by allowing multiple languages to be embedded in a single meta-language. Rhiger also considers the use of type constructors to embed typed languages, something we cannot do in our System F setting. We also note that the proofs here are very similar in structure to the proofs used for proving adequacy of higher-order syntax encodings in LF <ref type="bibr" target="#b7">[8]</ref>.</p><p>Corollary 1. The map φ can be seen as a map from T τ H γ to Term(0).</p><p>The map φ -1 from closed de Bruijn terms is defined by recursion over the structure of terms. We make use of an auxiliary data structure of vectors vec A n, representing lists of elements of type A : Set of length n. These have two constructors:</p><formula xml:id="formula_18">vecNil : vec A 0 vecCons : A → vec A n → vec A (n + 1)</formula><p>and a look-up function lookup : vec A n → {i :</p><formula xml:id="formula_19">N | i &lt; n} → A.</formula><p>The mapping φ -1 : Term(0) → T τ H γ is defined as: The basic idea is to recurse down the term, maintaining a vector of representations of bound variables. Every time we go under a binder, we extend the vector by the object provided by the implementation of lam. For this mapping to be well-defined, we must prove the following:</p><formula xml:id="formula_20">φ -1 (t)</formula><p>Lemma 3. For all t : Term(0), φ -1 (t) is parametric.</p><p>Proof. We must prove, essentially, that for any preorder W , pair of sets A 1 , A 2 and W -Kripke relation R over A 1 , A 2 , then if lam 1 , lam 2 and app 1 , app 2 are related pairs of functions, then the bodies of φ -1 are related by R at some index w. We strengthen the statement from talking about terms in Term(0) with empty starting environments to: for all n and t :</p><formula xml:id="formula_21">Term(n), v 1 : vec A 1 n, v 2 : vec A 2 n and w ≥ w, ∀i : {i : N | i &lt; n}, w ≥ w . R w (lookup v 1 i) (lookup v 2 i) implies R w (term rec ... t v 1 ) (term rec ... t v 2 )</formula><p>. This is easily proved by induction on t, and implies the lemma statement.</p><p>We now prove that our two mappings are mutually inverse. We first do the direction that does not require parametricity:</p><p>Lemma 4. For all t : Term(0), φ(φ -1 (t)) = t.</p><p>Proof. As with the previous proof, we strengthen the statement to prove that for all n, t : Term(n) and v : vec</p><formula xml:id="formula_22">(N → preTerm) n, ∀i ≤ n, n . n ≤ n → (lookup v i) n = Var(i + (n -n ))</formula><p>implies term rec ... t v n = t. This is easily proved by induction on t, and implies the lemma statement.</p><p>The other direction requires the use of parametricity:</p><p>Lemma 5. For all t : T τ H , φ -1 (φ(t) = t.</p><p>Proof. We are given a set A and operations lam and app. We apply the parametricity property of t (as given in the proof of Lemma 2) with the following data. The preorder W consists of lists of elements of A with the prefix ordering.</p><p>The set A 1 is set to N → preTerm, and A 2 is set to A. We set the relation R to be R env x y iff:</p><formula xml:id="formula_23">∀env env . term rec ... (x (length env )) (toVec env ) = y</formula><p>where length gives the length of a list, and toVec maps lists l of As to a value of type vec A (length l). It is easy to prove that is is a Kripke relation. The proof then proceeds in a very similar way to the proof of Lemma 2.</p><p>Summing up, we have:</p><formula xml:id="formula_24">Theorem 1. Term(0) ∼ = T τ H γ.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Alternative Representations of Variables</head><p>Washburn and Weirich <ref type="bibr" target="#b17">[18]</ref> also consider terms with a fixed maximum number of free variables by using types of the form:</p><formula xml:id="formula_25">τ n H = ∀α.((α → α) → α) → (α → α → α) → α n</formula><p>where α 0 = α and α n+1 = α → α n . By extending the proof in the previous section, we have been able to prove T τ n H γ ∼ = Term(n) for various n, but unfortunately we have not been able to formally prove this for all n.</p><p>Washburn and Weirich further claim ( <ref type="bibr" target="#b17">[18]</ref>, in the definition of iterList) that the type ∀α.</p><formula xml:id="formula_26">((α → α) → α) → (α → α → α) → [α] → α</formula><p>represents terms with arbitrary numbers of free variables, where [α] is shorthand for lists of α. However, it is easy to see that this is not the case. Consider the following inhabitant of this type:</p><p>Λα.λlam.λapp.λenv . match env with nil ⇒ lam(λx.x) | cons(x, t) ⇒ x (where we allow ourselves some syntactic sugar for lists in System F). This "term" represents λx.x when the free variable list is empty, and the first available free variable otherwise. This does not correspond to any single λ-term.</p><p>We now look at two other representations of variables in higher-order abstract syntax and evaluate them in the light of the techniques of Section 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Parameterised and Weak Higher-Order Abstract Syntax</head><p>In <ref type="bibr" target="#b5">[6]</ref> the authors note that the normal higher-order abstract syntax type cannot be directly translated to an inductive type in Coq due to the negative occurrence in the case for λ-abstraction. They propose weak higher-order abstract syntax, defined by an inductive type parameterised by a type of variables. We can represent this type in System F like so, using the normal encoding of inductive types:</p><formula xml:id="formula_27">τ WH (ν) = ∀α.(ν → α) → ((ν → α) → α) → (α → α → α) → α</formula><p>Choosing something obvious for ν, like natural numbers, results in inhabitants of this type that do not represent λ-terms (because they can inspect the variable names they are given). The solution is to keep the type ν abstract, so that inhabitants cannot inspect their variables. Hofmann <ref type="bibr" target="#b8">[9]</ref> analysed this construction in the setting of presheaves, using a presheaf of variables for ν.</p><p>Following on from <ref type="bibr" target="#b5">[6]</ref>, Chlipala <ref type="bibr" target="#b2">[3]</ref> noticed that, if the meta language has parametric polymorphism, then the type ∀ν.τ WH (ν) can be used to represent λ-terms, but he did not have a proof. He called this technique parameterised higher-order abstract syntax. We can supply such a proof:</p><formula xml:id="formula_28">Theorem 2. T τ H γ ∼ = T ∀ν.τ WH (ν) γ ( ∼ = Term(0)).</formula><p>Proof. Define (in System F) φ : τ H → ∀ν.τ WH (ν) and φ -1 : (∀ν.τ WH (ν)) → τ H by:</p><formula xml:id="formula_29">φ = λt.Λν.Λα.λvar .λlam.λapp. t [α] (λf. lam (λx. f (var x))) app φ -1 = λt.Λα.λlam.λapp. t [α] [α] (λx.x) lam app</formula><p>Since these functions are terms of System F, the parametricity properties automatically hold. The φ -1 (φ(t)) direction is particularly easy to prove:</p><formula xml:id="formula_30">φ -1 (Λν.Λα.λvar .λlam.λapp. t [α] (λf. lam (λx. f (var x))) app) = Λα.λlam.λapp. t [α] (λf. lam (λx. f ((λx. x) x))) app = Λα.λlam.λapp. t [α] lam app = t</formula><p>In the reverse direction we can prove φ(φ -1 (t)) = t by applying parametricity over ordinary relations (Kripke relations are not needed here). If we have sets V for ν and A for α, the key idea is to relate the A and V by Rxy iff x = var y and relate A and A by the equality relation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Locally Higher-Order Abstract Syntax</head><p>We now consider explicitly representing free variables in terms using any data type we choose, but representing bound variables using higher-order abstract syntax. This approach is inspired by locally nameless representations using de Bruijn indicies only for bound variables <ref type="bibr" target="#b0">[1]</ref>. We consider the type:</p><formula xml:id="formula_31">τ LH (ν) = ∀α.(ν → α) → ((α → α) → α) → (α → α → α) → α</formula><p>This type has three "constructors", one for injecting free variables of type ν into terms, and the two higher-order abstract syntax constructors. We are free to choose any type we like for ν, such as natural numbers or strings. Selecting naturals, we can define the following combinators:</p><formula xml:id="formula_32">var : N → τ LH (N) var = λx.Λα.λv.λl.λa. v x app : τ LH (N) → τ LH (N) → τ LH (N) app = λxy.Λα.λv.λl.λa. a x y lam : N → τ LH (N) → τ LH (N) lam = λxt.Λα.λv.λl. l (λy. t [α] (λx .if x = x then y else v x ) l a)</formula><p>The var combinator constructs a term with a single free variable, and app constructs the object-level application of two terms. The lam combinator is more complicated: for free variable x and term t, it creates a new object-level λabstraction, with the body being t with x substituted for the variable bound by the object-level λ-abstraction.</p><p>It is also possible to define a pattern matching combinator of type:</p><formula xml:id="formula_33">τ LH (N) → N + (τ LH (N) × τ LH (N)) + (τ LH (N) → τ LH (N))</formula><p>that analyses a term in our representation, and returns either a free variable, the pair of terms involved in an application, or a term abstracted over another term in the case of object-level λ-abstraction. We cannot give this term here due to lack of space: please see the OCaml files contained with the Coq development.</p><p>By using the techniques of Section 3 we can prove that this representation is actually equivalent to a representation using de Bruijn terms. We define such a representation LNTerm(A, n) inductively by the following constructors:</p><formula xml:id="formula_34">freeVar : A → LNTerm(A, n) boundVar : {i : N | i &lt; n} → LNTerm(A, n) Lam : LNTerm(A, n + 1) → LNTerm(A, n) App : LNTerm(A, n) → LNTerm(A, n) → LNTerm(A, n) Theorem 3. For closed types τ , LNTerm(T τ γ, 0) ∼ = T τ LH (τ ) γ.</formula><p>The significance of this theorem arises from the fact that we can use a language with parametric polymorphism to represent locally nameless λ-terms; a type that would normally seem to require some kind of indexed types to represent. We speculate that it would be possible to build a convenient (if inefficient) library for manipulating syntax with binders in OCaml using this representation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Mixing Computation and Representation</head><p>We now go beyond the representation of pure syntax to embed the computational power of System F in abstract syntax trees. Licata, Zeilberger and Harper <ref type="bibr" target="#b10">[11]</ref> define a system based on a proof theoretic analysis of focusing that allows for a mixing of computational and representational data. Note that the locally higherorder abstract syntax example from the previous section already demonstrates this in action: the ν → α constructor for free variables is computational in the sense that it can inspect the values it is given.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Arithmetic Expressions</head><p>Our first example is from Licata et al <ref type="bibr" target="#b10">[11]</ref>, that of the abstract syntax of arithmetic expressions with embedded "semantic" binary operations. Binding structure is introduced into the type by a "let" construct. We make the following definition, assuming some primitive type of integers int:</p><formula xml:id="formula_35">τ A = ∀α. (int → α) → ((int → int → int) → α → α → α) → (α → (α → α) → α) → α</formula><p>From the type, we have three "constructors": one to introduce integers into terms, one for terms representing binary operations, with a function expressing the actual operation to perform, and one to handle lets, using the normal higherorder abstract syntax representation for binding. We can write an evaluator for expressions in this type very easily:</p><formula xml:id="formula_36">eval(t) = t [int] (λx. x) (λf xy. f xy) (λxf. f x)</formula><p>A de Bruijn-style representation for these arithmetic expressions is given by the following constructors for an indexed type AExp : N → Set:</p><formula xml:id="formula_37">Num : int → AExp(n) Binop : (int → int → int) → AExp(n) → AExp(n) → AExp(n) Let : AExp(n) → AExp(n + 1) → AExp(n)</formula><p>Again, using the same method as Section 3 we can prove:</p><formula xml:id="formula_38">Theorem 4. AExp(0) ∼ = T τ A γ.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Encapsulated Side-Effects with Dynamic Allocation</head><p>The Haskell programming languages contains a monad called ST, that is used to represent encapsulated side-effects with dynamic allocation. A simplified version of this monad, with a single type of data stored in references σ, a type of references ρ and result type τ is given by the following data: a family of types ST τ σ ρ, with associated monadic return and bind operations, plus three operations:</p><formula xml:id="formula_39">new σρ : σ → ST ρ σ ρ upd σρ : ρ → σ → ST 1 σ ρ lkup σρ : ρ → ST σ σ ρ</formula><p>corresponding to dynamic allocation of a new memory cell, updating a memory cell and looking up the value of a memory cell. This monad has an associated function runST : ∀τ.∀σ.(∀ρ.τ ST (τ, σ, ρ)) → τ that takes a computation and runs it, producing a final result value of type τ . The intention is that the nested quantification over ρ prevents references leaking or entering from outside the computation.</p><p>Moggi and Sabry <ref type="bibr" target="#b11">[12]</ref> used operational techniques to prove the safety of the full ST monad with typed references. They represent values of the monadic type using a polymorphic type. Simplified to the System F setting with a single type for stored data, this type can be given as:</p><formula xml:id="formula_40">τ ST (τ, σ, ρ) = ∀α. (τ → α) → (σ → (ρ → α) → α) → (ρ → σ → α → α) → (ρ → (σ → α) → α) → α</formula><p>We can make this family of types into a monad with the following definitions: Using these combinators we can write programs in monadic style that issue commands to dynamically allocate new memory cells via the new operation and access them using the upd and lkup operations.</p><formula xml:id="formula_41">return τ σρ : τ → τ ST (τ,</formula><p>Moggi and Sabry note that (their version of) the type τ ST (τ, σ, ρ) almost fits the schema for the polymorphic representation of an inductive type in System F, were it not for the negative occurrence of ρ in the new "constructor". Using the techniques of Section 3, we can show that this type actually does correspond to an inductively defined type using de Bruijn representation for variables. The appropriate type is given by by the following constructors for an indexed type ST(A, S, -) : N → Set, for sets A and S.</p><formula xml:id="formula_42">Ret : A → ST(A, S, n) New : S → ST(A, S, n + 1) → ST(A, S, n) Update : {i : N | i &lt; n} → S → AExp(A, S, n) → AExp(A, S, n) Lookup : {i : N | i &lt; n} → (S → AExp(A, S, n)) → AExp(A, S, n) Theorem 5. For closed types τ and σ, ST(T τ γ, T σ γ, 0) ∼ = T ∀ρ.τ ST (τ, σ, ρ) γ.</formula><p>An obvious question now is whether this result extends to the case with typed references. Following Moggi and Sabry, we would expect that the F ω type λτ.∀ρ : * → * .∀α.</p><formula xml:id="formula_43">(τ → α) → (∀σ. σ → (ρ[σ] → α) → α) → (∀σ. ρ[σ] → σ → α → α) → (∀σ. ρ[σ] → (σ → α) → α) → α</formula><p>should have a de Bruijn-style representation similar to ST above. However, there is a problem with proceeding naively here. Consider the following program written in this monad (using Haskell's do notation):</p><p>do x ← new (λ(). return ()) upd x (λ(). do {y ← lkup x; y ()}) y ← lkup x y () which uses "Landin's knot" to represent a non-terminating computation using mutable references. However, the "obvious" de Bruijn-style type (using a context consisting of lists of types) does not admit the translation of this term.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related Work and Conclusions</head><p>Aside from the work of Washburn and Weirich <ref type="bibr" target="#b17">[18]</ref>, the closest work to ours is that of Rhiger <ref type="bibr" target="#b16">[17]</ref>, who shows that a higher-order abstract syntax encoding for a single typed object-language is sound and complete in a simply-typed metalanguage with a type constructor Exp : * → * . We have extended his work by allowing multiple embedded languages. The use of System F also allows the use of iteration constructs to access terms from the outside, as demonstrated by Washburn and Weirich. Also related is the work of Carette et al <ref type="bibr" target="#b1">[2]</ref>. They use the same method as Rhiger to embed languages inside an existing typed language (OCaml in this case). They abstract over the carrier type and actual implementations of lam and app, as we do here, but do not make the connection to concrete terms explicit.</p><p>It seems obvious, though we have not yet formally proved it, that there is a natural extension of the representation of inductive types in System F as polymorphic types ∀α.(F [α] → α) → α, where α is positive in F to ones, where we allow negative a occurrences, and the represented type is some kind of abstract syntax with binding. We leave formulating and proving a general theorem of this kind to future work, but we suspect that it will be a straightforward application of the ideas in Section 3, the key idea being the use of Kripke logical relations.</p><p>In future work we also wish to consider more powerful type theories than System F for use as the meta-language. An obvious first step is the use of System F ω , which will allow the use of type parameters to represent object languages with type systems that are subsets of the meta-language type system, although the case of the multi-typed ST monad from Section 5.2 shows that this extension may not be straightforward. Pfenning and Lee <ref type="bibr" target="#b13">[14]</ref> have considered the use of F ω as a meta language, using a form of weak higher-order abstract syntax, but did not prove the close connection between representation and syntax that we have here. A yet more powerful route may be to consider the combination of dependent types and parametric polymorphism, so that representations of logics in the same style as the Logical Framework approach maybe used, combined with powerful ways of computing with them. The work of Izumi <ref type="bibr" target="#b9">[10]</ref> on parametricity in dependent types may be useful here.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>= λA : Set.λlam.λapp. term rec (λn.vec A n → A)</figDesc><table /><note><p>(λn, i, env . lookup env i) (λn, h, env . lam (λx. h (vecCons x env ))) (λn, x, y, env . app (x env ) (y env )) 0 t vecNil</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>σ, ρ)return τ σρ = λx.Λα.λret new upd lkup. ret x bind τ1τ2σρ : τ ST (τ 1 , σ, ρ) → (τ 1 → τ ST (τ 2 , σ, ρ)) → τ ST (τ 2 , σ, ρ)Note that, unlike Moggi and Sabry, we have not included a "constructor" in our type to represent bind , it can already be defined from the ret "constructor". We define the operations of the monad like so:new σρ =λs.Λα.λret new upd lkup. new s (λr. ret r) upd ρ = λrs.Λα.λret new upd lkup. upd r s (ret * ) lkup σρ = λr.Λα.λret new upd lkup. lkup r (λs. ret s)</figDesc><table><row><cell>bind τ1τ2σρ = λcf.Λα.λret new upd lkup. c[α](λx. f x[α]ret new upd lkup)</cell></row><row><cell>new upd lkup</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>This is less general than the one Coq provides, but suffices for our purposes.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements. Thanks to Randy Pollack, Sam Staton and Jeremy Yallop for comments on this work. This work was funded by the ReQueST grant (EP/C537068) from the Engineering and Physical Sciences Research Council.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Engineering formal metatheory</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">E</forename><surname>Aydemir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Charguéraud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pollack</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Weirich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<editor>
			<persName><forename type="first">G</forename><forename type="middle">C</forename><surname>Necula</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Wadler</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="3" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Finally tagless, partially evaluated</title>
		<author>
			<persName><forename type="first">J</forename><surname>Carette</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Kiselyov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-C</forename><surname>Shan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">APLAS 2007</title>
		<editor>
			<persName><forename type="first">Z</forename><surname>Shao</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4807</biblScope>
			<biblScope unit="page" from="222" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Parametric higher-order abstract syntax for mechanized semantics</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Chlipala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICFP</title>
		<imprint>
			<biblScope unit="page" from="143" to="156" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Constructions: A higher order proof system for mechanizing mathematics</title>
		<author>
			<persName><forename type="first">T</forename><surname>Coquand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Huet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCAL 1985</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Buchberger</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1985">1985</date>
			<biblScope unit="volume">203</biblScope>
			<biblScope unit="page" from="151" to="184" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Lambda-calculus notation with nameless dummies: a tool for automatic formula manipulation with application to the Church-Rosser theorem</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">G</forename><surname>De Bruijn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Indag. Math</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page" from="381" to="392" />
			<date type="published" when="1972">1972</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Higher-Order Abstract Syntax in Coq</title>
		<author>
			<persName><forename type="first">J</forename><surname>Despeyroux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Felty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hirschowitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TLCA 1995</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Dezani-Ciancaglini</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Plotkin</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">902</biblScope>
			<biblScope unit="page" from="124" to="138" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A New Approach to Abstract Syntax Involving Binders</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gabbay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Pitts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LICS</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="214" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Mechanizing metatheory in a logical framework</title>
		<author>
			<persName><forename type="first">R</forename><surname>Harper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Licata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Funct. Program</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">4-5</biblScope>
			<biblScope unit="page" from="613" to="673" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Semantical Analysis of Higher-Order Abstract Syntax</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hofmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LICS</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="204" to="213" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The Theory of Parametricity in Lambda Cube</title>
		<author>
			<persName><forename type="first">T</forename><surname>Izumi</surname></persName>
		</author>
		<idno>1217</idno>
	</analytic>
	<monogr>
		<title level="j">RIMS Kokyuroku</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Focusing on Binding and Computation</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Licata</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Zeilberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Harper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LICS</title>
		<meeting><address><addrLine>Los Alamitos</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="241" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Monadic encapsulation of effects: a revised approach (extended version)</title>
		<author>
			<persName><forename type="first">E</forename><surname>Moggi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sabry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Funct. Program</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="591" to="627" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Higher-Order Abstract Syntax</title>
		<author>
			<persName><forename type="first">F</forename><surname>Pfenning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Elliott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLDI</title>
		<imprint>
			<biblScope unit="page" from="199" to="208" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Metacircularity in the polymorphic λ-calculus</title>
		<author>
			<persName><forename type="first">F</forename><surname>Pfenning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">89</biblScope>
			<biblScope unit="page" from="137" to="159" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Lambda-Definability in the Full Type Hierarchy</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Plotkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">To H. B. Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Seldin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Hindley</surname></persName>
		</editor>
		<meeting><address><addrLine>London</addrLine></address></meeting>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1980">1980</date>
			<biblScope unit="page" from="363" to="373" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Types, Abstraction and Parametric Polymorphism</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Reynolds</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983">1983</date>
			<publisher>IFIP Congress</publisher>
			<biblScope unit="page" from="513" to="523" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A foundation for embedded languages</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rhiger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="291" to="315" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Boxes go bananas: Encoding higher-order abstract syntax with parametric polymorphism</title>
		<author>
			<persName><forename type="first">G</forename><surname>Washburn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Weirich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Funct. Program</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="87" to="140" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
