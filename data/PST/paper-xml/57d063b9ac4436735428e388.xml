<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">History Driven Program Repair</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Xuan-Bach</forename><forename type="middle">D</forename><surname>Le</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Information Systems</orgName>
								<orgName type="institution">Singapore Management University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">David</forename><surname>Lo</surname></persName>
							<email>davidlo@smu.edu.sg</email>
							<affiliation key="aff0">
								<orgName type="department">School of Information Systems</orgName>
								<orgName type="institution">Singapore Management University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Claire</forename><surname>Le Goues</surname></persName>
							<email>clegoues@cs.cmu.edu</email>
							<affiliation key="aff1">
								<orgName type="department">School of Computer Science</orgName>
								<orgName type="institution">Carnegie Mellon University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">History Driven Program Repair</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">5EB7EDC4B6519330886E5C0A09EA1423</idno>
					<idno type="DOI">10.1109/SANER.2016.76</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T04:24+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Automated Program Repair</term>
					<term>Mutation Testing</term>
					<term>Graph Mining</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Effective automated program repair techniques have great potential to reduce the costs of debugging and maintenance. Previously proposed automated program repair (APR) techniques often follow a generate-and-validate and testcase-driven procedure: They first randomly generate a large pool of fix candidates and then exhaustively validate the quality of the candidates by testing them against existing or provided test suites. Unfortunately, many real-world bugs cannot be repaired by existing techniques even after more than 12 hours of computation in a multi-core cloud environment. More work is needed to advance the capabilities of modern APR techniques.</p><p>We propose a new technique that utilizes the wealth of bug fixes across projects in their development history to effectively guide and drive a program repair process. Our main insight is that recurring bug fixes are common in real-world applications, and that previously-appearing fix patterns can provide useful guidance to an automated repair technique. Based on this insight, our technique first automatically mines bug fix patterns from the history of many projects. We then employ existing mutation operators to generate fix candidates for a given buggy program. Candidates that match frequently occurring historical bug fixes are considered more likely to be relevant, and we thus give them priority in the random search process. Finally, candidates that pass all the previously failed test cases are recommended as likely fixes. We compare our technique against existing generate-andvalidate and test-driven APR approaches using 90 bugs from 5 Java programs. The experiment results show that our technique can produce good-quality fixes for many more bugs as compared to the baselines, while being reasonably computationally efficient: it takes less than 20 minutes, on average, to correctly fix a bug.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Bugs are prevalent in software development. Mature commercial software systems regularly ship with both known and unknown defects <ref type="bibr" target="#b30">[31]</ref>, despite the support of multiple developers and testers typically dedicated to such projects <ref type="bibr" target="#b2">[3]</ref>. To maintain software quality, bug fixing is thus inevitable and crucial. Yet, bug fixing is notoriously a difficult, timeconsuming, and labor-intensive process, dominating developer time <ref type="bibr" target="#b51">[51]</ref> and the cost of software maintainance. Many defects, including security-critical defects, remain unaddressed for extensive periods <ref type="bibr" target="#b18">[19]</ref>, and the resulting impact on the global economy is measured in the billions of dollars annually <ref type="bibr" target="#b48">[48]</ref>, <ref type="bibr" target="#b9">[10]</ref>. There is a dire need to develop automated techniques to ease the difficulty and cost of bug fixing in practice.</p><p>To address the above-mentioned need, substantial recent work proposes techniques for Automated Program Repair (APR). These techniques seek to automatically fix bugs by producing source-level patches. For example, GenProg <ref type="bibr" target="#b27">[28]</ref> uses a Genetic Programming <ref type="bibr" target="#b25">[26]</ref> heuristic to conduct a search for a patch that causes the input program to pass all given test cases (including at least one that initially failed, exposing the defect to be addressed). Subsequently, Kim et al. extend the GP approach in Pattern-based Automatic program Repair (PAR), which uses bug fix templates manually learned from existing human-written patches <ref type="bibr" target="#b24">[25]</ref> to guide the creation of the potential patches. These techniques are instructive examples of generate-and-validate and test-case-driven approaches to defect repair: They generate many candidate patches, and validate them against a set of test cases. The process is repeated many times, with a fitness score computed for each candidate patch based on the number of test cases that the associated modified program passes or fails. This score guides subsequent iterations, and thus the way the techniques traverse the search space of candidate repairs.</p><p>Despite the promise of existing APR techniques, current approaches are limited in several key ways <ref type="bibr" target="#b43">[43]</ref>. To truly improve the quality of real-world software as well as the experience of modern software developers, an ideal technique must be both effective (i.e, able to fix many real bugs) as well as efficient (i.e., able to do so in a short amount of time). Even merely plausible patches-those that lead the buggy program to pass the provide test cases, but that are not necessarily globally correct as judged by an informed programmer-may take more than 10 hours to generate, and the resulting patches may still be incorrect <ref type="bibr" target="#b24">[25]</ref>, <ref type="bibr" target="#b43">[43]</ref>. Although the risk of low quality patches can be mitigated by using more comprehensive test suites to guide the search process, even with full-coverage test suites, existing test-guided techniques may be susceptible to overfitting <ref type="bibr" target="#b47">[47]</ref>. That is, produced patches may fail to functionally generalize beyond the test suite used to produce them. Although the current APR state-of-research is still in its infancy, it is important to work towards both effectiveness and efficiency to allow APR to be ultimately adopted.</p><p>In this paper, we propose a novel technique for historybased program repair. Like several previous methods, our technique makes use of a stochastic search process to generate and then validate large numbers of patches, seeking one that causes previously-failing tests to pass. The most important feature differentiating our new technique from the previous work is that it evaluates the fitness or suitability of a candidate patch by assessing the degree to which it is similar to prior bug-fixing patches, taken from a large repository of real patches. This is in contrast with previous search-based approaches, which by and large use input test cases to assess intermediate patch suitability. Our intuition is that bug fixes are often similar in nature and past fixes can be a good guide for future fixes. This has at least partially informed a number of previous studies and approaches <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b24">[25]</ref>, <ref type="bibr" target="#b32">[33]</ref>. The important novelty in our technique is that, instead of simply using previous fixes to inform the construction of candidate patches, we use fix history to help assess their potential quality, or fitness. We expect that the history-driven approach mitigates the risk of overfitting to the test suite, because it does not directly use the test suite score to guide individual selection for later iterations. This increases the probability that the resulting patches generalize to the desired program specification. Moreover, using the history to guide the repair search can also imbue the APR process with history-informed "common sense" to identify plausible but clearly-to humans-nonsensical patches.</p><p>To illustrate, consider the buggy code snippet in Figure <ref type="figure" target="#fig_0">1</ref>, taken from Math version 85 in Defect4J benchmark <ref type="bibr" target="#b21">[22]</ref>. This buggy snippet throws a ConvergenceException when one of the test cases is executed. One low-quality way to "fix" the problem that eliminates the symptom, and causes the test case to trivially pass, simply deletes the throw statement. However, this would be a nonsensical solution, and is not consistent with the patch the human developer committed for the same defect. Unfortunately, prior generate-and-validate and test-case-driven APR techniques cannot identify such a solution as nonsensical. In our history based approach, on the other hand, the fact that such edits very rarely appear in the historical bug fix data means that it receives a very low score in the search process. In this way, our technique is more likely to avoid plausible but nonsensical patches.  <ref type="formula">3</ref>) bug fix generation. The first two phases are conducted in advance of any particular bug-fixing effort. In the first phase, our technique mines historical bug fixes from revision control systems of hundreds of projects in GitHub. In the second phase, our technique identifies a clean set of data, seeking to find frequently appearing or common bug fixes, and infering a common representation to capture many similar such bug fixes. Bug fixes are represented as change graphs, which have the benefit of being generic and able to capture various kinds of changes along with their contexts. These change graphs, along with their frequencies, are used as a knowledge base for the third phase. In the third phase, our technique iteratively generates candidate patches, ranks them based on the frequency with which their constituent edits appear in the knowledge base inferred in the second phase, and returns a ranked list of plausible patches that pass all previously failed test cases as recommendations to developers.</p><p>We have evaluated our solution on 90 real bugs from 5 Java programs. We compare our technique against GenProg and PAR. GenProg is a popular generate-and-validate and testcase-driven APR technique that with a publicly available Java implementation. <ref type="foot" target="#foot_0">1</ref> Similarly, PAR is a generate-and-validate, test-case-driven technique developed for Java programs that explicitly makes use of edit templates manually synthesized from edit histories. Both are generic approaches that can, in theory, produce multi-line patches for bugs in programs. Our experiments show that our approach can correctly fix 23 bugs out of the 90 programs, while PAR and GenProg are only able to correctly fix 4 and 1 bugs, respectively. Moreover, our approach on average only needs 20 minutes to fix the 23 bugs. The results demonstrate the effectiveness and efficiency of our proposed approach.</p><p>The contributions of our work are as follows:</p><p>1) We propose a generic and efficient history-based automatic program repair technique that uses information stored in revision control systems of hundreds of software systems to generate plausible and correct patches. Our approach is generic since it can deal with bugs whose fixes involve multi-line changes. It is efficient since it can complete on average within less than 20 minutes. 2) We demonstrate that our approach is effective in fixing 23 bugs correctly, dramatically outperforming the performance of the baseline solutions. 3) Our approach supports Java instead of C. Java is the most popular programming language and its influence is growing over time. <ref type="foot" target="#foot_1">2</ref> Prior generate-and-validate and test-case-driven APR techniques mostly work on C programs with a few exceptions (e.g., PAR). Unfortunately, the implementation of PAR is not made publicly available. To facilitate reproducible research, we made the implementation of our approach available at https://github.com/xuanbachle/bugfixes</p><p>The structure of the remainder of this paper is as follows. In Section II, we elaborate the three steps of our proposed approach. In Section III, we present our experiment results which answer four research questions. We discuss related work in Section IV and conclude in Section V.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. PROPOSED APPROACH</head><p>The overall goal of our approach is two-fold: to generate correct, high-quality bug fixes; and to quickly present such fixes to developers. To achieve this goal, we divide our framework into three main phases: (1) bug fix history extraction, (2) bug fix history mining and (3) bug fix generation. The first phase extracts a dataset of bug fixes made by human in the history from GitHub. This dataset is input to the second phase, which converts the bug fixes to a graph-based representation from which it automatically mines bug fix patterns. The mined bug fix patterns are input to the last phase.</p><p>In the last phase, we use a modified stochastic search technique <ref type="bibr" target="#b15">[16]</ref> to evolve patches to a given buggy program, until we find a desired number of solutions. To reduce the risks of either overly constraining the search space or overfitting to the test suite, we use 12 existing mutation operators previously proposed in the mutation testing literature and used by prior repair techniques <ref type="bibr" target="#b37">[38]</ref>, <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b24">[25]</ref>. The fitness of the generated fix candidates is determined by the frequency with which the changes included in a given patch occur in the mined bug fix patterns produced by the second phase. Better fix candidates are thus those that frequently occur in the past fix patterns, and are thus more likely to be chosen to be validated against failed test cases, i.e., the test cases that reveal the bug in the original buggy program. Such selected patches are also more likely to be further developed and evolved in subsequent iterations. This fix candidate generation process is repeated until a desired number of candidates that pass all the failed test cases is identified. At the end of this phase, these candidates are presented to the developer as possible fixes for the bug, ranked by the frequency with which their edits appear in the bug fix history. The developer can then investigate the suggested fixes to find an actually correct fix.</p><p>In the next subsections, we describe each of the three phases of our framework in more detail (Sections II-A-II-C); Section II-D describes our mutation operators.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Bug Fix History Extraction</head><p>In this phase, we collect human-made bug fixes from many open source projects on Github. The primary purpose of this phase is to collect and collate commits that are solely related to bug fix actions, excluding feature requests, refactoring, and other non-repair types of edits.</p><p>To collect bug fix history data from GitHub, we follow the procedure described by Ray et al. <ref type="bibr" target="#b44">[44]</ref> to gather large, popular, and active open source Java projects. In particular, we use Github Archive <ref type="bibr" target="#b0">[1]</ref>, a database that frequently records public activities from GitHub, e.g., new commits, fork events, etc, to select only projects with the above characteristics. The popularity of a project is indicated by the number of stars associated with its repository, which corresponds to the number of GitHub users that have expressed interest in that project. In the interest of identifying only large, popular projects, we filter out those with fewer than five stars and exclude projects with repositories smaller than 100 Megabytes. Finally, we retain projects that are active as of September, 2014. This still leaves us with thousands of projects.</p><p>For each of the retained projects, we iterate through its source control history, seeking to collect commits that exclusively concern bug repair. This is a difficult problem in repository mining <ref type="bibr" target="#b7">[8]</ref>. We therefore seek a complete set of bug-fixing commits using heuristics, though acknowledge that our approach is best-effort. We deem a commit a bug fix if it simultaneously satisfies the following conditions: 1) Its commit log contains the keywords such as fix, bug fix, while not containing keywords such as fix typo, fix build or non-fix.</p><p>2) It includes the submission of at least one test case in that commit. Although the submitted test case does not necessarily mean the one that induces the bug, the inclusion of test case in the commit further increases the likelihood that the commit is a bug fix.</p><p>3) It involves changes on no more than two source code lines. The changed lines are counted, excluding code comments.</p><p>This last requirement warrants additional explanation. Commits that satisfy the first condition but involve many changed lines typically include changes beyond the bug fix, addressing feature addition, refactoring, etc <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b22">[23]</ref>. Thus, we filter out commits involving more than two changed lines. Ultimately, this leaves us with 3000 bug fixes across 700+ large, popular and active open source Java projects from GitHub. <ref type="foot" target="#foot_2">3</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Bug Fix History Mining</head><p>In the second phase, we mine frequent bug fix patterns from the 3000 bug fixes, that appear in more than 700 projects, collected by previous phase. We first convert the collected bug fixes into a graph-based representation. We then apply an existing graph mining technique to the dataset to mine closed frequent patterns from the converted graphs.</p><p>Graph-based representation of bug fixes. Our goal in representing bug fixes is to succinctly abstract similar bug fixes into a common, abstract representation amenable to mining, which is especially challenging in the face of naming differences. Different bug fixes may vary in terms of the naming scheme in the underlying code, containing modifications to different variable names, method names, etc. For example, Figure <ref type="figure">2</ref> shows two bug fixes that both involve the change of method call parameter. Although there are differences in the expressions (variables) that invoke the method calls, the method call names and parameter names, conceptually, these bug fixes can easily be classified as the same kind of bug fix, i.e., "method call parameter replacement." Our first step in storing a bug fixing change is to capture its effects at the Abstract Syntax Tree (AST) level, which abstracts away many incidental syntactic differences (e.g., whitespace, bracket placement) that obscure a patch's semantic effect. To this end, we use GumTree, <ref type="foot" target="#foot_3">4</ref> an off-the-shelf, state-of-theart tree differencing tool that computes AST-level program modifications <ref type="bibr" target="#b14">[15]</ref>. GumTree represents differences between two ASTs via a series of actions including additions, deletions, updates or moves of individual tree nodes to transform one AST to another. To do this, given a bug fix, we first identify the file modified by the bug fix, and then retrieve the versions of the file before and after the modifications were made. Both versions of the modified file are then parsed to ASTs, denoted as the "buggy AST" and "fixed AST," respectively. We then use GumTree to compute the actions needed to transform the buggy AST into the fixed AST. For example, GumTree gives us the action needed to represent the bug fix 1 in the Figure <ref type="figure">2</ref> as update from x1 to x2.</p><p>However, this raw information provided by GumTree is insufficiently abstract on its own, since it is still specific to the variable names x1 and x2. Additionally, the semantic context surrounding the action is unclear, that is, whether the action applies to a method call, an assignment, etc. To remedy this issue, we convert the series of actions produced by GumTree into a labelled directed graph that further abstracts over the edit actions, while being able to capture surrounding semantics. In this directed graph representation, an edge from a parent vertex to a child vertex is labelled by the kind of the action made to the child vertex. The context of the action is then captured by the parent vertex. To illustrate by example, Figure <ref type="figure" target="#fig_1">3</ref> depicts the graph that represents the bug fix 1 in Figure <ref type="figure">2</ref>. Similarly, this graph also represents the change made in bug fix 2. Thus, by using this graph representation, we can represent bug fixes in a common abstraction and capture contexts of the bug fixes. This graph-based representation will then help us in using graph mining techniques to mine frequent bug fix patterns. Fig. <ref type="figure">2</ref>: Example of two bug fixes involving method call parameter replacement.</p><p>Mining closed frequent bug fix patterns. Given the full set of bug fixes, represented as graphs, we mine closed frequent patterns from the graphs. A pattern is frequent if it often occurs in the database; we heuristically set this count to at least two. A frequent pattern g is closed if there exists no proper supergraph of g that has the same number of supergraphs, i.e., support, as g. Thus, by definition, closed frequent patterns are the largest possible patterns that frequently occur in the database. In our domain, our goal is to mine the largest possible bug fix patterns to precisely capture behaviours of the changes. We therefore employ an extension of gSpan, 5 an implementation of a stateof-the-art frequent graph miner <ref type="bibr" target="#b52">[52]</ref> for this task. We consider a pattern is frequent if it has support greater than or equal to two.</p><p>We store information about patterns, including each pattern's vertices, edges, and supergraphs that contain the pattern. The number of supergraphs of a pattern constitutes the frequency of the pattern.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Bug Fix Generation</head><p>Overview. In this phase, we use a stochastic search approach loosely inspired by genetic programming <ref type="bibr" target="#b25">[26]</ref> to evolve a patch for a given buggy program. The search objective is a patch that, when applied to the input program, addresses the defect, as identified by a set of failing test cases. GP is the application of genetic algorithms (GA) to problems involving tree-based solutions (programs, typically; in our application, these are small edit programs applied to the original buggy program). A GA is a population-based, iterative stochastic search method inspired by biological evolution. Given a tree-based representation of candidate solutions, GP uses computational analogues of biological mutation and crossover to generate new candidate solutions, and evaluates solutions using a domainspecific objective, or fitness function. Potential solutions with high fitness scores are more likely to be randomly retained into future iterations both alone, modified slightly (via mutation), or, in some applications, in combination with other solutions (via crossover). In our approach, we represent a single candidate solution as a patch consisting of a sequence of edits to be made to the buggy program; this representation has been shown both efficient and effective in search-based program improvement <ref type="bibr" target="#b29">[30]</ref>. Given a population of candidate solutions, we then use a selection process to create new candidates through mutation, and then to select mutated candidates to subsequent generations for additional evolution. The selection phase applies to the mutation step, in which a new edit is pseudo-randomly constructed and then added to an existing (possibly-empty) candidate patch. This selection is informed by the bug fix history database constructed as discussed in Section II-B. Note that our algorithm does not perform crossover, using only mutation to create new individuals; we leave the development of a suitable crossover operator in our context to future work.</p><p>The details of this phase are further described in Algorithm 1. The primary inputs to the algorithm are the buggy program, where the bug is indicated by one or more failing test cases; a set of faulty locations, weighted by a preexisting fault localization procedure; a distribution of edit frequencies mined as discussed in the previous section, and a set of possible mutation operators. We presently assume that the faulty methods are known in advance, as file-and method-level localization represent an orthogonal problem; we then compute the faulty lines in each prospective faulty method using existing statistical fault localization techniques <ref type="bibr" target="#b1">[2]</ref>. The stochastic algorithm includes several tunable parameters, described in context.</p><p>Given those inputs, the algorithm works in multiple iterations. The first iteration constructs an initial generation of PopSize candidate solutions by repeatedly constructing single-edit patches for the program (lines <ref type="bibr" target="#b15">[16]</ref><ref type="bibr" target="#b16">[17]</ref><ref type="bibr" target="#b17">[18]</ref>. Subsequent generations are created by adding new mutations to retained solutions in the current population. We describe mutation as it is used to create the initial population of single-edit patches; its application in subsequent iterations follows naturally.</p><p>Mutation. The mutation procedure adds an edit to a (possiblyempty) candidate patch to create a new patch candidate. It is described from line 4 to line 12 in Algorithm 1. At a high level, the mutation step creates a large number of candidate edits, from which a single edit is ultimately propagated into the candidate patch. First, the algorithm randomly selects a subset of L fault locations to which mutations may be applied (line 5), weighted by the score given by the statistical fault localization. We heuristically set L to 10 in our experiments, leaving a full parameter sweep to future work. Next, lines 7 to 10 generates a set of possible edits to select in this mutation step. This involves first identifying which mutation operators can be applied to each of the prospective faulty locations. For Algorithm 1: Bug Fix Generation. The select procedure returns one or more individuals from a population, either uniformly or weighted by a provided function. applies and instant are described in text. The tunable parameters are PopSize (population size), M (desired solutions), E (number of seeded candidates to the initial population), and L (number of locations considered in the mutation step).  This check is performed by the function applies on line 8. We reuse existing mutation operators (see Section II-D for a complete list, and details about their application), that have been proposed in prior mutation testing and program repair studies, to provide a diverse set of bug fix edit candidates.</p><p>There are often several ways to instantiate a given operator. For example, append requires the selection of fix code to append at a given location. The instant function returns all possible instantiates of a given operator to the provided location, also on line 8. We select one of these edits (line 9) and create a new candidate by adding it to the current candidate.</p><p>This results in an intermediate pool of new pseudo-random patch candidates (initialized on line 6, updated on line 10) from which a single candidate will be retained. This retained candidate is thus the single result of the mutation step; it is the result of adding a new random edit to the (possibly-empty) candidate patch under mutation. To pseudo-randomly select an edit from this pool, we weight each edit by the frequency with which it appears in the mined bug fix patterns. This computation is performed in helper function editFreq, used in selection on line 12. Note that since exact graph matching (isomorphism) is notoriously difficult and expensive <ref type="bibr" target="#b49">[49]</ref>, we relax the conditions of matching fix candidates against past fix patterns. We instead say a fix candidate matches a fix pattern (graph) if the graph representing the candidate has more than half of its labels of vertices and edges matched with the fix pattern's vertices and edges respectively.</p><p>The frequency formula at line 3 works as follows: Given a fix candidate consisting of N edit operations, each edit operation contributes equally to the candidate's frequency. That is, we break down the block of N edits into each constitute edit and then fuse the frequency of each small edit together. The intuition is that, due to the randomness of the mutation procedure, generated fix candidates may contain bugfix irrelevant edit operations, e.g., field or variable declarations. Ideally, these irrelevant edits should not affect the score of fix candidates containing them, since such edits contribute nothing or very little to the fixing effort. If we count the frequency of the fix candidate consisting of these edit operations by the whole block of N combined edits, it would make the fix candidate very rare when comparing the candidates against the historical bug fix patterns, and reduce the likelihood that the fix candidate will persist for future evolution. Our use of mean edit frequency mitigates the effect of adding bug-fix irrelevant edit operations with respect to the viability of the overall patch.</p><p>At line 12, we pseudo-randomly select one edit from the pool to add to the current candidate solution. This selection is informed by the computed frequency of a candidate patch that includes each edit in turn (the higher the frequency score of the overall patch that includes it, the more likely it is that the potential edit is selected from the pool). We use stochastic universal sampling <ref type="bibr" target="#b5">[6]</ref> for this task. This selected candidate is thus the return value of the mutation procedure.</p><p>Main algorithm. Mutated candidates are created and processed by the main algorithm, described from line 13 to line 30. Line 15 adds E number of empty candidate patches to the initial population as seeds. We heuristically set E to 3 in our algorithm. Lines 16-18 create an initial population with P opSize candidate patches by repeatedly mutating the empty patch. We heuristically set P opSize to 40 in our algorithm. Next, from line 20 to line 28, we validate each candidate in the current population against the failed test cases. If a candidate passes all the failed test cases, we add it to the set of possible solutions (line 23). Otherwise, we mutate the candidate and carry the mutated candidate over the next iteration (line 25).</p><p>The process continues until a given number of fix candidates that pass all the previously failed test cases is reached. This is indicated at line 29, where the solutions' size reaches M desired solutions. We heuristically set M to 10 in our algorithm. Ultimately, these candidates are presented to the developer as possible fixes to the buggy program, ranked by the frequency of the underlying edits. The developer is then responsible for assessing the correctness of the suggested fixes. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Mutation Operators</head><p>In this section, we describe the 12 mutation operators we employ to generate fix candidates in our framework; these operators are listed in Table <ref type="table" target="#tab_2">I</ref>. These operators have been used previously in mutation testing and well-known repair techniques; we use them to simultaneously provide a broad array of potential edit types, while mitigating the risk of overfitting the operators used in our experiments to the underlying dataset.</p><p>GenProg Mutation Operators. We employ the three mutation operators from GenProg <ref type="bibr" target="#b27">[28]</ref>, <ref type="bibr" target="#b28">[29]</ref>. The delete operator deletes a given potentially-buggy statement. The insert and replace operators work under the assumption that the repair is a piece of code that can be found from somewhere else in the same program. The insert operator inserts a randomlyselected statement before or after a given buggy statement.The replace operator replaces a potentially-buggy statement with another randomly-selected statement. For insert and replace, the original GenProg algorithm randomly chooses a statement from elsewhere in the same program, given certain semantic constraints (e.g., variable scoping). However, given a time limit, a large program can enormously reduce the possibility of selecting the correct statement.</p><p>We mitigate this problem in several ways. First, we reduce the scope of source statement selection to the same file with the target buggy statement. Previous studies have shown that this is adequate for many automated program repair problems <ref type="bibr" target="#b6">[7]</ref>. Second, we heuristically prioritize in-scope statements. We view the problem of finding the source statement as two stages: First, we find the clones of the piece of code (method) surrounding the target buggy statement. Second, each of statements in the clones that have higher similarity is given higher probability to be a source statement. For statements that are not in any clones, we give them a default probability which is less than the probabilities of any statements found in clones. To find clones, we employ tree-based clone detection technique described by Jiang et al. in <ref type="bibr" target="#b19">[20]</ref>.</p><p>Mutation Testing Operators. We employ five mutation operators proposed in mutation testing research <ref type="bibr" target="#b37">[38]</ref>, <ref type="bibr" target="#b38">[39]</ref>. The first three concern type casting: delete type cast, insert type cast, and change type cast. The latter two focus on inserting or changing casts only to compatible types. The change infix expression operator changes the operator used in a given infix expression. For example, an infix expression like a ≥ b involves an arithmetic operator that can be randomly changed, such as to a &gt; b, a &lt; b or a ≤ b. An infix expression a = b that involves relational operator can be changed to a == b. An infix expression a &amp;&amp; b that involves conditional operator can be changed to a || b and vise versa. The boolean negation operator tries to negate a boolean expression. For example, true can be negated to false, and isN egative(a) can be negated to !isN egative(a). PAR Mutation Operators. We employ four out of ten mutation operators proposed by Kim et. al. <ref type="bibr" target="#b24">[25]</ref>, leaving the employment of the remaining six operators as future work. These operators are applied to either method call or if condition. The first operator replaces a method call parameter, while the second operator replaces method call name, or the expression that invokes the method call. The last two operators deal with condition expression of if statement. An if condition expression containing more than two conditions can apply the remove condition expression. For example, if(a || b){...} can be changed to if(a){...} by removing condition b, which is randomly chosen from the condition. The add condition expression tries to add a condition to an if condition. The condition to be added is chosen from a pool of conditions collected from the same file with the faulty if statement. However, this pool of collected conditions can be inappropriate to fix a given bug, since they may reference out of scope variables.</p><p>To address this, our framework further cultivates the search space by inventing new conditions that have not appeared elsewhere in the same file. The idea is that the missing condition may very likely involve one of the variables used in the current if condition. Toward this end, we collect all variables used in the if condition. We then collect all boolean usages that involve the types of the collected variables from the same file. We then apply the usages with the collected variable names, and add these usages to the pool possible conditions that can be added to the current if condition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. EXPERIMENTS AND ANALYSIS</head><p>In this section, we first describe our dataset (Section III-A), followed by our experimental settings (Section III-B), research questions (Section III-C), and results (Section III-D). We conclude with a discussion of threats to validity (Section III-E).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Dataset</head><p>We apply our approach to repair a subset of bugs from Defects4J <ref type="bibr" target="#b21">[22]</ref>, a large collection of defects in Java program intended to support research in fault localization and software quality. Defects4J has also been used in previous study of several automated program repair (APR) tools <ref type="bibr" target="#b13">[14]</ref>. The  <ref type="bibr" target="#b42">[42]</ref>. Second, we also filter out too difficult bugs considering the semantics of the bugs, even though they involve changes that are syntactically fewer than six lines. For example, one kind of difficult bugs could be adding a field in a class and use that field for fixing bugs in methods. We hypothesize that an effective and usable APR technique should be able to fix classes of bugs that are easier to fix first before it can handle very difficult bugs. We thus prefer this dataset, filtered according to rules suggested in previous empirical studies to a completely manually-constructed dataset to mitigate to some degree the threat over overfitting our technique to the bugs under repair <ref type="bibr" target="#b34">[35]</ref>. We use the fix template database constructed as described in Sections II-A-II-B.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Experiment Settings</head><p>We compare our approach against PAR <ref type="bibr" target="#b24">[25]</ref> and Gen-Prog <ref type="bibr" target="#b28">[29]</ref>. Since PAR is not publicly available, we reimplemented a prototype of PAR for this experiment based on our framework. We also note that the original version of GenProg works on C programs and thus we used a publicly available implementation of GenProg<ref type="foot" target="#foot_5">7</ref> that works on Java program provided by Monperrus et al. <ref type="bibr" target="#b13">[14]</ref>.</p><p>We assign one trial for each approach to run on each bug. Specifically, each trial of our approach is assigned one 2.4 GHz Intel Core i5-2435M CPU and 8GBs of memory. Each trial is terminated either after 90 minutes or 10 generations or if 10 possible solutions were found. The size for each population is set to 40 for consistency with previous work <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b24">[25]</ref>. Since we consider current automated program repair techniques as only recommendation systems (since they cannot fix most of the bugs yet), an automated program repair technique needs to be efficient enough (c.f., <ref type="bibr" target="#b26">[27]</ref>). We thus set the timeout for our experiment as 90 minutes for each trial. We note that since our approach, PAR and GenProg are all stochastic, multiple trials are needed to properly assess their performances <ref type="bibr" target="#b3">[4]</ref>. We discuss this in threats to validity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Research Questions</head><p>In our experiments, we seek to answer the following research questions:</p><p>RQ1 How many bugs can our technique fix, correctly, as compared to the baselines?</p><p>We compare the effectiveness of our approach against PAR and GenProg in terms of number of bugs that each approach can correctly fix. To do this, the first author of the paper manually inspected generated patches to verify their correctness with respect to the corresponding bugs. A patch is deemed a correct fix if it satisfies the following conditions:</p><p>(1) It results in a program that passes all test cases (both passing and initially failing). ( <ref type="formula">2</ref>) it follows the behavior of the corresponding human-made fix. Checking the first condition is not difficult. However, the second condition involves an intrinsic qualitative judgement and a deep understanding of the program in question. Thus, for the second condition, we only consider fixes that are as close as possible to the humanmade fixes. We leave a comprehensive human study on bug fixes quality to future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RQ2 Which bugs can the approaches fix in common? Which bugs can only be repaired by one of the approaches?</head><p>To gain insight into the process and limitations of the different approaches, we identify the defects for which our approach, PAR and GenProg all generate correct fixes. We describe case studies that illustrate potential reasons why some bugs can be fixed by one approach but not others.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RQ3 How long does it take to produce correct fixes?</head><p>In this research question, we investigate the average amount of time for each approach to run on the bugs that they can correctly fix. An approach is deemed efficient if it needs a reasonable computation time to find correct fixes. We consider current automated program repair techniques as recommendation systems, and a recommender that takes several hours to produce recommendations is ineffective.</p><p>RQ4 What are the rankings of the correct fixes among the solutions that our approach presents to the developer? Our approach generates a ranked list of possible solutions to a given bug. The higher a correct fix is ranked, the better, requiring less effort from the developer to try the solutions one by one from the top to the bottom. Thus, in this research question, we investigate the ranking of the correct fixes among the possible solutions that our approach presents to the developer.</p><p>We report on two types of ranking. First, we present the ranking in the order that fixes are generated temporally. If effective, this ranking is helpful in case the developer is rushing to clear the bug, since he or she can just try whatever suggestions appear earlier instead of waiting for the whole process to complete. Second, we assess a ranking based on the frequency with which fix edits appear in the historical data.   <ref type="table" target="#tab_4">III</ref> depicts the number of bugs for which each approach can generate correct fixes. In total, out of the 90 bugs, our approach generates correct fixes for 23 bugs; PAR can only correctly fix 4 bugs; GenProg generates only one correct fix. For the 23 bugs fixed by our approach, 11 (out of 12) mutation operators help fix these bugs. Each of these 11 operators helps fix no more than 5 bugs in the 23 bugs. Thus, it is not the case that the use of only a few operators can help fix all of the 23 bugs fixed by our approach. This supports our belief that while our approach is more effective than the baselines, its effectiveness is less likely to be biased by the experimental dataset.</p><p>Although the results for the previous techniques are somewhat worse than expected, we note that our timeout is set at 90 minutes and that we run only one trial on each bug. In previous experiments, GenProg and PAR set time outs at 12 hours, and run 10 trials in parallel for each bug <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b24">[25]</ref>. We can expect greater success if we increase the number of trials. However, our results are consistent with a recent study, demonstrating that GenProg produces correct patches for 4 of 357 bugs in Defects4J with a 2 hour timeout and single trial per bug <ref type="bibr" target="#b13">[14]</ref>. In sum, the results show that our approach substantially outperforms PAR and GenProg in terms of number of bugs correctly fixed. RQ2: Case Studies. Figure <ref type="figure" target="#fig_3">4</ref> shows that the bugs that PAR and GenProg correctly fix are a subset of those that our approach correctly fixes. There are 18 bugs that our approach can fix that PAR and GenProg do not. We present observations on this in the form of illustrative case studies.</p><p>Lack of Mutation Operators. In many cases, PAR's mutation operators/templates are inadequate for fixing these bugs in the same way that the developer did. For example, consider the human-produced fix for Commons Math Version 5:</p><p>if(real == 0.0 &amp;&amp; imaginary == 0.0){ -return NaN; + return INF; } Here, the human replaced one return statement with another. PAR has no mutation operator for this, while our approach has the replace statement operator adopted from GenProg, which helped generate this fix. Note that GenProg timed out on this bug, and thus did not fix the bug in our experiments.</p><p>Timeout. Even when the previous techniques possess the necessary mutation operators to potentially fix the bugs in the same way the developers did, in several cases they timed out before finding the fixes. For example, consider the developerproduced fix for Closure Compiler version 14:</p><p>for(Node finallyNode : cfa.finallyMap.get(parent)){ -cfa.createEdge(fromNode, Branch.UNCOND, finallyNode) + cfa.createEdge(fromNode, Branch.ON_EX, finallyNode); }</p><p>The developer replaced the method call parameter Branch.UNCOND with another parameter, Branch.ON_EX. PAR includes potentially appropriate templates, such as change method call name or replace parameter for method call. There are thus many possibilities for PAR to generate fix candidates for this buggy statement. However, even if PAR can generate the correct fix candidate among the pool of possible fix candidates, the correct fix candidate was not evaluated, as PAR timed out while evaluating other, incorrect candidates. We leave a more extensive study with longer timeouts and more random trials to future work.</p><p>Plausible vs Correct Fixes. Automated program repair techniques can generate both plausible and correct patches. A plausible patch leads the patched program to pass all test cases, but does not necessarily correspond to a true fix, consistent with the underlying specification and developer intent. A correct fix, on the other hand, is the one that correctly fixes the semantics of the buggy program. For example, consider the following code, including a plausible patch generated by GenProg for Math version 85: //Fix by human and our approach: change condition to fa * fb &gt; 0.0 if (fa * fb &gt;= 0.0) { //Plausible fix by GenProg -throw new ConvergenceException("...") }</p><p>GenProg's plausible patch simple deletes the throw statement. This fix makes the program pass all the given test cases, at least in part because the test cases do not truly check the underlying behavior. However, as compared to the human fix for the same bug, this fix is unlikely to correspond to developer intent or the underlying program specification. Additionally, the deletion of throw statements rarely happens in historical practice. A more correct fix for this bug changes the arithmetic operator so that the exception is thrown in a correct manner that indeed satisfies the desired behaviour of the program; this is shown in the comment in the snippet, above the if condition.</p><p>In our approach, the delete statement mutation operator adopted from GenProg and the change infix (arithmetic) expression operator adopted from mutation testing both lead to the generation of a plausible patch: one similar to GenProg's, and the other similar to the human fix. However, partially due to the guidance provided by historical bug fixes, we avoid the plausible but incorrect patch and correctly choose the correct patch since the historical bug fix patterns suggest that changing an arithmetic happens more frequently in bug fixing practice. We also note that PAR does not generate any patch for this bug. Although PAR has the expression replacer operator which replace an if condition with another condition collected from the same scope, this operator does not help PAR generate patches for this bug since there is no correct condition appearing elsewhere in the same scope (same file).</p><p>Unfixed bugs in common. We observe that a common reason for why our approach, PAR and GenProg cannot fix bugs is a lack of ingredients that help synthesize the fix. For example, consider the human repair for Closure Compiler version 42:</p><p>+ if(loopNode.isForEach()){ + errorReporter.error("unsupported...", sourceName, loopNode.getLineno(),"", 0); + return newNode(...); }</p><p>The developer added an entire if statement to fix the bug. At first sight, the bug may be fixable by the program repair techniques in the same way as the developer did, if the same if statement appears elsewhere in the search space. However, it is indeed not the case. Thus, the three approaches failed to generate fixes for this bug.</p><p>RQ3: Average Amount of Time to Correct Fixes. In this research question, we report the average amount of time that our approach, GenProg, and PAR need in order to generate the correct fixes. GenProg requires less than 10 minutes to produce the fix for the one bug that it can correctly fix. PAR requires on average 10 minutes to generate correct fixes for the 4 bugs that it successfully fixes. Our approach needs on average 20 minutes to generate correct fixes for each of the 23 bugs. This indicates that PAR and GenProg are still efficient and effective for a certain class of bugs. For example, bugs that have a small search space to be traversed to find correct fixes could be quickly fixed by PAR or GenProg. Our approach, on the other hand, is resilient to many classes of bugs with the help of both the mutation operators and the guidance of historical bug fix data. Note, however, that although our technique takes longer than the baselines, 20 minutes is still well within the range of a suitably efficient technique. Also, the average time is computed over the time needed by our approach to fix the more difficult bugs that cannot be fixed by PAR and GenProg even within 90 minutes (timeout cases).</p><p>The key to good efficiency of our approach is that we generate a diverse set of possible fix candidates, and then use historical data to help pick the likely good fix candidates and test them against only the failed test cases, which originally make the buggy program fail. Thus, we do not waste too much time on evaluating nonsensical candidates. However, we do depend on the developer to assess the final patches for suitability with respect to the initially passing test cases.</p><p>RQ4: Rankings of Correct Fixes among Recommended Solutions. In this research question, we report the rankings of the correct fixes among the possible solutions that our approach presents to the developer. Recall that for each bug, we attempt to generate 10 possible solutions. We investigate two criteria for ranking possible solutions: time in which the fixes are produced, and edit frequency in the historical database.</p><p>Using time, the correct fixes are ranked number one for 13 out of the 23 bugs that we can produce correct fixes. We note that there are 6 bugs that we can only generate one solution for each bug and this solution is indeed the correct fix of the bug. For the remaining 10 bugs, each bug has correct fix ranked from 3 to 7 among the 10 possible solutions presented to the developer. Using frequency, there are 11 bugs that have correct fixes ranked number one. The remaining 12 bugs have correct fixes ranked from 2 to 10, among the 10 possible solutions presented to the developer. These results suggest that ranking the correct fixes among possible solutions by either time or frequency is acceptable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Threats to Validity</head><p>We consider three types of threats to validity: internal, external and construct validity:</p><p>Threats to Internal Validity. Threats to internal validity relate to errors in our implementation and experiments. We use a publicly available implementation of GenProg for Java programs. That implementation of GenProg is not written by the authors of GenProg, and thus it is possible that the implementation does not match all details specified in the original paper. Similarly, we reimplement PAR following the details provided in its paper. There could be bugs in the implementation that we are not aware of. To mitigate these threats, we have rechecked our implementation and experiments, fixed errors that we have found, and released our prototype for assessment by and comment from the community.</p><p>Threats to External Validity. Threats to external validity correspond to the generalizability of our findings. We perform our experiment on a dataset of 90 bugs from five Java projects; although we filter heuristically, this dataset is independently created and curated, mitigating the risk that our technique overfits to it. Still, they may not fully represent all real-world bugs. We plan to experiment on a larger dataset in the future.</p><p>Threats to Construct Validity. Threats to construct validity correspond to the suitability of our evaluation metrics. We consider a patch is correct if it passes all the test cases and qualitatively semantically matches human-made fix. To assess the second criterion, the first author manually checks the patches generated by the APR techniques. The APR techniques often generate patches that are syntactically the same as the human-made fix, but not for all cases. The first author has exercised caution when checking the patches, but it is possible that there are mistakes that we are not aware of. We plan to do a human study on the patches that the three APR techniques produce to better assess the quality of the patches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. RELATED WORK</head><p>Automated program repair has been the subject of considerable recent attention in the software engineering research community, and a large number of projects concern some form of repair. In the interest of brevity, we focus on indicative and closely-related techniques.</p><p>APR targeting general bugs: GenProg <ref type="bibr" target="#b27">[28]</ref>, <ref type="bibr" target="#b28">[29]</ref> uses a Genetic Programming technique to evolve patches to a buggy input program, searching for candidates that cause the input program to pass all given test cases (both initially passing and initially failing). Other techniques using randomized search for patch generation have also been proposed <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b41">[41]</ref>, <ref type="bibr" target="#b50">[50]</ref>. Debroy and Wong's efforts notably also reuse mutation operators to create patches, but do not reference edit history in evaluating candidate solutions <ref type="bibr" target="#b12">[13]</ref>. Our work is importantly different because it uses the program history to inform fitness computation and candidate selection, with a long-term goal of creating more natural repairs and repairs that are of higher quality because of their resemblance to previous repairs. Pattern-based Automatic program Repair (PAR), which uses bug fix templates manually learned from existing humanwritten patches <ref type="bibr" target="#b24">[25]</ref>, is closely conceptually related to our own. PAR uses a similar randomized technique to apply these templates to a buggy program. The above mentioned approaches, including ours, make use of an important hypothesis that new code (e.g., bug fixes) can often be reconstructed from fragments of code that already exist in the code base. Barr et al. <ref type="bibr" target="#b6">[7]</ref> empirically validate this hypothesis, showing that changes are 43% graftable from the exact version of program being changed. Another closely related work, that is developed in parallel with our work, is the work by Long and Rinard, named Prophet <ref type="bibr" target="#b31">[32]</ref>. In that paper, the authors also leverage history information to fix bugs. Our work is different from theirs in several aspects: (1) Prophet can only fix bugs that involve one line bugs, while our approach can solve bugs that require multi-line changes, <ref type="bibr" target="#b1">(2)</ref> We use bug-fix information from hundreds of open source projects, while prophet only uses eight, (3) We use a graph based representation which is a generic representation as compared to the ad-hoc set of features that are used by Prophet, (4) Prophet works on C program, our approach works on Java program, (5) Prophet successfully fixes 14 bugs, our approach successfully fixes 23 bugs, and (6) Our approach is more efficient than Prophet; only 4 of the bugs can be fixed by Prophet in 20 minutes or less (which is the average time needed by our approach to fix bugs). Unfortunately, an empirical comparison between our approach and Prophet cannot be made since we support different programming languages.</p><p>By contrast with search-based heuristic approaches, semantic approaches borrow ideas from program synthesis to construct bug-fixing patches. Techniques in this class include Sem-Fix <ref type="bibr" target="#b35">[36]</ref>, a repair tool using semantic analysis such as symbolic execution, constraint solving and program synthesis. SemFix leverages test cases as implicit program specification to guide the patch synthesis process. More recently, DirectFix <ref type="bibr" target="#b33">[34]</ref> extends this approach by targeting simplicity of generated patches, using MaxSAT constraint solving and componentbased program synthesis. SearchRepair <ref type="bibr" target="#b23">[24]</ref> uses SMT-solverinformed semantic code search and lightweight analyses to construct high-quality patches at a higher granularity level than previous techniques.</p><p>APR targeting specific bugs: Our approach targets general defect repair in Java. By contrast, a number of techniques target particular defect types or classes. For example, <ref type="bibr">Perkins et al.</ref> propose ClearView, targeting security errors in binary programs <ref type="bibr" target="#b39">[40]</ref>. Jin et al. present AFix, which uses static analysis to automatically repair single-variable atomicity violations <ref type="bibr" target="#b20">[21]</ref>. Carbin et al. detect and fix infinite loop errors <ref type="bibr" target="#b10">[11]</ref>; Smirnov et al. target fixing buffer overflow related errors <ref type="bibr" target="#b46">[46]</ref>; Sidiroglou et. al propose an architecture to repair flaws that are exploited by zero-day worms <ref type="bibr" target="#b45">[45]</ref>; Novark et al. present Exterminator -a system that automatically fix memory errors, including buffer overflows and dangling pointers <ref type="bibr" target="#b36">[37]</ref>; Coker and Hafiz target integer vulnerabilities in C <ref type="bibr" target="#b11">[12]</ref>. We leave an assessment of the particular defect types to which our approach most naturally applies to future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. CONCLUSION AND FUTURE WORK</head><p>Bug fixing is a difficult task that often takes much time and resources. To help developers fix bugs, researchers have proposed automated program repair (APR) techniques. Unfortunately, existing techniques are often not effective or efficient enough. They often unsuccessfully return correct patches despite running for a long period of time (e.g., more than 10 hours). In this work, we propose a generic and efficient APR technique that leverages information from historical bug fixes. Our solution takes as input a large set of repositories of software projects to create a knowledge base which is then leveraged to generate a ranked list of plausible bug fix patches given a buggy program and a set of test cases. It works on three phases: bug fix history extraction, bug fix history mining, and bug fix generation. We have evaluated the effectiveness of our proposed approach on a dataset of 90 bugs from five Java programs, and compared its effectiveness against two other generic generate-and-validate and test-case-driven APR techniques that work on Java programs. Our experiment results highlight that our approach can fix 23 bugs correctly, which are many more than the bugs that can be fixed by GenProg and PAR. On average, our solution can fix the 23 bugs within 20 minutes. These highlight the superior performance of our proposed approach in terms of effectiveness and efficiency as compared to existing generic APR solutions that can fix multiline bugs in Java programs.</p><p>In the future, we plan to improve the effectiveness and efficiency of our solution further. We plan to do so by designing better ways to traverse the search space of potential patches. We also plan to incorporate data from not only 3,000 bug fixes but even a larger number taken from even many more programs. Moreover, we plan to design an adaptive APR strategy that can vary the way it generates patches depending on characteristics of a bug.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>/Fig. 1 :</head><label>1</label><figDesc>Fig. 1: Bug in Math version 85</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 :</head><label>3</label><figDesc>Fig.3: Graph-based representation of bug fixes in Figure2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Solutionsexample, we should not use append to add any statements after a return statement, because doing so results in a dead code.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 :</head><label>4</label><figDesc>Fig. 4: Common Bugs Fixed by Program Repair Techniques</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE I :</head><label>I</label><figDesc>12 mutation operators employed in our framework</figDesc><table><row><cell>Operator Action</cell><cell>Description</cell></row><row><cell></cell><cell>GenProg Mutation Operators</cell></row><row><cell>Insert statement</cell><cell>Insert a statement before or after a buggy statement</cell></row><row><cell>Replace statement</cell><cell>Replace a statement with a buggy statement</cell></row><row><cell>Delete statement</cell><cell>Delete a buggy statement</cell></row><row><cell></cell><cell>Mutation Testing Operators</cell></row><row><cell>Insert Type Cast</cell><cell>Cast an object to a compatible type</cell></row><row><cell>Delete Type Cast</cell><cell>Delete type cast used on an object</cell></row><row><cell>Change Type Cast</cell><cell>Change type cast to another compatible type</cell></row><row><cell>Change Infix Expres-</cell><cell>Change primitive operator (arithmetic, relational, condi-</cell></row><row><cell>sion</cell><cell>tional, etc) in an infix expression</cell></row><row><cell>Boolean Negation</cell><cell>Negate a boolean expression.</cell></row><row><cell></cell><cell>PAR Mutation Operators</cell></row><row><cell>Replace Method Call</cell><cell>Replace a parameter in a method call by another param-</cell></row><row><cell>parameter</cell><cell>eter with compatible types.</cell></row><row><cell>Replace Method Call</cell><cell>Replace the name of a method call, or a method-</cell></row><row><cell>Name/Invoker</cell><cell>invoking expression, by another method name or ex-</cell></row><row><cell></cell><cell>pression with compatible types.</cell></row><row><cell>Remove Condition</cell><cell>Remove a boolean condition in an existing if condition</cell></row><row><cell>Add Condition</cell><cell>Add a boolean condition to an existing if condition</cell></row><row><cell cols="2">For example, the developer can pick any of the fixes appearing</cell></row><row><cell cols="2">on top of the recommendation to validate the fixes by running</cell></row><row><cell cols="2">them against previously passed test cases, and see if the fixes</cell></row><row><cell cols="2">are actually semantically correct or not.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>TABLE II :</head><label>II</label><figDesc>Dataset Description. "#Bugs" denotes the total number of bugs in the Defects4J dataset. "#Bugs Exp" denotes the number of filtered bugs we used in our experiments. TableIIdepicts the number of bugs from each program in Defects4J and the number of bugs from each program that are used in our experiments. We use only these 90 bugs out of 357 bugs in Defects4J since we filtered out bugs that are too difficult for current stateof-the-art repair techniques to fix. That is, we first filter out bugs that involve more than six changed lines since they are typically too difficult for current automated program repair techniques to fix</figDesc><table><row><cell>Program</cell><cell cols="2">#Bugs #Bugs Exp</cell></row><row><cell>JFreeChart</cell><cell>26</cell><cell>5</cell></row><row><cell>Closure Compiler</cell><cell>133</cell><cell>29</cell></row><row><cell>Commons Math</cell><cell>106</cell><cell>36</cell></row><row><cell>Joda-Time</cell><cell>27</cell><cell>2</cell></row><row><cell>Commons Lang</cell><cell>65</cell><cell>18</cell></row><row><cell>Total</cell><cell>357</cell><cell>90</cell></row><row><cell cols="3">dataset contains 357 real and reproducible bugs from 5 real-</cell></row><row><cell cols="3">world open source Java programs. In our experiments, we</cell></row><row><cell cols="2">use 90 bugs from Defects4J. 6</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>TABLE III :</head><label>III</label><figDesc>Effectiveness of our approach, PAR and GenProg in terms of number of defects repaired from each program.</figDesc><table><row><cell>Program</cell><cell cols="3">Our Approach PAR GenProg</cell></row><row><cell>JFreeChart</cell><cell>2/5</cell><cell>-/5</cell><cell>-/5</cell></row><row><cell>Closure Compiler</cell><cell>7/29</cell><cell>1/29</cell><cell>-/29</cell></row><row><cell>Commons Math</cell><cell>6/36</cell><cell>2/36</cell><cell>-/36</cell></row><row><cell>Joda-Time</cell><cell>1/2</cell><cell>-/2</cell><cell>-/2</cell></row><row><cell>Commons Lang</cell><cell>7/18</cell><cell>1/18</cell><cell>1/18</cell></row><row><cell>Total</cell><cell>23/90</cell><cell>4/90</cell><cell>1/90</cell></row><row><cell></cell><cell>Our Approach</cell><cell></cell><cell></cell></row><row><cell cols="2">18 bugs</cell><cell>PAR</cell><cell></cell></row><row><cell></cell><cell></cell><cell>4 bugs</cell><cell></cell></row><row><cell></cell><cell>GenProg</cell><cell></cell><cell></cell></row><row><cell></cell><cell>1 bugs</cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>https://libraries.io/github/SpoonLabs/astor</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>Dataset available: https://github.com/xuanbachle/bugfixes</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>https://github.com/GumTreeDiff/gumtree</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_4"><p>The bugs are made available here: https://github.com/xuanbachle/bugfixes</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_5"><p>https://libraries.io/github/SpoonLabs/astor</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_6"><p>https://libraries.io/github/SpoonLabs/astor</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>We would like to thank Just et al. for releasing the Defect4J dataset <ref type="bibr" target="#b21">[22]</ref> and Monperrus et al. for releasing their implementation of GenProg 8 which works for Java programs <ref type="bibr" target="#b13">[14]</ref>.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<ptr target="https://githubarchive.org/" />
		<title level="m">Github archive</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">On the accuracy of spectrum-based fault localization</title>
		<author>
			<persName><forename type="first">R</forename><surname>Abreu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Zoeteweij</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Van Gemund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Testing: Academic and Industrial Conference Practice and Research Techniques-MUTATION</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2007">2007. 2007</date>
			<biblScope unit="page" from="89" to="98" />
		</imprint>
	</monogr>
	<note>TAICPART-MUTATION 2007</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Coping with an open bug repository</title>
		<author>
			<persName><forename type="first">J</forename><surname>Anvik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Hiew</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">C</forename><surname>Murphy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Eclipse Technology eXchange</title>
		<meeting><address><addrLine>San Diego, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="35" to="39" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A practical guide for using statistical tests to assess randomized algorithms in software engineering</title>
		<author>
			<persName><forename type="first">A</forename><surname>Arcuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Briand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM/IEEE International Conference on Software Engineering (ICSE)</title>
		<meeting><address><addrLine>Honolulu, HI, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A novel co-evolutionary approach to automatic software bug fixing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Arcuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Congress on Evolutionary Computation</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="162" to="168" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Reducing bias and inefficiency in the selection algorithm</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Baker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the second international conference on genetic algorithms</title>
		<meeting>the second international conference on genetic algorithms</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="14" to="21" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The plastic surgery hypothesis</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">T</forename><surname>Barr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Brun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Devanbu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Sarro</surname></persName>
		</author>
		<idno type="DOI">10.1145/2635868.2635898</idno>
		<ptr target="http://doi.acm.org/10.1145/2635868.2635898" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22Nd ACM SIGSOFT International Symposium on Foundations of Software Engineering, ser. FSE 2014</title>
		<meeting>the 22Nd ACM SIGSOFT International Symposium on Foundations of Software Engineering, ser. FSE 2014<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="306" to="317" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Fair and balanced?: Bias in bug-fix datasets</title>
		<author>
			<persName><forename type="first">C</forename><surname>Bird</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bachmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Aune</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Duffy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Filkov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Devanbu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Software Engineering Conference and the ACM SIGSOFT International Symposium on Foundations of Software Engineering (ESEC/FSE), Amsterdam</title>
		<meeting><address><addrLine>The Netherlands</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-08">August 2009</date>
			<biblScope unit="page" from="121" to="130" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Automatic repair of concurrency bugs</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Bradbury</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Jalbert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Search Based Software Engineering (SSBSE) fast abstract</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Di Penta</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Poulding</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><surname>Briand</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Clark</surname></persName>
		</editor>
		<meeting><address><addrLine>Benevento, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010-09">Sep. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Reversible debugging software</title>
		<author>
			<persName><forename type="first">T</forename><surname>Britton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Jeng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Carver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Cheak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Katzenellenbogen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Tech. Rep</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
		<respStmt>
			<orgName>University of Cambridge, Judge Business School</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Detecting and escaping infinite loops with jolt</title>
		<author>
			<persName><forename type="first">M</forename><surname>Carbin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Misailovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECOOP 2011-Object-Oriented Programming</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="609" to="633" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Program transformations to fix C integers</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Coker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hafiz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM/IEEE International Conference on Software Engineering (ICSE)</title>
		<meeting><address><addrLine>San Francisco, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="792" to="801" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Using mutation to automatically suggest fixes for faulty programs</title>
		<author>
			<persName><forename type="first">V</forename><surname>Debroy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Software Testing, Verification, and Validation</title>
		<meeting><address><addrLine>Paris, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="65" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Automatic Repair of Real Bugs: An Experience Report on the Defects4J Dataset</title>
		<author>
			<persName><forename type="first">T</forename><surname>Durieux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Martinez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Monperrus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sommerard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Xuan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015-05">May 2015</date>
		</imprint>
	</monogr>
	<note>ArXiv e-prints</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Fine-grained and accurate source code differencing</title>
		<author>
			<persName><forename type="first">J</forename><surname>Falleri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Morandat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Blanc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Martinez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Monperrus</surname></persName>
		</author>
		<idno type="DOI">10.1145/2642937.2642982</idno>
		<ptr target="http://doi.acm.org/10.1145/2642937.2642982" />
	</analytic>
	<monogr>
		<title level="m">ACM/IEEE International Conference on Automated Software Engineering, ASE &apos;14</title>
		<meeting><address><addrLine>Vasteras, Sweden</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">September 15 -19, 2014, 2014</date>
			<biblScope unit="page" from="313" to="324" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">The current state and future of search based software engineering</title>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM/IEEE International Conference on Software Engineering (ICSE)</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="342" to="357" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Automated patching techniques: the fix is in: technical perspective</title>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="108" to="108" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The impact of tangled code changes</title>
		<author>
			<persName><forename type="first">K</forename><surname>Herzig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zeller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Mining Software Repositories (MSR), 2013 10th IEEE Working Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="121" to="130" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Modeling bug report quality</title>
		<author>
			<persName><forename type="first">P</forename><surname>Hooimeijer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE/ACM International Conference on Automated Software Engineering (ASE)</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="34" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Deckard: Scalable and accurate tree-based detection of code clones</title>
		<author>
			<persName><forename type="first">L</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Misherghi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Glondu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICSE</title>
		<imprint>
			<biblScope unit="page" from="96" to="105" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Automated atomicity-violation fixing</title>
		<author>
			<persName><forename type="first">G</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liblit</surname></persName>
		</author>
		<idno type="DOI">10.1145/1993498.1993544</idno>
		<ptr target="http://doi.acm.org/10.1145/1993498.1993544" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 32Nd ACM SIGPLAN Conference on Programming Language Design and Implementation, ser. PLDI &apos;11</title>
		<meeting>the 32Nd ACM SIGPLAN Conference on Programming Language Design and Implementation, ser. PLDI &apos;11<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="389" to="400" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Defects4J: A database of existing faults to enable controlled testing studies for Java programs</title>
		<author>
			<persName><forename type="first">R</forename><surname>Just</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Jalali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Ernst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Software Testing and Analysis (ISSTA)</title>
		<meeting>the International Symposium on Software Testing and Analysis (ISSTA)<address><addrLine>San Jose, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-07">July 2014</date>
			<biblScope unit="page" from="437" to="440" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Non-essential changes in version histories</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kawrykow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Robillard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd International Conference on Software Engineering</title>
		<meeting>the 33rd International Conference on Software Engineering</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="351" to="360" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Repairing programs with semantic code search</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">T</forename><surname>Stolee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">Le</forename><surname>Goues</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Brun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th IEEE/ACM International Conference On Automated Software Engineering (ASE)</title>
		<meeting>the 30th IEEE/ACM International Conference On Automated Software Engineering (ASE)<address><addrLine>Lincoln, NE, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-11">November 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Automatic patch generation learned from human-written patches</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Nam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2013 35th International Conference on Software Engineering (ICSE)</title>
		<imprint>
			<date type="published" when="2013-05">May 2013</date>
			<biblScope unit="page" from="802" to="811" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Genetic programming: On the programming of computers by means of natural selection</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Koza</surname></persName>
		</author>
		<ptr target="http://miriad" />
	</analytic>
	<monogr>
		<title level="m">Iip6. fr/microbes Modeling Adaptive Multi-Agent Systems Inspired by Developmental Biology</title>
		<imprint>
			<date type="published" when="1992">1992. 1992</date>
			<biblScope unit="volume">229</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Should fixing these failures be delegated to automated program repair</title>
		<author>
			<persName><forename type="first">X.-B</forename><forename type="middle">D</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T.-D</forename><forename type="middle">B</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">26th IEEE International Symposium on Software Reliability Engineering (ISSRE)</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A systematic study of automated program repair: Fixing 55 out of 105 bugs for 8 each</title>
		<author>
			<persName><forename type="first">C</forename><surname>Le Goues</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dewey-Vogt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Forrest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Software Engineering (ICSE), 2012 34th International Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="3" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Genprog: A generic method for automatic software repair</title>
		<author>
			<persName><forename type="first">C</forename><surname>Le Goues</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Forrest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="54" to="72" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Representations and operators for improving evolutionary software repair</title>
		<author>
			<persName><forename type="first">C</forename><surname>Le Goues</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Forrest</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Genetic and Evolutionary Computation Conference</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Soule</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Moore</surname></persName>
		</editor>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="959" to="966" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Bug isolation via remote program sampling</title>
		<author>
			<persName><forename type="first">B</forename><surname>Liblit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">X</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">I</forename><surname>Jordan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGPLAN Conference on Programming Language Design and Implementation (PLDI)</title>
		<meeting><address><addrLine>San Diego, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="141" to="154" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Prophet: Automatic patch generation via learning from successful patches</title>
		<author>
			<persName><forename type="first">F</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</title>
		<meeting>the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Do the fix ingredients already exist? an empirical inquiry into the redundancy assumptions of program repair approaches</title>
		<author>
			<persName><forename type="first">M</forename><surname>Martinez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Monperrus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Companion Proceedings of the 36th International Conference on Software Engineering</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="492" to="495" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Directfix: Looking for simple program repairs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mechtaev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Roychoudhury</surname></persName>
		</author>
		<ptr target="http://dl.acm.org/citation.cfm?id=2818754.2818811" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 37th International Conference on Software Engineering</title>
		<meeting>the 37th International Conference on Software Engineering<address><addrLine>Piscataway, NJ, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="448" to="458" />
		</imprint>
	</monogr>
	<note>ser. ICSE &apos;15</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">A critical review of automatic patch generation learned from human-written patches: essay on the problem statement and the evaluation of automatic software repair</title>
		<author>
			<persName><forename type="first">M</forename><surname>Monperrus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th International Conference on Software Engineering</title>
		<meeting>the 36th International Conference on Software Engineering</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="234" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Semfix: Program repair via semantic analysis</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">D T</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Qi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Roychoudhury</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chandra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2013 35th International Conference on Software Engineering (ICSE)</title>
		<imprint>
			<date type="published" when="2013-05">May 2013</date>
			<biblScope unit="page" from="772" to="781" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Exterminator: Automatically correcting memory errors with high probability</title>
		<author>
			<persName><forename type="first">G</forename><surname>Novark</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">D</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">G</forename><surname>Zorn</surname></persName>
		</author>
		<idno type="DOI">10.1145/1250734.1250736</idno>
		<ptr target="http://doi.acm.org/10.1145/1250734.1250736" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th ACM SIGPLAN Conference on Programming Language Design and Implementation, ser. PLDI &apos;07</title>
		<meeting>the 28th ACM SIGPLAN Conference on Programming Language Design and Implementation, ser. PLDI &apos;07<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="1" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">An experimental determination of sufficient mutant operators</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Offutt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rothermel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Untch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zapf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Software Engineering and Methodology (TOSEM)</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="99" to="118" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">The class-level mutants of mujava</title>
		<author>
			<persName><forename type="first">J</forename><surname>Offutt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-S</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-R</forename><surname>Kwon</surname></persName>
		</author>
		<idno type="DOI">10.1145/1138929.1138945</idno>
		<ptr target="http://doi.acm.org/10.1145/1138929.1138945" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2006 International Workshop on Automation of Software Test, ser. AST &apos;06</title>
		<meeting>the 2006 International Workshop on Automation of Software Test, ser. AST &apos;06<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="78" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Perkins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Amarasinghe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bachrach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Carbin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pacheco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Sherwood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sidiroglou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Sullivan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-F</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Automatically patching errors in deployed software</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Zibin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ernst</surname></persName>
		</author>
		<author>
			<persName><surname>Rinard</surname></persName>
		</author>
		<idno type="DOI">10.1145/1629575.1629585</idno>
		<ptr target="http://doi.acm.org/10.1145/1629575.1629585" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGOPS 22Nd Symposium on Operating Systems Principles, ser. SOSP &apos;09</title>
		<meeting>the ACM SIGOPS 22Nd Symposium on Operating Systems Principles, ser. SOSP &apos;09<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="87" to="102" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">The strength of random search on automated program repair</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Qi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="254" to="265" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">An analysis of patch plausibility and correctness for generate-and-validate patch generation systems</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Qi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Achour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">An analysis of patch plausibility and correctness for generate-and-validate patch generation systems</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Qi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Achour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 International Symposium on Software Testing and Analysis</title>
		<meeting>the 2015 International Symposium on Software Testing and Analysis<address><addrLine>Baltimore, MD, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-07-12">2015. July 12-17, 2015, 2015</date>
			<biblScope unit="page" from="24" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">A large scale study of programming languages and code quality in github</title>
		<author>
			<persName><forename type="first">B</forename><surname>Ray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Posnett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Filkov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Devanbu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering</title>
		<meeting>the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="155" to="165" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">Countering network worms through automatic patch generation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sidiroglou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Keromytis</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Dira: Automatic detection, identification and repair of control-hijacking attacks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Smirnov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T.-C</forename><surname>Chiueh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<publisher>Citeseer</publisher>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Is the cure worse than the disease? overfitting in automated program repair</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">K</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Barr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">Le</forename><surname>Goues</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Brun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Software Engineering Conference and ACM SIGSOFT International Symposium on Foundations of Software Engineering (ESEC/FSE)</title>
		<meeting><address><addrLine>Bergamo, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-09">Sep. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">The economic impacts of inadequate infrastructure for software testing</title>
		<author>
			<persName><forename type="first">G</forename><surname>Tassey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">RTI Project</title>
		<imprint>
			<biblScope unit="volume">7007</biblScope>
			<biblScope unit="issue">011</biblScope>
			<date type="published" when="2002">2002</date>
		</imprint>
		<respStmt>
			<orgName>National Institute of Standards and Technology</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">On the hardness of graph isomorphism</title>
		<author>
			<persName><forename type="first">J</forename><surname>Torán</surname></persName>
		</author>
		<idno type="DOI">10.1137/S009753970241096X</idno>
		<ptr target="http://dx.doi.org/10.1137/S009753970241096X" />
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1093" to="1108" />
			<date type="published" when="2004-05">May 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Leveraging program equivalence for adaptive program repair: Models and first results</title>
		<author>
			<persName><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Fry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Forrest</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2013 IEEE/ACM 28th International Conference on Automated Software Engineering (ASE)</title>
		<imprint>
			<date type="published" when="2013-11">Nov 2013</date>
			<biblScope unit="page" from="356" to="366" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">How long will it take to fix this bug?</title>
		<author>
			<persName><forename type="first">C</forename><surname>Weiss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Premraj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Zimmermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zeller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Workshop on Mining Software Repositories</title>
		<meeting><address><addrLine>Minneapolis, MN, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Closegraph: mining closed frequent graph patterns</title>
		<author>
			<persName><forename type="first">X</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ninth ACM SIGKDD international conference on Knowledge discovery and data mining</title>
		<meeting>the ninth ACM SIGKDD international conference on Knowledge discovery and data mining</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="286" to="295" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
