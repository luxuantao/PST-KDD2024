<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Smart Meter Aggregation via Secret-Sharing</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">George</forename><surname>Danezis</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Microsoft Research</orgName>
								<address>
									<settlement>Cambridge</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Cédric</forename><surname>Fournet</surname></persName>
							<email>fournet@microsoft.com</email>
							<affiliation key="aff0">
								<orgName type="institution">Microsoft Research</orgName>
								<address>
									<settlement>Cambridge</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Markulf</forename><surname>Kohlweiss</surname></persName>
							<email>markulf@microsoft.com</email>
							<affiliation key="aff0">
								<orgName type="institution">Microsoft Research</orgName>
								<address>
									<settlement>Cambridge</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Santiago</forename><surname>Zanella-Béguelin</surname></persName>
							<email>santiago@microsoft.com</email>
							<affiliation key="aff0">
								<orgName type="institution">Microsoft Research</orgName>
								<address>
									<settlement>Cambridge</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Smart Meter Aggregation via Secret-Sharing</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">9A13BE968E1C1B8AF79E15E21FE8682C</idno>
					<idno type="DOI">10.1145/2516930.2516944</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:01+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Secure multi-party computation</term>
					<term>secret-sharing</term>
					<term>smart metering</term>
					<term>privacy</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We design and prototype protocols for processing smartmeter readings while preserving user privacy. We provide support for computing non-linear functions on encrypted readings, implemented by adapting to our setting efficient secret-sharing-based secure multi-party computation techniques. Meter readings are jointly processed by a (public) storage service and a few independent authorities, each owning an additive share of the readings. For non-linear processing, these parties consume pre-shared materials, produced by an off-line trusted third party. This party never processes private readings; it may be implemented using trusted hardware or somewhat homomorphic encryption. The protocol involves minimal, off-line support from the meters-a few keyed hash computations and no communication overhead.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Smart metering deployments have been plagued with privacy concerns <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10]</ref>. As a result, data protection authorities have recognized that fine grained readings are personal information, and as such should be processed in line with data protection principles, such as "data minimization" <ref type="bibr" target="#b13">[14]</ref> that dictates the minimal amount of information should be collected or made available to third parties to fulfill their business needs. Specific privacy technologies have been developed in the context of smart metering architectures, to minimize the information necessary to perform common tasks such as generating aggregate statistics <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b21">22]</ref> or computing bills <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b20">21]</ref> (see <ref type="bibr" target="#b12">[13]</ref> for a survey).</p><p>This work aims to expand the reach of these privacy technologies significantly, by allowing the computation of complex, non-linear functions on encrypted meter readings. This functionality goes beyond linear bills and aggregates <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b21">22]</ref>, and does not require interaction with a user device, as prior work did <ref type="bibr" target="#b20">[21]</ref>. Yet, it uses a similar security model as previous mechanisms <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b16">17]</ref> with multiple honest-butcurious parties. Our solution is based on extending these mechanisms with ideas from modern secret-sharing-based secure multi-party computation literature <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b5">6]</ref>.</p><p>Throughout this paper we use motivating examples directly inspired by problems related to smart metering <ref type="bibr" target="#b7">[8]</ref>:</p><p>• Line Fraud detection. Given encrypted readings of the voltage across the meters of two homes adjacent on a power line, a utility company wishes to determine if the voltage drop is suspiciously large. This may indicate someone stealing electricity directly from the line. Yet, ideally, the exact voltage at each meter or their exact difference should not be made available, unless there is a significant drop.</p><p>• Meter short-cut detection. In a normal setting, households adjacent on a power line should see a decreasing voltage across their meters. Yet, when someone shorts their meter to commit fraud, the reading will be lower than the two households on either side. This check needs to be made without revealing any other information about voltages.</p><p>• Non-linear billing. Demand-response systems direct or broadcast "back-off" signals to households at times of peak demand. Following such a signal, energy consumed above a predetermined threshold is billed at a very high tariff, to provide incentives to reduce demand. We show how such a non-linear billing mechanism can be implemented.</p><p>• Advanced statistics. Current aggregation schemes provide linear statistics, in the form of weighted sums over collections of readings. We show how to extract higher order statistics such as the variance of a collection of readings.</p><p>We will describe all building blocks we use to support the applications above, and evaluate their specific performance.</p><p>In the rest of this paper, we first review related work, on which we heavily rely; we then go on describing our system assumptions, adversary models, and security assumptions; we then give a description of the types of computations we support, their cost and how they compose; finally we present our preliminary experimental results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">BACKGROUND &amp; RELATED WORK</head><p>A thorough survey of privacy technologies applicable to smart metering exists <ref type="bibr" target="#b12">[13]</ref>, so here we limit ourselves to works that are directly relevant to the problem at hand.</p><p>Smart metering privacy protocols. Privacy-friendly aggregation has received a lot of attention: the aim of those protocols is for a utility to reveal the sum of readings from multiple meters without learning the readings themselves. Kursawe et al. <ref type="bibr" target="#b14">[15]</ref> concurrently with Shi et al. <ref type="bibr" target="#b21">[22]</ref> have presented a set of efficient aggregation protocols. In both schemes, meters generate readings (ri) that are blinded by additive shares (si) summing to zero (i.e. i si = 0, where all arithmetic is done modulo 2 32 ). Thus when the blinded readings (bi = si + ri) are revealed and summed, shares cancel out and the sum of the readings is revealed (i.e.</p><p>i bi = i ri). These protocols are very efficient but suffer from inflexibility: the groups of meters that can be aggregated are static, and missing readings prevent the computation of the aggregate. Furthermore, the details of computing the shares at each meter require some data per other meter in each group, and thus the size of groups is restricted and their membership is static. Finally, only simple sums of readings can be computed, which is a valuable but restricted statistic. Yet, this protocol is advantageous enough to form the basis of a mid-size trial in the Netherlands <ref type="bibr" target="#b7">[8]</ref>.</p><p>A number of protocols attempt to improve the robustness of aggregation, and allow for missing readings without jeopardizing computations. Jawurek and Kerschbaum <ref type="bibr" target="#b10">[11]</ref> propose a novel model for such protocols, which also forms the basis of our threat model and security assumptions. They consider the participation of additional "authorities" that facilitate the protocol, but do not learn any secrets (or readings) in the process. The key trust assumption is that at least one of the authorities is honest-if they are all corrupt and collude, then the protocol does not provide any privacy.</p><p>Also in a security model with authorities, Barthe et al. <ref type="bibr" target="#b0">[1]</ref> propose an efficient robust aggregation protocol, as follows: for each reading ri, the meter and each authority compute a set of shares that sum up to zero (i.e. j sij = 0). The meter then simply outputs a version of the reading blinded with its share (i.e. bi = ri +si0). With the help of all authorities, any linear aggregate of readings can be computed. For example, if the utility wishes to compute R = α • r1 + β • r2, it would compute the linear sum on the blinded readings B = α • b1 + β • b2, and request from each authority the same linear sum on the shares they hold for these readings Sa = α•s1a +β •s2a, where a ranges over the authorities. The aggregate can then be computed as R = B + a Sa, and their approach generalizes to computing any weighted sum. The selection of readings to be summed can be dynamic, and thus missing readings can simply be omitted (or implicitly be assigned a weight of zero). Furthermore, multiple readings per meter can be used, leading to a very efficient implementation of a linear time-of-use billing mechanism. All values exchanged are small, computations are linear and on small integers, and the contributions from the authorities can be collected ahead of time. Finally, additive noise can be added to make the aggregate differentially private <ref type="bibr" target="#b0">[1]</ref>.</p><p>The obvious limitation of these protocols is their inability to compute anything non-linear, for instance involving multiplications of secret readings, thresholds, comparisons between secret readings, etc. Three broad approaches have been proposed to run arbitrary computations on encrypted readings. The obvious approach is to provide all necessary readings to a trusted third party, and allow them to be decrypted to compute any function in clear. Relying on a single fully-trusted party is dangerous since implementing them well is expensive, and they could be compromised, collude with an adversary, or be compelled to reveal secrets. A second approach is to rely on fully homomorphic encryption <ref type="bibr" target="#b22">[23]</ref> but, in practice, such schemes remain too expensive for industrial applications, and still rely on the controlled decryption of final results <ref type="bibr" target="#b6">[7]</ref>. The final approach is to reflect the encrypted readings to a user device, decrypt them there, compute any function, and return the result alongside a zero-knowledge proof of correctness <ref type="bibr" target="#b20">[21]</ref>. This approach is surprisingly general, but its proofs can be expensive, it is only available for computing on data from a single household, and it requires interaction with some user device.</p><p>Computations using secret shares. The approach for performing computations on "encrypted" readings we present consists of a cut-down and optimized set of protocols inspired by recent work on secure multi-party computation using secret shares. In this setting, a user splits a secret into shares adding up to the secret value, i.e. ri = j sij, where the shares are usually denoted as ri , and distributes them to a number of authorities. Unless all authorities collude, the secret remains confidential. The aim of those authorities is to use their shares to jointly compute on the secret values, without revealing any intermediate results-a general problem in the realm of secure multi-party computation.</p><p>Applying linear functions in the secrets shared is a relatively easy task, that relates with the efficient aggregation protocol of Barthe et al. <ref type="bibr" target="#b0">[1]</ref>. It can be easily derived that the share of the sum of two secrets is simply the sum of shares of each secret (i.e. v + w = v + w ). Similarly, the share of a secret multiplied with a public value is simply the product of the share of the secret multiplied by the same value, i.e. α • v = α • v . While linear functions can be computed by each authority using only local shares of secrets that are combined to reveal the result, as in the linear sum example above, the same does not hold for multiplications of secrets.</p><p>The multiplication of two secrets requires some interaction between the parties that hold shares, as well as pre-shared state <ref type="bibr" target="#b4">[5]</ref>. First of all, we assume that all authorities have preshared, ahead of time and independently of the computation to be performed, a large number of triplets of shares a , b and c where a and b are random and c = a • b. We call those secrets "multiplication triplets"; §6 discusses options for deriving them in a smart metering setting. Using one of those triplets makes multiplication of two shared secrets possible through a single round of interaction: to multiply x and y , all authorities first compute and reveal their shares of = x + a and δ = y + b , enabling them to reconstruct and δ (which are statistically independent of x and y). The authorities then privately compute their shares of the product</p><formula xml:id="formula_0">x•y = c -• b -δ • a + •δ.</formula><p>This enables us to evaluate general arithmetic circuits, consuming a preshared triplet for each multiplication, with as many rounds of interaction as the multiplicative depth of the circuit.</p><p>In particular, the availability of multiplication on shared secrets enables the computation of any boolean circuit. Assuming secrets ranging over {0, 1} we can express NOT, AND, NAND, NOR and XOR gates directly as NOT <ref type="bibr" target="#b19">[20]</ref> and XOR(a, b) = (a -b) 2 . Each of these gates uses (at most) one multiplication, together with linear operations; thus evaluating a boolean circuit on shared secrets requires as many triplets as gates, and requires as many rounds of interaction as the depth of the circuit.</p><formula xml:id="formula_1">(a) = 1 -a; AND(a, b) = a • b; NAND(a, b) = 1 -a • b; NOR(a, b) = (1 -a)(1 -b)</formula><p>Boolean circuits operate on secret bits, but readings are usually larger integers. It is trivial to convert a vector of bit shares to an integer share using linear operations (i.e., v = i 2 i bi ). The converse decomposition of an integer into its binary representation is a more complex operation, for which we use a variant of the protocol by <ref type="bibr">Damgård et al. [4]</ref>. This protocol relies on pre-shared random bits bi . These, like the multiplication triplets, can be generated and shared before the computation takes place. Converting an n-bit shared number v to shares of its constituent n bits requires n pre-shared bits bi. The protocol proceed as follows: all authorities compute and reveal their share of d = vi 2 i bi (which is statistically independent from v), then decompose d into bits ui (d = i 2 i ui). The authorities use these bits, together with the secret bits bi , as inputs to a boolean circuit performing addition (implemented using any logic gates available). This circuit outputs shared bits hi such that v = i 2 i hi. The choice of the addition circuit can have profound implications on the efficiency of this protocol; we use a variant of Ladner and Fischer's adder with parallel prefix computation <ref type="bibr" target="#b15">[16]</ref> that minimizes the circuit depth, while increasing the fan out (which is not an issue for us).</p><p>Other general-purpose implementations of secret-sharing schemes and multi-party computation <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b17">18]</ref> also embed integrity-protection mechanisms, and sometimes support faster comparisons. We are investigating how to integrate and adapt their features to the context of smart metering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">SYSTEM MODEL</head><p>Protocol participants &amp; goals. Smart metering infrastructures involve the installation of next generation energy meters in user homes, to serve diverse needs. In our protocols, we assume that each smart meter is installed in a specific household (or user ) and monitors a number of variables such as volume of energy consumed, or voltage across the supply line regularly (e.g. 2 times per hour) to generate fine grained readings. Optionally, we assume that users have access to some form of modern computing device connected to the Internet. This user device can be a computer, a smart phone, a set-top box, a game console, or a user controlled online server or service. Meter readings are periodically (e.g. once a day) collected and uploaded to a storage service. This service can be a traditional large scale distributed database that keeps track of readings and their meta-data.</p><p>Queries can be submitted to the storage service, requesting the computation of certain statistics on the stored data, by a number of entities in the energy industry (producers, suppliers, distributors, or the grid). The storage service is in charge of initiating and orchestrating all protocols required to answer a query. It is useful to split queries into two categories: single-household and multi-household. Single household queries are executed on data from a single household, for example to compute its time-of-use bill, or to profile a single household's consumption pattern into one of many categories. A multi-household query, such as the total volume of energy consumed in an area, or by the customers of a single supplier, uses data from many households.</p><p>Our protocols are concerned with privacy-friendly computations. Thus the storage service will need to enlist the help of a number of other parties to authorize and compute queries. We assume the availability of a small number of authorities that help answer queries. Those authorities are only interacting with the storage service and, given a query, release just enough information to allow the result to be computed. We assume that the authorities are connected to the storage service through a low-latency high-bandwidth network. In addition to the authorities, our protocols optionally uses one or multiple randomness services with specific properties-we discuss these in some depth later.</p><p>Security properties, assumptions &amp; threat model. Our fundamental aim relates to privacy: to answer authorized queries without leaking any other information about stored readings. More precisely, we assume that meters are certified devices that act honestly in accordance to our protocolsthis is an inherent limitation of any technology in this space.</p><p>If the meter acts outside the policy, or could be controlled by an adversary, they could bypass any protection for their readings. (This important security assumption may not hold in practice, inasmuch as current architectures allow meters to be remotely re-configured and reprogrammed, and their software security is rather poor <ref type="bibr" target="#b18">[19]</ref>.) We also assume that the meters are tamper evident through passive or active triggers, to ensure the correctness of the readings. We do not suggest obscuring in any way the reporting of tamper switches-we aim to protect only the privacy of readings of energy consumption and associated information. Finally, we assume that meters are capable of storing and securing long-term keys for signing readings as well as protecting their privacy.</p><p>The storage service is entrusted to reliably store readings, but should not be in a position to access them in clear. We consider a storage service that is honest but curious, namely it follows the protocol but attempts to draw inferences from its observations. Such a service should not learn anything besides the result of authorized queries. There are a number of ways of extending the protocols of this paper to fully malicious storage services, but we leave this to future work. Yet, to practically discourage malicious behaviour, we design the storage service protocols to be auditable: the service does not hold any secret keys, and thus any transcript of its interactions can be verified for compliance to the protocol by anyone. Such a transcript does not violate privacy.</p><p>Authorities are entrusted to be honest but curious, i.e., to follow the protocol and not deviate from it. Some colluding authorities can, however, pool their shares. As long as all authorities follow the protocol and at least one authority does not collude privacy is not violated. More specifically, all operations an authority performs are parameterized by secret keys, and these long term secrets must not be divulged.</p><p>The integrity and availability of the protocols also depends on the authorities executing the protocol faithfully. In this paper we assume the authorities to be reputable enough to not deviate from the protocol. We are exploring a number of avenues to relax this "honest-but-curious" assumption that permeates the threat model of this work.</p><p>Optionally, our protocols will make use of random data from user devices or randomness services. We assume those to keep the random data confidential. Still, this data does not depend on the readings or queries, so it can be generated and distributed ahead of the shared-secret computation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">PROTOCOLS</head><p>The protocol involves meters Mm, authorities Aa, a storage service S, and a randomness service R. For simplicity, we assume a single, fixed series of authorities for all readings.</p><p>Cryptographic set-up. The set-up ensures that, upon completion, every meter m shares a secret symmetric key sm,a with every authority a. Although any means can be used to establish such secrets for privacy-friendly computations (see e.g. <ref type="bibr" target="#b0">[1]</ref>), we present a technique that minimizes key management for the authorities, allowing them to potentially handle a very large number of meters.</p><p>Upon initialization, each meter generates a key pair of a suitable public-key-encryption scheme. The public key is then certified, by the manufacturer or through a public-key infrastructure, as belonging to a meter with fixed, unique identifier m. Upon initialization, every authority a generates a master secret key sa, that will be used to derive all other keys, and a key pair for a suitable signature scheme.</p><p>To pair a meter m with authorities, each authority a computes their shared secret sm,a = H1(sa|m), where H1 is a key derivation function (modelled as a pseudo-random function or PRF), then it encrypts it under the public key of m and signs it using the public key of a. The message can be relayed through any channel; the meter will check the signature, ensure it corresponds to a valid authority (presumably through a root certificate from the manufacturer or certifier) and then decrypt and install sm,a. As a result, each meter stores one symmetric key for each authority, whereas each authority only needs to store a single master key sa. (In the following for simplicity we assume that the keys sm,a are communicated over a secure channel.)</p><p>Producing readings. Meters use the keys shared with authorities to 'blind' their readings, in a way that requires the cooperation of every authority to recover any information about them (as in <ref type="bibr" target="#b0">[1]</ref>). We assume each reading r m, from meter m is associated with a unique, public label (the sensor identifier and the time period, for example); the corresponding blinded reading is computed as:</p><formula xml:id="formula_2">c m, = r m, -a H2(sm,a| ) mod p (<label>1</label></formula><formula xml:id="formula_3">)</formula><p>where p is the native machine word size (e.g. 2 32 for a 32 bit processor) and H2 is a keyed hash function (also modelled as a PRF) that returns values in 0 . . . p-1. The meter, upon request, then transmits series of pairs ( , c m, ) to the storage service, using whichever authenticated channel is available. Importantly, the label must never be used for blinding any other reading. A safe implementation may for instance rely on a hardware counter included in .</p><p>By construction, the integers {c m, , H2(sm,a| ) for a ∈ a} form shares of an additive secret-sharing scheme: their sum modulo p yields the secret reading r m, . Yet, as long as one share remains secret, the others do not leak any information about the secret reading. The shared keys have allowed us to reduce the cost of transporting a share to a single integer modulo p (while sacrificing perfect secrecy and reducing it to the security of two PRFs and the master keys).</p><p>Preparing random values. The randomness source uses the same approach to efficiently distribute and store multiplication triplets and random bits. Like meters, it follows the</p><formula xml:id="formula_4">shares A 0 H 2 (sm,a 0 | ) H 2 (sr,a 0 | x) H 2 (sr,a 0 | z ) H 2 (sr,a 0 | d ) 0 A 1 H 2 (sm,a 1 | ) H 2 (sr,a 1 | x) H 2 (sr,a 1 | z ) H 2 (sr,a 1 | d ) 0 . . . S c m, 0 c ,z c ,d v r m, x xy d v</formula><p>Table <ref type="table">1</ref>: Shares for private readings r m, , random values x, y, products z, bits d, and public values v.</p><p>setup protocol and shares a symmetric key sr,a with each authority. To share a triplet x, y, z = xy with labels x, y , z , it sets x = a H2(sr,a| x) and y = a H2(sr,a| y ), and computes the blinded value for z as: c ,z = xya H2(sr,a| z ).</p><p>Similarly, to share a random bit d ∈ {0, 1} with label d , it computes the blinded value c ,d = da H2(sr,a| d ). As x and y are random secrets, the storage service does not require values for them and instead uses 0 as its share.</p><p>The whole distribution of random shares is summarized in Table <ref type="table">1</ref>. The last column lets the storage service S add public values only to its local share. We note that the cost of transporting a reading, a random bit, or a whole triplet is merely a single element in p. We are now ready to apply all the techniques from §2 to compute on these secret shares.</p><p>Computations. Upon receiving a query, the storage service communicates it to all authorities. A query consists of instructions on secret shares with specific labels-these instructions are executed on the stored shares by the storage service, and on the derived shares by each authority. The instruction set consists merely of linear weighted sums of shares, revelation of shares, and loading of pre-computed values. Revelation is done through the storage service, which gathers all shares revealed at a specific stage, adds them and broadcasts the result in clear to all authorities. Those few instructions allow us to execute interesting high level computations, using previously discussed techniques, in particular:</p><p>• Weighted sums of shared secrets and public values.</p><p>• Multiplications of shared secrets, at the cost of a shared triplet and a round of revelation.</p><p>• All boolean operations, including OR, AND, NAND, XOR, at the cost of a single multiplication each.</p><p>• Conversions between shares of integers mod p and vectors of shares of their binary representation, which requires pre-shared bits and triplets.</p><p>This set of operations allows us to express any boolean circuit and therefore support any fixed-depth computation. The cost of computing on shares is in terms of the number of rounds of revelation of shares (latency), the number of shares to be revealed (bandwidth), and the number of pre-shared values needed to facilitate operations. Careful arithmetic and circuit optimizations are applied to minimize those.</p><p>Main results. We outline the main properties of our protocol, but refer to prior work for detailed proofs.</p><p>Correctness: the protocol returns the same results as those returned by the source query on the readings. Table <ref type="table">2</ref>: Performance evaluation collections of readings that (1) coincide on corrupted meters; and (2) yield the same query result; 2. Given the trace of the protocol for one of these two collections, the adversary wins if it guesses which of the two is used. The advantage of the adversary reduces to those of H1 and H2 being PRFs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">APPLICATIONS &amp; COST</head><p>We illustrate the feasibility and practicality of using computations on secret shares on the four sample applications discussed in §1. To this end we have implemented the key distribution and secret-sharing-based computation engine in 1,600 lines of Python. Table <ref type="table">2</ref> summarizes the performance for each of the protocols, detailed next. The number of round trips of revelations of intermediate shares measures the impact of network latency between authorities and the storage service (this latency can be shared between many runs of the same protocol on different readings); the number of revealed shares indicates the volume of data transferred between authorities and the storage service (4 bytes per share); finally, the numbers of pre-shared triplets and pre-shared bits gives the intensity of use of the randomness service. The first protocol meanvar computes and reveals all necessary values to extract the mean and the variance or standard deviation of a set of 100 readings. It consists of a linear sum of all readings, then 100 squarings of each of the readings, followed by the sum of all squares. From these the variance can be publicly computed as Var</p><formula xml:id="formula_5">[X] = E[X 2 ] -(E[X]) 2 .</formula><p>Since the squarings do not depend on one another, a shallow multiplication circuit of depth one minimizes latency. Hence, only 200 shares need to be exchanged, in a single 800-byte message from each A. The same number of preshared triplets as multiplications are needed, and each only squares the reading from a single meter. The second protocol compare implements a simple theft prevention mechanism. It accepts readings of the voltage across meters of two consecutive houses on the same distribution line, and checks whether the voltage drop is above a threshold. If the drop is too high, it might indicate that someone is absconding electricity from the line between the two homes. The comparison is performed by subtracting the second reading and the threshold from the first one, and comparing the result with zero. Currently, this is done by decomposing the difference into bits, and testing the highend bit to determine the sign of the number (assuming that the difference fits within 16 bits). We are aware of more efficient comparison protocols <ref type="bibr" target="#b2">[3]</ref>. The resulting protocol takes 11 rounds of communication within which 117 shares are exchanged by each authority and the storage service. The bit decomposition protocol uses 32 pre-shared bits as expected. Another theft prevention protocol compare3way is designed to detect abnormal sequences of voltages cross consecutive households. It takes readings from three consecutive homes on the same line and ensures they are ordered, either in increasing or decreasing order. According to this use case, described in <ref type="bibr" target="#b7">[8]</ref>, if the middle household is shorting the meter, its reading will be lower than the two readings on either side. The protocol compares the difference between the adjacent pairs of households to zero, and requires their sign to be the same (through an XOR illustrating boolean gates). The two comparisons are run in parallel, and the XOR gate requires one round of interaction, resulting in 12 rounds of communication, and 236 shares being exchanged. Finally, demrespbill implements a time-of-use billing mechanism to support demand-response. It takes readings from a single household during 100 overloaded periods for which a "back-off" signal was sent. Each reading is compared with a cut-off consumption and any units of over consumption are billed at a punitive tariff. The sum of all bills over all periods is returned, to further hide when over-consumption occurred. This is achieved by building a binary vector indicating whether there is over-consumption in each period, and multiplying it with the amount to be paid. In case of no over consumption this yields zero, otherwise the amount to be billed. The computation is repeated for 100 periods, and the results summed. All comparisons are run in parallel leading to only 12 rounds of computation. In total 8700 shares are exchanged, and there is a need for 4300 pre-shared triplets and 3200 pre-shared bits. The pre-shared information is used only to blind readings from a single household.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">SOURCES OF RANDOMNESS</head><p>The availability of pre-shared "multiplication triplets" and random bits makes the multi-party protocols efficient and straightforward. Yet, the efficient provision of such values is a key open problem. A corrupt source of randomness that reveals values to the adversary can seriously harm privacy (and less so integrity, since their correctness can be checked at some cost). Here we somewhat depart from the orthodoxy that uses secret-sharing-based multiplication protocols and somewhat homomorphic encryption schemes to compute those values, and consider other available options:</p><p>For single household computations, such as the demandresponse billing protocol, any user device (laptop, mobile phone, game console, or even the meter itself) can provide ahead of time a large number of random values for use in subsequent computations on the household data. Thus we can very cheaply acquire a supply of randomness to cover all use-cases where in past proposals computation was offloaded to a user device <ref type="bibr" target="#b20">[21]</ref>. This option is also applicable to the computation of variance, since the squaring of each meter reading involves only data from a single household.</p><p>A second option is to rely on one or many secure hardware solutions to provide random data. This can be done ahead of time and efficiently. All opportunities, but also worries associated with hardware secure modules would apply.</p><p>Finally, we are exploring a collaborative approach to generating random data, whereas a number of users (or maybe their meters) collaborate to create a pool of randomness to be used across diverse applications. The probability of attack is minimized by making it unlikely that a single adversary can learn a significant or targeted amount of information. We are also working on ways of combining random sources to create a single high-quality random source.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSIONS</head><p>We have demonstrated that complex privacy-friendly computations on smart meter readings are practical, resolving a number of open challenges in billing, statistics and fraud detection. Furthermore, the cost on the meters and the storage required are minimal, and similar to the cost of producing and storing plain unprotected readings. Evaluating linear functions is simple. Thanks to offline sources of correlated randomness, evaluating more complex functions is comparable in terms of computation, but incurs communications bandwidth and latency overheads proportional to the number and depth of multiplications in the circuit, respectively.</p><p>We argued that, for smart metering, user devices can produce cheaply random values needed to fuel some protocols that compute on a single household. This pattern of private outsourced computation is likely to apply to other settings. Yet, how to acquire secure random values efficiently in general remains an open problem. Similarly, extending the protocols to the setting where the storage service or authorities are actively dishonest is left for future work. For both, recent progress in implementation of general-purpose multi-party computation offers valuable insights and reasons for optimism. Given sufficient business interest, there is evidence of a Moore's law for privacy-friendly secure computations.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>def meanvar (c, readings ): rsum = c. linear ([1] * 100, readings ) rsquares = [c.mult(x, x) for x in readings ] rsumsquares = c. linear ([1] * 100, rsquares ) return [rsum , rsumsquares ]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>def compare (c, rA , rB , Thld ): diff = c. linear ([1, -1], [rA , rB], -Thld) bits , _ = c. tobits (diff) return c.gneg(bits[-16])</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>def compare3way (c, rA , rB , rC ): diff1 = c. linear ([1 , -1], [rA , rB ]) diff2 = c. linear ([1 , -1], [rB , rC ]) bits1 , _ = c. tobits ( diff1 ) bits2 , _ = c. tobits ( diff2 ) return c.gxor( bits1[-16], bits2[-16])</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>def greaterthan (c, readingA , cutoff ): diff = c. linear ([1] , [ readingA ], -cutoff ) bits , _ = c. tobits (diff) return c.gneg(bits[-16]) def demrespbill (c, readings , cutoff , penalty ): free , cut = penalty * cutoff , [] for r in readings : gt = greaterthan (c, r, cutoff ) excess = c. linear ([ penalty ], [r], -free) cut += [c.mult(excess , gt )] return c. linear ([1] * 100 , cut)</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Privacy: provided at least one authority is securely implemented, the protocol leaks no other information on the readings. More precisely, consider the following game 1. After set-up, given the private states for some meters and for all-but-one authorities, the adversary chooses two</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Verified computational differential privacy with applications to smart metering</title>
		<author>
			<persName><forename type="first">G</forename><surname>Barthe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Danezis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Grégoire</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kunz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zanella-Béguelin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">26th IEEE Computer Security Foundations Symposium, CSF 2013</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Sharemind: A framework for fast privacy-preserving computations</title>
		<author>
			<persName><forename type="first">D</forename><surname>Bogdanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Laur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Willemson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Security -ESORICS 2008</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5283</biblScope>
			<biblScope unit="page" from="192" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Improved primitives for secure multiparty integer computation</title>
		<author>
			<persName><forename type="first">O</forename><surname>Catrina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">De</forename><surname>Hoogh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Security and Cryptography for Networks, SCN 2010</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6280</biblScope>
			<biblScope unit="page" from="182" to="199" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Unconditionally secure constant-rounds multi-party computation for equality, comparison, bits and exponentiation</title>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fitzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kiltz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Nielsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Toft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">3rd Theory of Cryptography Conference</title>
		<imprint>
			<date type="published" when="2006">2006. 2006</date>
			<biblScope unit="volume">3876</biblScope>
			<biblScope unit="page" from="285" to="304" />
		</imprint>
	</monogr>
	<note>TCC</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Practical covertly secure MPC for dishonest majority -or: Breaking the SPDZ limits</title>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Keller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Larraia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Pastro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Scholl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Smart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="page">642</biblScope>
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Multiparty computation from somewhat homomorphic encryption</title>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Pastro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Smart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zakarias</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO 2012</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7417</biblScope>
			<biblScope unit="page" from="643" to="662" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Towards ensuring client-side computational integrity</title>
		<author>
			<persName><forename type="first">G</forename><surname>Danezis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Livshits</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">3rd ACM Cloud Computing Security Workshop</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="125" to="130" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Implementation of privacy-friendly aggregation for the smart grid</title>
		<author>
			<persName><forename type="first">B</forename><surname>Defend</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kursawe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HotPETS</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Future of privacy summary of California public utilities commission proposed decision on smart grid privacy and security</title>
		<ptr target="http://www.futureofprivacy.org/issues/smart-grid/" />
		<imprint>
			<date type="published" when="2011-05-09">May 9, 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Smart energy meter will not be compulsory</title>
		<author>
			<persName><forename type="first">W</forename><surname>Heck</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009-04">April 2009</date>
			<publisher>NRC Handelsblad</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Fault-tolerant privacy-preserving statistics</title>
		<author>
			<persName><forename type="first">M</forename><surname>Jawurek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Kerschbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th Intl. Symp. on Privacy Enhancing Technologies, PETS 2012</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7384</biblScope>
			<biblScope unit="page" from="221" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Plug-in privacy for smart metering billing</title>
		<author>
			<persName><forename type="first">M</forename><surname>Jawurek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Johns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Kerschbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">11th Intl. Symp. on Privacy Enhancing Technologies</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011. 2011</date>
			<biblScope unit="volume">6794</biblScope>
			<biblScope unit="page" from="192" to="210" />
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Privacy technologies for smart grids -a survey of options</title>
		<author>
			<persName><forename type="first">M</forename><surname>Jawurek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Kerschbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Danezis</surname></persName>
		</author>
		<ptr target="http://research.microsoft.com/apps/pubs/?id=178055" />
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Smart metering under EU data protection law</title>
		<author>
			<persName><forename type="first">R</forename><surname>Knyrim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Trieb</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Intl. Data Privacy Law</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="121" to="128" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Privacy-friendly aggregation for the smart-grid</title>
		<author>
			<persName><forename type="first">K</forename><surname>Kursawe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Danezis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kohlweiss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">11th Intl. Symp. on Privacy Enhancing Technologies</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011. 2011</date>
			<biblScope unit="volume">6794</biblScope>
			<biblScope unit="page" from="175" to="191" />
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Parallel prefix computation</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Ladner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Fischer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="831" to="838" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Efficient privacy-preserving stream aggregation in mobile sensing with low aggregation error</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Cao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">13th Intl. Symp. on Privacy Enhancing Technologies, PETS 2013</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">7981</biblScope>
			<biblScope unit="page" from="60" to="81" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Fairplay-secure two-party computation system</title>
		<author>
			<persName><forename type="first">D</forename><surname>Malkhi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Nisan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="287" to="302" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Security and privacy challenges in the smart grid. Security &amp; Privacy</title>
		<author>
			<persName><forename type="first">P</forename><surname>Mcdaniel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mclaughlin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="75" to="77" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Pinocchio: Nearly practical verifiable computation</title>
		<author>
			<persName><forename type="first">B</forename><surname>Parno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Howell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Raykova</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2013 IEEE Symp. on Security and Privacy</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="238" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Privacy-preserving smart metering</title>
		<author>
			<persName><forename type="first">A</forename><surname>Rial</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Danezis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">10th annual ACM workshop on Privacy in the electronic society, WPES 2011</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="49" to="60" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Privacy-preserving aggregation of time-series data</title>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T.-H</forename><forename type="middle">H</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">G</forename><surname>Rieffel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Chow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2011 Network and Distributed System Security Symposium, NDSS 2011</title>
		<imprint>
			<publisher>The Internet Society</publisher>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Fully homomorphic encryption with relatively small key and ciphertext sizes</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Smart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Vercauteren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Public Key Cryptography -PKC 2010</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6056</biblScope>
			<biblScope unit="page" from="420" to="443" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
