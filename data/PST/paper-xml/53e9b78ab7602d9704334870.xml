<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">UML 2.0 and Agents: How to Build Agent-based Systems with the new UML Standard</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Bernhard</forename><surname>Bauer</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Programming of Distributed Systems</orgName>
								<orgName type="department" key="dep2">Institute of Computer Science</orgName>
								<orgName type="institution">University of Augsburg</orgName>
								<address>
									<postCode>D-86135</postCode>
									<settlement>Augsburg</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">James</forename><surname>Odell</surname></persName>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Agentis Software</orgName>
								<address>
									<settlement>Ann Arbor</settlement>
									<region>Michigan</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">UML 2.0 and Agents: How to Build Agent-based Systems with the new UML Standard</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">9A1036F2FCFAF2AE35DD48AC36B4DE31</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T02:15+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>UML 2.0</term>
					<term>Agent-based Systems</term>
					<term>agent-oriented Software Engineering</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>UML 2.0 is the upcoming standard of the OMG for specifying object-oriented software systems. In this paper we will show how UML 2.0 can be applied for the specification of agent-based systems. Moreover we will give a short overview on existing agent methodologies to have a reference what has to be specified in such systems. The paper concludes with some outlook for further research and open issues for specifying agents with UML 2.0.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Software engineering techniques are a key prerequisite of running successful software projects. Without a sufficient approach and adequate tools to support the development of software systems, it is virtually impossible to cope with the complexity of commercial software development processes. This tendency will increase over the years to come and appropriate software engineering methods will continually be in high demand. A software methodology is typically characterized by a modeling language -used for the description of models, defining the elements of the model together with a specific syntax (notation) and associated semantics -and a software process -defining the development activities, the interrelationships among the activities, and how the different activities are performed. In particular, the software process defines phases for process and project management as well as quality assurance. Each activity results in one or more deliverables -such as specification documents, analysis models, designs, code, testing specifications, testing reports, performance evaluation reports, etc. -serving as input for subsequent activities.</p><p>The three key phases that one is likely to find in any software engineering process are that of analysis, design and implementation. In a strict waterfall model these are the only phases; more recent software development process models employ a "round-trip engineering" approach, i.e., provide an iteration of smaller granularity cycles, in which models developed in earlier phases can be refined and adapted in later phases.</p><p>Agent technology enables the realization of complex software systems characterized by situation awareness and intelligent behavior, a high degree of distribution, as well as mobility support. Agent technology has the potential to play a key role in enabling intelligent applications and services by improving automation of routine processes, and supporting the nomadic users with pro-active and intelligent assistance based on principles of adaptation and self-organization. Hence, agent technology can open the way to new application domains while supporting the integration of existing and new software, and make the development process for such applications easier and more flexible. However, deploying agent technology successfully in industrial applications requires industrial-quality software methods and explicit engineering tools, such as UML 2.0. Therefore we will take a closer look at the new UML standard and its application to agent-bases systems.</p><p>This paper is structured as follows. In Section 2 we give a short overview on agent methodologies and notations to have a reference what has to be specified in agent-based systems. The main chapter is Section 3 showing the different UML diagrams and their application for agent-based systems.</p><p>Moreover we apply the model-driven architecture of the OMG for the specification of agent-based systems. The paper concludes with some open issues using UML 2.0 for the specification of such systems and concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Short Overview on Agent Methodologies and Notations</head><p>A considerable number of agent-oriented methodologies and tools are available today, and the agent community is facing the problem of identifying a common vocabulary to support them (for details see our work in <ref type="bibr" target="#b46">[49]</ref>, this section is based on it). There is a considerable interest in the agent R&amp;D community in methods and tools for analyzing and designing complex agent-based software systems, including various approaches to formal specification (see <ref type="bibr" target="#b0">[1]</ref> for a survey). Since 1996, agent-based software engineering has been in the focus of the ATAL workshop series; it also was the main topic of the 1999 MAAMAW workshop <ref type="bibr" target="#b1">[2]</ref>. Various researchers have developed methodologies for agent design, touching on representational mechanisms, like the GAIA methodology <ref type="bibr" target="#b5">[6]</ref> or the extensive program underway at the Free University of Amsterdam on compositional methodologies for requirements <ref type="bibr" target="#b6">[7]</ref>, design <ref type="bibr" target="#b7">[8]</ref>, and verification <ref type="bibr" target="#b8">[9]</ref>. In <ref type="bibr" target="#b4">[5]</ref> [4], <ref type="bibr">Kinny et al.</ref> propose a modeling technique for BDI agents. The close affinity between design mechanisms employed for agent-based system and those used for object-oriented systems is shared by a number of authors, for example, <ref type="bibr" target="#b20">[21]</ref>. In particular, since 2000, the Agent-Oriented Software Engineering Workshop (AOSE) has become the major forum for research carried out on these topics, including new methodologies such as Tropos <ref type="bibr" target="#b30">[31]</ref>, Prometheus <ref type="bibr">[40]</ref>, and MESSAGE <ref type="bibr" target="#b18">[19]</ref>. Currently, most industrial methodologies are based on the Object Management Group's (OMG) Unified Modeling Language (UML) accompanied by process frameworks such as the Rational Unified Process (RUP), see <ref type="bibr" target="#b32">[33]</ref> for details. The Model-Driven Architecture (MDA <ref type="bibr" target="#b41">[44]</ref>) from the OMG allows a cascade if code generations from high-level models (platform independent model) via platform dependent models to directly executable code (see section 3.2 for details). Another approach for agile software engineering that has been receiving active coverage is Extreme Programming <ref type="bibr" target="#b27">[28]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Knowledge Engineering Approaches</head><p>Most early approaches supporting the software engineering of agent-based systems were inspired by the knowledge engineering community. The three most influential methodologies inspired by this strand of research are CommonKADS <ref type="bibr" target="#b30">[31]</ref>, CoMoMAS <ref type="bibr" target="#b29">[30]</ref> and MAS-CommonKADS <ref type="bibr" target="#b9">[10]</ref>. Knowledge engineers need tools and methods to design good knowledge-based systems (KBS), however this relies on knowledge engineer abilities. The CommonKADS methodology was developed to support knowledge engineers in modeling expert knowledge and developing design specifications in textual or diagrammatic form. CommonKADS is a knowledge engineering methodology as well as a knowledge management framework. Two extensions to CommonKADS were developed that take agent-specific aspects into account: CoMoMAS and MAS-CommonKADS. MAS-CommonKADS <ref type="bibr" target="#b9">[10]</ref> adds various extensions to CommonKADS: protocol engineering techniques (namely software development lifecycle and MSC96 <ref type="bibr" target="#b42">[45]</ref>); object-oriented techniques (OMT <ref type="bibr" target="#b43">[46]</ref>[47]) and OOSE); and enhanced support to additional phases within the software life cycle.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Agent oriented Approaches</head><p>A perceived lack of the knowledge engineering software development methodologies was that they were not designed before the background of supporting the development of agent systems, and that hence they had limited capability to support agent-specific functions, which could only partly be overcome by extensions such as seen for MAS-CommonKADS. Gaia <ref type="bibr" target="#b10">[11]</ref> is a methodology for agent-oriented analysis and design supporting macro (societal) level as well as micro (agent) level aspects. Following <ref type="bibr" target="#b10">[11]</ref>, Gaia was designed to deal with coarse-grained computational systems, to maximize some global quality measure, to handle heterogeneous agents independent of programming languages and agent architectures, having static organization structures and agents having static abilities and services, with less then 100 different agent types. ROADMAP extends Gaia by adding elements to deal with the requirements analysis in more detail by using use cases and to handle open systems environments. Moreover it focuses more on the specification of interactions based on AUML <ref type="bibr" target="#b11">[12]</ref>. Another agent-oriented software engineering methodology mainly focusing on societies similar to Gaia's organizations is SODA (Societies in Open and Distributed Agent spaces <ref type="bibr" target="#b13">[14]</ref>). As ROADMAP it addresses some of the shortcomings of Gaia such as the insufficiencies in dealing with open systems or self-interested agents. Moreover SODA takes the agent environment into account and provides mechanisms for specific abstractions and procedures for the design of agent infrastructures. Based on the analysis and design of agent societies (exhibiting the global behaviors not deducible from the behavior of the individual agents) and agent environments (the space where agents live and interact, like open, distributed, decentralized, heterogeneous, dynamic, and unpredictable environment), SODA provides support for modeling the inter-agent aspects. However intra-agent aspects are not covered. Therefore SODA is not a complete methodology; rather, its goal is to define a coherent conceptual framework and a comprehensive software engineering procedure that accounts for the analysis and design of individual agents from a behavioral point of view, agent societies, and agent environments. As most of the considered methodologies do, SODA supports the analysis and design phase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Object oriented Approaches</head><p>A good procedure (if not the only viable one) for successful industrial deployment of agent technology is to present the new technology as an incremental extension of known and trusted methods, and to provide powerful engineering tools that support industry-accepted methods of technology deployment. Accepted methods of industrial software development depend on standard representations for artifacts to support the analysis, specification, and design of agent software. At the moment agent-oriented software engineering is still lacking the availability of suitable software processes and tools. The Unified Modeling Language (UML) is gaining wide acceptance for the representation of engineering artifacts using the object-oriented paradigm. Viewing agents as the next step beyond objects leads several authors (see on a discussion of this topic e.g. <ref type="bibr" target="#b21">[22]</ref>) to explore extensions to UML and idioms within UML to accommodate the distinctive requirements of agents as well as defining software methodologies based on object-oriented approaches. In general, building methods and tools for agent-oriented software development on their object-oriented counterparts seems suitable as it lends itself to smoother migration between these different technology generations and at the same time improves accessibility of agent-based methods and tools to the object-oriented developers' community, which, as per today, prevails in industry. One of the first methodologies for the development of BDI agents based on OO technologies was presented in <ref type="bibr" target="#b14">[15]</ref>[16][17] <ref type="bibr" target="#b17">[18]</ref>. The agent methodology distinguishes between the external viewpoint -the system is decomposed into agents, modeled as complex objects characterized by their purpose, their responsibilities, the services they perform, the information they require and maintain, and their external interactions -and the internal viewpoint -the elements required by a particular agent architecture must be modeled for each agent, i.e. an agent's beliefs, goals, and plans. MESSAGE (Methodology for Engineering Systems of Software Agents) <ref type="bibr" target="#b18">[19]</ref>[20] is a methodology which builds upon best practice methods in current software engineering such as for instance UML for the analysis and design of agent-based systems. It consists of (i) applicability guidelines; (ii) a modeling notation that extends UML by agent-related concepts (inspired e.g. by Gaia); and (iii) a process for analysis and design of agent systems based on RUP. The MESSAGE modeling notation extends UML notation by key agent-related concepts.</p><p>Tropos <ref type="bibr">[29][35]</ref>[34] is another good example of a agent-oriented software developmen t methodology that is based on object-oriented techniques. In particular, Tropos relies on UML and offers processes for the application of UML mainly for the development of BDI agents and the agent platform JACK <ref type="bibr" target="#b36">[38]</ref>. Some elements of UML (like class, sequence, activity and interaction diagrams) are adopted as well for modeling object and process perspectives. The concepts of i* [36] such as actor (actors can be agents, positions or roles), as well as social dependencies among actors (including goal, soft goal, task and resource dependencies) are embedded in a modeling framework which also supports generalization, aggregation, classification, and the notion of contexts <ref type="bibr" target="#b35">[37]</ref>. Similar to Tropos, Prometheus <ref type="bibr" target="#b38">[41]</ref>[40] <ref type="bibr" target="#b37">[39]</ref> is an iterative methodology covering the complete software engineering process and aiming at the development of intelligent agents using goals, beliefs, plans, and events, i.e. in particular BDI agents, resulting in a specification which can be implemented with JACK <ref type="bibr" target="#b36">[38]</ref>. The Prometheus methodology covers three phases, namely those of System specification, architectural design, and detailed design. Multiagent Systems Engineering (MaSE) <ref type="bibr" target="#b24">[25]</ref>[26] <ref type="bibr" target="#b26">[27]</ref> has been developed to support the complete software development lifecycle from problem description to realization. It offers an environment for analyzing, designing, and developing heterogeneous multi-agent systems independent of any particular multi-agent system architecture, agent architecture, programming language, or message-passing system. It takes an initial system specification, and produces a set of formal design documents in a graphical style. In particular, MaSE offers the ability to track changes throughout the different phases of the process. PASSI (Process for Agent Societies Specification and Implementation) <ref type="bibr" target="#b22">[23]</ref>[24] is an agent-oriented iterative requirement-to-code methodology for the design of multi-agent systems mainly driven from experiments in robotics. The methodology integrates design models and concepts from both object oriented software engineering and artificial intelligence approaches. PASSI is supported by a Rational Rose plug-in to have a dedicated design environment. In particular, automatic code generation for the models is partly supported and a focus lies on patterns and code reuse.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">UML 2.0 and MDA: Their Usage for Agent-based Systems</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">UML</head><p>UML has a long history and is the result of a standardization effort on different modeling languages (like Entity-Relationship-Diagrams, the Booch-Notation, OMT, OOSE), namely Unified Modeling Language. The most popular versions of UML are UML 1.x, but now UML 2.0 is the upcoming new specification for development of systems. The Unified Modeling Language (UML) is a standard modeling language for visualizing (using the standardized graphic UML notations), specifying the static structure, dynamic behavior and model organization as well as constructing system, by mapping UML to programming environment and generate some code automatically, and documenting every phase of the lifecycle from analysis and design through deployment and maintenance. UML consists of a notation, describing the syntax of the modeling language and a graphical notation, and a meta model, describing the semantics of UML, namely the static semantics of UML, but no operational semantics. However, UML defines no software process, since a software process describes the development activities, dependencies of these activities and how they are applied. Thus UML is no t a software methodology / method since a methodology consists of a modeling language and software process. But UML can be applied by several methodologies.</p><p>The UML 2.0 specification (for details see <ref type="bibr" target="#b48">[51]</ref>, note that <ref type="bibr" target="#b48">[51]</ref> is also the standard reference for this section) consists of the Infrastructure Specification, defines foundational language constructs required for UML 2.0. The achieved results are adjustment between UML, MOF and XMI, re-structuring of language definition (meta-model as well as notation) with the goal to increase understandability and extensibility and first class extensibility mechanisms; Superstructure Specification, defines user level constructs (diagrams) required for UML 2.0. The achieved results here are modeling of patterns, e.g. component based development, specification of run-time architectures; support for scalability and encapsulation as well as unique definition of semantics for relations, like generalization, dependencies and associations; OCL (Object Constraint Language) a formal language used to describe expressions on UML models. The achieved results are meta-model-based definition of OCL, increased expressability of OCL and a formal semantics of OCL; Diagram Interchange enables a smooth and seamless exchange of documents compliant to the UML standard between different software tools. UML 2.0 supports the following diagrams: class, object, component, deployment and composite structure diagrams for modeling the static aspects of the systems and use case, state machine, sequence, activity, interaction overview, timing and communication diagrams for modeling dynamic aspects and packages, models and subsystems for modeling the model management. We focus on the first two groups of diagrams defined in the Superstructure Specification. We will use this distinction to present the diagram types and how they can be applied for modeling agent-based systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Structural Diagrams -Static Aspects Class Diagram</head><p>A Class Diagram describes on the one side a data model, i.e. collection of declarative (static) model elements, like classes and types, and on the other side their contents and relationships. Moreover the static structure of the system to be developed and all relevant structure dependencies and data types can be modeled with class diagrams. They are applied in various phases of the project, e.g. analysis (conceptual modeling of the domain), design (platform independent description) of the implementation, detailed design (platform specific description; PSM) and to bridge the gap to the behavior diagrams. Class diagrams describe classes and interfaces with their attributes and operations, as well as associations between them (including aggregation and composition), but also generalization (a specific kind of inheritance) and dependencies among them. New to UML 2.0 is that attributes have ordering, graphical notations for associations are defined, graphical interface notation are introduced using lollipops, some unification on the notations for e.g. visibility, names and types has been done. Moreover attributes have no implicit composition associations and dependencies are completely redefined. An example of a class diagrams is illustrated in Fig. <ref type="figure">1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 1 Class diagram</head><p>Class diagrams can be used for the definition of organizational models; in particular the static aspects of the organization, its associations and part-of relationships can be modeled. For example, departments can be modeled using classes. Their characteristics can be modeled by attributes, whereas their services can be modeled using functions. Associations are used to define relationships between different organizational units. The description of, for example, sub-departments can be modeled using aggregation and composition, where aggregation and composition are special forms of associations, namely a whole-part relationship (aggregation) and an aggregation that requires that a part instance be included in at most one composite at a time (composition), respectively. Generalization is used for refining existing organizational structures. Dependencies are applied to define a relationship between e.g. two organizational units, in which a change to one modeling element will affect the other modeling element. Similar social structures are e.g. defined by Odell et al. using class diagrams, see <ref type="bibr" target="#b40">[43]</ref>. However, many modelers are now using composite structures to model social structures such as as groups, organizations, and roles. (See Composite Structure Diagram subsection.) Ontologies can also be defined with UML. An ontology as a whole is viewed as a package, where as a class represents e.g. the class concept of DAML/OWL. The class hierarchy of OWL is defined using generalization, whereas properties are modeled by attributes, associations and classes. Sub-Properties can be defined by generalization between stereotyped &lt;&lt;property&gt;&gt; classes. sameClassAs, samePropertyAs are modeled by stereotyped dependencies between two classes, and associations, respectively. Cardinalities are applied to define minCardinality and maxCardinalities.</p><p>For details we refer to <ref type="bibr" target="#b0">[1]</ref>. Thus organizational model knowledge can be modeled by using class diagrams for the definition of ontologies. Moreover class diagrams can be applied for the definition of sub-tasks and sub-goal hierarchies (using generalization) as well as to define the structural aspects of tasks (using aggregation and composition). In additional constraints like goals, control features, services (functions as interfaces) can be added via attributes, functions and associations. An agent model can be defined using class names, inheritance (generalization) of classes and adding name, type, position/role, capabilities and constrains, either directly or via associations. A role hierarchy can be defined using generalization. However roles cannot be modeled in the necessary detail with any UML 2.0 diagram. Service models can also be done by this diagram type, e.g. defining services with input/output parameters and pre-/post-conditions as classes with attributes and functions (the service interface). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 2 Object Diagram</head><p>They can be used for the definition of objects, like speech acts viewed as messages send between agents, handled by agents. Moreover agents as instances of agent classes can be modeled to describe an agent population during the run-time execution of an agent-based system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Composite Structure Diagram</head><p>A Composite Structure Diagram describes the internal structure of a classifier, including the interaction points of the classifier to other parts of the system. It shows the configuration of parts that jointly perform the behavior of the containing classifier. Moreover, it defines a set of instances playing parts (roles), as well as their required relationships given in a particular context (architecture). Therefore, the external interfaces are given and an abstraction of operations and signals is performed. It shows how the different architecture components are structured and interworking. They are applied during top-down modeling of the system, to model the relationship between parts of the system through specific interfaces (ports) in a precise manner. They can also be used to describe the architecture of the system (architecture diagram) and for specification and application of patterns. Since this diagram in newly introduced in UML2.0, we will have a closer look at it before showing the application for agent-based systems. An example of a composite structure diagram is contained in Fig. <ref type="figure">3</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 3 Composite Structure Diagram and its Instantiation</head><p>A part is an element representing a set of instances that are owned by a containing classifier instance or role of a classifier. Parts may be joined by attached connectors and specify configurations of linked instances to be created within an instance of the containing classifier. Parts are usable in class, object, component, deployment and package diagrams. A connector is a link that enables communication between two or more instances. The link may be realized by something as simple as a pointer or by something as complex as a network connection. A port specifies a distinct interaction point between a classifier and its environment or between the (behavior of the) classifier and its internal parts. Ports are connected to other ports through connectors through which requests can be made to invoke the behavioral features of a classifier. External interfaces are specified as indicated in Fig. <ref type="figure" target="#fig_1">4</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 5 Collaborations</head><p>This diagram type can be used for defining those agent patterns that can be instantiated in different contexts, such as a typical agent broker architecture, or negotiation pattern. Moreover, it allows to define the architecture of an agent-based system and how a given agent architecture can be instantiated in different contexts. Composite structure diagrams provide a useful way to represent social structures such as groups and roles. A group is a set of agents that are related via their roles, where these links must form a connected graph within the group. Another way to look at this is that a group is a composite structure consisting of interrelated roles, where each of the group's roles has any number of agent instances. This definition implies not only that a group is a function of the roles contained within it, but also that roles have no meaning without their group referent. Hence, our ability to understand roles is limited by our ability to understand the groups of which they are a part.</p><p>A group can be formed to take advantage of the synergies of its members, resulting in an entity that enables products and processes that are not possible from any single individual. As with roles, groups may be deliberately established (i.e., by a system designer) or they may be emergent. In human organization terms, a deliberately established group could be a department or other workgroup that has been defined by some organizational authority. In contrast, an emergent group might be a social group that forms when several individuals decide to go out for a beer after work. Over time, they define themselves as a group ("My Friday Afternoon Drinking Buddies").</p><p>Groups are commonly formed to regulate, foster, or support the interaction of those agents within the group; so the group provides a place for a limited number of agents to interact among themselves via roles. In this way, intra-group associations encourage resource sharing, promote internal coordination, establish common supervision, and provide a degree of safety in numbers.</p><p>Groups can be treated as either agents or objects. An Agentified Group possesses all the features that any agent might possess. For example, it can send and receive messages directly and take on roles. Such a group is an agent in its own right, and therefore is a subclass not only of Group but also of Agent. (Such groups can also be referred to as organizations.) In contrast, Non-Agentified Groups are still first-class entities; however, these entities do not possess agent properties. Thus, they are as objects, rather than agents. Figure <ref type="figure" target="#fig_2">6</ref> represents the Group "ABC Ltd" as a composite structure with three associated roles, "Manager", "Broker" and "ABC Buyer". The "Manager" interacts directly with the "ABC Buyer" and the "Broker". In this situation, it is possible to interact with the agent "ABC Ltd." without knowing directly about any specific "Manager", "Broker" or "ABC Buyer" within the department; thus, this group is Agentified. The stereotype "&lt;&lt;agent&gt;&gt;" indicates that the group is Agentified. Groups can also be formed simply to establish a set of agents for purposes such as intra-group synergies or conceptual organization. A Non-Agentified Group is a Group that is not a subclass of Agent. Figure <ref type="figure" target="#fig_3">7</ref> shows a Non-Agentified version of "ABC Customer Sales Dept". It has the same associated Roles; however, it does not have the "&lt;&lt;agent&gt;&gt;" stereotype. In order to interact with this Department, you must interact directly with one of its members: a "Manager", an "ABC Buyer" or a "Broker".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Component Diagram</head><p>A Component Diagram describes the organizations and dependencies among components. A component is a modular part of a system that encapsulates its contents and whose manifestation is replaceable within its environment. A component defines its behavior in terms of provided and required interfaces. A Component Diagram is applied to support self-containment of components, the exchangeability of components and the distributed development and assembling of components.</p><p>In particular information hiding of internal structures of components is supported. Therefore it describes components, interfaces, ports as well as the realization, implementation and usage relationships with its classes and artifacts. In UML 2.0 implementation is called manifesting with the stereotype &lt;&lt;manifest&gt;&gt;. Components are represented completely different and artifacts can be associated with packaged elements. Moreover a deployment specification can be given and new stereotypes &lt;&lt;device&gt;&gt;, &lt;&lt;execution environment&gt;&gt; and &lt;&lt;subsystem&gt;&gt; were introduced. A component is viewed as a specific class, as depicted in Fig <ref type="figure">8</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 8 Component Diagram</head><p>In particular interfaces of a component can either be a black-box and white-box representation. (See example in Fig. <ref type="figure">9</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 9 Component Diagram -Black and White Box</head><p>An artifact is a physical piece of information that is used or produced by a development process.</p><p>Examples of artifacts include models, source files, scripts, and binary executable files. An artifact may constitute the implementation of a deployable component (Fig. <ref type="figure">10</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 10 Component Diagram examples.</head><p>Component diagrams can be used to define the input/output behavior of tasks and for the decomposition of the system architecture. Moreover the black-and white-box notation allows defining private and public interfaces of agents. The manifest-stereotype can be used to show how an agent component is deployed in distinguished systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Deployment Diagram</head><p>A Deployment Diagram describes the execution architecture of systems and the system architecture. System artifacts are represented as nodes, which are connected through communication paths to create network systems of arbitrary complexity. Nodes represent run-time computational resources, which generally have at least memory and often processing capability. Run-time objects and components may reside on nodes. Nodes are typically defined in a nested manner, and represent either hardware devices or software execution environments. Deployment diagrams are applied to show the run-time environment of a system and to represent "software server" as well as to describe the distribution of components. UML 2.0 adds new elements: device, execution environment, and deployment specification. Moreover nodes can be defined in more detail and the implementrelationship is substituted by &lt;&lt;manifest&gt;&gt; relationship. Artifacts are implementations of any packageableElement. (See Fig. <ref type="figure">11</ref>.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 11 Deployment diagram and complex node</head><p>A deployment specification specifies a set of properties that specify the execution parameters of a component artifact that is deployed on a node and can be aimed at a specific type of container. An artifact that reifies or implements deployment specification properties is a deployment descriptor (Fig. <ref type="figure">12</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 12 Composite Structure Diagram -Ports</head><p>Deployment diagrams can be used to describe the physical distribution of agent instances; in particular they can be applied for defining the migration of agents. Moreover this specification defines the platform design of an agent-based system. Having e.g. generic agents, the deployment specification can be applied to define the customization of agents in a specific context.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Behavioral Diagrams -Dynamic Aspects</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Use Case Diagram</head><p>Use cases are a means for specifying required usages of a system. Typically, they are used to capture the requirements of a system, that is, what a system is supposed to do. The key concepts associated with use cases are actors, use cases, and the subject. The subject is the system under consideration to which the use cases apply. The users and any other systems that may interact with the subject are represented as actors. The required behavior of the subject is specified by one or more use cases, which are defined according to the needs of actors. Use case diagrams are applied to define the external viewpoint on the system and to support encapsulation. In particular they define the "what" instead of "how" a system is realized from the perspective of an external communication partner. Thus it describes the system, the use cases of a system, external actors and their relationships between actors and use-cases, between actors and between use-cases Agent-based systems can also use these same notions of actor, use case, and subject, as illustrated in Figure <ref type="figure">13</ref>. Some embellishments, however, have been made to this diagram. First, these include the events from the requesting actor to which the subject must respond (sometimes referred to as percepts) and the events that affect an actor in some way (sometimes referred to as actions). These are indicated as names on the associations between actors and use cases. The associations also indicate directionality for these events. The second graphical addition indicates the providing actor for the service defined by the use case. Both the requesting actor and providing actor are vital to the service-oriented approach. In particular, the metamodel for the W3C's Web Services Architecture [W3C, 2004] defines both of these notions in terms of agents. For example, the Customer actor is the requesting agent for the Process Order Service and the Order Handler actor is the providing agent. Figure <ref type="figure" target="#fig_4">14</ref> illustrates some of these same ideas for Use Case Diagrams that represent directed relationships.  Such association, therefore, may include multiplicities, end names, association name, and so on. While most OO modelers might not take advantage of these features, they are useful for agent-based development. One minor extension to the Use Case diagram is the change in the definition of actor. UML 2.0 defines an actor as being "played by an entity that interacts with the subject… but which is external to the subject." Since agent-based actors can request and provide services inside or outside the subject area, the definition needs to be changed to indicate that an actor is "played by an entity that interacts with the subject's use case… but which is external to the use case." In other words, an actor may interact with the subject, or within the subject-and therefore can be internal or external to the subject." This definitional extension enables an agent-based approach to application development. In UML 2.0, an actor "specifies a role played by a user or any other system that interacts with the subject. (The term "role" is used informally here and does not necessarily imply the technical definition of that term …. Internal actors might also become requestors for services from external actors. For example in Fig. <ref type="figure" target="#fig_2">16</ref>, the Shipment Inquiry Interface actor requests a Shipment Search service from the Tracking Inquiry agent. While no association has been drawn directly from the Shipment Inquiry Interface actor and the Tracking Inquiry agent, it is implied. First, the Shipment Inquiry Interface actor is the provider for the determine Shipment Interface service; therefore, this actor is in charge of requesting services to support it. Second, the request is for the Shipment Search service; therefore the request is drawn to the service directly. Since the service is provided by the Tracking Inquiry actor, the link to the actor is implied. While this approach may seem non-standard in practice, it does not violate the UML 2.0 metamodel. Furthermore, to support the service-oriented approach, clearly specifying the requested service would seem to provide better clarity than just drawing an association to the external agent. Groups of actors and functionality can be expressed using Composite Structure Diagrams.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Work Order Scheduler</head><note type="other">Customer</note></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Activity Diagram</head><p>Activity modeling emphasizes the sequence and conditions for coordinating lower-level behaviors. These are commonly called control flow and object flow models. The actions coordinated by activity models can be initiated because other actions finish executing, because objects and data become available, or because events occur external to the flow. For agents, all these conditions are useful. However, from the agent standpoint, additional UML 2.0 features are also practical. For example in the following figure (Figure <ref type="figure" target="#fig_6">17</ref>), the Activity Diagram represents a business process that an agent system might support. By its title, it suggests that this is a plan for the Process Order service.  Each plan can be expressed as an Activity diagram. However, UML 2.0 needs to be extended to define plan rule conditions. As mentioned earlier, the plan rule specifies those conditions under which the associated activity may be invoked. In the example below, the plan rule condition indicates that when Process Order service is requested for an order is to be invoiced, this particular Activity Diagram plan is executed. Different Activity Diagrams may specify alternate plans for Process Order based on, say, credit card or cash payment instead. It should be noted that to support the ability of a process (i.e. service or goal) to choose from multiple plans requires an extension to UML 2.0. Currently, UML 2.0 can only invoke a single Activity Diagram for a given process. For implementations of BDI planning systems, such as Agentis [Agentis Software, http:www.agentissoftware.com], , activity-based plans are typically simplified by remove branching conditions and replacing them with finer-grain plans. This normalization process can be accomplished during design time and does not require an extension to UML 2.0.</p><p>Indicating the role for the processes within an Activity Diagram is also useful. In UML 2.0, Activity Diagrams can represent this in two ways: partitions and annotated processes. In the diagram below, partitions for Order Handler and Invoice Handler roles are represented as swimlanes. However, graphical swimlanes are not always that clearest express partitioning. In UML 2.0, each process on an Activity Diagram can be notated individually with the appropriate designation. For example in the diagram below, the Order Handler and Invoice Handler roles are placed within each processes' round-cornered rectangle. Group can be depicted as partitions and annotated processes in UML 2.0, as well. However, both role and group associations need to be added to the UML 2.0 metamodel to use the partitions and annotated processes. Within UML 2.0, no notion of goal, per se, exists. However, two ways of think about goals for Activity Diagrams are supported. First, the activity final node (the bulls eye) is considered the goal for the activity, because it is the end point for the process. Second, at a more macro level, the service can be thought of as supporting a goal. For example, the Process Order activity can be thought of as providing a service that supports the goal of processing orders. For example, in Agentis, a Process Order goal is synonymous with being able to provide a Process Order service. The only other issue that has been identified involves the control nodes in the flow (decision/merge nodes and fork/join nodes). While the semantics of the control node is understood, the responsibility for its underlying processing is not. If the Activity Diagram has a "control" agent that coordinates the process flow, each Activity Diagram can be associated with a providing role, as mentioned earlier. Another option is that each of the control nodes could be associated with a role that provides the control node functionality with in the activity context (as indicated in the example, above). Both options may also be chosen, where a control agent is responsible for coordinating the overall process flow by delegating to more specialized roles to handle each control node-just as it could for the individual processes in the diagram. Both options are also supported by UML 2.0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>State Machine Diagram</head><p>A State Machine Diagram describes the discrete behavior modeled through finite state-transition systems. The sequences of states that an object or an interaction goes through during its life in response to events, together with its responses and actions can be modeled. State Machine Diagrams are applied for the state descriptions of e.g. classifiers, for detailing of use cases, for behavior description of interfaces and ports, for detailed descriptions of event and signal handling. They describe states (simple, composite, submachine states), transitions, state machine, regions, initial and final state and pseudostates. In UML 2.0 interfaces can posses protocol state machines, state entry and exit and termination can be formulated and rules for transitions in inherited state machines are added and updated UML 2.0 distinguishes between behavioural state machines, i.e. state machines can be used to specify behaviour of various model elements. For example, they can be used to model the behaviour of individual entities (e.g., class instances). The state machine formalism described is an object based variant of Harel statecharts; and Protocol State machines, i.e. Protocol state machines are used to express usage protocols. Protocol state machines express the legal transitions that a classifier can trigger. The state machine notation is a convenient way to define a lifecycle for objects, or an order of the invocation of its operation. Because protocol state machines do not preclude any specific behavioral implementation, and inforces legal usage scenarios of classifiers, interfaces and ports can be associated to this kind of state machines.</p><p>The State Machine Diagram provides a graphical way representing discrete behavior through finite state transition systems. State machine can be applied for modeling interaction protocols, similar to sequence diagrams and to model plans.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Sequence Diagram</head><p>The most common kind of Interaction Diagram is the Sequence Diagram, which focuses on the message interchange between a number of lifelines. In particular, a Sequence Diagram describes an Interaction by focusing on the sequence of messages that are exchanged, along with their corresponding event occurrences on the lifelines. In particular, time sequences but does not include object relationships. This can be done either in a generic form (describes all possible scenarios) or in an instance form (describes one actual scenario). Sequence diagrams are applied to model interactions and in various phases of the software development process (e.g. use case refinement, modeling of test scenarios, communication model, detailed modeling of message exchanges or specification of interfaces)</p><p>Prior to UML 2.0, FIPA defined an agent-based that extended UML 1.x to include roles, decision points, concurrency, modularity, and multicasting (Example in Figure <ref type="figure" target="#fig_10">21</ref>(a)). UML 2.0 includes representation of all these notions except role and multicasting support. UML 2.0 adds e.g. loops, alternatives, parallelism, sequences and critical fragments.</p><p>Role notation can initially include making each lifeline define a role. The current UML 2.0 metamodel is not far from this general concept, but the agent-based notion of role is not defined by UML 2.0. Therefore, the extension to the Sequence Diagram metamodel needs to include equate the lifeline with a metamodel notion of role. Furthermore, some agent-based applications involve dynamic and multiple classification of agents in their roles. In these kinds of applications, representing role change and multiple roles for an agent requires more research and extended notation. Representing groups is not part of UML 2.0, and would therefore need to be added</p><p>To support the notation of multicast and multiresponse, a cardinality-based notation was added to the message lines (Figure <ref type="figure" target="#fig_10">21</ref>(b)). For example, the cfp message is annotated to indicate a message that would be multicast from an Initiator to n Participants. The response then involves a refusal from j Participants and proposal from k other Participants; and so on. This notation represents a first try at representing multicasting, however it still requires more consideration. For instance, policies may need to be stated that multiple responses (e.g., the number of refusal and proposal responses may not exceed the number of multicast cfp invitations to participants.) Communication Diagrams (formerly known as Collaboration Diagrams in UML 1.x) focus on the interaction between lifelines message passing is central. They correspond to simple Sequence Diagrams that use none of structuring mechanisms such as interaction occurrences and combined fragments. It also assumes a strict ordering of messages. A Communication Diagram describes the interaction between lifelines where the architecture of the internal structure and how this corresponds with the message passing is central. In particular, sequencing of messages is characterized through a sequence numbering scheme. Are known as collaboration diagrams of UML 1.x. They are applied similar to simple sequence diagrams. However, due to their limited expressiveness, Communication Diagrams can only be used to represent simple and straight-forward interactions. While they remain as part of the UML 2.0 set of diagrams, their usefulness is limited.</p><p>12: assert + request 14: pay Communication Diagrams require the same role-based extensions as the Sequence Diagrams. Role notation can initially include making each lifeline define a role. The current UML 2.0 metamodel is not far from this general concept, but the agent-based notion of role is not defined by UML 2.0. Therefore, the extension to the Communication Diagram metamodel needs to include equate the lifeline with a metamodel notion of role. Furthermore, some agent-based applications involve dynamic and multiple classification of agents in their roles. In these kinds of applications, representing role change and multiple roles for an agent requires more research and extended notation. Representing groups is not part of UML 2.0, and would therefore need to be added. To support the notation of multicast and multi-response, a cardinality-based notation was added to the message lines in the same manner as sequence diagrams in Figure <ref type="figure" target="#fig_10">21(b)</ref>. For example, the cfp message is annotated to indicate a message that would be multicast from an Initiator to n Participants. The response then involves a refusal from j Participants and proposal from k other Participants; and so on. This notation represents a first try at representing multicasting, however it still requires more consideration. For instance, policies may need to be stated that multiple responses (e.g., the number of refusal and proposal responses may not exceed the number of multicast cfp invitations to participants.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Interaction Overview Diagram</head><p>Interaction Overview Diagrams define interactions through a variant of Activity Diagrams in a way that promotes overview of the control flow. Interaction Overview Diagrams focus on the overview of the flow of control where the nodes are interactions. The lifelines and the messages do not appear at this overview level. For example, the UML 1.x diagram in Figure <ref type="figure">23</ref>(a) would be graphically cumbersome to express as a Sequence Diagram in UML 2.0, because of the resulting plethora of boxes within boxes. By using the Interaction Overview Diagram, the flow can be more clearly delineated as depicted in Figure <ref type="figure">23(b)</ref>.  The Interaction Overview Diagram (IOD) contains Sequence Diagrams and therefore needs to address the extensions indicated for Sequence Diagrams (see above). The only other issue that has been identified involves the control nodes in the flow (decision/merge nodes and fork/join nodes). (This issue similar to those that exist for the Activity Diagram.) While the semantics of control node is understood, the responsibility for its underlying processing is not. If the Interaction Overview has a "control" agent that coordinates the process flow, each IOD can be associated with a providing role. Another option is that each of the control nodes could be associated with a role that provides the control not functionality with in the IOD context. Both options may also be chose, where a control agent is responsible for coordinating the overall process flow by delegating to more specialized roles to handle each control node.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">MDA</head><p>Our approach towards this end is a model-driven development and architecture (MDA; for details see <ref type="bibr" target="#b47">[50]</ref>) as promoted by the Object Management Group (OMG) for the development of agent-based systems. Key to MDA is the importance of models in the software development process. Within MDA the software development process is driven by the activity of modeling the business software system. The MDA development process does not look very different from a traditional lifecycle, containing the same phases (requirements, analysis, low-level design, coding, testing, and deployment). One of the major differences to traditional development processes lies in the nature of the artifacts that are created during the development process. These artifacts are formal models, i.e. models that can be understood by computers and finally be transformed into a representation that lends itself to execution. The following three models are at the core of the MDA: Computation Independent Model (CIM): This is the most abstract model within MDA is independent of computational technology. It describes the business (logic) and therefore defines business processes and workflows in detail. Platform Independent Model (PIM): This model is defined at a high level of abstraction; it is independent of any implementation technology. It describes a software system that supports some business. Within a PIM, the system is modeled from the viewpoint of how it best supports the business. Whether a system will be implemented on a mainframe with a relational database, on an EJB application server or on an agent-platform is irrelevant at the PIM level. Summarizing the different approaches of section 2 and the usage of UML 2.0 diagrams from section 3.1 we distill the following necessary aspects to be covered by a model-driven architecture covering major areas of agent-based systems (only focusing on CIM and PIM):</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Computational Independent Model</head><p>The CIM has to deal with the following aspects: Use Cases: Taken from object-oriented software development, use case scenarios are a suitable method to derive the functional requirements of a system need to be derived. Role Model: This model describes the roles in a domain, on the one hand in the traditional objectoriented sense (actor-role relationship), but also defining roles characterizing social relationships within an agent-based system. Goal/Task Model: This model defines the objectives of an agent in terms of soft and hard goals, and should also support means-ends analysis (as in Tropos). Moreover, the notion of tasks and plans should be provided to support the description of agent behavior at a high level of abstraction. Interaction Model: This model defines the regime of interaction and collaboration among entities and groups of entities, at a level which abstracts from specific interaction protocols. Organization/Society Model: This model defines to a reasonable extent the real-world society and organization and hence the social context within which agents in an agentbased system acts and interacts. Business process models: The notion of business processes is key for corporate business applications. Business processes describe the means and the ends of business interactions. For agents to support corporate applications, it is important to be able to access executable definitions of business processes, to reason about the semantics of goal-directed business processes (see <ref type="bibr" target="#b45">[48]</ref>), and to relate business process to the organizational model, the interaction model, and the task model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Platform Independent Model</head><p>Interaction Protocol Model: This model defines the interaction between different agent class, agent instances and roles at the level of interaction protocols, such as the Contract Net. Internal Agent Model: This model deals in particular with goals, beliefs and plans of agent classes, how they are defined and which underlying architecture is used. Agent Model: This model describes the behavior of agents and agent groups, i.e. how different agent are collaborating together independent of their implementation. The interaction model defines the concrete interaction of the agents, whereas the internal agent model defines the internal behavior of an agent, e.g. in terms of BDI, and the agent model defines the behavior of an agent seen by other agents. Service / Capability Model: Defines the services and capabilities of agents, mostly using service description languages and mechanisms such as UDDI or DAML-S. Acquaintance Model: This model provides agents with models of other agents' beliefs, capabilities, and intentions. It can be used to determine suitable partners for collaboration or to predict others' behavior e.g., in a coordination task. Deployment / agent instance model: This model describes which agent instances exist, the migration is considered as well as the dynamic creation of agents.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Open Issues and Conclusions</head><p>As an OMG standard, UML 2.0 is now considered a "final" standard, as of November 2004. In other words, many of the errors and inconsistencies of the original submission have been rectified. More than 3000 issues were files and resolved by the UML 2.0 Finalization Task Force. As such software vendors can begin to build software tools that support the UML 2.0 Superstructure and Infrastructure.</p><p>In addition, a firmer foundation is now available to adequately support the extensions for agent-based system modeling. The FIPA Modeling Technical Committee and the OMG Agent Special Interest Group are actively working on extending UML for agent-based system modeling. These efforts are primarily supported by the work of more than a dozen software tool vendors. The notation presented in this paper is an interim result of this effort. UML has no "off-the-shelf" constructs to express: goals, agent, groups, multicasting, generative functions, such as cloning, birthing, reproduction, parasitism and symbiosis, emergent phenomena, and many other nature-based constructs that are helpful for representing agent structures. Furthermore, agent researchers are still trying to determine useful ways of representing agents and agent-based systems. As such, we cannot expect to have rich modeling languages for agents for several more years. (The first OMG "agent UML" request for proposal is not scheduled to be issued until the Fall of 2005.) However, we can begin to provide the agent community with guidelines for notations that provide obvious benefit-such as those presented in this chapter.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>An</head><label></label><figDesc>Object Diagram describes a snapshot of the system at a specific time point, where objects and their relationships at a point in time are depicted. Object diagrams are a special case of a class diagram or a communication diagram, since objects are an instance of a class, where a link is an instance of an association and the values of attributes or simple objects. An Object Diagram consists of objects, links and values. Changes in UML 2.0 are that &lt;&lt;copy&gt;&gt; and &lt;&lt;become&gt;&gt; are obsolete and multi-object notation is obsolete. An example of an object diagram is depicted in Fig. 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4</head><label>4</label><figDesc>Figure 4 Composite Structure Diagram -PortsApplied to the agent-based modelling, this diagram can be used for modelling an organization, its dependencies and workflows between agents. In addition, the diagram can represent an organization's external interfaces, as well as the internal behaviour and interfaces of an agent. The notion of interface for agent-based systems is of course different to usual object-oriented systems. For agentbased systems the interface defines the speech acts understood by the agent as well as the actions performed by an agent. Furthermore this diagram type allows us to express collaboration collaborations. The specification of how an operation or classifier, such as a use case, is realized by a set of classifiers and associations playing specific roles used in a specific way. The collaboration defines an interaction among roles, as illustrated in Sale and BrokeredSale collaborations in Fig.5.</figDesc><graphic coords="7,156.16,186.28,297.12,78.24" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 6</head><label>6</label><figDesc>Figure 6 Example of the ABC Ltd. Agentified Group and its associated Roles.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 7</head><label>7</label><figDesc>Figure 7 Example of the Non-Agentified ABC Ltd.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 14 A</head><label>14</label><figDesc>Figure 14 A job scheduling Use Case Diagram with include and extend relationships.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 15</head><label>15</label><figDesc>Figure 15 An example when internal actors can be providing and/or requesting actors.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 17 An</head><label>17</label><figDesc>Figure 17 An Activity Diagram for a Process Order service.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 18</head><label>18</label><figDesc>Figure 18 An Activity Diagram with role-based swim lanes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 19</head><label>19</label><figDesc>Figure 19 An Activity Diagram with role-based annotations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 20 A</head><label>20</label><figDesc>Figure 20 A State Machine Diagram for a Process Order service.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>FIPAFigure 21</head><label>21</label><figDesc>Figure 21 UML 1.x agent extensions and UML 2.0 Sequence Diagrams Communication Diagram</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 22 A</head><label>22</label><figDesc>Figure 22 A Communication Diagram with role-based annotations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>UML 1.x agent extensions with looping (b) A UML 2.0 Interaction Overview Diagram representation for Figure 24.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 23 UML 1 .</head><label>231</label><figDesc>Figure 23 UML 1.x agent extensions with looping.</figDesc><graphic coords="17,79.84,323.08,146.64,216.72" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>I.e. UML 2.0 use case diagrams are applied. Environment Model: In [43], Odell et al. consider several aspects of environment modeling ranging from physical environments to agent communication and to how their considerations could be embedded into the FIPA architecture. Domain / Ontology Model: This model defines the ontologies of the domain and relates them to other existing ontologies using e.g. UML class diagrams and Semantic Web representation languages.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="5,126.64,281.80,356.16,236.88" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="9,164.08,110.20,281.52,225.12" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Use Case Diagram for an Order Processing application.</head><label></label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell cols="2">Order Processing System</cell><cell></cell></row><row><cell></cell><cell>Order requested Order sent</cell><cell>Order Process</cell><cell>provider</cell><cell></cell></row><row><cell>Customer</cell><cell>Order canceled</cell><cell>Cancel Order</cell><cell>provider</cell><cell>Order Handler</cell></row><row><cell>Figure 13 A</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>)." An actor, then, can represent a single role, such as the Customer or Manager actors in the figures, above.</figDesc><table><row><cell>Shipment Inquirer R e q u e s t to fi n d S t a t u s S h ip m e n t S ta tu s R e q u e s t S h ip m e n t Request for ETA lo s t s h ip m e n t L o st sh ip m e n t st a tu s</cell><cell>Find Lost Shipment ETA Determine Shipment Status «include» Determine «include»</cell><cell>Shipment Inquiry Interface {general: CSA} p r o v id e r provider Tracking info Allocation Mgr {general: CSA} Request for tracking info p r o v id e r Allocate Appropriate CSA «include» p r o v id e r</cell><cell>Search Shipment provider</cell></row></table><note><p><p><p>ETA</p>Figure 16</p>Indicating Actor roles and resources.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>Platform Specific Model (PSM): In the next step, the PIM is transformed into one or more PSMs. It is tailored to specify a system in terms of the implementation constructs available in one specific implementation technology. A PIM is transformed into one or more PSMs. For each specific technology platform a separate PSM is generated. Most systems today span several technologies; therefore it is common to have many PSMs with one PIM. The final step in the development is the transformation of each PSM to code. Because a PSM fits its technology rather closely, this transformation is relatively straightforward.</figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements:</head><p>We would like to thank Gerhard Weiß for the invitation to contribute an article to this journal.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A Survey of Agent-Oriented Methodologies</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Iglesias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Garijo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>González</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Fifth International Workshop on Agent Theories, Architectures, and Languages</title>
		<meeting>Fifth International Workshop on Agent Theories, Architectures, and Languages</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="185" to="198" />
		</imprint>
		<respStmt>
			<orgName>University Pierre et Marie Curie</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Multi-Agent System Engineering</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Garijo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Boman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of MAAMAW&apos;99</title>
		<meeting>MAAMAW&apos;99</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Engineering Artifacts for Multi-Agent Systems</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">V D</forename><surname>Parunak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Odell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ERIM CEC</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Modelling and Design of Multi-Agent Systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kinny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Georgeff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Intelligent Agents III</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><surname>Kinny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Georgeff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rao</surname></persName>
		</author>
		<title level="m">A Methodology and Modelling Technique for Systems of BDI Agents. 7th European Workshop on Modelling Autonomous Agents in a Multi-Agent World (MAAMAW&apos;96)</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="56" to="71" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The Gaia Methodology for Agent-Oriented Analysis and Design</title>
		<author>
			<persName><forename type="first">M</forename><surname>Wooldridge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">R</forename><surname>Jennings</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kinny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Autonomous Agents and Multi-Agent Systems</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Specification of Behavioural Requirements within Compositional Multi-Agent System Design</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Herlea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Jonker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Treur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">J E</forename><surname>Wijngaards</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Ninth European Workshop on Modelling Autonomous Agents in a Multi-Agent World</title>
		<meeting>Ninth European Workshop on Modelling Autonomous Agents in a Multi-Agent World</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<biblScope unit="page">199</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Principles of Compositional Multi-Agent System Development</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">M T</forename><surname>Brazier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Jonkers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Treur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 15th IFIP World Computer Congress, WCC&apos;98, Conference on Information Technology and Knowledge Systems, IT&amp;KNOWS&apos;98</title>
		<meeting>15th IFIP World Computer Congress, WCC&apos;98, Conference on Information Technology and Knowledge Systems, IT&amp;KNOWS&apos;98</meeting>
		<imprint>
			<publisher>Chapman and Hall</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="347" to="360" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Compositional Verification of Multi-Agent Systems: a Formal Analysis of Pro-activeness and Reactiveness</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Jonker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Treur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Workshop on Compositionality (COMPOS&apos;97)</title>
		<meeting>International Workshop on Compositionality (COMPOS&apos;97)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A methodological proposal for multiagent systems development extending CommonKADS</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Iglesias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Garijo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Velasco</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 10th KAW</title>
		<meeting>of 10th KAW<address><addrLine>Banoe, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The Gaia Methodology for Agent-Oriented Analysis and Design</title>
		<author>
			<persName><forename type="first">M</forename><surname>Wooldridge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">R</forename><surname>Jennings</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kinny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Autonomous Agents and Multi-Agent Systems</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="285" to="312" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Agent UML: A Formalism for Specifying Multiagent Software Systems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Müller</surname></persName>
		</author>
		<author>
			<persName><surname>Odell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal on Software Engineering and Knowledge Engineering (IJSEKE)</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1" to="24" />
			<date type="published" when="2001">2001 Engineering, 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">ROADMAP: Extending the Gaia Methodology for Complex Open Systems</title>
		<author>
			<persName><forename type="first">Th</forename><surname>Juan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pearce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Sterling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of AAMAS 2002</title>
		<meeting>AAMAS 2002</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">SODA: Societies and Infrastructures in the Analysis and Design Of Agent-based Systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Omicini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of AOSE 2000</title>
		<meeting>AOSE 2000</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A Methodology and Modeling Technique for Systems of BDI Agents</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kinny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Georgeff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Seventh European Workshop on Modelling Autonomous Agents in a Multi-Agent World (MAAMAW 96)</title>
		<meeting>the Seventh European Workshop on Modelling Autonomous Agents in a Multi-Agent World (MAAMAW 96)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1038</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A design methodology for BDI agent systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kinny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Georgeff</surname></persName>
		</author>
		<idno>55</idno>
	</analytic>
	<monogr>
		<title level="j">Australian Artificial Intelligence Institute</title>
		<imprint>
			<date type="published" when="1995">1995</date>
			<pubPlace>Melbourne, Australia</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Modelling techniques for BDI agent systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kinny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Georgeff</surname></persName>
		</author>
		<idno>54</idno>
	</analytic>
	<monogr>
		<title level="j">Australian Artificial Intelligence Institute</title>
		<imprint>
			<date type="published" when="1995">1995</date>
			<pubPlace>Melbourne, Australia</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Modelling and Design of Multi-Agent Systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kinny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Georgeff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ATAL 96</title>
		<meeting>ATAL 96</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<ptr target="http://www.eurescom.de/public/projects/P900-series/p907/" />
		<title level="m">MESSAGE web site</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Agent Oriented Analysis using MESSAGE/UML</title>
		<author>
			<persName><forename type="first">Giovanni</forename><surname>Caire</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wim</forename><surname>Coulier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Francisco</forename><surname>Garijo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jorge</forename><surname>Gomez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juan</forename><surname>Pavon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philippe</forename><surname>Massonet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Francisco</forename><surname>Leal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paulo</forename><surname>Chainho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><surname>Kearney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jamie</forename><surname>Stark</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Evans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings AOSE</title>
		<imprint>
			<date type="published" when="2001">2001. 2001</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Models and methodology for agent-oriented analysis and design</title>
		<author>
			<persName><forename type="first">Birgit</forename><surname>Burmeister</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Working Notes of the KI&apos;96 Workshop on Agent-Oriented Programming and Distributed Systems, 1996. DFKI Document D</title>
		<imprint>
			<biblScope unit="page" from="96" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><forename type="first">B</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Bergenti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ph</forename><surname>Massonet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Odell</surname></persName>
		</author>
		<title level="m">Agents and the UML: A Unified Notation for Agents and Multi-Agent Systems, Proceeding AOSE</title>
		<meeting><address><addrLine>Montreal</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title/>
		<author>
			<persName><surname>Passi Website</surname></persName>
		</author>
		<ptr target="www.csai.unipa.it/passi" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A CASE tool supported methodology for the design of multi-agent systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Cossentino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Potts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. The 2002 International Conference on Software Engineering Research and Practice (SERP&apos;02) Las</title>
		<meeting>The 2002 International Conference on Software Engineering Research and Practice (SERP&apos;02) Las<address><addrLine>Vegas (NV), USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">DeLoach An Overview of the Multiagent Systems Engineering Methodology</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">Wood</forename><surname>Mark</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First International Workshop on Agent-Oriented Software Engineering</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Ciancarini</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Wooldridge</surname></persName>
		</editor>
		<meeting>the First International Workshop on Agent-Oriented Software Engineering</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">1957</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Multiagent Systems Engineering: A Methodology for Analysis and Design of Multiagent Systems</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Wood</surname></persName>
		</author>
		<idno>AFIT/GCS/ENG/00M-26</idno>
		<imprint>
			<publisher>School of Engineering</publisher>
		</imprint>
	</monogr>
	<note type="report_type">MS thesis</note>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Multiagent Systems Engineering: the Analysis Phase</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Deloach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Wood</surname></persName>
		</author>
		<idno>AFIT/EN-TR-00-02</idno>
		<imprint>
			<date type="published" when="2000-06">June 2000</date>
		</imprint>
		<respStmt>
			<orgName>Air Force Institute of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Extreme Programming Explained</title>
		<author>
			<persName><forename type="first">K</forename><surname>Beck</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Addison Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<author>
			<persName><forename type="first">Fausto</forename><surname>Giunchiglia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">_</forename></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Mylopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">_</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Anna</forename><surname>Perini</surname></persName>
		</author>
		<title level="m">The Tropos Software Development Methodology: Processes, Models and Diagrams</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Contribution to Knowledge Modelling in a Multi-Agent Framework (the Co-MoMAS Approach</title>
		<author>
			<persName><forename type="first">Norbert</forename><surname>Glaser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">L&apos;Universtit´ e Henri Poincar´ e</title>
		<meeting><address><addrLine>Nancy I, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-11">November, 1996</date>
		</imprint>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">CommonKADS: A comprehensive methodology for KBS development</title>
		<author>
			<persName><forename type="first">A</forename><surname>Th</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">J</forename><surname>Schreiber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Wielinga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Akkermans</surname></persName>
		</author>
		<author>
			<persName><surname>Van De Velde</surname></persName>
		</author>
		<ptr target="/M1/RR/UvA/70/1.1" />
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
		<respStmt>
			<orgName>University of Amsterdam, Netherlands Energy Research Foundation ECN and Free University of Brussels</orgName>
		</respStmt>
	</monogr>
	<note>Deliverable DM1.2a KADS-II</note>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<ptr target="http://www.semanticweb.org" />
		<title level="m">Semantic Web Inititiative</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<author>
			<persName><forename type="first">Ivar</forename><surname>Jacobson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Grady</forename><surname>Booch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Rumbaugh</surname></persName>
		</author>
		<title level="m">The Unified Software Development Process</title>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">UML for agent-oriented software development: The Tropos proposal</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mylopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kolp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Castro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 4th Int. Conf. on the Unified Modeling Language UML&apos;01</title>
		<meeting>of the 4th Int. Conf. on the Unified Modeling Language UML&apos;01<address><addrLine>Toronto, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-10">Oct. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<ptr target="http://www.cs.toronto.edu/km/tropos/" />
		<title level="m">Tropos web site</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Towards Requirements-Driven Information Systems Engineering: The Tropos Project</title>
		<author>
			<persName><forename type="first">J</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kolp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mylopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Systems</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Elsevier</publisher>
			<pubPlace>Amsterdam, The Netherlands</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">JACK Intelligent Agents -Components for Intelligent Agents in Java</title>
		<author>
			<persName><forename type="first">P</forename><surname>Busetta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rönnquist</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hodgson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lucas</surname></persName>
		</author>
		<idno>TR9901</idno>
		<ptr target="http://www.jackagents.com/pdf/tr9901.pdf" />
	</analytic>
	<monogr>
		<title level="j">AOS</title>
		<imprint>
			<date type="published" when="1999-01">January 1999</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Prometheus: A Methodology for Developing Intelligent Agents</title>
		<author>
			<persName><forename type="first">Lin</forename><surname>Padgham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Winikoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of AOSE 2002</title>
		<meeting>AOSE 2002</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Prometheus: A Pragmatic Methodology for Engineering Intelligent Agents</title>
		<author>
			<persName><forename type="first">Lin</forename><surname>Padgham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Winikoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the workshop on Agent-oriented Methodologies at OOPSLA 2002</title>
		<meeting>the workshop on Agent-oriented Methodologies at OOPSLA 2002</meeting>
		<imprint>
			<date type="published" when="2002-11-04">November 4, 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Representing Social Structures in UML</title>
		<author>
			<persName><forename type="first">H</forename><surname>Van Dyke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Parunak</surname></persName>
		</author>
		<author>
			<persName><surname>Odell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of AOSE 2001</title>
		<meeting>AOSE 2001</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">J</forename><surname>Odell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Van Dyke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mitch</forename><surname>Parunak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sven</forename><surname>Fleischer</surname></persName>
		</author>
		<author>
			<persName><surname>Brueckner</surname></persName>
		</author>
		<title level="m">Modeling Agents and their Environment</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
	<note>Proceedings of AOSE 2002</note>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title/>
		<ptr target="http://www.omg.org/mda/" />
	</analytic>
	<monogr>
		<title level="j">Model-driven Architecture</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Tutorial on message sequence charts (MSC</title>
		<author>
			<persName><forename type="first">E</forename><surname>Rudolph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Grabowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Graubmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of FORTE/PSTV&apos;96 Conference</title>
		<meeting>FORTE/PSTV&apos;96 Conference</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">OMT: The development model</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rumbaugh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JOOP Journal of Object Oriented Programming</title>
		<imprint>
			<biblScope unit="volume">76</biblScope>
			<biblScope unit="page" from="8" to="16" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">OMT: The dynamic model</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rumbaugh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JOOP Journal of Object Oriented Programming</title>
		<imprint>
			<biblScope unit="page" from="6" to="12" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<ptr target="http://www.agentissoftware.com" />
		<title level="m">Agentis</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<author>
			<persName><forename type="first">B</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Müller</surname></persName>
		</author>
		<title level="m">Methodologies and Modeling Languages</title>
		<editor>
			<persName><forename type="first">Agent-Based Software</forename><surname>Development</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Luck</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Ashri</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>D'inverno</surname></persName>
		</editor>
		<meeting><address><addrLine>Boston, London</addrLine></address></meeting>
		<imprint>
			<publisher>Artech House Publishers</publisher>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<title level="m" type="main">MDA Explained -The Model Driven Architecture: Practice and Promise</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kleppe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Warmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Bast</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>Addison Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<ptr target="http://www.omg.org/uml" />
		<title level="m">Upcoming UML 2.0 Standard</title>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
