<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Adaptive Functional Programming *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Umut</forename><forename type="middle">A</forename><surname>Acar</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">Carnegie Mellon University Pittsburgh</orgName>
								<address>
									<postCode>15213</postCode>
									<region>PA</region>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Guy</forename><forename type="middle">E</forename><surname>Blelloch</surname></persName>
							<email>blelloch@cs.cmu.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">Carnegie Mellon University Pittsburgh</orgName>
								<address>
									<postCode>15213</postCode>
									<region>PA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Robert</forename><surname>Harper</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">Carnegie Mellon University Pittsburgh</orgName>
								<address>
									<postCode>15213</postCode>
									<region>PA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Adaptive Functional Programming *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">D59BD27B46FC0A8A979E5DD2535A588A</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:09+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>An adaptive computation maintains the relationship between its input and output as the input changes. Although various techniques for adaptive computing have been proposed, they remain limited in their scope of applicability. We propose a general mechanism for adaptive computing that enables one to make any purely-functional program adaptive.</p><p>We show that the mechanism is practical by giving an efficient implementation as a small ML library. The library consists of three operations for making a program adaptive, plus two operations for making changes to the input and adapting the output to these changes. We give a general bound on the time it takes to adapt the output, and based on this, show that an adaptive Quicksort adapts its output in logarithmic time when its input is extended by one key.</p><p>To show the safety and correctness of the mechanism we give a formal definition of AFL, a call-by-value functional language extended with adaptivity primitives. The modal type system of AFL enforces correct usage of the adaptivity mechanism, which can only be checked at run time in the ML library. Based on the AFL dynamic semantics, we formalize the change-propagation algorithm and prove its correctness.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>An adaptive program responds to input changes by updating its output while only re-evaluating those portions of the program affected by the change. Adaptive programming is useful in situations where input changes lead to relatively small changes in the output. In limiting cases one cannot avoid a complete re-computation of the output, but in many cases the results of the previous computation may be re-used to obtain the updated output more quickly than a complete Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. POPL '02, Jan. <ref type="bibr" target="#b15">[16]</ref><ref type="bibr" target="#b16">[17]</ref><ref type="bibr" target="#b17">[18]</ref><ref type="bibr">2002</ref> Portland, OR USA 2002 ACM ISBN 1-58113-450-9/02/01...$5.00 re-evaluation. For example, as we shall see below, an adaptive version of Quicksort takes expected logarithmic time to adapt its output when its input list is extended by one key. This is an improvement by a linear factor over simply re-evaluating the sort for the changed inputs.</p><p>In this paper we propose a general mechanism for adaptive programming. Our proposed mechanism extends callby-value functional languages with a small set of primitives to support adaptive programming. Apart from requiring that the host language be purely functional, we make no other restriction on its expressive power. In particular our mechanism is compatible with the full range of effect-free constructs found in ML. Our proposed mechanism has these strengths:</p><p>• Generality: It applies to any purely functional program. The programmer can build adaptivity into an application in a natural and modular way.</p><p>• Flexibility: It enables the programmer to control the amount of adaptivity. For example, a programmer can choose to make only one portion or aspect of a system adaptive, leaving the others to be implemented conventionally.</p><p>• Simplicity: It requires small changes to existing code. For example, the adaptive version of Quicksort presented in the next section requires only minor changes to the standard implementation.</p><p>• Efficiency: The mechanism admits a simple implementation and yields efficient adaptivity. For example, the adaptive version of Quicksort updates the output in expected O(log n) time upon extension to the input.</p><p>Our adaptivity mechanism is based on the idea of a modifiable reference (or modifiable, for short) and three operations for creating (mod), reading (read), and writing (write) modifiables. A modifiable allows us to record the dependence of one computation on the value of another. A modifiable reference is essentially a write-once reference cell that records the value of an expression whose value may change as a (direct or indirect) result of changes to the inputs. Any expression whose value can change must store its value in a modifiable reference; such an expression is said to be changeable. Expressions that are not changeable are said to be stable; stable expressions are not associated with modifiables.</p><p>Any expression that depends on the value of a changeable expression must express this dependence by explicitly reading the contents of the modifiable storing the value of that changeable expression. This establishes a data dependency between the expression reading that modifiable, called the reader, and the expression that determines the value of that modifiable, the writer. Since the value of the modifiable may change as a result of changes to the input, the reader must itself be deemed a changeable expression. This means that a reader cannot be considered stable, but may only appear as part of a changeable expression whose value is stored in some other modifiable.</p><p>By choosing the extent to which modifiables are used in a program, the programmer can control the extent to which it is able to adapt to change. For example, a programmer may wish to make a list manipulation program adaptive to insertions into and deletions from the list, but not under changes to the individual elements of the list. This can be represented in our framework by making only the "tail" elements of a list adaptive, leaving the "head" elements stable. However, once certain aspects are made changeable, all parts of the program that depend on those aspects are, by implication, also changeable.</p><p>The key to adapting the output to change of input is to record the dependencies between readers and writers that arise during the initial evaluation. These dependencies may be maintained as a graph in which each node represents a modifiable, and each edge represents a read whose source is the modifiable being read and whose target is the modifiable being written. Also, each edge is tagged with the corresponding reader. Whenever the source modifiable changes, the new value of the target is determined by re-evaluating the associated reader.</p><p>It is not enough, however, to maintain only this dependency graph connecting readers to writers. It is also essential to maintain an ordering on the edges and keep track of which edges (reads) are within the dynamic scope of which other edges. We call this second relationship the containment hierarchy. The ordering among the edges enables us to re-evaluate readers in the same order as they were evaluated in the initial evaluation. The containment hierarchy enables us to identify and remove edges that become obsolete. This occurs, for example, when the result of a conditional inside a reader takes a different branch than the initial evaluation. The difficulty is maintaining the ordering and containment information during re-evaluation. We show how to maintain this information efficiently using time-stamps and an order-maintenance algorithm of Dietz and Sleator <ref type="bibr" target="#b3">[4]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>Several researchers have studied approaches that are similar to what we call adaptive programming. The idea of using dependency graphs for incremental updates was introduced by Demers, Reps and Teitelbaum <ref type="bibr" target="#b2">[3]</ref> in the context of attribute grammars. Reps then showed an algorithm to propagate a change optimally <ref type="bibr" target="#b15">[16]</ref>, and Hoover generalized the approach outside the domain of attribute grammars <ref type="bibr" target="#b8">[9]</ref>. A crucial difference between this previous work and ours is that the previous work is based on static dependency graphs. Although they allow the graph to be changed by the modify step, the propagate step (i.e., the propagation algorithm) can only pass values through a static graph. This severely limits the types of adaptive computations that the technique handles <ref type="bibr" target="#b13">[14]</ref>. Another difference is that they don't have the notion of forming the initial graph/trace by running a computation, but rather assume that it is given as input (often it naturally arises from the application). Yellin and Strom use the dependency graph ideas within the INC language <ref type="bibr" target="#b17">[18]</ref>, and extend it by having incremental computations within each of its array primitives. Since INC does not have recursion or looping, however, the dependency graphs remain static.</p><p>Another approach to incremental/adaptive computations is function caching <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b12">13]</ref>. In function caching, a computation reuses cached results from earlier evaluations whenever appropriate. Thus, one must run the computation from scratch to identify the part of the computation that does not change. In contrast, in our approach, an input change pinpoints the parts of the computation that need to be re-evaluated. Function caching therefore is bad at handling "deep" modifications. We conjecture, for example, that with function caching no algorithm can update a sorted linked-list in less than linear expected time. This is because the inserted element is expected to end up half way down the list, and function caching will always recreate the part of the list ahead of the inserted element. There are two other problems with function caching. First it can be hard to effectively check for equality of arguments for the purpose of matching elements in the cache. This is particularly true if the inputs are functions themselves, possibly with captured environments. Second, for efficiency it is critical to evict elements from the cache. The suggested methods we have seen to decide when and what to evict seem ad-hoc, although Liu and Teitelbaum have made some progress using automatic program transformation techniques to decide what to cache <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b9">10]</ref>. In spite of these problems, function caching might have some advantages over our method for "shallow" modifications. We expect that these techniques can be integrated to further improve performance in certain situations.</p><p>Other approaches are based on various forms of partial evaluation <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b16">17]</ref>. These approaches are arguably cleaner than the function caching approach (they don't have the issues with equality of inputs or deciding when to evict from the cache), but are even more limited in the type of adaptivity they allow. Ramalingam and Reps wrote an excellent bibliography summarizing other work on incremental computation <ref type="bibr" target="#b14">[15]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Overview of the Paper</head><p>In Section 4 we illustrate the main ideas of adaptive functional programming in an algorithmic setting. We first describe how to implement an adaptive form of Quicksort in Standard ML based on the interface of a module implementing the basic adaptivity mechanisms. We then describe the change-propagation algorithm that lies at the heart of the mechanism and establish an upper bound for its running time. Using this bound, we then prove the expected O(log n) time bound for adaptive Quicksort to accommodate an extension to its input. We finish by briefly describing the implementation of the mechanism in terms of an abstract ordered list data structure. This implementation requires less than 100 lines of Standard ML code.</p><p>In Section 5 we define an adaptive functional programming language, called AFL, which is an extension of a simple call-by-value functional language with adaptivity primitives. The static semantics of AFL enforces properties that can only be enforced by run-time checks in our ML library. The dynamic semantics of AFL is given by an evaluation rela-  tion that maintains a record of the adaptive aspects of the computation, called a trace, which is used by the change propagation algorithm.</p><p>In Section 6 we present the change propagation algorithm in the framework of the dynamic semantics of AFL. The change propagation algorithm interprets a trace to determine the correct order in which to propagate changes, and to determine which expressions need to be re-executed. The trace also records the containment structure of the computation, which is updated during change propagation. Using this presentation we give a proof of correctness of the change propagation algorithm stating that change propagation yields essentially the same result as a complete reexecution on the changed inputs.</p><p>We note that we had originally thought that incorporating an adaptivity mechanism in ML would require the involvement of a compiler. Working out the semantics of AFL led to the particular mechanism we describe and its simple implementation as an ML library.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">A Framework for Adaptive Computing</head><p>We give an overview of our adaptive framework based on our ML library and an adaptive version of Quicksort.</p><p>The ML library. The signature of our adaptive library for ML is given in Figure <ref type="figure" target="#fig_0">1</ref>. The library provides functions to create (mod), to read from (read), and to write to (write) modifiables, as well as meta-functions to initialize the library (init), change input values (change) and propagate changes to the output (propagate). The meta-functions are described later in this section. The library distinguishes between two "handles" to each modifiable: a source of type 'a mod for reading from, and a destination of type 'a dest for writing to. When a modifiable is created, correct usage requires that it only be accessed as a destination until it is written, and then only be accessed as a source. <ref type="foot" target="#foot_0">1</ref> All changeable expressions have type changeable, and are used in a "destination passing" style-they do not return a value, but rather take a destination to which they write a value. Correct usage requires that a changeable expression ends with a write-we define "ends with" more precisely when we discuss time stamps. The destination written will be referred to as the target destination. The type changeable has no interpretable value.</p><p>The mod takes two parameters, a conservative comparison function and an initializer. A conservative comparison function returns false when the values are different but may return true or false when the values are the same. This function is used by the change-propagation algorithm to avoid unnecessary propagation. The mod function creates a modifiable and applies the initializer to the new modifiable's destination. The initializer is responsible for writing the modifiable. Its body is therefore a changeable expression, and correct usage requires that the body's target match the initializer's argument. When the initializer completes, mod returns the source handle of the modifiable it created.</p><p>The read takes the source of a modifiable and a reader, a function whose body is changeable. The read accesses the contents of the modifiable and applies the reader to it. Any application of read is itself a changeable expression since the value being read could change. If a call Ra to read is within the dynamic scope of another call R b to read, we say that Ra is contained within R b . This relation defines a hierarchy on the reads, which we will refer to as the containment hierarchy (of reads).</p><p>Making an Application Adaptive. The transformation of a non-adaptive program to an adaptive program involves two steps. First, the data structures are made "modifiable" by placing desired elements in modifiables. Second, the original program is updated by making the reads of modifiables explicit and placing the results of each expression that depends on a modifiable into another modifiable. This means that all values that directly or indirectly depend on modifiable inputs are placed in modifiables.</p><p>As an example, consider the code for a standard Quicksort, qsort, and an adaptive Quicksort, qsort', as shown in Figure <ref type="figure">2</ref>. To avoid linear-time concatenations, qsort uses an accumulator to store the sorted tail of the input list. The transformation is done in two steps. First, we make the lists "modifiable" by placing the tail of each list element into a modifiable as shown in lines 1,2,3 in Figure <ref type="figure">2</ref>. The resulting structure, a modifiable list, allows the user to insert and delete items to and from the list. Second, we change the program so that the values placed in modifiables are accessed explicitly via a read. The adaptive Quicksort uses a read (line 21) to determine whether the input list l is empty and writes the result to a destination d (line 23). This destination belongs to the modifiable that is created by a call to mod (through modl) in line 28 or 33. These modifiables form the output list, which now is a modifiable list. The function filter is similarly transformed into an adaptive one, filter' (lines 6-18). The modl is defined to take an initializer and pass it to the mod with a constant-time, conservative comparison function for lists. The comparison function returns true, if and only if both lists are NIL and returns false otherwise. This comparison function is sufficiently powerful to prove the O(log n) bound for adaptive Quicksort.</p><p>Adaptivity. An adaptive computation allows the programmer to change input values and update the result. This process can be repeated as desired. The library provides the meta-function change to change the value of a modifiable and the meta-function propagate to propagate these changes to the output. Figure <ref type="figure">3</ref> illustrates an example. The  fromList function converts a list to a modifiable list, returning both the modifiable list and its last element. The test function first performs an initial evaluation of the adaptive Quicksort by converting the input list lst to a modifiable list l and sorting it into r. It then changes the input by adding a new key v to the end of l. To update the output r, test calls propagate. The update will result in a list identical to what would have been returned if v was added to the end of l before the call to qsort. In general, any number of inputs could be changed before running propagate.</p><p>Augmented Dependency Graphs. The crucial issue is to support change propagation efficiently. To do this, an adap-tive program, as it evaluates, creates a record of the adaptive activity. It is helpful to visualize this record as a dependency graph augmented with additional information regarding the containment hierarchy and the evaluation order of reads. In such a dependency graph, each node represents a modifiable and each edge represents a read. An evaluation of mod adds a node, and an evaluation of read adds an edge to the graph. In a read, the node being read becomes the source, and the target of the read (the modifiable that the reader finished by writing to) becomes the target. We also tag the edges with the reader function.</p><p>To operate correctly, the change-propagation algorithm needs to know the containment hierarchy of reads. To maintain this information, we tag each edge and node with a time stamp, which are generated by the mod and read. All expressions are evaluated in a time range (ts, te) and time-stamps generated by the expression are allocated sequentially within that range, i.e., each generated time stamp is greater than the previous one, but less than the end of the time range. The time stamp of an edge is generated by the corresponding read, before the reader is evaluated, and the time stamp of a node is generated by the mod after the initializer is evaluated (the time stamp of a node corresponds to the time it was initialized). Correct usage of the library requires that the order of time stamps is independent of whether the write or mod generate the time stamp for the corresponding node. This is what we mean by saying that a changeable expression must end with a write to its target.</p><p>The time stamp of an edge is called its start time and the time stamp of the target of the edge is called the edge's stop time. The start and the stop time of the edge define the time span of the edge. We note that the time span can be used to identify the containment relationship of reads. In particular, a read Ra is contained in a read R b if and only if the start time of the edge associated with Ra is within the time span of the edge associated with R b . For now, we will represent time stamps with real numbers, and assume that top-level expressions are evaluated in the range (0.0, 1.0). Subsequently, we will show how the Dietz-Sleator Order-Maintenance Algorithm can be used to maintain time stamps efficiently <ref type="bibr" target="#b3">[4]</ref>.</p><p>We define an augmented dependency graph (adg) as a DAG in which each edge has an associated reader and time stamp, and each node has an associated value and time stamp. 2 We say that a node (and corresponding modifiable) is an input if it has no incoming edges.</p><p>An example should help make the ideas clear. Consider the adaptive filter function filter' shown in Figure <ref type="figure">2</ref>. The function takes another function f and a modifiable list l as parameters and outputs a modifiable list that contains the items of l satisfying f. Figure <ref type="figure" target="#fig_2">4</ref> shows the dependency graph for an evaluation of filter' with the function (fn x =&gt; x &gt; 2) and a modifiable input list of 2::3::nil. The output is the modifiable list 3::nil. Although not shown in the figure, each edge is also tagged with a reader. In this example, all edges have an instance of reader (fn l' =&gt; case l' of ...) (lines 8-15 of qsort' in Figure <ref type="figure">2</ref>). The time stamps for input nodes are not relevant, and are marked with an asterisk in Figure <ref type="figure" target="#fig_2">4</ref>.</p><p>Change Propagation. Given an augmented dependency graph and a set of changed input modifiables, the changepropagation algorithm updates the adg and the output by propagating changes in the adg. We say that an edge, or corresponding read, is invalidated if the source of the edge changes value. We say that an edge is obsolete if it is contained within an invalidated edge.</p><p>Figure <ref type="figure">5</ref> defines the change-propagation algorithm. The algorithm maintains a Priority Queue of invalidated edges. The queue is prioritized on the time stamp of each edge, and is initialized with the out-edges of the changed input values. Each iteration of the while loop processes one invalidated edge, and we call the iteration an edge update. The update re-evaluates the associated reader. This makes any code that was within the reader's dynamic scope obsolete. A key aspect of the algorithm is that when an edge is updated, all nodes and edges that are contained within that edge are deleted from both the graph and queue. This prevents the reader of an obsolete edge from being re-evaluated. Evaluating such a reader on a changed input may incorrectly 2 We do not formalize adgs more precisely here since we view them as an implementation of a cleaner notion of traces, which we formalize in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Propagate Changes</head><formula xml:id="formula_0">I is the set of changed inputs (V, E) = G is an adg 1 Q = v∈I outEdges(v) 2 while Q is not empty 3 e = deleteMin(Q) 4</formula><p>(Ts, Te) = timeSpan(e) 5 update a modifiable, incorrectly raise an exception, or even not terminate. After the reader is re-evaluated we check if the value of the target has changed (line 10) by using the conservative comparison function passed to mod. If it has changed, we add the out-edges of the target to the queue to propagate that change.</p><formula xml:id="formula_1">V = V -{v ∈ V |Ts &lt; T (v) &lt; Te} 6 E = {e ∈ E|Ts &lt; T (e ) &lt; Te} 7 E = E -E 8 Q = Q -E</formula><p>As an example, consider an initial evaluation of filter whose dependency graph is shown in Figure <ref type="figure" target="#fig_2">4</ref>. Now, suppose we change the modifiable input list from 2::3::nil to 2::4::7::nil by creating the modifiable list 4::7::nil and changing the value of modifiable l1 to this list. The leftmost frame in Figure <ref type="figure" target="#fig_4">6</ref> shows the input change. Now, we run the change-propagation algorithm to update the output. First, we insert the sole outgoing edge of l1, namely (l1,l3), into the queue. Since this is the only (hence, the earliest) edge in the queue, we remove it from the queue and establish the current time-span as 0.2 -0.5 . Next, we delete all the nodes and edges contained in this edge from the adg and from the queue (which is empty) as shown by the middle frame in Figure <ref type="figure" target="#fig_4">6</ref>. Then we redo the read by re-evaluating the reader (fn l' =&gt; case l' of ...) (8-15 in Figure <ref type="figure">2</ref>) in the current time span 0.2 -0.5 . The reader walks through the modifiable list 4::7::nil as it filters the items and writes the head of the result list to l3, as shown in the rightmost frame in Figure <ref type="figure" target="#fig_4">6</ref>. This creates two new edges, which are given the time stamps, 0.3 , and 0.4 . The targets of these edges, l7 and l8, are assigned the time stamps, 0.475 , and 0.45 , matching the order that they were initialized (these time stamps are otherwise chosen arbitrarily to fit in the range 0.4 -0.5 ).</p><p>Implementing Change Propagation Efficiently. The change-propagation algorithm described above can be implemented efficiently using a standard representation of graphs, a standard priority-queue algorithm, and an Order-Maintenance Algorithm for time stamps. The implementation of the adg needs to support deleting an edge, a node, and finding the outgoing edges of a node. An adjacency list representation in which the edges of a node are maintained in a doubly-linked list implements these operations in constant time. The algorithm also needs to identify all the edges between two time stamps so they can be deleted. This can be implemented with a time-ordered, doubly-linked list of all edges. Inserting, deleting, and find-next all take constant time per edge. The priority queue should support addition, deletion, and delete-minimum operations efficiently.</p><p>Standard based priority-queue algorithms perform these operations in logarithmic time. This is sufficient for our purposes and any of these algorithms can be used to implement priority queues.</p><p>A more interesting question is how to implement time stamps efficiently. To do this, we require efficient support for four operations: compare two time stamps, insert a new time stamp after a given time stamp, delete a time stamp, and retrieve the next time stamp (used in deleting the timespan of an edge). Using real numbers is not an efficient solution, because, in change propagation, an arbitrary number of new time stamps could be inserted between two fixed time stamps. This requires arbitrary precision real numbers, which are costly. A simple alternative to real numbers is to have all the time stamps ordered in a list. To insert or delete a time stamp, we simply insert it into the list or delete it from the list. To compare two time stamps, we compare their positions in the list-the time stamp closer to the beginning of the list is smaller. This comparison operation, however, can take linear time in the length of the list. A more efficient approach is to assign an integer rank to each time stamp in the list such that nodes closer to the beginning of the list have smaller ranks. This enables constant time comparisons by comparing the ranks. The insertion algorithm then may have to do some re-ranking to find space to insert an integer between two adjacent integers. Dietz and Sleator give two efficient algorithms for this problem, which is known as the Order-Maintenance Problem <ref type="bibr" target="#b3">[4]</ref>. The first algorithm is a simple algorithm that performs all operations in amortized constant time, the second more sophisticated algorithm achieves worst case constant time.</p><p>Performance of Change Propagation. We show an upper bound on the running time of change propagation. As discussed above, we assume an adjacency list representation for augmented dependency graphs together with a time-ordered list of edges, a priority queue that can support insertions, deletions, and remove-minimum operations in logarithmic time, and an order-maintenance structure that supports insert, delete, compare, and find-next operations in constant time.</p><p>We define several performance measures for change propagation. Consider running the change-propagation algorithm, and let I denote the set of all invalidated edges. Of these edges, some of them participate in an edge update, whereas some become obsolete and are deleted before participating. We refer to the set of updated edges as Iu. For an updated edge e ∈ Iu, let |e| denote the re-evaluation time (complexity) of the reader associated with e assuming that mod, read, write, take constant time, and let ||e|| denote the number of time stamps created during the initial evaluation of e. Let q be the maximum size of the priority queue at any time during the algorithm. Theorem 1 bounds the time of a propagate step. Proof: The time for propagate can be partitioned into 4 items: (1) re-evaluation of readers, (2) creation of time stamps, (3) deletion of time stamps and contained edges, and (4) insertion to and deletions from the priority queue. Re-evaluation of the readers takes e∈Iu |e| time. The number of time stamps created during the re-evaluation of a reader is no greater than the time it takes to re-evaluate the reader. Since creating one time stamp takes constant time, creating time stamps takes O( e∈Iu |e|) time. Determining each time stamp to delete, deleting the time stamp and the corresponding node or edge from the adg and the timeordered doubly-linked edge list takes constant time. Thus total time for these deletions is ( e∈Iu ||e||).</p><p>Finally, each edge is added to the priority queue once and deleted from the queue once, thus the time for maintaining the priority queue is O(|I| log q). The total time is the sum of these terms.</p><p>Performance of Adaptive Quicksort. We now analyze the propagate time for Quicksort when the input list is modified by adding a new key at the end. The analysis is based on the bound given in Theorem 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 2</head><p>Change propagation updates the output of adaptive Quicksort in O(log n) time after the input list of length n is extended with a new key at the end.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof:</head><p>The proof is by induction on the height h of a call tree representing just the calls to qs. When the input is extended, the value of the last element ln of the list is changed from NIL to CONS(v,ln+1), where the value of ln+1 is NIL and v is the new key. The induction hypothesis is that in change propagation on an input tree of height h, the number of invalidated reads is at most 2h (|I| ≤ 2h and Iu = I), each reader takes constant time to re-evaluate (∀e ∈ I, |e| = O(1)), the time span of a reader contains no other time stamps (∀e ∈ I, ||e|| = 0), and the maximum size of the priority queue is 4 (q ≤ 4).</p><p>In the base case, we have h = 1, and the call tree corresponds to an evaluation of qs with an empty input list. The only read of ln is the outer read in qs. The change propagation algorithm will add the corresponding edge to the priority queue, and then update it. Now that the list has one element, the reader will make two calls to filter and two calls to qs' both with empty input lists. This takes constant time and does not add any edges to the priority queue. There are no time stamps in the time span of the re-evaluated edge and the above bounds hold.</p><p>For the inductive case assume that the hypothesis holds for trees up to height h -1, and consider a tree with height h &gt; 1. Now, consider the change propagation starting with the root call to qs. The list has at least one element in it, therefore the initial read does not read the tail ln. The only two functions that use the list are the two calls to filter', and these will both read the tail in their last recursive call. Therefore, during change propagation these two reads (edges) are invalidated, will be added to the queue, and then updated. Any other edges that these updates add to the queue will have start times after the start times of these edges. Re-evaluating the reader of one of the two edges will rewrite NIL and therefore not change its target. Reevaluating the other will change its target from NIL to the value CONS(v,ln+1), and therefore extend the corresponding list. Re-evaluating both readers takes constant time and the update deletes no time stamps. Only one of the two recursive calls to qs has any changed data, and that one has its input extended with one element. Since the call tree of the qs has depth at most d -1, the induction hypothesis applies. Thus, |e| = O(1) and ||e|| = 0 for all invalidated edges. Furthermore, the total number of invalidated edges is |I| ≤ 2(d -1) + 2 = 2d and all edges are re-evaluated (Iu = I). To see that q ≤ 4, note that the queue contains edges from at most 2 different qs calls and there are at most 2 edges invalidated from each call.</p><p>It is known that the expected height of the call tree is O(log n) (expectation is over all inputs). Thus The ML Implementation. We present an implementation of our adaptive mechanism in ML. It uses a library for ordered lists, which is an instance of the Order-Maintenance Problem, and a standard priority queue. In the ordered-list interface (shown in Figure <ref type="figure" target="#fig_7">7</ref>), spliceOut deletes all time stamps between two given time stamps and isSplicedOut returns true if the time stamp has been deleted and false otherwise.</p><p>Figure <ref type="figure">8</ref> shows the code for the ML implementation. The implementation differs somewhat from the algorithm described earlier, but the asymptotic performance remains  the same. The edge and node types correspond to edges and nodes in the adg. The reader and time-span are represented explicitly in the edge type, but the source and destination are implicit in the reader. In particular the reader starts by reading the source, and ends by writing to the destination. The node consists of the corresponding modifiable's value (value), its out-edges (outEdges), and a write function (wrt) that implements writes or changes to the modifiable. A time stamp is not needed since edges keep both start and stop times. The currentTime is used to help generate the sequential time stamps, which are generated for the edge on line 37 and for the node on line 29 by the write operation.</p><p>Some of the tasks assigned to the change-propagate loop in Figure <ref type="figure">5</ref> are performed by the write operation in the ML code. This includes the functionality of lines 10-12 in Figure <ref type="figure">5</ref>, which are executed by lines 20-25 in the ML code. Another important difference is that the deletion of contained edges is done lazily. Instead of deleting edges from the Queue and from the graph immediately, the time stamp of the edge is marked as invalid (by being removed from the ordered-list data structure), and is deleted when it is next encountered. This can be seen in line 55.</p><p>We note that the implementation given does not include sufficient run-time checks to verify "correct usage". For example, the code does not verify that an initializer writes its intended destination. The code, however, does check for a read before write.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">An Adaptive Functional Language</head><p>In the first part of the paper, we described an adaptivity mechanism in an informal setting. The purpose was to introduce the basic concepts of adaptivity and show that the mechanism can be implemented efficiently. We now turn to the question of whether the proposed mechanism is sound. To this end, we present a small, purely functional language with primitives for adaptive computation, called AFL. AFL ensures correct usage of the adaptivity mechanism statically by using a modal type system and employing implicit "destination passing."</p><p>The adaptivity mechanisms of AFL are similar to those of the adaptive library presented in Section 4. The chief difference is that the target of a changeable expression is implicit in AFL. Because of this, AFL also includes two forms of function type, one for functions whose body is stable, and one for functions whose body is changeable. The former corresponds to the standard function type found in any functional language. The latter is included to improve efficiency by allowing such functions to share their (implicit) target with the caller. This avoids the need to allocate a modifiable for the result of a procedure call, and is crucial to supporting the tail recursion optimization in changeable mode.</p><p>AFL does not include analogues of the meta-operations   tinues evaluation of ec. A read is considered changeable because the contents of the modifiable on which it depends is subject to change. A changeable function itself is stable, but its body is changeable; correspondingly, the application of a changeable function is a changeable expression. The sequential let construct allows for the inclusion of stable sub-computations in changeable mode. Finally, conditionals with changeable branches are themselves changeable.</p><formula xml:id="formula_2">(l) = τ ) Λ; Γ s l : τ mod (Γ(x) = τ ) Λ; Γ s x : τ Fun Λ; Γ, f : τ 1 s → τ 2 , x : τ 1 s e : τ 2 Λ; Γ s funs f (x : τ 1 ) : τ 2 is e end : (τ 1 s → τ 2 ) Λ; Γ, f : τ 1 c → τ 2 , x : τ 1 c e : τ 2 Λ; Γ s func f (x : τ 1 ) : τ 2 is e end : (τ 1 c → τ 2 ) Prim Λ; Γ s v i : τ i (1 ≤ i ≤ n) o o : (τ 1 , . . . , τn) τ Λ; Γ s o(v 1 , . . . ,</formula><p>Static Semantics. The AFL type system is inspired by the type theory of modal logic given by Pfenning and Davies' <ref type="bibr" target="#b11">[12]</ref>. We distinguish two modes, the stable and the changeable, corresponding to the distinction between terms and expressions, respectively, in Pfenning and Davies' work. However, they have no analogue of our changeable function type, and do not give an operational interpretation of their type system.</p><p>The judgement Λ; Γ s e : τ states that e is a well-formed stable expression of type τ , relative to Λ and Γ. The judgement Λ; Γ c e : τ states that e is a well-formed changeable expression of type τ , relative to Λ and Γ. Here Λ is a location typing, a finite function assigning types to locations, and Γ is a variable typing, a finite function assigning types to variables. The rules for deriving these judgements are given in Figures <ref type="figure" target="#fig_8">10</ref> and<ref type="figure" target="#fig_5">11</ref>.</p><p>Dynamic Semantics. The evaluation judgements of AFL have one of two forms. The judgement σ, es ⇓ s v, σ , Ts states that evaluation of the stable expression es, relative to the input store σ, yields the value v, the trace Ts, and the updated store σ . The judgement σ, l ← ec ⇓ c σ , Tc states that evaluation of the changeable expression ec, relative to the input store σ, writes its value to the target l, and yields the trace Tc and the updated store σ .</p><p>In the dynamic semantics, a store, σ, is a finite function mapping each location in its domain, dom(σ), to either a value v or a "hole" . The defined domain, def(σ), of σ consists of those locations in dom(σ) not mapped to by σ. When a location is created, it is assigned the value to reserve that location while its value is being determined.</p><p>A trace is a finite data structure recording the adaptive aspects of evaluation. The abstract syntax of traces is given by the following grammar: A stable trace records the sequence of allocations of modifiables that arise during the evaluation of a stable expression. The trace Tc l:τ records the allocation of the modifiable, l, its type, τ , and the trace of the initialization code for l. The trace Ts ; T s results from evaluation of a let expression in stable mode, the first trace resulting from the bound expression, the second from its body.</p><p>A changeable trace has one of three forms. A write, Wτ , records the storage of a value of type τ in the target. A sequence Ts ; Tc records the evaluation of a let expression in changeable mode, with Ts corresponding to the bound stable expression, and Tc corresponding to its body. A read R x.e l (Tc) trace specifies the location read, l, the context of use of its value, x.e, and the trace, Tc, of the remainder of evaluation with the scope of that read. This records the dependency of the target on the value of the location read.</p><p>The augmented dependency graphs described in Section 4 may be seen as an efficient representation of traces. Time stamps may be assigned to each read and write operation in the trace in left-to-right order. These correspond to the time stamps in the adg representation. The containment hierarchy is directly represented by the structure of the trace. Specifically, the trace Tc (and any read in Tc) is contained within the read trace R x.e l (Tc).</p><p>Stable Evaluation. The evaluation rules for stable expressions are given in Figure <ref type="figure" target="#fig_11">12</ref>. Most of the rules are stan-</p><formula xml:id="formula_3">Value σ, v ⇓ s v, σ, ε Op's (v = app(o, (v 1 , . . . , vn))) σ, o(v 1 , . . . , vn) ⇓ s v , σ, ε If σ, e 1 ⇓ s v, σ , Ts σ, if true then e 1 else e 2 ⇓ s v, σ , Ts σ, e 2 ⇓ s v, σ , Ts σ, if false then e 1 else e 2 ⇓ s v, σ , Ts Apply (v 1 = funs f (x : τ 2 ) : τ is e end) σ, [v 1 /f, v 2 /x] e ⇓ s v , σ , Ts σ, apply s (v 1 , v 2 ) ⇓ s v , σ , Ts Let σ, e 1 ⇓ s v 1 , σ , Ts σ , [v 1 /x]e 2 ⇓ s v 1 , σ , T s σ, let x be e 1 in e 2 end ⇓ s v 2 , σ , (Ts ; T s ) Mod σ[l → ], l ← e ⇓ c σ , Tc (l ∈ dom(σ))</formula><p>σ, modτ e ⇓ s l, σ , Tc l:τ  dard for a store-passing semantics. For example, the let rule sequences evaluation of its two expressions, and performs binding by substitution. Less conventionally, it yields a trace consisting of the sequential composition of the traces of its sub-expressions. The most interesting rule is the evaluation of modτ e. Given a store σ, a fresh location l is allocated and initialized to prior to evaluation of e. The sub-expression e is evaluated in changeable mode, with l as the target. Preallocating l ensures that the target of e is not accidentally re-used during evaluation; the static semantics ensures that l cannot be read before its contents is set to some value v.</p><formula xml:id="formula_4">Write σ, l ← write(v) ⇓ c σ[l ← v], Wτ If σ, l ← e 1 ⇓ c σ , Tc σ, l ← if true then e 1 else e 2 ⇓ c σ , Tc σ, l ← e 2 ⇓ c σ , Tc σ, l ← if false then e 1 else e 2 ⇓ c σ , Tc Apply (v 1 = func f (x : τ 1 ) : τ 2 is e end) σ, l ← [v 1 /f, v 2 /x] e ⇓ c σ , Tc σ, l ← apply c (v 1 , v 2 ) ⇓ c σ , Tc Let σ, e 1 ⇓ s v 1 , σ , Ts σ , l ← [v 1 /x]</formula><p>Changeable Evaluation. The evaluation rules for changeable expressions are given in Figure <ref type="figure" target="#fig_12">13</ref>. The let rule is sim-ilar to the corresponding rule in stable mode, except that the bound expression, e1, is evaluated in stable mode, whereas the body, e2, is evaluated in changeable mode. The read expression substitutes the binding of location l in the store σ for the variable x in e, and continues evaluation in changeable mode. The read is recorded in the trace, along with the expression that employs the value read. The write rule simply assigns its argument to the target. Finally, application of a changeable function passes the target of the caller to the callee, avoiding the need to allocate a fresh target for the callee and a corresponding read to return its value to the caller.</p><p>Type Safety. The static semantics of AFL ensures these four properties of its dynamic semantics: (1) each modifiable is written exactly once; (2) no modifiable is read before it is written; (3) dependencies are not lost, i.e. if a value depends on a modifiable, then its value is also placed in a modifiable; (4) the store is acyclic.</p><p>The proof of type safety for AFL hinges on a type preservation theorem for the dynamic semantics. As may be expected, the preservation theorem ensures that the value of a well-typed stable expression is also well-typed (indeed, has the same type). In addition preservation ensures that evaluation of a changeable expression preserves the type of the store. The typing relation for stores ensures not only that the contents of locations are consistent with their type, but also that there are no cyclic dependencies among them. Thus preservation for AFL ensures that no cycles can arise during evaluation, which is consistent with pure functional programming.</p><p>Space considerations preclude a rigorous presentation of type safety for AFL. A complete proof is given in the companion technical report <ref type="bibr" target="#b0">[1]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Change Propagation is Sound</head><p>We formalize the notion of an input change and present a formal version of the change-propagation algorithm. Using this formal framework, we prove that the change-propagation algorithm is correct.</p><p>Changing the Input. We represent an input change with a difference store. A difference store is a finite mapping assigning values to locations. Unlike a store, a difference store may contain "dangling" locations that are not defined within the store. The process of modifying a store with a difference store is defined as follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3 (Store Modification)</head><p>Let σ be a store and let δ be a difference store. The modification of σ by δ is the store σ = σ ⊕ δ given by the equation</p><formula xml:id="formula_5">σ ⊕ δ = δ ∪ { (l, σ(l)) | l ∈ dom(δ) and l ∈ dom(σ) }.</formula><p>This store modification yields an input change when it is applied to an input store.</p><p>Change Propagation Algorithm. We present a formal version of the change-propagation algorithm, which is informally described in Section 4. In the rest of this section, we will use the term change-propagation algorithm to refer to this formal algorithm. The change-propagation algorithm takes a modified store, a trace obtained by evaluating an AFL program with respect to the original store, and a set of input locations that are changed by the store modification, called the changed set. The algorithm scans the trace as it seeks for reads of changed locations. When such a read is found, the associated expression is re-evaluated with the new value to obtain a revised trace and store. Furthermore, the target of a re-evaluated read is added to the changed set, because re-evaluation may change its value. Thus, the order in which the reads are re-evaluated is important. The change-propagation algorithm scans the trace in the order that it was originally generated. This ensures that the trace is scanned only once and is done by establishing a correspondence between the change-propagation rule that handles a trace and the AFL rule that generates that trace.</p><p>Formally, the change propagation algorithm is given by two judgements:</p><formula xml:id="formula_6">1. Stable propagation: σ, Ts, C ⇓ p s σ , T s , C</formula><p>2. Changeable propagation: σ, l ← Tc, C ⇓ p c σ , T c , C These judgement define the change-propagation for a stable and a changeable trace (Ts and Tc) with respect to a store (σ) and a changed set (C). In changeable propagation, a target (l) is maintained as in changeable evaluation mode of AFL.</p><p>The rules defining the change-propagation judgements are given in Figure <ref type="figure" target="#fig_13">14</ref>. Given a trace, change propagation mimics the evaluation rule of AFL that originally generated that trace. To stress this correspondence, each changepropagation rule is marked with the name of the evaluation rule to which it corresponds. For example, the propagation rule for the trace Ts ; T s mimics the let rule of the stable mode that gives rise to this trace. The most interesting rule is the read rule. This rule mimics a read operation, which evaluates an expression after binding its specified variable to the value of the location read. The read rule takes two different actions depending on whether this location is in the changed set or not. If the location has changed (is in the changed set), then the expression is re-evaluated with the new value of location. This re-evaluation yields a revised store and a new trace. The new trace "repairs" the original trace by replacing the trace of the read. Also, the target location is added to the changed set because it may now have a different value. Finally, the "repaired" trace, the revised store, and the revised changed set is yielded. If the read location has not been changed (is not in the changed set), then there is no need to re-evaluate this read and change-propagation continues by scanning the rest of the trace. This is because a re-evaluation would generate the same effects to the store and to the trace as done by the initial evaluation. Since these effects are already present in the store and the trace, this read could safely be skipped.</p><p>Note that the purely functional change-propagation algorithm presented here scans the whole trace. Therefore, a direct implementation of this algorithm will run in time linear in the size of the trace. On the other hand, the changepropagation algorithm revises the trace by only replacing the changeable trace of re-evaluated reads. Thus, if one is content with updating the trace with side effects, then traces of re-evaluated reads can be replaced in place, while skipping all the rest of the trace. This is indeed how the ML implementation performs change propagation using an augmented dependency graph as described in Section 4.</p><p>Correctness of Change Propagation. Change propagation simulates a complete re-evaluation by only re-evaluating the affected sub-expressions of an AFL program. Here we show that change propagation yields the same output and the trace as a complete re-evaluation and thus is correct.</p><p>Figure <ref type="figure" target="#fig_14">15</ref> illustrates this simulation process. First, we evaluate a program e, which we assume to be a stable expression, with respect to an initial store σi obtaining a value vi, an extended store σ i , and a trace T i s . This is called the initial evaluation. Then, we modify the initial store with a difference store δ as σs = σi ⊕ δ and re-evaluate the program with this store in a subsequent evaluation.</p><p>To simulate the subsequent evaluation via a change propagation, we first apply the modifications δ to σ i , to ob-tain a new store σm as σm = σ i ⊕ δ. We then perform change propagation with respect to σm, using the trace of the initial evaluation, and the set of changed locations C = dom(σ i ) ∩ dom(δ). As a result, we obtain a revised trace and store σ m and a revised trace T m s . For the changepropagation to work properly, we require that δ changes only input locations, i.e., dom(σ i ) ∩ dom(δ) ⊆ dom(σi).</p><p>To prove correctness, we compare the trace and store obtained by the subsequent evaluation to those obtained by the change propagation. Since these two evaluations are independent, we do not expect the locations generated in these evaluations match. Thus, the two traces and the stores can indeed contain different locations. On the other hand, this is not a problem because locations themselves are transparent to the user. To capture this, we introduce an equivalence relation for stores and traces that disregards locations (names) via a partial bijection between locations. A partial bijection is a one-to-one mapping from a set of locations D to a set of locations R that may not map all the locations in D.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4 (Partial Bijection)</head><p>B is a partial bijection from set D to set R if it satisfies the following:</p><formula xml:id="formula_7">1. B ⊆ { (a, b) | a ∈ D, b ∈ R }, 2. if (a, b) ∈ B and (a, b ) ∈ B then b = b , 3. if (a, b) ∈ B and (a , b) ∈ B then a = a .</formula><p>A partial bijection, B can be applied to a trace T or a store σ, denoted B[T ] and B[σ] by replacing each location l in T or σ with its image B[l] whenever the image is defined. The formal definitions for these are given in the companion technical report <ref type="bibr" target="#b0">[1]</ref>. The theorem below states that the change-propagation algorithm is correct, the proof of the theorem is given in the companion technical report <ref type="bibr" target="#b0">[1]</ref>. In the theorem, the reason that the store σ m is a super set of σ s is that σ m contains remnant locations from the initial evaluation, whereas σ s does not.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 5 (Correctness)</head><p>Let σi be an initial store, δ be a difference store, σs = σi ⊕ δ, and σm = σ i ⊕ δ as shown in Figure <ref type="figure" target="#fig_14">15</ref>. If 1. σi, e ⇓ s vi, σ i , T i s , (initial evaluation) 2. σs, e ⇓ s vs, σ s , T s s , (subsequent evaluation) 3. dom(σ i ) ∩ dom(δ) ⊆ dom(σi) then the following holds:</p><formula xml:id="formula_8">1. σm, T i s , (dom(σ i ) ∩ dom(δ)) ⇓ p s σ m , T m s , , 2. there is a partial bijection B such that (a) B[vi] = vs, (b) B[T m s ] = T s s , (c) B[σ m ] ⊇ σ s .</formula><p>Type Safety. The change-propagation algorithm also enjoys a type preservation property stating that if the initial state is well-formed, so is the result state. This ensures that the results of change propagation can subsequently be used as further inputs. The proof requires that store modification operation respect the typing of the store being modified and given in the companion report <ref type="bibr" target="#b0">[1]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Discussion</head><p>Variants. In the process of developing the mechanisms presented in this paper we considered several variants. Here we mention a few of them. One variant is to replace the explicit write operation with an implicit one. In the ML library this requires making the target destination an argument to the read operation. In AFL it requires adding some implicit type subsumption rules. We decided to include the explicit write since we believe it is cleaner. We also considered a variant of our mechanism in which the mod, read, and write are combined into a single operation. This operation reads a modifiable, evaluates an expression with the value of the modifiable, and writes the result into a new modifiable. In the ML library the operation can be defined as follows. This operation, along with another that does two reads, were sufficient to express many of the examples we were working with. The operations, however, are not expressive enough for many other examples, and in particular for Quicksort. In practice it would worthwhile including these two operations in a comprehensive adaptive library since implementing them directly would be more efficient than the composition given above.</p><p>Side Effects. We require that the underlying language be purely functional. The main reason for this is that each edge (read) stores a closure (code and environment) which might be re-evaluated. It is critical that this closure does not change. The key requirement, therefore, is not that there are no side-effects, but rather that all data is persistent (i.e., the closure's environment cannot be modified). It is therefore likely that the adaptive mechanism could be made to work in an imperative setting as long as relevant data structures are persistent. There has been significant research on persistent data-structures under an imperative setting <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b6">7]</ref>.</p><p>We further note that certain "benign" side effects are not harmful. For example, side effects to objects that are not examined by the adaptive code itself are harmless. This includes print statements, or any changes to "meta" data structures that are somehow recording the progress of the adaptive computation itself. For example, one way to determine which parts of the code are being re-evaluated is to sprinkle the code with print statements and see which ones print during the change propagation. In fact, re-evaluations of a function can be counted by simply inserting a counter at the start of the function. Also, the memoization of the kind done by lazy languages will not affect the correctness of change-propagation, because the value remains the same whether it has been calculated or not. We therefore expect that our approach can be applied to lazy languages, but we have not explored this direction. Function Caching. As mentioned in the related work section, it might be useful to add function caching to our framework. We believe this is a promising extension, but should note that it is not trivial to incorporate this feature. The problem is that function caching and modifiables interact in subtle ways-function caching requires purely functional code, but our framework involves side-effects in its implementation.</p><p>Applications. The work in this paper was motivated by the desire to make it easier to define kinetic data structures for problems in computational geometry <ref type="bibr" target="#b1">[2]</ref>. Consider the problem of maintaining some property of a set of objects in space as they move, such as the nearest neighbors or convex hull of a set of points. Kinetic data structures are designed to maintain such properties by re-evaluating parts of the code when certain conditions become violated (e.g., a point moves from one side of a line to the other). Currently, however, every problem requires the design of its own kinetic data structure. We believe that it is possible, instead, to use adaptive versions of non-kinetic algorithms.</p><p>Full Adaptivity. It is not difficult to modify the AFL semantics to interpret standard functional code (e.g. the call-by-value lambda-calculus) in a fully adaptive way (i.e., all values are stored in modifiables, and all expressions are changeable). It is also not hard to describe a translator for converting functional code into AFL, such that the result is fully adaptive. The only slightly tricky aspect is translating recursive functions. We in fact had originally considered defining a fully adaptive version of AFL but decided against it since we felt it would be more useful to selectively choose what code is adaptive.</p><p>Meta Language. We have not included a "meta" language for AFL that would allow a program to change input and run change-propagation. There are some subtle issues in defining such a language such as how to restrict changes to inputs, and how to identify the "safe" parts of the code in which the program can make changes. We worked on a system that includes an additional type mode, which we called meta-stable. Changes and change-propagation could be performed only in this mode, and there was no way to get into this mode other than from top-level. We felt, however, that this system did not add much to the main concepts covered in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>We have presented a mechanism for adaptive computation based on the idea of a modifiable reference. We expect that this mechanism can be incorporated into any purely functional call-by-value language. A key aspect of our mechanism is that it can dynamically create new computations and delete old computations. The main contributions of the paper are the particular set of primitives we suggest, the change-propagation algorithm, and the semantics along with the proofs that it is sound. The simplicity of the primitives is achieved by using a destination passing style. The efficiency of the change-propagation is achieved by using an optimal order-maintenance algorithm. The soundness of the semantics is aided by a modal type system.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Signature of the adaptive library.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :Figure 3 :</head><label>23</label><figDesc>Figure 2: The complete code for non-adaptive (left) and adaptive (right) versions of Quicksort.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: The adg for an application of filter' to the function fn x =&gt; x&gt;2 and the input modifiable list 2::3::nil. The output is the modifiable list 3::nil.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>9 vFigure 5 :</head><label>95</label><figDesc>Figure 5: The change-propagation algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Snapshots of the adg during change propagation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Theorem 1 (</head><label>1</label><figDesc>Propagate) Change propagation takes time O e∈Iu (|e| + ||e||) + |I| log q .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>we have: E [|I|] = O(log n), I = Iu, q = 4, and ∀e ∈ I, |e| = O(1), ||e|| = 0. Thus by taking the expectation of the formula given in Theorem 1 and plugging in values gives expected O(log n) time for propagate.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: The signature of an ordered list.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Typing of stable expressions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>2 Read Λ; Γ s v 1 : 2 Figure 11 :</head><label>21211</label><figDesc>Figure 11: Typing of changeable expressions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>Trace T : : = Ts | Tc Stable Ts : : = | Tc l:τ | Ts ; Ts Changeable Tc : : = Wτ | R x.e l (Tc) | Ts ; Tc When writing traces, we adopt the convention that ";" is right-associative.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: Evaluation of stable expressions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 13 :</head><label>13</label><figDesc>Figure 13: Evaluation of changeable expressions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 14 :</head><label>14</label><figDesc>Figure 14: Change propagation rules (stable and changeable).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>⊆Figure 15 :</head><label>15</label><figDesc>Figure 15: Change propagation simulates a complete reevaluation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>function modrw(x : 'a mod, f : 'a -&gt; 'b) : 'b = mod(fn d =&gt; read x (fn x' =&gt; write(d, f(x'))))</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The library does not enforce this restriction statically, but can enforce it with run-time checks. In the following discussion we will use the term "correct usage" to describe similar restrictions in which runtime checks are needed to check correctness. The language described in Section 5 enforces all these restrictions statically using a modal type system.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements We are grateful to Frank Pfenning for his advice on modal type systems. We also would like to thank Mihai Budiu, Aleks Nanevski, and the anonymous referees for their comments on the earlier drafts of this paper.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"> *   <p>This research was supported in part by NSF grants CCR-9706572, CCR-0085982, and CCR-0122581.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>for making and propagating changes found in the ML library. Instead, we give a direct presentation of the changepropagation algorithm in Section 6, which is defined in terms of the dynamic semantics of AFL given here. Just as with the ML implementation, the dynamic semantics must keep a record of the adaptive aspects of the computation. However, rather than use adg's, the semantics maintains this information in the form of a trace, which guides the change propagation algorithm. By doing so we are able to give a relatively straightforward proof of correctness of the change propagation algorithm in Section 6.</p><p>Abstract Syntax. The abstract syntax of AFL is given in Figure <ref type="figure">9</ref>. We use the meta-variables x, y, and z (and variants) to range over an unspecified set of variables, and the meta-variable l (and variants) to range over a separate, unspecified set of locations. The syntax of AFL is restricted to "2/3-cps", or "named form", to streamline the presentation of the dynamic semantics. The types of AFL include the base types int and bool; the stable function type, τ1 s → τ2; the changeable function type, τ1 c → τ2; and the type τ mod of modifiable references of type τ . Extending AFL with product, sum, recursive, or polymorphic types presents no fundamental difficulties, but they are omitted here for the sake of brevity.</p><p>Expressions are classified into two categories, the stable and the changeable. The value of a stable expression is not sensitive to modifications to the inputs, whereas the value of a changeable expression may, directly or indirectly, be affected by them. The familiar mechanisms of functional programming are embedded in AFL as stable expressions. These include basic types such as integers and booleans, and a sequential let construct for ordering evaluation. Ordinary functions arise in AFL as stable functions. The body of a stable function must be a stable expression; the application of a stable function is correspondingly stable. The stable expression modτ ec allocates a new modifiable reference whose value is determined by the changeable expression ec. Note that the modifiable itself is stable, even though its contents is subject to change.</p><p>Changeable expressions are written in destinationpassing style, with an implicit target. The changeable expression write(v) writes the value v into the target. The changeable expression read v as x in ec end binds the contents of the modifiable v to the variable x, then con-</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Adaptive functional programming</title>
		<author>
			<persName><forename type="first">A</forename><surname>Umut</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guy</forename><forename type="middle">E</forename><surname>Acar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Blelloch</surname></persName>
		</author>
		<author>
			<persName><surname>Harper</surname></persName>
		</author>
		<idno>CMU-CS- 01-161</idno>
		<imprint>
			<date type="published" when="2001-11">November 2001</date>
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon University, Computer Science Department</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Data structures for mobile data</title>
		<author>
			<persName><forename type="first">Julien</forename><surname>Basch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonidas</forename><forename type="middle">J</forename><surname>Guibas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Hershberger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Algorithms</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="28" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Incremental evaluation of attribute grammars with application to syntax directed editors</title>
		<author>
			<persName><forename type="first">Alan</forename><surname>Demers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Reps</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tim</forename><surname>Teitelbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference Record of the 8th Annual ACM Symposium on POPL</title>
		<imprint>
			<date type="published" when="1981-01">January 1981</date>
			<biblScope unit="page" from="105" to="116" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Two algorithms for maintaining order in a list</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">F</forename><surname>Dietz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">D</forename><surname>Sleator</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings. 19th ACM Symposium. Theory of Computing</title>
		<meeting>19th ACM Symposium. Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="365" to="372" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Fully persistent arrays</title>
		<author>
			<persName><forename type="first">F</forename><surname>Paul</surname></persName>
		</author>
		<author>
			<persName><surname>Dietz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Algorithms and Data Structures</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1989-08">August 1989</date>
			<biblScope unit="volume">382</biblScope>
			<biblScope unit="page" from="67" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Making data structures persistent</title>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">R</forename><surname>Driscoll</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Neil</forename><surname>Sarnak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">D</forename><surname>Sleator</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="86" to="124" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Fully persistent lists with catenation</title>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">R</forename><surname>Driscoll</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">D</forename><surname>Sleator</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="943" to="959" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Incremental reduction in the lambda calculus</title>
		<author>
			<persName><forename type="first">J</forename><surname>Field</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Teitelbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM &apos;90 Conference on LISP and Functional Programming</title>
		<meeting>the ACM &apos;90 Conference on LISP and Functional Programming</meeting>
		<imprint>
			<date type="published" when="1990-06">June 1990</date>
			<biblScope unit="page" from="307" to="322" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Incremental Graph Evaluation</title>
		<author>
			<persName><forename type="first">Roger</forename><surname>Hoover</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987-05">May 1987</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, Cornell University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Discovering auxiliary information for incremental computation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Yanhong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tim</forename><surname>Stoller</surname></persName>
		</author>
		<author>
			<persName><surname>Teitelbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference Record of the 23rd Annual ACM Symposium on POPL</title>
		<imprint>
			<date type="published" when="1996-01">January 1996</date>
			<biblScope unit="page" from="157" to="170" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Systematic derivation of incremental programs</title>
		<author>
			<persName><forename type="first">Yanhong</forename><forename type="middle">A</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tim</forename><surname>Teitelbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="30" />
			<date type="published" when="1995-02">February 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A judgmental reconstruction of modal logic</title>
		<author>
			<persName><forename type="first">Frank</forename><surname>Pfenning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rowan</forename><surname>Davies</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Notes to an invited talk at the Workshop on Intuitionistic Modal Logics and Applications (IMLA&apos;99)</title>
		<meeting><address><addrLine>Trento, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999">2001. July 1999</date>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="511" to="540" />
		</imprint>
	</monogr>
	<note>Mathematical Structures in Computer Science</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Incremental computation via function caching</title>
		<author>
			<persName><forename type="first">W</forename><surname>Pugh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Teitelbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference Record of the 16th Annual Symposium on POPL</title>
		<imprint>
			<date type="published" when="1989-01">January 1989</date>
			<biblScope unit="page" from="315" to="328" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Incremental computation via function caching</title>
		<author>
			<persName><forename type="first">William</forename><surname>Pugh</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987-08">August 1987</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, Cornell University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A categorized bibliography on incremental computation</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ramalingam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">W</forename><surname>Reps</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference Record of the 20th Annual ACM Symposium on POPL</title>
		<imprint>
			<date type="published" when="1993-01">January 1993</date>
			<biblScope unit="page" from="502" to="510" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Generating Language-Based Environments</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Reps</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1982-08">August 1982</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, Cornell University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Incremental compilation via partial evaluation</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Sundaresh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><surname>Hudak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference Record of the 18th Annual ACM Symposium on POPL</title>
		<imprint>
			<date type="published" when="1991-01">January 1991</date>
			<biblScope unit="page" from="1" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Inc: A language for incremental computations</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Yellin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Strom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="211" to="236" />
			<date type="published" when="1991-04">April 1991</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
