<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Exploring Predictive Replacement Policies for Instruction Cache and Branch Target Buffer</title>
				<funder ref="#_whNvCD6">
					<orgName type="full">unknown</orgName>
				</funder>
				<funder ref="#_zNvhDTD">
					<orgName type="full">National Science Foundation</orgName>
					<orgName type="abbreviated">NSF</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Samira</forename><forename type="middle">Mirbagher</forename><surname>Ajorpaz</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science &amp; Engineering</orgName>
								<orgName type="institution">Texas A&amp;M University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Elba</forename><surname>Garza</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science &amp; Engineering</orgName>
								<orgName type="institution">Texas A&amp;M University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sangam</forename><surname>Jindal</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science &amp; Engineering</orgName>
								<orgName type="institution">Texas A&amp;M University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Daniel</forename><forename type="middle">A</forename><surname>Jim?nez</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science &amp; Engineering</orgName>
								<orgName type="institution">Texas A&amp;M University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Exploring Predictive Replacement Policies for Instruction Cache and Branch Target Buffer</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1109/ISCA.2018.00050</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-01-03T08:37+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Modern processors support instruction fetch with the instruction cache (I-cache) and branch target buffer (BTB). Due to timing and area constraints, the I-cache and BTB must efficiently make use of their limited capacities. Blocks in the I-cache or entries in the BTB that have low potential for reuse should be replaced by more useful blocks/entries. This work explores predictive replacement policies based on reuse prediction that can be applied to both the I-cache and BTB. Using a large suite of recently released industrial traces, we show that predictive replacement policies can reduce misses in the I-cache and BTB. We introduce Global History Reuse Prediction (GHRP), a replacement technique that uses the history of past instruction addresses and their reuse behaviors to predict dead blocks in the Icache and dead entries in the BTB. This paper describes the effectiveness of GHRP as a dead block replacement and bypass optimization for both the I-cache and BTB. For a 64KB setassociative I-cache with a 64B block size, GHRP lowers the I-cache misses per 1000 instructions (MPKI) by an average of 18% over the leastrecently-used (LRU) policy on a set of 662 industrial workloads, performing significantly better than Static Re-reference Interval Prediction (SRRIP) [1] and Sampling Dead Block Prediction (SDBP)[2]. For a 4K-entry BTB, GHRP lowers MPKI by an average of 30% over LRU, 23% over SRRIP, and 29% over SDBP.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. Introduction</head><p>Modern processors rely on efficient instruction fetch to keep the pipeline fed with right-path instructions <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b3">[4]</ref>. To maintain that stream of instructions, the front-end relies on structures such as the instruction cache (I-cache) and branch target buffer (BTB). The I-cache stores blocks of recently used instructions, improving instruction throughput and latency. The BTB caches targets of previouslytaken branches to minimize target re-computation latency <ref type="bibr" target="#b4">[5]</ref>. Because of timing and area constraints, these structures require efficient organization and management to achieve high caching accuracies and speed.</p><p>Fig. <ref type="figure">1</ref>. Heat map illustrating cache efficiency <ref type="bibr" target="#b5">[6]</ref> of a 16KB 8-way I-cache using five replacement policies for a given trace. Lighter pixels represent longer live times.</p><p>A block is said to be live in a cache if it will be used again before it is evicted. A block is dead if it will not be used before evicted. Much recent work in data caches relies on predicting and replacing dead blocks. This paper explores such predictive policies for the I-cache and BTB.</p><p>Figure <ref type="figure">1</ref> illustrates the cache efficiency <ref type="bibr" target="#b5">[6]</ref> of a 16KB instruction cache using several replacement policies. Cache efficiency is the fraction of time a block is live in the cache. Each pixel represents a cache block in an 8-way set-associative, 16KB I-cache with each row corresponding to one set. Clearly, the replacement policy has a large impact on cache efficiency. Our proposed replacement policy, Global History Reuse Prediction, results in significant improvements in cache efficiency that translate into improved performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Instruction Cache and BTB Management</head><p>Most literature on I-cache management has focused on either prefetching techniques <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b11">[12]</ref>, or software-based techniques <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b15">[16]</ref>, <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b18">[19]</ref> to increase I-cache performance. However, very little work has been done on developing and evaluating replacement policies expressly for the I-cache. Smith and Goodman <ref type="bibr" target="#b19">[20]</ref> evaluate replacement policies for the I-cache but, due to the earliness of the work, analyze nascent policies like first-in, first-out (FIFO), least-recentlyused (LRU), and random replacement. We find very little work on high-performance BTB replacement policies, although we know through private communications that industry is very interested in good BTB replacement.</p><p>To improve replacement policies in the I-cache and BTB, we look to recent work in data cache replacement <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b21">[22]</ref>, <ref type="bibr" target="#b22">[23]</ref>, <ref type="bibr" target="#b23">[24]</ref>. A key idea in recent work is that sequences of recently accessed instructions correlate strongly with the likelihoods of block reuse. Training a predictor on control-flow traces based on sampled sets yields a high reuse prediction accuracy. We find this correlation holds within both I-cache and BTB, but due to the nature of instruction streams, the current literature's sampling approaches are unsuitable as we will see in Section II-A. In response to this analysis, we develop Global History Reuse Prediction (GHRP), a block replacement technique for the I-cache and BTB that can predict the reuse behaviors of the entries in these components.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Contributions</head><p>The contributions of this paper are:</p><p>1) An exploration of techniques for I-cache and BTB management using a set of over 600 industry-sourced workloads recently released through the Fifth Championship Branch Prediction Competition <ref type="bibr" target="#b24">[25]</ref>. 2) Evaluation of replacement policies adapted from recent work on data cache management to demonstrate their potential for improving I-cache and BTB hit rates. In particular, we explore whether using sampling-based policies benefit I-cache replacement. We compare these results to LRU as well as Static Re-reference Interval Prediction (SRRIP) <ref type="bibr" target="#b0">[1]</ref>. 3) Based on the analysis of the reference patterns of I-caches and BTBs, we describe why sampling-based policies like SDBP fail to predict dead blocks/entries. We thus propose Global History Reuse Prediction, a replacement policy for both the I-cache and BTB that exploits these reference pattern behaviors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. Background and Motivation</head><p>We have not found much recent work on the impact of replacement policy on BTB performance beyond the work of Perleberg et al. <ref type="bibr" target="#b25">[26]</ref>. New mobile and server workloads motivate us to take a fresh look at this area. As we explore I-cache design, exploring the BTB alongside it is a natural extension of our work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Sampling-Based Dead Block Prediction is Unsuitable</head><p>Our original intent was to apply PC-based dead block predictors such as SDBP and SHiP to instruction caches and BTBs. These predictors use setsampling <ref type="bibr" target="#b21">[22]</ref>, <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b20">[21]</ref> to generalize the behavior of accesses to a small number of cache sets over the entire cache. For example, SDBP can yield a good speedup from sampling only 32 of the 2,048 sets of a 2MB last-level cache. We expected to see good performance improvements for the I-cache and BTB as well, but were surprised that the results were disappointing. In retrospect the reason seems obvious but we will explain it here. PC-based predictors exploit the observation that, if a block in the data cache is accessed by a given PC and becomes dead, other blocks accessed by the same PC in other sets are likely to become dead as well. Set-sampling allows the predictor to learn from only a small number of sets, allowing the metadata store to be very small. Unfortunately, instruction streams do not allow for set-sampling in this way since the PC itself forms the index into the I-cache or BTB. Thus, set-sampling cannot generalize behavior on a small number of sets over the entire structure, as a given PC only accesses one set. Figure <ref type="figure">2</ref> illustrates this difference. Hereafter, we evaluate SDBP for I-cache and BTB with a sampler the same size as the cache, to avoid this inability to generalize.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Dead Block Prediction</head><p>It has been observed that caches often retain dead blocks, i.e. blocks in the cache that will not be used again until they are evicted <ref type="bibr" target="#b26">[27]</ref>. Dead blocks waste space and energy in the cache. Dead block prediction has been evaluated in the context of making replacement decisions in L1 Data cache <ref type="bibr" target="#b26">[27]</ref>, <ref type="bibr" target="#b27">[28]</ref>, Last level cache <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b27">[28]</ref>, <ref type="bibr" target="#b28">[29]</ref> and prefetching <ref type="bibr" target="#b26">[27]</ref>,  [30], bypassing <ref type="bibr" target="#b30">[31]</ref>, <ref type="bibr" target="#b31">[32]</ref>, <ref type="bibr" target="#b32">[33]</ref>, <ref type="bibr" target="#b33">[34]</ref>, <ref type="bibr" target="#b34">[35]</ref>, <ref type="bibr" target="#b35">[36]</ref>, <ref type="bibr" target="#b36">[37]</ref>, <ref type="bibr" target="#b37">[38]</ref>, <ref type="bibr" target="#b38">[39]</ref>, <ref type="bibr" target="#b39">[40]</ref>, <ref type="bibr" target="#b40">[41]</ref>, <ref type="bibr" target="#b41">[42]</ref>, <ref type="bibr" target="#b42">[43]</ref>, power reduction <ref type="bibr" target="#b43">[44]</ref>, <ref type="bibr" target="#b44">[45]</ref>, and cache coherence protocol optimization <ref type="bibr" target="#b45">[46]</ref>, <ref type="bibr" target="#b46">[47]</ref>, <ref type="bibr" target="#b47">[48]</ref>. Note that no cache replacement policy has been proposed for I-cache or BTB based on dead block prediction.</p><p>Lai et al. propose a trace-based dead block predictor <ref type="bibr" target="#b26">[27]</ref> used to prefetch data into predicted dead blocks and thus improve prefetching and replacement decisions for the L1 data cache. In this technique, a trace of instruction addresses that make reference to a block is summarized in a block signature associated with that block. The signature is used to index a table of saturating counters. The corresponding counter is incremented when a block is evicted and decremented when a block is reused, thus keeping track of the tendency of an instruction trace to lead to a dead block.</p><p>Kharbutli et al. propose a counter-based dead block prediction approach <ref type="bibr" target="#b22">[23]</ref> to drive cache replacement and bypassing. Each cache block is associated with a counter keeping track of the number of accesses to a block before it is evicted. The live time and access time of a block are tracked using Live time (LvP) and access time predictor (AIP). When the counter reaches a threshold, the block is predicted as dead. Blocks predicted dead on their first access are bypassed to the L1 cache.</p><p>Hu et al. propose timekeeping techniques <ref type="bibr" target="#b29">[30]</ref> that can be used to predict dead blocks by learning number of cycles a block is accessed. A block is considered dead if it is not accessed twice the number of cycles. Virtual Victim Cache <ref type="bibr" target="#b28">[29]</ref> uses a dead block predictor to reuse dead regions of the cache as a victim cache, effectively reducing conflict and capacity misses.</p><p>Liu et al. <ref type="bibr" target="#b27">[28]</ref> propose dead block prediction based on cache bursts, i.e., repetitive accesses to the mostrecently-used (MRU) position. In this scheme, the prediction is made when a block becomes non-MRU. Sampling-based Dead Block Prediction (SDBP) <ref type="bibr" target="#b1">[2]</ref> uses only the address (PC) of the most recent instruction, allowing it to be useful in the last-level cache and eliminating the need to store signatures with blocks. In this method, a predictor learns the pattern of accesses and evictions from a small number of sets. There is also some work <ref type="bibr" target="#b48">[49]</ref>, <ref type="bibr" target="#b49">[50]</ref> on software-based learning, in which hints from the compiler are learned to predict dead block information.</p><p>Our policy is the first to use dead block prediction in the I-cache and BTB. We compare it with the state of the art replacement policies LRU, SRRIP <ref type="bibr" target="#b0">[1]</ref>, SBDP <ref type="bibr" target="#b1">[2]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Static Re-reference Prediction(SRRIP)</head><p>SRRIP <ref type="bibr" target="#b0">[1]</ref> keeps track of the recency of blocks by predicting blocks that will be re-referenced again in the cache. Each block is associated with a two-bit re-reference prediction value. An initial prediction is made on block placement and revised when a block is reused or replaced.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Hashed Perceptron Branch Predictor</head><p>Alongside the I-cache and BTB, we need a highly accurate branch predictor. We have used a hashed perceptron branch predictor <ref type="bibr" target="#b50">[51]</ref> that merges the concepts behind the gshare <ref type="bibr" target="#b51">[52]</ref>, path-based <ref type="bibr" target="#b52">[53]</ref> and perceptron branch predictors <ref type="bibr" target="#b53">[54]</ref>. The main idea is that the one-to-one correlation of weights to the number of history bits in a perceptron is not necessary. The hashed value of a history of instruction addresses is used in combined with global branch outcome to index the weight tables. Perceptron-based branch predictors are used in high-performance ARM processors from Samsung <ref type="bibr" target="#b54">[55]</ref> as well as processors from AMD and Oracle <ref type="bibr" target="#b55">[56]</ref>, <ref type="bibr" target="#b56">[57]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. I-Cache Optimizations</head><p>Previous work on I-cache management has focused on instruction prefetching <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b11">[12]</ref>, code placement optimization <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b15">[16]</ref>, <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b18">[19]</ref>, and basic block reordering <ref type="bibr" target="#b57">[58]</ref>. Prefetching schemes <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b11">[12]</ref> focus on keeping a record of committed instruction streams, which better predict future control transfers and accesses to instruction blocks. Work on cache block alignment <ref type="bibr" target="#b57">[58]</ref> and other software solutions <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b15">[16]</ref>, <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b18">[19]</ref> help minimize conflict misses and improve locality within the I-cache.</p><p>Several proposed solutions incur a large hardware overhead. For example, Shift <ref type="bibr" target="#b9">[10]</ref> has 240KB storage overhead (750% of I-cache capacity) just for the index table, compared to 5KB of GHRP overhead for a larger I-cache. Similarly, some previous work explores unrealistically low associativities resulting in higher MPKI, while we model a realistic I-cache from the Samsung Mongoose processor. Little work has focused on evaluating and creating replacement policies for the I-cache <ref type="bibr" target="#b19">[20]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F. BTB Optimizations</head><p>Previous literature <ref type="bibr" target="#b58">[59]</ref>, <ref type="bibr" target="#b25">[26]</ref>, <ref type="bibr" target="#b59">[60]</ref>, <ref type="bibr" target="#b60">[61]</ref>, <ref type="bibr" target="#b61">[62]</ref>, <ref type="bibr" target="#b62">[63]</ref> on the BTB has focused on its design structure, including the branch target selection algorithm, the utilization of multi-level BTB organizations, and using different replacement policies. To reduce the bit storage overhead in the BTB, Fagin et al. propose an encoding scheme requiring the storing of partial tags <ref type="bibr" target="#b63">[64]</ref>. Kobayashi et al. <ref type="bibr" target="#b64">[65]</ref> further the work by also encoding target addresses' higher-order and lower-order bits separate tables. Other schemes for the BTB <ref type="bibr" target="#b65">[66]</ref>, <ref type="bibr" target="#b66">[67]</ref> attempt to better capture large workloads by augmenting the effective BTB size via secondary structures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G. Joint I-Cache/BTB Management</head><p>Some previous work <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b67">[68]</ref> addresses the BTB and I-cache design problem together. Kaynak et al. <ref type="bibr" target="#b10">[11]</ref> take advantage of in-common metadata to simultaneously prefetch blocks and branch instructions into the I-cache and BTB, respectively. Similarly, Rakesh et al. <ref type="bibr" target="#b67">[68]</ref> propose a branch predictor-directed prefetching strategy that also populates the I-cache and BTB concurrently, however, without the need for metadata. In this paper, we have focused on maintaining efficient utilization of both the I-cache and BTB by targeting the removal of dead blocks/BTB entries. updateLRU stackP osition()</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1 GHRP</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. Global History Reuse Predictor</head><p>It is often the case that a majority of the blocks in the last-level cache (LLC) are dead <ref type="bibr" target="#b1">[2]</ref>. LLC dead block predictors are adept at determining whether a block is dead after its first access. However, their accuracy declines for subsequent accesses. Because common access patterns to the BTB and I-cache tend to consist of multiple reuses before eviction, current PC-based dead block prediction schemes such as SDBP and SHiP are ill-fit for these structures as explained in section II-A. An algorithm that takes into account control-flow history should have  higher accuracy <ref type="bibr" target="#b26">[27]</ref>, <ref type="bibr" target="#b68">[69]</ref>. While PC-based policies can only efficiently predict dead blocks at insertion time, Global History Reuse Predictor (GHRP) is able to predict dead blocks more generally, either at insertion or at the last reuse. The main steps taken by GHRP are shown in Algorithm 1. We first propose GHRP algorithm for I-cache replacement and present results. Then we describe an enhancement for BTB replacement that uses minimal extra overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Signature formula in GHRP</head><p>Like previous dead block predictors, GHRP indexes a table of counters with a signature generated from features correlated with reuse behavior. The GHRP signature uses the global path history of instruction addresses. Algorithm 2 line 1 shows the steps of updating the global path history. To update the global history, on every access we shift the three lowest-order bits of the PC into the history followed by one zero bit. The history register is 16 bits, allowing four previous accesses to be recorded. The signature is constructed by exclusive-ORing the history with the PC of the access to be predicted (Algorithm 2 line 4) . The zero bits in the history allow some of the PC bits to pass into the signature unmodified, yielding a useful hash of the history and PC. To compute indices into the prediction tables, we compute three different 12-bit hashes of the 16bit signature with the function ComputeIndices in Algorithm 2 line 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. GHRP Prediction State</head><p>GHRP stores metadata for each I-cache block, consisting of 3 LRU stack position bits, a valid bit, a 16-bit signature and a prediction bit. Let us consider a real-world example I-cache: the Samsung Exynos M1 processor has a 64KB I-cache with 128B blocks <ref type="bibr" target="#b54">[55]</ref>. The extra metadata and prediction tables of GHRP would impose an additional 5.13 KB of metadata, or 8% of the capacity of the I-cache. All of GHRP's operations are off the critical path to hitting Algorithm 2 Updating path history and computing signatures 1: procedure UpdatePathHist(int PC, int history)</p><formula xml:id="formula_0">2:</formula><p>history ? history &lt;&lt; 4 </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. GHRP Predictor Table Indexing</head><p>GHRP uses three tables to provide a prediction via majority vote. This technique is shown in Algorithm 3. Each table is indexed by a distinct hash function similarly to the three tables in SDBP <ref type="bibr" target="#b1">[2]</ref>. The indexing step is shown in Algorithm 2 line 7 and Algorithm 4. Each of the three corresponding counters is thresholded. If two or more counters exceed the threshold, the aggregate prediction is that the entry is dead. SDBP also utilizes three tables but aggregates the results via summation rather than majority vote. We find majority vote <ref type="bibr" target="#b69">[70]</ref> superior to summation due to the nature of instruction cache accesses versus LLC accesses: with a high threshold and summation, SDBP is more conservative when it decides to predict a block as dead. Aliasing in the prediction tables leads to a lack of confidence and less coverage, rather than costly LLC misses. Instruction accesses are less likely to be dead, requiring lower thresholds for reasonable coverage. Majority vote avoids the effects of aliasing without needing a high threshold, so coverage and accuracy can both improve.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Accessing Predictor Table and Metadata in GHRP</head><p>On each access to the I-cache, the global path history is used to make the signature (Algorithm 1 lines 5)(Algorithm 2 line 4). Next, the prediction tables are indexed by hashing the signature. The corresponding counters are read out from the arrays (Algorithm 1 lines 6, 7, Algorithm 4 and Algorithm 2 line 7). Figure <ref type="figure" target="#fig_1">4</ref> illustrates the datapath for making a prediction.</p><p>The prediction table needs to be accessed on each access to I-cache because for each reuse the future prediction for one block may vary as the global history changes. Even if there were a hit during one access the next accurate prediction for that block may be dead. Thus, this prediction will be obtained from the prediction table indexed by the signature made with the current history and will be used to update the prediction bit in I-cache. The fact that the block received a hit during an access reveals an information about its future reuses and so the prediction table entry indexed with the old signature will be updated. On a miss, the prediction bit of the evicted block is updated with a prediction obtained by indexing the prediction table with the current history. Reading from prediction table is also necessary on each access to the I-cache to allow bypass. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 4 Index prediction tables and get counters procedure GetCounters(int[][] predTables, int[] indices) for t = 1 to numPredTables do counters[t] ? predTables[indices[t], [t]] return counters[]</head><p>The counters are used to decide if the incoming block should be bypassed or placed. In case of a miss, the tables vote and decide to bypass the block if the majority of the corresponding counters are above the bypass threshold. If the vote is to bypass, there are no more accesses to the prediction tables, and no metadata is updated. On the other hand, if it was a miss that is not bypassed (Algorithm 1 line 13) then a victim block is chosen to be replaced with the new one (Algorithm 1 line 14). GHRP first tries to find a predicted dead block by reading the prediction bit of each block: block.dead. If no block was predicted as dead then GHRP evicts the LRU block. The details of victim block selection is shown in Algorithm 5. As soon as one block is chosen to be evicted, the prediction tables need to be updated by the new information about this eviction. First, the signature bits of the victim block are used to index the prediction tables and each corresponding counter is increased by one since the block was just shown to be dead (Algorithm 6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 5</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 6 Index prediction tables and update counters procedure updatePredTables(int[] indices, bool isDead, ) for t = 1 to numPredTables do if isDead = true then predTables[ indices[t], [t]]++ else predTables[ indices[t], [t]]--</head><p>After replacing the new block, the corresponding metadata for that block is updated (Algorithm 1 lines 20, 28 and 19). The dead block prediction for the signature made based on the current PC is obtained (Algorithm 1 line 18) and the prediction bit is updated (Algorithm 1 line 19). Algorithm 1 lines 15 to 18 summarizes the steps taken for eviction. Note that GHRP does not update the predictor table for the new signature related to current access. Rather, it updates the signature bits of the corresponding block which will be used in the future accesses.</p><p>In the case of a hit access (Algorithm 1 line 21) first, the prediction tables will be indexed based on the old signature in the block (Algorithm 1 line 23) and the corresponding counters will be decreased by one to make sure this block will be predicted as live under the same conditions in the future (Algorithm 1 lines 25 and Algorithm 6). Then the old signature is replaced with the new one and the prediction bit is replaced with the prediction obtained from the prediction table.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Adapting GHRP for BTB Replacement</head><p>The BTB is another cache-like structure that relies on a replacement policy to do a good job of providing branch targets. We use the GHRP algorithm to enable improved replacement of BTB entries as well as I-cache block replacement. Every BTB access comes from a branch that occupies some I-cache block. When a BTB access is made, the metadata corresponding to that branch's block in the I-cache is used to make a GHRP prediction. That is, the signature recorded for that I-cache block is used to index the I-cache GHRP prediction tables to generate three predictions that are thresholded and majorityvoted to yield a dead-entry prediction for that BTB entry. Each BTB entry maintains one additional bit of metadata: a prediction bit that records whether that BTB entry is predicted as dead. The history register is also shared and is only updated with branch PCs using the same formula. All of the other structures for the GHRP algorithm are already present for use by the I-cache dead block prediction, so BTB replacement comes with almost no additional overhead. As in the I-cache, BTB replacement and bypass are guided by GHRP. A predicted dead block will be evicted, or if there is no such block, the LRU block will be evicted.</p><p>We first modeled GHRP as a stand-alone replacement policy with its own metadata, but realized that the size of the predictor would be so large that it would make more sense to simply increase the BTB size. However, we noticed that the prediction tables and metadata from the I-cache did just as well for the BTB. This result is somewhat counterintuitive; as cache blocks may have multiple branches, we would make the same prediction for each BTB entry in a cache block. However, the algorithm still provides good BTB replacement for the following reasons:</p><p>1) Most branches are highly biased to be taken or not taken. A branch that is never taken will not get a BTB entry, so it will never need to replace another entry or be replaced. A branch that is seldom taken will have its BTB entry quickly reach the LRU position, and when it is occasionally taken the BTB miss will not have a large impact on MPKI. 2) On the other hand, a branch that is always or often taken will cut off fetching to other branches in the same cache block, so those branches will seldom or never need BTB entries. 3) Due to modulo indexing of the BTB, branches in the same cache block will map to distinct BTB sets. Figure <ref type="figure" target="#fig_3">5</ref> illustrates a BTB heat map for the various policies similar to the one shown in Figure <ref type="figure">1</ref>. One noticeable feature of this image is that the different sets experience different levels of access, i.e. there are hot and cold sets. If a cache block is mostly live, the corresponding BTB entries will be predicted as live. This will protect vulnerable BTB entries in hot sets and not matter for BTB entries in cold sets. 4) It is possible that a dead BTB entry will be falsely predicted as live, but this sort of misprediction only reduces the opportunity to evict that block, rather than the other kind of misprediction that falsely predicts a live block as dead and can lead to a miss. By tuning the threshold for BTB predictions separately from I-cache predictions, we find a balance that minimizes false dead predictions while allowing the best coverage for the replacement optimization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F. Impact of Misspeculation on Training</head><p>To prevent wrong-path information from polluting the prediction tables, GHRP only updates the tables of counters at commit time with right-path branches, a practice consistent with branch predictor implementation <ref type="bibr" target="#b70">[71]</ref>, <ref type="bibr" target="#b71">[72]</ref>. GHRP uses path history to make predictions. The history used to predict the current I-cache or BTB access must be current, so GHRP uses the stream of fetch addresses from the branch predictor to update its history speculatively. For recovery from mispredictions, GHRP borrows a technique from branch prediction speculative history management <ref type="bibr" target="#b71">[72]</ref>. GHRP maintains two path histories: the speculative history updated using the outcome of the branch predictor, and a nonspeculative history updated when a branch is retired from the reorder buffer (ROB). On a misprediction, the speculatively history is restored from the nonspeculative one. To support speculation on a modern processor, the I-cache and BTB may be updated according to wrong-path cache accesses and targets. Thus, GHRP updates its prediction tables based on the speculative history so that its predictions reflect the liveness of actual accesses to the BTB and Icache.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G. Integrating GHRP into a Modern Decoupled Front-End</head><p>Modern processors use decoupled front-ends to fill an instruction queue. To ensure efficient instruction delivery, a new component must not introduce extra latency into the critical path for dequeuing instructions. Fortunately, none of GHRP's operations are on the critical path. Predictions are used to drive BTB and I-cache replacement, and can occur simultaneously with target computation and reading the L2, respectively. The speculative path history is updated simultaneously with branch predictor histories which, in a modern processor, are far deeper than the simple history used by GHRP. Using 8T SRAM cells for the prediction tables would allow updates to be made simultaneously with prediction. More area-friendly 6T cells would require some queuing of updates, but since the counters tend to saturate quickly most accesses would not require training.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. Methodology A. Simulation Infrastructure</head><p>We use the simulator and traces released for the recent Championship Branch Prediction competition(CBP5) <ref type="bibr" target="#b24">[25]</ref>. As it is intended for branch prediction studies, we augment it with additional code to study the I-cache and BTB. We use a hashed perceptron predictor as the branch direction predictor <ref type="bibr" target="#b50">[51]</ref>. Perceptron-based branch predictors are used in highperformance ARM processors from Samsung <ref type="bibr" target="#b54">[55]</ref> as well as processors from AMD and Oracle <ref type="bibr" target="#b55">[56]</ref>, <ref type="bibr" target="#b56">[57]</ref>.</p><p>The original traces contain one record for every branch, including conditional, unconditional, indirect, and returns. From these traces we reconstruct the block address of every instruction fetch group by inferring the missing instructions between branch targets. The simulator is not cycle accurate, so we use misses per 1000 instructions (MPKI) as our figure of merit. For a given benchmark, MPKI is roughly proportional to cycles per instruction (CPI). Arithmetic mean MPKI gives a good overall indication of the relative benefits of I-cache and BTB replacement policies.</p><p>We measure performance of the I-cache and BTB using LRU replacement as the baseline. We study static re-reference interval prediction (SRRIP), sampling-based dead block prediction (SDBP) and global history reuse prediction (GHRP) for different configuration parameters such as associativity, block size and cache size. We characterize the workloads as described in the following section.</p><p>For this study, we use a modified version of SDBP. The following modifications are applied to achieve the best possible results for I-cache and BTB based on SDBP design: 1) The sampler is as large as the cache, i.e. it has the same number of sets and same associativity. 2) Tuned dead block threshold to decrease number of false positives. 3) Tuned bypass threshold to avoid costly incorrect dead predictions. The original SDBP work used 2-bit counters, but in the context of I-cache and BTB we find the best performance comes with 8-bit counters. This is mainly to cover high bypass value which was required to get better accuracy. Our SDBP uses three skewed prediction table to reduce the possibility of miss prediction due to conflicts. Each entry in the sampler consist of 1 valid bit, 1 prediction bit, 3 bits to maintain LRU positions, 12 bits as partial PC (signature), and 16 bits of tag. Taking these steps adapts SDBP to work well with instruction streams as explained in Section II-A.</p><p>GHRP also keeps metadata for each I-cache block and BTB entry. GHRP also uses three skewed prediction tables. Each of the 4,096 entries in the tables contains a two-bit counter. The additional metadata for each block consists of 1 prediction bit, 3 bits to maintain LRU positions, and 16 bits of signature. Table I summarizes the storage requirements for GHRP for a 64KB I-cache with 8-way associativity. The modified SDBP requires considerably more storage due to the wider prediction tables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Workloads</head><p>We use the set of 662 traces provided as a part of CBP5. The distribution of benchmarks is a mixed set of SHORT-MOBILE, LONG-MOBILE, SHORT-SERVER, and LONG-SERVER workloads. Short traces are simulated completely, while long traces are allowed to run for the first one billion instructions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Warm-up</head><p>In each simulation, we warm the cache using the first half of the instructions in the trace, or up to two hundred million instructions, whichever comes first. We stop the simulation after one billion instructions. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. Results</head><p>In this section we describe the results of experiments simulating the GHRP policy as well as policies adapted from previous work. We first present results on I-cache replacement, then give results for BTB replacement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. I-Cache Results</head><p>Figure <ref type="figure" target="#fig_4">6</ref> depicts per-benchmark results for the various replacement policies for a 8 way 64KB I-cache with 64B blocks. The x-axis shows the benchmarks in order of sorted MPKI for LRU and is compared with other policies. Since it is not possible to depict the bar charts for all 662 benchmarks, an S-curve is shown in Figure <ref type="figure" target="#fig_2">3</ref> for the 64KB I-cache on all 662 benchmarks. On average for the 662 workloads, GHRP achieves 0.86 average MPKI, compared with 1.05 for LRU, 1.14 for Random, 1.02 for SRRIP, and 1.10 for SDBP. GHRP improves average MPKI by 18% over LRU, 24% over Random, 16% over SRRIP and 22% over SDBP. For a subset of 123 benchmarks experiencing at least 1 MPKI under the LRU policy on average, GHRP achieves 4.32 MPKI, compared with 5.11 for LRU, 5.53 for Random, 4.50 for SRRIP, and 5.38 for SDBP. GHRP improves average MPKI by 26% over LRU, 32% over Random, 15% over SRRIP and 20% over SDBP. GHRP is the only policy that significantly improves MPKI over LRU.For the vast majority of cases, GHRP provides lower MPKI than the other policies. In only 14 out of the 662 traces, GHRP fails to improve over LRU. This number is 106 for SDBP, 110 for SRRIP and 541 for Random.</p><p>We focus on the 64KB I-cache as it represents a common configuration in existing processors. However, we have also explored other configurations to verify our approach. I-cache MPKI values averaged over all 662 benchmarks mentioned above for multiple configurations are shown in Figure <ref type="figure">7</ref>. The figure shows various combinations of 8KB, 16KB, 32KB and 64KB caches with 64B blocks and 4-way or 8way associativity. For each configuration, the trend is the same: Random performs poorly, SRRIP performs better than LRU and SDBP perform better in some benchmarks and worse than LRU in some others, and GHRP provides significantly lower MPKI than the other policies.</p><p>1) Statistical Analysis: Figure <ref type="figure">8</ref> is the average of difference relative to LRU with error bars (95% confidence interval). The relative difference for GHRP is negative more than 95% of the times meaning that the MPKI was lower compared to LRU, and the average of this relative difference is -33% meaning that on average there is a 33% reduction in MPKI using GHRP compared to LRU. In more than 95% of tests the relative difference is at least 31% reduction (-31%).</p><p>Figure <ref type="figure">9</ref> shows that the number of traces in which Random performed worse than LRU (541) is 5 times more than this measurement in SDBP (106). This  difference shows that SDBP can still a benefit large number of workloads (41% of traces) while harming 16% and performing similarly to LRU for the others (42% of traces). On the other hand, Figure <ref type="figure">9</ref> shows that the number of traces in which SRRIP performs worse than LRU (110) is close to this measurement for SDBP (106).</p><p>The figure also shows that GHRP is sufficient for 98% of traces (benefits 83% of traces and being similar to LRU for 14% of traces) while only harming 2% of traces. This observation did not indicate any dependency on trace category (SHORT-MOBILE, LONG-MOBILE, SHORT-SERVER and LONG-SERVER).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Branch Target Buffer</head><p>BTB misses for the various policies are shown in Figure <ref type="figure" target="#fig_6">10</ref>. Since it was not possible to depict the bar charts for all 662 benchmarks so Figure <ref type="figure">11</ref> shows an S-curve for the 64KB I-cache on all 662 benchmarks. This BTB has 4,096 entries and is modeled after the Mongoose <ref type="bibr" target="#b54">[55]</ref> BTB.</p><p>We find that more traces experience high MPKIs with smaller BTBs, but to keep our research rele-vant to future processors we choose a modern BTB capacity. Over these traces, the LRU policy yields an average 4.58 MPKI. Random is worse at 4.81 MPKI, SRRIP and SDBP are slightly better at 4.17 and 4.57 MPKI, respectively. GHRP has the lowest average MPKI at 3.21, a 30.0% improvement over LRU, 33.3% over Random, 23.1% over SRRIP and 29.1% over SDBP.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. Conclusions and Future Work</head><p>This paper has demonstrated that predictive replacement policies can significantly reduce I-cache and BTB misses over a large suite of industrial traces. Previous replacement policies adapted from data cache replacement policies have potential, but a policy specifically designed for instruction streams has greater benefits. We introduce Global History Reuse Prediction, a dead block/entry predictor designed for instruction streams. In future work we will explore how our techniques interact with highperformance indirect branch prediction.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Fig.2. Set-sampling for PC-based dead block predictors does not work for I-cache or BTB. For an 8-way, 16-set data cache (a), it is sufficient to sample the first two sets to generalize behavior over the entire cache. For an 8-way, 16-set I-cache or BTB (b), one PC accesses only one set, so the behavior of all sets must be measured. Hereafter SDBP is modeled sampling all cache sets.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 4 .</head><label>4</label><figDesc>Fig.4. Prediction datapath. Three hash functions of the signature index 3 tables to read 2-bit counters that are thresholded to make predictions. Aggregate prediction is by majority vote.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. MPKI comparison of various policies for a 8-way 64KB I-cache with 64B cache lines. The horizontal axis shows the benchmarks in the order of sorted MPKI for LRU. Multiple areas of the graph are shown in zoomed windows for different ranges of MPKI.</figDesc><graphic url="image-3.png" coords="7,73.32,72.57,468.74,165.02" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Heat map showing the efficiency of a 256-entry, 8way BTB using five replacement policies for a given industrial trace. The darker the pixel, the block remains unevicted while dead. GHRP improves live time over the other policies.</figDesc><graphic url="image-4.png" coords="8,322.03,495.96,210.74,129.26" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. MPKI for a 64KB 8-way I-cache with 64B cache lines for various policies over benchmarks. The last group of bars shows the average among the benchmarks illustrated.</figDesc><graphic url="image-5.png" coords="9,73.57,72.73,144.50,129.02" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 7 .Fig. 8 .</head><label>78</label><figDesc>Fig. 7. Average MPKI for multiple I-cache configuration with various policies. g g g</figDesc><graphic url="image-16.png" coords="10,73.22,211.60,234.50,178.94" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. BTB MPKI for a 4-way 4K-entry BTB with various policies.</figDesc><graphic url="image-22.png" coords="11,73.47,219.01,468.74,177.74" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 11 .Fig. 9 .</head><label>119</label><figDesc>Fig. 11. MPKI comparison of various policies for a 8-way 4K BTB. The horizontal axis is showing the benchmarks in the order of sorted MPKI for LRU. Multiple areas of the graph are shown in zoomed windows for different ranges of MPKI. g</figDesc><graphic url="image-23.png" coords="11,73.59,424.69,167.54,103.34" type="bitmap" /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgments</head><p>This research was funded in part by <rs type="funder">NSF</rs> grants <rs type="grantNumber">CCF-1649242</rs> and <rs type="grantNumber">CCF-1216604/1332598</rs>. Thanks to the anonymous reviewers for their many helpful suggestions, and heartfelt thanks in particular to <rs type="person">Mike Ferdman</rs> for his help preparing the final version of this paper.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_zNvhDTD">
					<idno type="grant-number">CCF-1649242</idno>
				</org>
				<org type="funding" xml:id="_whNvCD6">
					<idno type="grant-number">CCF-1216604/1332598</idno>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">High performance cache replacement using re-reference interval prediction (rrip)</title>
		<author>
			<persName><forename type="first">A</forename><surname>Jaleel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">B</forename><surname>Theobald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Steely</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Emer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="60" to="71" />
			<date type="published" when="2010">2010</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Sampling dead block prediction for last-level caches</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Jim?nez</surname></persName>
		</author>
		<editor>MICRO</editor>
		<imprint>
			<date type="published" when="2010-12">December 2010</date>
			<biblScope unit="page" from="175" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Fetching instruction streams</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ramirez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">J</forename><surname>Santana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Larriba-Pey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Valero</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 35th annual ACM/IEEE international symposium on Microarchitecture</title>
		<meeting>the 35th annual ACM/IEEE international symposium on Microarchitecture</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="371" to="382" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A comprehensive instruction fetch mechanism for a processor supporting speculative execution</title>
		<author>
			<persName><forename type="first">T.-Y</forename><surname>Yeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">N</forename><surname>Patt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGMICRO Newsletter</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="129" to="139" />
			<date type="published" when="1992">1992</date>
			<publisher>IEEE Computer Society Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Branch prediction strategies and branch target buffer design</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">K F</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="6" to="22" />
			<date type="published" when="1984-01">Jan 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">The declining effectiveness of dynamic caching for general-purpose microprocessors</title>
		<author>
			<persName><forename type="first">D</forename><surname>Burger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Goodman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kagi</surname></persName>
		</author>
		<idno>1261</idno>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Temporal instruction fetch streaming</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ferdman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Wenisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ailamaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Falsafi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moshovos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">st IEEE/ACM International Symposium on</title>
		<editor>
			<persName><surname>Microarchitecture</surname></persName>
		</editor>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2008">2008. 2008. 2008</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
	<note>MICRO-41</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Proactive instruction fetch</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ferdman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kaynak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Falsafi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 44th Annual IEEE/ACM International Symposium on Microarchitecture</title>
		<meeting>the 44th Annual IEEE/ACM International Symposium on Microarchitecture</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="152" to="162" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Efetch: optimizing instruction fetch for event-driven webapplications</title>
		<author>
			<persName><forename type="first">G</forename><surname>Chadha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mahlke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Narayanasamy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd international conference on Parallel architectures and compilation</title>
		<meeting>the 23rd international conference on Parallel architectures and compilation</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="75" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Shift: Shared history instruction fetch for lean-core server processors</title>
		<author>
			<persName><forename type="first">C</forename><surname>Kaynak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Grot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Falsafi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 46th Annual IEEE/ACM International Symposium on Microarchitecture</title>
		<meeting>the 46th Annual IEEE/ACM International Symposium on Microarchitecture</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="272" to="283" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Confluence: unified instruction supply for scale-out servers</title>
		<author>
			<persName><forename type="first">C</forename><surname>Kaynak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Grot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Falsafi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 48th International Symposium on Microarchitecture</title>
		<meeting>the 48th International Symposium on Microarchitecture</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="166" to="177" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Rdip: returnaddress-stack directed instruction prefetching</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kolli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Saidi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Wenisch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Microarchitecture (MICRO), 2013 46th Annual IEEE/ACM International Symposium on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="260" to="271" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Program optimization for instruction caches</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mcfarling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third International Conference on Architectural Support for Programming Languages and Operating Systems</title>
		<meeting>the Third International Conference on Architectural Support for Programming Languages and Operating Systems</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="183" to="191" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Procedure placement using temporal-ordering information</title>
		<author>
			<persName><forename type="first">N</forename><surname>Gloy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems (TOPLAS)</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="977" to="1027" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Carr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Mckinley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-W</forename><surname>Tseng</surname></persName>
		</author>
		<title level="m">Compiler optimizations for improving data locality</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">29</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Cacheconscious data placement</title>
		<author>
			<persName><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Krintz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>John</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Austin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Notices</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="139" to="149" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Efficient procedure mapping using cache line coloring</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">H</forename><surname>Hashemi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Kaeli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Notices</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="171" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Achieving high instruction cache performance with an optimizing compiler</title>
		<author>
			<persName><forename type="first">W.-M</forename><forename type="middle">W</forename><surname>Hwu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">P</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="242" to="251" />
			<date type="published" when="1989">1989</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Optimizing instruction cache performance for operating system intensive workloads</title>
		<author>
			<persName><forename type="first">J</forename><surname>Torrellas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Daigle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">High-Performance Computer Architecture, 1995. Proceedings., First IEEE Symposium on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="360" to="369" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Instruction cache replacement policies and organizations</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Goodman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="234" to="241" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">SHiP: Signature-based hit predictor for high performance caching</title>
		<author>
			<persName><forename type="first">C.-J</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jaleel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Hasenplaugh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Martonosi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Simon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Steely</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Emer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 44th Annual IEEE/ACM International Symposium on Microarchitecture, MICRO-44</title>
		<meeting>the 44th Annual IEEE/ACM International Symposium on Microarchitecture, MICRO-44<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="430" to="441" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A case for mlp-aware cache replacement</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Qureshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">N</forename><surname>Lynch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Mutlu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">N</forename><surname>Patt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd Annual International Symposium on Computer Architecture, ISCA &apos;06</title>
		<meeting>the 33rd Annual International Symposium on Computer Architecture, ISCA &apos;06<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="167" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Counter-based cache replacement and bypassing algorithms</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kharbutli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Solihin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="433" to="447" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Exploiting compressed block size as an indicator of future reuse</title>
		<author>
			<persName><forename type="first">G</forename><surname>Pekhimenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Huberty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Mutlu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">B</forename><surname>Gibbons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Kozuch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">C</forename><surname>Mowry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">21st IEEE International Symposium on High Performance Computer Architecture, HPCA 2015</title>
		<meeting><address><addrLine>Burlingame, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">February 7-11, 2015. 2015</date>
			<biblScope unit="page" from="51" to="63" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<ptr target="https://www.jilp.org/cbp" />
	</analytic>
	<monogr>
		<title level="m">The 5th JILP Championship Branch Prediction Competition (CBP-5)</title>
		<imprint>
			<date type="published" when="2016-06">2016. June 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Branch target buffer design and optimization</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Perleberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE transactions on computers</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="396" to="412" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Dead-block prediction and dead-block correlating prefetchers</title>
		<author>
			<persName><forename type="first">A</forename><surname>Lai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Fide</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Falsafi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th International Symposium on Computer Architecture</title>
		<meeting>the 28th International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="144" to="154" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Cache bursts: A new approach for eliminating dead blocks and increasing cache efficiency</title>
		<author>
			<persName><forename type="first">H</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ferdman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Huh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Burger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE/ACM International Symposium on Microarchitecture</title>
		<meeting>the IEEE/ACM International Symposium on Microarchitecture<address><addrLine>Los Alamitos, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="222" to="233" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Using dead blocks as a virtual victim cache</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Jim?nez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Burger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Falsafi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th Workshop on Chip Multiprocessor Memory Systems and Interconnects (CMP-MSI)</title>
		<meeting>the 4th Workshop on Chip Multiprocessor Memory Systems and Interconnects (CMP-MSI)</meeting>
		<imprint>
			<date type="published" when="2010-01">January 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Timekeeping in the memory system: predicting and optimizing memory behavior</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kaxiras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Martonosi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGARCH Comput. Archit. News</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="209" to="220" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Improving cache performance by selective cache bypass</title>
		<author>
			<persName><forename type="first">C.-H</forename><surname>Chi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Dietz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Architecture Track, Proceedings of the Twenty-Second Annual Hawaii International Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1989">1989. 1989</date>
			<biblScope unit="volume">I</biblScope>
			<biblScope unit="page" from="277" to="285" />
		</imprint>
	</monogr>
	<note>System Sciences</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Compiler managed micro-cache bypassing for high performance epic processors</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rakvic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L.-L</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-C</forename><surname>Miao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Chrysos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Fang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings. 35th Annual IEEE/ACM International Symposium on</title>
		<meeting>35th Annual IEEE/ACM International Symposium on</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="134" to="145" />
		</imprint>
	</monogr>
	<note>in Microarchitecture, 2002.(MICRO-35</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Run-time cache bypassing</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">L</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Connors</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Merten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-M</forename><surname>Hwu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1338" to="1354" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Active management of data caches by exploiting reuse information</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">S</forename><surname>Tam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Rivers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Srinivasan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Tyson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">S</forename><surname>Davidson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1244" to="1259" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Run-time adaptive cache hierarchy management via reference analysis</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">L</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-M</forename><forename type="middle">W</forename><surname>Hwu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="315" to="326" />
			<date type="published" when="1997">1997</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Utilizing reuse information in data cache management</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Rivers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">S</forename><surname>Tam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Tyson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">S</forename><surname>Davidson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Farrens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th international conference on Supercomputing</title>
		<meeting>the 12th international conference on Supercomputing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="449" to="456" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Reducing conflicts in direct-mapped caches with a temporality-based design</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Rivers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">S</forename><surname>Davidson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1996 International Conference on</title>
		<meeting>the 1996 International Conference on</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1996">1996. 1996</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="154" to="163" />
		</imprint>
	</monogr>
	<note>Parallel Processing</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">The split temporal/spatial cache: initial performance analysis</title>
		<author>
			<persName><forename type="first">V</forename><surname>Milutinovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Markovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tomasevic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tremblay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the SCIzzL-5</title>
		<meeting>of the SCIzzL-5<address><addrLine>Santa Clara, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="72" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">A data cache with multiple caching strategies tuned to different types of locality</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gonz?lez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Aliagas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Valero</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM International Conference on Supercomputing 25th Anniversary Volume</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="217" to="226" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">A modified approach to data cache management</title>
		<author>
			<persName><forename type="first">G</forename><surname>Tyson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Farrens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Matthews</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Pleszkun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th annual international symposium on Microarchitecture</title>
		<meeting>the 28th annual international symposium on Microarchitecture</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="93" to="103" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Leakage energy management in cache hierarchies</title>
		<author>
			<persName><forename type="first">L</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Kadayif</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-F</forename><surname>Tsai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Vijaykrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kandemir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Irwin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sivasubramaniam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Parallel Architectures and Compilation Techniques</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2002">2002. 2002. 2002</date>
			<biblScope unit="page" from="131" to="140" />
		</imprint>
	</monogr>
	<note type="report_type">Proceedings</note>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Enhancing last-level cache performance by block bypassing and early miss determination</title>
		<author>
			<persName><forename type="first">H</forename><surname>Dybdahl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Stenstr?m</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Asia-Pacific Conference on Advances in Computer Systems Architecture</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="52" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">A novel approach to cache block reuse predictions</title>
		<author>
			<persName><forename type="first">J</forename><surname>Jalminger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Stenstrom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings. 2003 International Conference on</title>
		<meeting>2003 International Conference on</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2003">2003. 2003</date>
			<biblScope unit="page" from="294" to="302" />
		</imprint>
	</monogr>
	<note>Parallel Processing</note>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Iatac: a smart predictor to turn-off l2 cache lines</title>
		<author>
			<persName><forename type="first">J</forename><surname>Abella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gonz?lez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Vera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>O'boyle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Architecture and Code Optimization (TACO)</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="55" to="77" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Cache decay: Exploiting generational behavior to reduce cache leakage power</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kaxiras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Martonosi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Computer Architecture</title>
		<meeting>the International Symposium on Computer Architecture<address><addrLine>Los Alamitos, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page">240</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Selective, accurate, and timely self-invalidation using last-touch prediction</title>
		<author>
			<persName><forename type="first">A.-C</forename><surname>Lai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Falsafi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Computer Architecture</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="139" to="148" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Dynamic selfinvalidation: Reducing coherence overhead in sharedmemory multiprocessors</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Lebeck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="48" to="59" />
			<date type="published" when="1995">1995</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Memory coherence activity prediction in commercial workloads</title>
		<author>
			<persName><forename type="first">S</forename><surname>Somogyi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Wenisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Hardavellas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ailamaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Falsafi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WMPI &apos;04: Proceedings of the 3rd workshop on Memory performance issues</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="37" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Cooperative caching with keep-me and evictme</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Sartor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Venkiteswaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Mckinley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Interaction between Compilers and Computer Architectures, 2005. INTERACT-9. 9th Annual Workshop on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="46" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Using the compiler to improve cache replacement decisions</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Mckinley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Rosenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">C</forename><surname>Weems</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Parallel Architectures and Compilation Techniques</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2002">2002. 2002</date>
			<biblScope unit="page" from="199" to="208" />
		</imprint>
	</monogr>
	<note>Proceedings. 2002 International Conference on</note>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Merging path and gshare indexing in perceptron branch prediction</title>
		<author>
			<persName><forename type="first">D</forename><surname>Tarjan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Skadron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Archit. Code Optim</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="280" to="300" />
			<date type="published" when="2005-09">September 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<title level="m" type="main">Combining branch predictors</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mcfarling</surname></persName>
		</author>
		<idno>TN-36</idno>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
		<respStmt>
			<orgName>Digital Western Research Laboratory</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>tech. rep.</note>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Fast path-based neural branch prediction</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Jim?nez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO-36)</title>
		<meeting>the 36th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO-36)</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2003-12">December 2003</date>
			<biblScope unit="page" from="243" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Dynamic branch prediction with perceptrons</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Jim?nez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th International Symposium on High Performance Computer Architecture (HPCA-7)</title>
		<meeting>the 7th International Symposium on High Performance Computer Architecture (HPCA-7)</meeting>
		<imprint>
			<date type="published" when="2001-01">January 2001</date>
			<biblScope unit="page" from="197" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Samsung&apos;s exynos-m1 cpu</title>
		<author>
			<persName><forename type="first">B</forename><surname>Burgess</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hot Chips: A Symposium on High Performance Chips</title>
		<imprint>
			<date type="published" when="2016-08">August 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Sparc t4: A dynamically threaded server-on-a-chip</title>
		<author>
			<persName><forename type="first">M</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Golla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Grohoski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Jordan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Barreh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Brooks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Greenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Levinsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Luttrell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Olson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Samoail</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Smittle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ziaja</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="8" to="19" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<monogr>
		<title level="m" type="main">neural network&apos; spotted deep inside samsung&apos;s galaxy s7 silicon brain</title>
		<author>
			<persName><forename type="first">C</forename><surname>Williams</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016-08">August 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Reducing branch costs via branch alignment</title>
		<author>
			<persName><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Grunwald</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Notices</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="242" to="251" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Branch prediction strategies and branch target buffer design</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">K</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE computer</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="6" to="22" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">A study of branch prediction strategies</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th annual symposium on Computer Architecture</title>
		<meeting>the 8th annual symposium on Computer Architecture</meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1981">1981</date>
			<biblScope unit="page" from="135" to="148" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">An analysis of instructionfetching strategies in pipelined computers</title>
		<author>
			<persName><forename type="first">R</forename><surname>Holgate</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">N</forename><surname>Ibbett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="325" to="329" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Method and apparatus for implementing a setassociative branch target buffer</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">D</forename><surname>Hoyt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Hinton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Papworth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Fetterman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Natarajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenoy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">V</forename><surname>D'sa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">US Patent</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page">871</biblScope>
			<date type="published" when="1996-11-12">November 12 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Branch target buffer for dynamically predicting branch instruction outcomes using a predicted branch history</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">D</forename><surname>Hoyt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Hinton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">F</forename><surname>Glew</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Natarajan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">US Patent</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="1996-12-10">December 10 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Partial resolution in branch target buffers</title>
		<author>
			<persName><forename type="first">B</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Russell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th Annual International Symposium on</title>
		<editor>
			<persName><surname>Microarchitecture</surname></persName>
		</editor>
		<meeting>the 28th Annual International Symposium on</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1995">1995. 1995</date>
			<biblScope unit="page" from="193" to="198" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">A cost-effective branch target buffer with a two-level table organization</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kobayashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yamada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ando</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Shimada</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd International Symposium of Low-Power and High-Speed Chips (COOL Chips II)</title>
		<meeting>the 2nd International Symposium of Low-Power and High-Speed Chips (COOL Chips II)</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Two level bulk preload branch prediction</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bonanno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Collura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lipetz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Mayer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Prasky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Saporito</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">High Performance Computer Architecture (HPCA2013)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2013">2013. 2013</date>
			<biblScope unit="page" from="71" to="82" />
		</imprint>
	</monogr>
	<note>IEEE 19th International Symposium on</note>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Phantom-btb: a virtualized branch target buffer design</title>
		<author>
			<persName><forename type="first">I</forename><surname>Burcea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moshovos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Acm Sigplan Notices</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page" from="313" to="324" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Boomerang: A metadata-free architecture for control flow delivery</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-C</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Grot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Nagarajan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">High Performance Computer Architecture (HPCA), 2017 IEEE International Symposium on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="493" to="504" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">Cache bursts: A new approach for eliminating dead blocks and increasing cache efficiency</title>
		<author>
			<persName><forename type="first">H</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ferdman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Huh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Burger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 41st Annual IEEE/ACM International Symposium on Microarchitecture</title>
		<meeting>the 41st Annual IEEE/ACM International Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="222" to="232" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<monogr>
		<title level="m" type="main">An optimized 2bcgskew branch predictor</title>
		<author>
			<persName><forename type="first">A</forename><surname>Seznec</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">The impact of delay on the design of branch predictors</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Jim?nez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Keckler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd Annual International Symposium on Microarchitecture (MICRO-33)</title>
		<meeting>the 33rd Annual International Symposium on Microarchitecture (MICRO-33)</meeting>
		<imprint>
			<date type="published" when="2000-12">December 2000</date>
			<biblScope unit="page" from="67" to="76" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Speculative updates of local and global branch history: A quantitative analysis</title>
		<author>
			<persName><forename type="first">K</forename><surname>Skadron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Martonosi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Clark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Instruction-Level Parallelism</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<date type="published" when="2000-01">January 2000</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
