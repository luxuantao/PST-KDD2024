<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Testing an Optimising Compiler by Generating Random Lambda Terms</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Michał</forename><forename type="middle">H</forename><surname>Pałka</surname></persName>
							<email>michal.palka@chalmers.se</email>
							<affiliation key="aff0">
								<orgName type="institution">Chalmers University of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Koen</forename><surname>Claessen</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Chalmers University of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alejandro</forename><surname>Russo</surname></persName>
							<email>russo@chalmers.se</email>
							<affiliation key="aff0">
								<orgName type="institution">Chalmers University of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">John</forename><surname>Hughes</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Chalmers University of Technology</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Testing an Optimising Compiler by Generating Random Lambda Terms</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">5E803EF5F4861331A812D2747B610094</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:30+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D</term>
					<term>1</term>
					<term>1 [Programming Techniques]: Applicative (Functional) Programming; D</term>
					<term>2</term>
					<term>5 [Software Engineering]: Testing and Debugging-Testing tools Software Testing, Random Testing</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper considers random testing of a compiler, using randomly generated programs as inputs, and comparing their behaviour with and without optimisation. Since the generated programs must compile, then we need to take into account syntax, scope rules, and type checking during our random generation. Doing so, while attaining a good distribution of test data, proves surprisingly subtle; the main contribution of this paper is a workable solution to this problem. We used it to generate typed functions on lists, which we compiled using the Glasgow Haskell compiler, a mature production quality Haskell compiler. After around 20,000 tests we triggered an optimiser failure, and automatically simplified it to a program with just a few constructs.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Testing a compiler traditionally relies on running it on a suite of hand-written test programs. This approach is problematic for two reasons. Firstly, because collecting a large number of suitable programs is difficult and such programs rarely cover all interesting cases of code <ref type="bibr" target="#b7">[7,</ref><ref type="bibr" target="#b10">10]</ref>. Secondly, because the compiler is tested against the same set of programs over and over again, which means that if a bug is not triggered by any of them, then it will never be found. Using random property-based testing is an alternative that could remedy both of these problems. However, this alternative requires automatic generation of test programs.</p><p>Generating good test programs is not an easy task, since these programs should have a structure that is accepted by the compiler. As compilers often employ multi-stage processing before producing compiled code, in order to test later stages, earlier ones must be completed without error. The requirements for passing a compilation stage can be as basic as a program having the correct syntax, or more complex such as a program being type-correct in a statically-typed programming language.</p><p>In this paper, we study the problem of generating random, type-correct programs. We chose a simple, yet rich, statically typed programming language, namely the simplytyped lambda calculus <ref type="bibr" target="#b13">[13]</ref>. The lambda calculus (λ-calculus) is very simple -it basically only contains anonymous functions, a feature found in many contemporary programming languages, such as Haskell, Scheme, Python, C , Visual Basic, and so on. However, the λ-calculus still captures the two main aspects that makes generating random programs hard: variable binding and type-correctness. While it is quite easy to ensure that generated programs only refer to variables in scope, we found that satisfying the type-checker is much more subtle, and this is the main focus of this paper.</p><p>Note that, even when testing compilers for dynamicallytyped languages, it makes sense to use statically type-correct programs, since these programs are far more likely to be runnable without crashing immediately.</p><p>For our experiments, we have chosen an industrial-strength compiler that accepts expressions from λ-calculus directly, namely the Glasgow Haskell compiler <ref type="bibr" target="#b15">[15]</ref> (GHC). This compiler contains a powerful optimiser, which consists of numerous complex transformations operating on the GHC's intermediate Core language, such as inlining, let-floating, lambda lifting, specialisation and common subexpression elimination <ref type="bibr" target="#b12">[12]</ref>. Such elaborate processing could easily be a source of intricate bugs, making it interesting to test.</p><p>The compiler was tested by compiling randomly generated functions with different optimisation settings and comparing the behaviour of resulting programs under the assertion that optimisation should not change the meaning of the program. These tests revealed actual failures in the compiler.</p><p>The remainder of the paper is structured as follows. In the next section we explain the simply-typed λ-calculus, the language we target. In section 3, we explain our basic approach to random generation. Section 4 makes an important extension to type polymorphism, essential to generating interesting Haskell programs. Section 5 describes the generation algorithm in detail, including optimisations to reduce the need for search. Section 6 presents the results of our </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">LANGUAGE</head><p>The formal language that we choose to develop our ideas is essentially the simply-typed λ-calculus <ref type="bibr" target="#b13">[13]</ref> extended with constants and basic types. The calculus allows programs to define and manipulate variables and functions. Specifically, programs are constructed from four different kinds of terms: variables (x), constants (c), function applications, and anonymous functions. Terms of the form λx : σ. M , referred to as lambda expressions (λ-expressions), represent functions with argument x of type σ and body M . Types are discussed in the next section; they include, for example, traditional built-in types denoting integers or strings. Terms of the shape M N represent application of functions, i.e. the first term M , which is a function, is given the second term N as an argument. Originally a feature of functional programming languages such as LISP, Scheme and Haskell, λexpressions are now found in many contemporary programming languages, including Python, Ruby, JavaScript, C , Visual Basic, and Visual C++.</p><p>Although minimalistic, simply-typed λ-calculus can represent a wide range of programs. For example, there are no infix operators, but they can be represented as constant functions. λ-expressions define functions taking a single argument, but multi-argument functions can be represented as functions returning functions. Thus 2 × 3 is represented as (* 2) 3, where (* 2) is the constant function * applied to 2, returning a function of one remaining argument (3) that doubles it, returning 6. Correspondingly, multi-argument functions are defined using nested λs; the C function int f (int x, int y) return 2 * x + y; can be represented by the λ-expression f = λx : Int.λy : Int.+ (* 2 x) y Function application brackets to the left, so (* 2 x) just means ((* 2) x), as above. The variables x and y in the function body of f are said to be bound by the λ-expressions; variables which are not bound are said to be free. For simplicity, we consider constants such as +, * and 2 to be free variables defined in a scope enclosing the entire program. Figure <ref type="figure" target="#fig_0">1</ref> shows the formal syntax of the simply-typed λ-calculus.</p><p>In simply-typed λ-calculus, variables and expressions have only base or function types. A base type can be, for instance, Int or Bool. Function types, on the other hand, are of the shape σ → τ , representing a function which takes a value of type σ as argument and returns a value of type τ as result.</p><p>Observe that σ and τ can be any type-functions can take functions as arguments, and return them as results.</p><p>Functions taking many arguments are represented by functions whose result type is a functional type. For example, the function *, shown above, has type Int → (Int → Int), i.e. a function that, after being applied to an argument of type Int, returns a function that can be applied again to another Int in order to return their product. It is common to treat → as a right-associative operator and thus write Int → Int → Int instead.</p><p>In addition to syntactic restrictions, terms must be well- x : σ ∈ Γ Γ x : σ</p><formula xml:id="formula_0">(Lam) x : σ, Γ M : τ Γ λx : σ.M : σ → τ (App) Γ M : σ → τ Γ N : σ Γ M N : τ Figure 2:</formula><p>Typing rules typed, i.e. functions must only be applied to correctly typed arguments. For instance, the function * must be applied to arguments of type Int, i.e. numbers, and not to arguments of type Bool. Well-typed terms are defined using assertions of the form Γ M : σ (typing judgements), meaning that term M has type σ provided that the types of free variables in M are as specified in Γ. The environment Γ is just a list of elements of the form x : σ (c : σ), indicating that variable x (constant c) has type σ. Figure <ref type="figure">2</ref> formally describes Γ.</p><p>The rules defining valid typing judgements are shown in Figure <ref type="figure">2</ref>. These rules have zero or more premises placed above a horizontal bar, with their consequence below it. The rule (Var) indicates that x has type σ (Γ x : σ) if x is associated with σ in Γ (x : σ ∈ Γ). Rule (Lam) is used for typing functions. To determine that a function takes an argument of type σ and returns a result of type τ (Γ λx : σ.M : σ → τ ), the rule requires that the body of the function has type τ (x : σ, Γ M : τ ) when the argument of the function is assumed to have type σ; this assumption is captured by the expression x : σ, Γ. Rule (App) makes sure that the function's actual argument (N ) has a type matching the one in the function's type, i.e. σ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">RANDOM LAMBDA-TERMS</head><p>The typing rules suggest a straightforward generation procedure for well-typed terms. Each typing rule can be interpreted as a generation rule by reading it backwards. To generate a term that is in the consequence of a rule, it is firstly necessary to generate terms that are in its premises. Our procedure is goal-oriented and has as input the target type, which is the type that generated terms will have, and an environment containing all variables and constants that can be used in the terms.</p><p>Depending on the target type, a subset of the typing rules may be applicable. For example, the (Lam) rule is only applicable when the target type is a function type. The (Var) rule is only applicable when the environment contains a variable or a constant of the given target type.</p><p>The following example illustrates how generation works. Suppose that we have to generate a term of type Int and that two constants are available in the initial environment Γ, representing the number zero and the successor function.</p><formula xml:id="formula_1">Γ = {zero : Int, succ : Int → Int}</formula><p>We start off with the initial environment Γ and the target type, whereas the term that we want to generate, which is as yet unknown, is denoted by a placeholder ?.</p><formula xml:id="formula_2">Γ ? : Int<label>(1)</label></formula><p>Both the (Var) rule, using constant zero, and the (App) rule can be applied at this point to obtain a term of type Int.</p><p>Choosing the former immediately terminates the generation, since a variable has no subterms, and the generated term would be complete. Choosing the latter, on the other hand, requires generating two subterms, i.e. a function returning an Int and its argument. Type σ in the (App) rule is neither determined by the environment nor by the target type and, as a consequence, can be freely chosen. We arbitrarily decide to select the (App) rule and to fix the σ type to Int. Since both σ and τ from the (App) rule are determined to be Int, to finish the generation it is necessary to generate two subterms, denoted by ?1 and ?2, with the following types.</p><formula xml:id="formula_3">Γ ?1 : Int → Int Γ ?2 : Int</formula><p>To generate the first subterm, any of the three rules might be used. In particular, the (Lam) rule is permitted by the fact that Int → Int is a functional type. Nevertheless, we opt for the simple alternative of using the (Var) rule and therefore ?1 is replaced by succ.</p><formula xml:id="formula_4">Γ succ : Int → Int</formula><p>To generate ?2, we choose simply to use the constant zero from the environment exercising the (Var) rule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Γ zero : Int</head><p>Observe that the term ?2 is generated under the same environment and the target type as the main term ? from equation 1, which means that the generator could proceed in exactly the same ways here as at that point.</p><p>To finish the generation, our procedure constructs the main term from equation ? = ?1 ?2, since the (App) rule was invoked in the first step, which gives us the final term.</p><p>Γ succ zero : Int</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Naïve Approach</head><p>The generation procedure derived from the typing rules is non-deterministic in that more than one rule may be applicable at any given point, and a single rule may be applied in many different ways. Thus, in order to implement the procedure, we must supply a way of choosing the rule to apply whenever this ambiguity occurs. Unfortunately, not all choices are equally good and some of them might lead to a dead end or to non-terminating generation. A simple remedy is to impose a size limit on generated terms and allow the procedure to backtrack and choose another option whenever it goes astray.</p><p>Once the size limit and backtracking are in place, we can choose any strategy for selecting the rule to apply without compromising the strength of the generator, since it will be able to backtrack from any bad choice. Therefore, it is reasonable to adopt a very simple strategy of choosing the rules at random.</p><p>Although this simple approach is capable of generating every well-typed term smaller than a given size limit, it has a serious shortcoming. Whenever the (App) rule is used, the type of the argument is neither determined by the target type nor the environment, and thus any type can appear there. This yields too many possibilities even if the size of types could be restricted.</p><p>A bad choice at this point can be a serious problem, as often only a very specific choice of types will allow the search to progress. For example, suppose that the target type is Int and the constant f : String → Bool → Int is available. Constant f might be used to construct the required term by applying it to two arguments, of types String and Bool respectively. However, for that to happen, the (App) rule must be invoked twice, and the argument types guessed to be Bool and String respectively at the two invocations. Unfortunately, guessing these types correctly is very unlikely to occur, and on average, a large number of backtracking steps will be needed. This makes the generation of terms very inefficient, and moreover, hard-to-guess terms (like this one) will occur very rarely in the results of the generator.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Refined Approach</head><p>In order to address the problem of guessing argument types, we introduce another typing rule (inspired by the proof synthesis method from <ref type="bibr" target="#b18">[18]</ref>).</p><formula xml:id="formula_5">f : . . . , Γ M1 : σ1 • • • f : . . . , Γ Mn : σn (Indir) f : σ1 → . . . → σn → τ, Γ f M1 . . . Mn : τ</formula><p>This rule is logically unnecessary, as it follows from the other typing rules, but as a generation rule it is far superior to the (App) rule. It creates a term that is a variable (or constant) from the environment applied to a number of recursively generated argument terms. What is important here is that even though the resulting term contains a number of term applications, no types have to be guessed as they are determined by the type of the function. Since no guessing is involved, the search is no longer so erratic and generation is much more efficient. However, if we were to replace the (App) rule by this one, then we would no longer be able to generate all λ-terms-in particular, terms such as (λx : Int.x) 1, in which a λ-expression is applied directly, could no longer be generated. Therefore, we choose to keep both rules just to make it possible to generate λ-expressions that are directly applied to arguments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">POLYMORPHISM</head><p>Parametric polymorphism refers to the use of the same code at several different types. First introduced by Damas and Milner in ML <ref type="bibr" target="#b4">[4]</ref>, it has become a standard feature of functional languages such as Miranda and Haskell, and is now also found in mainstream languages via, for example, Java generics <ref type="bibr" target="#b19">[19]</ref>. Opportunities for polymorphism arise when the same underlying term can be typed in several different ways. For instance, the identity function λx : ?.x, which takes an argument and returns it, can be assigned either of the types Int → Int or Bool → Bool choice of ?. Rather than use question marks as types, we introduce type variables α, β, . . . , and say that λx : α.x has the type α → α for any type α, where α might take the value Int, Bool, or any other type. To express the fact that α can be arbitrarily chosen, we assign to the identity function the type ∀α. α → α, a polymorphic type where ∀α. indicates the changing type variable.</p><p>Polymorphism is heavily used in conjunction with parametrised datatypes. For example, let List α be the type of lists with elements of type α. Two useful functions on lists are head, which returns the first element of the list, and tail, which returns all the elements except for the first one. The types of these functions are naturally polymorphic:</p><formula xml:id="formula_6">head : ∀α.List α → α tail : ∀α.List α → List α</formula><p>When these functions are used, then α may be instantiated to any type, allowing the same code to manipulate lists with any type of element. Figure <ref type="figure" target="#fig_1">3</ref> shows the formal syntax for a simple polymorphic λ-calculus. The syntax for terms is exactly the same as for simply-typed λ-calculus (see Figure <ref type="figure" target="#fig_0">1</ref>). The only changes are to the syntax for types, where we introduce type variables (α) and polymorphic lists (List α).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Generation of Terms</head><p>The approach described in Section 3 generates terms with monomorphic types such as Int, Bool, and Int → Int, i.e. types that do not involve type variables. In this paper, we only consider generating terms with monomorphic types. However, we allow the use of polymorphic constants, such as head and tail, in the terms we generate. This allows us to generate programs that make use of Haskell's list-processing library functions.</p><p>Generation of random terms using polymorphic constants introduces the problem of instantiating a polymorphic type to a monomorphic one when the constant is used. In some cases, instantiating a polymorphic type is straightforward. For example, suppose that we want to generate a term of type List Int, and we have available an environment Γ containing the constants lst : List Int, and tail : ∀α.List α → List α. Clearly, if we choose to generate a call of tail with type List Int, then we must instantiate α to Int, and generate an argument which also has the type List Int. We could now choose lst : List Int to be the argument, and generate the term tail lst.</p><p>However, suppose the environment contains the constants</p><formula xml:id="formula_7">map : ∀αβ.(α → β) → List α → List β lst : List Int lst2 : List Bool</formula><p>where map f l returns the list of type List β obtained by applying the function f , of type α → β, to every element of the list l, of type List α. If we choose to generate a term of type List Int which is a call of map, then as subgoals we must generate an f of type α → Int and an l of type List α-but α is not determined, and can be chosen freely. This leads to similar problems to those described in Section 3.1 with the rule (App). In this particular example, α can be chosen to be at least Int or Bool, since we have a list of integers (lst : Int) and booleans (lst2 : Bool) in the context, but in general the choice of α is difficult.</p><p>In fact, the problem of instantiating polymorphic functions is a generalisation of the problem of instantiating the (App) rule. To see this, it is enough to make rule (App) redundant by introducing a polymorphic constant app : ∀αβ.(α → β) → α → β that, when used in the (Indir) rule, generates the same subterms as rule (App).</p><p>We adopted a simple solution to this problem, which is crude, but reasonably effective. Instead of instantiating undetermined type variables with any possible type, we use a method for randomly generating types that avoids those for which it is impossible to construct a term. Firstly, a set of types is constructed, which initially consists of the types from the environment. Then, further types are added to the set using the rule that if both a functional type and its argument type are present, then we can also add the type of the function's result. This set is then used to generate random types either by selecting them directly or by creating a functional type based on them when instantiating. Since polymorphic types can also be present in the environment, this procedure sometimes involves specialising them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">GENERATION ALGORITHM</head><p>We describe the generation algorithm informally to avoid overwhelming formal notation. It works by applying generation rules, which build successive parts of the generated terms, and by backtracking when generation reaches a dead end. The basic structure of the algorithm is as follows:</p><p>• A list of generation rules that are applicable is constructed based on the target type and the symbols contained in the environment. If one rule can be applied in several different ways, for instance, with different symbols from the environment, then it is represented several times in the list.</p><p>• The list of rule applications is then randomly shuffled and the first one from the randomised list is applied.</p><p>• The generation procedure is invoked recursively for the premises of the selected rule.</p><p>• If all the recursive calls finish with success, all required subterms are available and the term is constructed according to the rule.</p><p>• If generating any of the premises fails, then the generator backtracks and the next rule from the list is selected instead.</p><p>• If all rules have been tried without success, then the generation fails. Thus, the generator first tries to exhaust all possibilities for constructing subterms required by a generation rule, before deciding to select another one-the search is depth-first.</p><p>An awkward special case arises when applying the (Indir) rule to a function whose result type is just a type variable-for example, the identity function id : ∀α.α → α. By instantiating α to a function type with n arguments, we can apply (Indir) to generate a call of id with n + 1 arguments, for any n, and whatever the target type! For instance, if the target type is Int, then we can instantiate α to String → Bool → Int and generate a call id F S B, where subgoal F must have type String → Bool → Int, S must have type String, and B must have type Bool. There are thus infinitely many ways to apply the (Indir) rule to such a function. To remove the possibility of infinite backtracking we only allow the (Indir) rule to consider at most three extra parameters. This trade-off prevents the (Indir) rule from generating some terms, however they can still be generated using the (App) rule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Optimisations</head><p>Sometimes we reduce backtracking by omitting rule applications which we know will fail. For example, when the (Indir) rule using one symbol fails, we can conclude that it will also fail with any other symbol of the same type, as the premises for the rule application are the same. Therefore, the generation algorithm considers one version of the (Indir) rule for each unique type present in the environment, and the exact symbol is chosen at random afterwards.</p><p>We also prioritise rule applications to speed up generation and reduce backtracking. Rules with higher weights have a higher chance of being selected before others. We use weights to first try rules that have a high chance of success, using other rules only occasionally, or when the preferred ones fail. In particular, applying rules which involve guessing types usually has a low probability of success-but is necessary sometimes to produce certain terms.</p><p>Even rule prioritisation is not always enough to prevent massive backtracking, we also limit the number of 'dangerous' rules-the ones involving guessing types-that can be applied recursively. Undoubtedly, this rules out the generation of some complex terms, but we still generate enough interesting terms to find compiler failures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Distribution</head><p>The distribution of generated terms is ad-hoc, but produces an acceptable rate of terms that trigger failures-we have tweaked it to achieve good results in our own testing. Weights assigned to rules are respectively 4 for rules that use locally-bound variables, 2 for rules that introduce constants, 8 for the rules for introducing an application or a λ-expression, and 6 for the seq rule.</p><p>It is unclear what the "best" distribution would be. There is no reason to believe, for example, that a uniform distribution over terms of a specific size would be more effective at revealing bugs, and it might well be less so. In any case, we do not have the goal to approximate "programs that could be written by real programmers", because how well the generated terms correspond to this notion is hard to determine. So, we are pragmatic, and consider that success in finding bugs is the most important measure of a good distribution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">TESTING GHC</head><p>We use the generation of random λ-terms described in Section 3 and 4 to test the Glasgow Haskell Compiler <ref type="bibr" target="#b15">[15]</ref> (GHC). Haskell is a purely functional programming language with lazy evaluation-expressions are by default compiled as closures, and their evaluation delayed until the value is actually required. GHC is the most popular and complex Haskell compiler-its main part consists of approximately 120,000 lines of code. Part of its complexity comes from an elaborate code optimiser. The optimiser transforms code in many stages, one of which is the strictness analyser <ref type="bibr" target="#b12">[12]</ref>, which identifies expressions whose value is always required eventually, and which can therefore be compiled for immediate evaluation (avoiding the costly closure mechanism) without changing the semantics of the program. Since Haskell is purely functional, changing the order of evaluation in this way does not change the program semantics.</p><p>Determining whether code has been compiled by the compiler correctly is, of course, difficult since the semantics of Haskell is complex. However, one way to check the correctness of optimised code is to compare it to the unoptimised version. Optimisations should only make programs more efficient without changing their semantics. Establishing program equivalence cannot be done automatically in general, since the input domain of many programs is infinite, but we can demonstrate that programs are not equivalent just by finding one random input on which their output differs.</p><p>More formally, it should be the case that ∀x ∈ dom f : f ghc -O1 (x) = f ghc (x) where f is a Haskell program, f ghc -O1 and f ghc represents the optimised and unoptimised compiled version of f , respectively. If this equation does not hold for a program f and an input x, then optimisations are changing the semantics of the program. The techniques described in Section 3 and 4 can provide us with several f and x where the equation above does not hold, thus showing that GHC is buggy. Although Sections 3 and 4 present techniques to generate random programs in a very simple setting, i.e. simple-typed λ-calculus, our approach detects failures in such a complex piece of code as GHC in just a few minutes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Correctness of the Strictness Analyser</head><p>To evaluate the correctness of the strictness analyser, we decided to test compilation of functions that operate on lazy data structures, i.e. data structures with elements or components which are computed on demand. In particular, we focus on testing Haskell programs manipulating lazy lists. Such lists can contain "undefined" components, represented as closures of expressions, that raise an exception when evaluated. A function operating on lists can receive such a partially-defined list as an argument, and still yield a result, as long as it does not inspect the parts of the list that are undefined. For example, in Haskell, a function that returns the second element of a list can be successfully applied to lists of length two even if the first element is undefined.</p><p>We automatically generate random lambda terms of type List Int → List Int to test GHC's strictness analyser. Programs are compiled with GHC's optimisations turned on and off, respectively. Both compiled versions are then run with a number of simple partially-defined lists as input in order to compare their outputs. Since the results of the compiled functions are also lazy lists, instead of just yielding a result or failing completely, most commonly the functions yield a partially-defined result. Clearly, if two functions are equivalent, they should yield the same partially-defined result when applied to the same partially-defined argument.</p><p>To compare partially-defined lists, we traverse each list from left to right, printing its value on the output. We then compare lists by comparing the generated output. For example, a list containing the numbers from 0 to 4 is printed as [0, <ref type="bibr" target="#b1">1,</ref><ref type="bibr" target="#b2">2,</ref><ref type="bibr" target="#b3">3,</ref><ref type="bibr" target="#b4">4]</ref>. Square brackets and commas are the Haskell notation for lists. In contrast, if we encounter an undefined value, then the list is printed as [0,1,2,3,*** Exception:, where *** Exception: is appended by an exception handler. Note that this approach does not guarantee to distinguish different partially-defined lists, but it works well enough for our purposes, even though more accurate methods are available <ref type="bibr" target="#b6">[6]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Generating Random Haskell Functions</head><p>To generate random functions on lists, we gave our generation algorithm an initial environment containing list operations, functions from the standard Prelude module (e.g. (+), (-), (&amp;&amp;), (||), map, length, and filter) and constant values (e.g. 0, 1, True, and False). Having such a rich initial environment increases the possibility of generating interesting terms.</p><p>Haskell provides programmers with a way to control lazy evaluation, via the built-in operation seq which forces the evaluation of terms. This operation takes two arguments and forces the evaluation of the first one before returning the second. We wanted to test whether GHC's strictness analyser accounts for this behaviour correctly.</p><p>The type of seq is ∀αβ.α → β → β. Observe that the type of the first argument is completely unrelated to the second one. We could just include function seq in the initial environment like any other function, but because its type is so general, doing so leads to overuse of seq in the generated terms-a call of seq can be inserted anywhere, with any value as first argument. We therefore used a custom generation rule that restricts the first argument of seq to be a local variable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Testing Environment</head><p>Testing was performed on GHC version 6.12.1 configured for x86-64 systems, running on a modern laptop<ref type="foot" target="#foot_0">1</ref> . Because starting the compiler is quite costly, at around 0.5 s, we placed 1,000 generated functions in each module, thus amortising this cost across a large number of tests. The choice of the number 1,000 roughly balances compilation time with the time spent on test case generation, yielding a total time of around 20 s for generation, compilation and testing of 1,000 terms. Using a larger number of terms in a module would not improve performance considerably.</p><p>The generated modules invoke the generated functions on about 20 simple partially-defined lists, and print the results. The small set of test data is sufficient, as even two partiallydefined lists are enough to uncover most compiler failures that were found. Each generated module was compiled with the default optimisation level (compiler flag -O1) and with no optimisation (compiler flag -O0), the compiled code was executed, and the outputs were compared.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Results</head><p>We limited the size of generated functions to a maximum of 70 function applications or λ-expressions per generated term. After generating and testing around 20,000 random terms of type List Int → List Int, which took around 15 minutes, a failure in GHC's strictness analyser was found. The random functions exposing failures in GHC consisted of terms of size between 30 and 50. These functions were then automatically simplified by a procedure known as shrinking (see next section), roughly halving their sizes. After this simplification phase, the functions that triggered the compiler failure are the following ones 2 (in Haskell syntax): (Note the first parameter of seq is not always a variable in these examples-this is a result of the shrinking process). We illustrate the failure using the first test case above. The expected behaviour of that function is to raise an exception immediately, on application to any argument. The term should be equivalent to seq (undefined :: Int), which forces the evaluation of an undefined value before proceeding with any other computation. However, this behaviour is  We can see in Table <ref type="table" target="#tab_1">1</ref> that the function behaves as expected when compiled without optimisations (column -O0). However, if the same function is compiled with optimisations (column -O1), the function returns a partially-defined list instead of directly raising an exception. In fact, the function returns a list which is equal to its argument (column Argument).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Shrinking</head><p>The randomly generated functions that provoke failures are typically too big to be comfortably read and understood. Clearly, it is desirable to find smaller functions that show the presence of bugs. Fortunately, it is likely that not all parts of a randomly generated function are needed to reveal a bug, and that smaller, similar terms provoke the same bugs. With this in mind, we establish a phase of shrinking <ref type="bibr" target="#b3">[3]</ref> for failing test cases. This phase consists of creating a number of smaller variants of bug-triggering functions. These variants are then tested to determine if they trigger the same failure. If that is the case, we repeat the shrinking process to search for an even smaller term that results in a failure. Shrinking finishes when a minimal test case is found that provokes a failure, which might (or not) be caused by the original bug.</p><p>In this case, shrinking is done using three simple rules. Firstly, a sub-term can be replaced by any of its sub-terms as long as variable bindings and its type are preserved. Secondly, a subterm, that is not a constant, can be replaced by any constant of the same type. And thirdly, an application of a λ-expression (λx.M ) N can be replaced by the body M , with x replaced by the actual parameter N -a β-reduction. In simply-typed λ-calculus, β-reductions cannot continue indefinitely, so the shrinking process always terminates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">RELATED WORK</head><p>Random testing used for finding bugs in compilers and programming language tools has received some attention in recent years. Lindig <ref type="bibr" target="#b10">[10]</ref> created a tool for testing the C function calling convention of the GCC compiler. This tool randomly generates only the types of functions; their bodies just checked that the parameters were received correctly.</p><p>Wrangler, a refactoring tool for Erlang has also been tested using random program generation <ref type="bibr" target="#b7">[7]</ref>. A rich program generator has been created, which is capable of generating full modules. Even though Erlang is an untyped language, the generator takes types into consideration in order to avoid argument mismatches when calling functions. Similarly, Daniel et al. <ref type="bibr" target="#b5">[5]</ref> exhaustively generate Java programs (up to certain size) in order to test the refactoring engines in Eclipse and NetBeans. Different from our approach, some of the generates programs are not valid inputs for the Java compiler.</p><p>Probably the work related most closely to ours is Klein et al. <ref type="bibr">[9]</ref>, who generated random programs to test an objectoriented library, finding a large number of bugs. Their generator is capable of producing higher-order object-oriented programs (which override methods) and supports monitoring of pre-and post-conditions. Their generation method uses generation rules similar to ours, and backtracks occasionally just as ours does. Rather than our (Indir) rule, which generates calls of functions in the environment only when their result type matches the target type, they use a rule which can generate a call of any function in the environment at any time, binding its result to a fresh local variable, which can then in turn be used in another attempt to generate a term of the target type. In a sense, we generate terms top down, while they generate them bottom up. The advantage of their approach is that it is easier to generate calls of functions in the environment-the disadvantage is that many of the local variables they create are never used, because their types do not match the target type. <ref type="bibr">Klein</ref>  Vytiniotis and Kennedy <ref type="bibr" target="#b16">[16]</ref> present encoding of datatypes into streams of bits, which can be used for their random generation. In their approach to generate simply-typed λterms, the target type is never fixed, and thus the generation never fails, eliminating the need for backtracking.</p><p>The λ-term enumerator developed by Yakushev and Jeuring <ref type="bibr" target="#b14">[14]</ref> creates function applications in the same way as our method, by generating a candidate type for the argument, and trying to generate the argument afterwards.</p><p>Djinn <ref type="bibr" target="#b1">[1]</ref> solves the type inhabitation problem for simplytyped λ-calculus, that is, it returns any term instead of a random one for a given type. It is based on a terminating proof procedure for intuitionistic propositional logic <ref type="bibr" target="#b8">[8]</ref>.</p><p>Statistical properties of random untyped λ-terms have been explored in <ref type="bibr" target="#b2">[2]</ref>, which also explores a method of generating them using Boltzmann sampling. Generation of random untyped λ-terms is tackled in <ref type="bibr" target="#b17">[17]</ref>, which employs counting of possible subterms to achieve uniform generation distribution. Correspondingly, the work in <ref type="bibr" target="#b11">[11]</ref> examines the proportion of simple types that are inhabited, that is, for which it is possible to create a term of that type.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUSIONS</head><p>Generating random and type correct programs for compiler testing is quite a difficult problem, because type correctness is a global property which must be achieved by a sequence of local choices. It is easy for a random generator to make a bad choice early on, painting itself into a corner in which generation cannot be completed at all, or can be completed only by generating very trivial programs (in which, for example, variables are defined but almost never used). We have presented a workable approach, in a simple setting-the simply-typed λ-calculus. In contrast to earlier work, we have considered type polymorphism, and shown that it introduces further complications for the generator.</p><p>We show the value of our approach by applying testing the optimiser of GHC finding surprising optimiser failures in a few minutes on an ordinary laptop. Moreover, the generator can be easily adapted to test other compilers by adding a term-printing function producing the syntax of the programming language and providing a suitable initial environment.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Syntax for simply-typed λ-calculus compiler testing using the generated λ-terms. Section 7 describes related work, and section 8 concludes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: A simple λ-calculus with polymorphism</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>seq (id (\a -&gt; seq a id) (undefined::Int)) seq (seq (\a -&gt; length) (\a -&gt; seq a seq) (head ([]::[] Bool))) seq (seq (\a -&gt; null) (\a -&gt; seq a (\b -&gt; length)) (head ([]::[] Bool)))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Exception: [1,*** Exception: [2,1,undefined] *** Exception: [2,1,*** Exception:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Outputs of a bug-triggering function not reflected by the code compiled with optimisations.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>et al. do not consider polymorphic types, nor do they shrink failing test cases to minimal examples as we do.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The machine had a</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>2.4 GHz Intel Core 2 CPU and 4 GB of RAM. 2 Readers can refer to http://www.cse.chalmers.se/~palka/ testingcompiler/ for further details</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Announcing Djinn, version 2004-12-11</title>
		<author>
			<persName><forename type="first">L</forename><surname>Augustsson</surname></persName>
		</author>
		<ptr target="http://permalink.gmane.org/gmane.comp.lang.haskell.general/12747" />
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Lambda terms of bounded unary height</title>
		<author>
			<persName><forename type="first">O</forename><surname>Bodini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gardy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Gittenberger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 8th Workshop on Analytic Algorithmics and Combinatorics</title>
		<meeting>of the 8th Workshop on Analytic Algorithmics and Combinatorics</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">QuickCheck: a lightweight tool for random testing of Haskell programs</title>
		<author>
			<persName><forename type="first">K</forename><surname>Claessen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hughes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the fifth ACM SIGPLAN International Conference on Functional Programming</title>
		<meeting>the fifth ACM SIGPLAN International Conference on Functional Programming</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Principal type-schemes for functional programs</title>
		<author>
			<persName><forename type="first">L</forename><surname>Damas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</title>
		<meeting>the 9th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Automated testing of refactoring engines</title>
		<author>
			<persName><forename type="first">B</forename><surname>Daniel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Garcia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Marinov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 6th meeting of the European Software Engineering Conference and the ACM SIGSOFT Symp. on the Foundations of Software Engineering</title>
		<meeting>of the 6th meeting of the European Software Engineering Conference and the ACM SIGSOFT Symp. on the Foundations of Software Engineering</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Chasing bottoms: A case study in program verification in the presence of partial and infinite values</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">A</forename><surname>Danielsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Jansson</surname></persName>
		</author>
		<editor>MPC</editor>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Quickchecking refactoring tools</title>
		<author>
			<persName><forename type="first">D</forename><surname>Drienyovszky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Horpácsi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Thompson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th ACM SIGPLAN workshop on Erlang</title>
		<meeting>the 9th ACM SIGPLAN workshop on Erlang</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Contraction-free sequent calculi for intuitionistic logic</title>
		<author>
			<persName><forename type="first">R</forename><surname>Dyckhoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Symbolic Logic</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Random testing for higher-order, stateful programs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Flatt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">B</forename><surname>Findler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the ACM International Conference on Object Oriented Programming Systems Languages and Applications</title>
		<meeting>of the ACM International Conference on Object Oriented Programming Systems Languages and Applications</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Random testing of C calling conventions</title>
		<author>
			<persName><forename type="first">C</forename><surname>Lindig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th International Symposium on Automated Analysis-Driven Debugging</title>
		<meeting>the 6th International Symposium on Automated Analysis-Driven Debugging</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Statistical properties of simple types</title>
		<author>
			<persName><forename type="first">M</forename><surname>Moczurad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tyszkiewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zaionc</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical. Structures in Computer Science</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<date type="published" when="2000-10">October 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Compiling Haskell by program transformation: a report from the trenches</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">L</forename><surname>Peyton</surname></persName>
		</author>
		<author>
			<persName><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of European Symp. on Programming</title>
		<meeting>of European Symp. on Programming</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Types and programming languages</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge, MA, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Enumerating well-typed terms generically</title>
		<author>
			<persName><forename type="first">A</forename><surname>Rodriguez Yakushev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jeuring</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Approaches and Applications of Inductive Programming</title>
		<meeting><address><addrLine>Berlin / Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">5812</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">Ghc</forename><surname>The</surname></persName>
		</author>
		<author>
			<persName><surname>Team</surname></persName>
		</author>
		<ptr target="http://haskell.org/ghc/" />
		<title level="m">The Glasgow Haskell Compiler. Software release</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Functional pearl: every bit counts</title>
		<author>
			<persName><forename type="first">D</forename><surname>Vytiniotis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Kennedy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th ACM SIGPLAN International Conference on Functional Programming</title>
		<meeting>the 15th ACM SIGPLAN International Conference on Functional Programming</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Generating random lambda calculus terms</title>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
		<respStmt>
			<orgName>Boston University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Mechanical procedure for proof construction via closed terms in typed λ calculus</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zaionc</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Autom. Reason</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="173" to="190" />
			<date type="published" when="1988-06">June 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Zakhour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hommel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Royal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Rabinovitch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Risser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hoeber</surname></persName>
		</author>
		<title level="m">The Java Tutorial: A Short Course on the Basics, 4th Edition</title>
		<imprint>
			<publisher>Prentice Hall PTR</publisher>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
